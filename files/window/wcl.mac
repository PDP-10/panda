	Title WCL -- Window Command Level

	SubTtl Table of contents

Comment \


Written by ...	Tad Marshall, American Express Co., March - November 1981


		Table of Contents	      Page(s)

\

	SubTtl Definitions

; Entry points ...
	Entry ComLvl, ClrBit, TypErr, Confrm, TypNam, NewWin, .Lock, .ULock

; Internal symbols ...
	Intern SbaFdb, CfmFdb, AllTab, CmdTab, IniFdb

; External subroutines required ...

	Extern GetSp2, GivSp2, GetXjf, GjfRes, PtyOut, DlsNam, DelSub
	Extern SetGjf, GetPtJ, PtyIni, WinIni, AcSave, AcLoad, EntVec
	Extern SetRes, DspPau, Tp1Rsk

	Extern HlpAcc, HlpBel, HlpCon, HlpDef, HlpDis, HlpExi, HlpSta
	Extern HlpKee, HlpKil, HlpLog, HlpPsh, HlpRed, HlpRef, HlpRPs
	Extern HlpTer, HlpSnd, HlpSil, HlpTak, HlpWht, HlpPrg, HlpBac
	Extern HlpMlt, HlpOne, HlpKey, HlpPf1, HlpPf2, HlpPf3, HlpPf4
	Extern HlpEnt, HlpCnL, HlpHlp, HlpBla, HlpCmd, HlpOrd, HlpRen
	Extern HlpRWi, HlpSho, HlpWin, HlpInf, HlpPau, HlpZer, HlpTra
	Extern HlpUpa, HlpDna, HlpLfa, HlpRta, HlpPer, HlpSex, HlpRex
	Extern HlpRdi, HlpDf,  HlpWai, HlpMrg, HlpPad, HlpDet

	Search WSym, MonSym, MacSym ; The symbols we need
	Sall			; Suppress macro expansions

	SubTtl WclLtb, WclCtb & WclCns -- Interrupt system tables

; Programmable Interrupt System

WclLtb:	Wcl1Pc			; Level 1
	Wcl2Pc			; Level 2
	Wcl3Pc			; Level 3

WclCtb:	3,, WclCon		; 0  -- Get interrupted by superior here
	0			; 1  -- Not used
	0			; 2  -- Not used
	0			; 3  -- Not used
	0			; 4  -- Not used
	0			; 5  -- Not used
	0			; 6  -- Arithmetic overflow, not used
	0			; 7  -- Floating point overflow, not used
	0			; 8  -- Reserved for DEC
	1,, WclPan		; 9  -- Pdl overflow
	0			; 10 -- End of file, not used
	1,, WclPan		; 11 -- Data error
	1,, WclPan		; 12 -- Disk full or quota exceeded
	0			; 13 -- Reserved for DEC
	0			; 14 -- Reserved for DEC
	1,, WclPan		; 15 -- Illegal instruction
	1,, WclPan		; 16 -- Illegal memory read
	1,, WclPan		; 17 -- Illegal memory write
	0			; 18 -- Reserved for DEC
	0			; 19 -- Inferior process termination, not used
	1,, WclPan		; 20 -- System resources exhausted
	0			; 21 -- Reserved for DEC
	1,, WclBdm		; 22 -- Nonexistant page reference
	0			; 23 -- Not used

Repeat ^d<35-24-1>, <0>		; Channels 24-35 are not used

WclCns: 1b0 ! 1b9 ! 1b11 ! 1b12 ! 1b15 ! 1b16 ! 1b17 ! 1b20 ! 1b22

	SubTtl .Lock -- WCL wants to use a resource, lock the superior

.Lock:	SetOM WantIt		; Say we want to take control
	Jrst LckCmn		; Go join common lock code

.ULock:	SetZM WantIt		; Say we are giving back control

; Common point for lock and unlock routines

LckCmn:	Push p, t1
	Push p, t2

	MoveM f, Flags		; Store the flag word

	MoveI t1, .FhSup	; Superior fork
	MovX t2, 1b<WclChn>	; This channel
	IIC%			; Initiate the interrupt
	 JEcBug (HLT,<WCL can't interrupt its superior fork>)

	WAIT%			; Wait until interrupted ...

; This is where we hang out until interrupted ...

WclWai:	SetZ f,			; Clobber this register

	Pop p, t2		; Restore regs
	Pop p, t1

	Ret			; That is all ...


	SubTtl Command Level

ComLvl:	Move p, [IoWd Pdlen, WCLPdl] ; Set up a fresh stack for WCL

	MoveI t1, .FhSlf	; Now initialize the interrupt system
	DIR%			; First turn it off

	CIS%			; Clear interrupt system ...

	Move t2, [WclLtb,, WclCtb] ; Set up pi system
	SIR%

	Move t2, WclCns		; Now activate all desired channels
	AIC%

	EIR%			; Enable the system

	SkipE IniDon		; Init done?
	 Jrst CmdStr		;  Yes, go do other stuff

	SetOM IniDon		; Done now ...

	Tmsg <
 [Starting Window version >

	MoveI t1, .PriOu	; Primary output
	Move t2, EntVec+2	; Pick up the version word
	Call Versio		; Type our version number
	 JcBug (HLT,<Can't type the version number>)

	Tmsg <, type "Help" for assistance]
>

	SkipE NoStrt		; Are we suppressing the startup?
	 Jrst [	Tmsg < [Window.Starting in logged-in directory ignored due to /NoAutoStart switch]

>
		Jrst CmdStr ]	; Move on ...

	SkipN RdJfn		; Is there a reading jfn?
	 Jrst [	Tmsg < [No Window.Starting file in logged-in directory]

>				; Type message
		Jrst CmdStr ]	; Don't type the other one

	 Call TypRdj		;  Yes, type this message ...

CmdStr:	SkipN DetMsg		; Need message?
	 Jrst CmdGo		;  No ...

	Tmsg <

? In your previous session, one of your subjobs ATTACHed itself to the job
  running Window (this job), putting Window into a kind of infinite loop.
  Window broke out of this loop by DETACHing the job and halting.  You
  should try to avoid doing this in the future.

>

	SetZM DetMsg		; Don't bug him again next time

CmdGo:	Call CmdRes		; Reset the COMND state block
	.LeftM			; Get to the left margin

Cmd0:	SetZ i,			; WCL is subjob zero ...

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, IniFdb	; Initialize function
	COMND%			; Do it
	 JEcBug (HLT,<COMND initialization failed>)

Cmd1:	SetZB i, NoFlag		; Sj is zero, clear the "NO" flag

	SetZM Comand		; No legal command yet
	SetZM Comnd2		;  or word 2
	SetZM Comnd3		;  or word 3

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CmdFdb	; The changable FDB ...
	MoveI t3, SenFdb	; We may want the send FDB also ...
	HlrZ t4, SjbTab		; Get number of defined subjobs
	SkipG t4		; Are there any?
	 SetZ t3,		;  No ...
	HrrM t3, 0(t2)		; Set whatever reparse address we decided on
	COMND%			; Do the COMND jsys
	 .NpRp ComErr, Cmd1

	MoveM t2, Comand	; Save ptr to the command we found

	HrrZS t3		; Keep addr of FDB actually used
	CaiE t3, CmdFdb		; Was it a command?
	 Jrst [	HrrE i, 0(t2)	;  No, get subjob ID ...
		MoveI t2, SendLn ; Addr of routine to run
		Jrst .+2 ]	; Skip next inst, go run the routine

	HrrZ t2, 0(t2)		; Get addr of routine to run
	Call 0(t2)		; Run the routine
CmdRet:	 .NpRpO CmdB0, Cmd1, CmdB0 ; On no-parse or 'other' error, go
				;  do another CmIni, else reparse from
				;  the beginning of the command string

	TstWOf HidFlg		; Are we hiding?
	 Jrst CmdTag		;  No ...

	Move t1, OldTty		; Get tty number
	AddI t1, .TtDes		; Make it a terminal designator
	MoveI t2, "."		; A small character
	BOUT%			; Type it to show some activity ...
	 JEcBug (HLT,<WCL can't type character to physical terminal>)

CmdTag:	TstWOn NotFst		; Was this the first command?
	 Jrst Cmd0		;  It was not the first, go get another 

	TstWOn WntHid		; Was the command "Hide"?
	 Jrst CmdB0		;  Yes, don't turn off hide flag

	SetWOf HidFlg		; Not "Hide", turn off hide flag
	
CmdB0:	SetWOn NotFst		; Say this is not the first command
	Jrst Cmd0		; Move on ...


	;continued on next page
	;continued from previous page

; Invalid command

ComErr:	.LeftM			; Get to the left margin
	Tmsg <? >		; Common start of error message
	Move t1, CmdErr		; What was the error?

	CaiN t1, NpxNoM		; No match?
	 Jrst [	Tmsg <Unknown >	; The error message
		Jrst CerTag ]

	CaiN t1, NpxNul		; Null?
	 Jrst [	Tmsg <Incomplete > ; The error message
		Jrst CerTag ]	; Common finish

	CaiN t1, NpxAmb		; Ambiguous?
	 Jrst [	Tmsg <Ambiguous >
		Jrst CerTag ]	; Go to common finish

	Tmsg <Invalid >

CerTag:	SkipE t2, Comand	; Was there a valid beginning to the command?
	 Jrst [	HlrO t1, 0(t2)	; Get ptr to the string
		PSOUT%		; Type the string
		MoveI t1, " "	; A space
		PBOUT%		; Type it
		Jrst .+1 ]	; Return to stream

	SkipE t2, Comnd2	; How about word 2?
	 Jrst [	HlrO t1, 0(t2)	; Get ptr to the string
		PSOUT%		; Type the string
		MoveI t1, " "	; A space
		PBOUT%		; Type it
		Jrst .+1 ]	; Return to stream

	SkipE t2, Comnd3	; And word 3?
	 Jrst [	HlrO t1, 0(t2)	; Get ptr to the string
		PSOUT%		; Type the string
		MoveI t1, " "	; A space
		PBOUT%		; Type it
		Jrst .+1 ]	; Return to stream

	Tmsg <command>		; Finish the first part of the error message
	Call TypAtm		; Type atom buffer contents in quotes, 2 CRLFs
	Jrst Cmd0		; Start anew ...

	SubTtl Command Table Definitions

; Command table - must be in alphabetical order

CmdTab:	%Table
	%Key <Accept>, Accept, Cm%Inv
	%Key <B>, .B, <Cm%Inv ! Cm%Abr>
	%Key <Bell>, BellCo, Cm%Inv
.B:	%Key <Blank>, BlnWCL
	%Key <C>, .C, <Cm%Inv ! Cm%Abr>
.C:	%Key <Connect>, Connec
;	%Key <Continue>, Contin
;	%Key <Copy>, CopyIt
	%Key <De>, .De, <Cm%Inv ! Cm%Abr>
.De:	%Key <Define>, DefJob
	%Key <Detach>, DetCmd
	%Key <Df>, DefFrk
	%Key <Discard>, Discar, Cm%Inv
	%Key <Dump>, DumpCo, Cm%Inv
	%Key <Exit>, ExitCo
	%Key <Get>, GetCom, Cm%Inv
	%Key <H>, .H, <Cm%Inv ! Cm%Abr>
.H:	%Key <Help>, Help
	%Key <Hide>, Hide, Cm%Inv
	%Key <Information>, Info
	%Key <K>, .K, <Cm%Inv ! Cm%Abr>
	%Key <Keep>, Keep, Cm%Inv
.K:	%Key <Kill>, Kill
	%Key <Log>, Log
	%Key <Logout>, Logout
	%Key <No>, NoComm, Cm%Inv
	%Key <Order>, Order
	%Key <Push>, PushE
	%Key <Red>, .Red, <Cm%Inv ! Cm%Abr>
.Red:	%Key <Redefine>, Redefi
	%Key <Redisplay>, Redisp
	%Key <Refuse>, Refuse, Cm%Inv
	%Key <Rename>, Rename
	%Key <Res>, .Res, <Cm%Inv ! Cm%Abr>
.Res:	%Key <Reset>, ResetC
	%Key <Restrict>, Rstrct
	%Key <Set>, SetCom
	%Key <Show>, Show
	%Key <Silence>, Silnce, Cm%Inv
	%Key <Take>, Take
	%Key <Terminal>, Termnl
	%Key <Unrestrict>, UnRsct
	%Key <Wait>, Wait
	%Key <What>, What
	%Key <Window>, WinCmd
	%TbEnd

; Table for Window x (is) arguments

WinTab:	%Table
	%Key <Banner>, WinBan
	%Key <Freeze-when-offscreen>, WinFre
	%Key <Invisible>, WinInv
	%Key <Lazy-Update>, WinLzy
	%Key <No>, WinNo
	%Key <Opaque>, WinOpa
	%Key <Size>, WinSiz
	%Key <Transparent>, WinTra
	%Key <Visible>, WinVis
	%TbEnd

	;continued on next page
	;continued from previous page

; Table for Window x (is) No arguments

WNoTab:	%Table
	%Key <Banner>, WNoBan
	%Key <Freeze-when-offscreen>, WinFre
	%Key <Lazy-Update>, WinLzy
	%Key <Size>, WNoSiz
	%TbEnd

; Negatable command table - must be in alphabetical order

CmdNTb:	%Table
	%Key <Accept>, Refuse	; 'NO ACCEPT' is the same as 'REFUSE'
	%Key <Bell>, BellCo, Cm%Inv
	%Key <Discard>, Keep	; 'NO DISCARD' is the same as 'KEEP'
	%Key <Keep>, Discar	; 'NO KEEP' is the same as 'DISCARD'
	%Key <Log>, NoLog
	%Key <Refuse>, Accept	; 'NO REFUSE' is the same as 'ACCEPT'
	%Key <Silence>, Silnce
	%TbEnd

; Reset arguments

ResTab:	%Table
	%Key <EMACS-fork>, ResEma
	%Key <EXEC-filename>, ResXec
	%Key <Pushed-EXEC>, ResPsh
	%Key <Window>, ResWin
	%TbEnd

; Restrict arguments

RstTab:	%Table
	%Key <All>, < CommaR ! EnterR ! EscapR ! NineR ! PF3R ! PF4R ! ZeroR >
	%Key <Comma-key>, CommaR
	%Key <Enter-key>, EnterR
	%Key <Escape-character>, EscapR
	%Key <Nine-key>, NineR
	%Key <PF3-key>, PF3R
	%Key <PF4-key>, PF4R
	%Key <Zero-key>, ZeroR
	%TbEnd

; Set arguments

SetTab:	%Table
	%Key <Auto-Redisplay>, SetARd
	%Key <Continue-Halted-Forks>, SetCon
	%Key <EXEC-filename>, SetXec
	%Key <Flash>, SetFla
	%Key <Indicate>, SetInd
	%Key <Key>, SetKey
	%Key <Margin>, SetMrg
	%Key <Multi-Window-Mode>, SetMWM
	%Key <No>, SetNo
	%Key <One-Window-Mode>, SetOWM
	%Key <Padding>, SetPad
	%Key <Pause-on-Command>, SetPau
	%Key <Screen-Banner>, SetScr
	%Key <Terminal>, Termnl
	%Key <Window>, WinCmd
	%TbEnd


; "Set No xxx" ...

SNoTab:	%Table
	%Key <Auto-Redisplay>, SetNAR
	%Key <Continue-Halted-Forks>, SetCon
	%Key <Flash>, SetNFl
	%Key <Indicate>, SetInd
	%Key <Log>, NoLog
	%Key <Pause-on-Command>, SNoPau
	%Key <Screen-Banner>, SNoScr
	%TbEnd


; "Set Flash xxx"

FlaTab:	%Table
	%Key <Black>, 1
	%Key <White>, -1
	%TbEnd


; "Set Padding" ...

PadTab:	%Table
	%Key <Double>, 1
	%Key <Full>, 0
	%Key <Half>, -1
	%Key <None>, -17
	%Key <Quarter>, -2
	%TbEnd


; Terminal types

TerTab:	%Table
	%Key <Hard-Copy>, 0
	%Key <IBM-3101>, Im3101
	%Key <VT100>, Vt100
	%Key <VT52>, Vt52
	%TbEnd


; 'All' table, used to look for keyword 'All'

AllTab:	%Table
	%Key <All>, -1		; Our flag for 'All'
	%TbEnd


; 'Default' or 'All' table, used to look for keywords Default or All

DfATab:	%Table
	%Key <All>, -1		; Our flag for 'All'
	%Key <Default>, -2	; Flag for 'Default'
	%TbEnd


; Key table, names of user-definable keypad keys

KeyTab:	%Table
	%Key <1>, 1
	%Key <2>, 2
	%Key <3>, 3
	%Key <4>, 4
	%Key <5>, 5
	%Key <6>, 6
	%Key <7>, 7
	%Key <8>, 8
	%TbEnd

	SubTTl Commonly used Field Descriptor Blocks 

; FDB for sending text to a subjob from command level

SenFdb:	FldBk. (.CmKey,, 
		   SjbTab,<(to send a line to a subjob) subjob name,>,, 
		     [BrMsk. (KeyB0.,KeyB1.,KeyB2.,KeyB3.,<_>,<->)], 
		[FldBk. (.CmKey,, 
		   AllTab,<(to send a line to all subjobs),>,, 
		  [BrMsk. (KeyB0.,KeyB1.,KeyB2.,KeyB3.,<_>,<->)] )] ) ; Keyword
				;  or subjob name terminated by dash, or "All"

; FDB for initialization

IniFdb: FldDb. (.CmIni)


; FDB for confirm function

CfmFdb:	FldDb. (.CmCfm)


		; FDBs for PrsSjb

; Subjob or 'All', default is 'All'

SbaFdb:	FldBk. (.CmKey,,SjbTab,<name,>,<All>, 
		[BrMsk. (KeyB0.,KeyB1.,KeyB2.,KeyB3.,<_>)], 
			[ FldDb. (.CmKey,,AllTab) ] )


; Subjob or 'All', no default

SbnFdb:	FldBk. (.CmKey,,SjbTab,<name,>,, 
		[BrMsk. (KeyB0.,KeyB1.,KeyB2.,KeyB3.,<_>)], 
			[ FldDb. (.CmKey,,AllTab) ] )


; Fdb for parsing EXEC name ...

ExcFdb:	FldDb. (.CmFil,Cm%Sdh,,<EXEC to run>)

	SubTtl Accept command -- Accept output from subjobs

Accept:	Call GetSjb		; Get the subjob ID
	 Ret			;  Failed

	MovX t2, PtRefF		; Set up to clear refuse flag

	SkipGE i		; If user said 'All' ...
	 SetZM RefAll		;  Mark that an 'ACCEPT ALL' was done

	Jrst ClrBit		; Go clear the bit for any indicated subjobs


	SubTtl Bell command -- Set flag to ding the bell when output waiting

BellCo:	CmNoi <when output waiting> ; Noise words
	CmCfm			; Confirm

	Tmsg < [Obsolete command ignored]>
	Jrst Tp2Rsk		; Say we don't care ...

	SubTtl Blank command -- Blank WCL's screen

BlnWCL:	CmNoi <Command Level window> ; Noise ...

	CmCfm			; Confirm

	Tmsg < [Ok]

>				; Say we are doing it ...

	MoveI t1, .PriOu	; Controlling terminal
	RFMOD%			; Get the current mode
	Push p, t2		; Save it

	TxZ t2, Tt%Dam		; Clobber data mode (makes it image mode)

	SFMOD%			; Set the new mode

	Tmsg <[H[J>		; Text to clear the screen

	MoveI t1, .PriOu	; Controlling terminal
	Pop p, t2		; Get back the old mode
	SFMOD%			; Restore it

	RetSkp			; And return good

	SubTtl Connect command -- Connect to a PTY line

Connec:	CmNoi <to>		; Noise words

	SetZ t1,		; Start with no pointer
	SkipLE i, LstCon	; Get last connected, skip if none
	 HrrO t1, PtyNam(i)	; Pointer to name of subjob

	MoveI t2, SboFdb	; Addr of FDB to use
	MoveM t1, .CmDef(t2)	; Set the default subjob name

	Call PrsSjb		; Parse for a subjob ID
	 Ret			;  Didn't get one
	CmCfm			; Confirm

	Tmsg < [Connecting to > ; Start of message
	Call TypNam		; The name
	Tmsg <]

>				; End of message

	MoveI t1, .PriOu	; The terminal
	DOBE%			; Wait until quiet

	Lock			; Lock resources
	MoveM i, LstHdr		; Say we already did the header
	MoveM i, ConSjb		; Say who we are connected to now ...
	SetOM SwiSjb		; Tell higher level we are switching subjobs
	SetFOn StrChg		; Say structure changed ...
	UnLock			; Say we made a change

	MoveI t1, ^d2000	; Two full seconds ...
	DISMS%			; Wait ... (so we don't look hungry too soon)

	RetSkp			;  Returns to us when going back to WCL ...

	SubTtl Continue command -- Continue a subfork

Contin:	Ret			; Nothing, for now

	SkipE t1, PtyFrk(i)	; Is the connected subjob a fork?
	 Jrst [	RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get status of subfork>)	
		Load t2, Rf%Sts, t1 ; Pick up the relevant bits
		CaiN t2, .RfHlt	; Halted?
		 Call [	Move t1, PtyTtd(i) ; TTY of the subfork
			HrrOI t2, [AsciZ/ [Continuing subfork ...]
/]				; A message
			SetZ t3, ; Stop on a null
			SOUT%	; Type the message in his window
			 JEcBug (HLT,<Can't type message for subjob>)
			Move t1, PtyFrk(i) ; Get fork handle again
			TxO t1, Sf%Con ; Want to continue him
			SFORK%	; Try to do it
			 JEcBug (HLT,<Can't continue halted subfork>)
			Ret ]	; Return from this literal
		HrrO t2, PtyNam(i) ; Yes ...
;		Call AscSix	; Convert into SIXBIT
		Jrst .+1 ]	; Go set it

	SubTtl Define command -- Define a subjob

DefJob:	SetZM AFork		; It's not a fork ...

	CmNoi <subjob>		; Noise words

	SetZ p1,		; Don't try to insert
	SetO p2,		; Create a new subjob
	MoveI p3, CmdAtm + AtmLen/2 ; Addr of the name to be added
	SetZ p4,		; Start with 'subjob number' zero
DsuDlp:	HrrOI t1, CmdAtm + AtmLen/2 ; Addr of our little buffer
	Move t2, p4		; Copy in the 'subjob number' to try
	MovX t3, ^d10		;  as decimal
	NOUT%			; Do it
	 JEcBug (HLT,<NOUT failed>)

	SetZ t2,		; Clear t2
	Idpb t2, t1		; Tie off the string

	Call AddSub		; Try to add this subjob ID
	 AojA p4, DsuDlp	;  Can't, try the next one and loop

	HrrOI t1, 0(p3)		; The default name ...
	MoveM t1, DefFdb + .CmDef ; Store it as our default

	MoveI t1, CmdCsb	; The command state block
	MoveI t2, DefFdb	; Use changable FDB
	COMND%			; Do it
	 .NpRp DsuBad, R	; Handle errors

; Here when user has entered the first subjob name into the atom buffer

	SetZ p1,		; Just check for feasibility of adding
	MoveI p3, CmdAtm	; Addr of name to test for
	Call ChkAll		; Is it 'All'?
	 Ret			;  Yes, return NG

	Call ChkDsh		; Does it have any dashes in it?
	 Ret			;  Yup, no good

	;continued on next page
	;continued from previous page

	Call AddSub		; Test if it can be added
	 Jrst [	.LeftM		; Failed, get to left margin
		Tmsg <? Window >
		TmsgS CmdAtm
		Tmsg < is already defined.

>				; Complain
		Ret ]		;  and return NG
	Move t1, [CmdAtm,, CmdAtm + AtmLen/2] ; BLT the name to the top half
	Blt t1, CmdAtm + AtmLen - 1
	CmNoi <alias>		; Noise words
	MoveI t1, CmdCsb	; Again
	MoveI t2, AltCfm	; Use alternate FDB
	COMND%			; Do it
	 .NpRp DsuBad, R	; Handle errors
	HrrZS t3		; Get addr of FDB used
	CaiE t3, AltCfm		; Is it a name?
	 Jrst DsuAlt		;  Yes, go handle it

; Here when user has entered a single name and confirmed

	Lock
	SetO p1,		; Try to insert
	SetO p2,		; Create a new subjob
	MoveI p3, CmdAtm + <AtmLen/2> ; Addr of name to be added
	Call AddSub		; Try to add this subjob ID
	 Bug (CHK,<Can't add a name that should be addable>)

	Jrst DsuFin		; Go join common finish up code ...

	;continued on next page
	;continued from previous page

; Here when user has entered the second subjob name into the atom buffer

DsuAlt:	CmCfm			; Confirm

	SetO p1,		; Try to add
	SetO p2,		; Create a new subjob

	Call ChkAll		; Is it 'All'?
	 Ret			;  Yes, return NG
	Call ChkDsh		; Does it have any dashes in it?
	 Ret			;  Yup, no good
	Lock
	Call AddSub		; Test if it can be added
	 Jrst [	Unlock
		Tmsg <? Window >
		TmsgS CmdAtm
		Tmsg < is already defined.

>				; Complain
		Ret ]		;  and return NG

; We added the alternate name, now add the primary
	Move p2, i		; Copy down the old subjob offset
	MoveI p3, CmdAtm + <AtmLen/2> ; Addr of name to be added

	Call AddSub		; Try to add this subjob ID
	 Trn			;  Maybe he used the same name twice


; Common finish up code ...

DsuFin:	SetZM PtyFrk(i)		; Mark that this is a job, not a fork ...
	Call NewWin		; Set up the new window

	SetFOn StrChg		; Things changed ...
	Unlock

	Tmsg < [Defined subjob > ; Start of message
	Call TypNam		; Type the name
	Tmsg <]>

	Jrst Tp2Rsk		; Finish up the msg, return skip

DsuBad:	.LeftM			; Get to left margin
	Tmsg <? Invalid name>	; Complain
	Jrst TypAtm

	;continued on next page
	;continued from previous page

;
; ChkAll - routine to check for 'All'
;
;   Takes:
;	p3/ addr of string to check
;
;   Returns:
;	+1 if 'All' exactly
;	+2 otherwise
;

ChkAll:	HrrO t1, p3		; Get pointer to test string
	HlrO t2, AllTab+1	; Steal pointer to 'All'
	STCMP%			; Compare the strings
	TxNE t1, Sc%Lss ! Sc%Sub ! Sc%Gtr ; Skip if exact match
	 Jrst RSkp		; Give 'not All' return

	.LeftM			;  Yes, complain
	Tmsg <? Illegal to define 'All'

>
	Ret			;  and return NG

	SubTtl ChkDsh -- Check entered subjob name for dashes

;
; ChkDsh - routine to check for dashes in name
;
;   Takes:
;	p3/ addr of string to check
;
;   Returns:
;	+1 if any dashes are found
;	+2 otherwise
;

ChkDsh:	MovSI t2, (Point 7, 0)	; Make a byte ptr
	Hrr t2, p3		; Copy in the addr of the name

CdsLp1:	Ildb t1, t2		; Get next byte
	JumpE t1, RSkp		; If a null, then done here
	CaiE t1, "-"		; Dash?
	 Jrst CdsLp1		;  No, go get next byte

	.LeftM			; Left margin
	Tmsg <? Name may not contain dash (-) ... try underscore (_)>
	Jrst Tp2Ret		; 2 crlfs, ret

	SubTtl DetCmd -- Detach command

DetCmd:	CmNoi <Window from this terminal> ; Noise

	CmCfm			; Confirm

	Tmsg < [Detaching ...]

>				; A confirmation message ...
	Call DspPau		; Pause the display

	SetFOn WntDet		; Flag that we want this
	UnLock			; This makes it happen ..

	RetSkp			; That's it

	SubTtl Df command -- Define a fork window

DefFrk:	SetOM AFork		; It's a fork

	CmNoi <define fork>	; Noise

	SetZ p1,		; Don't try to insert
	SetO p2,		; Create a new subjob
	SetZM DefFdb + .CmDef	; No default

	MoveI t1, CmdCsb	; The command state block
	MoveI t2, DefFdb	; Use changable FDB
	COMND%			; Do it
	 .NpRp DsuBad, R	; Handle errors

	Move t3, [Point 7, CmdAtm] ; Get ptr to atom buffer
	Ildb t4, t3		; Pick up the first byte
	JumpE t4, [.LeftM	; Get to left margin
		   Tmsg <? Window name was not specified>
		   Jrst Tp2Ret ] ; Return bad ...

	MoveI p3, CmdAtm	; Addr of name to test for
	Call ChkAll		; Is it 'All'?
	 Ret			;  Yes, return NG

	Call ChkDsh		; Does it have any dashes in it?
	 Ret			;  Yup, no good

	SetZ p1,		; Just check for feasibility of adding
	Call AddSub		; Test if it can be added
	 Jrst [	.LeftM		; Failed, get to left margin
		Tmsg <? Window >
		TmsgS CmdAtm
		Tmsg < is already defined.

>				; Complain
		Ret ]		;  and return NG

	Move t1, [CmdAtm,, CmdAtm + AtmLen/2] ; BLT the name to the top half
	Blt t1, CmdAtm + AtmLen - 1

	CmNoi <running program>	; Noise

	Call GjfRes		; Reset (most of) the GTJFN block

	Move t4, .GjGen(t3)	; Get flags set so far ...
	TxO t4, Gj%Old		; Add the fact that it should be an old file ..
	MoveM t4, .GjGen(t3)	; Put it back ...
	HrrOI t4, [AsciZ/Sys:/]	; Default structure
	MoveM t4, .GjDev(t3)	; Store it
	HrrOI t4, [AsciZ/Exe/]	; Default extension
	MoveM t4, .GjExt(t3)	; Store it

	MoveI t1, GjfBlk	; The GTJFN block
	HrrOI t2, CmdAtm+<AtmLen/2> ; The filename ...
	GTJFN%			; Long form GTJFN ...
	 ErJmp [SetZM HldJfn	;  Fialed, no jfn ...
		Jrst DfkTag ]	; Move on ...

	HrrZM t1, HldJfn	; Put it here

	HrrOI t4, CmdAtm+<AtmLen/2> ; Default filename
	MoveM t4, .GjNam(t3)	; Store it

DfkTag:	HrrOI t1, String	; Place to build a help message
	HrrOI t2, [AsciZ/Confirm with carriage return to run /]
	SetZ t3,		; Stop on a null
	SOUT%			; Type this string
	 JEcBug (HLT,<Can't type string in core>)

	Move p1, t1		; Store ptr to the file name for later GTJFN%

	SkipE HldJfn		; Do we have a jfn?
	 Jrst [ HrrOI t2, [AsciZ/SYS:/]	; More text
		SOUT%		; Type it ...
		 JEcBug (HLT,<Can't type string in core>)
		Move t2, HldJfn	; Get the jfn ...
		MovX t3, Fld(.JsAof, Js%Nam) ! Fld(.JsAof, Js%Typ) ! 
			Fld(.JsAof, Js%Gen) ! Js%Paf ; No device or directory
		JFNS%		; Type this file name into the string
		 JEcBug (HLT,<Can't type program filespec in core>)
		Push p, t1	; Save this reg
		Move t1, t2	; Move over the jfn
		RLJFN%		; Release it
		 ErCal R	;  Ignore error
		Pop p, t1	; Restore reg
		Jrst DfkTg1 ]	; Skip over the other text

	HrrOI t2, ExecNm	; Use the name of the EXEC
	SetZ t3,		; Stop on a null
	SOUT%			; Type this text
	 JEcBug (HLT,<Can't type string in core>)

DfkTg1:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, PrgFdb	; Parse for a jfn
	HrrOI t3, String	; Ptr to string
	MoveM t3, .CmHlp(t2)	; Set up the help text we just built
	COMND%			; Go get the jfn, if we can
	 .NpRp BadPsh, R	; Handle bad file name here, return on reparse

	HrrZS t3		; Isolate the right half
	CaiN t3, PrgFdb		; Was this the one we used?
	 Jrst [	MovX t1, Gj%Sht ! Gj%Old ;  Yes, short form, old file ...
		Move t2, p1	; Use the file name we used before
		GTJFN%		; Short form GTJFN
		 JEcBug (HLT,<Can't get jfn on the EXEC>)
		HrrZM t1, HldJfn ; Got it, store the jfn
		SetZM CmdAtm	; Make atom buffer seem empty
		Call SetRes	; Set up the rescan buffer
		Jrst DfkTg2 ]	; Continue later on ...

	HrrZM t2, HldJfn	; Store the jfn we got

	CmNoi <with rescan text> ; Noise

	MoveI t1, CmdCsb	; Again
	MoveI t2, [FldDb. (.CmTxt,Cm%Sdh,,<text for rescan buffer>)]
	COMND%			; Get text for the rescan buffer
	 .NpRp FixPsh, FixPsh	;  Just give up if no parse ...

	Call SetRes		; Load up the rescan text for this guy

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CfmFdb	; FDB for confirm
	COMND%			; Confirm the command
	 .NpRp ClrPsh, FixPsh	; Handle bad file name here, unget jfn if
				;  reparse needed, then return

	;continued on next page
	;continued from previous page

DfkTg2:	Lock
	SetO p1,		; Try to insert
	SetO p2,		; Create a new subjob
	MoveI p3, CmdAtm + <AtmLen/2> ; Addr of name to be added
	Call AddSub		; Try to add this subjob ID (sets the flag so
				;  that interrupt level will CFORK% him)
	 Bug (CHK,<Can't add a name that should be addable>)

	SetOM PtyFrk(i)		; Mark it as a fork first ...
	Call NewWin		; Set up the new window

	Move t1, HldJfn		; Pick up the jfn
	MoveM t1, PtyPjf(i)	; Store it as the jfn for this program

	SetFOn StrChg		; Things changed ...
	Unlock			; Make it all happen now ...

	MoveI t1, ^d500		; This many milliseconds ...
	DISMS%			; Wait for lower fork to read rescan buffer ...

	Tmsg < [Defined subfork > ; Start of message
	Call TypNam		; Type the name
	Tmsg <]>

	Jrst Tp2Rsk		; Finish up the msg, return skip

	SubTtl Discard command -- Discard output from subjob

Discar:	Call GetSjb		; Get the subjob ID
	 Ret			;  Failed

	MovX t2, PtDisF		; The Discard flag

	SkipGE i		; If user said 'All' ...
	 SetOM DisAll		;  Mark that a 'Discard All' was done

	Jrst SetBit		; Go set the bit for any indicated subjobs

	SubTtl Dump command -- Dump one line of timing info to dump file

DumpCo:	CmNoi <timing information to DSK:WINDOW.TIMING-DUMP.0> ; Noise
	CmCfm			; Confirm

	MovX t1, Gj%Sht		; Short form
	HrrOI t2, [AsciZ/Dsk:Window.Timing-Dump.0 /] ; File name
	GTJFN%			; Get a jfn on the file
	 JEcBug (HLT,<Can't get jfn on DSK:WINDOW.TIMING-DUMP.0>)

	HrrZ p1, t1		; Get jfn into p1

	MovX t2, Fld(7,Of%Bsz) ! Of%App	; 7 bit bytes, append
	OPENF%			; Open the file
	 JEcBug (HLT,<Can't open DSK:WINDOW.TIMING-DUMP.0>)

	HrrOI t2, [AsciZ/          Total in-state times (in seconds) as of /]
	SetZ t3,		; Stop on a null
	SOUT%			; Type a header
	 JEcBug (HLT,<Can't write string to file>)

	SetO t2,		; Current time and date
	ODTIM%			; Output a timestamp
	 JEcBug (HLT,<Can't write timestamp to file>)

	HrrOI t2, [AsciZ/

                     Total times        Times since last dump
                     Value     %             Value     %
                     ------------            ------------
/]
	SOUT%			; Type more header ...
	 JEcBug (HLT,<Can't write string to file>)


	Lock			; Lock up, so the numbers don't change ...

; First, get the total so we can do percentages ...

	SetZ t3,		; Start with a grand total of zero
	SetZ t4,		; Start with the first state

DmpLp1:	Add t3, Times(t4)	; Get the data item
	CaiGE t4, HiStat	; Was this the highest state?
	 AojA t4, DmpLp1	;  No, bump ptr and go do another

	MoveM t3, NewTot	; Store the total for loop code


; Then do the detailed records ...

	SetZ t4,		; Start with the first state again ...

DmpLp2:	HrrO t2, NmTabl(t4)	; Get ptr to data item name string
	SetZ t3,		; Stop on a null
	SOUT%			; Type the string
	 JEcBug (HLT,<Can't write item name to file>)

	Move p3, NewTot		; Get new total
	Move t2, Times(t4)	; Get the data item
	Call DmpNum		; Dump the value and the percentage of total

	HrrOI t2, [AsciZ/           /] ; Type some spaces
	SetZ t3,		; Stop on a null
	SOUT%			; Type them
	 JEcBug (HLT,<Can't write string to file>)

	Sub p3, DmpTot		; Compute total difference
	Move t2, Times(t4)	; Get the new data value
	Sub t2, DmpTms(t4)	; Subtract the old data value
	Call DmpNum		; Dump the difference

	HrrOI t2, [AsciZ/
/]
	SetZ t3,		; Stop on a null
	SOUT%			; Type a CrLf
	 JEcBug (HLT,<Can't write string to file>)

	JumpL t4, DmpDon	; Finished doing total line, done here

	CaiGE t4, HiStat	; Was this the highest state?
	 AojA t4, DmpLp2	;  No, bump ptr and go do another

	SetO t4,		; Done with the basic stats, set up for total
	Jrst DmpLp2		; Go do the last pass

DmpDon:	HrrOI t2, [AsciZ/
/]
	SOUT%			; Type a CrLf
	 JEcBug (HLT,<Can't write string to file>)

	Move t1, p1		; Get back the jfn
	CLOSF%			; Close the file
	 JEcBug (HLT,<Can't close DSK:WINDOW.TIMING-DUMP.0>)

	Move t1, [NewTot,, DmpTot] ; Blt word
	Blt t1, DmpTot+NTimes	; Copy over the new values

	Unlock			; Unlock now that timing has been dumped ...

	Tmsg < [Timing information dumped]>
	Jrst Tp2Rsk		; Done here

; Name table for dumped items

	[AsciZ/---------------------------------------------------------
Total:              /]
NmTabl:	[AsciZ/Background:         /]
	[AsciZ/Timer:              /]
	[AsciZ/Chunk update:       /]
	[AsciZ/Screen update:      /]
	[AsciZ/Line update (1):    /]
	[AsciZ/Line update (2):    /]
	[AsciZ/Screen addressing:  /]
	[AsciZ/String output:      /]
	[AsciZ/PTY output:         /]
	[AsciZ/BIN%s from PTYs:    /]
	[AsciZ/Undefined 1:        /]
	[AsciZ/Undefined 2:        /]
	[AsciZ/Undefined 3:        /]
	[AsciZ/Undefined 4:        /]
	[AsciZ/Undefined 5:        /]


;
; Type value and percentage
;
;  Call with ...
;	t2/ Value to display
;	p3/ Total
;

DmpNum:	Push p, t2		; Save t2 on stack

	IDivI t2, ^d100		; Convert to milliseconds
	CaiL t3, ^d50		; Compare remainder with 1/2 of divisor
	 Aoj t2,		;  Bigger, bump quotient

	IDivI t2, ^d1000	; Convert to seconds
	Move p2, t3		; Store away remainder
	MovX t3, No%LFl ! No%OOv ! Fld(3,No%Col) ! Fld(^d10,No%Rdx)
	NOUT%			; Type the first part
	 JEcBug (HLT,<Can't write number to file>)

	MoveI t2, "."		; A decimal point
	BOUT%			; Type it

	Move t2, p2		; Get back the fractional part of the number
	MovX t3, No%LFl ! No%Zro ! Fld(3,No%Col) ! Fld(^d10,No%Rdx)
	NOUT%			; Type the second part
	 JEcBug (HLT,<Can't write number to file>)

	Pop p, t2		; Get back saved value
	IMulI t2, ^d1000	; Prepare to round off at tenths of percent
	IDiv t2, p3		; Divide by total
	Lsh t3, 1		; Double the remainder
	CamL t3, p3		; Compare with divisor
	 Aoj t2,		;  Bigger, bump quotient

	IDivI t2, ^d10		; Div by 10, quotient = %, remainder = tenths
	Move p2, t3		; Store away remainder
	MovX t3, No%LFl ! No%OOv ! Fld(4,No%Col) ! Fld(^d10,No%Rdx)
	NOUT%			; Type the first part
	 JEcBug (HLT,<Can't write number to file>)

	MoveI t2, "."		; A decimal point
	BOUT%			; Type it

	Move t2, p2		; Get back the fractional part of the number
	MovX t3, No%LFl ! No%Zro ! Fld(1,No%Col) ! Fld(^d10,No%Rdx)
	NOUT%			; Type the second part
	 JEcBug (HLT,<Can't write number to file>)

	Ret			; Done here

	SubTtl Exit command -- Exit from Window

ExitCo:	CmNoi <from Window>	; Noise words
	CmCfm			; Confirm
	Call ChkLOG		; See if any active subjobs
	 Jrst Exit1		;  None, go exit

	Tmsg < Caution: Exiting may cause your subjobs to become detached
>				; Start of message

	Call CfmRes		; Reset the confirm-only command state block
	MoveI t1, CfmCsb	; Addr of confirmation-only state block
	MoveI t2, IniFdb	; Initialize it
	COMND%			; Do it
	 JEcBug (HLT,<COMND failed>)

	MoveI t2, CfmFdb	; Confirm with carriage return ...
	COMND%			; Do it
	TxNE t1, Cm%Nop ! Cm%Rpt ; If any parse error
	 Jrst ExiNop		;  then don't confirm

	Call Tp1Ret		; Another CrLf (to separate the next message)

Exit1:	Tmsg < [Exiting to superior EXEC]

>				; A message ...

	MoveI t1, .PriOu	; Terminal
	DOBE%			; Wait till quiet

	MoveI t1, ^d1000	; This many milliseconds
	DISMS%			; Wait that long ...

	SetOM Halted		; Say we are done
	UnLock			; Kick him

	HALTF%			; Stop cold ...
Stopd:	Jrst .-1		;  with no where to go ...

ExiNop:	.LeftM			; Get to left margin
	Tmsg <
% EXIT not confirmed>		; Type a non-confirmation message
	Jrst Tp2Ret		; Return ...

	SubTtl Get command -- Get input from a file

GetCom:	CmNoi <commands from file> ; Noise words

	Call GjfRes		; Reset (most of) the GTJFN block

	HrrOI t4, [AsciZ/Ato/]	; Default extension
	MoveM t4, .GjExt(t3)	; Store it

	Jrst TakTag		; Go join common code

	SubTtl Help command -- Help the user know what he can do

Help:	CmNoi <with>		; Noise words

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,HlpTab,,<Help>)] ; FDB for help
	COMND%			; Do it
	 .NpRp HlpErr, R	; Handle errors

	HrrZ p1, 0(t2)		; Get addr of code word ...
	Move p1, 0(p1)		; Get code word ...

; If left half is zero, type message located at address from right half
;	else, run right half as a program

	JumpG p1, [CmCfm	;  Confirm
		TmsgS (<0(p1)>)	;  Type out the help
		RetSkp ]	;  and return

	Jrst 0(p1)		; Go run the sub-function

HlpErr:	.LeftM			; Get to left margin
	Tmsg <? Invalid help request>
	Jrst TypAtm

	SubTtl Help command table

HlpTab:	%Table
	%Key <Accept>, [HlpAcc]
	%Key <Background>, [HlpBac]
	%Key <Bell>, [HlpBel], Cm%Inv
	%Key <Blank>, [HlpBla]
	%Key <Commands>, [HlpCmd]
	%Key <Connect>, [HlpCon]
	%Key <Control-L>, [HlpCnL]
	%Key <Define>, [HlpDef]
	%Key <Detach>, [HlpDet]
	%Key <Df>, [HlpDf]
	%Key <Discard>, [HlpDis]
	%Key <Down-Arrow-key>, [HlpDna]
	%Key <Enter-key>, [HlpEnt]
	%Key <Exit>, [HlpExi]
	%Key <Help>, [HlpHlp]
	%Key <Information>, [HlpInf]
	%Key <Keep>, [HlpKee]
	%Key <Key-summary>, [HlpKey]
	%Key <Kill>, [HlpKil]
	%Key <Left-Arrow-key>, [HlpLfa]
	%Key <Log>, [HlpLog]
	%Key <Order>, [HlpOrd]
	%Key <Period-key>, [HlpPer]
	%Key <PF1-key>, [HlpPF1]
	%Key <PF2-key>, [HlpPF2]
	%Key <PF3-key>, [HlpPF3]
	%Key <PF4-key>, [HlpPF4]
	%Key <Program>, [HlpPrg]
	%Key <Push>, [HlpPsh]
	%Key <Redefine>, [HlpRed]
	%Key <Redisplay>, [HlpRdi]
	%Key <Refuse>, [HlpRef]
	%Key <Rename>, [HlpRen]
	%Key <Reset>, [-1,,HlpRes] ; Reset command takes arguments
	%Key <Right-Arrow-key>, [HlpRta]
	%Key <Sending>, [HlpSnd]
	%Key <Set>, [-1,,HlpSet] ; Set command takes arguments also
	%Key <Show>, [HlpSho]
	%Key <Silence>, [HlpSil]
	%Key <Starting>, [HlpSta]
	%Key <Take>, [HlpTak]
	%Key <Terminal>, [HlpTer]
	%Key <Tracing>, [HlpTra]
	%Key <Up-Arrow-key>, [HlpUpa]
	%Key <Wait>, [HlpWai]
	%Key <What>, [HlpWht]
	%Key <Window>, [HlpWin]
	%Key <Zero-key>, [HlpZer]
	%TbEnd

; Help table for Reset arguments

HReTab:	%Table
	%Key <EXEC-filename>, HlpRex
	%Key <Pushed-EXEC>, HlpRPs
	%Key <Window>, HlpRWi
	%TbEnd

; Help table for Set arguments

HSeTab:	%Table
	%Key <EXEC-filename>, [HlpSex]
	%Key <Margin>, [HlpMrg]
	%Key <Multi-Window-Mode>, [HlpMlt]
	%Key <One-Window-Mode>, [HlpOne]
	%Key <Padding>, [HlpPad]
	%Key <Pause-on-Command>, [HlpPau]
	%TbEnd

	SubTtl Help for Reset command

HlpRes:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,HReTab)] ; FDB for help
	COMND%			; Do it
	 .NpRp HlpErr, R	; Handle errors

	HrrZ p1, 0(t2)		; Get addr of code word ...

	CmCfm			;  Confirm
	TmsgS (<0(p1)>)		;  Type out the help
	RetSkp			;  and return

	SubTtl Help for Set command

HlpSet:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,HSeTab)] ; FDB for help
	COMND%			; Do it
	 .NpRp HlpErr, R	; Handle errors

	HrrZ p1, 0(t2)		; Get addr of code word ...
	Move p1, 0(p1)		; Get code word ...

; If left half is zero, type message located at address from right half
;	else, run right half as a program

	JumpG p1, [CmCfm	;  Confirm
		TmsgS (<0(p1)>)	;  Type out the help
		RetSkp ]	;  and return

	Jrst 0(p1)		; Go run the sub-function

	SubTtl Hide command -- Try to hide the startup code

Hide:	CmNoi <startup code>	; Noise

	CmCfm			; Confirm

	.LeftM			; Left margin

	SkipN RdJfn		; Is this from a file?
	 Jrst [	Tmsg < [Not from a file, ignored]> ; A message ...
		Jrst Tp2Rsk ]	; That's it

	TstWOn NotFst		; Is this the first command?
	 Jrst [	Tmsg < [Not first command, ignored]> ; A message ...
		Jrst Tp2Rsk ]	; That's it

	Tmsg < [Hiding startup code]> ; A message ...

	Move t1, OldTty		; Get tty number
	AddI t1, .TtDes		; Make it a terminal designator
	HrrOI t2, [AsciZ/ [Hiding startup code]/] ; A message
	SetZ t3,		; Stop on a null
	SOUT%			; Type the string to the real terminal
	 JEcBug (HLT,<WCL can't type message to physical terminal>)

	SetWOn WntHid		; Flag that we want this
	Jrst Tp2Rsk		; That's it

	SubTtl Information command -- Give information about global parameters

Info:	CmNoi <about global parameters>	; Noise ...

	CmCfm			; Confirm

	Tmsg < Taking input from > ; Start of message

	SkipE t1, RdJfn		; Are we reading from a file?
	 Jrst [	MoveM t1, TheJfn ; Yes, jfn of the file
		Call TypJfn	; Type the file name
		Jrst .+2 ]	; Skip next literal
	Jrst [	Tmsg <terminal>
		Jrst .+1 ]

	Tmsg <
>
	SkipE LogJfn		; Are we logging?
	 Jrst [	Tmsg < Logging output to > ; Yes ...
		Move t1, LogJfn	; Get the jfn
		MoveM t1, TheJfn ; Set it for the other routine
		Call TypJfn	; Type out the name
		Jrst .+2 ]
	Jrst [	Tmsg < Not logging output>
		Jrst .+1 ]

	Tmsg <
 Output is >			; Start of message

	TstWOf HidFlg		; Are we hiding?
	 Jrst [	Tmsg <not >	;  We are not, say so ...
		Jrst .+1 ]	; Move on ...

	Tmsg <being hidden
 Escape character is control->	; Start of message
	Move t1, TrpChr		; Get trap character
	AddI t1, 100		; Turn it into capital counterpart
	PBOUT%			; Type it

	Tmsg <
 Terminal type is >
	Move t1, VtType		; Get terminal type
	CaiN t1, Vt100		; Is it Vt100?
	 Jrst [	Tmsg <VT100
  ... >
		SkipN Flash	; Do we flash?
		 Call [ Tmsg <No Flash (screen on bell)
  ... padding is >
			Ret ]
		SkipGE Flash
		 Call [	Tmsg <Flash White (then black)
  ... padding is >
			Ret ]
		SkipLE Flash
		 Call [	Tmsg <Flash Black (then white)
  ... padding is >
			Ret ]
		Move t3, PadAmt	; Get current padding amount
		CaiN t3, -1	; This value?
		 Jrst [	Tmsg <Half>
			Jrst InfTag ]
		CaiN t3, -2	; This value?
		 Jrst [	Tmsg <Quarter>
			Jrst InfTag ]
		CaiN t3, 1	; This value?
		 Jrst [	Tmsg <Double>
			Jrst InfTag ]
		CaiN t3, -17	; This value?
		 Jrst [	Tmsg <None>
			Jrst InfTag ]
		Tmsg <Full>
		Jrst InfTag ]
	CaiN t1, Vt52		; Is it Vt52?
	 Jrst [	Tmsg <VT52>
		Jrst InfTag ]
	CaiN t1, Im3101		; Is it IBM 3101?
	 Jrst [	Tmsg <IBM-3101>
		Jrst InfTag ]
	Tmsg <Hard-Copy>	; Else, assume hard copy

InfTag:	Tmsg <
 >
	TstWOf ShoBel		; Do we show bells?
	 Jrst [	Tmsg <Don't >
		Jrst .+1 ]
	Tmsg <Indicate Bells (in subjob output)
 >

	SkipE ExecFk		; Is there a lower fork?
	 Jrst [	Tmsg <Pushed EXEC exists
  ... EXEC is >
		TmsgS (ExecNm)
		Jrst .+2 ]
	Jrst [	Tmsg <No pushed EXEC
  ... default EXEC is >
		TmsgS (ExecNm)
		Jrst .+1 ]

	SkipL Editor		; Is there an editor?
	 Jrst [	Tmsg <
 EMACS fork is loaded>
		Jrst .+2 ]
	Jrst [	Tmsg <
 No EMACS fork>
		Jrst .+1 ]

	SkipN t4, RedInt	; Is there an interval?
	 Jrst [	Tmsg <
 No Auto-Redisplay interval>
		Jrst .+2 ]
	Jrst [	Tmsg <
 Auto-Redisplay interval is >
		Move t2, t4	; Copy over ...
		IDivI t2, <1000000 / ^d<24*60> > ; Convert back to minutes
		MoveI t1, .PriOu ; Primary output
		MoveI t3, ^d10	; Decimal
		NOUT%		; Type the number
		 JEcBug (HLT,<Can't type interval>)
		Tmsg < minutes>
		Jrst .+1 ]

	Tmsg <
 Pause-on-Command is >

	SkipN PauCom		; Page mode?
	 Jrst [	Tmsg <off>	;  No ...
		Jrst .+2 ]
	Jrst [	Tmsg <on>
		Jrst .+1 ]
	Tmsg <
 >				; CrLf and a space ...
	SkipE OneWin		; Are we in one-window mode?
	 Jrst [	Tmsg <One>
		Jrst .+2 ]
	Jrst [	Tmsg <Multi>
		Jrst .+1 ]

	Tmsg <-Window-Mode
 >

	TstWOf ConFlg		; Are we continuing halted forks?
	 Jrst [	Tmsg <No >	;  No, say not
		Jrst .+1 ]

	Tmsg <Continue-Halted-Forks> ; End of message

InfEnd:	Tmsg <

>				; The final two CrLf's

	RetSkp			; Done

	SubTtl Keep command -- Keep output from subjob

Keep:	Call GetSjb		; Get the subjob ID
	 Ret			;  Failed

	MovX t2, PtDisF		; The Discard flag

	SkipGE i		; If user said 'All' ...
	 SetZM DisAll		;  Mark that a 'Keep ALL' was done

	Jrst ClrBit		; Go clear the bit for any indicated subjobs

	SubTtl Kill command -- Kill a subjob

Kill:	CmNoi <window>		; Noise words
	MoveI t2, SbnFdb	; 'All' is ok, but not the default
	Call PrsSjb		; Parse for a subjob name
	 Ret			;  Didn't get one
	CmCfm			; Confirm

	SkipG SjCnt		; Are there any subjobs?
	 Jrst [	Tmsg < [Nothing to kill]

>				; Make note of the triviality of this command
		RetSkp ]	;  and return

	JumpL i, KilAll		; If the user said all, go kill them

	Call KilWin		;  He gave a subjob name, so kill this one job
	Jrst KilDon		; That's it ...

KilAll:	Call FrstSj		; Get first i
	 Jrst KilDon		;  no more

	Call KilWin		; Kill this window

	Jrst KilAll		; Go kill the new first subjob

KilDon:	Tmsg <
>				; Skip a line ...
	RetSkp			;  and return


; Kill one window, and remove all traces of it

KilWin:	SkipE PtyFrk(i)		; Is it a fork?
	 Jrst [	MoveM i, KilFrk ;  Yes, flag what to kill for higher fork
		Jrst KjbClo ]	; Don't want to log it out ...

	Hrl t1, PtyTtd(i)	; Get tty number for this subjob
	TxZ t1, 1b0		; Turn off tty designator
	Hrr t1, TtyJob		; Get TtyJob table number for GETAB%
	GETAB%			; Get job number associated with tty
	 Jrst KjbClo		; Failed

	HlrES t1
	JumpL t1, KjbClo	; If -1 or -2, then no job

	LGOUT%			; Log this job out
	 Jrst [	Tmsg <
% Could not LOGOUT subjob >
		Call TypNam
		Call Tp2Ret
		Jrst .+1 ]	; See if we can do anything else

	;continued on next page
	;continued from previous page

	MoveI t3, ^d20		; We will check at most this many times ...
KjbLop:	HrlZ t1, PtyTtd(i)	; Get tty number
	TxZ t1, 1b0		; Turn off tty designator
	Hrr t1, TtyJob		; Get TtyJob table number for GETAB%
	GETAB%			; Get job number associated with tty
	 Jrst KjbClo		; Failed

	HlrES t1
	JumpL t1, KjbClo	; If -1 or -2, then no job

	MoveI t1, ^d100		; We want to wait this long to give the
	DISMS%			;  "Killed" message a chance to show up ...

	SojG t3, KjbLop		; Go see if it is dead yet

KjbClo:	MoveI t1, ^d500		; This many milliseconds ...
	DISMS%			; Wait that long ...

	CamN i, Editor		; Killing editor?
	 Jrst KjbTag		;  Yes, he types his own message ...

	Tmsg < [Killed sub>	; Start ...
	SkipE PtyFrk(i)		; Is it a fork?
	 Jrst [	Tmsg <fork >	;  Yes ...
		Jrst .+2 ]
	 Jrst [	Tmsg <job >	; No ...
		Jrst .+1 ]
	Call TypNam
	Tmsg <]
>

KjbTag:	UnLock			; Make the kill happen now ...

	Lock			; Lock the structures

	CamN i, LstCon		; Check if we are killing the last connected
	 SetOM LstCon		;  Yes we are, so there is no last connected

	Move t1, SjList		; Get ptr to subjob list
	MoveI t2, SjList	; Get addr of where to put ptr
KjbLp1:	Move t3, 1(t1)		; Get subjob number
	CaiN t3, 0(i)		; Is this the one?
	 Jrst [	Hrr t3, 0(t1)	;  Yes, get forward ptr from this node
		HrrM t3, 0(t2)	; Store it as forward ptr from prev node
		CaiN t2, SjList	; Is the "prev" node really the SjList ptr?
		 SetZ t2,	;  Yes, so zero the ptr to it
		SkipE t3	; If there is a next node ...
		 HrlM t2, 0(t3)	;  set the back ptr in it to point to prev node
		Jrst KjbEn1 ]	; All done with node removal
	MoveI t2, 0(t1)		; Copy over the old ptr
	HrrZ t1, 0(t1)		; Advance the ptr
	JumpN t1, KjbLp1	; If we have a good ptr, all is ok, so loop
	Bug (HLT,<Window we want to kill isn't on subjob list>)

	;continued on next page
	;continued from previous page

; Done removing the subjob from SjList, now update the display

KjbEn1:	Call GivSp2		; Give back the space from the node

	Move p1, PtyLoL(i)	; Get ptr to lowest line on virtual screen
KjbLp2:	HrrZ p2, .BkwPt(p1)	; Grab back ptr from it, if any
	MoveI t1, 0(p1)		; Copy over the addr of the line node
	Call GivSp2		; Give back the space used by this line node

	SkipE p1, p2		; Copy over the ptr, see if non-zero
	 Jrst KjbLp2		;  It is non-zero, so loop more more

	Move t1, PtyJfn(i)	; Get this job's jfn
	MoveM t1, CloJfn	; Say we want to close the jfn for this sj

	Call DelSub		; Remove name pointers, and retrieve space

	SetFOn StrChg		; Say that structure changed, need new lists

	CamE i, Editor		; Killing editor?
	 Sos SjCnt		;  No, decrement the subjob count

	Unlock			; Let it all happen now ...

	Ret			; Done here

	SubTtl Log command -- Set up a log file

Log:	CmNoi <output to file>	; Noise words

	Call GjfRes		; Reset most of the GTJFN block
	HrrOI t4, [AsciZ/Window/] ; Default filename
	MoveM t4, .GjNam(t3)	; Store it
	HrrOI t4, [AsciZ/Window-Log/] ; Default extension
	MoveM t4, .GjExt(t3)	; Store it
	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmFil,Cm%Sdh,,<file to log output to>)]
				; Parse for an output file
	COMND%			; Go get the jfn, if we can
	 .NpRp BadLog, R	; Handle bad file name here, return on reparse
	HrrZM t2, HldJfn	; Store the jfn we got

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CfmFdb	; FDB for confirm
	COMND%			; Confirm the command
	 .NpRp ClrLog, FixLog	; Handle no-confirm here, unget jfn if reparse
	SkipE LogJfn		; Is there an open file to close?
	 Jrst [	Tmsg < [Closed log file > ; Yes, so type the start of message
		Move t1, LogJfn	; Get the jfn
		MoveM t1, TheJfn ; Set it up to type out
		Call TypJfn	; Type the name
		Tmsg <]
>				; End the message
		Jrst .+1 ]	;  and return to the stream
	Tmsg < [Beginning logging to >
	Move t1, HldJfn		; Get the new logging jfn
	MoveM t1, TheJfn	;  and set it as the jfn to type
	Call TypJfn		; Go type out the file name
	Tmsg <]

>				;  and close out the message

	;continued on next page
	;continued from previous page

	Lock

	SkipE t1, LogJfn	; Get old jfn if any
	 Jrst [	CLOSF%		;  Close the file
		 Trn		;  Ignore any error
		Jrst .+1 ]	;  and rejoin the stream

	Move t1, HldJfn		; Get the new log file jfn
	MoveM t1, LogJfn	;  and save it as the jfn

	MovX t2, Fld(7, Of%Bsz) ! Of%Wr ! Of%App ; 7 bit bytes, write & append
	OPENF%			; Try to open the file
	 Jrst [	Unlock
		.JerMs <Can't open file> ; Failed, complain
		Move t1, LogJfn	; Get the jfn
		RLJFN%		; Release it
		 Trn		;  Ignore the error
		Ret ]		;  and return

	HrrOI t2, [AsciZ/
<-----------                     ------------                     ----------->
    Window log file  --  /]
	SetZ t3, 
	SOUT%			; Send out header
	SetO t2,		; Now send out the date
	ODTIM%
	HrrOI t2, [AsciZ/

/]
	SOUT%
	Unlock
	RetSkp			; Return

BadLog:	SetO t1,		; Use most recent error
	.JerMs <Can't get handle on file> ; Complain
	Ret			;  and return

ClrLog:	.LeftM			; Get to left margin
	Tmsg <? Not confirmed

>				; Complain

FixLog:	Move t1, HldJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			;  Ignore the error
	Ret			;  and return

	SubTtl Logout command -- Logout this job, but confirm first

Logout:	CmNoi <this job>	; Noise
	CmCfm			; Confirm

	Tmsg < Logout command -- Please confirm your desire to log out
>				; Start of message

	Call CfmRes		; Reset the confirm-only command state block
	MoveI t1, CfmCsb	; Addr of confirmation-only state block
	MoveI t2, IniFdb	; Initialize it
	COMND%			; Do it
	 JEcBug (HLT,<COMND failed>)

	MoveI t2, CfmFdb	; Confirm with carriage return ...
	COMND%			; Do it
	TxNE t1, Cm%Nop ! Cm%Rpt ; If any parse error
	 Jrst LgoNop		;  then don't confirm

	Call Tp1Ret		; Another CrLf (to separate the next message)

	Tmsg < [Confirmed]
>				; A message ...

	MoveI t1, .PriOu	; Terminal
	DOBE%			; Wait till quiet

	MoveI t1, ^d1000	; This many milliseconds
	DISMS%			; Wait that long ...

	SetFOn WntLgo		; Say we want this
	UnLock			; Kick him

LgoNop:	.LeftM			; Get to left margin
	Tmsg <
% LOGOUT not confirmed>		; Type a non-confirmation message
	Jrst Tp2Ret		; Return ...

	SubTtl No command -- Negate the meaning of the next command

NoComm:	MoveI t1, CmdCsb	; Addr of the command state block
	MoveI t2, [FldDb. (.CmKey,,CmdNTb,<negatable Window command,>)]
	COMND%			; Do it
	 .NpRp NoCoNp, R	; Fix 'no parse' locally, return on 'reparse'

	MoveM t2, Comnd2	; Save second word we got

	SetOM NoFlag		; Set the NO flag

	HrrZ t2, 0(t2)		; Get the dispatch addr
	Jrst 0(t2)		; Dispatch to the routine

NoCoNp:	Pop p, 0(p)		; Flush the return addr from the stack
	Jrst ComErr		; Handle as a normal command error

	SubTtl No Log command -- Stop logging and close the log file

NoLog:	CmNoi <output to file>	; Noise words
	CmCfm			; Confirm

	SkipN LogJfn		; Is there an open jfn?
	 Jrst [	Tmsg < [No log file open]

>
		RetSkp ]	; No jfn, so just return

	Tmsg < [Closed log file > ; Start of message
	Move t1, LogJfn		; Get the jfn
	MoveM t1, TheJfn	; Set it up to type out
	Call TypJfn		; Type the name
	Tmsg <]

>				; End of message

	Lock

	HrrZ t1, LogJfn		; Get JFN of log file

	CLOSF%			; Close it
	 Jrst [	Unlock
		.JerMs <Can't close log file> ; Complain

		Move t1, LogJfn	; Get jfn for log file
		RLJFN%		; Release it
		 Trn		; Ignore the error
		SetZM LogJfn	; Erase the jfn

		Ret ]		;  and return

	SetZM LogJfn		; Clear JFN word

	Unlock

	RetSkp			; Return

	SubTtl Order -- Order (of windows) command

Order:	CmNoi <of windows is>	; Noise words

	Lock

	MoveI t2, MaxPty	; Size of block we need
	Call GetSp2		; Get the block
	Move p4, t1		; Hold addr of starting block

	Call GetSp2		; Get another block of the same size
	Move p5, t1		; Remember its location also

	MoveI t2, SjbLen+1	; Get size we might need in a subjob table
	Call GetSp2		; Get a block of that size
	Move p3, t1		; Save addr in p3

	Unlock

	SetZ p1,		; Clear count of old subjobs
	Push p, p4		; Save addr of old block
	Call FrstSj		; Get first sj
	 Jrst OrdTg1		;  None, skip on down ...

OrdLp1:	MoveM i, 0(p4)		; Store this one in the table
	Aoj p1,			; Bump count

	Call NextSj		; Get number of next sj
	 TrnA			;  None ...
	  AojA p4, OrdLp1	;   Bump location, loop

OrdTg1:	Pop p, p4		; Get back start of old block
	SetZ p2,		; Clear count of new subjobs

; Either build a new table, or confirm the command

OrdTab:	SkipN p1		; Are there any subjobs left?
	 Jrst [	Push p, [Clean]	; If CmCfm returns, do a Clean first ...
		CmCfm		; Confirm
		Pop p, 0(p)	; Flush the extra return we put in ...
		Jrst OrdSet ]	; Go set the new order now

	MoveI t1, SjbLen	; Get 0,,size in t1
	MoveM t1, 0(p3)		; Save as what is in this subjob table

	SetZ t3,		; Clear index into old subjob list

	Push p, p4		; Save start of block
OrdLp3:	CaiL t3, 0(p1)		; Is there a subjob in this slot?
	 Jrst OrdTg3		;  No ...

	Move i, 0(p4)		; Pick up the subjob number

	Hrl t2, PtyNam(i)	; Get addr of primary name
	Hrr t2, i		; Copy over subjob number
	MoveI t1, 0(p3)		; Addr of subjob table we are building
	TBADD%			; Add the primary name to the table
	 JEcBug (HLT,<Can't add name to table>)

	SkipE PtyNm2(i)		; Is there a second name?
	 Jrst [	Hrl t2, PtyNm2(i) ;  Yes, get addr of secondary name
		Hrr t2, i	; Copy over subjob number
		MoveI t1, 0(p3)	; Addr of subjob table we are building
		TBADD%		; Add the primary name to the table
		 JEcBug (HLT,<Can't add name to table>)
		Jrst .+1 ]	;  return to stream

	Aoj p4,			; Bump ptr into old  list
	AojA t3, OrdLp3		; Bump index and loop

OrdTg3:	Pop p, p4		; Restore start of block

	MoveI t2, SboFdb	; Addr of FDB to use
	MoveM p3, .CmDat(t2)	; Set new table addr
	Move i, 0(p4)		; Default subjob will be first one in list
	Hrro t1, PtyNam(i)	; Ptr to name
	MoveM t1, .CmDef(t2)	; Set the default

	Call PrsSjb		; Get subjob id
	 Jrst Clean		;  Clean up, return from there

	Push p, p5		; Save addr of new list
	AddI p5, 0(p2)		; Addr of next unused slot
	MoveM i, 0(p5)		; Save it in the new list
	Aoj p2,			; Bump the count of items in new list
	Pop p, p5		; Restore addr of new list

	Push p, p4		; Save addr of old list
	Push p, p1		; Save count also

OrdLp4:	Soj p1,			; Decr the count ...
	CamE i, 0(p4)		; Found this one in the old list?
	 AojA p4, OrdLp4	;  No, bump the ptr and loop

	JumpG p1, [	Hrr t4, p4 ; Addr to copy to
			Aoj p4,	; Next word
			Hrl t4, p4 ; Addr to copy from
			Add p4, p1 ; Add in the size of what has to be moved
			Blt t4, -2(p4) ; Copy down the block
			Jrst .+1 ] ; Return to stream

	Pop p, p1		; Restore original count
	Pop p, p4		; Restore start of old list

	SojA p1, OrdTab		; Decr count in old list, go do a new table
				;  or a confirm ...

OrdSet:	Move t1, SjList		; Ptr to old subjob list
	Lock			; Lock it up tight first ...

OstLp1:	HrrZ p1, 0(t1)		; Get forward ptr from this node
	Call GivSp2		; Release this node
	MoveI t1, 0(p1)		; Copy over the forward ptr
	JumpN t1, OstLp1	; If more nodes, give them back too

	MoveI t2, 2		; Need 2 words
	Call GetSp2		; Get them
	MoveM t1, SjList	; Set ptr to start of list
	SetZM 0(t1)		; No forward of backward ptrs yet
	SetZM 1(t1)		; Subjob number for WCL is zero

	Push p, p5		; Save addr of start of new list

OstLp2:	JumpLE p2, OstDon	; If no subjobs left in new list, done here
	MoveI p1, 0(t1)		; Save the ptr to this node
	Call GetSp2		; Get a new node

	HrlZM p1, 0(t1)		; Set back ptr in new node
	HrrM t1, 0(p1)		; Set forward ptr in prev node
	Move i, 0(p5)		; Pick up the subjob number
	MoveM i, 1(t1)		; Set it in the new node

	Soj p2,			; Decr count of subjobs in new list
	AojA p5, OstLp2		; Bump ptr into list and loop

OstDon:	Pop p, p5		; Restore addr of new list

	SetFOn StrChg		; Say we need a new visible list
	UnLock

	Call Clean		; Go clean up before leaving ...

	Tmsg < [Order set]

>				; A simple message to say what happened ...

	RetSkp			; Return happily

Clean:	Lock

	MoveI t1, SjbTab	; Addr of real subjob table
	MoveI t2, SboFdb	; Addr of FDB we used
	MoveM t1, .CmDat(t2)	; Set the proper addr

	Move t1, p3		; Addr of one block to release
	Call GivSp2		; Give it back

	Move t1, p4		; Another block we got
	Call GivSp2		; Release it too

	Move t1, p5		; The final block
	Call GivSp2		; Give it back also

	Unlock
	Ret

	SubTtl Push command -- Push down to a lower EXEC

PushE:	CmNoi <to lower EXEC>	; Noise words

	SkipE ExecFk		; Is there already a lower fork?
	 Jrst [ CmCfm		; We already have an EXEC fork ...
		Tmsg < [Pushing to existing lower EXEC]

>				; End of the message
		Jrst PshGot ]	; All set ...

	Call SetGjf		; Go set up the GTJFN block to get the EXEC

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, ExcFdb	; The FDB to use
	COMND%			; Go get the jfn, if we can
	 .NpRp BadPsh, R	; Handle bad file name here, return on reparse

	HrrZM t2, HldJfn	; Store the jfn we got

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CfmFdb	; FDB for confirm
	COMND%			; Confirm the command
	 .NpRp ClrPsh, FixPsh	; Handle bad file name here, unget jfn if
				;  reparse needed, then return

	;continued on next page
	;continued from previous page

	Lock

	Move t1, HldJfn		; Pick up the jfn
	MoveM t1, ExcJfn	; Store it here

	HrrOI t1, ExecNm	; Pointer to where to put the name
	Move t2, ExcJfn		; The jfn
	MovX t3, Fld(.JsAof, Js%Dev) ! Fld(.JsAof, Js%Dir) ! 
		 Fld(.JsAof, Js%Nam) ! Fld(.JsAof, Js%Typ) ! 
		 Fld(.JsAof, Js%Gen) ! Js%Paf ; The full name
	SetZ t4,		; No prefix
	JFNS%			; Get the jfn into a file name
	 JEcBug (HLT,<JFNS failed>)

	Unlock

PshTag:	Tmsg < [Pushing to >	; Start of message
	TmsgS (ExecNm)		; The EXEC name ...
	Tmsg <]

>				; End of message

PshGot:	MoveI t1, .PriOu	; Primary output
	DOBE%			; Wait until quiet ...

	MoveI t1, ^d1000	; This many milliseconds
	DISMS%			; Wait that long ...

	SetFOn WntPsh		; Say "Push Me" 
	UnLock			; Unlock to make it happen

	RetSkp			; Return to the command level

ClrPsh:	.LeftM			; Psh to left margin
	Tmsg <? Not confirmed

>				; Complain

FixPsh:	Move t1, HldJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			;  Ignore the error
	Ret			;  and return

BadPsh:	SetO t1,		; Want the most recent error
	.JerMs <Can't get handle on file> ; Do the message
	Ret			;  and return

	SubTtl Redefine command -- Change the Window escape character

; Routine to change the Window escape character

Redefi:	CmNoi <Window escape character to be> ; Noise words

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmTxt,Cm%Sdh,,<control character>)]
	COMND%			; Do it
	 .NpRp BadRed, R	; Handle bad here, return on reparse

	CmCfm			; Then wait for confirmation

	HrrOI t1, CmdAtm	; Point to the atom buffer
	BIN%			; Pick up the first character

	AndI t2, 177		; Keep only ASCII bits, no parity

	JumpE t2, [ Tmsg <? No character entered

>
		    Ret ]	; No char, complain and return

	BIN%			; Get a second character

	AndI t2, 177		; Keep only ASCII bits, no parity

	JumpN t2, [ Tmsg <? Too many characters entered

>
		    Ret ]	; Too many, complain and return

	HrrOI t1, CmdAtm	; Point to the character again
	BIN%			; Pick it up again

	AndI t2, 177		; Keep only ASCII bits, no parity

	;continued on next page
	;continued from previous page

	Move t1, t2		; Copy the character into reg t1

	CaiE t1, .ChTab		; Don't allow it to be tab
	 CaiLE t1, "Z"-100	;  and it must be a control-alphabetic
	  Jrst BadRed		; Illegal

	CaiE t1, .ChCnC		; Not control-C
	 CaiN t1, .ChCnO	;  nor control-O
	  Jrst BadRed

	CaiE t1, .ChLfd		; No line feed ...
	 CaiN t1, .ChCrt	;  or carriage return
	  Jrst BadRed

	CaiN t1, .ChFfd		; ... or form feeds
	 Jrst BadRed

	Lock
	MoveM t1, TrpChr	; Save the trap char
	Unlock

	Tmsg < [Escape character is now ^> ; Start of message
	Move t1, TrpChr		; Get the real character
	AddI t1, 100		; Make it Ascii counterpart
	PBOUT%			; Type the byte
	Tmsg <]

>				; End of message

	RetSkp			;  and return

BadRed:	ErrMes <? Illegal Window escape character>
	Ret			; Return NG

	SubTtl Redisplay command -- Blank the screen, then redisplay it all

Redisp:	CmNoi <screen>		; Noise ...

	SkipN VtType		; Are we on a video terminal?
	 Jrst [	.LeftM		;  No, complain ...
		Tmsg <
% Can't redisplay screen on hardcopy terminal>
		Jrst Tp2Ret ]	; 2 CrLf's, then return

	CmCfm			; Confirm

	Lock			; Lock resources
	SetFOn ClearF		; Set this flag
	UnLock			; Update the display

	Tmsg < [Screen redisplayed]

>				; A message ...

	RetSkp			; And return good

	SubTtl Refuse command -- Refuse output from subjobs

Refuse:	Call GetSjb		; Get the subjob ID
	 Ret			;  Failed

	MovX t2, PtRefF		; The Refuse flag

	SkipGE i		; If user said 'All' ...
	 SetOM RefAll		;  Mark that a 'Refuse All' was done

	Jrst SetBit		; Go set the bit for any indicated subjobs

	SubTtl Rename command -- Change the name(s) of a window

Rename:	CmNoi <window>		; Noise
	MoveI t2, SboFdb	; Addr of FDB to use
	Call SetDef		; Use a default if we can
	Call PrsSjb		; Get a subjob name
	 Ret			;  A problem
	Move p2, i		; Save subjob number in p2
	CmNoi <to be>		; Noise

	MoveI t1, CmdCsb	; The command state block
	MoveI t2, DefFdb	; Use changable FDB
	SetZM .CmDef(t2)	; No default ...
	COMND%			; Do it
	 .NpRp DsuBad, R	; Handle errors

; Here when user has entered the first subjob name into the atom buffer

	MoveI p3, CmdAtm	; Addr of name to test for
	HrlI p3, (Point 7,0)	; Make it a byte ptr
	Ildb t1, p3		; Pick up the first byte
	JumpE t1, [ .LeftM	; Null name, don't let him do it
		    Tmsg <? No name specified

>
		    Ret ]	; That's it

	MoveI p3, CmdAtm	; Addr of name to test for
	Call ChkAll		; Is it 'All'?
	 Ret			;  Yes, return NG

	Call ChkDsh		; Does it have any dashes in it?
	 Ret			;  Yup, no good

	;continued on next page
	;continued from previous page

	SetZ p1,		; Just check for feasibility of adding

	Call AddSub		; Test if it can be added
	 Jrst [	.LeftM		; Failed, get to left margin
		Tmsg <? Window >
		TmsgS CmdAtm
		Tmsg < is already defined.

>				; Complain
		Ret ]		;  and return NG

	Move i, p2		; Get back the subjob ID (AddSub clobbered it)

	Move t1, [CmdAtm,, CmdAtm + AtmLen/2] ; BLT the name to the top half
	Blt t1, CmdAtm + AtmLen - 1

	CmNoi <alias>		; Noise words

	MoveI t1, CmdCsb	; Again
	MoveI t2, AltCfm	; Use alternate FDB
	COMND%			; Do it
	 .NpRp DsuBad, R	; Handle errors
	HrrZS t3		; Get addr of FDB used
	CaiE t3, AltCfm		; Is it a name?
	 Jrst RenAlt		;  Yes, go handle it

; Here when user has entered a single name and confirmed

	Tmsg < [Window >	; Start of message
	Call TypNam		; The old name(s)
	Tmsg < renamed to be >	; Middle of message

	Lock

	Move p3, PtyNam(i)	; Get addr of old name
	Call DlsNam		; Delete the name and give back its space
	SetZM PtyNam(i)		; Clobber ptr to old name

	SkipE p3, PtyNm2(i)	; Was there an alternate name?
	 Jrst [	Call DlsNam	;  Yes, delete this name too
		SetZM PtyNm2(i)	; Clobber ptr to it
		Jrst .+1 ]	; Return to stream

	SetO p1,		; Try to insert
	MoveI p3, CmdAtm + <AtmLen/2> ; Addr of name to be added
	Call AddSub		; Try to add this subjob ID
	 Bug (CHK,<Can't add a name that should be addable>)

	Jrst RenDon		; Use common finish-up code

	;continued on next page
	;continued from previous page

; Here when user has entered the second subjob name into the atom buffer

RenAlt:	CmCfm			; Confirm

	Call ChkAll		; Is it 'All'?
	 Ret			;  Yes, return NG
	Call ChkDsh		; Does it have any dashes in it?
	 Ret			;  Yup, no good
	Call AddSub		; Test if it can be added
	 Jrst [	.LeftM		; Failed, get to left margin
		Tmsg <? Window >
		TmsgS CmdAtm
		Tmsg < is already defined.

>				; Complain
		Ret ]		;  and return NG

	Move i, p2		; Get back the subjob ID (AddSub clobbered it)

; We know that both names are addable, so add them

	Tmsg < [Window >	; Start of message
	Call TypNam		; The old name(s)
	Tmsg < renamed to be >	; Middle of message

	Lock

	Move p3, PtyNam(i)	; Get addr of old name
	Call DlsNam		; Delete the name and give back its space
	SetZM PtyNam(i)		; Clobber ptr to old name

	SkipE p3, PtyNm2(i)	; Was there an alternate name?
	 Jrst [	Call DlsNam	;  Yes, delete this name too
		SetZM PtyNm2(i)	; Clobber ptr to it
		Jrst .+1 ]	; Return to stream

	SetO p1,		; Try to insert
	MoveI p3, CmdAtm	; Location of alternate name
	Call AddSub		; Add the alternate name first
	 Bug (CHK,<Can't add a name that should be addable>)
	MoveI p3, CmdAtm + <AtmLen/2> ; Then add the primary name
	Call AddSub		; Try to add this subjob ID
	 Bug (CHK,<Can't add a name that should be addable>)

RenDon:	SetZM PtyBtm(i)		; Force a banner update
	UnLock			; Update the screen to get new banner

	Call TypNam		; Type the names

	Tmsg <]

>				; Tail of message
	RetSkp			; Return

	SubTtl Reset command -- Undo something

ResetC:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,ResTab,<item to Reset,>)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse

	HrrZ t2, 0(t2)		; Get addr of routine to run
	Jrst 0(t2)		; Dispatch to the routine

ResNop:	Pop p, 0(p)		; Flush return addr
	Jrst ComErr		; Handle as normal command error

	SubTtl Reset EMACS-fork

ResEma:	CmCfm			; Confirm
	SkipG i, Editor		; If there is no editor fork ...
	 Jrst [	Tmsg < [No EMACS-fork to reset]

>				; Complain ...
		RetSkp ]	; Return OK

	Call KilWin		; Use this routine to do it ...

	SetOM Editor		; There is now no editor fork

	Tmsg < [EMACS has been reset]> ; Say what we did ...
	Jrst Tp2Rsk		; 2 CRLFs, then RetSkp

	SubTtl Reset EXEC-filename

ResXec:	SkipE ExecFk		; Do we already have a lower fork?
	 Jrst [	.LeftM		; Left margin
		Tmsg <? Lower fork exists ... reset it first

>
		Ret ]		; Return ...

	CmCfm			; Confirm

	Lock

	Move t1, ExcJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			; Ignore error

	SetZM ExcJfn		; Forget we ever had this jfn

	SetZM ExecNm		; Clobber the old name ...
	Call GetXjf		; Get a new jfn

	Move t1, ExcJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			; Ignore error

	SetZM ExcJfn		; Forget we ever had this jfn

	Unlock

	Tmsg < [Default EXEC filename has been reset to > ; Start of message
	TmsgS (ExecNm)		; The name of the EXEC (as we stored it)
	Tmsg <]

>				; A little message to say what we did

	RetSkp			; Done here

	SubTtl Reset pushed EXEC

ResPsh:	CmCfm			; Confirm
	SkipN  ExecFk		; If there is no lower fork ...
	 Jrst [	Tmsg < [No lower EXEC]

>				; Complain ...
		RetSkp ]	; Return OK

	Lock
	SetOM KilPsh		; Tell superior to do this
	UnLock

	Tmsg < [Lower EXEC reset]

>				; Say what we did ...
	RetSkp			;  and return good

	SubTtl ResWin -- Reset Window X (parameters)

ResWin:	MoveI t2, SbaFdb	; Subjob, or 'All'
	Call PrsSjb		; Parse for a subjob ID
	 Ret			; Problem

	CmNoi <parameters>	; Noise ...

	CmCfm			; Confirm

	MoveI p1, RwnJob	; The Reset Window routine
	Call EachSj		; Do it for each subjob
	Tmsg <
>				; Skip a space after the list ...
	RetSkp			;  and return

	SubTtl RwnJob -- Reset Window X (parameters) for a single window

RwnJob:	Lock

	SetOM PtySiz(i)		; Set size floating

	MovX t1, PtDisF ! PtRefF ! PtInvF ! PtNobF ! PtTraF
	AndCam t1, PtySts(i)	; Clear these attributes

	SetFOn StrChg		; Say something changed
	SetZM PtyBtm(i)		; Force a banner update
	UnLock			; Update the screen to show the changes

	Tmsg < [Window >	; Start of message
	Call TypNam		; Type the name
	Tmsg < parameters reset]
>				; End of message
	Ret			; Return

	SubTtl Restrict command -- Restrict some Window function

Rstrct:	CmNoi <window function>	; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmKey,,RstTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	;  Fix no-parse, ret on error

	HrrZ p1, 0(t2)		; Copy over the answer

	CmCfm			; Confirm

	IOrM p1, Restri		; Restict this function

	Tmsg < [Ok]>
	Jrst Tp2Rsk		; Done here

	SubTtl Set command -- Set various parameters

SetCom:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,SetTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse

	MoveM t2, Comnd2	; Save second word we got

	HrrZ t2, 0(t2)		; Get addr of routine to run
	Jrst 0(t2)		; Dispatch to the routine

	SubTtl Set Auto-Redisplay (interval to) command

SetARd:	CmNoi <interval to>	; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmNum,Cm%Sdh, 
		^d10,<number of minutes between automatic screen refreshs, 1 to 60>)]
	COMND%			; Get the number
	 .NpRp ResNop, R	;  On error ...
	Move t4, t2		; Save the number we got

	CmNoi <minutes>		; More noise
	CmCfm			; Confirm

	JumpLE t4, [ Tmsg <% Ignored ...> ; Message
		     Jrst Tp2Rsk ] ; Two CrLfs, retskip

	CaiLE t4, ^d60		; Less than or equal to sixty seconds?
	 Jrst [	Tmsg <% Redisplay interval reduced to 60 minutes ...
>				; Message ...
		MoveI t4, ^d60	; Load up the limit
		Jrst .+1 ]	; Move on ...

	Tmsg < [Auto-Redisplay interval will be >

	MoveI t1, .PriOu	; Primary output
	MoveI t2, 0(t4)		; Get time
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type new margin size>)

	Tmsg < minutes]>	; End of message

	IMulI t4, <1000000/ ^d<24*60> >	; Convert minutes to GTAD% form
	MoveM t4, RedInt	; Store this away

	Jrst Tp2Rsk		; Standard close

	SubTtl Set No Auto-Redisplay command

SetNAr:	CmCfm			; Confirm

	SkipN t4, RedInt	; Was there an interval?
	 Jrst [	Call AlrSet	;  No, say this is already set up
		RetSkp ]	; Done here

	Tmsg < [Interval was >	; Start of message

	Move t2, t4		; Copy over ...
	IDivI t2, <1000000 / ^d<24*60> > ; Convert back to minutes
	MoveI t1, .PriOu ; Primary output
	MoveI t3, ^d10	; Decimal
	NOUT%		; Type the number
	 JEcBug (HLT,<Can't type interval>)

	Tmsg < minutes]>	; End of message

	SetZM RedInt		; Set the interval to zero

	Jrst Tp2Rsk		; Done here ...

	SubTtl SetXec -- Set EXEC-filename command

SetXec:	SkipE ExecFk		; Do we already have a lower fork?
	 Jrst [	.LeftM		; Left margin
		Tmsg <? Lower fork exists ... reset it first

>
		Ret ]		; Return ...

	CmNoi <to be>		; Noise

	Call SetGjf		; Go set up the block

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, ExcFdb	; Parse for a jfn
	COMND%			; Go get the jfn, if we can
	 .NpRp BadPsh, R	; Handle bad file name here, return on reparse

	HrrZM t2, HldJfn	; Store the jfn we got

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CfmFdb	; FDB for confirm
	COMND%			; Confirm the command
	 .NpRp ClrPsh, FixPsh	; Handle bad file name here, unget jfn if
				;  reparse needed, then return

	Lock

	Move t1, Hldjfn		; Pick up the new jfn
	MoveM t1, ExcJfn	; Save it for later

	HrrOI t1, ExecNm	; Pointer to where to put the name
	Move t2, ExcJfn		; The jfn
	MovX t3, Fld(.JsAof, Js%Dev) ! Fld(.JsAof, Js%Dir) ! 
		 Fld(.JsAof, Js%Nam) ! Fld(.JsAof, Js%Typ) ! 
		 Fld(.JsAof, Js%Gen) ! Js%Paf ; The full name
	SetZ t4,		; No prefix
	JFNS%			; Get the jfn into a file name
	 JEcBug (HLT,<JFNS failed>)

	Move t1, ExcJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			;  Ignore error ...

	SetZM ExcJfn		; Then forget we ever had one ...

	Unlock

	Tmsg < [Default EXEC will be > ; Start of message ...
	TmsgS (ExecNm)		; The name of the EXEC (as we stored it)
	Tmsg <]

>				; A little message to say what we did

	RetSkp			; Done here

	SubTtl SetFla -- Set Flash command

SetFla:	CmNoi <screen on bell>	; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmKey,,FlaTab,,<White>)]
	COMND%			; Get the keyword
	 .NpRp ResNop, R

	HrrE p1, 0(t2)		; Get the code

	JumpL p1, [ CmNoi <then black> ; Noise ...
		    Jrst SflTag ] ; Merge ...

	CmNoi <then white>	; Other noise ...

SflTag:	CmCfm			; Confirm

	CamN p1, Flash		; See if the same thing ...
	 Jrst [	Call AlrSet	;  Yes, say so ...
		RetSkp ]	; That's it

	SkipN Flash		; Was it off?
	 Jrst [	Tmsg < [Was No Flash]>
		Jrst SflEnd ]

	SkipG Flash		; Was it this?
	 Jrst [	Tmsg < [Was Flash White]>
		Jrst SflEnd ]

	Tmsg < [Was Flash Black]>

SflEnd:	MoveM p1, Flash		; Set it now ...
	Jrst Tp2Rsk		; That's it

	SubTtl SetNFl -- Set No Flash command

SetNFl:	CmNoi <screen on bell>	; Noise

	CmCfm			; Confirm

	SkipN Flash		; Was it off?
	 Jrst [	Call AlrSet	;  Yes, say so ...
		RetSkp ]	; That's it

	SkipG Flash		; Was it this?
	 Jrst [	Tmsg < [Was Flash White]>
		Jrst SfnEnd ]

	Tmsg < [Was Flash Black]>

SfnEnd:	SetZM Flash		; Set it now ...
	Jrst Tp2Rsk		; That's it

	SubTtl SetInd -- Set Indicate bells in output command

SetInd:	CmNoi <bells in subjob output> ; Noise words
	CmCfm			; Confirm

	MovX t1, ShoBel		; Get this flag
	Move t2, NoFlag		; Copy over the NO flag
	And t2, t1		; Keep only the ShoBel bit
	And t1, WState		; AND in the current setting of the flag
	CamE t1, t2		; Compare with what we are trying to do, same?
	 Jrst [	Call AlrSet	; Say it is already set
		RetSkp ]	; Return good

	SetWOn ShoBel		; Assume 'Indicate' for now
	SkipE NoFlag		; Is it really 'No Indicate'?
	 Jrst [	SetWOf ShoBel	;  Yes, turn off the flag
		Tmsg < [Was Indicate mode]>
		Jrst Tp2Rsk ]	; Return good

	Tmsg < [Was No Indicate mode]>

	Jrst Tp2Rsk		; Return good

	SubTtl SetCon -- Set Continue-Halted-Forks (mode)

SetCon:	CmNoi <mode>		; Noise word
	CmCfm			; Confirm

	MovX t1, ConFlg		; Get this flag
	Move t2, NoFlag		; Copy over the NO flag
	And t2, t1		; Keep only the interesting bit
	And t1, WState		; AND in the current setting of the flag
	CamE t1, t2		; Compare with what we are trying to do, same?
	 Jrst [	Call AlrSet	; Say it is already set
		RetSkp ]	; Return good

	SetWOn ConFlg		; Assume 'on' for now
	SkipE NoFlag		; Is it really 'off'?
	 Jrst [	SetWOf ConFlg	;  Yes, turn off the flag
		Tmsg < [Was Continue-Halted-Forks mode]>
		Jrst Tp2Rsk ]	; Return good

	Tmsg < [Was No Continue-Halted-Forks mode]>

	Jrst Tp2Rsk		; Return good

	SubTtl SetKey -- Set Key command

SetKey:	CmNoi <number>		; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmKey,,KeyTab,<keypad key number,>)]
	COMND%			; Get the number
	 .NpRp ResNop, R	;  On error ...
	HrrZ p1, 0(t2)		; Save the number we got

	CmCfm			; Confirm

	SkipN t1, Keys-1(p1)	; Is this key already defined?
	 Jrst [	Lock		;  Not yet, lock, so we can use GetSp2
		MoveI t2, ^d17	; This many words ...
		Call GetSp2	; Get space for string
		SkipN t2	; Did we get the space?
		 Bug (HLT,<Can't get space for key string>) ; A problem ...
		Unlock		; Free up the top guy now
		Jrst .+1 ]	; Move on ...

	HrlI t1, (Point 7,0)	; Turn address into a byte ptr
	MoveM t1, Keys-1(p1)	; Put it back

	Tmsg < Type a delimiting character:  >

	PBIN%			; Get the character

	Move p2, t1		; Copy the character

	Tmsg <
 Delimiter is ">
	Move t1, p2		; Copy the char
	PBOUT%			; Type it
	Tmsg <", ASCII code >
	MoveI t1, .PriOu	; Primary output
	Move t2, p2		; Get the char again
	MovX t3, No%LFl ! No%Zro ! Fld(3, No%Col) ! Fld(^d8,No%Rdx)
				; Three octal digits (sic) (as in 001 ...)
	NOUT%			; Type the number
	 JEcBug(HLT,<Can't type octal character number>)

	Tmsg <
 Typein will be stored VERBATIM, including DELETEs -- Don't make misteaks!
 Type the string to be loaded into key >

	MoveI t1, .PriOu	; Primary output
	Move t2, p1		; Copy over the number
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type key number>)

	Tmsg <, end with the delimiting character:
>

	MoveI t1, .PriIn	; Primary input
	Move t2, Keys-1(p1)	; Where to put the string
	MoveI t3, <^d17*5>-1	; Maximum number of characters to accept
	Move t4, p2		; Copy over the delimiter
	SIN%			; Get the string
	 JEcBug (HLT,<Can't read string from terminal>)

	SetZ t1,		; Clear a reg
	Dpb t1, t2		; Drop a null on the delimiter

	Move t1, Keys-1(p1)	; Get back the byte ptr
	Move t2, t1		; Get it here too ...

SkyLop:	Ildb t3, t1		; Get the next input byte
	JumpE t3, SkyBot	; If null, done here

	CaiN t3, .ChCrt		; Return?
	 Jrst [ Ildb t4, t1	;  Yes, get the next byte
		JumpE t4, SkyBot ; Treat Cr <nul> as <nul>
		CaiN t4, .ChLfd	; Is it a linefeed?
		 Jrst .+1	;  Yes, "eat" the linefeed, use the return
		Idpb t3, t2	; Some other char, let both thru
		Move t3, t4	; Copy over the second character
		Jrst .+1 ]	; Move on

	Idpb t3, t2		; Put down the character
	Jrst SkyLop		; Loop some more

SkyBot:	SetZ t1,		; Clear a reg
	Idpb t1, t2		; Drop a null to tie off the string (again)

	Tmsg <
 [Stored string for key >

	MoveI t1, .PriOu	; Primary output
	Move t2, p1		; Copy over the number
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type key number>)

	Tmsg <]>		; End of string

	Jrst Tp2Rsk		; Done here

	SubTtl SetMrg -- Set Margin command

SetMrg:	CmNoi <to>		; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmNum,Cm%Sdh, 
		^d10,<number of columns to indent, 0 to 40>)]
	COMND%			; Get the number
	 .NpRp ResNop, R	;  On error ...
	Move t4, t2		; Save the number we got

	CmNoi <columns>		; More noise
	CmCfm			; Confirm

	JumpLE t4, [Tmsg < [Margin cleared, was >
		    SetZ t4,	; Clobber the margin
		    Jrst SmgTag ] ; Go finish up

	CaiLE t4, ^d40		; Less than or equal to sixty seconds?
	 Jrst [	Tmsg <% Using maximum margin of 40 ...
>				; Type warning ...
		MoveI t4, ^d40	; Load up the limit
		Jrst .+1 ]	; Move on ...

	Tmsg < [New margin is >

	MoveI t1, .PriOu	; Primary output
	MoveI t2, 0(t4)		; Get new margin
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type new margin size>)

	Tmsg <, was >		; Middle of message

SmgTag:	MoveI t1, .PriOu	; Primary output
	Move t2, Margin		; Get margin
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type new margin size>)
	Tmsg <]

>				; Finish string

	MoveM t4, Margin	; Store the new margin
	UnLock			; Make the top fork set it

	RetSkp			; Return good ...

	SubTtl SetMWM -- Set Multi-Window-Mode command

SetMWM:	CmCfm			; Confirm

	Push p, OneWin		; Save old value of flag

	Lock
	SetZM OneWin		; Set it
	SetFOn StrChg		; New vis list
	Unlock

	Pop p, t1		; Get old flag back in t1
	JumpE t1, [Call AlrSet
		   RetSkp ]

	Tmsg < [Was One-Window-Mode]

>
	RetSkp			; Return good

	SubTtl SetNo -- Set No something-or-other

SetNo:	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,SNoTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse

	MoveM t2, Comnd3	; Save third word we got

	SetOM NoFlag		; Very similar to the "No" command

	HrrZ t2, 0(t2)		; Get addr of routine to run
	Jrst 0(t2)		; Dispatch to the routine

	SubTtl SetOWM -- Set One-Window-Mode command

SetOWM:	CmCfm			; Confirm

	Push p, OneWin		; Save old value of flag

	Lock
	SetOM OneWin		; Set it
	SetFOn StrChg		; New vis list
	Unlock

	Pop p, t1		; Get old flag back in t1
	JumpN t1, [Call AlrSet
		   RetSkp ]

	Tmsg < [Was Multi-Window-Mode]

>

	RetSkp			; Return good

	SubTtl SetPad -- Set Padding

SetPad:	CmNoi <amount to>	; Noise

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey,,PadTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse

	HrrZ p1, 0(t2)		; Pick up the code value

	CmCfm			; Confirm ...

	Move t3, PadAmt		; Pick up old amount
	MoveM p1, PadAmt	; Set the new padding amount

	CamN t3, PadAmt		; Same amount?
	 Jrst [	Call AlrSet	;  Yes, say its the same
		RetSkp ]	; That's it

	Tmsg < [Was Padding >	; Start of message

	CaiN t3, -1		; This value?
	 Jrst [	Tmsg <Half>
		Jrst SpdDon ]

	CaiN t3, -2		; This value?
	 Jrst [	Tmsg <Quarter>
		Jrst SpdDon ]

	CaiN t3, 1		; This value?
	 Jrst [	Tmsg <Double>
		Jrst SpdDon ]

	CaiN t3, -17		; This value?
	 Jrst [	Tmsg <None>
		Jrst SpdDon ]

	Tmsg <Full>

SpdDon:	Tmsg <]

>				; End of message

	RetSkp			; Done

	SubTtl SetPau -- Set Pause-on-Command (mode)

SetPau:	CmNoi <mode>		; Noise

	CmCfm			; Confirm ...

	SkipE PauCom		; Already set?
	 Jrst [	Call AlrSet
		Jrst .+2 ]

	Jrst [	Lock
		SetOM PauCom	; Set it
		SetOM NewPau	; Say we set it
		UnLock		; Make it happen

		Tmsg < [Was No Pause-on-Command]

>
		Jrst .+1 ]

	RetSkp			; Done

	SubTtl SNoPau -- Set No Pause-on-Command (mode)

SNoPau:	CmNoi <mode>		; Noise

	CmCfm			; Confirm ...

	SkipN PauCom		; Already set?
	 Jrst [	Call AlrSet
		Jrst .+2 ]

	Jrst [	Lock
		SetZM PauCom	; Clear it
		SetOM NewPau	; Say we set it
		UnLock		; Make it happen

		Tmsg < [Was Pause-on-Command]

>
		Jrst .+1 ]

	RetSkp			; Done

	SubTtl SetScr -- Set Screen-Banner

SetScr:	CmCfm			; Confirm ...

	SkipE ScrBnF		; Already set?
	 Jrst [	Call AlrSet
		Jrst .+2 ]

	Jrst [	SetOM ScrBnF	; Set it
		SetFOn StrChg	; Say structure changed
		UnLock		; Make it happen

		Tmsg < [Was No Screen-Banner]

>
		Jrst .+1 ]

	RetSkp			; Done

	SubTtl SNoScr -- Set No Screen-Banner

SNoScr:	CmCfm			; Confirm ...

	SkipN ScrBnF		; Already set?
	 Jrst [	Call AlrSet
		Jrst .+2 ]

	Jrst [	SetZM ScrBnF	; Clear it
		SetFOn StrChg	; Say structure changed
		UnLock		; Make it happen

		Tmsg < [Was Screen-Banner]

>
		Jrst .+1 ]

	RetSkp			; Done

	SubTtl Show command -- Show window parameters

Show:	CmNoi <parameters for window> ; Noise ...
	MoveI t2, SbaFdb	; Subjob, or 'All'
	Call PrsSjb		; Parse for a subjob ID
	 Ret			; Problem
	CmCfm			; Confirm

	MoveI p1, ShoJob	; This is the Show routine
	Call EachSj		; Do it for each subjob

	Tmsg <
>				; Skip a line after it ...

	RetSkp			;  and return

	SubTtl ShoJob -- Type parameters for one window

ShoJob:	Call Front		; Standard front

	Move p2, PtySts(i)	; Pick up status
	TxNE p2, PtNobF		; Test banner flag
	 Jrst [	Tmsg <No >
		Jrst .+1 ]
	Tmsg <Banner, >

	TxNE p2, PtInvF		; Test invisible flag
	 Jrst [	Tmsg <Invisible, >
		Jrst .+2 ]
	Jrst [	Tmsg <Visible, >
		Jrst .+1 ]

	TxNE p2, PtTraF		; Test transparent flag
	 Jrst [	Tmsg <Transparent, >
		Jrst .+2 ]
	Jrst [	Tmsg <Opaque, >
		Jrst .+1 ]

	TxNN p2, PtLzyF		; Test Lazy-Update flag
	 Jrst [	Tmsg <No >
		Jrst .+1 ]
	Tmsg <Lazy-Update, >

	SkipG PtyFrk(i)		; Is it a fork?
	 Jrst ShjTg1		;  No ...

	TxNN p2, PtFreF		; Test Freeze-when-offscreen flag
	 Jrst [	Tmsg <No >
		Jrst .+1 ]
	Tmsg <Freeze-when-offscreen, >

ShjTg1:	Tmsg <with Size >
	SkipGE PtySiz(i)	; Test size
	 Jrst [	Tmsg <floating>
		Jrst ShjDon ]	; Go finish up

	SetZM String		; Clear first word of string
	HrrOI t1, String	; Point to string
	Move t2, PtySiz(i)	; Get size value
	MoveI t3, ^d10		; Decimal
	NOUT%			; Write to core
	 JEcBug (HLT,<Can't write size>)
	TmsgS (String)		; Write the number
	Tmsg < lines>

ShjDon:	Tmsg <]
>				; End the line
	Ret			;  and return

	SubTtl Silence command -- Rig for Silent Running

Silnce:	CmNoi <all output to terminal> ; Noise words
	CmCfm			; Confirm

	Push p, SilncF		; Save old value of flag

	SetOM SilncF		; Assume it's 'SILENCE'
	SkipE NoFlag		; Was it really 'NO SILENCE'?
	 SetZM SilncF		; Yes, set the flag the other way
	Unlock

	Pop p, t1		; Get old flag back
	CamN t1, SilncF		; Compare with new value
	 Jrst [	Call AlrSet	;  Same thing, say  so
		RetSkp ]	; Done here

	SkipN SilncF		; Is it now Silence?
	 Jrst [	Tmsg < [Was Silence]> ;  Yes, say what it was
		Jrst Tp2Rsk ]	; Done here

	Tmsg < [Was No Silence]> ; Say what it was
	Jrst Tp2Rsk		; Done here

	SubTtl Take command -- Take input from a file

Take:	CmNoi <commands from file> ; Noise words

	Call GjfRes		; Reset most of the GTJFN arg block

	HrrOI t4, [AsciZ/Cmd/]	; Default extension
	MoveM t4, .GjExt(t3)	; Store it

TakTag:	Move t4, .GjGen(t3)	; Get flags set so far ...
	TxO t4, Gj%Old		; Add the fact that it should be an old file ..
	MoveM t4, .GjGen(t3)	; Put it back ...

	HrrOI t4, [AsciZ/Window/] ; Default filename
	MoveM t4, .GjNam(t3)	; Store it

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmIfi,Cm%Sdh,,<file to read commands from> )]
				; Parse for an input file
	COMND%			; Go get the jfn, if we can
	 .NpRp BadTak, R	; Handle bad file name here, return on reparse

	HrrZM t2, HldJfn	; Store the jfn we got

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, CfmFdb	; FDB for confirm
	COMND%			; Confirm the command
	 .NpRp ClrTak, FixTak	; Handle bad file name here, unget jfn if
				;  reparse needed, then return

	SkipE RdJfn		; Are we already reading from a file?
	 Jrst [	.LeftM		;  Yes, complain
		Tmsg <? Nested Get or Take is illegal

>
		Ret ]		;  and return NG

	;continued on next page
	;continued from previous page

	Lock			; Grab control ...

	Move t1, HldJfn		; Get back the jfn
	MovX t2, Fld(7, Of%Bsz) ! Of%Rd ; Seven bit bytes, read
	OPENF%			; Try to open the file
	 Jrst [	.JerMs <Can't open file> ; Complain
		Move t1, HldJfn	; Get the jfn
		RLJFN%		; Release it
		 Trn		;  Ignore the error
		Unlock		; Free it up again
		Ret ]		;  and return

	Move t1, HldJfn		; Get the jfn
	MoveM t1, RdJfn		; Store it

	Unlock			; Got it open ...

	Call TypRdj		; Go tell what file we are reading from

	RetSkp			; Done here ...

BadTak:	SetO t1,		; Want the most recent error
	.JerMs <Can't get handle on file> ; Do the message
	SetZM RdJfn		; There is now no jfn
	Ret			;  and return

ClrTak:	.LeftM			; Get to left margin
	Tmsg <? Not confirmed

>				; Complain

FixTak:	Move t1, HldJfn		; Get the jfn
	RLJFN%			; Release it
	 Trn			;  Ignore the error
	Ret			;  and return

	SubTtl Terminal command -- Say what our terminal type is

Termnl:	CmNoi <type>		; Noise words

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmKey, 
		,TerTab,<type of terminal you are using now,>)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse

	HrrZ p1, 0(t2)		; Get terminal type code

	CmCfm			; Confirm

	Lock
	MoveM p1, VtType	; Set the new type
	SetOM NewTrm		; Say we want a new terminal type
	UnLock

	CaiN p1, Im3101		; Is it IBM 3101?
	 Jrst [	Tmsg < [Monitor has been told this is a VT52]

>				; Say that we did something strange ...
		Jrst .+2 ]	; Return to stream, skipping ...

	 Jrst [	Tmsg < [Monitor has been informed]

>
		Jrst .+1 ]	; Return to stream

	RetSkp			;  and return good ...

	SubTtl Unrestrict command -- Unrestrict some Window function

UnRsct:	CmNoi <window function>	; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmKey,,RstTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	;  Fix no-parse, ret on error

	HrrZ p1, 0(t2)		; Copy over the answer

	CmCfm			; Confirm

	AndCaM p1, Restri	; Unrestict this function

	Tmsg < [Ok]>
	Jrst Tp2Rsk		; Done here

	SubTtl Wait command -- Wait for some number of seconds

Wait:	CmNoi <for>		; Noise

	MoveI t1, CmdCsb	; Command state block
	MoveI t2, [FldDb. (.CmNum,Cm%Sdh, 
		^d10,<number of seconds to wait, between 1 and 60>)]
	COMND%			; Get the number
	 .NpRp ResNop, R	;  On error ...
	Move t4, t2		; Save the number we got

	CmNoi <seconds>		; More noise
	CmCfm			; Confirm

	JumpLE t4, [ Tmsg <% Not waiting ...> ; Message
		     Jrst Tp2Rsk ] ; Two CrLfs, retskip

	CaiLE t4, ^d60		; Less than or equal to sixty seconds?
	 Jrst [	Tmsg <% Wait time reduced to 60 seconds ...
>				; Message ...
		MoveI t4, ^d60	; Load up the limit
		Jrst .+1 ]	; Move on ...

	Tmsg < [Waiting for >

	MoveI t1, .PriOu	; Primary output
	MoveI t2, 0(t4)		; Get waiting time
	MoveI t3, ^d10		; Decimal
	NOUT%			; Type it
	 JEcBug (HLT,<Can't type new margin size>)

	Tmsg < seconds ...]

>				; End of message

	MoveM t4, WaitTm	; Store the wait time
	UnLock			; Make the top fork do it

	RetSkp			; Return good ...

	SubTtl What command -- Give SYSTAT for subjobs

What:	CmNoi <is state of subjob> ; Noise words
	MoveI t2, SbaFdb	; Subjob, or 'All'
	Call PrsSjb		; Parse for a subjob ID
	 Ret			; Problem
	CmCfm			; Confirm

	MoveI p1, TypSys	; This is the What routine
	Call EachSj		; Do it for each subjob

	Tmsg <
>				; Skip a line after too ...

	RetSkp			;  and return

	SubTtl TypSys -- Type a Systat of a subjob

TypSys:	CamN i, LstCon		; Is this the last connected?
	 Jrst [	Tmsg < . >	;  Yes, so type a period to indicate
		Jrst .+2 ]	;  and return to the stream

	 Jrst [	Tmsg <   >	; Not last connected, type 3 spaces
		Jrst .+1]	; and return to stream

	Call TypNam		; Name of subjob

	Call TypTab		; Tab to the second tab stop

	HrlZ t1, PtyTtd(i)	; Now see if logged in
	txz t1, 1b0		; Turn off the Tty designator
	Hrr t1, TtyJob		; Get table # for GETAB%
	GETAB%
	 Jrst TYPSNJ		; Failed!

	HlrE t2, t1		; Get the job number
	 JumpL t2, TYPSNJ	;  If -1 or -2, then not logged in

	Push p, t2		; Save job number ...

	HrrOI t1, String	; Put number in string
	MovX t3, No%Lfl ! Fld(2,No%Col) ! Fld(10,No%Rdx) ; Leading filler
				;  two column, decimal
	NOUT%
	 Trn

	TmsgS (String)		; Type out the number

	Tmsg <  >		; Skip 2 spaces

	Pop p, t1		; Restore job number

	Move t2, [-JITBLN,, JITAB] ; Get info about this job
	SetZ t3,
	GETJI%
	 Jrst Tp2Ret		; If none, don't type any more

	Move t2, JITAB+.JIUNO	; Get user number
	JumpE t2, [ Tmsg <Not logged in
>
		    Ret ]	; Not logged in if 0

	HrrOI t1, String	; Output name to string
	DIRST%			; Type out logged in name
	 Trn

	;continued on next page
	;continued from previous page

	TmsgS (String)		; Now type out the name

	Call TypTab
	Move t1, JITAB+.JIPNM	; Get PROGRAM NAME
	Call TYPSIX		; TYPE IT OUT

	Call TypTab

	Move t1, JITAB+.JIRT	; Get RUN TIME OF THE JOB
	IDivI t1, ^D1000	; TURN IT INTO SECONDS
	IDivI t1, ^D60		; Get SECONDS
	Push p, t2		; SAVE SECONDS

	IDivI t1, ^D60		; Get MINUTES
	Push p, t2

	MoveI t3, ^d10		; Decimal output, any number of cols
	Call TTDNUM		; TYPE OUT THE DECIMAL HOURS

	MoveI t1, ":"		; Followed by ":"
	PBOUT%			; Type the colon

	Pop p, t1		; Get MINUTES
	MovX t3, No%Lfl ! No%Zro ! Fld(2,No%Col) ! Fld(^d10,No%Rdx) ; 2 digits
	Call TTDNUM

	MoveI t1, ":"
	PBOUT%			; Type the colon

	Pop p, t1		; AND NOW DO THE SECONDS
	MovX t3, No%Lfl ! No%Zro ! Fld(2,No%Col) ! Fld(^d10,No%Rdx) ; 2 digits
	Call TTDNUM
	Jrst Tp1Ret		; Type a CrLf, then return

	;continued on next page
	;continued from previous page

TYPSNJ:	Tmsg <No job number assigned
>
	Ret			; Pretty simple ...


TYPSIX:	Move t4, t1		; SAVE ARG
	MoveI t3, 6		; TYPE A MAX OF 6 CHARS
	Move t2, [Point 6, t4]	; Set UP Byte POINTER

TYPSXL:	Ildb t1, t2		; Get NEXT CHAR
	AddI t1, 40		; CONVERT TO ASCII
	PBOUT%			; Type the colon
	SojG t3, TYPSXL		; LOOP FOR 6 CHARS
	Ret

TTDNUM:	Move t2, t1		; Get CHARACTER
	HrrOI t1, String	; Get ANSWER INTO A STRING
	NOUT%
	 JEcBug (CHK,<NOUT failed>)
	TmsgS (String)		; Now output the answer
	Ret


; Routine to put out enough spaces to get to the next tab stop

TypTab:	Push p, t2		; SAVE ACS
	MoveI t1, .PriOu	; Get COLUMN COUNT
	RFPOS%
	HrrZ t1, t2
	IDivI t1, TabSiz	; Get NUMBER OF SPACES TO TYPE
	MovNS t2		; CALCULATE NUMBER REMAINING
	AddI t2, TabSiz
	MoveI t1, " "		; Simulate with spaces
	PBOUT%			; Type it
	SojG t2, .-1
	Pop p, t2		; RESTORE ACS
	Ret

	SubTtl Window command -- Change some window parameter ...

WinCmd:	MoveI t2, SbAFdb	; Addr of FDB to use
	Call PrsSjb		; Parse for a subjob ID
	 Ret			;  Didn't get one

	MoveI t1, CmdCsb	; Addr of CSB
	MoveI t2, [FldDb. (.CmKey,,WinTab)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Handle like the rest

	SkipN Comnd2		; Is there a second word yet?
	 Jrst [	MoveM t2, Comnd2 ; No, save this as the second word
		Jrst .+2 ]	; Skip the other save

	MoveM t2, Comnd3	; Save as the third word

	HrrZ t2, 0(t2)		; Get addr of routine to run
	Jrst 0(t2)		; Dispatch to the routine

	;continued on next page
	;continued from previous page

; Window X (is) Banner

WinBan:	CmCfm			; Confirm

	MoveI p1, OneBan	; Routine to use
	Call EachSj		; Do it for each one, as required

	Jrst Tp1Rsk

OneBan:	Call Front		; Type front of message

	SkpfOn PtNobF		; Test banner status
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst [	Tmsg <Was No Banner mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtNoBF		; Get the bit
	AndCam t4, PtySts(i)	; Clear the (no banner) flag

	SetFOn StrChg		; Say that structure changed, need new lists
	SetZM PtyBtm(i)		; Force a banner update

	UnLock			; Update the screen
	Ret			; Return ...

	;continued on next page
	;continued from previous page

; Window X (is) Invisible

WinInv:	CmCfm			; Confirm

	MoveI p1, OneInv	; This routine
	Call EachSj		; For each sj

	Jrst Tp1Rsk		; Done here

OneInv:	Call Front		; Type front of message

	SkpfOf PtInvF		; Test invisible flag
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst [	Tmsg <Was Visible mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtInvF		; Get invisible flag
	IOrM t4, PtySts(i)	; Set the flag

	SetFOn StrChg		; Say that structure changed, need new lists
	UnLock			; Update the screen
	Ret			; Return

; Window X (is) Freeze-when-offscreen

WinFre:	CmCfm			; Confirm

	MoveI p1, OneFre	; This routine
	Call EachSj		; For each subjob

	Jrst Tp1Rsk		; Done here ...

OneFre:	Call Front		; Type front of line

	Call TstFrk		; Test if a fork, is so, return twice

	MovX t1, PtFreF		; Get this flag
	Move t2, NoFlag		; Copy over the NO flag
	And t2, t1		; Keep only the ShoBel bit
	And t1, PtySts(i)	; AND in the current setting of the flag
	CamE t1, t2		; Compare with what we are trying to do, same?
	 Jrst [	Call AlrSt1	; Say it is already set
		Ret ]		; Return

	SetWOn (PtFreF, PtySts(i)) ; Assume 'on' for now
	SkipE NoFlag		; Is it really 'off'?
	 Jrst [	SetWOf (PtFreF, PtySts(i)) ;  Yes, turn off the flag
		Tmsg <Was Freeze-when-offscreen mode]>
		Jrst Tp1Ret ]	; Return

	Tmsg <Was No Freeze-when-offscreen mode]>
	Jrst Tp1Ret		; Return

	;continued on next page
	;continued from previous page

; Window X (is) No ?

WinNo:	MoveI t1, CmdCsb	; Addr of CSB
	MoveI t2, [FldDb. (.CmKey,,WNoTab)]
	COMND%			; Do it
	 .NpRp ResNop, R

	SetOM NoFlag		; Set this flag

	HrrZ t2, 0(t2)		; Get dispatch addr
	Jrst 0(t2)		; Dispatch

	;continued on next page
	;continued from previous page

; Window X (is) No Banner

WNoBan:	CmCfm			; Confirm

	MoveI p1, OneNBn	; This routine
	Call EachSj		; For each window

	Jrst Tp1Rsk		; Done here

OneNBn:	Call Front		; Type front of line

	SkpfOf PtNobF		; Test banner bit
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst [	Tmsg <Was Banner mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtNoBF		; Get no banner flag
	IOrM t4, PtySts(i)	; Set the (no banner) flag

	SetFOn StrChg		; Say that structure changed, need new lists
	SetZM PtyBtm(i)		; Force a banner update
	UnLock			; Update the screen
	Ret			; Return

; Window X (is) Lazy-Update (or No Lazy-Update)

WinLzy:	CmCfm			; Confirm

	MoveI p1, OneLzy	; This routine
	Call EachSj		; For each subjob

	Jrst Tp1Rsk		; Done here ...

OneLzy:	Call Front		; Type front of line

	MovX t1, PtLzyF		; Get this flag
	Move t2, NoFlag		; Copy over the NO flag
	And t2, t1		; Keep only the ShoBel bit
	And t1, PtySts(i)	; AND in the current setting of the flag
	CamE t1, t2		; Compare with what we are trying to do, same?
	 Jrst [	Call AlrSt1	; Say it is already set
		Ret ]		; Return

	SetWOn (PtLzyF, PtySts(i)) ; Assume 'on' for now
	SkipE NoFlag		; Is it really 'off'?
	 Jrst [	SetWOf (PtLzyF, PtySts(i)) ;  Yes, turn off the flag
		Tmsg <Was Lazy-Update mode]>
		Jrst Tp1Ret ]	; Return

	Tmsg <Was No Lazy-Update mode]>
	Jrst Tp1Ret		; Return

	;continued on next page
	;continued from previous page

; Window X (is) No Size

WNoSiz:	CmCfm			; Confirm

	MoveI p1, OneNSz	; This routine
	Call EachSj		; For each sj

	Jrst Tp1Rsk		; Done here

OneNSz:	Call Front		; Type front of message

	SkipGE PtySiz(i)	; Was there a size set?
	 Jrst [	Call AlrSt1
		Jrst NSzBot ]	; Jump down

	Tmsg <Size was >	; Start of message
	SetZM String		; Clear first word of string
	HrrOI t1, String	; Point to string
	Move t2, PtySiz(i)	; Get old value
	MoveI t3, ^d10		; Decimal
	NOUT%			; Write to core
	 Bug (HLT,<Can't write old size>)
	TmsgS (String)		; Write the number
	Tmsg < lines]
>

NSzBot:	Lock

	SetOM PtySiz(i)		; Set no size

	SetFOn StrChg		; Say that structure changed, need new lists
	UnLock			; Update the screen
	Ret			; Return

	;continued on next page
	;continued from previous page

; Window X (is) Opaque

WinOpa:	CmNoi <to action-keys not preceded by Break> ; Noise ...

	CmCfm			; Confirm

	MoveI p1, OneOpa	; This routine
	Call EachSj		; For each subjob

	Jrst Tp1Rsk		; Done here

OneOpa:	Call Front		; Type front of message

	SkpfOn PtTraF		; Test transparency
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst [	Tmsg <Was Transparent mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtTraF		; Get the flag
	AndCam t4, PtySts(i)	; Clear it

	Unlock
	Ret			; Return

	;continued on next page
	;continued from previous page

; Window X (is) Size

WinSiz:	CmNoi <to>		; Noise

	MoveI t1, CmdCsb	; Addr of command state block
	MoveI t2, [FldDb. (.CmNum,Cm%Sdh,^d10,<number of lines>)]
	COMND%			; Do it
	 .NpRp ResNop, R	; Fix no-parse, return on reparse
	Move p2, t2		; Move the number out of the way

	CmNoi <lines>		; More noise ...

	CmCfm			; Confirm

	CaiGE p2, 4		; Must be at least this many lines
	 Jrst [	Tmsg <? Window size must be 4 or more lines

>
		RetSkp ]	; Complain

	CaiLE p2, TrmLen	; Can't be more than this many lines
	 Jrst [	Tmsg <? Window size can't be greater than screen size

>
		RetSkp ]	; Complain

	MoveI p1, OneSiz	; This routine
	Call EachSj		; For each sj

	Jrst Tp1Rsk		; Done here

OneSiz:	Call Front		; Type front of message

	Tmsg <Size was >	; Start of message
	SkipGE PtySiz(i)	; Was there a size?
	 Jrst [	Tmsg <floating]
>
		Jrst SizBot ]	; No size, say so and jump down

	SetZM String		; Clear first word of string
	HrrOI t1, String	; Point to string
	Move t2, PtySiz(i)	; Get old value
	MoveI t3, ^d10		; Decimal
	NOUT%			; Write to core
	 Bug (HLT,<Can't write old size>)

	TmsgS (String)		; Write the number

	Tmsg < lines]
>

SizBot:	Lock

	MoveM p2, PtySiz(i)	; Save it
	SetFOn StrChg		; Say that structure changed, need new lists

	UnLock			; Update the screen
	Ret			; Return

	;continued on next page
	;continued from previous page

; Window X (is) Transparent

WinTra:	CmNoi <to action-keys not preceded by Break> ; Noise ...

	CmCfm			; Confirm

	MoveI p1, OneTra	; This routine
	Call EachSj		; For each sj

	Jrst Tp1Rsk		; Done here

OneTra:	Call Front		; Type the front of the line

	SkpfOf PtTraF		; Test transparency
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst [	Tmsg <Was Opaque mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtTraF		; Get the flag
	IOrM t4, PtySts(i)	; Set it

	Unlock
	Ret			; Return

	;continued on next page
	;continued from previous page

; Window X (is) Visible

WinVis:	CmCfm			; Confirm

	MoveI p1, OneVis	; This routine
	Call EachSj		; For each sj

	Jrst Tp1Rsk		; Done here

OneVis:	Call Front		; Type front of message

	SkpfOn PtInvF		; Test visibility
	 Jrst [	Call AlrSt1
		Jrst .+2 ]

	Jrst  [	Tmsg <Was Invisible mode]
>
		Jrst .+1 ]

	Lock

	MovX t4, PtInvF		; Get invisible flag
	AndCam t4, PtySts(i)	; Clear the flag

	SetFOn StrChg		; Say that structure changed, need new lists
	UnLock			; Update the screen
	Ret			; Return

	SubTtl Send -- Send a single line to a subjob

SendLn:	MoveI t1, CmdCsb	; State block
	MoveI t2, [FldBk. (.CmTok,Cm%Sdh,<-1,,[AsciZ/-/]>,<->,<->)] ; Dash ...
	COMND%			; Do it
	 .NpRp SndTag, R	;  Ignore missing dash, ret on reparse

SndTag:	MoveI t1, CmdCsb	; State block
	MoveI t2, [FldDb. (.CmTxt,Cm%Sdh,,<line to be sent to window>)]
	COMND%			; Do it
	 .NpRp BadSnd, R	;  Handle bad line (?), return on reparse

	CmCfm			; Confirm

	SkipLE LstCon		; Is this a specific subjob?
	 MoveM i, LstCon	;  Yes, so make him be the last connected ...

	HrrOI p1, CmdAtm	; Ptr to atom buffer
	SetZ p2,		; No previous char

SndLop:	Move t1, p1		; Copy over the ptr
	BIN%			; Get the next char
	Move p1, t1		; Copy back the updated ptr

	AndI t2, 177		; Keep only ASCII bits, no parity

	JumpE t2, SndDon	; Hit a null, go do Cr ...

	CaiN t2, "\"		; Backslash not preceded by control-V?
	 MoveI t2, .ChCrt	;  Yes, pretend it was a return

	CaiN t2, "|"		; Vertical-bar not preceded by control-V?
	 MoveI t2, .ChEsc	;  Yes, pretend it was an escape

	CaiN t2, .ChCnV		; Control-V?
	 Jrst [	BIN%		;  Yes, get next char
		AndI t2, 177	; Keep only ASCII bits, no parity
		Move p1, t1	; Copy the updated ptr
		SkipN t2	; Not a null we hope
		 Bug (HLT,<Hit isolated control-V>) ; What to do?
		Jrst .+1 ]	; Ok, go handle the char

	;continued on next page
	;continued from previous page

	CaiN p2, "$"		; Previous char was dollar sign?
	 Jrst [ Push p, t2	; Yes, save this reg for a second ...
		MoveI t2, "$"	; Get dollar sign in t2
		Call PtyMlt	; Send along to subjob(s)
		Pop p, t2	; Restore reg
		Jrst .+1 ]	; Return to stream

	Move p2, t2		; Save this char
	CaiE t2, "$"		; This char a dollar sign?
	 Call PtyMlt		;  No, give it to the subjob(s)

	Jrst SndLop		; Go handle next char

; Done with text part, now do the return (if prev char wasn't dollar sign)

SndDon:	CaiN p2, "$"		; Prev char a dollar sign?
	 RetSkp			;  Yes, all done

	MoveI t2, .ChCrt	; Get a return
	Call PtyMlt		; Give it to the subjob(s)

	RetSkp			; Return Ok

; Bad line (what can be wrong?)

BadSnd:	.LeftM			; Left margin
	Tmsg <? Invalid line

>
	Ret			; Return NG

	SubTtl Confrm & Noise -- Confirm a COMND line, parse noise words

;
; Confrm -- handle confirmation
;

Confrm:	MoveI t1, CmdCsb	; Get addr of command state block
	MoveI t2, CfmFdb	; Confirm function
	COMND%			; Do it
	 .NpRp NotCfm, RFlsh	; Jump for no-parse, return for reparse

	Ret			; That's it

;
; Noise -- handle noise words
;
;   Call with ...
;	t1/ ptr to noise string
;

Noise:	MoveI t2, NoiFdb	; Addr of noise fdb
	MoveM t1, .CmDat(t2)	; Store byte ptr in block

	MoveI t1, CmdCsb	; Get addr of command state block
	COMND%			; Do it
	 .NpRp BadNoi, RFlsh	; Complain if no-parse, return on reparse

	Ret			; All is Ok, just return

; Junk at end of line

NotCfm:	.LeftM			; Get to left margin
	Tmsg <? Not confirmed

>				; Complain

RFlsh:	Pop p, 0(p)		; Flush inner return
	Ret			; Return

; Invalid noise words

BadNoi:	.LeftM			; Get to left margin
	Tmsg <? Invalid guide word

>				; Complain

	Jrst RFlsh		; Flush return addr, then return

	SubTtl TypAtm -- Type contents of Atom Buffer (to complain)

TypAtm:	Move t1, [Point 7, CmdAtm] ; Ptr to atom buffer
	Ildb t2, t1		; Get the first char
	JumpE t2, Tp2Ret	; If empty, skip this

	Tmsg < - ">		; Start of msg
	HrrOI t1, CmdAtm	; Ptr to atom buffer
	PSOUT%			; Type it

	Tmsg <">		; End of msg
	Jrst Tp2Ret		; That's it

	SubTtl AlrSt1 -- Say "already set]", one CrLf

AlrSt1:	Tmsg <Already set]>	; Type the message

	Jrst Tp1Ret		; Type one CrLf, then return

	SubTtl AlrSet -- Say " [Already set]", two CrLf's

AlrSet:	Tmsg < [Already set]>	; Type the message

	Jrst Tp2Ret		; Type two CrLf's, then return

	SubTtl CmdRes -- Reset the normal COMND command state block

CmdRes:	Push p, t1		; Save t1

	SetZ t1,		; Clear t1
	MoveM t1, CmdCsb+.CmFlg	; No flags or reparse address
	MoveM t1, CmdCsb+.CmInc	; Also, no chars still to be parsed

	Move t1, [.PriIn,, .PriOu] ; Primary input and output
	MoveM t1, CmdCsb+.CmIoj	; Set the I/O jfns

	HrlI t1, (Point 7, 0)	; We want real byte pointers ...
	HrrI t1, [AsciZ/Window> /] ; The prompt
	MoveM t1, CmdCsb+.CmRty	;  as our CTRL/R text

	HrrI t1, CmdBuf		; Pointer to the COMND buffer
	MoveM t1, CmdCsb+.CmBfp	;  as pointer to start of buffer ...
	MoveM t1, CmdCsb+.CmPtr	;  and as pointer to next input to be parsed

	MoveI t1, BufChr	; Count of char positions in the buffer
	MoveM t1, CmdCsb+.CmCnt	;  as count of space left in the buffer

	HrrOI t1, CmdAtm	; Pointer to the atom buffer
	MoveM t1, CmdCsb+.CmAbp	;  as the same

	MoveI t1, AtmChr	; Count of char positions in the atom buffer
	MoveM t1, CmdCsb+.CmAbc	;  as the same

	MoveI t1, GjfBlk	; Addr of the GTJFN arg block
	MoveM t1, CmdCsb+.CmGjb	;  as the same

	Pop p, t1		; Restore t1

	Ret			; Return

	SubTtl CfmRes -- Reset the (confirm-only) COMND command state block

CfmRes:	Push p, t1		; Save t1

	SetZ t1,		; Clear t1
	MoveM t1, CfmCsb+.CmFlg	; No flags or reparse address
	MoveM t1, CfmCsb+.CmInc	; Also, no chars still to be parsed

	Move t1, [.PriIn,, .PrIou] ; Primary input and output
	MoveM t1, CfmCsb+.CmIoj	;  as our JFNs

	HrrOI t1, [AsciZ/ [Confirm: (Hit ESC to get back to Window)] /]
	MoveM t1, CfmCsb+.CmRty	; This is our CTRL/R text

	HrrOI t1, CfmBuf	; Pointer to the COMND buffer
	MoveM t1, CfmCsb+.CmBfp	;  as pointer to start of buffer ...
	MoveM t1, CfmCsb+.CmPtr	;  and as pointer to next input to be parsed

	MoveI t1, BufChr	; Count of char positions in the buffer
	MoveM t1, CfmCsb+.CmCnt	;  as count of space left in the buffer

	HrrOI t1, CfmAtm	; Pointer to the atom buffer
	MoveM t1, CfmCsb+.CmAbp	;  as the same

	MoveI t1, AtmChr	; Count of char positions in the atom buffer
	MoveM t1, CfmCsb+.CmAbc	;  as the same

	MoveI t1, GjfBlk	; Addr of the GTJFN arg block
	MoveM t1, CfmCsb+.CmGjb	;  as the same

	Pop p, t1		; Restore t1

	Ret			; Return

	SubTtl PrsSjb -- Parse for a window name, using FDB in t2

;
;   Takes:
;	t2/ Addr of FDB to use
;
;   Returns:
;	+1 if failure, no such subjob ID
;	+2 if success, register 'i' holds the subjob offset or -1 if 'ALL'
;

PrsSjb:	MoveI t1, CmdCsb	; Addr of command state block
	COMND%			; Do it
	 .NpRp BadSjb, R	; Handle bad name, return on reparse

	HrrE i, 0(t2)		; Get the subjob offset, 
				;  or -1 or -2 (which must be extended)

	RetSkp			;  and return

BadSjb:	.LeftM			; Get to the left margin
	Tmsg <? >		; Common start of error message
	Move t1, CmdErr		; What was the error?

	CaiN t1, NpxNoM		; No match?
	 Jrst [	Tmsg <Unknown>	; The error message
		Jrst BsjTag ]

	CaiN t1, NpxAmb		; Ambiguous?
	 Jrst [	Tmsg <Ambiguous>
		Jrst BsjTag ]	; Go to common finish

	CaiN t1, NpxNul		; Null?
	 Jrst [	Tmsg <Window name not specified>
		Jrst Tp2Ret ]	; Special case

	Tmsg <Invalid >

BsjTag:	Tmsg < window name>	; More text
	Jrst TypAtm		; Type unknown name, return with a problem

	SubTtl SetDef -- Set a default window name if it makes sense

;
; Call with ...
;	t2/ ptr to the COMND block (probably SboFdb)
;

SetDef:	SetZ t1,		; Assume no default
	Move t3, SjCnt		; Get number of defined subjobs
	CaiE t3, 1		; Exactly one?
	 Jrst SdfEnd		;  No, don't have a default name

	Hrr t1, SjbTab+1	; Get the id of the only subjob
	HrrO t1, PtyNam(t1)	; Use its primary name as the default

SdfEnd:	MoveM t1, .CmDef(t2)	; Set it
	Ret			; Then return

	SubTtl Some typing routines

; Type the name of the current subjob

TypNam:	HrrZ t4, PtyNam(i)	; Get addr of name for this line
	TmsgS (<0(t4)>)		; Type out the name

	HrrZ t4, PtyNm2(i)	; Get addr of secondary name
	JumpE t4, R		; Return if none

	Tmsg <(>		; Start of secondary name ...
	TmsgS (<0(t4)>)		;  ... the name itself
	Tmsg <)>		;  ... and a close

	Ret			;  and return


;
;   TypErr -- Type out an error message
;
;   Takes:
;	t1/ error number, or -1 for most recent error
;
;   Clobbers t1, t2 and t3
;

TypErr:	Move t2, t1		; Copy over the error number
	HrlI t2, .FhSlf		; This fork
	HrrOI t1, ErrStr	; Put message into a string
	SetZ t3, 
	ERSTR%			; Get the error string
	 Trn			; Failed, use default message
	 TrnA t1, [%Ptr <Unknown error code>] ; Failed, use default message

	TmsgS (ErrStr)		; Type out the message

	Ret

	;continued on next page
	;continued from previous page

; Tell where we are reading from

TypRdj:	Tmsg < [Reading from >
	Move t1, RdJfn		; Get the reading jfn
	MoveM t1, TheJfn	; Set it as the one to type
	Call TypJfn		; Go type out the file name
	Tmsg <]

>				;  close out the message ...
	Ret			;  and return


; Type out the name of the file (from TheJfn)

TypJfn:	MoveI t1, .PriOu	; The terminal
	Move t2, TheJfn		; The jfn
	MovX t3, Fld(.JsAof, Js%Dev) ! Fld(.JsAof, Js%Dir) ! 
		 Fld(.JsAof, Js%Nam) ! Fld(.JsAof, Js%Typ) ! 
		 Fld(.JsAof, Js%Gen) ! Js%Paf ; The full name
	SetZ t4,		; No prefix
	JFNS%			; Get the jfn into a file name
	 JEcBug (HLT,<JFNS failed>)

	Ret			;  and return

; Get a subjob ID

GetSjb:	CmNoi <output from windows> ; Noise words
	MoveI t2, SbaFdb	; Subjob, or 'All'
	Call PrsSjb		; Parse for a subjob ID
	 Ret			; Didn't get one ...
	CmCfm			; Confirm
	RetSkp			; Return good


; Set a bit in the status word

SetBit:	JumpL i, SetAll		; Jump if user said (or defaulted to) 'ALL'

	IorM t2, PtySts(i)	; Set the bit
	RetSkp			; Return

SetAll:	Call FrstSj		; Get the first i
	 TrnA			;  There is no first (!)

SetAl2:	IorM t2, PtySts(i)	; Set the bit

	Call NextSj		; Get next i
	 TrnA			;  none, quit

	Jrst SetAl2		;  and loop

	RetSkp			; Return


; Clear a bit in the status word

ClrBit:	JumpL i, CbtAll		; Jump if user said (or defaulted to) 'ALL'

	AndCAM t2, PtySts(i)	; Clear the bit
	RetSkp			; Return

CbtAll:	Call FrstSj		; Get the first i
	 TrnA			;  There is no first (!)

CbtAl2:	AndCAM t2, PtySts(i)	; Clear the bit

	Call NextSj		; Get next i
	 TrnA			;  none, quit

	Jrst CbtAl2		;  and loop

	RetSkp			; Return


; Check if any subjobs are logged in

ChkLog:	Move q1, NumPty		; Get highest pty job
	SetZ i,			; Start at number 0

ChkLG1:	SkipN PtyJfn(i)		; Is there a job on this line?
	 Jrst ChkLG2		; No, check other subjobs

	HrrZ t1, PtyTtd(i)	; Get tty designator
	Move t2, [-1,, t4]	; Get logged-in dir number
	MoveI t3, .JiUno
	SetZ t4,		; Start with 0 dir num
	GETJI%
	 SetZ t4,		; Assume 0 if failure

	JumpN t4, RSkp		; Job is logged in

ChkLG2:	AddI i, PtyLen		; Go to next job
	SojG q1, ChkLG1		; Loop back for all subjobs

	Ret			; No active jobs

	SubTtl AddSub -- Add (or test for addability of) a subjob name

;
;   Takes:
;	p1/ zero to just check for addability, nonzero to try to add
;	p2/ -1 to create a new subjob, subjob offset to create a new
;		name for an old subjob, ignored if p1=zero
;	p3/ pointer to subjob name to try to add
;
;   Returns:
;	+1 if failure, name in use (probably)
;	+2 if success, reg i is the offset (if really adding)
;

AddSub:	SetO i,			; Set the index reg to 'ALL', in case
	SetZ t1,		; Clear t1
	HrrZ t2, p3		; Addr of name
	Add t2, [Point 7, 7, 34] ; Make a pointer to the 40th byte
	Dpb t1, t2		; Tie off the string to max of 39 chars
	MoveI t1, SjbTab	; Addr of subjob table
	HrrO t2, p3		; Pointer to name to test
	TBLUK%			; Look for it in the table
	TxNE t2, Tl%Exm		; Is it an exact match for something?
	 Ret			;  Yes, return NG

	JumpE p1, RSkp		; If only testing, then we are done
	JumpGE p2, AdsNam	; If given a subjob offset, just add the name

; Here if we are creating a subjob prior to adding its name

	SetZ i,			; Start at zero
	Move t3, NumPty		; The number of ptys we can use
AdsLop:	SkipN PtyNam(i)		; See if assigned yet
	 Jrst AdsHit		;  No, we got one!
	AddI i, PtyLen		; Go to next slot
	SojG t3, AdsLop		; Loop
	Bug (HLT,<Can't find space in subjob tables>)
	Ret			; Return NG

	;continued on next page
	;continued from previous page

AdsHit:	MoveM i, LstCon		; This is the last connected ...

	SetZ t2,		; Start with no flags
	SkipE RefAll		; If 'REFUSE ALL'
	 TlO t2, PtRefF		;  then set the Refuse bit
	SkipE DisAll		; If 'DISCARD ALL'
	 TlO t2, PtDisF		;  then set the Discard bit
	MoveM t2, PtySts(i)	; Store the status

	MoveM i, DefWin		; Tell higher fork to do define this guy

AdsNam:	Call PshNam		; Put the name onto the name stack
	 Jrst [	Bug (HLT,<Can't add name to name stack>)
		Ret ]		;  A problem, return NG

	SkipGE i		; If index is not yet set, 
	 Move i, p2		;  then steal it from p2

	SkipN PtyNam(i)		; Is there a name defined yet for this pty?
	 Jrst [	MoveM t1, PtyNam(i) ;  No, so use this as the name
		Jrst AdsMrg ]	;  now go merge

	MoveM t1, PtyNm2(i)	; There was a primary name, so this is
				;  a secondary name

AdsMrg:	Hrl t2, t1		; Get addr of name in LH of t2
	Hrr t2, i		; Get subjob offset in RH of t2
	MoveI t1, SjbTab	; Addr of subjob table
	TBADD%			; Add this entry to the table
	 JEcBug (HLT,<Can't add name to subjob table>)

	RetSkp			; Return good

	SubTtl NewWin -- Do work required to add a new window

NewWin:	Call WinIni		; Set 24 blank lines

	Move t1, SjList		; Get ptr to subjob list
NwnLop:	HrrZ t2, 0(t1)		; Get forward ptr from this node
	SkipE t2		; Skip if no forward ptr
	 Jrst [	MoveI t1, 0(t2)	;  Advance the ptr
		Jrst NwnLop ]	;  and loop

	MoveI p1, 0(t1)		; Save the addr of the last node in the list
	MoveI t2, 2		; We will need a node of 2 words
	Call GetSp2		; Get space for the node
	SkipN t2		; Did we get the space?
	 Bug (HLT,<Failed to get space for new subjob node>)

	HrlZM p1, 0(t1)		; Set the back ptr from this node
	HrrM t1, 0(p1)		; Set the forward ptr in the previous node
	MoveM i, 1(t1)		; Store the new subjob number in this node

	Ret			; Done here

	SubTtl PshNam -- Push a name onto the name stack

;
;   Takes:
;	p3/ pointer to name to add
;
;  Returns:
;	+1 if failure, no space available
;	+2 if success, t1 points to the location of the saved data
;

PshNam:	Move t2, p3		; Addr of the name
	HrlI t2, (Point 7, 0)	; Make it a byte pointer

PnmLop:	Ildb t1, t2		; Get the next byte
	SkipE t1		; Skip down if hit a null
	 Jrst PnmLop		;  Not yet, so loop some more

	HrrZS t2		; Clear BP part of t2
	Sub t2, p3		; Subtract out addr of start of string
	Aoj t2,			; Add one for good luck

	Call GetSp2		; Try to get this much space
	JumpE t2, R		; If can't get space, return NG

	Hrl t3, p3		; Set up to do BLT
	HrrI t3, 0(t1)		; Addr to copy to
	Move t4, t1		; Build addr to stop at
	Add t4, t2		; ...
	Blt t3, -1(t4)		; Copy up the string

	RetSkp			; Return


	SubTtl EachSj -- Call some routine for one, or for each, defined subjob

;
;  Call EachSj with ...
;	p1/ Addr of routine to run
;	i/ subjob number, -1 if all are desired
;
;  Returns +1 always
;

EachSj:	SkipL i			; A specific subjob?
	 Jrst 0(p1)		;  Yes, call it and return from there

	Call FrstSj		; Get first i
	 Jrst [	.LeftM		;  None, say so ...
		Tmsg < [No windows defined]
>
		Ret ]		;  and return

EsjLop:	Call 0(p1)		; Call the routine for this subjob

	Call NextSj		; Get next i
	 Ret			;  Did them all ...

	Jrst EsjLop		; Loop

	SubTtl FrstSj and NextSj -- Get the first and next subjobs

;
;   Returns:
;	+1 if failure, no first or no next
;	+2 if success, reg i is the subjob offset
;
;  (Register t1 is clobbered in any case)
;

FrstSj:	MoveI t1, SjList	; Get addr of ptr to subjob list
	MoveM t1, SjbNum	; Store it as our location in the list

NextSj:	Move t1, SjbNum		; Get pointer
	HrrZ t1, 0(t1)		; Look at the forward ptr from it
	JumpE t1, R		;  If no forward ptr, just return NG

	MoveM t1, SjbNum	; Update the ptr in core
	Move t1, 1(t1)		; Get the subjob number from this node
	JumpE t1, NextSj	;  If WCL, skip this node

	CamN t1, Editor		; Is it the editor?
	 Jrst NextSj		;  Yes, don't select it

	Move i, t1		; Copy over the value
	RetSkp			;  ... and return good

	SubTtl PtyMlt -- Output a character to one or all ptys

PtyMlt:	Push p, i		; Save reg
	Push p, p1		; Save this reg
	MoveM t2, OptChr	; Save the char
	MoveI p1, PtyCal	; The addr of the routine to run
	Call EachSj		; Call routine for each the subjob
	Pop p, p1		; Restore regs
	Pop p, i		;  ...
	Ret			;  and return ...

;
;  Intermediate routine to call ptyout for us ...
;

PtyCal:	Move t2, OptChr		; Pick up the saved char ...
	Hrl t2, i		; Get subjob id in left half

	MoveM t2, SendCh	; Say what to send and to whom ...

	Unlock			; Unlock to get I/O level to do the work for us

	Ret			; Done here ...

	SubTtl Versio -- Type the version number of this program

;Routine to output a version number
; T1/ Output designator (JFN, string, etc.)
; T2/ Version number word
;Returns
; +1: Failure, error code in AC2
; +2: Success, updated byte pointer in AC1 if appropriate

base==^d8			;base for output of numbers

major==7777B11
minor==77B17
edit==777777
who==7B2

Versio:	skipn t2		;check for a version #
	 jrst rskp		; none, just return +2
	saveac <t1,t2,t3,t4>
	move t4,t2		;save version #

	load t2,major,t4	;get major version #
	movei t3,base		;octal output
	nout%			;output it
	 jrst [	move t2,t3	; get error code
		ret ]		; return +1
	txnn t4,minor		;check minor version #
	 jrst vrs.1		; none, proceed
	movei t2,"."		;get a period
	bout%			;output it
	 erjmp geterr		; failed
	load t2,minor,t4	;load the minor version
	movei t3,base		;octal
	nout%			;output it
	 jrst [	move t2,t3	; get error code
		ret ]		; return +1
vrs.1:	txnn t4,who+edit	;have we who or edit?
	 jrst rskp		;no, done
	movei t2,"("		;get a parenthesis
	bout%			;output it
	 erjmp geterr		; failed
	load t2,edit,t4		;get edit number
	movei t3,base		;get base
	nout%			;output it
	 jrst [	move t2,t3	; get error code
		ret ]		; return +1
	movei t2,")"		;get closer
	bout%			;output it
	 erjmp geterr		; failed
	load t2,who,t4		;load who edited
	 jumpe t2,rskp		; none, done
	movns t2		;negate it
	movei t3,base		;get base
	nout%			;output it
	 jrst [	move t2,t3	; get error code
		ret ]		; return +1
	RetSkp			; Return skip

geterr:	move t3,t1		;save pointer
	movei t1,.fhslf		;our fork
	geter%			;get our last error
	 erjmp [movei t2,.erbas	;load an invalid error
		jrst .+1]	;return that!!
	hrrz t2,t2		;isolate error code
	move t1,t3		;get back T1
	ret			;return

if2,<	purge major,minor,edit,who,geterr,vrs.1,base>

	SubTtl Front -- Type front of subjob-specific message

Front:	Tmsg < [>		; Start ...
	Call TypNam		; Say which one we have here ...
	Tmsg < -- >		; Separate ...
	Ret			; Done here ...


; Test if a fork, say ignored if not

TstFrk:	SkipLE PtyFrk(i)	; Is this a fork?
	 Ret			;  Yes, all is ok

	Tmsg <Ignored for a subjob]
>
	Pop p, 0(p)		; Flush first level return
	Ret			; Return all the way ...

	SubTtl WclCon -- Interrupt from superior to continue out of a WAIT%

WclCon:	Call ACSave		; Save ACs

	HrrZ t1, Wcl3Pc		; Get address from which we were interrupted
	CaiE t1, WclWai		; Place we expect to be
	 CaiN t1, WclWai-1	;  Another possible place
	  Jrst WcnPOk		;   One of the above, move on

	CaiE t1, WclWai-2	; The only other address we will tolerate ...
	 Bug (HLT,<WCL not at expected address when receiving interrupt from superior>)


; WCL PC is Ok, change debreak address to 

WcnPOk:	MoveI t1, WclWai	; The desired PC
	HrrM t1, Wcl3Pc		; Store it as address part of the PC

	MovX t1, 1b5		; Set up a user bit
	IOrM t1, Wcl3Pc		; Turn on the bit in the interrupt word

	Call ACLoad		; Restore ACs

	DEBRK%			; Debreak to new address ...

	SubTtl WclPan -- Panic level interrupt, a real problem (we guess)

WclPan:	Call AcSave		; Save temp ac's

	Move t1, OldTty		; Get tty number
	TxO t1, .TtDes		; Make it a device designator
	HrrOI t2, [AsciZ/
? WCL bug:  Panic-level interrupt at /] ; Complain
	SetZ t3,		; Stop on a null
	SOUT%			; Send the string
	 ErJmp .+1

	HrrZ t2, Wcl1PC		; The PC from which we bombed
	MoveI t3, ^d8		; In octal ...
	NOUT%			; Type the number
	 ErJmp [MoveI t2, "?"
		BOUT%		; Don't even know the number
		 ErJmp .+1
		Jrst .+1 ]	; Move on anyway


	HrrOI t2, [AsciZ/ -- /]
	SetZ t3,		; Stop on a null
	SOUT%			; Send the string
	 ErJmp .+1

	Push p, t1		; Save tty desig
	SetO t1,		; Want most recent error
	Call TypErr		; Type out the error message
	Pop p, t1		; Restore tty desig
	HrrOI t2, ErrStr	; Get the string we just built
	SetZ t3,
	SOUT%
	 ErJmp .+1

	HrrOI t2, [AsciZ/
% Halting ...

/]
	SetZ t3,
	SOUT%
	 ErJmp .+1

	Call AcLoad		; Restore regs

	HALTF%			; Stop cold
	DEBRK%			;  but debreak if user wants to
	 ErJmp .+1

	Tmsg <
? WCL bug: Fell through panic DEBRK
>
	 ErJmp .+1		;  Just in case ...

	HALTF%			; Stop cold (what else can we do?)
	Jrst .-1

	SubTtl WclBdm -- Reference to nonexistent page, see if a problem

WclBdm:	Call AcSave		; Save temp ac's

	HrrZ t1, Wcl1PC		; PC from whence we came
	MoveI t1, @0(t1)	; Get address which was referenced
	Lsh t1, -^d9		; Make it a page number

	CamG t1, HiCore		; Compare with highest we saw
	 Jrst [	Call ACLoad	; Get back saved AC's
		Jrst WclDeb ]	; Go debreak

	Move t2, HiCore		; Pick up high core address
	CaiN t1, 1(t2)		; Is this page the next one?
	 Jrst [	Aos HiCore	;  Yes, bump the core count
		Call ACLoad	; Get back saved AC's
		Jrst WclDeb ]	; Go debreak

	Move t1, OldTty		; Get tty number
	TxO t1, .TtDes		; Make it a device designator
	HrrOI t2, [AsciZ/
? WCL bug:  Wild reference to memory location /] ; Complain
	SetZ t3,		; Stop on a null
	SOUT%			; Send the string
	 ErJmp .+1

	HrrZ t2, Wcl1PC		; The PC from which we bombed
	MoveI t2, @0(t2)	; Get address which was referenced
	MoveI t3, ^d8		; In octal ...
	NOUT%			; Type the number
	 ErJmp [MoveI t2, "?"
		BOUT%		; Don't even know the number
		 ErJmp .+1
		Jrst .+1 ]	; Move on anyway

	HrrOI t2, [AsciZ/ from location /]
	SetZ t3,		; Stop on null
	SOUT%
	 ErJmp .+1

	HrrZ t2, Wcl1PC		; The PC from which we bombed
	MoveI t3, ^d8		; In octal ...
	NOUT%			; Type the number
	 ErJmp [MoveI t2, "?"
		BOUT%		; Don't even know the number
		 ErJmp .+1
		Jrst .+1 ]	; Move on anyway

	HrrOI t2, [AsciZ/
% Halting ...

/]
	SetZ t3,
	SOUT%
	 ErJmp .+1

	Call AcLoad		; Restore regs

	HALTF%			; Stop cold

WclDeb:	DEBRK%			;  but debreak if user wants to
	 ErJmp .+1

	Tmsg <
? WCL bug: Fell through bad memory reference DEBRK
>
	 ErJmp .+1		;  Just in case ...

	HALTF%			; Stop cold (what else can we do?)
	Jrst .-1

	End
  