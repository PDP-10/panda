	Title WKeys -- Subroutines to handles terminal keys

Comment \


Tad Marshall, American Express Co., March - November 1981


		Table of Contents	       Page(s)

Entrys & Externs ............................... 2

\

	SubTtl Entrys & Externs

; Entry points of subroutines found in WKeys ...

	Entry EscChk, ConWcl

; External symbols required

	Extern EscDly, PtyStr, PiOff,  PiOn,   EchByt, Beep,   WinHdr, GetPtf
	Extern BldBan, NewSjb, PtyIni, NewWin, DmpBfr, TrmImg, BldSbn

	Search WSym, MonSym, MacSym ; The symbols we need
	Sall			; Suppress macro expansions

	SubTtl EscChk -- Check for escape sequence from DEC Vt100

EscChk:	SetZM DidEsc		; We haven't yet done an escape sequence ...

	Move t1, VtType		; Get term type
	CaiN t1, Im3101		; Is it IBM 3101?
	 Jrst Esc101		;  Yes, run the other routine

	CaiN t1, Vt52		; Is it Vt52?
	 Jrst EscV52		;  Yes, run the other routine

	CaiE t1, Vt100		; Is it Vt100?
	 Ret			;  No, wouldn't know a key anyway ...

	MoveI t1, .PriIn	; Get back the right jfn
	BIN%			; Get the next byte
	AndI t2, 177		; Keep only ASCII bits, no parity
	CaiN t2, "O"		; See if it is a capital O
	 Jrst [	SIBE%		;  Yes, it is, see if any more chars
		 TrnA		; There are more chars, go get them
		  Jrst [MoveI t1, "O" ; No more chars, get a capital O
			Call PtIPut ; Stuff it in the input buffer
			 Bug (HLT,<Can't add 1 char to buffer>)
			Ret ]	; and return
		BIN%		; Get the next char
		AndI t2, 177	; Keep only ASCII bits, no parity
		CaiN t2, "A"	; Is it up-arrow-key?
		 Jrst [	Call UpArro ; Handle it
			Jrst CesEnd ] ; And flush this key

		CaiN t2, "B"	; Is it down-arrow-key?
		 Jrst [	Call DnArro ; Handle it
			Jrst CesEnd ] ; And flush this key

		CaiN t2, "C"	; Is it right-arrow-key?
		 Jrst [	Call RtArro ; Handle it
			Jrst CesEnd ] ; And flush this key

		CaiN t2, "D"	; Is it left-arrow-key?
		 Jrst [	Call LfArro ; Handle it
			Jrst CesEnd ] ; And flush this key

		CaiN t2, "M"	; Is it enter?
		 Jrst [	Call EnterK ; Handle it
			Jrst CesEnd ] ; and continue ...

		CaiN t2, "P"	; Is it PF1?
		 Jrst [	Call Pf1 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "Q"	; Is it PF2?
		 Jrst [	Call Pf2 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "R"	; Is it PF3?
		 Jrst [	Call Pf3 ; Handle it
			Jrst CesEnd ] ; Done here

		CaiN t2, "S"	; Is it PF4?
		 Jrst [	Call Pf4 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "l"	; Is it keypad comma?
		 Jrst [	Call CommaK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "m"	; Is it keypad minus?
		 Jrst [	Call MinusK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "n"	; Is it keypad period?
		 Jrst [	Call Period ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "p"	; Is it keypad zero?
		 Jrst [	Call ZeroKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "q"	; Is it keypad one?
		 Jrst [	Call OneKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "r"	; Is it keypad two?
		 Jrst [	Call TwoKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "s"	; Is it keypad three?
		 Jrst [	Call ThreeK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "t"	; Is it keypad four?
		 Jrst [	Call FourKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "u"	; Is it keypad five?
		 Jrst [	Call FiveKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "v"	; Is it keypad six?
		 Jrst [	Call SixKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "w"	; Is it keypad seven?
		 Jrst [	Call SevenK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "x"	; Is it keypad eight?
		 Jrst [	Call EightK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "y"	; Is it keypad nine?
		 Jrst [	Call NineKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

	;continued on next page
	;continued from previous page

		Push p, t2	; Save the char for a second
		MoveI t1, "O"	; Get the capital O again
		Call PtIPut	; Stuff it in the buffer
		 Bug (HLT,<Can't add 1 char to buffer>)
		Pop p, t1	; Get back the char (into t1 this time)
		Call PtIPut	; Stuff it
		 Bug (HLT,<Can't add 1 char to buffer>)
		Ret ]		;  and return to stream

	MoveI t1, 0(t2)		; Copy down the character
	Call PtIPut		; Stuff it
	 Bug (HLT,<Can't add 1 char to buffer>)

	Ret			;  and return with empty hands ...

	SubTtl Esc101 -- Check for escape sequence from IBM 3101

Esc101:	MoveI t1, .PriIn	; Get back the right jfn
	BIN%			; Get the next byte

	AndI t2, 177		; Keep only ASCII bits, no parity

	CaiN t2, "A"		; Is it up-arrow-key?
	 Jrst [	Call UpArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "B"		; Is it down-arrow-key?
	 Jrst [	Call DnArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "C"		; Is it right-arrow-key?
	 Jrst [	Call RtArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "D"		; Is it left-arrow-key?
	 Jrst [	Call LfArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "H"		; "Home" key?
	 Jrst [	Call ZeroKy	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "I"		; Is it "Erase EOL/EOF"?
	 Jrst [	Call OneKey	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "J"		; Is it "Erase EOS"?
	 Jrst [	Call ThreeK	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "K"		; Is it "Erase input"?
	 Jrst [	Call TwoKey	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "L"		; Is it "Clear"?
	 Jrst [	Call FourKy	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "S"		; Is it "Cancel"?
	 Jrst [	Call Period	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "U"		; Is it "Print line"?
	 Jrst [	Call MinusK	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "V"		; Is it "Print message"?
	 Jrst [	Call CommaK	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "W"		; Is it "Print page"?
	 Jrst [	Call NineKy	; Handle it
		Jrst CesEnd ]	; And flush this key

	Push p, t2		; Save the char we got
	CaiL t2, "a"		; Is it between lowercase "a"
	 CaiLE t2, "h"		;  ... and lowercase "h"?
	  TrnA			;   No ...
	 Jrst [	SIBE%		;  Yes, it is, see if any more chars
		 TrnA		; There are more chars, go get them
		  Jrst [Pop p, t1 ; Get back the char we saw
			Call PtIPut ; Stuff it in the input buffer
			 Bug (HLT,<Can't add 1 char to buffer>)
			Ret ]	; and return
		BIN%		; Get the next char
		AndI t2, 177	; Keep only ASCII bits, no parity
		CaiN t2, .ChCnC	; Control-C?
		 TrnA		;  Yes, found a good end char
		CaiN t2, .ChCnD	; Control-D?
		 TrnA		;  Yes, found a good end char
		CaiN t2, .ChCrt	; Return?
		 TrnA		;  Yes, found a good end char
		CaiN t2, .ChCnS	; Control-S?
		 TrnA		;  Yes, found a good end char
		  Jrst [Exch t1, 0(p) ; Swap with saved char
			Call PtIPut ; Stuff the first char
			 Bug (HLT,<Can't stuff char>)
			Pop p, t1 ; Get back the terminator
			Call PtIPut ; Stuff this char
			 Bug (HLT,<Can't stuff char>)
			Ret ]	; and return ...

		Pop p, t2	; All is ok, see which key this is
		CaiN t2, "a"	; Is it PF1?
		 Jrst [	Call Pf1 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "b"	; Is it PF2?
		 Jrst [	Call Pf2 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "c"	; Is it PF3?
		 Jrst [	Call Pf3 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "d"	; Is it PF4?
		 Jrst [	Call Pf4 ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "e"	; Is it PF5?
		 Jrst [	Call FiveKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "f"	; Is it PF6?
		 Jrst [	Call SixKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "g"	; Is it PF7?
		 Jrst [	Call SevenK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "h"	; Is it PF8?
		 Jrst [	Call EightK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		Jrst CesEnd ]	; and continue ...

	Pop p, t1		; Get char into t1
	Call PtIPut		; Stuff it
	 Bug (HLT,<Can't add 1 char to buffer>)

	Ret			;  and return with empty hands ...

	SubTtl EscV52 -- Check for escape sequence from DEC Vt52

EscV52:	MoveI t1, .PriIn	; Get back the right jfn
	BIN%			; Get the next byte

	AndI t2, 177		; Keep only ASCII bits, no parity

	CaiN t2, "A"		; Is it up-arrow-key?
	 Jrst [	Call UpArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "B"		; Is it down-arrow-key?
	 Jrst [	Call DnArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "C"		; Is it right-arrow-key?
	 Jrst [	Call RtArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "D"		; Is it left-arrow-key?
	 Jrst [	Call LfArro	; Handle it
		Jrst CesEnd ]	; And flush this key

	CaiN t2, "P"		; Is it PF1?
	 Jrst [	Call Pf1	; Handle it
		Jrst CesEnd ]	; All taken care of, just continue

	CaiN t2, "Q"		; Is it PF2?
	 Jrst [	Call Pf2	; Handle it
		Jrst CesEnd ]	; All taken care of, just continue

	CaiN t2, "R"		; Is it PF3?
	 Jrst [	Call Pf3	; Handle it
		Jrst CesEnd ]	; Done here

	CaiN t2, "S"		; Is it PF4?
	 Jrst [	Call Pf4	; Handle it
		Jrst CesEnd ]	; All taken care of, just continue

	CaiN t2, "?"		; See if it is a question mark
	 Jrst [	SIBE%		;  Yes, it is, see if any more chars
		 TrnA		; There are more chars, go get them
		  Jrst [MoveI t1, "?" ; No more chars, get a question mark
			Call PtIPut ; Stuff it in the input buffer
			 Bug (HLT,<Can't add 1 char to buffer>)
			Ret ]	; and return
		BIN%		; Get the next char
		AndI t2, 177	; Keep only ASCII bits, no parity

		CaiN t2, "M"	; Is it enter?
		 Jrst [	Call EnterK ; Handle it
			Jrst CesEnd ] ; and continue ...

		CaiN t2, "l"	; Is it keypad comma?
		 Jrst [	Call CommaK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "m"	; Is it keypad minus?
		 Jrst [	Call MinusK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "n"	; Is it keypad period?
		 Jrst [	Call Period ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "p"	; Is it keypad zero?
		 Jrst [	Call ZeroKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "q"	; Is it keypad one?
		 Jrst [	Call OneKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "r"	; Is it keypad two?
		 Jrst [	Call TwoKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "s"	; Is it keypad three?
		 Jrst [	Call ThreeK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "t"	; Is it keypad four?
		 Jrst [	Call FourKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "u"	; Is it keypad five?
		 Jrst [	Call FiveKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "v"	; Is it keypad six?
		 Jrst [	Call SixKey ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "w"	; Is it keypad seven?
		 Jrst [	Call SevenK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "x"	; Is it keypad eight?
		 Jrst [	Call EightK ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

		CaiN t2, "y"	; Is it keypad nine?
		 Jrst [	Call NineKy ; Handle it
			Jrst CesEnd ] ; All taken care of, just continue

	;continued on next page
	;continued from previous page

		Push p, t2	; Save the char for a second
		MoveI t1, "?"	; Get the question mark again
		Call PtIPut	; Stuff it in the buffer
		 Bug (HLT,<Can't add 1 char to buffer>)
		Pop p, t1	; Get back the char (into t1 this time)
		Call PtIPut	; Stuff it
		 Bug (HLT,<Can't add 1 char to buffer>)
		Ret ]		;  and return to stream

	MoveI t1, 0(t2)		; Copy down the character
	Call PtIPut		; Stuff it
	 Bug (HLT,<Can't add 1 char to buffer>)

	Ret			;  and return with empty hands ...

	;continued on next page
	;continued from previous page

;
;  Done processing escape-sequence key, go get a new char
;

CesEnd:	SetOM DidEsc		; Flag that we "used" this escape ...
	Ret			;  and return


	SubTtl PtIPut -- Routine to store a character into a pty buffer

PtIPut:	Move t2, PtICnt(i)	; Get count of chars in buffer
	CaiL t2, PtyMxC		; Is buffer full?
	 Ret			; Yes, don't overfill it

	Idpb t1, PtIPbp(i)	; Store character
	Move t2, PtIPbp(i)	; Get new pointer
	CamN t2, PtIEbp(i)	; Is it time to wrap around?
	 Move t2, PtIIbp(i)	;  Yes, wrap it around to beginning

	MoveM t2, PtIPbp(i)	; Store updated pointer
	Aos PtICnt(i)		; Increment count

	RetSkp			; Give successful return

	SubTtl Key handling routines

UpArro:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/[A/] ; What a Vt100 key would send
		SkpfOf PtCurF	; See which cursor-key mode we are in
		 MoveI t4, [AsciZ/OA/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	Call GoTrce		; Flag the trace

	HlrZ t1, PtyNSL(i)	; Get current window size
	SubI t1, 3		; Subtract 3 (1 banner, 2 overlap)

UpaLop:	Call UpTrce		; Back up by one line
	 Jrst UpaDon		;  Failed ...

	SojG t1, UpaLop		; If more, go do them

	SetOM NoScrl		; Disable scrolling for next update

UpaDon:	SetFOn StrChg		; Structure changed
	Call BldBan		; Build a new banner for this sj
	SetZM PtyBtm(i)		; Force a banner update
	Jrst GenInt		; Go gen an interrupt, ret from there

DnArro:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/[B/] ; What a Vt100 key would send
		SkpfOf PtCurF	; See which cursor-key mode we are in
		 MoveI t4, [AsciZ/OB/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkpfOn PtTrcF		; Are we tracing?
	 Jrst [	Call Beep	;  Yes, can't budge, just beep
		MoveI t1, .PriIn ; The terminal
		CFIBF%		; Clear its buffer (to prevent repeated beeps)
		Ret ]		; Done here

	HlrZ t1, PtyNSL(i)	; Get current window size
	SubI t1, 3		; Subtract 3 (1 banner, 2 overlap)

DnaLop:	Call DnTrce		; Go forward by one line
	 Jrst [	Call UnTrce	;  If we are back to the beginning, untrace
		Jrst DnaDon ]	;  Failed ...

	SojG t1, DnaLop		; If more, go do them

	SetOM NoScrl		; Disable scrolling for next update

DnaDon:	SetFOn StrChg		; Structure changed
	SetZM PtyBtm(i)		; Force a banner update
	Jrst GenInt		; Go gen an interrupt, ret from there

LfArro:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/[D/] ; What a Vt100 key would send
		SkpfOf PtCurF	; See which cursor-key mode we are in
		 MoveI t4, [AsciZ/OD/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	Call GoTrce		; Just flag a trace for now

	Call UpTrce		; Go back by one line
	 Trn			;  Doesn't matter whether it worked or not

	SetFOn StrChg		; Structure changed
	Call BldBan		; Build a new banner for this sj
	SetZM PtyBtm(i)		; Force a banner update
	Jrst GenInt		; Go gen an interrupt, ret from there

RtArro:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/[C/] ; What a Vt100 key would send
		SkpfOf PtCurF	; See which cursor-key mode we are in
		 MoveI t4, [AsciZ/OC/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkpfOn PtTrcF		; Are we tracing?
	 Jrst [	Call Beep	;  Yes, can't budge, just beep
		MoveI t1, .PriIn ; The terminal
		CFIBF%		; Clear its buffer (to prevent repeated beeps)
		Ret ]		; Done here

	Call DnTrce		; Go forward by one line
	 Call UnTrce		;  If we are back to the beginning, untrace

	SetFOn StrChg		; Structure changed
	SetZM PtyBtm(i)		; Force a banner update
	Jrst GenInt		; Go gen an interrupt, ret from there

Pf1:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/OP/] ; What a Vt100 key would send
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkipE OneWin		; Already in that mode?
	 Jrst Beep		;  Yes, beep at the user, ret from there

	SetOM OneWin		; Set the flag
	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Go gen an interrupt, ret from there

Pf2:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/OQ/] ; What a Vt100 key would send
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkipN OneWin		; Already in that mode?
	 Jrst Beep		;  Yes, beep at the user, ret from there

	SetZM OneWin		; Clear one window flag
	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Go gen an interrupt, ret from there

Pf3:	TestOn Litral		; Handle literally?
	 Jrst LitPF3		;  Yes ...

	TstWOn (PF3R, Restri)	; Is this resticted?
LitPF3:	 Jrst [	MoveI t4, [AsciZ/OR/] ; What a Vt100 key would send
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	Jrst ConWcl		; Connect to WCL, return from there

Pf4:	TestOn Litral		; Handle literally?
	 Jrst LitPF4		;  Yes ...

	TstWOn (PF4R, Restri)	; Is this resticted?
LitPF4:	 Jrst [	MoveI t4, [AsciZ/OS/] ; What a Vt100 key would send
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkipE ConSjb		; Are we in WCL?
	 Jrst Pf4Tag		;  No, use this routine ...

	Call ConWin		; Yes, use this connector ...

	TrnA			; Skip the other call ...

; Else ...

Pf4Tag:	Call AdvWin		; Advance from a subjob

	MoveM i, ConSjb		; Make this one be the new connected

	Call NewSjb		; Say we switched subjobs ...

	SkipE i, ConSjb		; If subjob is not WCL ...
	 MoveM i, LstCon	;  Make this one be the last connected also

	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Gen an int, ret from there

CommaK:	TestOn Litral		; Handle literally?
	 Jrst LitCma		;  Yes ...

	TstWOn (CommaR, Restri)	; Is it restricted?
LitCma:	 Jrst [	MoveI t4, [AsciZ/,/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ol/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Already have a prefix?
	 Jrst ShoKys		;  Yes, show keypad map

	SetOM SetPre		; No prefix yet, say we want it set
	Ret			; Thats all

MinusK:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/-/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Om/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	Jrst Beep		; Undefined either way

EnterK:	TestOn Litral		; Handle literally?
	 Jrst LitEnt		;  Yes

	TstWOn (EnterR, Restri)	; Is this resticted?
LitEnt:	 Jrst [	MoveI t4, [AsciZ//] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/OM/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst [	SetCmM ScrBnF	; Toggle the screen banner flag
		SkipE ScrBnF	; Are we bringing it up now?
		 Call BldSbn	;  Yes, make up a new one
		SetFOn StrChg	; Need new lists
		Jrst GenInt ]	; Go do it

	MovX t1, PtNobF		; Get no banner flag in lh
	XorM t1, PtySts(i)	; Flip the bit for this subjob (may be WCL)

	SkpfOn PtNobF		; Are we bringing it up now?
	 Call BldBan		;  Yes, make up a new one

	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Make an int, ret from there

Period:	CamN i, Editor		; In the editor?
	 Jrst RetEdi		;  Yes, just return from it ...

	TestOn Litral		; Handle literally?
	 Jrst LitPer		;  Yes ...

	SkipA			; No restriction test yet
LitPer:	 Jrst [	MoveI t4, [AsciZ/./] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/On/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	Jrst UnTrce		; Undo any tracing, return from there

ZeroKy:	TestOn Litral		; Handle literally?
	 Jrst Lit0		;  Yes ...

	TstWOn (ZeroR, Restri)	; Is this resticted?
Lit0:	 Jrst [	MoveI t4, [AsciZ/0/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Op/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SetFOn WntPsh		; Flag that a push is wanted

	Ret			; That's all

OneKey:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/1/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Oq/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Start fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		Load t3, Rf%Sts, t1 ; Pick up the relevant bits
		CaiE t3, .RfHlt	; Is he halted?
		 Jrst Beep	;  No, so beep ...
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		SetZ t2,	; Start at offset zero
		SFRKV%		; Start him up
		 JEcBug (HLT,<Can't start fork>)
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys		; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

TwoKey:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/2/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Or/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Reenter fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		Load t3, Rf%Sts, t1 ; Pick up the relevant bits
		CaiE t3, .RfHlt	; Is he halted?
		 Jrst Beep	;  No, so beep ...
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		MoveI t2, 1	; Start at offset one
		SFRKV%		; Start him up
		 JEcBug (HLT,<Can't reenter fork>)
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys+1	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

ThreeK:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/3/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Os/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Continue fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpLE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		Load t3, Rf%Sts, t1 ; Pick up the relevant bits
		CaiE t3, .RfHlt	; Is he halted?
		 Jrst Beep	;  No, so beep ...
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		TxO t1, Sf%Con	; Continue him
		SFORK%		; Try to continue the fork ...
		 JEcBug (HLT,<Can't continue fork>)
		MovX t1, PtHltF	; Flag for seen to be halted
		AndCam t1, PtySts(i) ; Turn off the flag
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys+2	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

FourKy:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/4/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ot/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Halt fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpLE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		Load t3, Rf%Sts, t1 ; Pick up the relevant bits
		CaiN t3, .RfHlt	; Is he halted?
		 Jrst Beep	;  No, so beep ...
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		HFORK%		; Try to halt the fork ...
		 JEcBug (HLT,<Can't halt fork>)
		MovX t1, PtHltF	; Flag for seen to be halted
		IOrM t1, PtySts(i) ; Turn on the flag
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys+3	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

FiveKy:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/5/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ou/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Freeze fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		JumpL t1, Beep	; Beep if already frozen
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		FFORK%		; Try to freeze the fork ...
		 JEcBug (HLT,<Can't freeze fork>)
		MovX t1, PtDlFF	; Flag for deliberately frozen
		IOrM t1, PtySts(i) ; Turn on the flag
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys+4	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

SixKey:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/6/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ov/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Is there a prefix?
	 Jrst [	SetFOn WntDet	;  Yes, flag that we want to detach
		Ret ]		; That's it ...

	SkipE t4, Keys+5	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

SevenK:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/7/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ow/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

; Resume fork?
	SkipE PreFix		; Prefix set?
	 Jrst [	JumpE i, Beep	; If WCL, just beep
		HrrZ t1, PtyFrk(i) ; Handle of this fork
		JumpE t1, Beep	; Beep if not a fork
		RFSTS%		; Get his status
		 JEcBug (HLT,<Can't get fork status>)
		JumpGE t1, Beep ; Beep if not frozen
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		RFORK% ; Try to resume the fork ...
		 JEcBug (HLT,<Can't resume fork>)
		MovX t1, PtDlFF	; Flag for deliberately frozen
		AndCam t1, PtySts(i) ; Turn off the flag
		Jrst FrkCmn ]	; Join common fork finish

	SkipE t4, Keys+6	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

; Common finish for fork code

FrkCmn:	MoveI t1, ^d110		; This many milliseconds
	DISMS%			; Sleep ...

	SetZM PtyBtm(i)		; Force a banner update
	SetZM Prefix		; Forget we had a prefix
	Jrst GenInt		; Cause a screen update to show the new status	

EightK:	TestOn Litral		; Handle literally?
	 Jrst [	MoveI t4, [AsciZ/8/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Ox/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Is there a prefix set?
	 Jrst Beep		;  Yes ...

	SkipE t4, Keys+7	; Is there a key defined?
	 Jrst PtyStr		;  Yes, go send it along ...

	Jrst Beep		; Undefined

NineKy:	TestOn Litral		; Handle literally?
	 Jrst Lit9		;  Yes, send the key directly

	TstWOn (NineR, Restri)	; Is the nine key resticted?
Lit9:	 Jrst [	MoveI t4, [AsciZ/9/] ; What a Vt100 key would send
		SkpfOf PtPadF	; See which keypad mode we are in
		 MoveI t4, [AsciZ/Oy/]	; The other mode
		Jrst PtyStr ]	; Send it to the subjob, return from there

	SkipE Prefix		; Prefix set?
	 Jrst Beep		;  Yes, this is undefined

	SkipG Editor		; Is there an editor?
	 Jrst CreEdi		;  No, create an editor fork, then invoke it

	Call CalEdi		; Invoke the editor

	HrrZ t1, PtyFrk(i)	; Handle of editor fork
	RFSTS%			; Get his status
	 JEcBug (HLT,<Can't get status of editor fork>)

	Load t3, Rf%Sts, t1	; Pick up the relevant bits
	CaiN t3, .RfHlt		; Is he halted?
	 Jrst [	HrrZ t1, PtyTtd(i) ; Get tty desig for him
		HrrOI t2, [AsciZ/
% EMACS has halted, continuing it ...
/]
		SetZ t3,	; Stop on a null
		SOUT%		; Send this explanation
		MoveI t1, ^d2000 ; A while ...
		DISMS%		; Wait ...
		HrrZ t1, PtyFrk(i) ; Get fork handle again
		TxO t1, Sf%Con	; Continue him
		SFORK%		; Try to continue the fork ...
		Jrst .+1 ]

	Ret			; Done here

	SubTtl ConWin -- Connect to a subjob, via PF4 key

ConWin:	SkipLE LstCon		; Is there a last connected?
	 Jrst [	Move i, LstCon	;  Yes, get its number
		Ret ]		;  ... and go connect to it

	Move t1, SjList		; Get ptr to subjob list

CwnLop:	Move t2, 1(t1)		; Get the subjob number
	JumpE t2, CwnBot	; If this is WCL, skip it

	CamN t2, Editor		; The editor?
	 Jrst CwnBot		;  Yes, don't connect to it

	Move i, 1(t1)		; Get the subjob number
	Ret			;  ... and go connect to it

CwnBot:	HrrZ t1, 0(t1)		; Advance the ptr
	JumpN t1, CwnLop	; If there is another subjob, go do it

	Jrst Beep		; None, just beep, ret from there

	SubTtl AdvWin -- Advance to the next visible window, if we can

AdvWin:	Move t1, SjList		; Get ptr to subjob list
AwnLp1:	Move i, 1(t1)		; Get subjob number
	CamN i, ConSjb		; Have we found the connected one?
	 Jrst AwnLp2		;  Yes, skip on down
	HrrZ t1, 0(t1)		; Advance the list ptr
	JumpE t1, [Bug (HLT,<Connected subjob not on subjob list!>)]
	Jrst AwnLp1		; Go look at the next one

AwnLp2:	HrrZ t1, 0(t1)		; Advance the ptr
	JumpE t1, [Move t1, SjList ; If last in list, rescan the list
		   Jrst .+1 ]	; and continue

	Move i, 1(t1)		; Load up the subjob id
	CamN i, ConSjb		; Have we hit the connected one again?
	 Jrst Beep		;  Yes, just beep and do nothing

	JumpE i, AwnLp2		; If we hit WCL, skip it

	CamN i, Editor		; The editor?
	 Jrst AwnLp2		;  Yes, don't advance to it

	Ret			; Got a good one, return with it

	SubTtl ConWCL --- Connect to Window Command Level

ConWcl:	SkipN ConSjb		; Already WCL?
	 Jrst Beep		;  Yes, just beep at him

	Call PiOff		; Ints off

	SetZB i, ConSjb		; Now connected to WCL

	Call NewSjb		; Say we switched subjobs

	MoveI t1, "^"		; Get an uparrow
	Call EchByt		; Type it
	Move t1, TrpChr		; Trap char
	TxO t1, 100		; Make it ascii
	Call EchByt		; Type it

	Call WinHdr		; Get a header to show where we are

	Call PiOn		; Ints on

	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Go gen an interrupt, ret from there

	SubTtl CreEdi -- Create an editor fork

CreEdi:	MovX t1, Gj%Sht ! Gj%Old ; Short form, old file
	HrrOI t2, [AsciZ/Emacs:Emacs.Exe /] ; Name of the editor
	GTJFN%			; Get a jfn on the file if we can
	 Jrst Beep		;  Nope ...

	HrrZM t1, EdiJfn	; Store the jfn we got

	SetZ i,			; Start at zero
	Move t3, NumPty		; The number of ptys we can use
CedLop:	SkipN PtyNam(i)		; See if assigned yet
	 Jrst CedTag		;  No, we got one
	AddI i, PtyLen		; Go to next slot
	SojG t3, CedLop		; Loop

	Bug (HLT,<Can't find space in subjob tables for editor>)

	Move t1, EdiJfn		; Get back the jfn
	RLJFN%			; Release it
	 Trn			; Ignore error
	SetZM EdiJfn		; Forget we ever had this jfn
	Ret			; Return ...

CedTag:	MoveM i, Editor		; Save id for editor fork

	MoveI t1, [AsciZ/Emacs/] ; The name
	MoveM t1, PtyNam(i)	; Set it as the subjob name

	Call PiOff		; Ints off, for now

	Call GetPtF		; Set up a pty for the editor
	 Bug (HLT,<No PTYs available>)

; Be a pig ... this really IS an interactive fork, I don't care what the
;  Monitor thinks!

;	Move t1, PtyFrk(i)	; The editor fork
;	MovX t2, 1b29 ! 3b35	; Highest queue is 1, lowest is 2 (written
				;  as desired queue plus 1, see SJPRI% jsys)
;	SPRIW%			; Set the priority for this fork
;	 ErJmp .+1		;  Can't, must not be allowed ...

	Call PtyIni		; Do standard initialization stuff
	 Bug (HLT,<Can't initialize for editor PTY>)

	MovX t4, PtNoBF ! PtInvF ! PtLzyF ; Get "no banner", "invisible", and
				;  "lazy update" flags
	IOrM t4, PtySts(i)	; Set them

	Call NewWin		; Set up the empty window, put it on the list

	Call PiOn		; Ints back on

	Move i, ConSjb		; Remember who we are REALLY connected to ...
	Call CalEdi		; Set this up as the current window

	Move t1, PtyTtd(i)	; Get tty designator for this fork
	RFMOD%			; Get its mode
	TxZ t2, Tt%Dam		; Make it image mode
	SFMOD%			; Set it

	HrrOI t2, [AsciZ/[12;26HInvoking EMACS, please wait ...[14;19HUse keypad period (.) to return from EMACS.[H/]
	SetZ t3,		; Stop on a null
	SOUT%			; Send this text

	MoveI t1, ^d3000	; Leave the message there for a while ...
	DISMS%

	Hrr t1, EdiJfn		; Get jfn in right half
	Hrl t1, PtyFrk(i)	; Got a jfn, get fork handle in left half
	GET%			; First get the program into our fork
	 ErJmp [ JCBug (HLT,<Can't get editor into lower fork>)
		 Move t1, EdiJfn ; Get back the jfn
		 RLJFN%		; Release it
		  Trn		; Ignore error
		 SetOM Editor	; Forget we ever had this ...
		 Ret ]		; Return if continued

	SetZ t2,		; Clear a register
	HrrOI t1, t2		; Make a ptr to it
	RSCAN%			; Set up an empty rescan buffer for this guy
	 JEcBug (HLT,<Can't set up empty rescan buffer for EMACS>)

	Move t1, PtyFrk(i)	; Fork handle
	SetZ t2,		; Entry vector position zero
	SFRKV%			; Start fork
	 JEcBug (HLT,<Can't start editor>)

	Ret			; Done here ...

	SubTtl CalEdi -- Invoke the editor

CalEdi:	MoveM i, EdiFrm		; Say where we invoked the editor from ...

	Move i, Editor		; Get editor handle
	MoveM i, ConSjb		; Make this one be the new connected

	Call NewSjb		; Say we switched subjobs ...

	Move t1, PauCom		; Normal pause-on-command mode
	MoveM t1, EdiPau	; Save it for later
	SetZM PauCom		; Want it off for EMACS
	Call TrmImg		; Call this routine to set it

	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Force the screen update, ret from there

	SubTtl RetEdi -- Return from editor

RetEdi:	Move i, EdiFrm		; Where we invoked the editor from ...
	MoveM i, ConSjb		; Make this one be the new connected

	Call NewSjb		; Say we switched subjobs ...

	Move t1, EdiPau		; Saved pause-on-command mode
	MoveM t1, PauCom	; Restore it
	Call TrmImg		; Call this routine to set it

	SetFOn StrChg		; Say we need a new visible list (etc. ...)
	Jrst GenInt		; Gen an int, ret from there

	SubTtl ShoKys -- Show a keypad map on the screen

ShoKys:	Jrst Beep		; For now, just remove prefix, and beep

	SubTtl Tracing Routines

;
;   GoTrce -- Begin tracing a subjob
;
;	Call with:
;		i/ subjob id
;

GoTrce:	SkpfOf PtTrcF		; Already traced?
	 Ret			;  Yes, nothing to do

	MovX t1, PtTrcF		; The traced bit
	IOrM t1, PtySts(i)	; Set it

	MovX t1, PtHldF		; The hold flag
 	IOrM t1, PtySts(i)	; Set the bit

	SetZM PtyTCt(i)		; Zero traced amount

	Move t1, PtyPos(i)	; Pick up position
	MoveM t1, PtySPT(i)	; Save it
	MovX t1, <BotLin,,0>	; Put it in bottom row, column zero while
				;  traced ...
	MoveM t1, PtyPos(i)	; Store it

	Move t1, PtyRcl(i)	; Pick up current ptr to most recent line
	MoveM t1, PtySRc(i)	; Save it

	HrrZ t1, PtyLol(i)	; The low line ptr (into the right half)
	MoveM t1, PtyRcl(i)	; Make the low line the most-recent (for
				;  tracing purposes anyway ...)

	Hrl t1, PtyHil(i)	; The high line ptr (into the left half)
	MoveM t1, PtySHL(i)	; Save high and low ptrs

	Ret			; That's it

;
;   UnTrace -- End tracing a subjob
;
;	Call with:
;		i/ subjob id
;

UnTrce:	SkpfOn PtTrcF		; Already traced?
	 Jrst [	Call Beep	;  No, just beep and do nothing
		MoveI t1, .PriOu ; The terminal
		DOBE%		; Wait a sec ...
		MoveI t1, .PriIn ; Input tty jfn
		CFIBF%		; Clear its buffer (to prevent repeated beeps)
		Ret ]		; Done here

	Move t1, PtySRc(i)	; Get saved ptr into t1
	MoveM t1, PtyRcl(i)	; Restore saved ptr to most recent line

	Move t1, PtySPT(i)	; Get saved position
	MoveM t1, PtyPos(i)	; Restore it

	Move t1, PtySHL(i)	; Pick up saved high and low lines
	HlrZM t1, PtyHil(i)	; Restore high line
	HrrZM t1, PtyLol(i)	; Restore low line

	MovX t1, PtTrcF		; The traced bit
	AndCaM t1, PtySts(i)	; Clear it

	SetFOn StrChg		; Structure changed
	SetZM PtyBtm(i)		; Force a banner update
	Update			; Make the banner say not-traced

	MovX t1, PtHldF		; The hold flag
	AndCaM t1, PtySts(i)	; Clear the bit

	MoveI t1, .FhSlf	; This fork
	MovX t2, 1b<OptChn>	; This channel
	IIC%			; Initiate an int to check pty buffers

	Ret			; That's it for now


;
;  UpTrce -- Move "up" 1 line
;
;  Call with ...
;	i/ subjob id
;
;  Returns ...
;	+1/ Can't do it
;	+2/ Success

UpTrce:	Push p, t1		; Save regs
	Push p, t2
	Push p, t3

	Move t1, PtyHil(i)	; Get current high line ptr
	CamN t1, PtyTop(i)	; Is it already at the top?
	 Jrst UptTg1		;  Yes, can't move the whole screen up by one

	Move t1, .BkwPt(t1)	; Get back ptr from the high line

	Move t2, PtyRcl(i)	; Pick up ptr to recent line
	Move t2, .BkwPt(t2)	; Back ptr from it

	Move t3, PtyLol(i)	; Ptr to low line ...
	Move t3, .BkwPt(t3)	; Back ptr from it

	MoveM t1, PtyHil(i)	; Update ptr to high line ...
	MoveM t2, PtyRcl(i)	;  recent line ...
	MoveM t3, PtyLol(i)	;  and low line ...

	Aos PtyTCt(i)		; Increment trace count for this window

	Aos -3(p)		; Make the return a RetSkp

	Jrst UptEnd		; Go return ...

UptTg1:	HlrZ t1, PtyPos(i)	; Current position on (virtual) screen
	HlrZ t2, PtyNSL(i)	; Number of lines in currently displayed window
	CaiGE t1, -1(t2)	; Do we want to back up?
	 Jrst UptBep		;  No, go beep

	Sos t1			; Decr current position
	HrlM t1, PtyPos(i)	; Store the updated row (one less)

	Move t1, PtyRcl(i)	; Pick up ptr to recent line
	Move t1, .BkwPt(t1)	; Get back ptr from it
	MoveM t1, PtyRcl(i)	; Make most-recent be one higher on the screen

	HlrZ t1, PtyPos(i)	; Current position on (virtual) screen
	HlrZ t2, PtyNSL(i)	; Number of lines in currently displayed window
	CaiL t1, -1(t2)		; Are we now as far as we can go?
	 Aos -3(p)		;  Make the return a RetSkp

	Aos PtyTCt(i)		; Increment trace count for this window

	Jrst UptEnd		; Go exit

UptBep:	Call Beep		; Beep
	CFIBF%			; Clear input buffer (prevents repeated beeps)

UptEnd:	Pop p, t3		; Restore regs
	Pop p, t2
	Pop p, t1

	Ret			; All done


;
;  DnTrce -- Move "down" 1 line
;
;  Call with ...
;	i/ subjob id
;

DnTrce:	Push p, t1		; Save regs
	Push p, t2
	Push p, t3

	Move t1, PtyRcl(i)	; Get current recent-line ptr
	CamN t1, PtyLol(i)	; Are we at the bottom of the virtual screen?
	 Jrst DntTg1		;  Yes, try to move the whole screen down by 1

	Move t1, .FwdPt(t1)	; Get forward ptr from the most-recent line
	MoveM t1, PtyRcl(i)	; Make most-recent be one lower on the screen

	HlrZ t1, PtyPos(i)	; Current position on (virtual) screen
	Aos t1			; Incr it
	HrlM t1, PtyPos(i)	; Store the updated row (one greater)

	Sos PtyTCt(i)		; Decrement trace count for this window

	Move t1, PtyRcl(i)	; Get current recent-line ptr
	CamN t1, PtyLol(i)	; Are we at the bottom of the virtual screen?
	 Jrst [	HrrZ t1, PtySHL(i) ; Get saved low line ptr
		CamN t1, PtyLol(i) ; Are we already at the bottom?
		 Jrst DntEnd	;  Yes, we really are back where we started,
				;    so do the UnTrce
		Jrst .+1 ]	; Return to stream

	Aos -3(p)		; Don't do an untrace ...

	Jrst DntEnd		; Go return ...

DntTg1:	HrrZ t1, PtySHL(i)	; Get saved low line ptr
	CamN t1, PtyLol(i)	; Are we already at the bottom?
	 Jrst DntEnd		;  Yes, can't budge

	Move t1, PtyHil(i)	; Pick up high line ptr
	Move t1, .FwdPt(t1)	; Get forward ptr from the high line

	Move t2, PtyRcl(i)	; Pick up ptr to recent line
	Move t2, .FwdPt(t2)	; Forward ptr from it

	Move t3, PtyLol(i)	; Ptr to low line ...
	Move t3, .FwdPt(t3)	; Forward ptr from it

	MoveM t1, PtyHil(i)	; Update ptr to high line ...
	MoveM t2, PtyRcl(i)	;  recent line ...
	MoveM t3, PtyLol(i)	;  and low line ...

	HrrZ t1, PtySHL(i)	; Get saved low line ptr
	CamE t1, PtyLol(i)	; Have we now restored our old position?
	 Aos -3(p)		;  No, make the return a RetSkp so we don't
				;  UnTrce before our time ...

	Sos PtyTCt(i)		; Decrement trace count for this window

DntEnd:	Pop p, t3		; Restore regs
	Pop p, t2
	Pop p, t1

	Ret			; All done

	End
