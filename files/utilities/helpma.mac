;<UTILITIES>HELPMA.MAC.30,  3-Dec-85 12:14:03, Edit by MRC
; Fix bug in ADDIT if no TB%ABR
;USERS:<SU-UTILITIES>HELPMA.MAC.29, 24-Jun-85 13:44:04, Edit by FRANK
; Document difference between EXIT and QUIT commands
; Add to and clarify internal help
;<SU-UTILITIES>HELPMA.MAC.28,  7-Jun-85 16:35:02, Edit by FMF
; Be careful about the aobjn pointer in VERIFY, especially if we
;  delete something with abbreviations
;<SU-UTILITIES>HELPMA.MAC.27,  7-Jun-85 16:22:16, Edit by FMF
;<SU-UTILITIES>HELPMA.MAC.26,  7-Jun-85 16:12:46, Edit by FMF
; VERTBX should return with a jrst, not a ret
; If TB%ABR, don't "verify" abberviations
;<SU-UTILITIES>HELPMA.MAC.25,  7-Jun-85 15:30:25, Edit by FMF
; Make BUFLEN larger to allow for abbreviations
; Add /ABBREVIATION switch to ADD and /ABBR.. and /NO-ABBR.. to MODIFY
;  to allow abbreviations for keywords.  Note this needs TB%ABR to work.
;  For now it's in a compile switch, but the switch should eventually be
;  removed
; Change .MODIF to allow multiple switches
; Change macros to use "\" instead of "/" so we can use "/" in messges
;<SU-UTILITIES>HELPMA.MAC.24, 10-Aug-83 23:00:52, Edit by LOUGHEED
; Document MODIFY and VERIFY commands
;<SU-UTILITIES>HELPMA.MAC.23, 10-Aug-83 22:57:04, Edit by LOUGHEED
; Convert to MACRO assembly for export
;<SU-UTILITIES>HELPMA.FAI.19, 28-Feb-83 16:55:39, Edit by KRONJ
; Add MODIFY command
; always use CM%FW words even for visible entries
; (so MODIFY can change them later)
;<SU-UTILITIES>HELPMA.FAI.17, 23-Feb-83 15:37:20, Edit by KRONJ
; Never include generation in saved filespecs
;<SU-UTILITIES>HELPMA.FAI.11, 23-Feb-83 13:39:06, Edit by KRONJ
; Flush CM%FIX
;<SU-UTILITIES>HELPMA.FAI.9, 23-Feb-83 12:31:38, Edit by KRONJ
; EXIT saves any changes - add QUIT to leave without doing so
; add VERIFY command
;ACCT:<UTILITIES.SUBSYS>HELPMA.FAI.8, 18-Jul-81 22:59:07, Edit by B.BOMBADIL
; change TAKE command into REBUILD command
; R is for REMOVE
;ACCT:<UTILITIES.SUBSYS>HELPMA.FAI.7, 18-Jul-81 22:33:40, Edit by B.BOMBADIL
; table clobberage due to fouled TABFRE pointer - some fixes and bug traps
;ACCT:<UTILITIES.SUBSYS>HELPMA.FAI.4, 18-Jul-81 20:58:44, Edit by B.BOMBADIL
; remove LOAD command - too confusing and too dangerous
;ACCT:<UTILITIES.SUBSYS>HELPMA.FAI.3, 18-Jul-81 19:50:15, Edit by B.BOMBADIL
; experimental fix to table clobbering with LOAD command
;<B.BOMBADIL>HELPMA.FAI.2, 17-Jul-81 17:27:08, Edit by B.BOMBADIL
; I think those trvars are introducing subtle parsing bugs - removed them
;<B.BOMBADIL>HELPMA.FAI.1, 17-Jul-81 17:06:52, Edit by B.BOMBADIL

Title HELPMAINT - Maintain Fancy HELP Keyword Database
Search Monsym, Macsym
.require sys:macrel
asuppress
sall

a=1
b=2
c=3
d=4
p=17

pdlen==20
buflen==100
ifdef tb%abr,<
abrbfl==100			;buffer for abbreviations
>;ifdef tb%abr

tabpag==500			;map keyword table to this page
tabadr==tabpag*1000		;starting address of keyword table
tablen==777			;maximum length of keyword table
tabfre==tabadr+tablen+1		;free storage pointer

pdlist:	block pdlen		;pushdown stack 
atmbuf:	block buflen		;atom buffer for COMND%
cmdbuf:	block buflen		;command buffer for COMND%
keybuf:	block buflen		;keyword
filbuf:	block buflen		;file specification
changd:	block 1			;nonzero if we need to do a WRITE on EXIT
buildf:	block 1			;-1 if a rebuild command is in progress
bldjfn:	block 1			;jfn of build file (not necessarily HELP.CMD)
binjfn:	block 1			;jfn of HELP.BIN
txtjfn:	block 1			;jfn of HELP.CMD
swflag:	block 1			;keyword flags
ifdef tb%abr,<
abrptr:	block 1			;pointer into the abbreviation buffer
abrbuf:	block abrbfl		;generous buffer for abbreviations
>;ifdef tb%abr
oldfre:	block 1			;original free space pointer



;COMND% argument block

csb:	0,,repars		;.cmflg - reparse address, flags
	.priin,,.priou		;.cmioj - I/O jfns
	-1,,[asciz/HELPMAINT> /] ;.cmrty - pointer to prompt
	-1,,cmdbuf		;.cmbfp - holds whole command being assembled
	-1,,cmdbuf		;.cmptr - pointer to next field
	buflen*5-1		;.cmcnt - number of bytes in CMDBUF
	0			;.cminc - count of unparsed characters
	-1,,atmbuf		;.cmabp - pointer to atom buffer
	buflen*5-1		;.cmabc - number of bytes in ATMBUF
	ijfnbk			;.cmgjb - address of GTJFN% block


;GTJFN% argument block for input files

ijfnbk:	gj%old+.gjdef		;.gjgen - flags,,generation number
	.priin,,.priou		;.gjsrc - source/destination jfns
	-1,,[asciz/HLP/]	;.gjdev - default device
	0			;.gjdir - default directory
	0			;.gjnam - default name
	-1,,[asciz/HLP/]	;.gjext - default extension
	block ijfnbk+.gjatr+1-.	;we don't use the rest of the argument block


;GTJFN% argument block for command files

cjfnbk:	gj%old+.gjdef		;.gjgen - flags,,generation number
	.priin,,.priou		;.gjsrc - source/destination jfns
	-1,,[asciz/HLP/]	;.gjdev - default device
	0			;.gjdir - default directory
	-1,,[asciz/HELP/]	;.gjnam - default name
	-1,,[asciz/CMD/]	;.gjext - default extension
	block cjfnbk+.gjatr+1-.	;we don't use the rest of the argument block


;EMSG
;pretty print a general error message

define emsg (str) <
	 jrst [ hrroi a,[asciz\str\]
	 	call eprint
		haltf
		jrst .-1 ]
>


;JMSG
;informative error messages for JSYS failure returns

define jmsg (str) <
	 erjmp [ ifdif <str>,<>,<hrroi a,[asciz\str\]>
		 ifidn <str>,<>,<hrroi a,[asciz\JSYS error\]>
		 jrst perr ]
>

;PMSG
;handle parsing errors

define pmsg (str) <
	 jrst [ hrroi a,[asciz\str\] ;;pointer to a descriptive string
		call eprint	;;print the message
		jrst parse ]	;;jump to top of the parse loop
>


;NOISE
;print some noise words

define noise (str) <
	movei b,[flddb. .cmnoi,,<-1,,[asciz\str\]>] ;;b/ function code
	call .comnd		;;parse a noise word
	 pmsg <Invalid noise word> ;;some error
>

;KEYWRD
;create an entry in a keyword table

define keywrd (keywrd,addrss,flags) <
	ifidn <flags> <> < [asciz\keywrd\],,addrss>
	ifdif <flags> <> < [ cm%fw+flags
			     asciz\keywrd\ ],,addrss>
>

;entry vector information

evec:	jrst start		;START address
	jrst start		;REENTER address
evecl==.-evec	


;main loop of HELPMAINT program

start:	reset%			;reset the world
	move p,[iowd pdlen,pdlist] ;set up a stack
	setzm changd		;not changed yet
	call lodkey		;load up the default keyword table, if any
parse:	move a,tabfre		;###
	subi a,tabadr		;###
	jumpl a,[emsg <TABFRE (free space pointer) is negative!>] ;###
	movei b,[flddb. .cmini]
	call .comnd		;initialize the COMND% jsys
	 pmsg <Unable to initialize state block>
repars:	move p,[iowd pdlen,pdlist] ;reset stack in case of reparse
	movei b,[flddb. .cmkey,,comtab]
	call .comnd		;parse a command keyword
	 pmsg <Unrecognized command>
	hrrz b,(b)
	call (b)
	jrst parse


;.COMND
;COMND% jacket routine
;takes	b/ address of function descriptor block
;returns +1 no parse
;	 +2 good parse

.comnd:	movei a,csb		;a/ address of state block
	comnd%			;parse something
	 erjmp comndx		;some error, go check it out
	txnn a,cm%nop		;no parse?
	aos (p)			;no, skip return
	ret			;return to caller


;here on a COMND% error

comndx:	movei a,.fhslf		;a/ our fork
	geter%			;get the last error
	hrrzs b			;clear spurious bits
	caie b,iox4		;end of file reached?
	cain b,comnx9		;end of input file?
	 skipa			;yes, close the take file
	  emsg <Fatal error while parsing>
	skipn buildf		;are we doing a REBUILD command?
	 emsg <End of file, but not in a REBUILD command>
	setzm buildf		;clear rebuild flag
	move a,bldjfn		;a/ get jfn of command file
	closf%			;close it
	 jmsg			;report any errors
	move a,[xwd .priin,.priou] ;fetch primary jfns
	movem a,csb+.cmioj	;set them
	jrst parse		;jump to top of parse loop


;COMTAB
;command table

comtab:	xwd comlen,comlen
	keywrd (ADD,.add)
	keywrd (DISPLAY,.displ)
	keywrd (EXIT,.exit)
	keywrd (HELP,.help)
	keywrd (MODIFY,.modif)
	keywrd (QUIT,.quit)
	keywrd (R,comta0,cm%abr+cm%inv)	;R for REMOVE
	keywrd (REBUILD,.rebui)
comta0:	keywrd (REMOVE,.remov)
	keywrd (VERIFY,.verif)
 	keywrd (WRITE,.write)	
comlen==.-comtab-1


Subttl REBUILD command

;.REBUI
;take commands from a file
;returns +1 always

.rebui:	noise (KEYWORD TABLE FROM)	;some noise
	skipe buildf		;already rebuilding?
	 pmsg <Recursive REBUILD commands not permitted> ;yes, bomb the program
	movei a,cjfnbk
	movem a,csb+.cmgjb	;set up for parsing a command file spec
	movei b,[flddb. .cmfil]
	call .comnd
	 pmsg <Unable to parse that file name>
	movem b,bldjfn
	call confrm		;wait for confirmation
	setzm tabadr		;clear the table header
	setom buildf		;flag that we are in a REBUILD file
	move a,bldjfn		;a/ input jfn
	move b,[7b5+of%rd]	;b/ 7 bits, read access
	openf%			;open the file
	 jmsg			;some error
	hrlz a,bldjfn		;read jfn is from REBUILD file
	hrri a,.nulio		;write jfn is the null device
	movem a,csb+.cmioj	;set new I/O jfns
	setom changd		;something has changed
	ret			;return to caller

Subttl HELP and EXIT commands

;.HELP
;here on the help command

.help:	noise (WITH HELPMAINT)	;some noise
	call confrm		;wait for confirmation
	hrroi a,hlpmsg		;point to help message
	psout%			;print it
	ret			;return to caller

hlpmsg:	asciz\

HELPMAINT is used to edit the keyword table of help topics used by the
HELP program.  The keyword  table is in a  binary format and lives  in
the file HLP:HELP.BIN.  The  table is a  simple mapping of  keyword(s)
(help topics) to the appropriate help file.

When you run  HELPMAINT, the  keyword table  is automatically  loaded.
Use the ADD, REMOVE, and MODIFY  commands to edit the table.  Use  the
DISPLAY command to look at  all or parts of  the table.  When you  are
done, use the WRITE command to generate HLP:HELP.BIN and HLP:HELP.CMD,
a textual  representation of  the keyword  table.  To  regenerate  the
keyword table from HLP:HELP.CMD, use the REBUILD command.  The REBUILD
command allows  you  to rebuild  the  .BIN  file from  the  text  file
HLP.HELP.CMD.  The VERIFY command verifies that each keyword points to
a file and that every  .HLP file in HLP: has  an entry in the  keyword
table.  

To leave HELPMAINT, the QUIT command aborts without changes.  The EXIT
command updates your changes and returns you to the EXEC.

When adding a new keyword, be as general as possible with the file
specification.  This aids the table's transportability greatly.
    do this ->  HELPMAINT> ADD (KEYWORD) foo (POINTING TO) hlp:foo.hlp
    not this -> HELPMAINT> ADD (KEYWORD) foo (POINTING TO) sx:<help>foo.hlp.3

The /INVISIBLE switch in the ADD command causes a keyword to not be typed
out when a user types "HELP ?" to the EXEC.

HELPMAINT also knows about abbreviations.  For example, you can:

HELPMAINT> ADD INFORMATION HLP:INFORMATION.TXT /ABBREVIATION:I

and when you type HELP I it will give you help on information.  You
can also use the MODIFY command with the switches /ABBREVIATION and
/NO-ABBREVIATION.

\

;.EXIT
;here to gracefully leave HELP

.exit:	noise (AND UPDATE BINFILE)
	call confrm		;wait for confirmation
	skipe changd		;anything to save?
	 call .wr0		;yes, do so
	haltf%			;shut us down
	ret			;return to command loop if continued

.quit:	noise (FROM HELPMAINT)	;exit without saving
	call confrm		;finish command parse
	haltf%			;shut us down
	ret			;return to command loop if continued

Subttl ADD Command

;.ADD
;add a keyword to the table
;return +1 always

.add:	call addprs		;parse the command line
	call addit		;add results to table
	setom changd		;something has changed
	ret			;return to caller


;SWITAB
;table of add switches

switab:	xwd switbl,switbl
ifdef tb%abr,<
	keywrd (ABBREVIATION:,abrswi)
>;ifdef tb%abr
	keywrd (INVISIBLE,invswi)
switbl==.-switab-1

;here on the /INVISIBLE switch

invswi:	movx a,cm%inv+cm%fw	;invisible and flag word bits
	orm a,swflag		;set them
	ret			;return to caller

ifdef tb%abr,<
;here on the /ABBREVIATION: switch

abrswi:	movei b,[flddb. .cmfld]
	call .comnd		;parse the abbreviation
	 pmsg <Unable to parse abbreviation>
	move a,csb+.cmabp	;get the atom buffer pointer word
				; note we know atmbuf starts on a word boundary
	ibp a			;account for the null at the end
	hrrzs a			;isolate the right half
	subi a,atmbuf		;find out how many words it'll use
	add a,abrptr		;will we overflow the buffer?
	cail a,abrbuf+abrbfl	;let's see...
	 pmsg <Too many abbreviations> ;yes, complain
	movei a,tabadr
	hrroi b,atmbuf		;want to see if this item's in the table
	tbluk%			;let's see...
	txne b,tl%exm		;is it already in the table?
	 pmsg <Abbreviation already in table as abbrev. or keyword> ;oh well
	hrroi a,atmbuf		;the test string
	hrroi b,keybuf		;the base string
	stcmp%			;let's see what happens...
	txnn a,sc%sub		;the abbrev a substring?
	 pmsg <Given abbreviation not a valid abbreviation of keyword> ;nope
	movei d,abrbuf		;pointer to the buffer
abrsw0:	camn d,abrptr		;do we have more to check?
	 jrst abrsw1		;no, go out of the loop
	hrroi a,atmbuf		;what we're testing
	hrro b,d		;get our current test abbreviation
	stcmp%			;compare them
	skipn a			;exact match?
	 pmsg <Same abbreviation given twice> ;yes, that shouldn't be
	ifxn. a,sc%lss		;if test string was less than base string
	  do.
	    ildb a,b		;yes, get a char
	    jumpn a,top.	;loop until we find the null
	  enddo.
	endif.
	movei d,1(b)		;point to the next string
	jrst abrsw0		;and go on

abrsw1:	hrroi a,atmbuf		;source of this abbreviation
	hrro b,abrptr		;and pointer into the buffer for destination
	call movstr		;copy it in
	movei b,1(b)		;point to the next available slot
	movem b,abrptr		;save it away
	ret			;and go back
>;ifdef tb%abr

;ADDPRS
;parse the ADD command line
;returns +1 always
;	   SWFLAG - TBLUK% table flags, if any	
;	   KEYBUF - keyword
;	   FILBUF - file specification

addprs:	noise (KEYWORD)		;some noise
	movei b,[flddb. .cmfld]
	call .comnd		;parse a keyword
	 pmsg <Unable to parse that keyword>
	hrroi a,atmbuf
	hrroi b,keybuf
	call movstr		;copy keyword into a temporary buffer
	noise (POINTING TO)
	movei a,ijfnbk
	movem a,csb+.cmgjb	;make sure we are parsing an input file
	movei b,[flddb. .cmfil]
	call .comnd		;parse a filename
	 pmsg <No such file>
	push p,b		;save jfn
	hrroi a,filbuf
	hrroi b,atmbuf
	movx c,<fld(.jsaof,js%nam)+fld(.jsaof,js%typ)+js%paf>
	call movdir		;copy until directory delimiter
	 txo c,<fld(.jsaof,js%dev)+fld(.jsaof,js%dir)> ;none, use file's
	pop p,b			;get jfn back
	jfns%			;finish string
	move a,b		;move jfn
	rljfn%			;so we can release it
	 erjmp .+1
	setzm swflag		;no flags yet
ifdef tb%abr,<
	movei a,abrbuf		;get pointer to the abbreviation buffer
	movem a,abrptr		;and save as the pointer
>;ifdef tb%abr
addpr0:	movei b,[flddb. .cmswi,,switab,,,<[
		 flddb. .cmcfm]>]
	call .comnd		;parse a switch or a confirmation
	 pmsg <Invalid switch or not confirmed>
	ldb c,[point 9,(c),8]	;get type of field parsed
	cain c,.cmcfm		;confirmation?
	ret			;yes, return now
	hrrz b,(b)		;get address of switch handling routine
	call (b)		;do switch-like things
	jrst addpr0		;go back and parse more switches or a return 

movdir:	saveac <c>		;don't mung flags in ADDPRS
	hrli a,(<point 7,0>)	;make into real byte pointers
	hrli b,(<point 7,0>)
	push p,a		;save original destination
movdr0:	movem a,d		;save the destination ptr for later
movdr1:	ildb c,b		;get a byte
	idpb c,a		;drop it in
	jumpe c,movdr2		;if null, go finish up
	caie c,":"		;is it a colon  ;<
	 cain c,">"		;or a close bracket?
	  jrst movdr0		;yes, save pointer  ;[
	cain c,"]"		;same for other bracket style
	 jrst movdr0
	jrst movdr1		;else got a normal char, just loop back

movdr2:	move a,d		;get saved pointer back - where string ends
	pop p,b			;get original pointer
	camn a,b		;if same
	 ret			;then no directory, stop now
	retskp			;else return success

;ADDIT
;takes results of ADDPRS routine and creates a new table entry
;returns +1 always

addit:	skipn tabadr		;skip if we have a header word
	 call initab		;else initialize the table
	move a,tabfre		;get current start of free space
	movem a,oldfre		;save it for late
	skipn a,swflag		;skip if we have any flags set
	 movx a,cm%fw		;none, always set at least this one
	movem a,@tabfre		;set up the flags word
	aos tabfre		;advance the free space pointer
addit0:	hrroi a,keybuf		;pointer to the keyword
	call addstr		;copy the keyword into free space
ifndef tb%abr,<
	movei a,tabadr		;a/ address of table header word
>;ifndef tb%abr
ifdef tb%abr,<
	movx a,tb%abr!tabadr	;a/ address of table header word
>;ifdef tb%abr
	hrlz b,oldfre		;b/ new entry
	tbadd%			;add the new keyword
	 erjmp additx		;some error, go find out why 
	hrrz b,tabfre
	push p,a		;save the address
	hrrm b,(a)		;pointer to filename string
	hrroi a,filbuf
	call addstr		;copy filename string into free space
ifndef tb%abr,<
	pop p,a
	ret			;return to caller
>;ifndef tb%abr
ifdef tb%abr,<
	pop p,a			;get the item we're going to abbreviate
	stkvar <additm,thsabr>
	movem a,additm		;save the item
	movei d,abrbuf		;pointer to the abbreviation table
addit1:	camn d,abrptr		;have we gone through all we have?
	 ret			;yes, go back
	move a,tabfre		;where this string is going to go
	movem a,thsabr		;this is the current abbreviation
	movx b,cm%fw!cm%abr!cm%inv ;want this an abbreviation and invisible
	movem b,(a)		;save it as the flags
	aos tabfre		;account for this word
	hrro a,d		;point to the string we want to add
	call addstr		;add the string into free space
	movei d,1(a)		;point to the next free word
	movx a,tb%abr!tabadr	;point to the table, we have abbrevs
	hrl b,thsabr		;pointer to the string
	hrr b,additm		;and where we want to point
	tbadd%			;add it in
	aos additm		;our location increases with each abbrev
	jrst addit1		;go get all the other abbrevs
	endsv.
>;ifdef tb%abr

;ADDITX
;here when we try to add a new keyword and we fail

additx:	movei a,.fhslf		;a/ our fork handle
	geter%			;get last error
	hrrzs b			;clear bits on left
	caie b,taddx2		;entry already in table?
	 emsg <Keyword table full - reassemble with larger TABLEN>
	hrroi a,[asciz/Entry already in table - /]
	call eprint		;pretty print the error
	hrro a,oldfre		;setup pointer to bum keyword
	ldb b,[point 7,(a),6]	;get first byte
	jumpn b,addtx0		;if not null, then no flag word
	addi a,1		;bump pointer past flag word
addtx0:	psout%			;this was the bum keyword
	move a,oldfre
	hrrzm a,tabfre		;reset free space counter
	ret			;return to caller

Subttl REMOVE Command

;.REMOV
;delete an entry from the keyword table
;returns +1 always

.remov:	noise (KEYWORD)		;some noise
	movei b,[flddb. .cmkey,,tabadr]
	call .comnd		;parse a keyword, entry word returned in B
	 pmsg <Unable to parse keyword>
	call confrm		;wait for confirmation
ifndef tb%abr,<
	movei a,tabadr		;a/ address of table header word
>;ifndef tb%abr
ifdef tb%abr,<
	movx a,tb%abr!tabadr	;a/ address of table
>;ifdef tb%abr
	tbdel%			;delete the entry
	setom changd		;something has changed
	ret			;return to caller

Subttl DISPLAY Command

;.DISPL
;display the keyword table

.displ:	movei b,[flddb. .cmcfm,cm%sdh,,<Press RETURN to see all keywords>,,<[
		 flddb. .cmkey,,tabadr]>]
	call .comnd		;parse a keyword or a return
	 pmsg <Keyword or confirmation required>
	ldb d,[point 9,(c),8]	;get type of field we parsed
	caie d,.cmkey		;keyword?
	 jrst disall		;no, user wants everything
	call confrm		;yes, wait for confirmation
	move d,b		;d/ get table entry into place
	call dispnt		;print the keyword
	ret			;return to caller


;here to display all our keywords

disall:	hllz d,tabadr		;get positive control count in D
	jumpe d,r		;quit now if no keywords in table
	movns d			;negate the control count for aobjn
	hrri d,tabadr+1		;aobjn pointer in D
disal0:
ifdef tb%abr,<
	hlr a,(d)		;get the address of the flags word
	move a,(a)		;and get the actual flags
	txnn a,cm%abr		;an abbreviation?
>;ifdef tb%abr
	call dispnt		;print a keyword and its filename
	aobjn d,disal0		;loop over entire table
	ret			;return to caller


;here to print a single keyword/filename combination

dispnt:	move a,d
	call tbptr		;return pointer to keyword in A
	psout%			;print keyword
	tmsg (	=> )
	hrro a,(d)
	psout%			;filename
	move a,d
	call tbflg		;return flagword
	jumpe a,dispn0		;none
	move b,a		;put flag word where it won't be clobbered
	hrroi a,[asciz\	/Invisible\]
	txne b,cm%inv		;Invisible?
	psout%			;yes,
ifdef tb%abr,<
	hrrz c,d		;get a pointer to this location
	hrrz b,d		;isolate where we are
	subi b,tabadr+1		;convert to how many we have
	jumpe b,dispn0		;if none, go on
	movns b			;negate
	movss b			;put counter in left half
	hrri b,tabadr+1		;create the aobjn pointer
dispn1:	hrrz a,(b)		;get the data address for this
	came a,c		;match?
	 jrst dispn3		;no, go on
	tmsg < /Abbreviation:>	;set up to output the abbrev
	hlrz a,(b)		;get the address of the abbreviation string
	hrroi a,1(a)		;make a string pointer to the actual string
	psout%			;add it
dispn3:	aobjn b,dispn1		;loop through all of these
>;ifdef tb%abr
dispn0:	tmsg <
>
	ret			;return to caller


Subttl MODIFY command

.modif:	trvar <visflg,keyptr>
	noise (KEYWORD)
	movei b,[flddb. .cmkey,,tabadr]
	call .comnd		;parse an existing keyword
	 pmsg <Invalid help keyword>
	hlrz d,(b)		;save in safe place
	movem b,keyptr		;save pointer to the key entry
	setzm visflg		;say we haven't set /inv or /vis
	move b,(d)		;get the first word
	txnn b,cm%fw		;is this a flag word?
	 pmsg <Key flags can not be modified - use DELETE and then ADD>
ifdef tb%abr,<
	movei a,abrbuf		;get pointer to the abbreviation buffer
	movem a,abrptr		;and save as the pointer
>;ifdef tb%abr
modif0:	movei b,[flddb. .cmswi,,modswi,,,[
		 flddb. .cmcfm]]
	call .comnd
	 pmsg <Invalid keyword switch or not confirmed>
	load c,cm%fnc,(c)	;get type of field parsed
	cain c,.cmcfm		;confirmation?
	 jrst modif1		;yes, go do everything
	hrrz b,(b)		;get switch dispatch
	call (b)		;go do it
	jrst modif0		;continue parsing
modif1:	setom changd		;we are about to change something
	skipn visflg		;want to fiddle with visibility?
	ifskp.			;yes
	  move a,(d)		;get the flags word
	  skipl visflg		;do we want to set visible?
	   txza a,cm%inv	;yes, clear the flag
	    txo a,cm%inv	;otherwise set the invisible flag
	  movem a,(d)		;save the result
	endif.
ifndef tb%abr,<
	ret			;go back now
>;ifndef tb%abr
ifdef tb%abr,<
	movei c,abrbuf		;get the pointer to the abbreviation table
modif2:	camn c,abrptr		;any more to do?
	 ret			;no, go back
	aos c			;point past our flag
	skipl -1(c)		;do we want to delete this one?
	 jrst modif3		;no, go around
	movei a,tabadr		;pointer to the table
	hrro b,c		;pointer to the word
	push p,c		;save the whales!
	tbluk%			;look for it
	pop p,c			;restore the whales!
	movem a,b		;put the pointer into the right register
	movx a,tb%abr!tabadr	;point to the table again
	tbdel%			;delete this entry
	sos keyptr		;the keyword went down one
	hrli c,(<point 7,0>)	;make this a byte pointer
	do.
	  ildb a,c		;get a byte
	  jumpn a,top.		;get all of them
	enddo.
	movei c,1(c)		;update our pointer
	jrst modif2		;and loop for another

modif3:	movx a,cm%fw!cm%abr!cm%inv ;set up the flags
	movem a,@tabfre		;save it away
	hrl b,tabfre		;save where this string will be
	aos tabfre		;point to the next available word
	hrro a,c		;pointer to the string we want to add in
	push p,b		;save ac's
	call addstr		;put it in free memory
	pop p,b
	movei c,1(a)		;update our pointer
	movx a,tb%abr!tabadr	;pointer to the table
	hrr b,keyptr		;and pointer to the keyword entry
	tbadd%			;add it in
	aos keyptr		;this bumps up the main entry
	jrst modif2		;continue
>;ifdef tb%abr

modswi:	xwd modswl,modswl
ifdef tb%abr,<
	keywrd <Abbreviation:>,abrmod
>;ifdef tb%abr
	keywrd Invisible,invmod
ifdef tb%abr,<
	keywrd <No-Abbreviation:>,noamod
>;ifdef tb%abr
	keywrd Visible,vismod
modswl==.-modswi-1

vismod:	skipe visflg		;already set something?
	 pmsg <Can't use more than one /Invisible or /Visible>
	aos visflg		;say we want to set visibility
	ret

invmod:	skipe visflg		;already set something?
	 pmsg <Can't use more than one /Invisible or /Visible>
	sos visflg		;say we want to set invisibility
	ret

ifdef tb%abr,<
abrmod:	movei b,[flddb. .cmfld]	;want to get which abbrev to add
	call .comnd
	 pmsg <Unable to parse abbreviation>
	move a,csb+.cmabp	;get the atom buffer pointer word
	ibp a			;account for the null at the end
	hrrzs a			;isolate the right half
	subi a,atmbuf-1		;find out how much it'll use (acct. for flag)
	add a,abrptr		;will we overflow the buffer?
	cail a,abrbuf+abrbfl	;let's see...
	 pmsg <Too many abbreviations added/deleted> ;yes, complain
	movei a,tabadr
	hrroi b,atmbuf		;want to see if this item's in the table
	tbluk%			;let's see...
	txne b,tl%exm		;is it already in the table?
	 pmsg <Abbreviation already in table as abbrev. or keyword>
	hrroi a,atmbuf		;the test string
	hrroi b,1(d)		;the base string
	stcmp%			;let's see what happens...
	txnn a,sc%sub		;the abbrev a substring?
	 pmsg <Given abbreviation not a valid abbreviation of keyword> ;nope
	setzm @abrptr		;flag we want to add this one
	jrst abmod0		;go join common code

noamod:	movei b,[flddb. .cmfld]	;want to get which abbrev to add
	call .comnd
	 pmsg <Unable to parse abbreviation>
	move a,csb+.cmabp	;get the atom buffer pointer word
	ibp a			;account for the null at the end
	hrrzs a			;isolate the right half
	subi a,atmbuf-1		;find out how much it'll use (acct. for flag)
	add a,abrptr		;will we overflow the buffer?
	cail a,abrbuf+abrbfl	;let's see...
	 pmsg <Too many abbreviations added/deleted> ;yes, complain
	movei a,tabadr
	hrroi b,atmbuf		;want to see if this item's in the table
	tbluk%			;let's see...
	txnn b,tl%exm		;is it already in the table?
	 pmsg <Abbreviation to remove doesn't exist>
	hrrz a,(a)		;get to where this abbrev. points
	came a,keyptr		;is it really an abbreviation?
	 pmsg <Key to remove not an abbreviation for modified keyword>
	setom @abrptr		;flag we want to remove this one
abmod0:	movei c,abrbuf		;get the pointer
abmod1:	camn c,abrptr		;are we done?
	 jrst abmod2		;yes, go add it in
	hrroi a,atmbuf		;what we're testing
	hrroi b,1(c)		;get our current test abbreviation
	stcmp%			;compare them
	skipn a			;exact match?
	 pmsg <Same abbreviation given twice> ;yes, that shouldn't be
	ifxn. a,sc%lss		;if test string was less than base string
	  do.
	    ildb a,b		;yes, get a char
	    jumpn a,top.	;loop until we find the null
	  enddo.
	endif.
	movei c,1(b)		;point to the next string
	jrst abmod1		;and go on

abmod2:	aos abrptr		;bump up the pointer to go past the flag
	hrroi a,atmbuf		;source of this abbreviation
	hrro b,abrptr		;and pointer into the buffer for destination
	call movstr		;copy it in
	movei b,1(b)		;point to the next available slot
	movem b,abrptr		;save it away
	ret			;and go back
	endtv.
>;ifdef tb%abr

Subttl VERIFY command

;.VERIF
;make sure the keyword table is in touch with the real world
;returns +1 always

.verif:	noise (CONSISTENCY OF KEYWORD TABLE)
	call confrm		;finish command parse
	call vertab		;verify table entries
	call verfil		;make sure all files in HLP: have an entry
	ret

;VERTAB
;make sure each table entry corresponds to a real file
;if not, it is deleted and a warning message is typed
;returns +1 always

vertab:	hllz d,tabadr		;get top of keyword table
	jumpe d,r		;if empty, don't bother going through it
	movns d			;form aobjn pointer
vertbl:
ifdef tb%abr,<
	hlrz a,tabadr+1(d)	;get the address of the string
	ldb b,[point 7,(a),6]	;get the first char
	jumpn b,vertb0		;we don't have flags in this word
	move a,(a)		;get the flags word
	txne a,cm%abr		;an abbreviation?
	 jrst vertbn		;yes, don't look up this file
vertb0:
>;ifdef tb%abr
	movx a,gj%old+gj%sht	;short form GTJFN on an existing file
	hrro b,tabadr+1(d)	;with the string for that key
	gtjfn%			;try to find the file
	 erjmp vertbx		;couldn't, remove that key
	rljfn%			;don't need the JFN any more
	 erjmp .+1
vertbn:	aobjn d,vertbl		;go back for the next
	ret			;all done, go home

vertbx:	tmsg <File >		;start message
	hrro a,tabadr+1(d)	;get pointer to filename
	psout%			;type it
	tmsg < for topic >
	hlro a,tabadr+1(d)	;get start of key
	move b,(a)		;get first word - maybe flags
	txne b,cm%fw		;if so
	 aos a			;then skip over that word when typing
	psout%			;type name of key
	tmsg < not found, deleting key.
>				;finish message
ifndef tb%abr,<
	movei a,tabadr		;a/ address of table header word
>;ifndef tb%abr
ifdef tb%abr,<
	hlrz c,tabadr		;get how many items we start out with
	movx a,tb%abr!tabadr	;with our command table
>;ifdef tb%abr
	movei b,tabadr+1(d)	;at the keyword we just checked
	tbdel%			;remove key from table
	setom changd		;something has changed
ifndef tb%abr,<
	sos d			;account for deleting the current entry
>;ifndef tb%abr
ifdef tb%abr,<
	hlrz a,tabadr		;see how many we changed by
	sub c,a			;find the difference
	sub d,c			;and fudge the pointer to that (abbrevs are
				; *always* below us in the table!)
	hlre a,d		;get the left half of the aobjn
	addi a,-1(c)		;fudge by difference-1 (will get it w/aobjn)
	hrlm a,d		;and fix the other half of the aobjn
>;ifdef tb%abr
	jrst vertbn		;go to the next entry

;VERFIL
;make sure all HLP: files have an entry in the keyword table
;if not, it is added with the file's first name as the key,
;with /Invisible set.
;returns +1 always

verfil:	movx a,gj%ifg+gj%old+gj%sht ;wildcard, existing files
	hrroi b,[asciz/HLP:*.HLP.0/] ;in the help directory
	gtjfn%			;get a JFN on them
	 erjmp verflx		;couldn't, done
verfll:	call vr1fil		;verify one file (don't mung JFN)
	move d,a		;save the jfn flags
	gnjfn%			;go on to the next file
	 ret			;none, done
	hll a,d			;get the flags back
	jrst verfll		;got one, go back and process it

verflx:	tmsg <Couldn't find any files matching HLP:*.HLP
>				;gtjfn failed, assume because no files
	ret			;done with verifying files

;VR1FIL
;make sure a given file has a keyword in the help table
;must not mung the JFN given in A
;returns +1 always

vr1fil:	saveac <a>		;must not mung the jfn for later gnjfn
	hrrz b,a		;copy into B
	hrroi a,keybuf		;into keyword buffer
	movx c,<fld(.jsaof,js%nam)> ;with main part of name only
	jfns%			;translate name to string
	push p,b		;save the JFN
	movei a,tabadr		;with our main keyword table
	hrroi b,keybuf		;and the keyword we just made
	tbluk%			;see if there is a keyword by that name
	pop p,c			;get the JFN back safe and sound
	txnn b,tl%exm		;match found?
	 jrst vr1fl2		;no, have to find it the long way
	move d,a		;put address in D for subroutine
	call vr1f1k		;verify that key for the file
	 ret			;got it, all done
vr1fl2:	hllz d,tabadr		;get top of keyword table
	jumpe d,vr1flu		;if empty, don't bother going through it
	movns d			;form aobjn pointer
	hrri d,tabadr+1		;this time it points to the tbl not the offset
vr1fl3:	call vr1f1k		;check this key
	 ret			;success, stop searching
	aobjn d,vr1fl3		;maybe go back for another

vr1flu:	tmsg <File >
	move b,c		;get file in appropriate place
	setz c,			;normal file typeout
	movei a,.priou		;to the terminal
	jfns%			;translate file to string
	tmsg < has no key - adding >
	hrroi a,keybuf		;from keyword buffer
	psout%			;type to terminal
	tmsg < /Invisible
>				;key already in buff, set up FILBUF, SWFLAG...
	hrroi a,filbuf		;into file buffer
	push p,b		;saving JFN
	hrroi b,[asciz/HLP:/]	;use logical name rather than real device
	sout%			;copy string (C is still zero)
	pop p,b			;get JFN back
	movx c,<fld(.jsaof,js%nam)+fld(.jsaof,js%typ)+js%paf>
	JFNS%			;type just name and extension
	setz c,			;get a null
	idpb c,a		;terminate string with it
	movx a,cm%fw+cm%inv	;invisible flag
	movem a,swflag		;in the flag word
	call addit		;add it to the table
	setom changd		;we changed something
	ret

;VR1F1K
;check one keyword to match it to a file
;takes C/JFN of file, D/pointer to keyword
;returns +1/found the key, +2/no such luck

vr1f1k:	movx a,gj%old+gj%sht	;old file, short form
	hrro b,(d)		;point to the filename
	gtjfn%			;get a jfn on it
	 erjmp rskp		;failed?? pretend it simply doesn't match
	move b,a		;move JFN where wild% will find it
	movx a,.wljfn		;comparing two JFNs
	wild%			;do the comparison
	txne a,wl%dev+wl%dir+wl%nam+wl%ext
	 aos (p)		;got a bit set, set skip return
	move a,b		;get JFN in A
	rljfn%			;so we can flush it
	 erjmp .+1
	ret

Subttl WRITE Command

;.WRITE
;write the data files
;returns +1 always

;.WR0 can be called as a subroutine...

.write:	noise (DATA FILES)	;some noise
	call confrm		;wait for confirmation
.wr0:	move a,tabfre		;###
	subi a,tabadr		;###
	jumpl a,[emsg <TABFRE (Free space pointer) is negative!>] ;###
	movei b,[flddb. .cmini]
	tmsg <HLP:HELP.CMD...>
	call maktxt		;generate HLP:HELP.CMD
	tmsg <[OK]
HLP:HELP.BIN...>
	call makbin		;generate HLP:HELP.BIN
	tmsg <[OK]>		;say we're done
	setzm changd		;nothing changed yet
	ret			;return to caller


;MAKTXT
;generate a text version of the help keyword table
;returns +1 always

maktxt:	movx a,gj%fou+gj%sht
	hrroi b,[asciz/HLP:HELP.CMD/]
	gtjfn%
	 jmsg
	movem a,txtjfn
	move b,[7b5+of%wr]
	openf%
	 jmsg
	hllz d,tabadr
	movns d
	hrri d,tabadr+1		;aobjn pointer in D
maktx0:
ifdef tb%abr,<
	hlr a,(d)		;get the address of the flags word
	move a,(a)		;and get the actual flags
	txne a,cm%abr		;an abbreviation?
	 jrst maktx2		;yes, don't print out this one
>;ifdef tb%abr
	move a,txtjfn
	hrroi b,[asciz/Add /]
	setz c,
	sout%			;the ADD command
	move a,d
	call tbptr
	move b,a
	move a,txtjfn
	setz c,
	sout%			;keyword
	hrroi b,[asciz/ /]
	sout%
	hrro b,(d)
	sout%			;filename
	move a,d
	call tbflg		;fetch flag words for that entry
	jumpe a,maktx1		;no flags set
	push p,d		;save D
	move d,a		;put flags in a safe place
	move a,txtjfn
	setz c,
	hrroi b,[asciz\	/Invisible\]
	txne d,cm%inv		;invisible?
	sout%			;yes,
	pop p,d			;restore D
maktx1:
ifdef tb%abr,<
	push p,d		;save the aobjn pointer
	hrr c,d			;get a pointer to this location
	hrrzs d			;isolate where we are
	subi d,tabadr+1		;convert to how many we have
	jumpe d,maktx4		;if none, go on
	movns d			;negate
	movss d			;put counter in left half
	hrri d,tabadr+1		;create the aobjn pointer
maktx3:	hrr a,(d)		;get the data address for this
	came a,c		;match?
	 jrst maktx5		;no, go on
	push p,c		;save the base address
	move a,txtjfn		;want to go out to the file
	hrroi b,[asciz \ /Abbreviation:\] ;set up to output the abbrev
	setz c,			;stop on null
	sout%			;add this string
	hlrz b,(d)		;get the address of the abbreviation string
	hrroi b,1(b)		;make a string pointer to the actual string
	sout%			;add it
	pop p,c			;restore the base address
maktx5:	aobjn d,maktx3		;loop through all of these
maktx4:	pop p,d			;restore the outer aobjn pointer
>;ifdef tb%abr
	move a,txtjfn
	hrroi b,[asciz/
/]
	setz c,
	sout%
maktx2:	aobjn d,maktx0		;loop over entire table
	move a,txtjfn		;a/ jfn of output file
	closf%			;close text file
	 jmsg			;some error
	ret			;return to caller


;MAKBIN
;write the keyword table into a file
;returns +1 always

makbin:	movx a,gj%sht+gj%fou	;a/ flags for output file
	hrroi b,[asciz/HLP:HELP.BIN/] ;b/ file spec
	gtjfn%			;get a jfn on the output file
	 jmsg			;some error
	movem a,binjfn		;save the jfn
	move b,[44b5+of%wr]	;b/ full word, write access
	openf%			;open the file
	 jmsg			;some error
	movn c,tabfre		;get negative end of free space
	addi c,tabadr		;calculate total number of words in file
	push p,c		;save on stack
	call fixsub		;fixup table addresses
	move a,binjfn		;a/ jfn of output file
	move b,[point 36,tabadr] ;b/ start of output data
	pop p,c			;c/ number of words
	sout%			;write out a copy of the keyword table
	move a,binjfn		;a/ jfn of binary file
	closf%			;close the file
	 jmsg			;some error
	call fixadd		;fixup table addresses
	ret			;return to caller

Subttl Table Manipulating Routines

;LODKEY
;here to load the keyword table
;returns +1 always

lodkey:	call initab		;initialize table, just in case
	movx a,gj%sht+gj%old
	hrroi b,[asciz/HLP:HELP.BIN/]
	gtjfn%
	 erjmp [ hrroi a,[asciz/Unable to find HLP:HELP.BIN/]
		 call eprint
		 ret ]		;complain and return
	movem a,binjfn
	move b,[44b5+of%rd]
	openf%
	 jmsg
	sizef%
	 jmsg 
	movn c,b		;c/ read minus number of bytes
	move a,binjfn		;a/ jfn of input file
	move b,[point 36,tabadr] ;b/ in-core destination
	sin%			;slurp a copy of the binary file
	 jmsg
	move a,binjfn
	closf%
	 jmsg
	call fixadd		;fix up table addresses
	ret


;INITAB
;initialize the keyword table

initab:	movei a,tablen		;no entries,,maximum table length
	movem a,tabadr		;set up first word of table
	movei a,tabfre+1	;first free word in string storage area
	movem a,tabfre		;store it
	ret			;return to caller


;ADDSTR
;add a string to the free space area of the keyword table
;capitalizes lowercase letters
;takes a/ string pointer
;returns +1 always

addstr:	hrli a,(<point 7,0>)	;make byte pointer out of source pointer
	hrrz b,tabfre		;fetch address of first free word
	hrli b,(<point 7,0>)	;make a destination byte pointer
addst0:	ildb c,a
	cail c,"a"
	caile c,"z"
	 skipa
	  subi c,40
	idpb c,b
	jumpn c,addst0
	addi b,2
	hrrzm b,tabfre
	ret



;TBPTR
;return a string pointer to the current keyword
;takes	a/ address of table entry
;returns +1 always with string pointer in A

tbptr:	push p,b		;save b
	hlro a,(a)		;a/ pointer to keyword
	ldb b,[point 7,(a),6]	;get first byte of "keyword"
	jumpn b,tbptr0		;if not null, then our pointer is good
	move b,(a)		;fetch first word of "keyword"
	txne b,cm%fw		;is it really a flag word?
	addi a,1		;yes, fudge the pointer
tbptr0:	pop p,b			;restore B
	ret			;return to caller


;TBFLG
;return the flag word, if any, for a table entry
;takes a/ address of table entry
;returns +1 always, with flag word in A

tbflg:	push p,b		;save B
	hlrz a,(a)		;get address of keyword
	ldb b,[point 7,(a),6]	;look at the first byte
	jumpn b,tbflg0		;if not null, then we have no flags
	move a,(a)		;fetch first word of keyword entry
	txnn a,cm%fw		;is it a flag word?
tbflg0:	setz a,			;no, return a zero word
	pop p,b			;restore B
	ret			;return to caller


;FIXADD
;fixup table addresses 
;adds HELPMAINT'S base address TABADR to a zero based table
;returns +1 always

fixadd:	move a,[xwd tabadr,tabadr] ;a/ offsets
	hlrz b,tabadr		;fetch number of entries
	movns b			;negate
	movss b			;swap sides
	hrri b,tabadr+1		;b/ finish building aobjn pointer
	addm a,(b)		;fixup
	aobjn b,.-1		;loop over entire table
	hrrzs a			;need only right half offset
	addm a,tabfre		;fixup free space pointer
	ret			;return to caller


;FIXSUB
;fixup table addresses 
;turns internal table into zero based TBLUK% table
;returns +1 always

fixsub:	hlrz b,tabadr		;fetch number of entries
	movns b			;negate
	movss b			;swap sides
	hrri b,tabadr+1		;b/ finish building aobjn pointer
fixsu0:	move a,(b)		;fetch an entry
	subi a,tabadr		;fixup right side
	movss a			;swap sides
	subi a,tabadr		;fixup left half
	movsm a,(b)		;swap and store back in table
	aobjn b,fixsu0		;loop over entire table
	hrrz a,tabfre
	subi a,tabadr
	movem a,tabfre		;fixup free space pointer
	ret			;return to caller

Subttl Miscellaneous Utility Subroutines

;EPRINT
;here to pretty print an error message
;takes	a/ pointer to error string
;returns +1 always

eprint:	push p,a
	movei a,.priou		;a/ reading from the tty
	rfpos%			;get cursor position
 	hrroi a,[byte(7) 15,12,0] ;a/ a CRLF
	trne b,-1		;skip if against left margin
	psout%			;print a CRLF otherwise
	pop p,a			;restore the string pointer
	esout%			;print the message
	ret			;return to caller


;PERR
;like EPRINT, but prints most recent error message
;takes	a/ pointer to error string
;never returns

perr:	call eprint		;print the string
	tmsg < - >		;print the separator
	movei a,.priou		;a/ to the terminal
	hrloi b,.fhslf		;b/ most recent error for this process
	setz c,			;c/ no string length limit
	erstr%			;print the error string
	 jfcl			;ignore errors
	  jfcl			;...
	haltf%			;shut us down
	jrst .-1		;and stay that way


;CONFRM
;wait for confirmation of a command
;returns +1 always

confrm:	push p,a		;save some AC's
	push p,b
	push p,c
	movei b,[flddb. .cmcfm] ;b/ function block
	call .comnd		;wait for confirmation
	 pmsg <Not confirmed>	;no...
	pop p,c			;restore the AC's
	pop p,b
	pop p,a
	ret			;return to caller


;MOVSTR
;move an asciz string from source to destination - includes the NUL
;takes	a/ source string pointer
;	b/ destination string pointer
;returns +1 always

movstr:	hrli a,(<point 7,0>)
	hrli b,(<point 7,0>)
	ildb c,a
	idpb c,b
	jumpn c,.-2
	ret

	end <evecl,,evec>
    