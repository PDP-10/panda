;<HELLIWELL>ADDDEF.MAC.16, 18-Apr-79 16:09:24, Edit by HELLIWELL
TITLE	ADDDEF - COMND JSYS PROGRAM TEMPLATE

SEARCH MONSYM,MACSYM
.REQUIRE SYS:MACREL
EXT <JSMSG0>

VGROUP==1
VMAJOR==3
VMINOR==0
VEDIT==4

DEFINE DATE<ASCIZ \18-Apr-79\>

A=1
B=2
C=3
D=4

;16 IS USED BY MACSYM

P=17

MAXJFN==^D20		;MAX 20 NESTED TAKES

MAXCHR==^D200

MAXLEN==<MAXCHR+5>/5

ABCHR==^D50

ABLEN==<ABCHR+5>/5

LOGLEN==MAXLEN*5

PDLLEN==20

DEFINE JCERR(TEXT)<
	 ERCAL [JSMSG<TEXT>
		RET]>

DEFINE JSMSG(TEXT)<
	TMSG <
?>
IFNB<TEXT><TMSG <TEXT: >>
	CALL JSMSG0
>

DEFINE FMSG(TEXT)<
	HRROI B,[ASCIZ \TEXT\]
	SETZ C,
	SOUT
>

DEFINE FCHR(CHR)<
	MOVEI B,CHR
	BOUT
>

DEFINE FVER<
	FMSG (\VMAJOR)
IFN VMINOR,<
IFG VMINOR-^D26,<
	VMIN1==<VMINOR-1>/^D26
	FCHR <"A"+VMIN1-1>
>
	VMIN1==VMINOR-<<VMINOR-1>/^D26*^D26>
	FCHR <"A"+VMIN1-1>
>
IFN VEDIT,<
	FCHR<"(">
	FMSG(\VEDIT)
	FCHR<")">
>
IFN VGROUP,<
	FCHR<"-">
	FMSG(\VGROUP)
>
>
SUBTTL	MACROS

;LOAD A BLOCK WITH DATA AND ALLOCATE ENOUGH SPACE
;FOR LARGEST WORD

DEFINE LDBLK(LIST)<
..LEN==0
	IRP LIST,<LDWRD(LIST)>
	RELOC .+..LEN
>

;LOAD 1 WORD CHECK MAX LENGTH

DEFINE LDWRD(A)<.LDWRD(A)>

;USED TO STRIP OFF <>

DEFINE .LDWRD(A,B)<
	RELOC .+A
	IFB<B>,<0;>B
	RELOC .-A-1
IFGE A-..LEN,<..LEN==A+1>
>

;KEYWORD TABLE MACROS

DEFINE TABLE<
	...BEG==.
	BLOCK 1
>

DEFINE TEND<
...LEN==.-...BEG
.ORG ...BEG
	...LEN-1,,...LEN
.ORG .+...LEN
>

DEFINE T(TEXT,VALUE)<	[ASCIZ \TEXT\],,VALUE>

;LOAD A FUNCTION DESCRIPTOR BLOCK
;USE FLDDB. MACRO FROM MONSYM. ARGS AS FOLLOWS:
;FLDDB.(TYP,FLGS,DATA,HLPM,DEFM,LST)
;TYP	COMND FUNCTION CODE (I.E. .CMKEY)
;FLGS	FLAGS (I.E. CM%SDH, SUPPRESS DEFAULT HELP)
;DATA	ARG TO SPECIFIC FUNCTION (I.E. RADIX FOR .CMNUM)
;HLPM	USER SUPPLIED HELP STRING (AUTOMATICALLY SETS CM%HPP)
;DEFM	DEFAULT STRING (AUTOMATICALLY SETS CM%DPP)
;LST	POINTER TO NEXT FUNCTION DESCRIPTOR BLOCK

;DEFINE SINGLE DATA WORD (OR WORDS)

DEFINE DATA(ADDR,SIZE)<
ADDR:	IFB<SIZE>,<BLOCK 1;>BLOCK SIZE
>

DEFINE CONFIRM(ERROR)<
	CALL DOCFM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>


DEFINE NIY<
	TMSG <
?Not implemented yet.
>
	JRST COMLOP
>

DEFINE COMINI(TEXT)<
IFNB<TEXT><HRROI A,[ASCIZ \TEXT\]>
IFB<TEXT><HRROI A,CMBUF>
	CALL DOINI
>

DEFINE FIELD(FDB,ERROR)<
	MOVEI B,FDB
	CALL DOCOM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>

DEFINE RFIELD(FDB)<
	MOVEI B,FDB
	MOVEI A,CMSTAT
	COMND
	 ERJMP ERSCAN
	TXNE A,CM%NOP
	JRST ERSCAN
>

DEFINE GETSTR(FIELD)<
	HRROI A,TMPSTR
	MOVE B,IJFN
	MOVE C,[FLD(1,JS%'FIELD)]
	JFNS
	 ERMSG <JFNS FAILURE>
>
SUBTTL	DATA AREA

EV:	JRST STRT
	JRST STRT
JOBVER:	BYTE (3)VGROUP(9)VMAJOR(6)VMINOR(18)VEDIT
EVL==.-EV

PDL:	BLOCK PDLLEN

CMSTAT:	LDBLK(<<.CMFLG,REPARS>,<.CMIOJ,<.PRIIN,,.PRIOU>>,<.CMBFP,<-1,,CMBUF>>,<.CMPTR,<-1,,CMBUF>>,<.CMCNT,MAXCHR>,<.CMINC,0>,<.CMABP,<POINT 7,ABBUF>>,<.CMABC,ABCHR>,<.CMGJB,CMGJFN>>)

CMGJFN:	BLOCK 16

CMBUF:	BLOCK MAXLEN

ABBUF:	BLOCK ABLEN

INIBLK:	FLDDB.(.CMINI)

ADDDEF:	FLDDB.(.CMKEY,,RESKEY)

RESKEY:	TABLE
	T ADDDEF,0
	TEND

COMAND:	FLDDB.(.CMKEY,,COMKEY)

COMKEY:	TABLE
	T APPEND,DOAPP
	T EXIT,LEAVE
	T HELP,PNTHLP
	T PREFIX,DOPRE
	T TAKE,DOTAKE
	TEND

TONOI:	FLDDB.(.CMNOI,,<-1,,[ASCIZ /TO/]>)

WITHNO:	FLDDB.(.CMNOI,,<-1,,[ASCIZ /WITH/]>)

LOGDEV:	FLDDB.(.CMFLD,CM%SDH,,<Logical device name>)

COLON:	FLDDB.(.CMTOK,CM%SDH,<-1,,[ASCIZ /:/]>,<Colon to terminate logical device name>,<: >)

COMTXT:	FLDDB.(.CMTXT,CM%SDH,,<Data to add to logical name definition>)

TAKFIL:	FLDDB.(.CMFIL,,,,,COMCFM)
TAKBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /CMD/]>>,<.GJNAM,[ASCIZ /ADDDEF/]>>)
TAKLEN==.-TAKBLK

COMCFM:	FLDDB.(.CMCFM)

;SAMPLES OF OTHER BLOCKS
;NOISE:	FLDDB.(.CMNOI,,<-1,,[ASCIZ /NOISE/]>)
;IFILE:	FLDDB.(.CMIFI)
;OFILE:	FLDDB.(.CMOFI)
;ARBFIL:FLDDB.(.CMFIL)
;FILBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /EXT/]>>,<.GJNAM,[ASCIZ /NAME/]>>)
;FILLEN==.-FILBLK

DATA	REPPDL
DATA	REPPC
DATA	SYSCOM
DATA	CMJFNS
DATA	CMJFNP
DATA	JFNSTK,MAXJFN
DATA	PREFLG
DATA	LOGPTR
DATA	LOGNAM,ABLEN

;NEXT TWO MUST BE TOGETHER
DATA	LOGDEF,LOGLEN
;LOGEXT MUST FOLLOW LOGDEF
DATA	LOGEXT,ABLEN
SUBTTL	STARTUP
STRT:	RESET
	MOVE P,[IOWD PDLLEN,PDL]
	MOVE A,[-MAXJFN,,JFNSTK-1]
	MOVEM A,CMJFNP
	SETOM SYSCOM
	SETZM CMJFNS
	SETZ A,
	RSCAN
	 ERJMP ERSCAN
	JUMPE A,ERSCAN
	COMINI()
	RFIELD(ADDDEF)		;MUST START WITH PROGRAM NAME, OR NO ERRORS
	MOVEI B,COMCFM
	MOVEI A,CMSTAT
	COMND
	 ERJMP REPAR1
	TXNE A,CM%NOP
	JRST REPAR1
;PROGRAM NAME<CR>, MAKE IT LOOK LIKE "R PROGRAM".
ERSCAN:	SETZM SYSCOM
	TMSG <ADDDEF version >
	MOVEI A,.PRIOU
	LDB B,[POINT 9,JOBVER,11]	;MAJOR
	MOVEI C,10
	NOUT
	 JCERR
	LDB B,[POINT 6,JOBVER,17]	;MINOR
	JUMPE B,NOMINR
	SUBI B,1
	IDIVI B,^D26
	JUMPE B,NOMINF
	MOVEI A,"A"-1(B)
	PBOUT
NOMINF:	MOVEI A,"A"(C)
	PBOUT
NOMINR:	HRRZ B,JOBVER			;EDIT
	JUMPE B,NOEDIT
	TMSG <(>
	MOVEI A,.PRIOU
	MOVEI C,10
	NOUT
	 JCERR
	TMSG <)>
NOEDIT:	LDB B,[POINT 3,JOBVER,2]
	JUMPE B,NOGRP
	TMSG <->
	MOVEI A,.PRIOU
	MOVEI C,10
	NOUT
	 JCERR
NOGRP:	TMSG <, >
	HRROI A,[DATE]
	PSOUT
	TMSG <.
Type "HELP" for help.
>
COMLOP:	CALL CLEAN
	SKIPE CMJFNS			;DON'T EXIT DURING TAKE
	JRST COMLP1
	SKIPE SYSCOM
	HALTF
	SETZM SYSCOM
COMLP1:	HRROI A,[ASCIZ /ADDDEF>/]
	CALL DOINI
	CALL CLEAN
REPAR1:
;SETUP COMMAND DEFAULTS
	FIELD(COMAND,CMEOFC)
	HRRZ B,(B)
	JRST (B)

REPARS:	MOVE P,REPPDL
	MOVE A,REPPC
	MOVEM A,(P)
	RET

DOINI:	MOVEM A,CMSTAT+.CMRTY
	MOVE A,(P)
	MOVEM A,REPPC
	MOVEM P,REPPDL
DOINI1:	SKIPN A,CMJFNS
	MOVE A,[.PRIIN,,.PRIOU]
	MOVEM A,CMSTAT+.CMIOJ
	MOVEI A,CMSTAT
	MOVEI B,INIBLK
	COMND
	 ERJMP FATAL
	TXNN A,CM%NOP
	RET
FATAL:	JSHLT

CMEOFC:	SKIPN CMJFNS
	JRST COMERR
	MOVEI A,.FHSLF
	GETER
	 ERJMP COMERR
	HRRZ B,B
	CAIE B,IOX4
	JRST COMERR
	TMSG <%End of >
	MOVEI A,.PRIOU
	HLRZ B,CMJFNS
	SETZ C,
	JFNS
	 JCERR<>
	TMSG <
>
	CALL TAKFIN
	JRST COMLOP

DOCFM:	MOVEI B,COMCFM
DOCOM:	MOVEI A,CMSTAT
	COMND
	 ERJMP R
	TXNE A,CM%NOP
	RET
	RETSKP

COMERR:	CALL ERRET
	JRST COMLOP

ERRET:	CALL ERRDO
	JSMSG <Command error>
	RET

ERRDO:	SKIPN CMJFNS
	RET
	TMSG <%Error reading >
	MOVEI A,.PRIOU
	HLRZ B,CMJFNS
	SETZ C,
	JFNS
	 JCERR<>
	TMSG <, command file input terminated.
>
	CALL TAKFIN
	JRST ERRDO

TAKFIN:	HLRZ A,CMJFNS
	MOVE B,CMJFNP
	POP B,CMJFNS
	MOVEM B,CMJFNP
	CLOSF
	 JCERR <Error closing command file>
	RET

CLEAN:	HRROI A,[0]
	RSCAN
	 ERJMP .+1
	MOVX A,CZ%NCL!FLD(.FHSLF,CZ%PRH)
	CLZFF
	 JCERR <Failed to release unopened JFNs>
	RET
SUBTTL	EXTEND DEFINITION
DOPRE:	SETOM PREFLG
	JRST DODEF

DOAPP:	FIELD(TONOI)
	SETZM PREFLG
DODEF:	FIELD(LOGDEV)
	HRROI A,LOGNAM
	HRROI B,ABBUF
	SETZ C,
	SOUT			;SAVE NAME
	FIELD(COLON)
	SKIPN PREFLG
	JRST DODEFA
	FIELD(WITHNO)
DODEFA:	FIELD(COMTXT)
	HRROI A,LOGEXT
	HRROI B,ABBUF
	SETZ C,
	SOUT
	CONFIRM
	HRROI A,LOGDEF
	HRROI B,LOGEXT
	SETZ C,
	SKIPE PREFLG
	SOUT
	MOVEM A,LOGPTR
	MOVEI A,.LNSJB
	PUSHJ P,GETLN
	 JRST GOTLN
	MOVEI A,.LNSSY
	HRROI B,LOGNAM
	MOVEI C,.NULIO		;FLUSH RESULT
	LNMST
	 ERJMP CHKDSK
	JRST ISSYLN

CHKDSK:	HRROI A,[ASCIZ /DSK/]
	HRROI B,LOGNAM
	STCMP
	JUMPN A,GOTLN
ISSYLN:	MOVE A,LOGPTR
	MOVEI B,","
	SKIPE PREFLG
	BOUT
	HRROI B,LOGNAM
	SETZ C,
	SOUT
	MOVEI B,":"
	BOUT
	MOVEI B,","
	SKIPN PREFLG
	BOUT
	MOVEM A,LOGPTR
GOTLN:	MOVE A,LOGPTR
	HRROI B,LOGEXT
	SETZ C,
	SKIPN PREFLG
	SOUT
	SETZ B,
	BOUT
	MOVEI A,.CLNJB
	HRROI B,LOGNAM
	HRROI C,LOGDEF
	CRLNM
	 ERJMP [JSMSG <CRLNM failed>
		JRST COMLOP]
	HRROI A,LOGNAM
	PSOUT
	HRROI A,[ASCIZ / => /]
	PSOUT
	HRROI A,LOGDEF
	PSOUT
	TMSG <
>
	JRST COMLOP


GETLN:	PUSH P,A
	MOVE A,LOGPTR
	MOVEI B,","
	SKIPE PREFLG
	BOUT
	MOVE C,A
	POP P,A
	HRROI B,LOGNAM
	LNMST
	 ERJMP RSKP
	MOVE A,C
	SKIPE PREFLG
	JRST GETLN2
	MOVEI B,","
	BOUT
GETLN2:	MOVEM A,LOGPTR
	HRRZ A,A
	CAIGE A,LOGDEF+LOGLEN-1
	RET
	TMSG <?Current logical name definition too long.
>
	POP P,(P)
	JRST COMLOP
SUBTTL	COMMAND HANDLERS
LEAVE:	CONFIRM
	HALTF
	JRST COMLOP

PNTHLP:	CONFIRM
	HRROI A,HLPMES
	PSOUT
	JRST COMLOP

HLPMES:	ASCIZ \
This program will add new data to the beginning or end of a logical
name. If the logical name does not exist, it is created. There are
five commands:

APPEND (TO) <logical device name>: <data to add to logical name>
	Add data at end of logical name.

EXIT
	Exit to EXEC.

HELP
	Type this text.

PREFIX <logical device name>: (WITH) <data to add to logical name>
	Add data to beginning of logical name.

TAKE <filespec>
	Take commands from file. "TAKE" commands may be nested. When EOF
	is reached, the message "%End of filespec." is printed. If you
	Say "TAKE" with no filespec, input is terminated with no message.

In addition, the program may be given a command on the EXEC command line
as in:

ADDDEF command line

If "ADDDEF" is successfully parsed, the command will exit upon completion
of the command. If a TAKE is done, the program will not exit until all
take files are completed.
\

DOTAKE:	SETZM CMGJFN
	MOVE A,[CMGJFN,,CMGJFN+1]
	BLT A,CMGJFN+15
	MOVE A,[TAKBLK,,CMGJFN]
	BLT A,CMGJFN+TAKLEN-1
	FIELD(TAKFIL)
	HRRZ C,C
	CAIN C,COMCFM
	JRST DOTAK1
	MOVE D,B
	CONFIRM
	MOVE A,CMJFNP
	AOBJP A,[CALL ERRDO
		TMSG <?Too many nested "TAKE" commands.
>
		JRST COMLOP]
	MOVE A,D
	MOVX B,<FLD(7,OF%BSZ)!OF%RD>
	OPENF
	 ERJMP [JSMSG <Error opening command input file.
>
		JRST COMLOP]
	MOVE A,CMJFNP
	PUSH A,CMJFNS
	MOVEM A,CMJFNP
	HRLI D,.NULIO
	MOVSM D,CMJFNS
	JRST COMLOP

DOTAK1:	SKIPE CMJFNS
	CALL TAKFIN
	JRST COMLOP

END XWD EVL,EV
  