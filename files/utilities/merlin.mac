;<UTILITIES>MERLIN.MAC.38, 30-Mar-2005 21:26:45, Edit by MRC
; Increase stack length
; <GERGELY.EXP>MERLIN.MAC.37,  5-Sep-85 11:39:20, Edit by GERGELY
; Verify FRENAME and FCOPY do not have wildcard source directories, and that
; they do not copy to self.
; <GERGELY.SYSTEM>MERLIN.MAC.36, 22-Jul-85 09:33:56, Edit by GERGELY
; Allow DELF to work with an archived file at .RNAMF+9 and not cause an error
;<SU-SOURCES>MERLIN.MAC.35, 18-Apr-85 11:27:10, Edit by SWEER
; Increase space for NEWNAM, OLDDIR, NEWDIR, and FRNNAM to allow
; for extra long names (multiple subdirectories)
; <GERGELY.EXP>MERLIN.MAC.34,  9-Apr-85 01:09:41, Edit by GERGELY
; frename requires special handling so as to delete archive files, and not
; destroy the access dates on files.
; Allow deleted, invisibles and archived in the fcopy and frename
;<SU-UTILITIES>MERLIN.MAC.32,  2-Apr-85 22:27:08, Edit by LOUGHEED
; From GERGELY@DREA:
;  - fix CPARCF to isolate correct reason for archiving
;  - increase stack size to cope with deep directory trees
;  - make sure deleted but permanent files are kept
;<SU-UTILITIES>MERLIN.MAC.31, 24-Oct-84 16:25:26, Edit by LOUGHEED
; Revoke buggy "fix" to SETCMD
;<SU-UTILITIES>MERLIN.MAC.30,  6-Oct-84 18:00:56, Edit by LOUGHEED
; Fix SETCMD to not unbalance stack pointer
; Reset stack pointer at CMDINI, just in case
;<SU-UTILITIES>MERLIN.MAC.29, 27-Aug-84 10:31:04, Edit by SATZ
; Might as well have an FRENAME command too.
;<SU-UTILITIES>MERLIN.MAC.28, 25-Aug-84 02:09:51, Edit by SATZ
; Add in the FCOPY command. This copies files while maintaining
; all of the FDB information.
;<SU-UTILITIES>MERLIN.MAC.27, 17-Apr-84 19:21:22, Edit by KRONJ
; Was losing with a TVEDIT file that had page 777 but nothing further.
; Try limiting multiple-page map to within section boundaries.
;<SU-UTILITIES>MERLIN.MAC.26, 30-Jan-84 14:53:38, Edit by KRONJ
; Len's suggestion for a more efficient way of copying files:
;  do it in multi-page blocks, preload the input PMAP, and use BLTs
;  followed by ERJMPs to explicitly copy pages ourself rather than
;  touching the page with PM%CPY and having the monitor do the BLT.
;<SU-UTILITIES>MERLIN.MAC.25, 29-Jan-84 16:26:39, Edit by KRONJ
; UPDATE wasn't calling UNSAVE, merge it into CP1FIL
;<SU-UTILITIES>MERLIN.MAC.24, 19-Nov-83 11:42:42, Edit by KRONJ
; Don't UPDATE directory files
; /KeepNumber switch to keep old dir numbers in COPY and RENAME
; Make .CRDIR smarter about various errors
;<SU-UTILITIES>MERLIN.MAC.23, 23-Sep-83 13:46:53, Edit by KRONJ
; Preserve author strings more accurately
; Set OF%PDT so read dates of files don't get updated by dir rename
; Make OLDJFN and NEWJFN not allocated from the stack
;<SCORE>MERLIN.MAC.3, 11-Aug-83 01:03:22, Edit by CHRIS
; Add /NoGroups switch to omit user/directory/subdirectory groups
;<SU-UTILITIES>MERLIN.MAC.21,  9-Aug-83 21:54:46, Edit by KRONJ
;<SU-UTILITIES>MERLIN.MAC.20,  9-Aug-83 15:44:43, Edit by KRONJ
;<SU-UTILITIES>MERLIN.MAC.19,  9-Aug-83 11:41:02, Edit by KRONJ
; Fix typo in previous edit
; Try clearing out expiration settings if CRDIR% fails the first time
; (was getting errors that dates can not be greater than system max)
;<SU-UTILITIES>MERLIN.MAC.18,  9-Aug-83 10:03:57, Edit by KRONJ
; Clean up a little bit
; Unprivileged users can not preserve quotas
; Copy parts of .FBBYV separately so non-priv copy doesn't lose byte size
;<GERGELY.SYSTEM>MERLIN.MAC.27,  8-Aug-83 15:53:37, Edit by GERGELY
; Fix RENAME <x> <y> /verbose
;<GERGELY.SYSTEM>MERLIN.MAC.25,  8-Aug-83 15:24:43, Edit by GERGELY
; Delete and expunge all files if preserving quotas when deleting a
; non-empty directory
;<GERGELY.SYSTEM>MERLIN.MAC.3,  5-Aug-83 13:31:53, Edit by GERGELY
; Preserve default login account and online offline expirations with COPY
; Copy archived files completely and properly
;<SU-UTILITIES>MERLIN.MAC.16, 20-Apr-83 19:51:06, Edit by KRONJ
; Confirmation is always from the terminal
;<SU-UTILITIES>MERLIN.MAC.15, 28-Mar-83 20:16:18, Edit by KRONJ
; Add UPDATE command
; Add /NoFiles, rename /FilesOnly to be /NoSubdirs
; Start edit history

TITLE Merlin - copy/rename/delete directories
SUBTTL David Eppstein / Stanford University / 13-Mar-83

	SEARCH MONSYM,MACSYM
	.REQUIRE SYS:MACREL
	.TEXT \MERLIN/SAVE\	; [PJG] Allow for automatic save

	VMAJOR==2		;Major version number
	VMINOR==0		;Minor version number
	VEDIT==^D38		;Edit number
	VWHO==7			;Who edited (7 = Panda)

F=:0				;Flags -- left half global, right half switches
	F%DLOK==1,,0		;Type [OK] in delete
	F%DSUB==2,,0		;Delete subdirectories
	F%RENM==4,,0		;RENAME command (not COPY)
	F%KOLD==10,,0		;Must kill old directory
	F%DELF==20,,0		;Current file is being deleted
	F%PRIV==40,,0		;User is privileged
	F%GNJ==100,,0		; [PJG] GNJFN is still valid in .FRENA

	F%NSUB==1		;No subdirectories
	F%VERB==2		;Verbose file listing
	F%NPRS==4		;Don't preserve superior quotas
	F%NFIL==10		;Don't copy contents
	F%NGRP==20		;Don't copy group numbers
	F%KNUM==40		;Try to keep directory numbers
	F%UPDA==100		;This is update command

A=:1				;Scratch and JSYS use
B=:2
C=:3
D=:4

E=:5				;More scratch for CPARCF routines
J=:6

FP=:15				;TRVAR frame pointer
CX=:16				;MACSYM scratch
P=:17				;Stack pointer

SUBTTL Macros

DEFINE ERNOP <ERJMP .+1>	;Ignore a JSYS error

DEFINE FATAL (MSG<Fatal error>) <
	CALL [	HRROI A,[ASCIZ/MSG - /]
		JRST .FATAL ]
>
DEFINE PMSG (MSG) <		;; Parse error
	JRST [	IFB <MSG>,<HRROI A,[ASCIZ//]>
		IFNB <MSG>,<HRROI A,[ASCIZ/MSG - /]>
		JRST .PMSG ]
>
DEFINE XPMSG (MSG) <		;; Parse error with no JSYS error
	JRST [	HRROI A,[ASCIZ/MSG/]
		JRST .XPMSG ]
>
DEFINE XFATAL (MSG) <		;; Fatal error with no JSYS error
	JRST [	HRROI A,[ASCIZ/MSG/]
		JRST .XFATL ]
>

DEFINE NOISE (WORDS) <		;; Parse guidance message
	MOVEI B,[FLDDB. .CMNOI,,<-1,,[ASCIZ\WORDS\]>]
	CALL .COMND
	 PMSG
>

DEFINE UPCASE (AC) <		;; Make sure a character is uppercase
	TRNE AC,100		;; Could it be lowercase?
	 TRZ AC,40		;; Yes, convert
>
DEFINE MKPTR (AC) <		;; Make sure it is a real byte pointer
	TLC AC,-1		;; Flip the left half bits
	TLCN AC,-1		;; Flip again and test if they started as -1
	 HRLI AC,(POINT 7)	;; They did, make it POINT 7 instead
>

DEFINE TYPE (LOC) <		;; Type out contents of the location
	HRROI A,LOC		;; Make pseudo-byte pointer
	PSOUT%			;; Type it
>

DEFINE CPYTRVAR <		;; Standard recursive variable list
	TRVAR <DEST,SOURCE,<NEWNAM,200>,NEWPTR,SAVJFN,SAVCTL,SAVBYV,CMDFLG>
	SETZM SAVJFN		;; Haven't run across any files yet
>


SUBTTL Impure uninitialized storage

	PDLEN==15000		;Large stack for deep directory trees
PDL:	BLOCK PDLEN		;Control stack

	BUFLEN==200
ATMBUF:	BLOCK BUFLEN		;Atom buffer
CMDBUF:	BLOCK BUFLEN		;Command buffer

ARCBLK:	BLOCK <.ARNAR+1>	;Archiving information to here
ODIRNM:	BLOCK 1			;Source directory number
NDIRNM:	BLOCK 1			;New dir number - prevent infinite recursion
OLDDIR:	BLOCK 100		;Source directory name
NEWDIR:	BLOCK 100		;New directory name
SAVPDL:	BLOCK 1			;Saved stack pointer for command processing
TEMP:	BLOCK 100		;Some more temporary storage
MAPLOC:	BLOCK 1			;Return address from mapdir
OLDJFN:	BLOCK 1			;Source
NEWJFN:	BLOCK 1			;Destination
CURJFN:	BLOCK 1			;What we're working on now
CURPAG:	BLOCK 1			;The page of it we're doing
CURNPG:	BLOCK 1			;How many we're doing in this block
FRNNAM:	BLOCK 100		; [PJG] Filename being renamed

DEFINE GROUPS <			;; Call macro for all types of groups
	DOGROUP(CDUGP)		;; User groups
	DOGROUP(CDDGP)		;; Directory groups
	DOGROUP(CDCUG)		;; Subdirectory user groups allowed
>
DEFINE DOGROUP (NAME) <$'NAME: BLOCK MAXGRP>

	CRDLEN==.CDDFE+1	;Size of CRDIR block
CRDBLK:	BLOCK CRDLEN		;CRDIR block
$CDPSW:	BLOCK 10		;Password storage area
$CDDAC:	BLOCK 10		;Default account for login
	MAXGRP==400		;Allow for huge numbers of groups
	GROUPS			;Allocate storage blocks for groups

	CPYPAG==200		;Where to map files to copy them
CPYADR=CPYPAG*1000
	OUTPAG==300		;Where to map them into
OUTADR=OUTPAG*1000
	NPAGES==^D10		;How many to copy at a time

CH1PC:	BLOCK 1			;Interrupt PC saved location
CH2PC:	BLOCK 1
CH3PC:	BLOCK 1

SUBTTL Impure initialized storage

CSB:	0			;.CMFLG -- flags ,, reparse address
	.PRIIN,,.PRIOU		;.CMIOJ -- input ,, output JFN
	0			;.CMRTY -- prompt pointer (set in SETCMD)
	-1,,CMDBUF		;.CMBFP -- ptr to start of command buffer
	-1,,CMDBUF		;.CMPTR -- ptr to next input
	<5*BUFLEN>-1		;.CMCNT -- size of buffer
	0			;.CMINC -- chars left in buffer
	-1,,ATMBUF		;.CMABP -- atom buffer pointer
	<5*BUFLEN>-1		;.CMABC -- size of atom buffer
	CMDGTJ			;.CMGJB -- long-form GTJFN% block

LEVTAB:	CH1PC			;Interrupt level table
	CH2PC
	CH3PC

CHNTAB:	1,,STATUS		;Channel 0: ^A status interrupt
	REPEAT ^D35,<0>		;No other interrupts

CMDGTJ:	GJ%OLD!GJ%IFG!GJ%FLG!.GJALL ;This block is for wild command parsing
	REPEAT 3,<0>		;COMND% will fill in JFNs
	REPEAT 2,<POINT 7,[ASCIZ/*/]> ;Wildcard name and extension
	REPEAT 8,<0>		;Fill out rest of block

WLJBLK:	GJ%OLD!GJ%IFG!GJ%FLG!GJ%DEL!GJ%XTN!.GJALL
	.NULIO,,.NULIO		;No source jfns
	REPEAT 2,<0>		;No default device or directory
	REPEAT 2,<POINT 7,[ASCIZ/*/]> ;Wildcard name and extension
	REPEAT 3,<0>		;.GJPRO, .GJACT, .GJJFN unused
	G1%IIN			;.GJF2  -- more flags (ignore invisible)
	REPEAT 5,<0>		;.GJCPP, .GJCPC, .GJRTY, .GJBFP, .GJATR

GTJBLK:	GJ%OLD!GJ%DEL!GJ%XTN	;This block is for normal files
	.NULIO,,.NULIO		;No source jfns
	REPEAT 7,<0>		;No defaults
	G1%IIN			;Allow invisible files
	REPEAT 5,<0>

SUBTTL Startup and main loop

EVEC:	JRST START		;Entry
	JRST START		;Re-entry is same as startup
	BYTE (3) VWHO (9) VMAJOR (6) VMINOR (18) VEDIT

START:	RESET%			;Clean up the world
	MOVE P,[IOWD PDLEN,PDL]	;Make a stack pointer

	SETZM CURJFN		;No current jfn
	SETOM CURPAG		;No current page

	MOVEI A,.FHSLF		;Get our own capabilities
	RPCAP%
	TXNN B,SC%WHL!SC%OPR	;Test if an enabled wheel or operator
	 TDZA F,F		;No, no privileges
	  MOVX F,F%PRIV		;Yes, remember we have privs

	MOVX A,.FHSLF		;On our own process
	MOVE B,[LEVTAB,,CHNTAB]	;With normal level and channel tables
	SIR%			;Set up interrupt system
	EIR%			;And enable it
	MOVX B,1B0		;Get mask of channels to activate
	AIC%			;And activate them
	MOVX A,<.TICCA,,0>	;Control-A, channel 0
	ATI%			;Set up interrupt for that key

	MOVX A,.RSINI		;Function to read from RSCAN buffer
	RSCAN%			;Read JCL input
	 FATAL			;Can't fail
	JUMPE A,CMDINI		;None, go on
	MOVEI A,.NULIO		;Get null JFN
	HRRM A,CSB+.CMIOJ	;Save as output JFN
	HRROI A,[ASCIZ//]	;No prompt
	CALL SETCMD		;Set up for command processing
	MOVEI B,[FLDDB. .CMFLD]	;Field (our program name)
	CALL .COMND		;Parse and ignore
	 JRST NORSCN		;Failed, give up on JCL
	MOVEI B,[FLDDB. .CMCFM]	;Confirmation (if succeeds then no JCL)
	CALL .COMND		;Parse it
	 JRST CPARSE		;Failed, go process JCL
NORSCN:	MOVEI A,.PRIOU		;Normal output JFN
	HRRM A,CSB+.CMIOJ	;Save as output JFN
	HRROI A,[ASCIZ//]	;Get null string
	RSCAN%			;Clear RSCAN buffer with it
	 FATAL
CMDINI:	MOVE P,[IOWD PDLEN,PDL]	;Reset stack pointer for safety's sake
	HRRZ A,CSB+.CMIOJ	;Get output JFN
	CAIE A,.NULIO		;Redirected?
	IFSKP.
	  HALTF%		;Stop the program (continuable)
	  JRST NORSCN		;Go fix RSCAN buffer
	ENDIF.
	HRROI A,[ASCIZ/Merlin> /]
	CALL SETCMD		;Initialize parser
CPARSE:	SETZM NDIRNM		;Clear new dir number once here
	TXZ F,F%KOLD		;Clear flags used in parse
	MOVEI B,[FLDDB. .CMKEY,,CMDTAB]
	CALL .COMND		;Parse a command name
	 PMSG
	HRRZ B,(B)		;Get dispatch routine
	CALL (B)		;Run the routine
	JRST CMDINI		;Back for another

SUBTTL Table of commands

DEFINE T (KEY,FLAGS) <
	[ IFNB <FLAGS>,<CM%FW!FLAGS>
	  ASCIZ\KEY\ ] ,, .'KEY
>

CMDTAB:	NCMDS,,NCMDS
	T COPY
	T DELETE
	T EXIT
	T FCOPY
	T FRENAME
	T HELP
	T QUIT,CM%INV
	T RENAME
	T UPDATE
NCMDS==.-CMDTAB-1

SUBTTL Copy command

.COPY:	CALL ODIR		;Parse source directory
	NOISE <to>
	CALL NDIR		;And destination
	SETZ D,			;All flags apply
	CALL PFLAGS		;Parse them
	CALL CONFRM		;Finish command parse
	HRROI A,NEWDIR		;Point to new dir
	MOVE B,ODIRNM		;And get old dir num
	TXZ F,F%RENM		;Copying with no deletion
;	JRST CPYDIR		;Do the copy

DEFINE DOGROUP (NAME) <		;; Set CRDIR block entry for a group
	MOVEI B,$'NAME		;; Point to block for that group
	MOVEM B,CRDBLK+.'NAME	;; Set it in block
	MOVEM A,(B)		;; Set size of the group
	SETZM 1(B)		;; No groups there yet
>

CPYDIR:	CAMN B,NDIRNM		;Are we copying the new directory?
	 RET			;Yes, don't recurse indefinitely
	CPYTRVAR		;Make some variables
	MOVEM A,DEST		;Save destination directory name
	MOVEM B,SOURCE		;Save source directory number
	MOVEI A,MAXGRP		;Get maximum group block size
	GROUPS			;Set the CRDIR block entries
	MOVE A,[POINT 7,$CDDAC]
	MOVEM A,CRDBLK+.CDDAC	;Save in the block
	MOVEI A,CRDLEN		;Want the whole CRDIR block
	MOVEM A,CRDBLK+.CDLEN	;Need it here for directory information
	MOVE A,SOURCE		;From the old directory
	MOVEI B,CRDBLK		;Into CRDIR block
	HRROI C,$CDPSW		;And password string
	GTDIR%			;Get directory information
	 ERNOP
	MOVE A,[POINT 7,$CDDAC]	;Get pointer to account string
	MOVEM A,CRDBLK+.CDDAC	;Save in the block
	MOVE A,DEST		;Point to destination directory
	MOVX B,CD%PSW!CD%LIQ!CD%PRV!CD%MOD!CD%LOQ!CD%FPT!CD%DPT!CD%RET!CD%LLD!CD%UGP!CD%DGP!CD%SDQ!CD%CUG!CD%DAC
				;Save the default account
	CALL .CRDIR		;Make the new directory
	IFNSK.
	  TMSG <% Couldn't create >
	  MOVE A,DEST		;Point to original name of new directory
	  PSOUT%		;Type it
	  JRST ERDASH		;Type dash and error message, then return
	ENDIF.
	SKIPN NDIRNM		;If no new directory number yet
	 MOVEM A,NDIRNM		;Then this is it

; Made the new directory, now copy the contents across
	MOVE B,A		;Get number into B
	HRROI A,NEWNAM		;Point to new name space
	DIRST%			;Translate to string
	 FATAL
	MOVEM A,NEWPTR		;Save pointer to new name

	MOVE B,SOURCE		;From the old directory
	CALL MAPDIR		;Map over all files and subdirs
	 CALL CP1FIL		;Copy a file
	 CALL CPYSUB		;Copy a subdir
	CALL UNSAVE		;Now make sure the last file is deleted or not

	TMSG < >		;Start message
	MOVEI A,.PRIOU		;To terminal
	MOVE B,SOURCE		;From old directory name
	DIRST%			;Type as a string
	 FATAL
	TMSG ( => )
	MOVEI A,">"		;Get a close bracket
	DPB A,NEWPTR		;Make sure new name ends with it
	SETZ A,			;Get a null
	IDPB A,NEWPTR		;Drop at end of new directory name
	TYPE NEWNAM		;Type the new name
	TMSG < [OK]
>				;Finish message
	TXNN F,F%RENM		;Renaming?
	 RET			;No, done
	MOVE B,SOURCE		;From source
	TXZ F,F%DLOK!F%DSUB	;Being quiet, not deleting subdirs
	JRST DELDIR		;Delete the directory

; Copy subroutines

; Given JFN of old file in A, copy or rename into new directory
; also given .FBCTL word in C


CP1FIL:	TXNE F,F%NFIL		;Copying files?
	 RET			;No, don't do so
	STKVAR <CP1JFN,NEWBYV,NEWCTL>
	MOVEM A,CP1JFN		;Save JFN for later
	MOVEM C,NEWCTL		;Save flag word for later
	MOVE A,NEWPTR		;With the pointer at the end of the new dir
	MOVEI B,">"		;Get a close bracket
	DPB B,A			;Make sure directory ends with it

	;; If this is UPDATE command, check if the file is more recent
	IFXN. F,F%UPDA		;If updating
	  MOVE B,CP1JFN		;Get JFN to handle
	  MOVX C,FLD(.JSAOF,JS%NAM)!FLD(.JSAOF,JS%TYP)!JS%PAF
	  JFNS%			;Make string for JFN
	  MOVX A,GJ%SHT!GJ%OLD	;Looking for an old JFN
	  HRROI B,NEWNAM	;From string we just built
	  GTJFN%		;Get a JFN on it
	ANSKP.			;If that succeeded
	  MOVX B,<1,,.FBWRT>	;Then for the write date of the file
	  MOVEI C,D		;Into D
	  GTFDB%		;Get FDB word
	  RLJFN%		;Now flush useless JFN
	   NOP
	  HRRZ A,CP1JFN		;With current JFN
	  MOVEI C,C		;Into C
	  GTFDB%		;Get write date again
	  CAMG C,D		;If source is not later than dest
	   RET			;Then skip that file
	ENDIF.

	;; Have made sure we want to copy, now make a filename
	MOVE A,NEWPTR		;Point to end of directory part again
	MOVE B,CP1JFN		;From the given JFN
	MOVX C,FLD(.JSAOF,JS%NAM)!FLD(.JSAOF,JS%TYP)!FLD(.JSAOF,JS%GEN)!JS%PAF
	JFNS%			;Add the file name at the end
	MOVX A,GJ%SHT!GJ%FOU	;Flags for an output file
	HRROI B,NEWNAM		;Now point to the start of the string
	GTJFN%			;And get a JFN on it
	 FATAL

	;; Save that JFN and find out about byte sizes etc of old file
	EXCH A,CP1JFN		;Get old JFN, save new
	MOVX B,<1,,.FBBYV>	;Word with various random fields
	MOVEI C,NEWBYV		;Into stack variable
	GTFDB%			;Get FDB word

	;; Now do the copy or rename as appropriate
	MOVE B,CP1JFN		;Now get new
	TXNN F,F%RENM		;Renaming?
	IFSKP.
	  SETZM CURJFN		;Yes, rename will lose the JFN
	  CALL .RNAMF		;Do the rename
	ELSE.
	  CALL CPYFIL		;Else just copy the files
	ENDIF.

	;; Copied or renamed, Clean up after previous copy or rename
	MOVE A,CP1JFN		;Get JFN for the file we just made
	MOVE C,NEWBYV		;Get gen retention count word back
	MOVE D,NEWCTL		;and flag words
;	JRST UNSAVE		;Go finish setting previous file

; Set flag words in file from previous cycle
; Call with A/JFN for next cycle, C/next .FBBYV, D/next .FBCTL

UNSAVE:	EXCH A,SAVJFN		;Get back the one we saved from last time
	IFE. A			;If zero
	  MOVEM C,SAVBYV	;Save flag word
	  MOVEM D,SAVCTL	;And gen-ret count
	  RET
	ENDIF.
	HRLI A,.FBBYV		;Into gen-ret-count word
	MOVX B,FB%RET		;Only the generation retention count
	EXCH C,SAVBYV		;With old byte count etc
	CHFDB%			;Set FDB words
	 ERNOP
	HRLI A,.FBCTL
	MOVX B,FB%TMP!FB%PRM!FB%DEL!FB%NOD!FB%INV!FB%FCF!FB%NDL
	MOVE C,SAVCTL		;Get old saved bits back
	MOVEM D,SAVCTL		;And save the new ones
	CHFDB%			;Set them in the file
	 ERNOP
	RLJFN%			;Release the JFN now that we are done with it
	 FATAL
	RET

CPYSUB:	TXNE F,F%NSUB		;Copying subdirectories?
	 RET			;No, don't do this one
	HRROI A,TEMP		;Into temporary storage
	DIRST%			;Copy old directory name
	 FATAL
	MOVE A,[POINT 7,TEMP]	;Now point to it
	DO.
	  ILDB D,A		;Get the next char
	  CAIN D,"."		;Dot?
	   MOVE C,A		;Yes, save this pointer
	  JUMPN D,TOP.		;Maybe go back for more
	ENDDO.
	MOVE A,NEWPTR		;Point to end of new directory
	MOVEI D,"."		;Get a dot
	DPB D,A			;Drop it in in place of close bracket
	DO.
	  ILDB D,C		;Get next subdir name char
	  IDPB D,A		;Drop it in
	  JUMPN D,TOP.		;Maybe go back for more
	ENDDO.
	HRROI A,NEWNAM		;Now point to start of string
	JRST CPYDIR		;Recursively call directory copier

SUBTTL Delete command

.DELETE:CALL ODIR		;Parse directory to be deleted
	MOVX D,F%NSUB!F%NFIL!F%NGRP!F%KNUM ; Flags with no meaning here
	CALL PFLAGS
	CALL CONFRM		;Finish command parse
	MOVE A,ODIRNM		;With that directory number
	TXO F,F%DLOK!F%DSUB	;Typing verbose messages, deleting subdirs
;	JRST DELCNF		;Delete with confirmation


; Delete a directory, confirming with user if not empty.
; Call with A/directory number
; Returns +1/always

DELCNF:	TRVAR <DLDIRN>
	MOVEM A,DLDIRN		;Save directory number
	GTDAL%			;Find out how much of the dir is being used
	IFN. B			;If there are non-null files
	  HRROI A,[ASCIZ/is non-empty/]
	  CALL DOCONF		;Make sure user wants to go through with it
	ELSE.
	  HRROI A,TEMP		;Into temporary storage
	  MOVE B,DLDIRN		;With the old directory number
	  DIRST%		;Make a string
	   FATAL
	  MOVEI B,"."		;Now a dot
	  DPB B,A		;In place of the close bracket
	  MOVEI B,"*"		;And a star
	  IDPB B,A
	  MOVEI B,">"		;And a close bracket
	  IDPB B,A
	  SETZ C,		;And a null
	  IDPB C,A		;To make <DIR.*>
	  MOVX A,RC%AWL		;Wildcard RCDIR%
	  HRROI B,TEMP		;Point to string we just made
	  CALL .RCDIR		;Check if directory exists
	  IFSKP.
	    HRROI A,[ASCIZ/has sub-directories/]
	    CALL DOCONF		;Get confirmation from user
	  ENDIF.
	ENDIF.
	MOVE B,DLDIRN		;With the old directory
;	JRST DELDIR		;Delete the directory

DELDIR:	STKVAR <DLNDIR,DELJFN>	;Declare local storage
	TXNN F,F%DSUB		;Deleting subdirs?
	IFSKP.
	  CALL MAPDIR		;Map over everything in the directory
	   NOP			;Ignoring normal files
	   CALL DELDIR		;And calling self recursively on subdirectories
	ENDIF.
	HRROI A,TEMP		;Into temporary storage
	DIRST%			;Translate dir number into a string
	 FATAL
	MOVEM B,DLNDIR		;Save it just in case
	TXNE F,F%NPRS		;Preserving quotas?
	 JRST DELDI0		;No, don't need this hackery

; In order to preserve quotas we must set the working and permanent disk space
; to 0 as CD%DEL ignores the preserve bit.  To do so without an error, we must
; first delete every file, and expunge that directory with a rebuild.

	MOVE A,DLNDIR		;Get the number of used pages in the 
	GTDAL%			;Directory
	 ERNOP
	JUMPE B,DELDI1		;If nothing used, just fix the quotas
	SETZM DELJFN		;Store the deleted files here
	MOVEI A,WLJBLK		;Get wild GTJFN block
	HRROI B,TEMP		;With the string we just built
	GTJFN%			;Get a JFN
	 JRST DELDI1		;Failed, just clear quotas
	MOVEM A,DELJFN		;Save the JFN to be deleted
	TXO F,F%DELF		;If there is a file, then 
	DO.			;Do until all files are done
	  MOVE A,DELJFN		;Get the current JFN
	  MOVEM A,CURJFN	;Save it for other routines
	  IFXN. F,F%VERB	;If being verbose
	    TMSG < Deleting >
	    MOVEI A,.PRIOU	;Output the name of the current
	    HRRZ B,DELJFN	;file name to delete
	    MOVX C,JS%SPC!JS%TMP!JS%OFL!JS%PAF
	    SETZ D,		;with temp and offline bits
	    JFNS%
	     ERNOP		;Ignore the error
	  ENDIF.		;Done verbose
	  HRRZ A,DELJFN		;Get the current file
	  TXO A,DF%NRJ!DF%ARC	;Delete without releasing the JFN
	  DELF%			;(delete archive files also).
	  IFNJE.		;No error
	    CALL SAYOK		;Type [OK] if verbose
	  ELSE.			;Or error message if verbose
	    TXNE F,F%VERB	;And an error occurred
	     CALL ERDASH
	  ENDIF.
	  MOVE A,DELJFN		;Get the JFN we are deleting
	  GNJFN%		;Go to the next JFN
	   IFSKP. <LOOP.>	;If got another file, go back and delete it too
	ENDDO.			;End of delete loop

	SETZM CURJFN		;Say there is no current JFN
	TXZ F,F%DELF		;Say we are done deleting
	HRRZ A,DELJFN		;Release the current JFN
	RLJFN%
	 ERNOP			;Ignore the error

	IFXN. F,F%VERB		;If verbose
	  TMSG < Expunging >
	  TYPE TEMP		;Say we are expunging the directory
	ENDIF.
	MOVX A,DD%DTF!DD%DNF!DD%RST ;Expunge the current
	MOVE B,DLNDIR		;directory deleting temp files,
	DELDF%			;expunging open, and rebuild things
	IFNJE.
	  CALL SAYOK		;Inform of success
	ELSE.
	  TXNE F,F%VERB		;or if we started saying we were expunging
	    CALL ERDASH		;finish that message with failure text
	ENDIF.

; Here when we've emptied the directory.  We still need to set the quotas to 0
DELDI1:	SETZM CRDBLK+.CDLIQ	;We have to set quotas to zero first
	SETZM CRDBLK+.CDLOQ	;Because CD%DEL ignores CD%NSQ
	HRROI A,TEMP		;With the directory name we just made
	MOVX B,CD%LIQ!CD%LOQ	;Setting both quotas
	CALL .CRDIR		;Do the CRDIR
	IFNSK.			;Flag the error
	  TMSG <% Couldn't update quotas for >
	  CALL ERTEMP		;Type temp, dash, error
	ENDIF.

; Done hacking quotas, now do the deletion
DELDI0:	IFXN. F,F%DLOK!F%VERB	;If being verbose or typing deleted directories
	  IFXE. F,F%DLOK	;If primary action is not deletion
	    TMSG < Deleting>	;Then say that's what we're doing
	  ENDIF.
	  TMSG < >		;A space for pretty
	  TYPE TEMP		;Now type directory name
	ENDIF.
	HRROI A,TEMP		;With name we just made
	MOVX B,CD%DEL		;Deleting, make sure quotas get seen
	CALL .CRDIR		;Do the CRDIR%
	 JRST ERDASH		;Failed, complain
	TXNN F,F%DLOK!F%VERB	;Are we typing messages?
	 RET			;No, don't do so
	TMSG < [OK]
>				;Say it was removed.
	RET

; Here when we get an error and want to type the string for it

ERTEMP:	TYPE TEMP		;Type name of directory
ERDASH:	TMSG < - >
	CALL .ERSTR		;Say why it couldn't be deleted
	TMSG <
>				;Finish message
	RET

; Here to type [OK] if verbose
SAYOK:	TXNN F,F%VERB		;Verbose?
	 RET			;No, do nothing
	TMSG < [OK]
>				;Else give message
	RET

; Confirm to delete a non-empty directory

DOCONF:	CALL PUSHIO		;Make sure command I/O is to the terminal
	PUSH P,A		;Save the prompt
	HRROI A,TEMP		;Into temporary storage
	MOVE B,DLDIRN		;With given directory number
	DIRST%			;Translate to a string
	 FATAL
	MOVEI B," "		;Now get a space
	IDPB B,A		;To separate them
	POP P,B			;Get prompt back
	CALL STRCPY
	HRROI B,[ASCIZ/ [Confirm] /]
	CALL STRCPY		;Finish up
	IDPB C,A		;Drop null in
	MOVEI A,.PRIIN		;With the terminal
	CFIBF%			;Clear input buffer
	HRROI A,TEMP		;Now with prompt we built
	CALL SETCMD		;Set up for confirmation parse
	JRST CONFRM		;Confirm it

PUSHIO:	PUSH P,A		;Save a register
	MOVE A,[.PRIIN,,.PRIOU]	;Get command JFNs we want
	CAMN A,CSB+.CMIOJ	;Normal?
	IFSKP.
	  EXCH A,CSB+.CMIOJ	;No, set JFNs to tty and get what they were
	  EXCH A,(P)		;Save on stack and restore register
	  CALL @-1(P)		;Call caller
	  POP P,CSB+.CMIOJ	;Restore original JFNs
	ENDIF.
	POP P,A			;Get reg back or flush caller from stack
	RET			;Return to caller or caller's caller

STRCPY:	MKPTR (A)		;Make sure we have real byte pointers
	MKPTR (B)
	DO.
	  ILDB C,B		;Get a character
	  JUMPE C,R		;If null stop
	  IDPB C,A		;Else drop it in
	  LOOP.
	ENDDO.

SUBTTL Exit command

.QUIT:				;(invisible synonym)
.EXIT:	NOISE <from Merlin>
	CALL CONFRM		;Finish command parse
	HALTF%			;Stop the program
	RET			;Allow continue

SUBTTL FCOPY command

.FCOPY:	CPYTRVAR		;Declare standard TRVAR for copying files
	NOISE <from files>

	MOVEI A,WLJBLK		; [PJG] Replace the default GTJFN argument
	MOVEM A,CSB+.CMGJB	; [PJG] block with our own

	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<files to copy>]
	CALL .COMND		;Parse wildcard filespec
	 PMSG
	MOVEM B,SOURCE		;Save the JFN

	MOVEI A,CMDGTJ		; [PJG] Restore the original GTJFN argument
	MOVEM A,CSB+.CMGJB	; [PJG] block

	NOISE <into directory>	;Parse in this order to be consistent w/FTP etc
	CALL ODIRNN		;Parse directory into which to update
	CALL CONFRM		;Finish the parse

	CALL OKFCPY		; [PJG] Check if it OK to copy the files
	 RET			; [PJG] Error return

	HRROI A,NEWNAM		;Point to string space
	MOVE B,ODIRNM		;With old directory
	DIRST%			;Make a string
	 FATAL
	MOVEM A,NEWPTR		;Save for making filenames with
	TXO F,F%VERB		;Set verbose flag for CPYFIL
	TXZ F,F%NFIL!F%RENM	;Copying files, not renaming
	DO.
	  HRRZ A,SOURCE		;Get JFN to handle
	  MOVEM A,CURJFN	;Let ^A work
	  MOVX B,<1,,.FBCTL>	;Flag word
	  MOVEI C,C		;Into C
	  GTFDB%		;Get FDB word
	  TXNN C,FB%DIR		;If this is a real file...
	   CALL CP1FIL		;Then copy it
	  SETZM CURJFN		;Copied
	  MOVE A,SOURCE		;Get JFN back
	  GNJFN%		;Get the next one
	   JRST UNSAVE		;No more, make sure last file is deleted or not
	  LOOP.			;Else go back for the next
	ENDDO.

SUBTTL FRENAME command

.FRENA:	CPYTRVAR		;Declare standard TRVAR for copying files
	NOISE <from files>

	MOVEI A,WLJBLK		; [PJG] Replace the default GTJFN argument
	MOVEM A,CSB+.CMGJB	; [PJG] block with our own

	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<files to rename>]
	CALL .COMND		;Parse wildcard filespec
	 PMSG
	MOVEM B,SOURCE		;Save the JFN

	MOVEI A,CMDGTJ		; [PJG] Restore the original GTJFN argument
	MOVEM A,CSB+.CMGJB	; [PJG] block

	NOISE <into directory>	;Parse in this order to be consistent w/FTP etc
	CALL ODIRNN		;Parse directory into which to update
	CALL CONFRM		;Finish the parse

	CALL OKFCPY		; [PJG] Check if it OK to rename the files
	 RET			; [PJG] Error return

	HRROI A,NEWNAM		;Point to string space
	MOVE B,ODIRNM		;With old directory
	DIRST%			;Make a string
	 FATAL
	MOVEM A,NEWPTR		;Save for making filenames with
	TXO F,F%VERB!F%GNJ	;[PJG] Set verbose flag for CPYFIL
	TXZ F,F%NFIL!F%RENM	;[PJG] Copying files, rename files
	DO.
	  HRROI A,FRNNAM	; [PJG] Save the current filename
	  HRRZ B,SOURCE		; [PJG] Get JFN to handle
	  MOVX C,JS%SPC!JS%PAF	; [PJG] Must be the whole filename
	  JFNS%
	   ERJMP .+1

	  MOVE A,SOURCE		; [PJG] Increment to the next file
	  GNJFN%		; [PJG] So the JFN isn't used by mistake
	   TXZ F,F%GNJ		; [PJG] Say GNJFN is done

	  MOVEI A,GTJBLK	; [PJG] Regular JFN block
	  HRROI B,FRNNAM	; [PJG] Get the filename
	  GTJFN%
	  IFNJE.
	   HRRZ A,A		; [PJG] Get the new JFN
	   MOVEM A,CURJFN	;Let ^A work
	   MOVX B,<1,,.FBCTL>	;Flag word
	   MOVEI C,C		;Into C
	   GTFDB%		;Get FDB word
	   TXNN C,FB%DIR	;If this is a real file...
	   IFNSK.
	    CALL CP1FIL		; [PJG] Must copy it to keep the dates, and
				; [PJG] allow archived files to be deleted
	    MOVX A,DF%EXP!DF%ARC	; [PJG] Delete and expunge
	    HRR A,CURJFN	; [PJG] The current file
	    DELF%
	     ERJMP .+1		; [PJG] Ignore errors
	   ENDIF.
	  ENDIF.

	  SETZM CURJFN		;Copied
	  TXNN F,F%GNJ		; [PJG] If we have more then jump
	   JRST UNSAVE		;No more, make sure last file is deleted or not
	  LOOP.			;Else go back for the next
	ENDDO.

SUBTTL OKFCPY routine used to double legal file copying for FRENAME and FCOPY
;
;	OKFCPY is dependent on the variable SOURCE containing flags,,JFN for
; the files to copy, and OLDDIR to contain the destination directory.  It does
; a RETSKP if everything is OK to copy or rename.  This routine was written by
; GERGELY@DREA-XX, 5 Sept 85.

OKFRET:	BLOCK 1			; Place to save the return address
OKFCPY:	POP P,OKFRET		; Save the return address
	SETZM ATMBUF		; Zero out the atom buffer

	MOVE B,SOURCE		; Get the source JFN
	TXNE B,GJ%DEV!GJ%UNT!GJ%DIR	; Check if any wildcard spec is set
	 XPMSG <Illegal to FRENAME or FCOPY files with wildcard source directory specs>

	HRROI A,NEWNAM		; Use this for temporary storage
	HRRZ B,SOURCE		; Get the device and directory
	MOVX C,FLD(.JSAOF,JS%DEV)!FLD(.JSAOF,JS%DIR)!JS%PAF	; Output it
	JFNS%
	 ERNOP			; Ignore the error

	HRROI A,OLDDIR		; Get the destination directory
	HRROI B,NEWNAM		; Get the source directory
	STCMP%			; Compare the two strings
	 ERNOP
	SKIPN A			; If they are different then skip
	 XPMSG <Illegal to FRENAME or FCOPY files into self>

	PUSH P,OKFRET		; Retrieve the return address
	RETSKP			; No error

SUBTTL Help command

.HELP:	NOISE <with Merlin>
	CALL CONFRM		;Finish command parse
	TYPE HLPTXT		;Give the help
	RET

HLPTXT:	ASCIZ\Merlin performs various directory manipulations.  Commands are:
    COPY   - Copy directory without changing original.
    DELETE - Remove directory from the filesystem (may need confirmation).
    EXIT   - Return to the EXEC.
    FCOPY  - Copy files while maintaining the original FDB information.
    FRENAME- Rename files while maintaining the original FDB information.
    HELP   - Type this text.
    RENAME - Change a directory's name (new name may be on another structure).
    UPDATE - Copy recently-modified files into a directory.

Switches for COPY, DELETE, and RENAME are:
    /KeepNumbers  - keep directory numbers when copying directories
    /NoFiles      - keep directory structure but don't copy contents.
    /NoGroups	  - don't copy user, subdirectory user, or directory groups.
    /NoSubdirs    - don't recursively copy subdirectories (COPY only).
    /UpdateQuotas - don't preserve superior directory quotas.
    /Verbose      - type each file copy or rename processed.
\

SUBTTL Rename command

.RENAME:CALL ODIR		;Parse source directory
	NOISE <to be>		;Supply guide words
	CALL NDIR		;Parse a new name for it
	MOVE A,[POINT 7,OLDDIR]
	MOVE B,[POINT 7,NEWDIR]
	DO.
	  ILDB C,A		;Get a char from the old name
	  ILDB D,B		;And from the new name
	  CAIE C,">"		;Closing directory name?
	   CAIN C,"]"		;Or this kind of close?
	    IFSKP.
	      CAMN C,D		;No, see if the same character
	       LOOP.		;Yes, go back for another try
	    ELSE.
	      CAIN D,"."	;Then the other better not be a subdir
	       XPMSG <Can't rename a directory into its own subdirectory>
	    ENDIF.
	ENDDO.
	MOVX D,F%NSUB		;Don't want to use this flag for RENAME
	CALL PFLAGS		;Parse flags
	CALL CONFRM		;Finish command parse
	HRROI A,NEWDIR		;Point to new dir
	MOVE B,ODIRNM		;And get old dir num
	TXO F,F%RENM		;Renaming
	JRST CPYDIR		;Do the copy

SUBTTL Update command

.UPDATE:CPYTRVAR		;Declare standard TRVAR for copying files
	NOISE <from files>
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<files from which to update directory>]
	CALL .COMND		;Parse wildcard filespec
	 PMSG
	MOVEM B,SOURCE		;Save the JFN
	NOISE <into directory>	;Parse in this order to be consistent w/FTP etc
	CALL ODIRNN		;Parse directory into which to update
	CALL CONFRM		;Finish the parse

	HRROI A,NEWNAM		;Point to string space
	MOVE B,ODIRNM		;With old directory
	DIRST%			;Make a string
	 FATAL
	MOVEM A,NEWPTR		;Save for making filenames with
	TXO F,F%VERB!F%UPDA	;Set verbose flag for CPYFIL, updating
	TXZ F,F%NFIL!F%RENM	;Copying files, not renaming
	DO.
	  HRRZ A,SOURCE		;Get JFN to handle
	  MOVEM A,CURJFN	;Let ^A work
	  MOVX B,<1,,.FBCTL>	;Flag word
	  MOVEI C,C		;Into C
	  GTFDB%		;Get FDB word
	  TXNN C,FB%DIR		;If this is a real file...
	   CALL CP1FIL		;Then copy it
	  SETZM CURJFN		;Copied
	  MOVE A,SOURCE		;Get JFN back
	  GNJFN%		;Get the next one
	   JRST UNSAVE		;No more, make sure last file is deleted or not
	  LOOP.			;Else go back for the next
	ENDDO.

SUBTTL Parse flags

; D/inapplicable flags
; Returns +1/always, flags set in right half of F

PFLAGS:	HLLZS F			;Clear out switchable flags
	TXNN F,F%PRIV		;If not privileged
	 TXO F,F%NPRS		;Then can not preserve quotas
	DO.
	  MOVEI B,[FLDDB. .CMSWI,,SWITAB]
	  CALL .COMND		;Parse a switch
	   RET			;Failed, stop parsing
	  HRRZ B,(B)		;Get dispatch word
	  TRNE D,(B)		;Applicable for this command?
	   XPMSG <Switch inapplicable to this command>
	  IORI F,(B)		;Set in flags
	  LOOP.
	ENDDO.

DEFINE T (KEY,VAL) <[ASCIZ\KEY\] ,, VAL>

SWITAB:	NSWIT,,NSWIT
	T KeepNumbers,F%KNUM	;Keep directory numbers
	T NoFiles,F%NFIL	;Don't copy contents
	T NoGroups,F%NGRP	;Don't copy group numbers
	T NoSubdirs,F%NSUB	;Don't copy subdirectories
	T UpdateQuotas,F%NPRS	;Don't preserve superior quotas
	T Verbose,F%VERB	;Notify user for each file transfer
NSWIT==.-SWITAB-1

SUBTTL Directory parse routines

ODIR:	NOISE <directory>
ODIRNN:	MOVEI B,[FLDDB. .CMDIR,CM%SDH,,<existing directory>]
	CALL .COMND
	 PMSG
	MOVEM B,ODIRNM		;Save number
	HRROI A,OLDDIR		;Point to place to store dir string
	DIRST%			;Get name of directory
	 FATAL
	RET

NDIR:	MOVEI B,[FLDDB. .CMDIR,CM%SDH!CM%PO,,<directory to create>]
	CALL .COMND		;Read parse-only directory name
	 PMSG
	HRROI B,ATMBUF		;With the new directory name
	CALL DIRCHK		;Check if directory exists
	IFSKP.
	  CAMN B,ODIRNM		;Is it the same as the source directory number?
	   XPMSG <Illegal to copy or rename to self>
	  MOVEM B,NDIRNM	;Old but not same as source, save for later
	  TXO F,F%KOLD		;Remember we have to kill it before making anew
	  HRROI A,NEWDIR	;Into new directory name buffer
	  DIRST%		;Translate back into a canonicalized string
	   FATAL
	  MOVE A,[POINT 7,OLDDIR] ;Point to source string
	  MOVE B,[POINT 7,NEWDIR] ;And our destination string
	  DO.
	    ILDB C,A		;Get an old-dir char
	    ILDB D,B		;And a new-dir char
	    CAIE D,">"		;If it's a close bracket
	    IFSKP.
	      CAIE C,">"	;Then if old is close bracket (impossible)
	       CAIN C,"."	;Or dot
		XPMSG <Illegal to copy or rename to superior>
	    ELSE.
	      CAMN C,D		;Not a close.  if they're the same
	       JUMPN C,TOP.	;Then go back for another
	    ENDIF.
	  ENDDO.
	  RET
	ENDIF.

; Got here means directory doesn't exist.  Canonicalize after finding superior.
	CALL SUPER		;Get superior directory, leave pointers in A, B
	IFSKP.
	  MOVEI C,"."		;Get a dot
	  DPB C,A		;Drop it in to start subdirectory name
	ENDIF.
	DO.
	  ILDB C,B		;Get next char of subdir name
	  UPCASE (C)		;Make sure it is uppercase
	  CAIE C,"["		;If it's a funny open
	   CAIN C,"]"		;Or its a funny close
	    SUBI C,"["-"<"	;Turn it into an angle bracket instead
	  IDPB C,A		;Drop it in
	  JUMPN C,TOP.		;Loop back until done
	ENDDO.
	RET

; Return the new directory's superior
; returns +1/top level, a => STR:
;	  +2/a => STR:<SUPER>
; in either case B points to the rest of the directory (with "<" if top level)

SUPER:	STKVAR <DOTPTR,CLNPTR,SAVPTR>
	MOVE A,[POINT 7,NEWDIR]	;Point to destination buffer
	MOVE B,[POINT 7,ATMBUF]	;And source buffer
	SETZM DOTPTR
	SETZM CLNPTR		;Found no dots or colons yet
	MOVEM B,SAVPTR		;Save where to copy from
	DO.
	  ILDB D,B		;Get next char
	  UPCASE (D)		;Make it uppercase
	  CAIN D,"["		;If its a square bracket
	   MOVEI D,"<"		;Use this kind instead
	  IDPB D,A		;Drop it in
	  CAIE D,"."		;If it's a dot
	  IFSKP.
	    MOVEM A,DOTPTR	;Save it
	    MOVEM B,SAVPTR	;And where we got it from
	  ENDIF.
	  CAIE D,":"		;If it's a colon
	  IFSKP.
	    MOVEM A,CLNPTR	;Save that too
	    MOVEM B,SAVPTR
	  ENDIF.
	  JUMPN D,TOP.
	ENDDO.
	SKIPN C,DOTPTR		;If we found a superior directory
	IFSKP.
	  MOVEI B,">"		;Get a close bracket
	  DPB B,C		;Drop it in
	  IDPB D,C		;Drop our null in to terminate
	  HRROI B,NEWDIR	;With the new directory's superior
	  CALL DIRCHK		;Check if directory exists
	   XPMSG <Superior does not exist>
	  HRROI A,NEWDIR	;Into the new directory string
	  DIRST%		;Translate the directory
	   FATAL
	  MOVE B,SAVPTR		;Get pointer to rest of directory
	  RETSKP		;All done
	ENDIF.

; Got here means the superior is <ROOT-DIRECTORY>
	SKIPE A,CLNPTR		;If no colon found
	IFSKP.			;Then we have to use connected directory
	  GJINF%		;Find out which that is
	  HRROI A,NEWDIR	;Into new directory string space
	  DIRST%		;Copy the directory name
	   FATAL
	  MOVE A,[POINT 7,NEWDIR] ;Now point to the name we just got
	  DO.
	    ILDB B,A		;Get the next character
	    CAIE B,":"		;If not a colon
	     LOOP.		;Then go back for more
	  ENDDO.
	ENDIF.
	MOVE B,SAVPTR		;Get pointer to rest of directory
	RET			;All done

; Skip if string in B points to a real directory name
; alternate entry .RCDIR lets caller give flags
; if directory exists, a directory number is returned in B

DIRCHK:	MOVX A,RC%EMO		;Force exact match
.RCDIR:	SETZ C,			;No directory to step to
	RCDIR%			;Translate string to directory
	TXNE A,RC%NOM		;Matched?
	 RET			;No, give fail return
	MOVE B,C		;Else leave directory number where it belongs
	RETSKP

SUBTTL Call the CRDIR jsys

.CRDIR:	SAVEAC <C,D>		;Save a couple of registers
	HRRI B,CRDBLK		;Get block number in right half of B
	TXNE B,CD%DEL		;If deleting directory
	 JRST .CRDI0		;Go do it
	TXNE F,F%KNUM		;If keeping numbers
	 TXO B,CD%NUM		;Tell CRDIR to keep it
	TXO B,CD%LEN		;Use the information in word .CDLEN
	MOVEI C,CRDLEN		;Get the length of the argument block
	TXNN F,F%NPRS		;=0 then preserving current quotas
	 TXO C,CD%NSQ
	TXNE B,CD%PRV		;If setting privileges then must be
	 TXO C,CD%NED!CD%FED	;New, so set online/offline expiration
	MOVEM C,CRDBLK+.CDLEN	;Save word in crdir block
	TXNE F,F%NGRP		;Want group numbers?
	 TXZ B,CD%UGP!CD%DGP!CD%CUG ;No, turn off those flags

; Flags and block all set up, do the JSYS
.CRDI0:	SETZ C,			;No password
	CRDIR%			;Do the JSYS
	 IFNJE. <RETSKP>	;If succeeded, return

; Here on some JSYS error, find out what it was and retry if possible
	DMOVE C,A		;Copy flags and pointers for later
	MOVEI A,.FHSLF		;On ourself
	GETER%			;Get last error
	HRRZS B			;Keep only error code, flush fork handle
	CAIE B,CRDIX8		;Invalid directory number
	 CAIN B,CRDI10		;Or number out of range?
	  TXZN D,CD%NUM		;Yes, clear "set number", see if set already
	   IFSKP.
	     TMSG <% Couldn't keep directory number of >
	     MOVE A,C		;Get directory name
	     PSOUT%		;Type that too
	     TMSG <
>				;Finish with a crlf
	     JRST .CRDI1	;Go try again
	   ENDIF.

	CAIE B,ARGX27		;Offline expiration greater than system max?
	IFSKP.
	  MOVE A,CRDBLK+.CDLEN	;Get length/flag word
	  TXZN A,CD%NED!CD%FED	;Try clearing expiration bits
	   RET			;Already done so, give up
	  MOVEM A,CRDBLK+.CDLEN	;Else put cleared flags back
	  JRST .CRDI1		;And try again
	ENDIF.

	CAIE B,CRDI17		;User directory under files-only?
	IFSKP.
	  SKIPGE A,CRDBLK+.CDMOD ;Get mode word.  is CD%DIR set?
	   RET			;No, give up
	  TXO A,CD%DIR		;Else set the bit
	  MOVEM A,CRDBLK+.CDMOD	;And save for retry
	  TMSG <% >		;Start warning
	  MOVE A,C		;Get directory name
	  PSOUT%		;Type it
	  TMSG < will be created FILES-ONLY
>
	  JRST .CRDI1		;Go do it
	ENDIF.

	CAIN B,CRDI16		;Invalid user group?
	 TXZN D,CD%UGP!CD%DGP!CD%CUG ;Yes, turn off user group flags
	  RET			;Unknown error or no user group flags, give up
	TMSG <% User groups will not be copied for >
	MOVE A,C		;Get directory name
	PSOUT%			;Type it, fall through to retry

; Here on recoverable error, retry with new settings
.CRDI1:	DMOVE A,C		;Get flags and pointers back
	JRST .CRDI0		;Go try again

SUBTTL File manipulation routines

; Map over all files in a directory
; Call with B/directory number, returns +3/always
; executes instructions following call:
;	+1/routine to call with files, A/JFN
;	+2/routine to call with directories, B/directory number
; neither instruction should skip

MAPDIR:	POP P,A			;Get return address
	EXCH A,MAPLOC		;Save in standard place and get old value there
	PUSH P,A		;Save in case recursively called
	PUSH P,B		;Save dir number too
	HRROI A,TEMP		;Into temporary storage
	DIRST%			;Get directory name
	 FATAL
	MOVEI A,WLJBLK		;Get wild GTJFN block
	HRROI B,TEMP		;With the string we just built
	GTJFN%			;Get a JFN
	IFNJE.
	  DO.
	    MOVEM A,CURJFN	;Save JFN for ctrl-A routine and NXTJFN
	    HRRZS A		;Don't get confused by flag bits
	    MOVX B,<1,,.FBCTL>	;File flags
	    MOVEI C,C		;Into C
	    GTFDB%		;Get FDB word
	    HRRZ B,A		;Copy JFN for JFNS% taken by either branch
	    HRROI A,TEMP	;Set output into temporary area
	    TXNE C,FB%DIR	;Is it a file (instead of a directory)?
	    IFSKP.
	      PUSH P,C		;Save for callee
	      MOVX C,JS%SPC	;All fields
	      JFNS%		;Make a string for the JFN
	      MOVEI A,GTJBLK	;Point to GTJFN block
	      HRROI B,TEMP	;With string we just made
	      GTJFN%		;Get a new JFN to preserve ours from releasing
	       FATAL
	      POP P,C		;Restore saved .FBCTL word
	      CALL NXTJFN	;Move on to next JFN, save it on stack
	      MOVEM A,CURJFN	;Use appropriate JFN in ^A interrupt
	      PUSH P,A		;Save new JFN
	      XCT @MAPLOC	;Execute instruction following call
	      POP P,A		;Get new JFN back
	      SETZM CURJFN	;Forget current file if not already forgotten
	      RLJFN%		;Flush it
	       ERNOP		;Must have already been flushed
	    ELSE.
	      MOVX C,FLD(.JSAOF,JS%DEV)!FLD(.JSAOF,JS%DIR)!JS%PAF
	      JFNS%		;It's a directory, translate superior to string
	      MOVEI C,"."	;Get a dot
	      DPB C,A		;Drop it in instead of the close bracket
	      MOVX C,FLD(.JSAOF,JS%NAM)
	      JFNS%		;Now add the subdirectory name
	      MOVEI C,">"	;Get a close bracket
	      IDPB C,A		;Drop it in
	      SETZ C,		;Get a null
	      IDPB C,A		;Drop that in too
	      CALL NXTJFN	;Move it on to next JFN, save on stack
	      HRROI B,TEMP	;With name we just built
	      CALL DIRCHK	;Make sure directory exists
	      IFSKP.
		MOVE A,MAPLOC	;Get address following call
		XCT 1(A)	;Execute the +2 instruction
	      ELSE.
		TMSG <% Couldn't get directory number for >
		TYPE TEMP	;Tell user we couldn't do it
		TMSG <
  >
	      ENDIF.
	    ENDIF.
	    POP P,A		;Get JFN back from stack where nxtjfn left it
	    JUMPN A,TOP.	;Maybe go back (above routines do the gnjfn)
	  ENDDO.
	ENDIF.
	MOVE A,MAPLOC		;Get return address
	POP P,B			;Restore saved dir number
	POP P,MAPLOC		;Save old return in case recursive call
	JRST 2(A)		;Return +3

; Do GNJFN on JFN in B, leaving it pushed on the stack

NXTJFN:	PUSH P,A		;Save caller's register
	SETZ B,			;Clear another register
	EXCH B,CURJFN		;Get current JFN back, clear out temporarily
	MOVE A,B		;Copy JFN so we don't lose flags
	GNJFN%			;Move on to next
	 SETZ B,		;None, clear out JFN to return
	POP P,A			;Now safe to restore saved register
	EXCH B,(P)		;Leave new JFN on stack, get return address
	JRST (B)		;And return in this strange way

; Rename a file
; takes arguments just like RNAMF jsys, copies if rename fails
; returns +1/always

.RNAMF:	HRRZS A			;Clear out left halves
	HRRZS B			;In case this is a wildcard jfn
	MOVEM A,OLDJFN		;Save JFN in case RNAMF% fails
	MOVEM B,NEWJFN		;And this so VRBFIL works
	RNAMF%			;Try it the easy way first
	 IFSKP. <JRST VRBFIL>	;Type success notification
	CALL CPFILJ		;Call our special CPYFIL entry point
	MOVE A,OLDJFN		;Get JFN once more
	TXO A,DF%EXP!DF%ARC	;[PJG] Expunging on delete, Allow Archive
	DELF%			;Delete the file
	 CAIN A,DELFX2		;Failed, check if it was merely unexpungable
	  RET			;Succeeded or known error, return
	FATAL <Couldn't delete file> ;Something unexpected, complain

; Copy a file
; A/source JFN, B/destination
; both files must be on disk
; returns +1/always

CPYFIL:	MOVEM A,OLDJFN		;Save where it can be found by subroutines
	MOVEM B,NEWJFN
CPFILJ:	SETZM CURPAG		;Start looking at page 0
	HRRZ A,NEWJFN		;With the JFN for the new file
	MOVX B,OF%WR		;Writing
	OPENF%			;Open the file
	IFJER.
	  TMSG <% Couldn't open >
	  MOVEI A,.PRIOU	;To terminal
	  HRRZ B,NEWJFN		;Get failing JFN
	  SETZ C,		;Normal typeout
	  JFNS%			;Make string for file name
	  JRST ERDASH		;Type dash and error message, then return
	ENDIF.

	;; Try to open the file, thawed or unthawed as necessary
	MOVX B,OF%RD!OF%PDT	;Reading, without updating access dates
	DO.
	  HRRZ A,OLDJFN		;With the file we're copying from
	  OPENF%		;Open the file
	   IFNJE. <EXIT.>	;Success, done
	  TXON  B,OF%THW	;Try thawed mode
	   LOOP.		;Not tried before, go do it
	  CAIN A,OPNX2		;This means permament but delted
	   JRST CPFILN		;Close output file and go copy FDB
	  CAIN A,OPNX31		;If the error is not "file offline"
	   TXNN F,F%PRIV	;Or the user is not privileged
	    JRST OPNERR		;Go complain to the user
	  JRST CPFILN		;Close output file and go copy FDB
	ENDDO.

	;; Make sure output area is completely cleared, get page count
	SETO A,			;From nothingness
	MOVX B,<.FHSLF,,OUTPAG>	;To output area
	MOVX C,PM%CNT!NPAGES	;With appropriate number of pages
	PMAP%			;Map them out
	HRRZ A,OLDJFN		;Get source
	SIZEF%			;Find number of pages
	 FATAL			;Shouldn't bomb
	SKIPN D,C		;Get number of pages
	 JRST CPFILE		;None, don't bother copying them

; File is now open, start copying all its pages.
; Loop here for each set of NPAGES pages in the file.
; D keeps count of how many used pages we still expect to see.
CPFILL:	MOVE A,CURPAG		;Get next page
	HRL A,OLDJFN		;From the source file
	FFUFP%			;Find first used file page
	 JRST CPFILE		;No more???  Then done copying
	HRRZM A,CURPAG		;Save back as current page

	
	;; Have to make sure we aren't trying to map over a page boundary
	MOVE C,A		;Get copy of pointer
	ANDI C,777		;Only keep number within section
	CAIG C,1000-NPAGES	;See if this overflows the section boundary
	IFSKP.
	  HRREI C,-1000(C)	;Does, get neg count of pages left in section
	  MOVNM C,CURNPG	;Save as number to map this time
	ELSE.
	  MVI. NPAGES,CURNPG	;No overflow, just use full buffer size
	ENDIF.

	;; All set, do the map
	MOVX B,<.FHSLF,,CPYPAG> ;Into self at appropriate page
	MOVE C,CURNPG		;Get number of pages for this map
	TXO C,PM%RD!PM%PLD!PM%CNT ;Multiple pages, read access, preloaded
	PMAP%			;Map in file pages

	;; Set of pages mapped in, now BLT them to the output buffer
	MOVN C,CURNPG		;Get negative count of pages
	HRLZS C			;Make AOBJN pointer
	DO.
	  MOVEI A,OUTPAG(C)	;Get destination page addr
	  HRLI A,CPYPAG(C)	;And source page addr
	  LSH A,^D9		;Shift to make pair of addresses
	  MOVEI B,777(A)	;Make last address to copy - can't BLT A,777(A)
	  BLT A,(B)		;Copy words across to buffer
	   IFNJE. <SOJLE D,ENDLP.> ;Count down actual pages found
	  AOBJN C,TOP.		;Back for the next in the set
	ENDDO.

	;; All copied across, now map them out to the file
	MOVX A,<.FHSLF,,OUTPAG>	;From self at output buffer page
	MOVE B,CURPAG		;To current file page
	HRL B,NEWJFN		;Of output file
	MOVE C,CURNPG		;Get number of pages
	TXO C,PM%WR!PM%CNT	;Writing, multiple page map
	PMAP%			;Map pages out to disk, unmap from fork
	MOVE A,CURNPG		;Get number of pages we just used
	ADDM A,CURPAG		;Save next page to use
	JUMPG D,CPFILL		;Done with those pages, back for more

; Here when all file pages have been copied, close input and output files.
CPFILE:	SETOB A,CURPAG		;No page being mapped anymore
	MOVX B,<.FHSLF,,CPYPAG>	;To input area
	MOVX C,PM%CNT!NPAGES	;With appropriate number of pages
	PMAP%			;Map them out
	HRRZ A,OLDJFN		;Get the old file
	TXO A,CO%NRJ		;Without releasing the JFN
	CLOSF%			;Close it
	 FATAL

; Here to close the new file JFN - the old file is already closed.
CPFILN:	HRRZ A,NEWJFN		;Now the new file
	TXO A,CO%NRJ		;Don't want to release JFN
	CLOSF%			;Close it
	 FATAL
;	JRST CPFDB		;go copy FDB

; Copied the file's data, now copy its FDB words

DEFINE CPFDBW (WRD,BITS<-1>) <	;; Copy FDB word from old to new
	HRLI A,WRD		;; At the given offset
	MOVX B,BITS		;; With the bits given, or all possible
	MOVE C,TEMP+WRD		;; With the old word we read into TEMP
	CHFDB%			;; Set them
	 ERNOP			;; Ignore errors
>
DEFINE CPUST (FNC) <		;; Copy author string from old to new
	MOVSI A,FNC		;; Get function in left half
	CALL .CPUST		;; Copy user string
>

CPFDB:	HRRZ A,OLDJFN		;With the old JFN
	HRLZI B,.FBLEN		;All the way through
	MOVEI C,TEMP		;Into temporary storage
	GTFDB%			;Read the file's FDB
	HRRZ A,NEWJFN		;Now into the new file...
	CPFDBW .FBPRT,777777	;Copy flags, file access bits
	CPFDBW .FBCRE		;Copy last-write date
	SETZRO FB%RET,TEMP+.FBBYV ;Clear gen-ret count so file is not deleted
	CPFDBW .FBBYV,FB%RET!FB%BSZ ;Copy gen ret count and byte size
	CPFDBW .FBBYV,<-1-<FB%RET!FB%BSZ>> ;Now rest of file I/O (needs privs)
	CPFDBW .FBSIZ		;Copy number of bytes in file
	CPFDBW .FBCRV		;Copy creation date
	CPFDBW .FBWRT		;Copy last user write date
	CPFDBW .FBREF		;Copy last read date
	CPFDBW .FBCNT		;Copy number of references to file
	CPFDBW .FBBK0		;Copy dumper backup word
	CPFDBW .FBBBT,777777	;Copy archive bits
	CPFDBW .FBNET		;Copy on-line expiration
	CPFDBW .FBUSW		;Copy user-settable word
	CPFDBW .FBTDT		;Copy archive tape-write date
	CPFDBW .FBFET		;Copy offline expiration
	CPFDBW .FBTP1		;Copy archive tape id
	CPFDBW .FBSS1		;Copy save set numbers
	CPFDBW .FBTP2		;Copy tape id for second archive
	CPFDBW .FBSS2		;Copy save set for second archive
	CPUST .GFAUT		;Copy author string
	CPUST .GFLWR		;And last-writer string
 
	HRRZ A,OLDJFN		;Now with the original JFN
	HRROI B,TEMP		;Into temporary storage
	GACTF%			;Get the account string
	 FATAL
	HRROI B,TEMP		;Got a string, get it again (else number in B)
	HRRZ A,NEWJFN		;Into the new file
	SACTF%			;Set the file's account
	 ERNOP			;Couldn't, don't worry
;	JRST CPARCF		;Copy archive files

DEFINE CPARC (BIT,FUNC,BIT2) <
	IFXN. E,BIT		;; If the bit is set
	  HRRZ A,NEWJFN		;; Get the new file
	  MOVEI B,FUNC		;; And the function for the given bit
	  MOVEI C,.ARSET	;; Say to set it
    IFNB <BIT2>,<		;; If we have another bit to check...
	  TXNE E,BIT2		;; See if it is set in the old file
	   TXO C,BIT2		;; It is, set it for ARCF%
    >;Ifnb bit2
	  ARCF%			;; Set the archive
	   ERNOP		;; Ignore errors
	ENDIF.
>

CPARCF:	HRRZ A,OLDJFN		;Get the old JFN
	HRLZI B,.FBLEN		;Maximum FDB length
	MOVEI C,TEMP		;Put it here
	GTFDB%			;Get the FDB information
	 ERNOP			;Ignore the error
	MOVE E,TEMP+.FBBBT	;Get the archived bits
	CPARC (AR%RAR,.ARRAR,AR%NDL) ;User-requested archiving
	CPARC (AR%RIV,.ARRIV)	;Forced migration
	CPARC (AR%EXM,.AREXM)	;Exemption from forced migration
	CPARC (AR%NAR,.ARNAR)	;Resist involuntary migration
	CPARC (AR%RFL,.ARRFL)	;Restore has failed
	MOVE E,TEMP+.FBCTL	;Get the control bits
	IFXN. E,FB%ARC		;Is the file archived?
	  SETZM ARCBLK		;Zero out the archive file argument
	  MOVE A,[ARCBLK,,ARCBLK+1] ;Block used for storage
	  BLT A,ARCBLK+.ARNAR
	  HRRZ A,OLDJFN		;Get the tape information for the old
	  MOVEI B,.ARGST	;File
	  MOVEI C,ARCBLK	;Store it here
	  ARCF%
	   ERNOP
	  LDB J,[POINT 7,TEMP+.FBBBT,17] ;Find out the reason it is offline
	  CAIE J,2		;Is it user requested
	  IFSKP.		;Yes
	    HRRZ A,NEWJFN	;Set up a temporary user request for
	    MOVEI B,.ARRAR	;Archive
	    MOVEI C,.ARSET
	    TXNE E,AR%NDL	;No flush please?
	     TXO C,AR%NDL	;Yes, flag that
	    ARCF%
	     ERNOP
	  ENDIF.
	  CAIE J,3		;Was it migrated
	  IFNSK.		;Yes then set up a temporary migration
	    HRRZ A,NEWJFN
	    MOVEI B,.ARRIV
	    MOVEI C,.ARSET
	    ARCF%
	     ERNOP
	  ENDIF.
	  HRRZ A,NEWJFN		;For the new file
	  MOVEI B,.ARSST	;Set the archiving information
	  MOVEI C,ARCBLK	;From here
	  SETZ E,		;Flags to use
	  MOVE J,TEMP+.FBCTL	;Get the control word for the old FDB
	  TXNE J,FB%OFF		;Was it offline
	   TXO E,AR%OFL		;Yes then make it offline
	  TXO E,AR%O1!AR%O2!AR%ARC!AR%CRQ ;Archive it, store all info, clr reqs
	  MOVEM E,ARCBLK+.AROFL	;Put the flags in the argument block
	  ARCF%			;Set the archiving
	   ERNOP
	ENDIF.			;Done with archiving

;	JRST VRBFIL		;Type verbose file notification

; If verbose switch is on, say what we are doing.  Called from both
; .RNAMF and CPYFIL - they have to cooperate in their use of NEWJFN

VRBFIL:	TXNN F,F%VERB		;Verbose file notification?
	 RET			;No, don't do anything
	TMSG <    >		;Include some space
	MOVEI A,.PRIOU		;To the terminal
	HRRZ B,NEWJFN		;With new JFN
	MOVX C,FLD(.JSAOF,JS%NAM)!FLD(.JSAOF,JS%TYP)!FLD(.JSAOF,JS%GEN)!JS%PAF
	JFNS%			;Type the filename
	TMSG < [OK]
>				;Finish message
	RET

; Here to copy one user name

.CPUST:	HRR A,OLDJFN		; From the original file
	HRROI B,TEMP		; Into temp storage
	GFUST%			; Get the string
	MOVE B,[POINT 7,TEMP]	; Point to the new string
	MOVE C,[POINT 7,ATMBUF] ; And where to put new string
	DO.
	  MOVEI D,.CHCNV	; Get a control-V to quote
	  IDPB D,C		; Drop it in in front of new char
	  ILDB D,B		; Get a byte
	  JUMPE D,ENDLP.	; If null, done
	  IDPB D,C		; Drop it in too
	  LOOP.			; Back for more
	ENDDO.
	DPB D,C			; Drop in null over last ctrl-V
	HRR A,NEWJFN		; Now into the new file
	HRROI B,ATMBUF		; With the string we just got
	SFUST%			; Set the author string
	 ERNOP			; Ignore errors
	RET

; Here when we couldn't open the file to copy it

; If renaming the file might be deleted when the directory is and its bits
; permanently lost.  That is unlikely, though, because someone has it open
; now...  It is probably best to continue on with the copy ignoring it.

OPNERR:	HRRZ A,NEWJFN		;Get new file back
	TXO A,CO%NRJ!CZ%ABT	;Don't want to release JFN but abort output
	CLOSF%			;Close it - no point in keeping open
	 ERNOP
	TMSG <% Couldn't open >
	MOVEI A,.PRIOU		;To the terminal
	HRRZ B,OLDJFN		;With the file we couldn't open
	MOVX C,JS%SPC		;All fields
	JFNS%			;Type file name
	JRST ERDASH		;Type error message, dash, new line, and return

SUBTTL Control-A interrupt routine

STATUS:	CALL PTSTAT		;Print the status
	DEBRK%			;And return from interrupt

PTSTAT:	SKIPN CURJFN		;Do we have a current file?
	 RET			;No, ignore interrupt
	SAVEAC <A,B,C>		;Save used registers
	MOVEI A,.CTTRM		;Controlling tty
	RFPOS%			;Read cursor position
	TRNN B,-1		;Are we at column 1?
	IFSKP.
	  TMSG <
>				;No, print a crlf
	ENDIF.
	HRROI A,[ASCIZ/ Working on /] ;Get normal message
	TXNE F,F%DELF		;If deleting a file
	 HRROI A,[ASCIZ/ Deleting /] ;Then say that instead
	PSOUT%			;Type whichever it was
	CALL PTCURJ		;Print current JFN
	TMSG <
>				;Finish off with a new line
	RET

PTCURJ:	MOVEI A,.PRIOU		;To the terminal
	HRRZ B,CURJFN		;With the current JFN
	MOVX C,JS%SPC		;All fields of the filename
	JFNS%			;Type the file name
	IFNJE.
	  SKIPGE B,CURPAG	;Is there a current page?
	   RET			;No, done
	  TMSG <, page >	;Yes, start more message
	  MOVEI A,.PRIOU	;To the terminal
	  MOVEI C,^D10		;Decimal
	  NOUT%			;Type the number
	   FATAL
	  RET			;All done
	ENDIF.

	TMSG <?JSYS error: >	;Failed, start to say why
	SETZM CURJFN		;Don't type file name again
	JRST .ERSTR		;Go print JSYS error message

SUBTTL Command parsing routines

.COMND:	MOVEI A,CSB		;With the normal command state block
	COMND%			;Parse the FDB given in b
	TXNE A,CM%NOP		;Parsed?
	 RET			;No, give failure return
	RETSKP

CONFRM:	SAVEAC <A,B,C>		;Don't mung caller's registers
	MOVEI B,[FLDDB. .CMCFM]
	CALL .COMND		;Parse carriage return
	IFSKP.
	  TXZN F,F%KOLD		;Confirmed.  did we have to delete some dir?
	   RET			;No, return now
	  MOVE A,NDIRNM		;Else get the number for it
	  SETZM NDIRNM		;No more of that
	  TXO F,F%NSUB		;Killing subdirs
	  TXZ F,F%DLOK		;But not saying so
	  JRST DELCNF		;Delete after confirmation
	ENDIF.
	HRROI A,[ASCIZ/Not confirmed/]
	ESOUT%			;Type message, no atom buffer in case was pswd
	JRST CMDINI

SETCMD:	MOVEM A,CSB+.CMRTY	;Save prompt
	POP P,CSB+.CMFLG	;Save reparse address
	MOVEM P,SAVPDL		;Save the stack pointer
	HRRZS CSB+.CMFLG	;Don't leave any flags
	MOVEI B,[FLDDB. .CMINI]	;FDB to initialize COMND%
	CALL .COMND		;Parse it
	 FATAL <Fatal command initialization error>
REPARS:	MOVE P,SAVPDL		;Restore stack
	HRRZ B,CSB+.CMFLG	;Get reparse address
	JRST (B)		;And jump to it

SUBTTL Error handlers

.FATAL:	CALL PRTERR		;Type error message and JSYS error
	TMSG < at >		;Some text
	MOVEI A,.PRIOU		;To the terminal
	POP P,B			;With our return address
	SUBI B,2		;Back two to the JSYS or call
	HRRZS B			;Flush left-half bits
	MOVEI C,^D8		;Octal radix
	NOUT%			;Type address
	 XFATAL <Couldn't type error location>
	SKIPN CURJFN		;If there's no current file
	 JRST .ERHLT		;Then don't say anything
	TMSG < in >
	CALL PTCURJ		;Print current JFN
	JRST .ERHLT		;Stop the program

.XFATL:	ESOUT%			;Type error message without using ERSTR%
.ERHLT:	HALTF%			;Stop the program
	XFATAL <Can't continue>

.XPMSG:	ESOUT%			;Type error message
	CAIA
.PMSG:	 CALL PRTERR		;Type error message and jsys error
	MOVE A,[POINT 7,ATMBUF]	;Point to atom buffer
	ILDB A,A		;Get the first character there
	JUMPE A,CMDINI		;Nothing, go re-initialize command parser
	TMSG < - ">
	TYPE ATMBUF		;Type out failed parse atom buffer
	TMSG <">
	JRST CMDINI		;All done, go restart parse

PRTERR:	ESOUT%			;Type start of error message
.ERSTR:	MOVEI A,.PRIOU		;To the terminal
	HRLOI B,.FHSLF		;With our last error
	SETZ C,			;No character limit
	ERSTR%			;Type string for jsys error
	 XFATAL <Undefined error number>
	 XFATAL <Error within an error>
	RET

	END <3,,EVEC>
    