;<HELLIWELL>FU.MAC.32, 19-Mar-80 16:18:00, EDIT BY HELLIWELL
TITLE FU - File utility, lots of different special purpose file commands

SEARCH MONSYM,MACSYM
.REQUIRE SYS:MACREL
EXT <JSMSG0,.JBFF>

VGROUP==1
VMAJOR==5
VMINOR==0
VEDIT==26

DEFINE DATE<ASCIZ \19-March-80\>

A=1
B=2
C=3
D=4
E=5

;16 IS USED BY MACSYM

P=17

MAXJFN==^D20		;MAX 20 NESTED TAKES

MAXCHR==^D200

MAXLEN==<MAXCHR+5>/5

ABCHR==^D50

ABLEN==<ABCHR+5>/5

FILCHR==^D40*4+6	;MAX FILESPEC LENGTH

FILLEN==<FILCHR+5>/5

PDLLEN==20

;BIT ASSIGNMENTS FOR DIRECTORY AND NDIRECTORY COMMAND SWITCHES
;ALSO COLUMN WIDTHS
	FILCOL==^D32	;FILESPEC
DI%RD==1B35
DI%WR==1B34
DI%CR==1B33
	DATCOL==^D20	;DATE AND TIME
DI%TAB==1B32
DI%SIZ==1B31
	SIZCOL==^D6	;SIZE
DI%PRO==1B30
	PROCOL==^D8	;PROTECTION
DI%ACC==1B29
	ACCCOL==^D8	;ACCOUNT
DI%ATR==1B28
	ATRCOL==^D16	;ATTRIBUTES
DI%TMP==1B27
	TMPCOL==^D5	;"T"
DI%VER==1B26
DI%DEB==1B25
DI%NFL==1B24
DI%CMA==1B23
DI%NOH==1B22

DEFINE JCERR(TEXT)<
	 ERCAL [JSMSG<TEXT>
		RET]>

DEFINE JSMSG(TEXT)<
	TMSG <
?>
IFNB<TEXT><TMSG <TEXT: >>
	CALL JSMSG0
>

DEFINE FMSG(TEXT,FJFN)<
IFNB<FJFN>,<	HRRZ A,FJFN	>
IFB<FJFN>,<	HRRZ A,OJFN	>
	HRROI B,[ASCIZ \TEXT\]
	SETZ C,
	SOUT
>
SUBTTL	MACROS

;LOAD A BLOCK WITH DATA AND ALLOCATE ENOUGH SPACE
;FOR LARGEST WORD

DEFINE LDBLK(LIST)<
..LEN==0
	IRP LIST,<LDWRD(LIST)>
	RELOC .+..LEN
>

;LOAD 1 WORD CHECK MAX LENGTH

DEFINE LDWRD(A)<.LDWRD(A)>

;USED TO STRIP OFF <>

DEFINE .LDWRD(A,B)<
	RELOC .+A
	IFB<B>,<0;>B
	RELOC .-A-1
IFGE A-..LEN,<..LEN==A+1>
>

;KEYWORD TABLE MACROS

DEFINE TABLE<
	...BEG==.
	BLOCK 1
>

DEFINE TEND<
...LEN==.-...BEG
.ORG ...BEG
	...LEN-1,,...LEN
.ORG .+...LEN
>

DEFINE T(TEXT,VALUE)<	[ASCIZ \TEXT\],,VALUE>

;LOAD A FUNCTION DESCRIPTOR BLOCK
;USE FLDDB. MACRO FROM MONSYM. ARGS AS FOLLOWS:
;FLDDB.(TYP,FLGS,DATA,HLPM,DEFM,LST)
;TYP	COMND FUNCTION CODE (I.E. .CMKEY)
;FLGS	FLAGS (I.E. CM%SDH, SUPPRESS DEFAULT HELP)
;DATA	ARG TO SPECIFIC FUNCTION (I.E. RADIX FOR .CMNUM)
;HLPM	USER SUPPLIED HELP STRING (AUTOMATICALLY SETS CM%HPP)
;DEFM	DEFAULT STRING (AUTOMATICALLY SETS CM%DPP)
;LST	POINTER TO NEXT FUNCTION DESCRIPTOR BLOCK

;DEFINE SINGLE DATA WORD (OR WORDS)

DEFINE DATA(ADDR,SIZE)<
ADDR:	IFB<SIZE>,<BLOCK 1;>BLOCK SIZE
>

DEFINE CONFIRM(ERROR)<
	CALL DOCFM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>


DEFINE NIY<
	TMSG <
?Not implemented yet.
>
	JRST COMLOP
>

DEFINE COMINI(TEXT)<
IFNB<TEXT><HRROI A,[ASCIZ \TEXT\]>
IFB<TEXT><HRROI A,CMBUF>
	CALL DOINI
>

DEFINE FIELD(FDB,ERROR)<
	MOVEI B,FDB
	CALL DOCOM
IFB<ERROR>< JRST COMERR>
IFNB<ERROR>< JRST ERROR>
>

DEFINE RFIELD(FDB)<
	MOVEI B,FDB
	MOVEI A,CMSTAT
	COMND
	 ERJMP ERSCAN
	TXNE A,CM%NOP
	JRST ERSCAN
>

DEFINE JSA(BIT)<FLD(.JSAOF,JS%'BIT)>

DEFINE GETSTR(FIELD)<
	HRROI A,TMPSTR
	MOVE B,IJFN
	MOVE C,[JSA(FIELD)]
	JFNS
	 ERMSG <JFNS failure>
>
SUBTTL	DATA AREA

EV:	JRST STRT
	JRST STRT
JOBVER:	BYTE (3)VGROUP(9)VMAJOR(6)VMINOR(18)VEDIT
EVL==.-EV

PDL:	BLOCK PDLLEN

CMSTAT:	LDBLK(<<.CMFLG,REPARS>,<.CMIOJ,<.PRIIN,,.PRIOU>>,<.CMBFP,<-1,,CMBUF>>,<.CMPTR,<-1,,CMBUF>>,<.CMCNT,MAXCHR>,<.CMINC,0>,<.CMABP,<POINT 7,ABBUF>>,<.CMABC,ABCHR>,<.CMGJB,CMGJFN>>)

CMGJFN:	BLOCK 16

CMBUF:	BLOCK MAXLEN

ABBUF:	BLOCK ABLEN

INIBLK:	FLDDB.(.CMINI)

FILE:	FLDDB.(.CMKEY,,RESKEY)

RESKEY:	TABLE
	T FU,0
	TEND

COMAND:	FLDDB.(.CMKEY,,COMKEY)

COMKEY:	CMKLEN,,CMKLEN+1
	T ALL,ALLPNT
	T DATES,FIXDAT
	T DIRECTORY,DOADIR
	T EXIT,LEAVE
	T FDB,FDBPNT
	T HELP,PNTHLP
	T LONG,LONG
	T NDIRECTORY,DONDIR
	T ODIRECTORY,DODIR
	T SET,DOSET
	T TAKE,DOTAKE
	T TYPE,TYPE
	T VERSION,EXEVER
CMKLEN==.-COMKEY-1

SETOPT:	FLDDB.(.CMKEY,,SETKEY)

SETKEY:	SETLEN,,SETLEN+1
	T AUTHOR,[.GFAUT,,.SFAUT]
	T LAST-WRITER,[.GFLWR,,.SFLWR]
SETLEN==.-SETKEY-1

SETARG:	FLDDB.(.CMTOK,CM%SDH,<-1,,[ASCIZ /*/]>,<"*" For no change>,<*>,SETFLD)

SETFLD:	FLDDB.(.CMFLD,CM%SDH,,<New string value>,,SETQST)

SETQST:	FLDDB.(.CMQST,CM%SDH,,<"New string value">)

DIRFIL:	FLDDB.(.CMFIL,,,,,COMSWT)

DIRCFM:	FLDDB.(.CMCFM,,,,,DIROFL)

DIROFL:	FLDDB.(.CMOFI,,,,,COMSWT)

COMSWT:	FLDDB.(.CMSWI,,TYPSWT)

TYPSWT:	TABLE
	T ACCOUNT,DI%ACC
	T ALL,DI%ACC!DI%ATR!DI%CR!DI%PRO!DI%RD!DI%SIZ!DI%TMP!DI%VER!DI%WR
	T ATTRIBUTES,DI%ATR
	T COMMAS,DI%CMA
	T CREATE,DI%CR
	T DEBUG,DI%DEB
	T NOFILES,DI%NFL
	T NOHEADER,DI%NOH
	T PROTECTION,DI%PRO
	T READ,DI%RD
	T SIZE,DI%SIZ
	T TABS,DI%TAB
	T TEMPORARY,DI%TMP
	T VERSION,DI%VER
	T WRITE,DI%WR
	TEND

HLPFIL:	FLDDB.(.CMFIL,CM%DPP,,,<TTY:>)
HLPBLK:	LDBLK(<<.GJGEN,GJ%FOU>,<.GJEXT,<-1,,[ASCIZ /HLP/]>>,<.GJNAM,[ASCIZ /FU/]>>)
HLPLEN==.-HLPBLK

TAKFIL:	FLDDB.(.CMFIL,,,,,COMCFM)
TAKBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /CMD/]>>,<.GJNAM,[ASCIZ /FU/]>>)
TAKLEN==.-TAKBLK

COMCFM:	FLDDB.(.CMCFM)

OFILE:	FLDDB.(.CMOFI,,,,<TTY:>)

ARBFIL:	FLDDB.(.CMFIL)

IFIBLK:	LDBLK(<<.GJGEN,GJ%OLD!GJ%DEL>>)
IFILEN==.-IFIBLK

ALLBLK:	LDBLK(<<.GJGEN,GJ%OLD!GJ%IFG!.GJALL>,<.GJNAM,<-1,,[ASCIZ /*/]>>,<.GJEXT,<-1,,[ASCIZ /*/]>>>)
ALLLEN==.-ALLBLK

EXEBLK:	LDBLK(<<.GJGEN,GJ%OLD!GJ%IFG>,<.GJNAM,<-1,,[ASCIZ /*/]>>,<.GJEXT,<-1,,[ASCIZ /EXE/]>>>)
EXELEN==.-EXEBLK

DIRBLK:	LDBLK(<<.GJGEN,GJ%OLD!GJ%IFG!.GJALL>,<.GJDEV,<-1,,NULL>>,<.GJDIR,<-1,,NULL>>,<.GJNAM,<-1,,[ASCIZ /*/]>>,<.GJEXT,<-1,,[ASCIZ /*/]>>>)

;SAMPLES OF OTHER BLOCKS
;NOISE:	FLDDB.(.CMNOI,,<-1,,[ASCIZ /NOISE/]>)
;IFILE:	FLDDB.(.CMFIL)
;OFILE:	FLDDB.(.CMFIL)
;FILBLK:	LDBLK(<<.GJGEN,GJ%OLD>,<.GJEXT,<-1,,[ASCIZ /EXT/]>>,<.GJNAM,[ASCIZ /NAME/]>>)
;FILLEN==.-FILBLK

DATA	REPPDL
DATA	REPPC
DATA	SYSCOM
DATA	CMJFNS
DATA	CMJFNP
DATA	JFNSTK,MAXJFN
DATA	IJFN
DATA	OJFN
DATA	FORK
DATA	FILBUF,FILLEN
DATA	FILPTR
DATA	PAGES
DATA	FPAGE
DATA	LPAGE
DATA	NPAGE
DATA	NDIG
DATA	GJFN
DATA	MAPPAG
DATA	MAPADR
DATA	MAPBUF,2000
DATA	VERLOC
DATA	VERSIO
DATA	ALLFLG
DATA	FFPAGE
DATA	PPAGE
DATA	PBUFP
DATA	TRMFLG
DATA	COCWD,2
DATA	STWD
DATA	WHEELF
DATA	DATTXT
DATA	DATIND
DATA	SETSTR,ABLEN
DATA	SETDIS
DATA	SETFLG

;FROM HERE TO "TYP" IS GTJFN BLOCK
JFNBLK:
DATA	GEN
DATA	IO
DATA	DEV
DATA	DIR
DATA	NAM
DATA	TYP,4
DATA	GJF2

DATA	LNTYP
DATA	DEVT
DATA	TGEN
DATA	LDEV
DATA	ODEV
DATA	ODIR
DATA	ONAM
DATA	OTYP
DATA	OGEN
DATA	NULL
DATA	FPTR
DATA	INACC
DATA	NJFN
DATA	IFILEP
DATA	OFILEP
DATA	AFILEP
DATA	STACK
DATA	FLGS
DATA	LEVEL
DATA	NCOL

FILINI:	PUSH P,A
	SETZM CMGJFN
	MOVE A,[CMGJFN,,CMGJFN+1]
	BLT A,CMGJFN+15
	POP P,A
	HRRZ B,A
	HRRI A,CMGJFN
	BLT A,CMGJFN-1(B)
	RET
SUBTTL	STARTUP
STRT:	RESET
	MOVE P,[IOWD PDLLEN,PDL]
	MOVEI A,MAPBUF+777
	TRZ A,777
	MOVEM A,MAPADR
	LSH A,-9
	MOVEM A,MAPPAG
	MOVE A,[-MAXJFN,,JFNSTK-1]
	MOVEM A,CMJFNP
	SETOM SYSCOM
	SETZM CMJFNS
	SETZM TRMFLG
	SETZM IJFN
	SETZM OJFN
	SETZM FORK
	SETZ A,
	RSCAN
	 ERJMP ERSCAN
	JUMPE A,ERSCAN
	COMINI()
	RFIELD(FILE)		;MUST START WITH PROGRAM NAME, OR NO ERRORS
	MOVEI B,COMCFM
	MOVEI A,CMSTAT
	COMND
	 ERJMP REPAR1
	TXNE A,CM%NOP
	JRST REPAR1
;PROGRAM NAME<CR>, MAKE IT LOOK LIKE "R PROGRAM".
ERSCAN:	SETZM SYSCOM
	MOVEI A,.PRIOU
	CALL VERPNT
	TMSG <Type "HELP" for help.
>
COMLOP:	CALL CLEAN
	SKIPE CMJFNS			;DON'T EXIT DURING TAKE
	JRST COMLP1
	SKIPE SYSCOM
	HALTF
	SETZM SYSCOM
COMLP1:	HRROI A,[ASCIZ /FU>/]
	CALL DOINI
	CALL CLEAN
REPAR1:
;SETUP COMMAND DEFAULTS
	FIELD(COMAND,CMEOFC)
	HRRZ B,(B)
	JRST (B)

REPARS:	MOVE P,REPPDL
	MOVE A,REPPC
	MOVEM A,(P)
	RET

DOINI:	MOVEM A,CMSTAT+.CMRTY
	MOVE A,(P)
	MOVEM A,REPPC
	MOVEM P,REPPDL
DOINI1:	SKIPN A,CMJFNS
	MOVE A,[.PRIIN,,.PRIOU]
	MOVEM A,CMSTAT+.CMIOJ
	MOVEI A,CMSTAT
	MOVEI B,INIBLK
	COMND
	 ERJMP FATAL
	TXNN A,CM%NOP
	RET
FATAL:	JSHLT

CMEOFC:	SKIPN CMJFNS
	JRST COMERR
	MOVEI A,.FHSLF
	GETER
	 ERJMP COMERR
	HRRZ B,B
	CAIE B,IOX4
	JRST COMERR
	TMSG <%End of >
	MOVEI A,.PRIOU
	HLRZ B,CMJFNS
	SETZ C,
	JFNS
	 JCERR<>
	TMSG <
>
	CALL TAKFIN
	JRST COMLOP

DOCFM:	MOVEI B,COMCFM
DOCOM:	MOVEI A,CMSTAT
	COMND
	 ERJMP R
	TXNE A,CM%NOP
	RET
	RETSKP

COMDON:	HRRZ A,OJFN
	JUMPE A,COMLOP
	CLOSF
	 JCERR <Failed to close output file>
	JRST COMLOP

COMERR:	CALL ERRET
	JRST COMLOP

ERRET:	CALL ERRDO
	JSMSG <Command error>
	RET

ERRDO:	SKIPN CMJFNS
	RET
	TMSG <%Error reading >
	MOVEI A,.PRIOU
	HLRZ B,CMJFNS
	SETZ C,
	JFNS
	 JCERR<>
	TMSG <, command file input terminated.
>
	CALL TAKFIN
	JRST ERRDO

TAKFIN:	HLRZ A,CMJFNS
	MOVE B,CMJFNP
	POP B,CMJFNS
	MOVEM B,CMJFNP
	CLOSF
	 JCERR <Error closing command file>
	RET

CLEAN:	MOVEI A,.PRIOU
	DMOVE B,COCWD
	SKIPE TRMFLG
	SFCOC
	MOVEI A,.PRIOU
	MOVE B,STWD
	SKIPE TRMFLG
	STPAR
	SETZM TRMFLG
	SKIPE A,FORK
	KFORK
	 JCERR <Failed to kill inferior fork>
	SETZM FORK
	MOVX A,CZ%ABT
	HRR A,IJFN
	TRNE A,-1
	CLOSF
	 JFCL
	SETZM IJFN
	MOVX A,CZ%ABT
	HRR A,OJFN
	TRNE A,-1
	CLOSF
	 JFCL
	SETZM OJFN
	HRROI A,[0]
	RSCAN
	 ERJMP .+1
	MOVX A,CZ%NCL!FLD(.FHSLF,CZ%PRH)
	CLZFF
	 JCERR <Failed to release unopened JFNs>
	RET

VERPNT:	HRROI B,[ASCIZ /FU version /]
	SETZ C,
	SOUT
	LDB B,[POINT 9,JOBVER,11]	;MAJOR
	MOVEI C,10
	NOUT
	 JCERR
	LDB B,[POINT 6,JOBVER,17]	;MINOR
	JUMPE B,NOMINR
	SUBI B,1
	IDIVI B,^D26
	JUMPE B,NOMINF
	MOVEI B,"A"-1(B)
	BOUT
NOMINF:	MOVEI B,"A"(C)
	BOUT
NOMINR:	HRRZ C,JOBVER			;EDIT
	JUMPE C,NOEDIT
	MOVEI B,"("
	BOUT
	MOVE B,C
	MOVEI C,10
	NOUT
	 JCERR
	MOVEI B,")"
	BOUT
NOEDIT:	LDB C,[POINT 3,JOBVER,2]
	JUMPE C,NOGRP
	MOVEI B,"-"
	BOUT
	MOVE B,C
	MOVEI C,10
	NOUT
	 JCERR
NOGRP:	HRROI B,[ASCIZ /, /]
	SETZ C,
	SOUT
	HRROI B,[DATE]
	SOUT
	HRROI B,[ASCIZ /
/]
	SOUT
	RET
SUBTTL	COMMAND HANDLERS
LEAVE:	CONFIRM
	HALTF
	JRST COMLOP

PNTHLP:	MOVE A,[HLPBLK,,HLPLEN]
	CALL FILINI
	FIELD(HLPFIL)
	MOVEM B,OJFN
	CONFIRM
	HRRZ A,OJFN
	MOVX B,<FLD(7,OF%BSZ)!OF%WR>
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	HRRZ A,OJFN
	CALL VERPNT
	HRRZ A,OJFN
	HRROI B,HLPMES
	SETZ C,
	SOUT
	JRST COMDON

HLPMES:	ASCIZ \
This program will reference various file information not easily read
with other commands or programs.

ALL <input filespec> <output filespec>
	Read each existing page of <input filespec> and output to
	<output filespec>. Does not change date of last read.
	All control codes are output as ^<char> except for null (0),
	bell (7), tab (11), line feed (12) and carraige return (15).

DATES <filespec>
	Type dates of last write, create, last read, and (if wheel
	or operator) internal last write. Then accept new values
	for all 3 (or 4) dates. If all dates are entered successfully,
	they are updated to the file. Update may fail if proper access
	is not allowed. In addition to typing new dates, you may type
	<CR> to make no change, and "FIX" to fix date 75 problems.

DIRECTORY <switches> <input filespec> <output filespec>
	Directory command for logical names. If a logical name is referenced,
	it is searched in its entirety. Each file that is found has its'
	associated information printed. The following information is selected
	by switches:

	Switch		Information printed

	ACCOUNT		File account is printed
	ALL		Equivalent to:
				/ACCOUNT
				/ATTRIBUTES
				/CREATE
				/PROTECTION
				/READ
				/SIZE
				/TEMPORARY
				/VERSION
				/WRITE
	ATTRIBUTES	All file attributes are printed
	COMMAS		Separate all fields except filespec with a
			comma and a space.
	CREATE		Creation date is printed
	DEBUG		Print each term of each logical name as it
			is processed. The term is followed by the
			implied filespec so far.
	NOFILES		Suppress output of all file information.
			This means only headers and /DEBUG information
			are output.
	NOHEADER	Suppress output of header information.
	PROTECTION	File protection is printed.
	READ		Last reference date is printed.
	SIZE		Size in pages is printed.
	TABS		Separate all fields (including individual
			fields of filespec) with a single tab.
	TEMPORARY	Indicate temporary files with "T"
	VERSION		For files with the extension 'EXE', print
			the version in standard format.
	WRITE		Last written date is printed.

EXIT
	Exit to EXEC.

FDB <input filespec> <output filespec>
	Print FDB of <input filespec> on <output filespec>.

HELP
	Type this text.

LONG <input filespec> <output filespec>
	Scan all files indicated by <input filespec> (* and % allowed).
	Names of any files with greater than 6 character name or
	3 character extension are listed on <output filespec>.

NDIRECTORY <switches> <input filespec> <output filespec>
	Same as DIRECTORY command except that only files which can not
	be referenced using the fields explicitly specified will be
	printed. For example, the following logical name:

	A: => B:,C:

	and command:

	NDIRECTORY A:FOO.EXE.0

	where FOO.EXE exists in both B: and C: would only print the
	one found in C: because it cannot be referenced using logical
	name A: and generation of 0.

ODIRECTORY <switches> <input filespec> <output filespec>
	Same as DIRECTORY command except that only files which can be
	referenced using the fields explicitly specified will be printed.
	See NDIRECTORY command for example of files which can and can't
	be referenced.

SET AUTHOR <input filespec> <user string>
SET LAST-WRITER <input filespec> <user string>
	Set the indicated attribute of all specified files to <user string>.
	AUTHOR is the field indicating the user who created the file.
	LAST-WRITER is the field indcating the user who last wrote the file.
	The following formats are acceptable for <user string>:

	*		Uses original string for each file (no change).
			This does, however, get and set the old string.

	<field>		A field containing letters, digits or "-".

	"<string>"	Any character other than " may appear in <string>.
			A " may be included as "".

TAKE <filespec>
	Take commands from file. "TAKE" commands may be nested. When EOF
	is reached, the message "%End of filespec." is printed. If you
	Say "TAKE" with no filespec, input is terminated with no message.

TYPE <input filespec> <output filespec>
	Copy <input filespec> to <output filespec>. Disables control
	character conversion (passes all characters directly to
	<output filespec>). This is useful for copying text files
	to terminals.

VERSION <input filespec> <output filespec>
	Scan all files indicated by <input filespec> (* and % allowed).
	For each file with extension 'EXE', map the file and determine
	the version. All files are listed on <output filespec>. Default
	for <input filespec> is *.EXE.

In addition, the program may be given a command on the EXEC command line
as in:

FU command line

If "FU" is successfully parsed, the command will exit upon completion
of the command. If a TAKE is done, the program will not exit until all
take files are completed.
\

DOTAKE:	MOVE A,[TAKBLK,,TAKLEN]
	CALL FILINI
	FIELD(TAKFIL)
	HRRZ C,C
	CAIN C,COMCFM
	JRST DOTAK1
	MOVE D,B
	CONFIRM
	MOVE A,CMJFNP
	AOBJP A,[CALL ERRDO
		TMSG <?Too many nested "TAKE" commands.
>
		JRST COMLOP]
	MOVE A,D
	MOVX B,<FLD(7,OF%BSZ)!OF%RD>
	OPENF
	 ERJMP [JSMSG <Error opening command input file.
>
		JRST COMLOP]
	MOVE A,CMJFNP
	PUSH A,CMJFNS
	MOVEM A,CMJFNP
	HRLI D,.NULIO
	MOVSM D,CMJFNS
	JRST COMLOP

DOTAK1:	SKIPE CMJFNS
	CALL TAKFIN
	JRST COMLOP
;SUBTTL	TYPE, ALLPNT
TYPE:	TDZA A,A
ALLPNT:	SETO A,
	MOVEM A,ALLFLG
	MOVE A,[IFIBLK,,IFILEN]
	CALL FILINI
	MOVX A,GJ%DEL
	SKIPN ALLFLG
	ANDCAM A,CMGJFN+.GJGEN
	FIELD(ARBFIL)
	MOVEM B,IJFN
	FIELD(OFILE)
	MOVEM B,OJFN
	CONFIRM
	HRRZ A,IJFN
	MOVX B,<FLD(7,OF%BSZ)!OF%RD>
	SKIPE ALLFLG
	TXO B,OF%PDT
	OPENF
	 ERJMP [JSMSG <OPENF failed for input file>
		JRST COMLOP]
	HRRZ A,OJFN
	MOVX B,<FLD(7,OF%BSZ)!OF%WR>
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	MOVEI A,.PRIOU
	RFCOC
	DMOVEM B,COCWD		;SAVE CURRENT IN CASE OUR TTY
	RFMOD
	MOVEM B,STWD
	SETOM TRMFLG		;FLAG TERMINAL POSSIBLY CHANGED
	HRRZ A,OJFN
	SKIPN ALLFLG
	SKIPA B,[525252525252]
	MOVE B,[052532553125]	;NOT ^G, TAB, LF, CR, FLUSH NULL
	SKIPN ALLFLG
	SKIPA C,[525252525252]
	MOVE C,[252525652525]	;ALT
	SFCOC
	 ERCAL [MOVEI A,.FHSLF
		GETER
		HRRZ B,B
		CAIN B,DESX6	;IGNORE IF NOT TERMINAL
		RET
		JSMSG <SFCOC failed>
		RET]
	MOVE A,OJFN
	RFMOD
	TXO B,TT%LCA
	STPAR
	 ERCAL [MOVEI A,.FHSLF
		GETER
		HRRZ B,B
		CAIN B,DESX6	;IGNORE IF NOT TERMINAL
		RET
		JSMSG <STPAR failed>
		RET]
	HRLZ A,IJFN
	HRRZ B,.JBFF
	ADDI B,777
	TRZ B,777
	HRLI B,-1
	MOVEM B,PBUFP
	HRRZ B,PBUFP
	LSH B,-9
	HRLI B,400000
	MOVEM B,PPAGE
	SKIPE ALLFLG
	JRST NEXT
TYPLOP:	HRRZ A,IJFN
	MOVE B,PBUFP
	MOVNI C,1000*5
	SIN
	MOVNI C,1000*5(C)
	JUMPE C,DONE1		;DONE IF NO CHARS
	HRRZ A,OJFN
	MOVE B,PBUFP
	SOUT
	JRST TYPLOP

NEXT:	FFUFP
	 JRST DONE1		;DONE ON FAILURE
	MOVEM A,FFPAGE
	MOVE B,PPAGE
	MOVSI C,(PM%RD)
	PMAP
	HRRZ A,OJFN
	MOVE B,PBUFP
	MOVNI C,1000*5
	SOUT
	MOVE A,FFPAGE
	AOJA A,NEXT

DONE1:	MOVNI A,1
	MOVE B,PPAGE
	SETZ C,
	PMAP			;FLUSH PAGE
	JRST COMDON
SUBTTL	FDBPNT
;0 IS FLAG REG
PNTANY==1		;ON IF PRINTED ANY MEANINGS YET
PAGE0==2		;PAGE 0 EXISTS
HEADER==4		;HEADER HAS BEEN PRINTED

;LOCAL AC DEFS
T=13
TT=T+1
TTT=TT+1

FDBLEN==.FBLWR+1

FB%EPH==1B13		;EPHEMERAL BIT IN .FBCTL

FDB:	BLOCK FDBLEN

FDBPNT:	MOVE A,[IFIBLK,,IFILEN]
	CALL FILINI
	FIELD(ARBFIL)
	MOVEM B,IJFN
	FIELD(OFILE)
	MOVEM B,OJFN
	CONFIRM
	HRRZ A,OJFN
	MOVX B,FLD(7,OF%BSZ)!OF%WR
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	HRRZ A,OJFN
	SETO B,
	SETZ C,
	ODTIM
	FMSG<,  Input file: >
	MOVE B,IJFN
	SETZ C,
	JFNS
	FMSG <

>
	SETZ			;INIT FLAGS
	HRRZ A,IJFN
	MOVSI B,FDBLEN
	MOVEI C,FDB
	GTFDB
	MOVE T,FDB+.FBCTL
	TXNE T,FB%NEX!FB%NXF
	JRST PAGSOK		;FILE DOESN'T EXIST
	MOVX B,FLD(44,OF%BSZ)!OF%RD!OF%PDT
	OPENF
	 ERJMP PAGSER
	SETZM PAGES		;NO PAGES IN FILE YET
	HRLZ A,A
	FFUFP
	 ERJMP [CAIE A,FFUFX3
		JRST PAGSER
		FMSG <No pages in file.
>
		JRST PAGDON]
	AOS PAGES
	TRNN A,-1
	TRO PAGE0
	MOVEM A,FPAGE
	ADDI A,1
PAGLP1:	MOVEM A,LPAGE
	FFUFP
	JRST [	CAIE A,FFUFX3
		JRST PAGSER
		TRNN HEADER
		TRNN PAGE0
		CAIA
		JRST PAGDON
		CALL PAGPNT
		FMSG <
>
		JRST PAGDON]
	AOS PAGES
	CAMN A,LPAGE
	AOJA A,PAGLP1
	MOVEM A,NPAGE
	CALL PAGPNT
	MOVE A,NPAGE
	MOVEM A,FPAGE
	AOJA A,PAGLP1

PAGPNT:	TROE HEADER
	JRST PAGPN1
	FMSG <File is sparse, pages are:
>
	JRST PAGPN2

PAGPN1:	FMSG <, >
PAGPN2:	HRRZ T,FPAGE
	CALL OCTOUT
	SOS T,LPAGE
	CAMN T,FPAGE
	RET
	FMSG <->
	HRRZ T,LPAGE
	JRST OCTOUT

PAGSER:	JSMSG <Error scanning pages>
	JRST PAGSOK

PAGDON:	LOAD A,FB%PGC,FDB+.FBBYV
	CAMN A,PAGES
	JRST PAGSOK
	FMSG <File being extended, >
	MOVE T,PAGES
	CALL OCTOUT
	FMSG < (octal) pages in file.
>
PAGSOK:	MOVX A,CO%NRJ
	HRR A,IJFN
	CLOSF
	 JFCL
	FMSG <
Word	Value		Meaning
>
	MOVEI TTT,.FBCTL
	CALL FDBENT
	MOVE T,FDB+.FBCTL
	HRROI A,[ASCIZ/Temporary/]
	TXNE T,FB%TMP
	CALL PNTONE
	HRROI A,[ASCIZ/Permanent/]
	TXNE T,FB%PRM
	CALL PNTONE
	HRROI A,[ASCIZ/No extension (doesn't exist)/]
	TXNE T,FB%NEX
	CALL PNTONE
	HRROI A,[ASCIZ/Deleted/]
	TXNE T,FB%DEL
	CALL PNTONE
	HRROI A,[ASCIZ/File does not exist/]
	TXNE T,FB%NXF
	CALL PNTONE
	HRROI A,[ASCIZ/Long file/]
	TXNE T,FB%LNG
	CALL PNTONE
	HRROI A,[ASCIZ/Compressed page table/]
	TXNE T,FB%SHT
	CALL PNTONE
	HRROI A,[ASCIZ/Directory file/]
	TXNE T,FB%DIR
	CALL PNTONE
	HRROI A,[ASCIZ/No backup/]
	TXNE T,FB%NOD
	CALL PNTONE
	HRROI A,[ASCIZ/File has bad page(s)/]
	TXNE T,FB%BAT
	CALL PNTONE
	HRROI A,[ASCIZ /File is ephemeral/]
	TXNE T,FB%EPH
	CALL PNTONE
	LOAD T,FB%FCF,FDB+.FBCTL
	JUMPE T,NOFILC
	HRROI A,[ASCIZ /File class: /]
	CALL PNTONE
	PUSH P,T
	CALL DECOUT
	POP P,T
	HRROI A,[ASCIZ /(RMS)/]
	CAIN A,.FBRMS
	CALL PNTONE
NOFILC:	MOVEI TTT,.FBADR
	CALL FDBENT
	HRROI A,[ASCIZ /Disk address of index block/]
	CALL PNTONE
	MOVEI TTT,.FBPRT
	CALL FDBENT
	HRROI A,[ASCIZ/Protection/]
	CALL PNTONE
	MOVEI TTT,.FBCRE
	CALL FDBENT
	HRROI A,[ASCIZ/Internal creation: /]
	CALL PNTDTM
	MOVEI TTT,.FBAUT
	CALL FDBENT
	HRROI A,[ASCIZ /Author: /]
	CALL PNTONE
	SKIPN FDB+.FBAUT
	JRST [	FMSG <None>
		JRST NOAUT]
	MOVSI A,.GFAUT
	HRR A,IJFN
	HRROI B,FILBUF
	GFUST
	 ERJMP [FMSG <Unknown>
		JRST NOAUT]
	HRRZ A,OJFN
	HRROI B,FILBUF
	SETZ C,
	SOUT
NOAUT:	MOVEI TTT,.FBGEN
	CALL FDBENT
	HRROI A,[ASCIZ/Generation,,Directory #/]
	CALL PNTONE
	MOVEI TTT,.FBACT
	CALL FDBENT
	HRROI A,[ASCIZ /Account: /]
	CALL PNTONE
	HRRZ A,IJFN
	HRROI B,FILBUF
	GACTF
	 ERJMP [FMSG <Unknown>
		JRST NOACT]
	 JRST [	HRRZ A,OJFN
		HRROI B,FILBUF
		SETZ C,
		SOUT
		JRST NOACT]
	LDB T,[POINT 33,B,35]
	CALL DECOUT
NOACT:	MOVEI TTT,.FBBYV
	CALL FDBENT
	HRROI A,[ASCIZ/Ver ret: /]
	CALL PNTONE
	LOAD T,FB%RET,FDB+.FBBYV
	CALL DECOUT
	HRROI A,[ASCIZ/Byte size: /]
	CALL PNTONE
	LOAD T,FB%BSZ,FDB+.FBBYV
	CALL DECOUT
	HRROI A,[ASCIZ/Mode: /]
	CALL PNTONE
	LOAD T,FB%MOD,FDB+.FBBYV
	CALL OCTOUT
	HRROI A,[ASCIZ/Pages: /]
	CALL PNTONE
	LOAD T,FB%PGC,FDB+.FBBYV
	CALL OCTOUT
	FMSG < (octal)>
	MOVEI TTT,.FBSIZ
	CALL FDBENT
	HRROI A,[ASCIZ/EOF byte count: /]
	CALL PNTONE
	MOVE T,FDB+.FBSIZ
	CALL DECOUT
	FMSG < (decimal)>
	MOVEI TTT,.FBCRV
	CALL FDBENT
	HRROI A,[ASCIZ/Created: /]
	CALL PNTDTM
	MOVEI TTT,.FBWRT
	CALL FDBENT
	HRROI A,[ASCIZ/Last written: /]
	CALL PNTDTM
	MOVEI TTT,.FBREF
	CALL FDBENT
	HRROI A,[ASCIZ/Last accessed: /]
	CALL PNTDTM
	MOVEI TTT,.FBCNT
	CALL FDBENT
	HRROI A,[ASCIZ/# of writes,,# of non-write accesses/]
	CALL PNTONE
	MOVEI TTT,.FBBK0
	CALL FDBENT
	HRROI A,[ASCIZ/Backup system word 0/]
	CALL PNTONE
	MOVEI TTT,.FBBK1
	CALL FDBENT
	HRROI A,[ASCIZ/Backup system word 1/]
	CALL PNTONE
	MOVEI TTT,.FBBK2
	CALL FDBENT
	HRROI A,[ASCIZ/Backup system word 2/]
	CALL PNTONE
IFDEF .FBBK3,<
	MOVEI TTT,.FBBK3
	CALL FDBENT
	HRROI A,[ASCIZ/Backup system word 3/]
	CALL PNTONE
>
IFDEF .FBBK4,<
	MOVEI TTT,.FBBK4
	CALL FDBENT
	HRROI A,[ASCIZ/Backup system word 4/]
	CALL PNTONE
>
	MOVEI TTT,.FBUSW
	CALL FDBENT
	HRROI A,[ASCIZ/User settable word/]
	CALL PNTONE
	MOVEI TTT,.FBLWR
	CALL FDBENT
	HRROI A,[ASCIZ /Last writer: /]
	CALL PNTONE
	SKIPN FDB+.FBLWR
	JRST [	FMSG <None>
		JRST NOLWR]
	MOVSI A,.GFLWR
	HRR A,IJFN
	HRROI B,FILBUF
	GFUST
	 ERJMP [FMSG <Unknown>
		JRST NOLWR]
	HRRZ A,OJFN
	HRROI B,FILBUF
	SETZ C,
	SOUT
NOLWR:	FMSG <
>
	JRST COMDON

FDBENT:	TRZ PNTANY
	FMSG <
>
	MOVE T,TTT
	CALL OCTOUT
	FMSG <	>
	HLRZ T,FDB(TTT)
	CALL OCT6
	FMSG <,,>
	HRRZ T,FDB(TTT)
OCT6:	MOVEI TT,6
	MOVEM TT,NDIG
	JRST OCT0

OCTOUT:	SETZM NDIG
OCT0:	IDIVI T,10
	HRLM TT,(P)
	SOSG NDIG
	JUMPE T,.+2
	CALL OCT0
	HLRZ A,(P)
	MOVEI B,"0"(A)
	HRRZ A,OJFN
	BOUT
	RET

DECOUT:	IDIVI T,^D10
	HRLM TT,(P)
	JUMPE T,.+2
	CALL DECOUT
	HLRZ A,(P)
	MOVEI B,"0"(A)
	HRRZ A,OJFN
	BOUT
	RET

PNTONE:	PUSH P,A
	HRRZ A,OJFN
	HRROI B,[ASCIZ/, /]
	TRON PNTANY
	HRROI B,[ASCIZ/	/]
	SETZ C,
	SOUT
	POP P,B
	SOUT
	RET

PNTDTM:	CALL PNTONE
	SKIPN B,FDB(TTT)
	JRST [	FMSG <Never>
		RET]
	HRRZ A,OJFN
	MOVX C,OT%DAY!OT%NCO!OT%SCL
	ODTIM
	RET
SUBTTL	LONG
LONG:	MOVE A,[ALLBLK,,ALLLEN]
	CALL FILINI
	MOVX A,GJ%DEL
	IORM A,CMGJFN+.GJGEN	;ALLOW DELETED FILES
	FIELD(ARBFIL)
	MOVEM B,IJFN
	FIELD(OFILE)
	MOVEM B,OJFN
	CONFIRM
	HRRZ A,OJFN
	MOVX B,FLD(7,OF%BSZ)!OF%WR
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	HRRZ A,OJFN
	SETO B,
	SETZ C,
	ODTIM
	FMSG<,  Filespec: >
	MOVE B,IJFN
	MOVX C,JSA(DEV)!JSA(DIR)!JSA(NAM)!JSA(TYP)!JS%PAF
	JFNS
	FMSG <

>
LOOP:	MOVX C,JSA(NAM)
	MOVEI D,6
	CALL CHKNAM
	 JRST PRINT
	MOVX C,JSA(TYP)
	MOVEI D,3
	CALL CHKNAM
	 JRST PRINT
LOOP1:	MOVE A,IJFN
	GNJFN
	 ERJMP DONE
	JRST LOOP

PRINT:	HRRZ A,OJFN
	HRRZ B,IJFN
	SETZ C,
	JFNS
	 JCERR <JFNS failure>
	TMSG <
>
	JRST LOOP1

DONE:	CAIN A,GNJFX1
	JRST COMDON
	JSMSG <Error from GNJFN>
	JRST COMDON

CHKNAM:	MOVE A,[POINT 7,FILBUF]
	HRRZ B,IJFN
	JFNS
	 JCERR <JFNS failure>
	LDB B,[POINT 6,A,5]
	SUBI B,44
	IDIV B,[-7]
	SUBI A,FILBUF
	IMULI A,5
	ADDI A,(B)
	CAIL D,(A)
	RETSKP
	RET
SUBTTL	EXEVER

CHKARG:	LDBLK(<<.CKAAC,.CKARD>,<.CKALD,0>,<.CKACD,0>,<.CKAEC,0>,<.CKAUD,0>>)
CHKLEN==.-CHKARG

EXTERN .JBVER

EXEVER:	MOVE A,[EXEBLK,,EXELEN]
	CALL FILINI
	FIELD(ARBFIL)
	MOVEM B,IJFN
	FIELD(OFILE)
	MOVEM B,OJFN
	CONFIRM
	HRRZ A,OJFN
	MOVX B,FLD(7,OF%BSZ)!OF%WR
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	HRRZ A,OJFN
	SETO B,
	SETZ C,
	ODTIM
	FMSG<,  Filespec: >
	MOVE B,IJFN
	MOVX C,JSA(DEV)!JSA(DIR)!JSA(NAM)!JSA(TYP)!JS%PAF
	JFNS
	FMSG <

Filespec		Last write		Version
>
	CALL CHKSET
ELOOP:	FMSG <  >
	HRRZ B,IJFN
	MOVX C,JSA(DEV)!JSA(DIR)!JS%PAF
	JFNS
	 JCERR <JFNS failed>
	FMSG <
>
ELOOPN:	SETOM GJFN
	HRROI A,FILBUF
	HRRZ B,IJFN
	MOVX C,JSA(NAM)!JSA(TYP)!JSA(GEN)!JS%PAF
	JFNS
	 JCERR <JFNS failed>
	HRRZ A,OJFN
	HRROI B,FILBUF
	MOVEI C,FILCHR
	SETZ D,
	SOUT
	SUBI C,FILCHR-^D24-1
	CAIGE C,2
	MOVEI C,2		;AT LEAST 2 SPACES
	MOVEI B,40
LOOP3:	BOUT
	SOJG C,LOOP3
	HRRZ A,OJFN
	HRRZ B,IJFN
	MOVX C,JS%LWR
	JFNS
	 JCERR <JFNS failed>
	MOVE A,IJFN
	CALL GPVER		;GET AND PRINT VERSION
	 JRST LOOP4		;NONE
	FMSG <	>
	HRRZ A,OJFN
	HRROI B,FILBUF
	SETZ C,
	SOUT
LOOP4:	FMSG <
>
	MOVE A,IJFN
	GNJFN
	 ERJMP EDONE
	TXNE A,GN%STR!GN%DIR
	JRST ELOOP
	JRST ELOOPN

EDONE:	CAIN A,GNJFX1
	JRST COMDON
	JSMSG <Error from GNJFN>
	JRST COMDON

OCTPNT:	MOVE B,A
	MOVE A,FILPTR
	MOVEI C,10
	NOUT
	 JCERR <NOUT failure>
	MOVEM A,FILPTR
	RET

CHKSET:	MOVNI A,1
	HRROI B,C
	MOVEI C,.JIUNO
	GETJI
	 JCERR <GETJI failure>
	MOVEM C,CHKARG+.CKALD
	HRROI B,C
	MOVEI C,.JIDNO
	GETJI
	 JCERR <GETJI failure>
	MOVEM C,CHKARG+.CKACD
	MOVX A,.FHSLF
	RPCAP
	MOVEM C,CHKARG+.CKAEC
	SETZ A,
	CFORK
	 ERJMP [JSMSG <CFORK failed>
		JRST COMLOP]
	MOVEM A,FORK
	RET

GPVER:	MOVEM A,GJFN
	HRROI A,FILBUF
	MOVEM A,FILPTR
	HRRZ B,GJFN
	MOVX C,JSA(TYP)
	JFNS
	 JCERR <JFNS failed>
	MOVE A,FILBUF
	TRZ A,377
	CAME A,[ASCII /EXE/]
	RET
	HRROI A,FILBUF
	HRRZ B,GJFN
	MOVX C,JSA(DEV)!JSA(DIR)!JSA(NAM)!JSA(TYP)!JSA(GEN)!JS%PAF
	JFNS
	 JCERR <JFNS failed>
	MOVX A,GJ%OLD!GJ%SHT
	HRROI B,FILBUF
	SETZM GJFN
	GTJFN
	 JRST VERERR
	MOVEM A,GJFN
	MOVEM A,CHKARG+.CKAUD
	MOVX A,CK%JFN+CHKLEN
	MOVEI B,CHKARG
	CHKAC
	 JCERR <CHKAC failure>
	JUMPE A,[FMSG <Read access not allowed>
		JRST GPVER1]
	MOVE A,GJFN
	HRL A,FORK
	GET
	 ERJMP VERERR
	MOVE A,FORK
	GEVEC
	 ERJMP VERERR
	HLRZ A,B
	CAIGE A,3
	JRST NOVER
	CAIN A,(JRST)
	SKIPA A,[.JBVER]
	MOVEI A,2(B)
	MOVEM A,VERLOC
	LSH A,-11
	HRL A,FORK
	MOVE B,MAPPAG
	HRLI B,.FHSLF
	MOVX C,PM%RD
	PMAP
	 ERJMP VERERR
	MOVE A,VERLOC
	ANDI A,777
	ADD A,MAPADR
	MOVE A,(A)
	 ERJMP VERERR
	JUMPE A,NOVER
	MOVEM A,VERSIO
	LDB A,[POINT 9,VERSIO,11]	;GET MAJOR VERSION
	SKIPE A
	CALL OCTPNT
	LDB A,[POINT 6,VERSIO,17]	;GET MINOR VERSION
	JUMPE A,VERSI1		;SKIP IF 0
	SUBI A,1
	IDIVI A,^D26		;MAKE 2 LETTERS
	JUMPE A,VERSI2
	PUSH P,B
	MOVEI B,"A"-1(A)
	MOVE A,FILPTR
	BOUT
	MOVEM A,FILPTR
	POP P,B
VERSI2:	ADDI B,"A"
	MOVE A,FILPTR
	BOUT
	MOVEM A,FILPTR
VERSI1:	HRRZ A,VERSIO		;GET EDIT NUMBER
	JUMPE A,VERSI3
	MOVE A,FILPTR
	MOVEI B,"("
	BOUT
	MOVEM A,FILPTR
	HRRZ A,VERSIO
	CALL OCTPNT
	MOVE A,FILPTR
	MOVEI B,")"
	BOUT
	MOVEM A,FILPTR
VERSI3:	LDB A,[POINT 3,VERSIO,2]	;GET GROUP CODE
	JUMPE A,GPVER1
	PUSH P,A
	MOVE A,FILPTR
	MOVEI B,"-"
	BOUT
	MOVEM A,FILPTR
	POP P,A
	CALL OCTPNT
GPVER1:	MOVE A,FILPTR
	SETZ C,
	SOUT
	MOVEM A,FILPTR
	SETO A,
	HRLZ B,FORK
	MOVE C,[PM%CNT+1000]
	PMAP
	 JCERR <PMAP failure>
	SETO A,
	MOVE B,MAPPAG
	HRLI B,.FHSLF
	SETZ C,
	PMAP
	 JCERR <PMAP failure>
	SKIPG A,GJFN
	RETSKP
	GTSTS			;GET ITS STATUS
	TXNN B,GS%NAM
	RETSKP
	HRRZ A,A
	TXNN B,GS%OPN		;IS IT OPEN?
	JRST [	RLJFN		;NO, RELEASE IT
		 JCERR <RLJFN failure>
		RETSKP]
	CLOSF			;YES, CLOSE AND RELEASE
	 JCERR <CLOSF failure>
	RETSKP

NOVER:	HRROI B,[ASCIZ /No version/]
GPVERE:	MOVE A,FILPTR
	SETZ C,
	SOUT
	MOVEM A,FILPTR
	JRST GPVER1

VERERR:	MOVE A,FILPTR
	HRLOI B,.FHSLF
	SETZ C,
	ERSTR
	 JRST [	HRROI B,[ASCIZ /ERSTR: Undefined error number./]
		JRST GPVERE]
	 JRST [	HRROI B,[ASCIZ /ERSTR: Internal confusion./]
		JRST GPVERE]
	MOVEM A,FILPTR
	JRST GPVER1

SUBTTL	FIXDAT

;INSTR TO EXECUTE IF CONFIRM PARSED
	JRST NOCHNG
NDATE:	FLDDB.(.CMCFM,CM%SDH,,<<CR> for no change>,,FIXCOM)

;INSTR TO EXECUTE IF "FIX" PARSED
	JRST DOFIX
FIXCOM:	FLDDB.(.CMKEY,CM%SDH,FIXKEY,<FIX to fix date 75 problem>,,DATCOM)

;INSTR TO EXECUTE IF DATE PARSED
	JRST NEWDAT
DATCOM:	FLDDB.(.CMTAD,,CM%IDA!CM%ITM)

FIXKEY:	FIXLEN,,FIXLEN+1
	[ASCIZ /FIX/],,0
FIXLEN==.-FIXKEY-1

DATLEN==0

IFG .RSWRT-DATLEN,<DATLEN==.RSWRT>
IFG .RSCRV-DATLEN,<DATLEN==.RSCRV>
IFG .RSREF-DATLEN,<DATLEN==.RSREF>
IFG .RSCRE-DATLEN,<DATLEN==.RSCRE>
DATLEN==DATLEN+1

DATES:	BLOCK DATLEN

FIXDAT:	MOVE A,[IFIBLK,,IFILEN]
	CALL FILINI
	FIELD(ARBFIL)
	MOVEM B,IJFN
	CONFIRM
	SETZM WHEELF
	MOVEI A,.FHSLF
	RPCAP
	TDNE C,[SC%WHL!SC%OPR]
	SETOM WHEELF
	HRRZ A,IJFN
	MOVEI B,DATES
	MOVEI C,DATLEN
	RFTAD
	 ERJMP [JSMSG <RFTAD failed>
		JRST COMLOP]
	HRROI A,[ASCIZ /Last written: /]
	MOVEI B,DATES+.RSWRT
	CALL PNTDAT
	HRROI A,[ASCIZ /Created: /]
	MOVEI B,DATES+.RSCRV
	CALL PNTDAT
	HRROI A,[ASCIZ /Last read: /]
	MOVEI B,DATES+.RSREF
	CALL PNTDAT
	HRROI A,[ASCIZ /Internal write date: /]
	MOVEI B,DATES+.RSCRE
	SKIPE WHEELF
	CALL PNTDAT
	HRROI A,[ASCIZ /New last written: /]
	MOVEI B,DATES+.RSWRT
	CALL CHGDAT
	HRROI A,[ASCIZ /New created: /]
	MOVEI B,DATES+.RSCRV
	CALL CHGDAT
	HRROI A,[ASCIZ /New last read: /]
	MOVEI B,DATES+.RSREF
	CALL CHGDAT
	HRROI A,[ASCIZ /New internal write date: /]
	MOVEI B,DATES+.RSCRE
	SKIPE WHEELF
	CALL CHGDAT
	SKIPN WHEELF
	SETOM DATES+.RSCRE
	HRRZ A,IJFN
	MOVEI B,DATES
	MOVEI C,DATLEN
	SFTAD
	 ERJMP [JSMSG <SFTAD failed>
		JRST COMLOP]
	JRST COMLOP

PNTDAT:	PSOUT
	MOVEI A,.PRIOU
	MOVE B,(B)
	SETZ C,
	ODTIM
	TMSG <
>
	RET

CHGERR:	JSMSG <Command error>
	JRST CHGDA1

CHGDAT:	MOVEM A,DATTXT
	MOVEM B,DATIND
CHGDA1:	MOVE A,DATTXT
	CALL DOINI
	FIELD(NDATE,CHGERR)
	XCT -1(C)		;DISPATCH BY FDB USED

;NO CHANGE
NOCHNG:	SETOM @DATIND
	RET

;GOT DATE
NEWDAT:	MOVE D,B
	CONFIRM(CHGERR)
	MOVEM D,@DATIND
	RET

;"FIX" TYPED
DOFIX:	CONFIRM(CHGERR)
	HRROI A,[ASCIZ /05-JAN-75 0000/]
	SETZ B,
	IDTIM
	 ERJMP [JSMSG <IDTIM failed on "05-JAN-75 0000">
		JRST CHGDA1]
	CAMLE B,@DATIND
	JRST FIXIT
	TMSG <?Current date is after 05-JAN-75, will not fix.
>
	JRST CHGDA1

FIXIT:	HLLZ C,B			;SAVE THIS DATE
	HRROI A,[ASCIZ /01-JAN-64 0000/]
	SETZ B,
	IDTIM
	 ERJMP [JSMSG <IDTIM failed on "01-JAN-64 0000">
		JRST CHGDA1]
	CAMG B,@DATIND
	JRST FIXIT1
	TMSG <?Current date is before 01-JAN-64, will not fix.
>
	JRST CHGDA1

FIXIT1:	HLLZ B,B
	SUB C,B
	ADDM C,@DATIND
	MOVE B,DATIND
	HRROI A,[ASCIZ /Fixed to: /]
	JRST PNTDAT
SUBTTL	DIRECTORY, NDIRECTORY

;DEFINE STACK ENTRIES

..TMP==0

DEFINE $ALLOC(NAME)<
$'NAME==..TMP
..TMP==..TMP+1
>

$ALLOC(LINK)
$ALLOC(DEV)
$ALLOC(DEVT)
$ALLOC(DIR)
$ALLOC(NAM)
$ALLOC(TYP)
$ALLOC(GEN)
$ALLOC(PTR)
$ALLOC(LEN)

DEFINE GSTR(FIELD,PTR)<
	MOVE D,[[JSA(FIELD)],,PTR]
	CALL GFIELD
>

DEFINE GGEN(ADR)<
	CALL GENCON
	HRRM A,ADR
>

DODIR:	SETZM INACC
	JRST DODIRS

DOADIR:	MOVEI A,1
	MOVEM A,INACC
	JRST DODIRS

DONDIR:	SETOM INACC
DODIRS:	SETZM FLGS
	SETZM FILBUF
DODIR1:	SKIPE FILBUF			;GOT FILESPEC YET?
	JRST DODIR3
	MOVE A,[ALLBLK,,ALLLEN]
	CALL FILINI
	FIELD(DIRFIL)			;FILE OR SWITCHES
	HRRZ C,C
	CAIE C,DIRFIL
	JRST DODIR4
	MOVE D,B
	HRROI A,FILBUF
	HRROI B,ABBUF
	SETZ C,
	SOUT
	AOS FILBUF			;MAKE SURE NON-ZERO IN CASE NULL STRING
	MOVE A,D
	RLJFN
	 JFCL
	JRST DODIR1

DODIR3:	FIELD(DIRCFM)
	HRRZ C,C
	CAIN C,DIROFL
	JRST DODIR2
	CAIN C,DIRCFM
	JRST DODIR5
DODIR4:	HRRZ B,(B)
	IORM B,FLGS
	JRST DODIR1

DODIR2:	MOVEM B,OJFN
	CONFIRM
DODIR5:	MOVEI A,.PRIOU
	SKIPN OJFN		;ANY OUTPUT SPEC?
	MOVEM A,OJFN		;NO, USE PRIMARY OUTPUT
	CALL CHKSET		;IN CASE /VERSION
	SETOM LEVEL
	SETZM STACK
	MOVE A,.JBFF
	HRLI A,(<POINT 7,0>)
	MOVEM A,FPTR
	MOVE A,[.NULIO,,.NULIO]
	MOVEM A,IO
	MOVX A,GJ%XTN!GJ%OFG!GJ%CFM!GJ%FNS+.GJALL
	MOVEM A,JFNBLK
	MOVX A,G1%SLN
	MOVEM A,GJF2
	MOVE A,[-1,,NULL]
	MOVEM A,DEV
	MOVEM A,DIR
	HRROI A,[ASCIZ /*/]
	MOVEM A,NAM
	MOVEM A,TYP
	MOVEI A,JFNBLK
	HRROI B,FILBUF
	GTJFN
	 ERJMP [JSMSG <GTJFN failed on input filespec>
		JRST COMLOP]
	MOVEM A,IJFN
	GSTR(DEV,ODEV)
	GSTR(DIR,ODIR)
	GSTR(NAM,ONAM)
	GSTR(TYP,OTYP)
	GGEN(OGEN)
	HRRZ A,OJFN
	MOVX B,FLD(7,OF%BSZ)!OF%WR
	OPENF
	 ERJMP [JSMSG <OPENF failed for output file>
		JRST COMLOP]
	MOVE E,FLGS
	TXNE E,DI%NOH
	JRST PLOOP		;NO HEADERS
	HRRZ A,OJFN
	SETO B,
	SETZ C,
	ODTIM
	FMSG<,  Filespec: >
	MOVE B,IJFN
	MOVX C,JSA(DEV)!JSA(DIR)!JSA(NAM)!JSA(TYP)!JSA(GEN)!JS%PAF
	JFNS
	 JCERR <JFNS failed on input filespec at NONDIR>
	FMSG <

>
	HRROI B,[ASCIZ /Filespec/]
	MOVEI D,FILCOL
	CALL FOCOL
	HRROI B,[ASCIZ /Temp/]
	MOVEI D,TMPCOL
	TXNE E,DI%TMP
	CALL OCOL
	HRROI B,[ASCIZ /Prot./]
	MOVEI D,PROCOL
	TXNE E,DI%PRO
	CALL OCOL
	HRROI B,[ASCIZ /Account/]
	MOVEI D,ACCCOL
	TXNE E,DI%ACC
	CALL OCOL
	HRROI B,[ASCIZ /Size/]
	MOVEI D,SIZCOL
	TXNE E,DI%SIZ
	CALL OCOL
	HRROI B,[ASCIZ /Read date-time/]
	MOVEI D,DATCOL
	TXNE E,DI%RD
	CALL OCOL
	HRROI B,[ASCIZ /Write date-time/]
	MOVEI D,DATCOL
	TXNE E,DI%WR
	CALL OCOL
	HRROI B,[ASCIZ /Create date-time/]
	MOVEI D,DATCOL
	TXNE E,DI%CR
	CALL OCOL
	HRROI B,[ASCIZ /Attributes/]
	MOVEI D,ATRCOL
	TXNE E,DI%ATR
	CALL OCOL
	HRROI B,[ASCIZ /Version/]
	TXNE E,DI%VER
	CALL OCOL
	FMSG <

>
PLOOP:	GSTR(DEV,DEV)
	GSTR(DIR,DIR)
	GSTR(NAM,NAM)
	GSTR(TYP,TYP)
	GGEN(GEN)
	HRRZ A,IJFN
	RLJFN
	 JCERR <RLJFN failure at PLOOP>
	MOVE C,FPTR
	MOVEM C,LDEV
	MOVEI A,.LNSJB
	CALL LNCHK
	 JRST NGLOG
	JRST GOTLOG

NGLOG:	MOVEI A,.LNSSY
	CALL LNCHK
	 JRST GOTPHY
GOTLOG:	HRROI A,NULL
	SKIPN DIR
	MOVEM A,DIR
	SKIPN NAM
	MOVEM A,NAM
	SKIPN TYP
	MOVEM A,TYP
	MOVE B,FPTR
	MOVEI B,1(B)
	MOVE A,DEV
	MOVEM A,$DEV(B)
	MOVE A,DEVT
	MOVEM A,$DEVT(B)
	MOVE A,DIR
	MOVEM A,$DIR(B)
	MOVE A,NAM
	MOVEM A,$NAM(B)
	MOVE A,TYP
	MOVEM A,$TYP(B)
	MOVE A,GEN
	MOVEM A,$GEN(B)
	MOVE A,LDEV
	MOVEM A,$PTR(B)
	MOVE A,STACK
	MOVEM A,$LINK(B)
	MOVEM B,STACK
	ADD B,[POINT 7,$LEN]
	MOVEM B,FPTR
	AOS LEVEL
SLOOP:	MOVSI A,(GJ%OFG!GJ%XTN)
	HLLM A,JFNBLK
	MOVEI A,JFNBLK
	MOVE B,STACK
	MOVE B,$PTR(B)
	GTJFN
	 ERJMP [TMSG <Cannot parse remainder of logical name:
>
		MOVE A,STACK
		MOVE A,$PTR(A)
		PSOUT
		JSMSG <>
		JRST SLOOP1]
	MOVEM A,IJFN
	LDB A,B
	SKIPN A
	SETZ B,
	MOVE A,STACK
	MOVE D,$PTR(A)
	MOVEM B,$PTR(A)
	MOVE A,FLGS
	TXNN A,DI%DEB
	JRST PLOOP
	HRRZ A,OJFN
	MOVEI B,11
	SKIPA C,LEVEL
	BOUT
	SOJGE C,.-1
	MOVE A,STACK
	LDB B,$PTR(A)		;SAVE TERMINATOR
	SETZ C,
	DPB C,$PTR(A)		;MAKE IT NULL
	EXCH B,D		;PUT CHAR IN D, POINTER IN B
	HRRZ A,OJFN
	SOUT
	MOVE B,STACK
	DPB D,$PTR(B)
	HRROI B,[ASCIZ / => /]
	SOUT
	MOVE B,IJFN
	MOVX C,JSA(DEV)+JSA(DIR)+JSA(NAM)+JSA(TYP)+JSA(GEN)+JS%PAF
	JFNS
	FMSG <
>
	JRST PLOOP

GOTPHY:	MOVSI A,(GJ%IFG!GJ%OLD!GJ%NS!GJ%PHY)
	HLLM A,JFNBLK
	MOVEI A,JFNBLK
	SETZ B,
	GTJFN
	 JRST STEP
	MOVEM A,IJFN
	MOVE A,FPTR
	MOVEM A,LDEV		;SAVE FREE POINTER TO RECLAIM
	MOVSI A,(GJ%OLD)
	HLLM A,JFNBLK
	MOVE A,ODEV
	MOVEM A,DEV
	SETZM DIR
	SETZM NAM
	SETZM TYP
	HLLZS GEN
CLOOP:	SETZM NJFN
	MOVE A,FPTR
	MOVEM A,IFILEP
	SKIPLE INACC		;IF POSITIVE
	JRST ISGOOD		;ALWAYS PRINT
	HRRZ B,IJFN
	MOVX C,JSA(DEV)+JSA(DIR)+JSA(NAM)+JSA(TYP)+JSA(GEN)+JS%PAF
	JFNS
	 JCERR <JFNS failure on entire filespec at CLOOP>
	IBP A
	MOVEM A,OFILEP
	HRRZ B,IJFN
	MOVX C,JS%PAF
	SKIPE ODIR
	TXO C,JSA(DIR)
	SKIPE ONAM
	TXO C,JSA(NAM)
	SKIPE OTYP
	TXO C,JSA(TYP)
	SKIPE OGEN
	TXO C,JSA(GEN)
	JFNS
	 JCERR <JFNS failure on selected fields at CLOOP>
	IBP A
	MOVEM A,FPTR
	MOVEI A,JFNBLK
	MOVE B,OFILEP
	GTJFN
	 ERJMP [TMSG <Error on: >
		MOVE A,OFILEP
		PSOUT
		JSMSG <GTJFN failure at CLOOP>
		JRST NOMAT]
	MOVEM A,NJFN
	MOVE A,FPTR
	MOVEM A,AFILEP
	HRRZ B,NJFN
	MOVX C,JSA(DEV)+JSA(DIR)+JSA(NAM)+JSA(TYP)+JSA(GEN)+JS%PAF
	JFNS
	 JCERR <JFNS failure on actual file at CLOOP>
	IBP A
	MOVEM A,FPTR
	MOVE A,IFILEP
	MOVE B,AFILEP
	STCMP
	JUMPN A,NOMAT
	SKIPE INACC
	JRST NOGOOD
	JRST ISGOOD

NOMAT:	SKIPN INACC
	JRST NOGOOD
ISGOOD:	MOVE E,FLGS
	TXNE E,DI%NFL
	JRST NOGOOD		;NO OUTPUT FOR /NOFILES
	MOVX C,<JSA(DEV)!JSA(DIR)!JSA(NAM)!JSA(TYP)!JSA(GEN)>
	TXNN E,DI%TAB
	TXOA C,JS%PAF
	TXO C,JS%TBR
	MOVEI D,FILCOL
	CALL FCOL
	MOVEI D,TMPCOL
	MOVX C,JS%TMP
	TXNE E,DI%TMP
	CALL COLUMN
	MOVEI D,PROCOL
	MOVX C,JS%PRO
	TXNE E,DI%PRO
	CALL COLUMN
	MOVEI D,ACCCOL
	MOVX C,JS%ACT
	TXNE E,DI%ACC
	CALL COLUMN
	MOVEI D,SIZCOL
	MOVX C,JS%SIZ
	TXNE E,DI%SIZ
	CALL COLUMN
	MOVX C,JS%LRD
	MOVEI D,DATCOL
	TXNE E,DI%RD
	CALL COLUMN
	MOVEI D,DATCOL
	MOVX C,JS%LWR
	TXNE E,DI%WR
	CALL COLUMN
	MOVEI D,DATCOL
	MOVX C,JS%CDR
	TXNE E,DI%CR
	CALL COLUMN
	MOVEI D,ATRCOL
	MOVX C,JS%ATR
	TXNE E,DI%ATR
	CALL COLUMN
	TXNN E,DI%VER
	JRST NOPVER
	MOVE A,IJFN
	CALL GPVER
	 JRST NOPVER
	CALL FILL
	HRRZ A,OJFN
	HRROI B,FILBUF
	SETZ C,
	SOUT
NOPVER:	FMSG <
>
NOGOOD:	HRRZ A,NJFN
	JUMPE A,NOGOO1
	RLJFN
	 JCERR <RLJFN failure on NJFN at NOGOOD>
NOGOO1:	MOVE A,IFILEP
	MOVEM A,FPTR
	MOVE A,IJFN
	GNJFN
	 CAIA
	JRST CLOOP
	MOVEI A,.FHSLF
	GETER
	 JCERR <GETER failure at NOGOOD>
	HRRZ B,B
	CAIN B,GNJFX1
	JRST GNDONE
	JSMSG <Abnormal termination of GNJFN at NOGOOD>
	HRRZ A,IJFN
	RLJFN
	 JCERR <RLJFN failure on IJFN at NOGOOD>
GNDONE:	MOVE A,LDEV		;RESTORE FREE POINTER
	MOVEM A,FPTR
STEP:	SKIPN A,STACK
	JRST COMDON
	MOVE B,$PTR(A)
	MOVEM B,LDEV
	MOVE B,$GEN(A)
	MOVEM B,GEN
	MOVE B,$TYP(A)
	MOVEM B,TYP
	MOVE B,$NAM(A)
	MOVEM B,NAM
	MOVE B,$DIR(A)
	MOVEM B,DIR
	SKIPE LDEV
	JRST SLOOP
SLOOP1:	MOVE A,$LINK(A)
	MOVEM A,STACK
	SOS LEVEL
	JRST STEP

COLUMN:	CALL FILL
FCOL:	HRROI A,FILBUF
	HRRZ B,IJFN
	JFNS
	 JCERR <JFNS failure on input file at COLUMN>
	HRROI B,FILBUF
FOCOL:	MOVEM D,NCOL
	HRRZ A,OJFN
	MOVEI C,FILCHR
	SETZ D,
	SOUT
	SUBI C,FILCHR-1
	ADDM C,NCOL
	RET

OCOL:	PUSH P,B
	CALL FILL
	POP P,B
	JRST FOCOL

FILL:	HRRZ A,OJFN
	TXNE E,DI%TAB
	JRST FILL2
	TXNE E,DI%CMA
	JRST FILL3
	MOVEI B,40
FILL1:	BOUT
	SOSLE NCOL
	JRST FILL1
	RET

FILL2:	MOVEI B,11
	BOUT
	RET

FILL3:	HRROI B,[ASCIZ /, /]
	PUSH P,C
	SETZ C,
	SOUT
	POP P,C
	RET

GENCON:	GSTR(GEN,TGEN)
	MOVE A,IJFN
	TXNE A,GJ%VER
	JRST [	MOVEI A,.GJALL
		RET]
	MOVE A,TGEN
	MOVEI C,^D10
	NIN
	 JCERR <NIN failure at GENCON>
	MOVE A,B
	RET

GFIELD:	MOVE A,FPTR
	MOVEM A,(D)
	MOVE B,IJFN
	HLRZ C,D
	MOVE C,(C)
	JFNS
	 JCERR <JFNS failure at GFIELD>
	CAMN A,FPTR
	SETZM (D)
	SKIPE (D)
	IBP A
	MOVEM A,FPTR
	RET

LNCHK:	MOVEM A,LNTYP
	SKIPN D,STACK
	JRST LNCHK3
LNCHK1:	MOVE A,LNTYP
	CAME A,$DEVT(D)
	JRST LNCHK2
	MOVE A,DEV
	MOVE B,$DEV(D)
	STCMP
	 ERJMP LNCHK2
	JUMPE A,R
LNCHK2:	SKIPE D,$LINK(D)
	JRST LNCHK1
LNCHK3:	MOVE A,LNTYP
	MOVE B,DEV
	MOVE C,LDEV
	LNMST
	 ERJMP R
	MOVEM A,DEVT
	IBP C
	MOVEM C,FPTR
	RETSKP
SUBTTL	SET
DOSET:	FIELD(SETOPT)
	HRRZ B,(B)
	MOVE B,(B)
	MOVEM B,SETDIS
	MOVE A,[ALLBLK,,ALLLEN]
	CALL FILINI
	MOVX A,GJ%DEL
	IORM A,CMGJFN+.GJGEN	;ALLOW DELETED FILES
	FIELD(ARBFIL)
	MOVEM B,IJFN
	FIELD(SETARG)
	HRRZ C,C
	CAIN C,SETARG
	JRST SETSAM
	HRROI A,SETSTR
	HRROI B,ABBUF
	SETZ C,
	SOUT
	SETZM SETFLG
	JRST SETSM1

SETSAM:	SETOM SETFLG
SETSM1:	CONFIRM
SETLOP:	MOVEI A,.PRIOU
	HRRZ B,IJFN
	SETZ C,
	JFNS
	 JCERR <>
	SKIPN SETFLG		;COPYING STRING?
	JRST SETLP1
	HRRZ A,IJFN
	HLL A,SETDIS
	HRROI B,SETSTR
	GFUST
	 ERJMP[	JSMSG <Error reading old string>
		JRST SETLP2]
SETLP1:	HRRZ A,IJFN
	HRL A,SETDIS
	HRROI B,SETSTR
	SFUST
	 ERJMP[	JSMSG <Error setting string>
		JRST SETLP2]
	TMSG < [OK]
>
SETLP2:	MOVE A,IJFN
	GNJFN
	 ERJMP SETDON
	JRST SETLOP

SETDON:	CAIN A,GNJFX1
	JRST COMDON
	JSMSG <Error from GNJFN>
	JRST COMDON

END XWD EVL,EV
