;<SOURCES.UNSUPPORTED>DPY.FAI.16, 18-May-86 21:08:23, Edit by MRC
; Fix VH.INI to select correct character set for ANSI terminals
;PS:<SOURCES.UNSUPPORTED>DPY.FAI.15, 16-May-85 12:18:44, Edit by WANCHO
; Added PANDASW and DPYTAB entries for it.
;<ADMIN.JQJ>DPY.FAI.24, 23-Sep-81 15:07:27, Edit by ADMIN.JQJ
; another try at fixing he.dBx and vh.dBx
;<ADMIN.JQJ>DPY.FAI.23, 22-Sep-81 23:23:35, Edit by ADMIN.JQJ
; fix ..dBx, ..dBB, ..dEB to calculate cursor positions correctly
; eliminate last vestiges of Pflags (NIH code)
;<ADMIN.JQJ>DPY.FAI.22, 22-Sep-81 16:25:40, Edit by ADMIN.JQJ
; fix size initialization to use correct AC
; Ambassador -- don't scroll on wrap at end of screen, and check that
;  page size is one of the allowable set.
;<ADMIN.JQJ>DPY.FAI.21, 21-Sep-81 16:41:54, Edit by ADMIN.JQJ
; typos:  vh.mov CAIL instead of CAML.  vh.dlf no extra PUSH.
; add default to JRSTAB, and use it for xx.dSB, xx.dCB, xx.dBB, xx.dEB, xx.OUT
; redefine xx.bel so that low level routine writes ^G itself.  This will permit
;  implementations of "visible bell" if desired.
; replace xx.BOX with xx.dBX, so lowlevel routine can use multi-char seq.  Use
;  this feature on Heath and VT100.
;<ADMIN.JQJ>DPY.FAI.20, 19-Sep-81 08:56:46, Edit by ADMIN.JQJ
; make PLAY smarter:  <esc>55<esc>a = <esc>55^A now
; no $[4m in AM.QUI, eliminate repeat counts in AM.DCH, fix repeat in AM.DIL
; more rework to VT100 line I/D -- repeat counts
; fix many xx.DCh routines for better line overflow: no clearing (since high
;  level does it), no scroll in page mode (if ELC then don't write last char)
; rework ALBATROSS to correspond to current GILLOTINE implementation
;<ADMIN.JQJ>DPY.FAI.19, 18-Sep-81 10:39:09, Edit by ADMIN.JQJ
; rework VT100 to do line I/D correctly, and other code cleanup
;<ADMIN.JQJ>DPY.FAI.18, 14-Sep-81 10:52:19, Edit by ADMIN.JQJ
; clean up f%mlti, eliminating the feature (if DPYNCH then use RCount as count
;  for L/C I/D.  Should modify Tk, Al to use this feature.)
; more complete initialization for Ambassador, and make it use RCount
; rewrite some Tek4025 code, eliminating code that is never called
;<ADMIN.JQJ>DPY.FAI.15,  5-Aug-81 18:44:50, Edit by ADMIN.JQJ
; add Ambassador terminal type (not yet tested) 
;<ADMIN.JQJ>DPY.FAI.14,  7-Jul-81 14:50:31, Edit by ADMIN.JQJ
; vh.qui must reset the cursor.
; start modifications to have variable physical MaxPX and MaxPY
;ACCT:<SOURCES.TVEDIT>DPY.FAI.7,  6-Jul-81 10:07:36, Edit by J.JQJOHNSON
; clean up VT100 move calculation if PX=X.
;ACCT:<SOURCES.TVEDIT>DPY.FAI.6, 30-Jun-81 12:11:39, Edit by J.JQJOHNSON
; merge J.JWILSON's changes for VT100 support
; two flavors of PASCAL switch:  -1=Passgo, +1=Hedrick Pascal
;<ADMIN.JQJ>DPY.FAI.10,  6-Jan-81 11:51:39, Edit by ADMIN.JQJ
; Visual 200 EEOP.  Improve comments.  Merge Eric's changes.
;<ADMIN.JQJ>DPY.FAI.9, 20-Nov-80 13:08:06, Edit by ADMIN.JQJ
; eliminate FOUT, and clean up counting of buffer, to prevent stray nulls
;<ADMIN.JQJ>DPY.FAI.7,  4-Nov-80 17:40:34, Edit by ADMIN.JQJ
; padding for EEOP in Visual 200 (after Hedrick)
;<ADMIN.JQJ>DPY.FAI.6, 26-Oct-80 11:41:34, Edit by ADMIN.JQJ
; Coding errors in NIH: wxc not properly updated by IC, DC.  Insert
;   mode overflowed on long lines.  Erase to EOP not implemented.
;<ADMIN.JQJ>DPY.FAI.5, 25-Oct-80 11:17:55, Edit by ADMIN.JQJ
; Rutgers fixes for NIH:  at forceo, remember that NIH uses 8-bit bytes
;   IL and DL on should always be from col 1. (is this right?)
; Rutgers fixes for Visual:  vi.eeol, vi.eeop should be vi.eol and vi.eop
;   at vi.dl2, insert SETZ PX, since i/d line takes you to col 1
;<ADMIN.JQJ>DPY.FAI.3, 24-Oct-80 13:28:22, Edit by ADMIN.JQJ
; optimization at HZ.MOV -- don't use hz.up or hz.dow as much, they need leadin
; optimization at VT.MOV (HE, TL, HP)  -- note that incremental takes leadin
;   so should use DCA more.  But use LF and BS for incremental motion
; VT, TL, HP, HE incremental motion stops at margins
; TV, IQ incremental motion stops at margins
; AD incremental motion stops at margins
;<ADMIN.JQJ>DPY.FAI.2, 24-Oct-80 11:42:08, Edit by ADMIN.JQJ
; make code that optimizes incremental cursor movement common as RELMOV
;<ADMIN.JQJ>DPY..4, 23-Oct-80 15:15:31, Edit by ADMIN.JQJ
; rework handling of blinking fields (replace xx.BB and xx.EB with routines)
; eliminate most TVI code, since it identical to Soroc
; add TVI blinking fields, Soroc italics
; rework EEOP to agree with documentation--clears from beginning of line
;<ADMIN.JQJ>DPY..3, 22-Oct-80 23:12:13, Edit by ADMIN.JQJ
; eliminate Pflags and Fast in dm code
; eliminate unnecessary filter of ESC at xxx.dch (only printables get here)
;<ADMIN.JQJ>DPY..2, 20-Oct-80 21:47:07, Edit by ADMIN.JQJ
; more warnings on incompatible switch settings
; modify (improve) documentation slightly
; clean up forceO
; support Soroc IQ120 (handling of cursor movement off edge of screen
;  is wrong)
;<TV>DPY.;8    16-Oct-80 14:18:30	Edit by SCHOEN
; Define f%mlti feature.  Display has repeat count commands
; Added Tektronix 4025.  Most commands work, but without cursor addressing,
;  too many things go wrong.  Not added to TVEDIT for this reason.
; Add and debug ADDS Regent 60
; Debug HP26xx code (work on padding)
; Add Concept-100 (inHuman Designed System). Enormous padding requirements!
; ForceO uses SOUT now, as Concept-100 needs to send ESC NULL to end insert
; Save acs 2 and 3 around forceO call
;<TV>DPY.;7     25-Aug-80   10:12:06     Edit by SCHOEN
; Define xx.lead, xx.ldch for all terminals (for compatibility)
; Define f%ldbk feature, true for terminals whose blink mode
;  needs leadin character.  Modified ..doSB/..doCB accordingly
; Clean up Heath and NIH coding errors
;<ADMIN.JQJ>DPY.FAI.4, 30-Apr-80 19:27:48, Edit by ADMIN.JQJ
; merge changes by Rutgers (not yet fully cleaned up):
;  Infoton 400 dpy type
;  Visual 200 dpy type
;  NIH 5200 dpy type
;<ADMIN.JQJ>DPY.FAI.3, 11-Apr-80 14:30:56, Edit by ADMIN.JQJ
; merge changes by Kanerva and Schoen:
;  one-segment code under ONESEG conditional
;  Albatross dpy type
;  improve padding on Hazeltine
;  use pxy0pu and px0put  
;<ADMIN.JQJ>DPYPAS.FAI.50,  2-Apr-80 16:14:07, Edit by ADMIN.JQJ
; updated dpytab for SCORE and Stanford R4 systems
;<J.JQJOHNSON>DPYPAS.FAI.49, 20-Mar-80 13:24:04, Edit by J.JQJOHNSON
; some cleanup in comments.
;<J.JQJOHNSON>DPYPAS.FAI.48, 19-Mar-80 18:00:13, Edit by J.JQJOHNSON
; make it work (I think) in a non-zero section [SAIL mode calling
;  convention requires that stack pointers be local].  JRSTAB sets IFIW,
;  don't use "(f)" in dm code, make sure index regs are always .le. 0, etc.
;<J.JQJOHNSON>DPYPAS.FAI.47, 19-Mar-80 13:53:35, Edit by J.JQJOHNSON
; make sure that LH of F is always available to device-dependent routines.
; implement GLASS tty type -- most people don't like TTY type.
;<J.JQJOHNSON>DPYPAS.FAI.45, 15-Mar-80 11:12:18, Edit by J.JQJOHNSON
; rework TEST mode.
; fix HP26xx italic and blink.
; no leadin is required when CR is used for xxx.Mov
;<J.JQJOHNSON>DPYPAS.FAI.42,  5-Mar-80 12:38:31, Edit by J.JQJOHNSON
; implement italics and blink mode for HP26xx.
;  (more padding is needed for HP26xx on cursor up/down if PX is large.)
; add defaults for xxx.BOX, xxx.BB, xxx.EB.  Eliminate xxx.lcd.
; newline-clearing in TTY mode.  Move out of low-level routine to INCX
;<J.JQJOHNSON>DPYPAS.FAI.41,  4-Feb-80 17:35:37, Edit by J.JQJOHNSON
; TEST and PASCAL are incompatible switches
;<J.JQJOHNSON>DPYPAS.FAI.39,  4-Feb-80 03:14:12, Edit by J.JQJOHNSON
; make space always do doText, irrespective of tty mode. (is this right?)
;<J.JQJOHNSON>DPYPAS.FAI.38,  1-Feb-80 16:26:40, Edit by J.JQJOHNSON
; rework VT52, Heath, etc. to have more code sharing.  Improve move
; optimization near left margin (did I break anything?)
; enable DM italic, since it works correctly on Hazelmedia, but don't advertise
; remove padding for Heath; only makes matters worse.  Should use DISMS, but...
;<J.JQJOHNSON>DPYPAS.FAI.36, 21-Jan-80 19:13:41, Edit by J.JQJOHNSON
; some misc. cleanup, mostly in comments
;<J.JQJOHNSON>DPYPAS.FAI.35, 21-Jan-80 18:59:09, Edit by J.JQJOHNSON
; add Heath H19 support
;<J.JQJOHNSON>DPYPAS.FAI.34, 19-Dec-79 17:56:48, Edit by J.JQJOHNSON
;  massive reorganization of symbol names for 2-char tty dependent prefixes
;  convert partially to CTL macro for greater readability
;<J.JQJOHNSON>DPYPAS.FAI.33, 18-Dec-79 17:06:21, Edit by J.JQJOHNSON
;  fix TVI padding.  Still not really right
;<J.JQJOHNSON>DPYPAS.FAI.31, 18-Dec-79 16:35:43, Edit by J.JQJOHNSON
;  added TVI 912/920 code
;PS:<J.JQJOHNSON>DPYPAS.FAI.24, 19-Sep-79 18:54:56, Edit by J.JQJOHNSON
;  added HP2648 code (not yet debugged)
;PS:<J.JQJOHNSON>DPYPAS.FAI.23, 15-Sep-79 13:32:49, Edit by J.JQJOHNSON
;  added sfpos at TURNOF to tell system what the current state of world is.
;PS:<J.JQJOHNSON>DPYPAS.FAI.22, 14-Sep-79 12:25:49, Edit by J.JQJOHNSON
;try different Haz. timing for IL/DL.
;PS:<J.JQJOHNSON>DPYPAS.FAI.21, 13-Sep-79 09:43:58, Edit by J.JQJOHNSON
;  added DPYSTR in Pascal, and fixed h.qui to clear italic in both versions.
;<J.JQJOHNSON>DPYPAS.FAI.7, 16-Jun-79 11:35:42, Edit by J.JQJOHNSON
;  finish conversion to Pascal-callable, by adding functions for
;  external variables
;<J.JQJOHNSON>DPYPAS.FAI.5, 16-Jun-79 10:47:35, Edit by J.JQJOHNSON
;  convert to Pascal-callable
;6-Apr-79 /pk
;  (1) Removed virtual display simulation by Hazeltine
;4-Apr-79 /pk
;  (1) Hazeltine BOX rather * than `
;3-Apr-79 /pk
;  (1) Brand new timing formulas for Teleray
;2-Apr-79 /pk
;  (1) Don't pass ~ (lead-in) to Hazeltine, convert to BOX
;  (2) Teleray EEOL needs padding
;1-Apr-79 /pk
;  (1) Separated EEOL and EEOP of Teleray and VT
;  (2) New EEOP for Datamedia (sequence of EEOLs)
;30-Mar-79 /pk
;  (1) Added padding to EEOP and CL of Teleray
;29-Mar-79 /pk
;  (1) Fixed PDL OVERFLOW in SEEOS
;  (2) Removed calls to simulate erase fns for Teleray & VT52
;28-Mar-79 /pk
;  (1) Changed (improved) line-I/D timing for Teleray
;27-Mar-79 /pk
;  (1) Removed Teleray blink mode.  Unwieldy hardware.
;  (2) Fixed Teleray EEOP.  But why does it simulate EEOS (37.53)?
;<CUSPS.TVEDIT>DPY.FAI.13, 19-Feb-79 11:47:41, Edit by ADMIN.JQJ
; VT52 doesn't have CLP
;<CUSPS.TVEDIT>DPY.FAI.12, 17-Feb-79 16:40:19, Edit by ADMIN.JQJ
; some more cleanup
;<SOURCES.TVEDIT>DPY.FAI.4, 16-Feb-79 07:29:29, Edit by J.JQJOHNSON
; Revised use of JRSTAB and CONTAB -- build automatically from DEFTTY,
; and use only two words for all tty-dependent constants.
;<CUSPS.TVEDIT>DPY.FAI.11, 15-Feb-79 08:30:19, Edit by ADMIN.JQJ
; Cleaned up VT52 code slightly, and combined some VT52 and Teleray code
;<CUSPS.TVEDIT>DPY.FAI.10, 15-Feb-79 08:19:40, Edit by ADMIN.JQJ
; Fixed Hazeltine Insert mode, fixed bottom-left cursor movement
; for Teleray and VT52, added real VT52 code.
; Reworked redrawing of line on Hazeltine IC and DC functions
;<CUSPS.TVEDIT>DPY.FAI.9, 12-Feb-79 21:47:05, Edit by ADMIN.JQJ
; Fixed bug in Teleray insert-char mode
;<CUSPS.TVEDIT>DPY.FAI.8, 12-Feb-79 21:31:54, Edit by ADMIN.JQJ
; Rewrote Hazeltine support to use virtual dpy, and to handle bold mode
;<CUSPS.TVEDIT>DPY.FAI.7, 12-Feb-79 20:10:12, Edit by ADMIN.JQJ
; Implemented "virtual" dpy to simulate ch/li ins/del
;<CUSPS.TVEDIT>DPY.FAI.5, 12-Feb-79 01:03:39, Edit by ADMIN.JQJ
; Started adding VT52 code -- very incomplete
;<CUSPS.TVEDIT>DPY.FAI.4, 12-Feb-79 00:07:54, Edit by ADMIN.JQJ
; Add Teleray code.  Converted PJ, RJ to CALL, RET

 	subttl assembly parameters

; Site selection switches.

ifndef stansw,<stansw __ 0>
ifndef sumex,<sumex__0>
ifndef sum20,<sum20__0>
ifndef rutg,<rutg__0>
ifndef sri20,<sri20__0>
ifndef ecl,<ecl __ 0>
ifndef pandasw,<pandasw __ 0>
ifn <stansw+sumex+sum20+rutg+sri20+ecl+pandasw-1>,<
	printx No (or multiple) site switch specified.
	end >

; Feature selection switches

ifn sumex,<tops20__0>
ifn ecl,<tops20__0>

ifndef tops20,<tops20 __ 1>	; 0 for Tenex, 1 for Tops20
ifndef test,<test __ 0 >	; 0 for FALSE, non-0 for TRUE
ifndef pascal,<pascal __ 0 >	; 0 for Sail, 1 for (Hedrick) Pascal
				;	callable, -1 for Passgo callable
ifn <test*pascal>,<printx Incompatible switch settings.
	end
>
ifndef oneseg,<oneseg __ 0 >	; 1 for one segment code, 0 for twoseg


ife pascal,<TITLE DPY  Sail-callable display compatibility package
>;ife pascal
ifn pascal,<TITLE DPYPAS  Pascal-callable display compatibility package
>;ifn pascal

	subttl Description of the package

COMMENT \

	Display compatibility package for SAIL, Pascal, and assembly
	language programs.  

	Three switches govern assembly of this file:
	1/    PASCAL==0 if Sail linkage convention.  1 if Pascal linkage.
	2/    TEST==0 if normal package.  1 if standalone test version.
	Default for each switch is 0.
	3/    a site dependent switch.  Set one of the following to
		1, or define a new one:
	      STANSW,SUMEX,SUM20,RUTG,SRI20,ECL
	To assemble:
	    @copy tty: site.fai
	    stansw==1			;or whichever
	    ^Z
	    @copy tty: pasflg.fai
	    pascal==1
	    ^Z
	    @compile site+dpy, site+pasflg+dpy dpypas.rel

	SAIL users should
	    REQUIRE "SAI:DPY.SAI" SOURCE!FILE, or
	    REQUIRE "SAI:DPYCOM.SAI" SOURCE!FILE,
	but not both.  The former declares the external variables 
	and procedures of DPY, the latter in addition defines (and 
	explains) the display commands.

	Assembly language programmers should copy the external
	declarations from  ACCT:<SOURCES.TVEDIT>DPY.ASS  and load
	with SYS:DPY.REL

	Pascal programmers should copy the external declarations from
	SYS:DPY.PAS and load with SYS:DPYPAS.REL.

	Compactness and speed have been the primary criteria in the 
	design of this package.  In a few places this might have led 
	into code whose function is not immediately obvious.

	Programmed by Pentti Kanerva, IMSSS, Stanford University,
	June 1975.  Modified by J.Q. Johnson and Pentti Kanerva,
	1979, and J.Q. Johnson and Eric Schoen, 1980, 1981.
    \

	subttl Caveats, and suggestions for improvement

COMMENT	\

To install this package:

	Edit the comment on the previous page to point to the 
appropriate places for the relevant files, and add a new site switch
and a newtable at DPYTAB to reflect the local site's choices of
terminal numbers.
	Compile as above.
	Install the files SYS:DPY.PAS, SYS:DPYPAS.REL, SAI:DPY.SAI
SAI:DPY.REL, SAI:DPYCOM.SAI, and SAI:DPYCOM in the appropriate places.


Caveats and suggestions for improvement:

Should support more dpy types.
q.dirt, q.over, q.back should be flags in LH of F instead of
	variables.
Display service for TVI 912 and Soroc is not fully debugged.
Padding for TVI, VT52, and HP26xx is incorrect.
The handling of Italic and Blink mode on HP26xx is quite awkward.
Device-dependent initialization is inconsistent.  It should always place
	the terminal in a known state, but not change the contents of the
	screen.  Quiting should also leave screen and cursor intact.
Handling of Blink Mode and Blinking Field may still be inconsistent, and
	does not exist for most terminal types.
\

	subttl Definitions

	nolit			; no literals expanded in listing
	xall			; no macro expansions in listing
	asuppress		; no unused symbols in REL file

INTERNAL  cx, cy, dpyOn, bps, lcDpy, maxCX, maxCY
INTERNAL  dpyIni, turnOn, turnOf, setCur, clrCur
INTERNAL  dpyChr, dpyNCh, dpyStr, dpyOut
INTERNAL  setIta, clrIta, setIns, clrIns, setBli, clrBli, setTTY, clrTTY
INTERNAL  doRigh, doDown, doLeft, doUp, doHome
INTERNAL  doIC, doIL, doDC, doDL, doEEOL, doEEOP, doCL, doCP, doBB, doEB
INTERNAL  dpyTyp, Ftest
ifn pascal,<
INTERNAL  RmaxCX,RMaxCY,RCX,RCY,RBps,hasLow
>;ifn pascal

  ;; AC Assignments

	zero_  0	; temporary storage
	t1  _  1	; temporary storage
	n1  _  2	; counter (for PUTNC1 etc.)
	tmp _  3	; WARNING: "IDIV N1, xxx" clobbers TMP
	px  _  4	; physical (dpy dependent)  X,  stored in  DPYX
	py  _  5	; physical (dpy dependent)  Y,  stored in  DPYY
	x   _  6	; virtual  X,  stored in  CX
	y   _  7	; virtual  Y,  stored in  CY 
	f   _ 10	; flags for insert, italic, blink, and tty mode
	dpy _ 11	; display type (internal index into tables)
  ;	reserved _ 12	; reserved by SAIL

	ch  _ 13	; character, dpy independent 
	ch1 _ 14	; character, dpy dependent
	ch2 _ 15	; char, Datamedia mode change
	delX __ ch1	; delta X
	delY __ ch2	; delta Y
	sp  _ 16	; string stack pointer, as in SAIL
	p   _ 17	; stack pointer, as in SAIL and Pascal

  ;; Flag bits, right hand side of F

	insert __ 400000
	italic __ 200000
	blink __  100000
	tty __     40000
	
  ;; Flag bits, left hand side of F (hardware-local to low-level routines)

	pinsrt __ 400000
	pital __  200000
	pblink __ 100000
	ptty __    40000

; n.b.	777 reserved for local flags particular to a terminal type.

  ;; Constants (ASCII codes)

	BEL __  7
	LF  __ 12
	CR  __ 15
	ESC __ 33
	RUB __ 177

  ;; Feature indices for FTEST. (a Pascal-style set)
	f%dca	__ 1b0		;has cursor addressing
	f%eeol	__ 1b1		;has cleol
	f%eeos	__ 1b2		;has cleos
	f%clp	__ 1b3		;has clear page (or home and cleos)
	f%lid	__ 1b4		;has line insert/delete
	f%cid	__ 1b5		;has character insert/delete
	f%lc	__ 1b6		;has lower case
	f%ital	__ 1b7		;has italic (standout) characters
	f%blm	__ 1b8		;has blink mode
	f%blf	__ 1b9		;has blinking fields
;	f%mlti __ 1b10		;has repeat count argument feature
				;1 lollipop to EJS
	f%home __ 1b11		;has home (J.JWilson)
	f%udlr __ 1b12		;has up-down-left-right
				;(J.JWilson --one lollipop to me)

;(a prize of one lollipop goes to anyone who comes up with more features)

OPDEF	call	[pushj	p,]
OPDEF	ret	[popj	p,]
OPDEF	callret	[jrst]
OPDEF	jsys	[104000000000]
OPDEF	psout	[jsys	 76]
OPDEF	rfmod	[jsys	107]
OPDEF	sfmod	[jsys	110]
OPDEF	sfpos	[jsys	526]
OPDEF	gttyp	[jsys	303]
OPDEF	mtopr	[jsys	77]
.morlw==30			;read tty width with MTOPR
.morll==32			;read tty length with MTOPR

define ctl(chr) {"chr"-100}

; DEFTTY -- define symbols for new terminal type
;call:	letter/ one- or two- letter code-prefix for the terminal type
;	sym/	one- to four- letter name for the terminal type
;n.b. both LETTER and SYM must be unique, though they may be the same.
define deftty ' (letter,sym) {
    ifdef nttys,<		;add another terminal type to the list
	concat (\ttylst,letter)
	nttys __ nttys+1
    >
    ifndef nttys,<
	nttys __ 0		;first internal tty type is zero
	define ttylst {0,letter}
    >
	t%'sym __ nttys		;define a symbolic name
}
; FORALL -- macro to use in generating lists of terminal types.
;call:	forall (\ttylst) <text>
; Text following the forall is expanded nttys times, with ... 
; substituted for the appropriate LETTER value.  Assumes 
; that ' is the concat. char.
; n.b. used to generate lists e.g. dispatch tables.
define forall (a,b) {for @` ... in (b) }

define concat (a,b,c) { define ttylst {0,<b,c>}
}
	subttl Impure data

ife oneseg,<
	TWOSEG
	RELOC	400000
	RELOC	0
>;ife oneseg

  ; SAFE is where important AC's are kept between calls to dpy package
  ; The AC's are saved and restored using a BLT
  ; storing ACs px through dpy ('4 .. '11)

safe:	block  16

	dpyX  _  safe + px
	dpyY  _  safe + py
	cx    _  safe + x	; *INTERNAL*
	cy    _  safe + y	; *INTERNAL*
	flags _  safe + f
	dpyTyp _ safe + dpy	; *INTERNAL*

ifn pascal,<
  ; ACBLK is used to store important ACs for the caller.
  ; The AC's are saved and restored using a BLT, 
  ; storing ACs px through sp ('2 .. '16)
  ; n.b. the arguments to a procedure are typically in ACs 2..6

acblk:	block	17
	ac2 __ acblk + 2
	ac3 __ acblk + 3

>;ifn pascal

  ; the next 2 lines of code go to low segment

next:	1b0!doInit		; this will force initialization
cpopj:	ret


maxX:		; Maximum X value of virtual display,  0 leq X leq MAXX 
maxCX:	=79	; *INTERNAL*
maxY:		; Maximum Y value of virtual display,  0 leq Y leq MAXY
maxCY:	=23	; *INTERNAL*
maxPX:	=79	; Maximum physical X value of actual screen.  MaxX leq MaxPX
maxPY:	=23	; Maximum physical Y value of actual screen.  MaxY leq MaxPY
RCount:	0	; Repeat count if in DPYNCH.  RCount.le.0 iff no count.

Dbuf.p:	point 7,dBuf,-1	; Byte pointer to dpy buffer
Dbuf.n:	0	; Byte count to end of buffer
Dbfn.p:	point 7,dBuf,-1	; Byte pointer to be used for reinitialization
Dbfn.n:	0	; Bye count to end of reinitialized buffer
bps:	=2400	; Line speed, Bits Per Second *INTERNAL*
fast:	0	; -1 for 9600-bps Datamedia (I/D commands need padding)
		;  0 otherwise
dpyOn:	-1	; Display on (not in ^O) *INTERNAL*
lcDpy:	-1	; LowerCase Display *INTERNAL*

	dBufSz __ 200	; the buffer itself is declared at end of file

ife oneseg,<
	RELOC	; now high segment
>;ife oneseg
begCod:

	subttl *** Display Dependent Routines ***

;		      Display Dependent Routines
;		      ==========================

comment \

	Entry points to low-level routines (xx is the dpy-type code, e.g.
xx.mX might be dm.mX or hz.mX):

stored in dpysiz (size parameters):
  xx.mX		physical maximum row number -- used by low level routines
		to determine when cursor is expected to wrap, etc.
  xx.mY		physical maximum column number -- used by low level
		routines to determine when scroll occurs, etc.
stored in dpyfea:
  xx.fea	feature indices.  Used by FTEST and to initialize lcDpy 
in dispatch tables:
  xx.ini	device-dependent initialization.  Called from DPYINI
		after  setting default parameters, making cursors
		illegal, and clearing flags.  Should set any hardware
		specific modes to the standard value expected in the
		package, and set any hardware specific state flags
		accordingly.  Should not change the contents of the screen.
  xx.qui	device-dependent cleanup.  Called from TURNOF after
		bringing cursor up to date and dumping buffer.  Should
		clear any hardware specific modes, and return terminal
		to its ordinary (ascii mode) state.  Should leave cursor
		in place, and should not change the contents of the screen.
  xx.out	called on user request to dump buffer, with cursor up to
		date but buffer not yet dumped.  By default if not defined
		does nothing.
  xx.dCh	actually put a displayable character in the buffer.
		Called with character in Ch.  Should account for any
		motion of cursor; should not cause roll unless wrap from
		bottom of screen in TTY mode; should not clear newly
		entered line; should obey INSERT, ITALIC and BLINK flags
		in RH of F.
  xx.mov	bring physical cursor (PX, PY) up to date to match the
		logical cursor (X, Y).  Called with delX and delY
		containing the magnitudes of distances to move.
  xx.dLC	Load Cursor.  Do a direct cursor addressing function to
		update (PX, PY) assuming that current (PX,PY) are illegal.
  xx.dIC	insert a blank at the current cursor position, (leaving
		the cursor in place).  Should not cause scrolling even if
		insertion is done at last character of screen.	Cursor is
		assumed to be up to date.
  xx.dIL	insert a blank line.  Cursor is assumed to be up to date.
  xx.dDC	delete the character at the current cursor position.
  xx.dDL	delete current line.  Cursor is assumed to be up to date.
  xx.dEL	clear from cursor to end of line.  Cursor is assumed to be 
		up to date.
  xx.dEP	erase from beginning of current line to end of page.
		Cursor is assumed to be up to date.
  xx.dCP	clear screen.    Cursor is assumed to be up to date.
  xx.dSB	Set blink mode.  If called as "blinking field", then
		after calling this routine, a field separator is written
		at the current X,Y.  Default, if this routine is undefined,
		is to do nothing.
  xx.dCB	Clear blink mode.  If called as "blinking field", then
		after calling this routine, a field separator is written 
		at the current X,Y.  Default, if this routine is undefined,
		is to do nothing.
  xx.bel	Ring the terminal's bell.  By default, an invisible BEL
		character is written into the output buffer.
  xx.dLF	Move down one line, with scrolling.  Cursor is assumed to
		be up to date and at bottom of screen.
  xx.dBB	Insert a Begin-Blinking field character, or a space.  If
		blinking-field does not occupy a visible/addressable
		space, then an extra space is written.	Cursor is
		assumed to be up to date.  Default, if this routine is 
		undefined, is to write a visible space.
  xx.dEB	Insert an End-Blinking-Field character, or a space if
		terminal does not support blinking fields.  Cursor is
		assumed to be up to date.  Default, if this routine is
		undefined, is to write a visible space.
  xx.dBx	Print a "box" character.  If the routine is undefined,
		then a "*" is printed using xx.dCh.
  xx.dRi
  xx.dDo
  xx.dLe
  xx.dUp	Incremental cursor motion.  Called from relmov i.e. xx.mov
		by some DPYs.  Move one or more spaces, stopping at margins.
		Number of spaces to move on terminals with repeat counts is
		controlled by delX, delY.
\
	subttl TTY display dependent routines

;				 TTY
;				 ===

deftty(q,tty)

COMMENT	\
	All tty movement is delayed until a printing character is sent.
	\

	q.mX	__ =71
	q.mY	__ =23

	q.pch  __ RUB		;pad char

	q.FEA __ f%lc		;has lowercase
	q.ldch __ 0		;no leadin

ife oneseg,<
	RELOC
>;ife oneseg

qx:	0	; Position of true print head.  (DX,DY) is the
qy:	-1	;   position of virtual print head (it is ahead).

q.dirt:	-1	; True if current line has been written on, in which
              	;   case backing up buys automatic new line.
q.over:	 0	; True means to allow overprinting, i.e., to inhibit 
		;   automatic new line on backing up (see comment 
		;   above), in which case backing up sets  Q.BACK.
q.back:	 0	; We have actually backed up on a dirty line, in order 
		;  to point or overprint.

ife oneseg,<
	RELOC
>;ife oneseg


q.ini:	move	zero, maxPX
	addi	zero, 1
	movem	zero, qx
	setom	 qy
	setom	 q.dirt
	setzm	 q.over
	setzm	 q.back
; fall through
q.dLe:	q.dRi:	q.dDo:	q.dUp:	; used by RELMOV
q.qui:	ret


q.dCh:	cain	ch, " "		; is it a space?
	 jrst	 q.Sp		; ..yes, delay spacing
	call	 q.chk
	call	 putCh
	setom	 q.dirt		; mark current line as dirty
	camn	t1, maxPX	; past right margin?
	 aoja	t1, q.Sp	; yes.  Just increment t1.
	aos	t1, qx		; INC(QX) and INC(T1)

q.Sp:	came	px, maxPX
	 aoj	px,		; move cursor that the world believes in
	ret


q.LF:	movem	py, qy
	setzm	 q.dirt
	setzm	 q.over
	setzm	 q.back
	movei	ch1, LF
	jrst	 putCh1


q.mov:			; called from dev independent routines
q.dLC:	movei	px, (x)		; fake the move.  The moving is
	movei	py, (y)		;   delayed until something is
	ret			;   actually printed


q.OUT:				; entry for user-issued FORCEOUT
q.ch1:	setom	 q.over		; entry for  Q.dDC, to allow overprint
	skipa
q.chk:	 setzm	 q.over		; entry for normal printing
	camn	px, qx
	 came	py, qy
	  jrst	 q.set
	skipe	 q.back		; in place.  About to overprint?
	 skipe	 q.over		; ..yes, but is that so bad?
	  ret			; ..no, stay put

q.set:	setz	n1,
	caml	px, qx		; are we past the target?
	 jrst	 q.mvY		; ..no
	skipe	 q.dirt		; ..yes
	 setom	 q.back		; backing up on a dirty line!
	movei	ch1, CR
	call	 putCh1
	exch	n1, qx		; N1 _ length of CR action,  QX _ 0
	idivi	n1, =25		; NOTE:  Clobbers TMP!!
	aoj	n1,		; N1 _ time to allow for CR

q.mvY:	came	py, qy
	 jrst	 q.feed
	skipe	 q.back		; About to overprint?
	 skipe	 q.over		; ..yes, but is that so bad?
	  jrst	 q.pad		; ..no, stay on current line
q.feed:	call	 q.LF		; makes QY = PY
	soj	n1,		; LF counts as one fill

q.pad:	jumple	n1, q.mvX
	movei	ch1, q.pch
	call	 putNC1

q.mvX:	movei	n1, (px)	; target X
	move	zero, n1
	exch	zero, qx
	sub	n1,		; N1 _ PX - QX
	movei	ch1, " "
	jrst	 putNC1		; space to position


	; TTY Insert/Delete !!

  ; Note:  Q.dIC/DC will not update  QX

q.dIC:	call	 q.chk
	setom	 q.dirt
	movei	ch1, "/"
	jrst	 putCh1


q.dDC:	call	 q.ch1		; Q.CH1  to allow overprinting
	setom	 q.dirt
	movei	ch1, "\"
	jrst	 putCh1


q.dCP:	call	 q.LF
q.dLF:
q.dEP:
q.dDL:
q.dIL:	setom	 qy
q.dEL:	ret


	LIT
	subttl Glass tty display dependent routines.

;				GLASS
;				=====


deftty(gl,glass)

;glass ttys are assumed to erase the current char on the screen when
;sent a space, but not to erase on BS (cursor right) or CR (cursor to
;beginning of line.  No other display functions are presumed.  Thus,
;the ADM3 is a good model for glass ttys.

	gl.mX	__ =79
	gl.mY	__ =23

	gl.lef	__ ctl(H)

	gl.FEA	__ f%lc+f%eeol+f%clp	; has lowercase, normally


ife oneseg,<
	RELOC
>;ife oneseg

gl.dir:	block	1		; position of last dirty char on line
				; (or -1 if line is clean)
ife oneseg,<
	RELOC
>;ife oneseg
gl.lead:
gl.dIC:
gl.dIL:
gl.dDL:
gl.qui:
gl.dep:
	ret

gl.ini:	setom	 gl.dir		; line is not dirty
	setzb	px, py		; assume at home
	movei	ch1, CR		; but really just at beginning of some line.
	call	 putch1
	jrst	 gl.dLF

;delete a character -- replace it with a space
gl.dDC:	came	px, gl.dir	; are we at end of line?
	 sos	 gl.dir		; one less dirty position.
	movei	ch1, " "
	call	 putch1
	movei	ch1, gl.lef
	jrst	 putch1

;erase to end of line -- with spaces
gl.del:	skipge	n1, gl.dir	; get max spaces to clear.  Is line dirty?
	 ret			; no.  No clearing needed
	subi	n1, -1(px)	; need not clear beginning
	jumpe	n1,cpopj	; nothing to clear
	exch	px, gl.dir
	addi	px, 1		; indicate that we'll be right after eol.
	movei	ch1, " "	; clear to spaces
	jrst	 putnc1		; do the clearing
	
gl.dCh:	cain	ch, " "
	 jrst	 gl.dC1
	camle	px, gl.dir	; gl.dir := max(gl.dir,px)
	 movem	px, gl.dir	; writing anything but space gives dirty line
gl.dC1:	call	 putch		; write the character
	came	px, maxPX	; at end of line?
	 aoja	px, cpopj	; no.
	ret			; yes.  Cursor does not automatically wrap.

; actually move the cursor.
gl.dlc:
gl.mov:	jumpl	x,gl.mvY	; prevent hanging on igl X
	camg	x, maxPX
gl.mX1:	 cain	 x, (px)
	  jrst	  gl.mvY	; we're ok
	jumpn	x, gl.mX2 ; don't use CR
	movei	ch1, CR
	setz	px,		; we'll be in col. 1
	call	 putch1
	jrst	 gl.mvY		; all done with X
gl.mX2:	movei	t1, gl.dRi	; assume right move
	caig	x, (px)		; but is it?
	 movei	t1, gl.dLe	; nope.  Left.
	call	 (t1)		; do it
	jrst	 gl.mX1
gl.mvY:	jumpl	y, cpopj	; illegal y
	camg	y, maxPY
gl.mY1:	 cain	y, (py)
	  ret			; already ok
	movei	t1, gl.dDo
	caig	y, (py)		; is it up?
	 movei	t1, gl.dUp
	call	 (t1)
	jrst	gl.mY1

gl.dUp:	move	py, y		; say we're in the right place
; [jqj this should maybe be just RET?]:
	jrst	 gl.dLF		; and enter a new line

;not ok.  Fall into gl.dLF

gl.dLF:	setom	 gl.dir		; we're on a clean new line
	movei	ch1, LF		; enter a new line.
	jrst	 putCh1

gl.dDo:	camn	py, maxPY
	 seto	py,		; -1.  Incremented below
	aoja	py, gl.dLF

gl.dLe:	movei	ch1, gl.lef	; move left using BS
	sojge	px, putch1
	move	px, maxPX	; back up a line
	soja	y, cpopj

gl.dRi:	movei	ch1, " "	; move right using destructive SPACEs
	camge	px, maxPX
	 aoja	px, putch1	; send a space (best we can do)
	setz	px,
	movei	ch1, CR
	call	 putch1
	aoja	y, gl.dDo	; move down a line

; clear the page
gl.dcp:	movei	ch1, ctl(L)	; some use ^L
	call	 putCh1
	movei	ch1, ctl(Z)	; others use ^Z
	jrst	 putCh1

	subttl TEC display dependent routines

;				 TEC
;				 ===

deftty(tc,tec)

	tc.mX	__ =79
	tc.mY	__ =23

		; TEC Display Commands

	tc.EOL	__ 143	; c 
	tc.IC	__ 144	; d 
	tc.IL	__ 145	; e 
	tc.righ	__ 147	; g 
	tc.dow	__ 150	; h 
	tc.hom	__ 151	; i 
	tc.LCA	__ 154	; l 
	tc.eop	__ 163	; s 
	tc.DC	__ 164	; t 
	tc.DL	__ 165	; u 
	tc.CP	__ 166	; v 
	tc.lef	__ 167	; w 
	tc.up	__ 170	; x 

	tc.BB	__ 173	; { 
	tc.EB	__ 174	; | 
	tc.pch	__ RUB		;pad char
	tc.ldch __ 0

	tc.BOX	__  32	; ^Z, all bright "BOX" character
	tc.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%blf
				 ;n.b. no lower case!

tc.ini:
tc.qui:	ret

tc.dBB:	movei	ch1, tc.bb
	jrst	 putCh1

tc.dEB:	movei	ch1, tc.eb
	jrst	 putCh1

tc.bel:	movei	ch, BEL
	call	 putCh		; send a BEL (^G)
	movei	ch1, tc.pch	; one fill to flip the bell's flop
	jrst	 putCh1

tc.dBx:	movei	ch, tc.BOX	; just write the box character

tc.dCh:	trne	f, insert
	 call	 tc.dIC
	call	 putCh
	came	px, maxPX
	 aoja	px, cpopj	; INC(PX)
	setz	px,
	came	py, maxPY
	 aoja	py, cpopj	; INC(PY)
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 ret			; ..no
	call	 tc.dUp		; ..yes, cursor to lower left corner

	; falls to  Tc.dLF

tc.dLF:	movei	ch1, LF		; for last line LF only, to scroll
	jrst	 putCh1


tc.mov:	movei	zero, (x)
	addi	zero, (y)

	movei	t1, (delX)
	addi	t1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
	caige	zero, (t1)
	 jrst	 tc.hOK		; home wins over move
	caig	t1, 3		; home loses
	 jrst	 relmov		; move wins.  Use common code w/o CR
	jrst	 tc.dLC		; LCA wins

tc.hOK:	cail	zero, 3		; close to home?
	 jrst	 tc.dLC		; ..no, do LCA
	call	 tc.dHo		; ..yes 
	jrst	 relmov		; then do relative move

tc.dLC:	movei	ch1, tc.LCA	; do absolute move
	call	 putCh1
	movei	px, (x)
	movei	ch1, (x)
	trc	ch1, 177
	call	 putCh1
	movei	py, (y)
	movei	ch1, (y)
	trc	ch1, 177
	jrst	 putCh1		; will RET


tc.dRi:	movei	ch1, tc.righ
	came	px, maxPX
	 aoja	px, putCh1 	; INC(PX)
	setz	px,
	skipa

tc.dDo:	 movei	ch1, tc.dow
	camn	py, maxPY
	 seto	py,             ; -1, incremented below
	aoja	py, putCh1	; INC(PY)


tc.dLe:	movei	ch1, tc.lef
	sojge	px, putCh1
	move	px, maxPX
	skipa

tc.dUp:	 movei	ch1, tc.up
	sojge	py, putCh1
	move	py, maxPY
	jrst	 putCh1


tc.dHo:	movei	ch1, tc.hom	; home cursor 
	jrst	 pxy0Pu


	; TEC Insert/Delete

tc.dIC:	movei	ch1, tc.ic
	jrst	 putCh1



tc.dDC:	movei	ch1, tc.dc
	jrst	 putCh1


tc.dEP:	movei	ch1, tc.eop	; Erase to End Of Page
	jrst	 px0put


tc.dCP:	movei	ch1, tc.cp	; Clear Memory 
	jrst	 pxy0Pu


tc.dIL:	movei	ch1, tc.IL
	jrst	 px0put


tc.dDL:	movei	ch1, tc.dl
	jrst	 px0put


tc.dEL:	movei	ch1, tc.eol	; Erase to End Of Line
	jrst	 putCh1


	LIT

	subttl Imlac display dependent routines

;			        IMLAC
;			        =====

deftty(im,imlac)

	im.mX	__ =79
	im.mY	__ =39
	im.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc


		; IMLAC Display Commands

	im.LCA	__  1	; ^A 
	im.hom	__  3	; ^C 
	im.up	__  4	; ^D 
	im.rig	__  5	; ^E 
	im.lef	__ 10	; ^H = BS
	im.dow	__ 12	; ^J = LF
	im.eop	__ 13	; ^K = VT
	im.CP	__ 14	; ^L = FF
	im.SB	__ 16	; ^N 
	im.CB	__ 17	; ^O 
	im.eol	__ 20	; ^P 
	im.DC	__ 26	; ^V 
	im.IC	__ 27	; ^W 
	im.DL	__ 30	; ^X 
	im.IL	__ 31	; ^Y 

	im.pch	__ 37		;pad char


im.lead:ret

im.dSB:	movei	ch1, im.SB
	jrst	 putCh1

im.dCB: movei	ch1, im.CB
	jrst	 putCh1


im.ini:
im.qui:	ret


im.bel:	call	 chkXY		; since BELL is displayed at cursor,
	movei	ch, BEL		; first bring it up to date
	jrst	putCh		; write the bell

im.dCh:	trne	f, insert
	 call	 im.dIC
	call	 putCh
	came	px, maxPX
	 aoja	px, cpopj	; INC(PX)
	setz	px,
	came	py, maxPY
	 aoja	py, cpopj	; INC(PY)
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 ret			; ..no
	call	 im.dUp		; ..yes, cursor to lower left corner

	; falls to  Im.dLF

im.dLF:	movei	ch1, LF		; for last line LF only, to scroll 
	jrst	 putCh1


im.mov:	movei	zero, (x)
	addi	zero, (y)

	movei	t1, (delX)
	addi	t1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
	caige	zero, (t1)
	 jrst	 im.hOK		; home wins over move
	caig	t1, 3		; home loses
	 jrst	 relmov		; move wins (should be relmCR?)
	jrst	 im.dLC		; LCA wins

im.hOK:	cail	zero, 3		; close to home?
	 jrst	 im.dLC		; ..no, do LCA
	call	 im.dHo		; ..yes 
	jrst	 relmov		; do common move routine

im.mvY:	jumpl	y, cpopj
	camg	y, maxPY
im.mY1:	 cain	y, (py)
	  ret
	movei	t1, im.dDo
	caig	y, (py)
	 movei	t1, im.dUp
	call	 (t1)		; up/down move 
	jrst	 im.mY1


im.dLC:	movei	ch1, im.LCA	; do absolute move
	call	 putCh1
	movei	px, (x)
	movei	ch1, (x)
	trc	ch1, 177
	call	 putCh1
	movei	py, (y)
	movei	ch1, (y)
	trc	ch1, 177
	jrst	 putCh1		; will RET


im.dRi:	movei	ch1, im.rig
	came	px, maxPX
	 aoja	px, putCh1 	; INC(PX)
	setz	px,
	skipa

im.dDo:	 movei	ch1, im.dow
	camn	py, maxPY
	 jrst	 putCh1		; scroll from last line
	aoja	py, putCh1	; INC(PY)


im.dLe:	movei	ch1, im.lef
	sojge	px, putCh1
	skipa	px, maxPX

im.dUp:	 movei	ch1, im.up
	sojge	py, putCh1
	move	py, maxPY
	jrst	 putCh1


im.dHo:	movei	ch1, im.hom	; home cursor 
	jrst	 pxy0Pu


	; Imlac Insert/Delete

im.dIC:	movei	ch1, im.ic
	jrst	 putCh1


im.dIL:	movei	ch1, im.IL
	jrst	 px0Put


im.dDC:	movei	ch1, im.dc
	jrst	 putCh1


im.dDL:	movei	ch1, im.dl
	jrst	 px0Put


im.dEL:	movei	ch1, im.eol	; Erase to End Of Line
	jrst	 putCh1


im.dEP:	movei	ch1, im.eop	; Erase to End Of Page
	jrst	 px0Put


im.dCP:	movei	ch1, im.cp	; Clear Memory 
	jrst	 pxy0Pu


	LIT
	subttl Datamedia 2500 display dependent routines

;			      DATAMEDIA
;			      =========

deftty(dm,dm2500)

	dm.mX	__ =79
	dm.mY	__ =23
	dm.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc+f%blm

;		   DATAMEDIA display commands

	dm.hom	__  2	; ^B
	dm.lef	__ 10	; ^H = BS
	dm.dow	__ 12	; ^J = LF
	dm.LCA	__ 14	; ^L = FF
	dm.blin	__ 16	; ^N
	dm.ital	__ 17	; ^O
	dm.inse	__ 20	; ^P
	dm.EOL	__ 27	; ^W
	dm.unlo	__ 30	; ^X
	dm.up	__ 32	; ^Z
	dm.righ	__ 34	; ^\
	dm.roll	__ 35	; ^]
	dm.CP	__ 36	; ^^

	dm.IC	__ dm.righ
	dm.IL	__ dm.dow
	dm.DC	__ dm.lef
	dm.DL	__ dm.up

	dm.pch	__ RUB		;pad char
;local flags in F(LH)
	dmeat __   1		;1 iff have just performed auto n.l.
	dmfast __  2		;1 iff bps .ge.4800

dm.rese:
	setzb	px, py		; reset to be used by Dm.dCP
	tlz	f, insert!italic!blink!tty
dm.ate:	tlz	f, dmeat
	ret

dm.qui:	call	 dm.off
dm.ttOn:tlo	f, tty
	movei	ch2, dm.roll
	jrst	 putch2


dm.itOn:tlo	f, italic	; ; set flog only (the bright
;-jqj	ret			; ;  characters are protected!)

; ; ..and this is what it should be in the future
	movei	ch2, dm.ital
	jrst	 putch2


dm.blOn:tlo	f, blink
	movei	ch2, dm.blin
	jrst	 putch2


dm.inOn:tlz	f, blink	; I/D mode inhibits blink mode!!!
	tlo	f, insert
	movei	ch2, dm.inse
	jrst	 putCh2


dm.ini:	tlz	f, dmfast
	move	zero, bps
	caile	 =4800
	 tlo	f, dmfast		; faster than 2400 bps
dm.off:	tlz	f, insert!italic!blink!tty
	movei	ch2, dm.unlo
	jrst	 putCh2		; will RET


dm.dCh:	call	 dm.chkF	; will also INCX
	call	 putCh
	aoje	ch2, cpopj
	ret


dm.chkF: hlrz	zero, f		; get physical flags
	xor	zero, f		; AC0 _ PFLAGS xor F 
	trnn	zero, insert!italic!blink!tty  ; all flags match? 
	 jrst	 dm.inX		; ..yes
	andcm	zero, f		; ..no
	trne	zero, insert!italic!blink!tty  ; any flags to remove? 
	 call	 dm.off		; ..yes, clear all

	jumpe	f, dm.inX	; any flags to set?
	hlrz	tmp, f		; ..yes
	andca	tmp, f		; flags that need to be set, to TMP
	trne	tmp, insert
	 call	 dm.inOn
	trne	tmp, italic
	 call	 dm.itOn
	trne	tmp, tty
	 call	 dm.ttOn
	trne	tmp, blink
	 call	 dm.blOn	; inhibited by I/D mode

dm.inX:
	came	px, maxPX
	 aoja	px, dm.ate
	tlo	f, dmeat	; automatic new line
	setz	px,
	skipa
dm.inY:	tlz	f, dmeat
	came	py, maxPY
	 aoja	py, dm.liOv	; INC(PY)
	tlnn	f, tty
	 setz	py,
	ret

dm.liOv:	setz	ch2,
	trne	f, tty
	 seto	ch2,
	ret


dm.mov:	movei	zero, (x)
	addi	zero, (y)
	tlne	f, insert	; in I/D, MOVE and LCA require xtra char
	 subi	zero, 1		; ac0:  bytes through HOME (-1 if in I/D)

	movei	t1, (delX)
	addi	t1, (delY)	; ac1:  bytes by incrementing (-1 if in I/D)

  ; what is the fastest move?
	caige	zero, (t1)
	 jrst	 dm.hOK		; home wins over move
	caig	t1, 3		; home loses
	 jrst	 relmov		; move wins.  Use common move routine
	jrst	 dm.dLC		; LCA wins

dm.hOK:	cail	zero, 3		; close to home?
	 jrst	 dm.dLC		; ..no, do LCA
	call	 dm.dHo		; ..yes 
	jrst	 relmov		; use common move (w/o CR)


dm.dLC:	movei	ch1, dm.lca	; do absolute move
	call	 dm.noID
	movei	px, (x)
	movei	ch1, (x)
	trc	ch1, 140
	call	 putCh1
	movei	py, (y)
	movei	ch1, (y)
	trc	ch1, 140
	jrst	 putCh1		; will RET


dm.dRi:	movei	ch1, dm.righ
	call	 dm.noID
	jrst	 dm.inX


dm.dDo:	movei	ch1, dm.dow
	call	 dm.noid	; do it
	tlze	f, dmeat	; except that after wrap, LF gets
	 call	 putch1		; ..eaten, so send another
	jrst	 dm.inY		; account for down one


dm.dLe:	jumpe	px, cpopj	; already at left margin?
	soj	px,
	movei	ch1, dm.lef

	; falls to  Dm.NOID

dm.noID:			; accepts char in  CH1
	tlne	f, insert
	 call	 dm.off
	jrst	 putCh1


dm.dUp:	jumpe	py, cpopj	; already on top line?
	movei	ch1, dm.up
	soja	py, dm.noID	; DEC(PY)


dm.dHo:	call	 dm.rese	; home cursor 
	movei	ch1, dm.hom
	jrst	 putCh1


dm.dLF:	tlne	f, insert	; for last line LF only, to scroll
	 call	 dm.off
	tlnn	f, tty
	 call	 dm.ttOn
	movei	ch1, LF
	jrst	 putCh1


dm.dIC:	movei	ch1, dm.ic

	; falls to  Dm.dID

dm.dID:	tlnn	f, insert	; command character is in CH1
	 call	 dm.inOn
	call	putCh1
	movei	ch1, dm.pch	; one fill for .le.4800 bps DM, two otherwise
	tlnn	f, dmfast
	 jrst	 putCh1
	movei	 n1, 2		; "fast" Datamedia, pad twice
	jrst	 putNC1

dm.dIL:	movei	ch1, dm.IL
	call	 dm.dID
  ; put  ((30-py)*bps - 2400) DIV 14400  padding characters
	movei	n1, =30
	subi	n1, (py)
	imul	n1, bps
	subi	n1, =2400
	idivi	n1, =14400	; NOTE:  Clobbers  TMP!
;-----
	tlnn	f, dmfast
	 subi	n1, 1
	movei	ch1, dm.pch
	jrst	 putNC1


dm.dDC:	movei	ch1, dm.dc
	jrst	 dm.dID


dm.dDL:	movei	ch1, dm.dl
	jrst	 dm.dID


dm.dEL:	movei	ch1, dm.eol	; Erase to End Of Line
	jrst	 putCh1


dm.dEP:

;-pk;	call	 dm.dDL		; Erase to End Of Page.  CH1 gets Dm.DL
;	movei	n1, dm.mY
;	subi	n1, (py)
;-pk;	jrst	 putNC1

	push	p, x		;+pk;
	setz	x,		;
	call	 chkXY		;
	skipa			;
dm.dE1:	 call	 dm.dDo		;
	call	 dm.dEL		;
	camge	py, maxPY	;
	 jrst	 dm.dE1		;
	pop	p, x		;
	ret			;+pk;


dm.dCP:	call	 dm.rese	; Clear Memory
	movei	ch1, dm.cp
	jrst	 putCh1


	LIT

	subttl Hazeltine 1500 display dependent routines

;			HAZELTINE
;			=========

deftty(hz,haz1500)

	hz.mY== =23
	hz.mX== =79
	hz.FEA== f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%lc+f%ital

	hz.BOX=="*"		;used by the translation
	hz.bi== =31		;begin italics
	hz.ei== =25
	hz.hom==ctl(R)		;22
	hz.up==ctl(L)		;14
	hz.dow==ctl(K)		;13
	hz.right==ctl(P)	;20
	hz.lef==ctl(H)		;10
	hz.ldch==176		;tilde, H1500 lead-in character
	hz.eol==ctl(O)		;17
	hz.eop==ctl(X)		;30
	hz.il==ctl(Z)		;32
	hz.dl==ctl(S)		;23
	hz.CP==34		;^\
	hz.LCA==ctl(Q)		;21
	hz.pch==RUB		;RUBOUT = pad char 


hz.ini:	tlz f,pital		; we don't think we're in italic mode
	jrst hz.qui		; really clear it.


;Move routine copied from hp.mov
hz.mov:	movei	zero, (x)	; calculate distance from home
	addi	zero, (y)
	addi	zero, (y)	; vertical movement needs leadin

	skipe	t1, x		; if x=0, then can use CR
	 hrrei	t1, -1(delX)	; t1:=#chars needed-1
	addi	t1, (delY)	; ac1:  bytes by incrementing
	addi	t1, (delY)	; vertical movement needs leadin

  ; what is the fastest move?
	caige	zero, (t1)
	 jrst	 hz.hok		; home wins over move
	caig	t1, 3		; home loses
	 jrst	 relmCR		; move wins
	jrst	 hz.dLC		; LCA wins

hz.hok:	cail	zero, 3		; close to home?
	 jrst	 hz.dLC		; ..no, do LCA
	call	 hz.dHo		; ..yes.  Do home followed by incremental
	jrst	 relmov		; do relative move

hz.dLC:	movei px,(x)
	movei py,(y)
hz.dL0:	movei ch1,hz.LCA	;to here if px,py already set up
	call hz.lead		; as destination of move
	movei ch1,140(px)
	cail ch1,177
	subi ch1,140
	call putch1
	movei ch1,40(py)
	jrst putch1


hz.dCh:	cain ch,hz.ldch
hz.dBx:	 movei ch,hz.BOX	;translate tilde into Box
	trnn f,insert		;if not insert mode, then
	 jrst hz.dc0		; just send the char
	call hz.dIC		; make room
	call hz.mov		;put the cursor back

hz.dc0:	trne f,italic		;italic mode?
	 jrst [	call hz.ion	;yes.  Make sure pital is on
		jrst hz.dc1 ]
	call hz.iof		;no.  Turn off pital
hz.dc1:	came px,maxPX
	 aoja px,putCh
	setz px,
	came py,maxPY
	 aoja py,putCh
	trnn f,tty
	 jrst hz.dHO		;go home and forget about writing the char
	call putCh		;write the char to output buffer
	movei ch1,CR		;send CRLF
	call putch1
;fall through to hz.dLF

hz.dLF:	movei ch1,LF
	jrst putch1

hz.ion:	tloe f,pital		;set italic
	 ret			;already set.
	movei ch1,hz.bi		;send foreground-follows
	jrst hz.lead


hz.iof:	tlzn f,pital		;clear italic
	 ret			;already clear

hz.qui:	movei ch1,hz.ei		;send background-follows

;fall through to hz.lead
hz.lead:	push p,ch1
	movei ch1,hz.ldch
	call putch1
	pop p,ch1
	jrst putch1


;;;  NOTE:  TELERAY TIMING IS USED FOR NOW  /pk

hz.dIL:	skipa	ch1, [hz.IL]					;+pk;
hz.dDL:	 movei	ch1, hz.DL
	setz	px,		;IL, DL takes you to col 0
	call	 hz.lead
; Try ~ .5 x 57 ms. worst case (center of screen is slowest):
;  (25 - py)*bps Div 4050  for  py Geq 12
;   (2 + py)*bps Div 4050  for  py < 12
	movei	n1, =25
	subi	n1, (py)
	caile	n1, =13
	 subi	n1, =27
	movm	n1, n1
	imul	n1, bps
	idivi	n1, =4050	; Up to .5 x 57 ms.
	movei	ch1, hz.pch
	jrst	 putNC1		; Send that many		;+pk;

hz.dDC:
hz.dIC:
	movei ch1,bel		; indicate illegal
	jrst putCh1


hz.dEL:	movei ch1, hz.eol
	call hz.lead
; Try ~ 4 ms. max:  (80 - px)*bps Div 188000		;+pk;
	movei	n1, =80
	subi	n1, (px)
	imul	n1, bps
	idivi	n1, =188000
	movei	ch1, hz.pch
	jrst	 putNC1		; Send that many	;+pk;

hz.dEP:	jumpe	px, hz.dE1				;+pk;
	movei	ch1, CR
	call	px0Put
hz.dE1:	movei	ch1, hz.eop
hz.dE2:	call	 hz.lead
; Try ~ 48 ms. worst case:  (25 - py)*bps Div 4700
	movei	n1, =25
	subi	n1, (py)
	imul	n1, bps
	idivi	n1, =4700	; Up to 48 ms.
	movei	ch1, hz.pch
	jrst	 putNC1		; Send that many

hz.dCP:	movei	ch1, hz.cp
	setzb	px, py
	jrst	 hz.dE2					;+pk;

hz.dHo:	movei	ch1,hz.hom
	setzb	px,py
	jrst	hz.lead

hz.dUp:	jumpe py,cpopj
	movei ch1,hz.up
	soja py,hz.lead

hz.dDo:	movei ch1,hz.dow
	camn py,maxPY
	 ret
	aoja py,hz.lead

hz.dLe:	movei ch1,hz.lef
	skipe px
	 soja px,putch1
	jumpe py,cpopj		;at (0,0) do nothing
	move px,maxPX		;otherwise, wrap to end of previous line
	soja py,putch1

hz.dRi:	movei ch1,hz.righ
	came px,maxPX
	 aoja px,putch1
	camn py,maxPY		;at (23,79) ?
	 ret			;yes, cursor stays put
	setz px,		;wrap cursor to start of next line
	aoja py,putch1

	LIT

	subttl VT52 display dependent routines

;				VT52
;				====


deftty(vt,vt52)


	vt.mX __ =79
	vt.mY __ =23
	vt.FEA  __ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lc

	vt.ldch  __ 33		;ESC
	vt.eol	__ "K"
	vt.hom	__ "H"
	vt.LCA	__ "Y"
	vt.eop	__ "J"

	vt.lef	__ ctl(H)	; or esc D
	vt.up	__ "A"		; esc A
	vt.righ	__ "C"		; esc C
	vt.dow	__ LF		; or esc D


tl.ini:	tl.qui:
vt.ini:	vt.qui:
	ret

vt.dCh:	trnn	f, insert
	 jrst	 vt.dC1
	call	vt.dIC		; ding a dong
tl.dC1:
vt.dC1:	camge	px, maxPX
	 aoja	px, putCh	; INC(PX)
	setz	px,
	camge	py, maxPY
	 aoja	py,[ call putCh
		     jrst vt.dL0 ]	; go to next line
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst	 vt.dHo		; No.  Don't write the character
	call	 putCh		; Write the character, and scroll
	call	 vt.dUp		; ..yes, cursor to lower left corner

; falls to  Vt.dLF
hp.dLF:
he.dLF:
tl.dLF:
vt.dLF:	movei	ch1, LF		; for last line LF only, to scroll
	jrst	 putCh1


; cursor movement.
;
;  The code on this and the next page is shared by Teleray and Heath
;  =================================================================

he.mov:
tl.mov:
vt.mov:	movei	zero, (x)	; calculate distance from home
	addi	zero, (y)	; i.e. 1/2 of cost

	skipe	t1, x		; if x=0 then can use CR, else
	 movei	t1, (delX)	; may use incremental cursor move
	addi	t1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
;+pk;		OPTIMIZING STILL NEEDS WORK

	caige	zero, (t1)
	 jrst	 vt.hOK		; home wins over move
	caig	t1, 2		; home loses
	 jrst	 relmCR		; do relative move, w/ CR if necessary
	jrst	 vt.dLC		; LCA wins

vt.hOK:	cail	zero, 2		; close to home?
	 jrst	 vt.dLC		; ..no, do LCA
	call	 vt.dHo		; ..yes 
	jrst	 relmov		; Now do relative move

ad.dLC:
he.dLC:
tl.dLC:
vt.dLC:	movei	py, (y)
	movei	px, (x)
ad.dL0:
he.dL0:
tl.dL0:
vt.dL0:	movei	ch1, vt.LCA	; do absolute move
	call	vt.lead		; requires leadin
	movei	ch1, " " (py)	; code for row
	call	 putCh1
	movei	ch1, " " (px)	; code for column
	jrst	 putCh1		; will RET


; The code on this page is shared by Teleray, Heath, and HP26xx
; =============================================================

; cursor movement, cont.

tl.dRi:
hp.dRi:
he.dRi:
vt.dRi:	caml	px, maxPX	; in range?
	 ret			; no.  Don't move
	movei	ch1, vt.righ
	aoja	px, vt.lead 	; INC(PX)

he.dDo:
hp.dDo:
tl.dDo:
vt.dDo:	caml	py, maxPY	; in range?
	 ret			; no.  We don't move anyway, so why bother?
	movei	ch1, vt.dow	; send LF
	aoja	py, putCh1	; INC(PY)

he.dLe:
hp.dLe:
tl.dLe:
vt.dLe:	jumple	px, cpopj	; don't move if already as far as can go
	movei	ch1, vt.lef	; send BS
	soja	px, putCh1	; no leadin required


he.dUp:
hp.dUp:
tl.dUp:
vt.dUp:	jumple	py, cpopj	; don't move if already as far as can go
	movei	ch1, vt.up
	soja	py, vt.lead

he.dHo:
hp.dHo:
vt.dHo:	movei	ch1, vt.hom	; home cursor 
	setz	py,
he.xput:
tl.xput:
	setz	px,
;	jrst	 vt.lead
tv.lead:
iq.lead:
cn.lead:
ad.lead:
in.lead:
he.lead:
hp.lead:
tl.lead:
vi.lead:
vt.lead: push	p, ch1
	movei	ch1, vt.ldch	; first, send lead character
	call	 putCh1
	pop	p, ch1
	jrst	 putCh1		; then, send function code

hp.dCP:
vt.dCP:
	call	vt.dHo		; Home cursor, then
	movei	ch1, vt.eop	; Erase to End Of Page
	jrst	 vt.lead


he.dEL:
vt.dEL:	movei	ch1, vt.eol	
	jrst	 vt.lead

he.dEP:
vt.dEP:	jumpe	px, vt.dE1
	movei	ch1, CR
	call	px0Put
vt.dE1:	movei	ch1, vt.eop	; Erase to End Of Page
	jrst	vt.lead


	; VT52 Insert/Delete -- no longer simulated

vt.dDC:
vt.dIC:
vt.dDL:
vt.dIL:
	movei	ch1, bel
	jrst	 putch1

	LIT

	subttl Soroc IQ120 display dependent routines

;				IQ120
;				=====


deftty(iq,IQ120)


	iq.mX __ =79
	iq.mY __ =23
	iq.FEA  __ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lc+f%ital

	iq.ldch  __ 33		;ESC
	iq.eol	__ "T"
	iq.hom	__ ctl(^)
	iq.LCA	__ "="
	iq.eop	__ "Y"

	iq.lef	__ ctl(H)
	iq.up	__ ctl(K)
	iq.righ	__ ctl(L)
	iq.dow	__ ctl(J)
	iq.bi	__ ")"		;italic=dim?
	iq.ei	__ "("		;roman=bold?


tv.ini:
iq.ini:	tlz	f, pital	;assume we're in italic

tv.qui:
iq.qui:	movei ch1,42		;send " to unlock keyboard
	call iq.lead
	movei ch1,"'"		;send ' to clear protect mode
	call iq.lead
;	jrst iq.iof		;clear italics

iq.iof:	tlzn	f, pital	;on?
	 ret
	movei	ch1, iq.ei	;turn it off
	jrst	 putch1

iq.ion:	tloe	f, pital	;does italic mode break EEOS?
	 ret
	movei	ch1, iq.bi
	jrst	 putch1

iq.dCh:	trnn	f, insert
	 jrst	 iq.dC0
	call	iq.dIC		; ding a dong

tv.dC0:
iq.dC0:	trne	f, italic	; italic requested?
	 call	 iq.ion		; yes.  Turn it on
	trnn	f, italic
	 call	iq.iof		; or turn it off
	camge	px, maxPX
	 aoja	px, putCh	; INC(PX)
	setz	px,		; overflow at right margin wraps, we presume
	camge	py, maxPY	; overflow at bottom of screen?
	 aoja	py, putCh	; presumably, we are now at right margin?
	trne	f, tty		; Last line.  Want to scroll?
	 jrst	putCh		; Yes.  If we want to scroll, we're ok.
	jrst	 iq.dHo		; otherwise, don't write the character!


; cursor movement.

tv.mov:
iq.mov:	movei	zero, (x)
	addi	zero, (y)	; calculate distance from home

	skipe	t1, x		; if x=0 then can use CR, else
	 movei	t1, (delX)	; may use incremental cursor move
	addi	t1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
;+pk;		OPTIMIZING STILL NEEDS WORK

	caige	zero, (t1)
	 jrst	 iq.hOK		; home wins over move
	caig	t1, 2		; home loses
	 jrst	 relmCR		; do relative move, w/ CR if necessary
	jrst	 iq.dLC		; LCA wins

iq.hOK:	cail	zero, 2		; close to home?
	 jrst	 iq.dLC		; ..no, do LCA
	call	 iq.dHo		; ..yes 
	jrst	 relmov		; now do relative move

tv.dLC:
iq.dLC:	movei	py, (y)
	movei	px, (x)
tv.dL0:
iq.dL0:	movei	ch1, iq.LCA	; do absolute move
	call	iq.lead		; requires leadin
	movei	ch1, " " (py)	; code for row
	call	 putCh1
	movei	ch1, " " (px)	; code for column
	jrst	 putCh1		; will RET


; cursor movement, cont.

tv.dRi:
iq.dRi:	movei	ch1, iq.righ
	came	px, maxPX
	 aoja	px, putch1 	; INC(PX)
	tdna	px, px		; px:=0, and skip

tv.dLF:
iq.dLF:	movei	ch1, iq.dow	; send LF to scroll
	camn	py, maxPY
	 seto	py,		; -1, incremented below
	aoja	py, putch1

tv.dDo:
iq.dDo:	caml	py, maxPY
	 ret
	movei	ch1, iq.dow	; would scroll
	aoja	py, putch1	; INC(PY)

tv.dLe:
iq.dLe:	jumple	px, cpopj
	movei	ch1, iq.lef	; send BS

tv.dUp:
iq.dUp:	jumple	py, cpopj
	movei	ch1, iq.up
	soja	py, putch1

iq.dHo:	movei	ch1, iq.hom	; home cursor 
	setzb	py, px
	jrst	 putCh1

iq.dCP:
	call	iq.dHo		; Home cursor, then
	movei	ch1, iq.eop	; Erase to End Of Page
	jrst	 iq.lead


tv.dEL:
iq.dEL:	movei	ch1, iq.eol	
	jrst	 iq.lead

tv.dEP:
iq.dEP:	jumpe	px, iq.dE1
	movei	ch1, CR
	call	px0Put
iq.dE1:	movei	ch1, iq.eop	; Erase to End Of Page
	call	iq.lead
	ret


	; IQ120 Insert/Delete

iq.dDC:
iq.dIC:
iq.dDL:
iq.dIL:
	movei	ch1, bel
	jrst	 putch1

	LIT

	subttl VT100 display dependent routines
 
;				VT100
;				=====

; We use the VT100 in ANSI mode.  Other ANSI things could share this code.
; Note, however, that the VT100 uses a very peculiar technique for
; insert and delete line.

deftty(vh,vt100)

	vh.mX __ =79
	vh.mY __ =23
	vh.FEA  __ f%dca+f%eeol+f%eeos+f%clp+f%lc+f%ital+f%home+f%udlr

	vh.ldch __ ESC		;first leadin
	vh.2ld	__ "["		;second leadin for ANSI commands
	vh.eol	__ "K"
	vh.LCA	__ "H"		;does home when args defaulted
	vh.eop	__ "J"

	;arguments for italic:
	vh.bi	__ 4		;begin underline (or possibly reverse video)
	vh.ei	__ 0		;turn off bright, reverse, blinking, and underline
	vh.it	__ "m"		;control italicization

	vh.lef	__ "D"
	vh.qle	__ ctl(H)	;for short distances
	vh.up	__ "A"
;	vh.qup	__ "E"		;esc E goes up--  non-ANSI
	vh.rig	__ "C"
	vh.dow	__ "B"
;	vh.qdo	__ LF		;for short distances
	vh.scu	__ "M"		; scroll up
	vh.idl	__ "r"		; for setting scrolling region
	vh.pch	__ RUB

ife oneseg,<
	RELOC
>;ife oneseg
scrlin:	block	1		; the top of the current scrolling region
ife oneseg,<
	RELOC
>;ife oneseg


; Set ANSI mode, set G0 and G1 char sets to ASCII, special graphics. select G1
; Clear scrolling region if any, reset scrolling (fast), origin mode
; (home), auto wrap (off),
vh.ini:	hrroi	ch1,[asciz/<(B)0/]
	call	putcom

vh.in0:	setzm	scrlin		; start with full screen
	movei	n1, 1
	call	vh.scr		; send $[r to clear scrolling region
	hrroi	ch1,[asciz/[?4;6;7l/]
	call	putcom
	tlo	f, pital	; assume italic is on
	jrst	vh.itf		; and turn it off


vh.qui:	call	vh.in0		; clear scrolling and italic mode
	jrst	moveXY		; put the cursor back where it should be.

vh.dBx:	call	vh.SFM		; set appropriate mode
	hrroi	ch1,[asciz/a/]	; shift to graphics, and display
	call	putcom		; a BOX or checkerboard, then clear graphics
	jrst	vh.inX		; now account

vh.SFM:	trne	f, insert
	 call	vh.dIC		; just beep
	trnn	f, italic	; italic mode?
	 jrst	vh.itf		; no.  Not either, so clear things
	jrst	 vh.itn


vh.dCh:	call	vh.SFM		; set modes
	call	 putCh		;we can write before accounting, since we don't
				;wrap at right margin
vh.inX:	camge	px, maxPX	;increment X
	 aoja	px, cpopj
	setz	px,
	movei	ch1, CR
	call	 putch1
	camge	py, maxPY
	 aoja	py, [	movei ch1, CR
			call putch1
			movei ch1, LF
			jrst putch1 ]	; go to next line
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst	 vh.dHo		; No.  Go home
	jrst	 vh.dLF		; yes.  Scroll whole screen

vh.itn:	tloe	f, pital
	 ret			;italic already set
	movei	n1, vh.bi
	jrst	vh.itx

vh.itf:	tlzn	f, pital
	 ret			;italic already cleared
	movei	n1, vh.ei
vh.itx:	movei	ch1, vh.it
	jumpn	n1,vh.arg	;send $[1m
	jrst	vh.2lead	;send $[m

; cursor movement.

vh.mov:	skiple	n1, scrlin
	 cail	y, -1(n1)	; Can't do relative motions out of scrolling
	  jrst	vh.moX		; region.
	movei	n1,1
	call	vh.scr		; Clear scrolling region, if necessary
	jrst	moveXY		; Recalculate delX and delY
; (note potential infinite loop if vh.scr doesn't reset scrolling)

; We don't have a scrolling region, so use complex moves
vh.moX:	movei	tmp, 3		; First, figure cost of LCA
	caile	x, 0
	 addi	tmp, 2
	caile	y, 0
	 addi	tmp, 1
	caile	x, =8
	 addi	tmp, 1
	caile	y, =8
	 addi	tmp, 1

	movei	t1, 1		; now, figure x-cost of relmov
	jumpe	x, vh.yco	; going to col. 1 is cheap
	caile	delX, =8
	 jrst [	movei t1, 5	; must use $[nnC or $[nnB
		jrst	vh.yco ]
	movei	t1, 4		; assume using $[nC or $[nB
	caig	x, (px)		; moving negatively?
	 jrst [	caig	delx, 3	; yes.  Use multiple BS?
		 move	t1, delx ;  yes.
		jrst	vh.yco ]
	cain	delx, 1
	 jrst [	movei	t1, 3	; can use $[C
		jrst	vh.yco ]
vh.yco:				;figure y-cost of relmov, similarly to x-cost
	caile	delY, =8
	 jrst [	addi t1,5	; must use $[nnA or $[nnD
		jrst vh.mo1 ]
	cail	y, (py)		; moving downwards?
	 jrst [	cail delY, 4	; yes.  A short way?
		 jrst .+1	;  no.  Use $[nD
		add t1,delY	; use multiple LFs
		jrst vh.mo1 ]
	addi	t1, 3		; use $[nD, $[A, or $[nA
	caile	delY, 1
	 addi	t1, 1

;note: we don't make quite full use of CR here, but how often do you
; move to column 2?  Not worth the hassle of a special case.
; we also don't make full use of HOME followed by LF.
vh.mo1:	
	camg	tmp, t1
	 jrst	vh.dLC		;LCA wins
	jrst	relmcr		;LCA loses -- use relative motion

vh.dDo:	move	n1, py
	subm	y, n1		; calculate n1:=y-py
	move	py, y		; we go there in one swell foop
	movei	ch1, LF		; maybe we can use LF
	caig	n1, 3		; if distance is short
	 jrst	 putnc1
	movei	ch1, vh.dow	; must use $[nB
	jrst	vh.1arg		; (or $[B)

vh.dUp:	move	n1, py
	subi	n1, (y)		; calculate n1:=py-y
	move	py, y		; we go there in one swell foop
	movei	ch1, vh.up
	jrst	vh.1arg		; via $[nA or $[A.  Don't use $E since some
				; ANSI terminals may not support it
vh.dLe:	move	n1, px
	subi	n1, (x)		; calculate n1:=px-x
	skipn	px, x		; we go there in one swell foop
	 jrst [	movei ch1, CR	; just use CR to go to column 1
		jrst putch1 ]
	movei	ch1, vh.qle	; via multiple BS if distance is short,
	caig	n1, 3
	 jrst	putnc1
	movei	ch1, vh.lef
	jrst	vh.arg		; else use $[nD

vh.dRi:	move	n1, px
	subm	x, n1		; calculate n1:=x-px
	move	px, x		; we go there in one swell foop
	movei	ch1, vh.rig	; using $[nC or $[C
	jrst	vh.1arg

vh.dHo:	setzb	px, py
	movei	ch1, vh.LCA	;do LCA with args defaulted
	jrst	vh.2lead

vh.dLC:	movei	py, (y)
	movei	px, (x)
vh.dl0:	jumpn	px, vh.dl1
	jumpe	py, vh.dHo	;we are going home--defaulting x and y
	movei	n1, 1(py)	;we are defaulting x
	movei	ch1, ";"
	call	vh.arg
	jrst	vh.dl5

vh.dl1:	jumpn	py, vh.dl2
	movei	ch1, ";"	;we are defaulting y
	call	vh.2lead
	jrst	vh.dl3

vh.dl2:	movei	ch1, ";"
	movei	n1, 1(py)
	call	vh.arg
vh.dl3:	movei	t1, 1(px)	; finish off the string
	call	putnum
vh.dl5:	movei	ch1, vh.LCA
	jrst	putCh1

vh.2lead:
	push	p, ch1
	movei	ch1, vh.ldch	;send first lead character
	call	putch1
	movei	ch1, vh.2ld	;send second lead character
	call	putch1
	pop	p, ch1		;then, send function code
	jrst	putch1

vh.1arg:
	cain	n1, 1		; default argument of 1
	 jrst	vh.2lead

vh.arg:	push	p, ch1		;writes leadins, decimal argument, and char
	push	p, n1
	movei	ch1, vh.ldch
	call	putCh1
	movei	ch1, vh.2ld
	call	putCh1
	pop	p, t1
	call	putnum
	pop	p, ch1
	jrst	putCh1

vh.dCP:	call	vh.dHo		; Home cursor, then
	movei	ch1, vh.eop	; Erase to End Of Page
	jrst	 vh.2lead	;   (ANSI erase-screen doesn't move cursor)

vh.dEL:	movei	ch1, vh.eol
	jrst	 vh.2lead

vh.dEP:	jumpe	px, vh.dE1	; move to left margin
	movei	ch1, CR
	call	px0Put
vh.dE1:	movei	ch1, vh.eop	;and erase to end of page
	call	vh.2lead

; Try 31 ms. worst case:  bps / 300
	movei	ch1, vh.pch	; padding
	move	n1, bps
	idivi	n1, =300
	jrst	putnc1


	; VT100 Insert/Delete -- with repeat counts of a sort

; Insert one or more lines
vh.dIL:	movei	n1, 1(py)	; start scrolling at current line
	camle	n1, maxPY	; require that scrolling region be 2
	 jrst	 vh.dlx		; lines or more
	call	vh.scr		; set scrolling region if necessary
	came	y,py		; are we in the right column?
	 call	vh.dlc		; go back to where we were for sure
				; (can't use relative motion here, since
				;  scrolling regions)
vh.dI0:	movei	ch1, vh.scu	; send $M to index up
	call	vt.lead
	call	vh.ilp		; do padding
	sosle	RCount
	 jrst	vh.dI0
	setzm	RCount
	ret


; Delete a line or lines
vh.dDL:	movei	n1, 1(py)	; start scrolling at current line
	camle	n1, maxPY	; require that scrolling region be 2
	 jrst	 vh.dlx		; lines or more
	call	vh.scr		; set scrolling region if necessary
	movei	px, 0		; stay in column 1
	move	py, maxPY	; go to bottom
	call	vh.dl0		; (can't use relative motion out of regions)
vh.dd1:	movei	ch1, LF
	call	putch1		; do a scroll
	call	vh.ilp		; pad
	sosle	RCount		; repeat for count
	 jrst	vh.dd1
	setzm	RCount
	ret


; LF at last line of display, to scroll
vh.dLF:	movei	n1, 1		; scroll whole screen
	call	vh.scr		; clear scrolling region if necessary
	movei	px, 0		; stay in column 1
	move	py, maxPY	; go to bottom
	call	vh.dl0		; (can't use relative motion out of regions)
	movei	ch1, LF
	call	putch1		; do a scroll
	jrst	vh.ilp		; pad

; Try 25 ms. worst case:  bps / 360
vh.ilp:	movei	n1, bps
	idivi	n1, =360
	movei	ch1, vh.pch
	jrst	putnc1

vh.dlX:	movei	n1, 2		; send $[2K to clear the current line instead
	movei	ch1, vh.eol	; (n.b. this code is not executed by vh.DLF)
	jrst	vh.arg


vh.scr:	camn	n1, scrlin	; is that already right?
	 ret			; yes.
	movem	n1, scrlin	; new scrolling region
	setzb	px, py		; setting the region takes us home
	cain	n1, 1		; if whole screen
	 jrst	vh.sc0		; just send $[r
	movei	ch1,";"		; send $[n;r
	call	vh.arg
	movei	ch1, vh.idl
	jrst	putch1
vh.sc0:	movei	ch1, vh.idl
	jrst	vh.2lead	; send $[r

vh.dDC:
vh.dIC:	movei	ch1, bel
	jrst	 putch1


	LIT

	subttl Ann Arbor Ambassador display dependent routines
 
;				Ambassador
;				==========

; We use the Ambassador in ANSI mode, sharing some code with the
; VT-100.  Note, though, that we can make use of repeat counts.

deftty(am,ambassador)

	am.mX __ =79
	am.mY __ =47		;We only use 48 lines to minimize padding
	am.FEA  __ f%dca+f%eeol+f%eeos+f%clp+f%lc+f%ital+f%home+f%udlr

repeat 0,<
;the following are identical with VT-100
	am.ldch __ ESC		;first leadin
	am.2ld	__ "["		;second leadin for ANSI commands
	am.eol	__ "K"
	am.LCA	__ "H"		;does home when args defaulted
	am.eop	__ "J"
	am.it	__ "m"		;control italicization

	am.lef	__ "D"
	am.qle	__ ctl(H)	;for short distances
	am.up	__ "A"
	am.rig	__ "C"
	am.dow	__ "B"
;	am.qdo	__ LF		;for short distances
	am.pch	__ RUB
>;repeat 0
;ambassador only
	;arguments for italic:
	am.bi	__ 1		;begin bold mode
	am.ei	__ 0		;turn off bright, reverse, blinking, and
				; underline
	am.il	__ "L"		; insert line
	am.dl	__ "M"		; delete line
	am.ic	__ "@"		; insert character
	am.dc	__ "P"		; delete character
;local state flags
	psem	__ 1		; Editing extent.  1=display, 0=line
	

; The Ambassador has several physical modes of interest.  It may be in 
;	Bold mode ( enter=$[1m, leave=$[m ).  We use pital
;	  to indicate which state (1=on).  Note that I/D C/L insert bold
;	  blanks if this mode is set.
;	Editing Extent: ( line=$[1Q, display=$[Q ).  We currently always 
;	  leave it in "line" mode, but could use psem for state.
;	Insertion-Replacement Mode ( insert=$[4h, replace=$[4l, toggle=$6 ).
;	  We use pinsrt for state (1=insert).

; send $[48;0;0;48p$[1Q$[m$[4;20l
;  to set screen size, editing extent=line, no italics, LF=LF, no insert
; send $[<25;30;35l$[<33h
;  to reset (clear) margin bell, destructive BS, DEL display.  Set wrap forward
am.ini:	tlz	f, pinsrt!pital!psem!ptty
	move	n1, maxPY
	addi	n1, 1		; convert to external notation
	caile	n1, =60		; maximum value is 60
	 movei	n1, =60
	movei	ch1, ";"
	call	am.arg		; send $[48;
	hrroi	ch1, [asciz/0;0;/]
	call	putcom
	move	ch1, maxPY
	addi	ch1, 1		; check that this is one of the allowable
	move	n1, [point 6,[	;   values, or take next larger if not
		byte (6) =18,=20,=22,=24,=26,=28,=30,=36,=40,=48,=60,0]]
am.in0:	ildb	t1, n1		; get a possible value
	caige	t1, (ch1)	; is it big enough?
	 jumpn	t1, am.in0	; no, try the next one.  For big screens,
	call	putnum		;  use 0 i.e. present value
	hrroi	ch1,[asciz/p[1Q[m[4;20l[<25;30;35l[<33h/]
	jrst	putcom

; clear italics, insert, wrap forward
am.qui:	hrroi	ch1,[asciz/[m[4l<33l/]
	call	putcom
	jrst	moveXY		; put the cursor back where it should be.


am.dCh:	trne	f, insert	; Insert mode?
	 jrst [	call am.icM	; enter insert mode, then!
		jrst am.dC1 ]
	call	am.icf		; exit insert mode
am.dC1:	trne	f, italic	; italic mode?
	 jrst [	call am.itn	; (use bold rather than inverse-video)
		jrst am.dc2 ]
	call	am.itf		; turn off italics
am.dc2:	camge	px, maxPX	; increment X
	 aoja	px, putCh	; ...and write the character
	setz	px,		; Cursor already wraps for us
	camge	py, maxPY	; Last line is special
	 aoja	py, putCh
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst	 am.dHo		; No.  Go home (we don't print the char)
	movei	ch1,CR		; yes.  Scroll whole screen (not VT-100)
	call	putch1		; ...first making sure we're at col 0
	jrst	 am.dLF		; then scroll


repeat 0,<
; Much of the complexity of this routine comes from wanting to handle
; repeat counts for DPYNCH, which doesn't work because InX is only called
; the first time in the high level routine.
	sosg	n1, RCount	; have we a repeat count?
	 jrst	am.dc3		; no
	movei	ch1,"b"		; repeat graphic
	call	am.arg
; we'll loop to here to account for multiple characters
am.dc3:	camge	px, maxPX	; increment X
	 aoja	px, am.dc4
	setz	px,		; Cursor already wraps for us
	camge	py, maxPY	; Last line is special
	 aoja	py, [	trne f,tty	; tty mode?
			skiple RCount	; and at end of repetition?
			 jrst am.dc4    ; no.  No problem.
			call am.dEL 	; yes -- clear new line
			jrst am.dc4 ]
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst [	call am.dHo	; No.  Go home (we're stuck at end of screen)
		skiple RCount	; at end of repetition?
		 jrst am.dc4	; yes.
		call incX	; account in high-level routine
		jrst am.dch ]	; no.  Start another count
	movei	ch1,CR		; yes.  Scroll whole screen (not VT-100)
	call	putch1		; ...first making sure we're at col 0
	call	 am.dLF		; then scroll
	skiple	RCount		; at end of repetition?
	 jrst [	call incX	; account for this character,
		jrst am.dch ]	; then start another count
am.dc4:	sosg	RCount		; still more characters to account for?
	 jrst [	setzm RCount	; just in case it has gone negative
		ret ]		; (the last char will be accounted in highlevel
	call	incX		; account for this character
	jrst	am.dc3		; and do another one
>;repeat 0

; must clear page mode here, then reset it after sending INDEX
am.dLF:	movei	ch1, LF
	jrst	putch1		; page mode temporarily


; Flip Insert/Replace mode
am.icM:	tloe	f, pinsrt	; Turn insert on
	 ret
	jrst	am.ic0
am.icf:	tlzn	f, pinsrt	; Turn insert off
	 ret
am.ic0:	movei	ch1, ESC
	call	putCh1		; Send ESC 6
	movei	ch1, "6"
	jrst	putCh1

; Turn on italics
am.itn:	tloe	f, pital
	 ret			;italic already set
	movei	n1, am.bi	;we use bold rather than underscore
	jrst	am.itx

;identical with VT-100
repeat 0,<
am.itf:	tlzn	f, pital
	 ret			;italic already cleared
	movei	n1, am.ei
am.itx:	movei	ch1, am.it
	jrst	am.arg
>;repeat 0

; cursor movement.  This page is shared with VT-100
am.mov==vh.moX
am.dDo==vh.dDo
am.dUp==vh.dUp
am.dRi==vh.dRi
am.dLe==vh.dLe
am.dLC==vh.dLC
am.dHo==vh.dHo
am.dEP==vh.dEP
am.dEL==vh.dEL
am.dCP==vh.dCP
am.itf==vh.itf
am.itx==vh.itx
am.arg==vh.arg
am.1arg==vh.1arg
am.2lead==vh.2lead

repeat 0,<
am.mov:	movei	tmp, 3		;first, figure cost of LCA
	caile	x, 0
	 addi	tmp, 2
	caile	y, 0
	 addi	tmp, 1
	caile	x, =8
	 addi	tmp, 1
	caile	y, =8
	 addi	tmp, 1

	movei	t1, 1		;now, figure x-cost of relmov
	jumpe	x, am.yco	; going to col. 1 is cheap
	caile	delX, =8
	 jrst [	movei t1, 5	; must use $[nnC or $[nnB
		jrst	am.yco ]
	movei	t1, 4		; assume using $[nC or $[nB
	caig	x, (px)		; moving negatively?
	 jrst [	caig	delx, 3	; yes.  Use multiple BS?
		 move	t1, delx ;  yes.
		jrst	am.yco ]
	cain	delx, 1
	 jrst [	movei	t1, 3	; can use $[C
		jrst	am.yco ]
am.yco:				;figure y-cost of relmov, similarly to x-cost
	caile	delY, =8
	 jrst [	addi t1,5	; must use $[nnA or $[nnD
		jrst am.mo1 ]
	cail	y, (py)		; moving downwards?
	 jrst [	cail delY, 4	; yes.  A short way?
		 jrst .+1	;  no.  Use $[nD
		addi t1,delY	; use multiple LFs
		jrst am.mo1 ]
	addi	t1, 4		; use $[nD or $[nA

;note: we don't make quite full use of CR here, but how often do you
; move to column 2?  Not worth the hassle of a special case.
; we also don't make full use of HOME followed by LF.
am.mo1:	
	camg	tmp, t1
	 jrst	am.dLC		;LCA wins
	jrst	relmcr		;LCA loses -- use relative motion

; routines on this page are shared with VT-100

am.dDo:	move	n1, py
	subm	y, n1		; calculate n1:=y-py
	move	py, y		; we go there in one swell foop
	movei	ch1, LF		; maybe we can use LF
	caig	n1, 3		; if distance is short
	 jrst	 putnc1
	movei	ch1, am.dow	; must use $[nB
	jrst	am.1arg		; (or $[B)

am.dUp:	move	n1, py
	subi	n1, (y)		; calculate n1:=py-y
	move	py, y		; we go there in one swell foop
	movei	ch1, am.up
	jrst	am.1arg		; via $[nA or $[A.  Don't use $E since non-ansi
	
am.dLe:	move	n1, px
	subi	n1, (x)		; calculate n1:=px-x
	skipn	px, x		; we go there in one swell foop
	 jrst [	movei ch1, CR	; just use CR to go to column 1
		jrst putch1 ]
	movei	ch1, am.qle	; via multiple BS if distance is short,
	caig	n1, 3
	 jrst	putnc1
	movei	ch1, am.lef
	jrst	am.arg		; else use $[nD

am.dRi:	move	n1, px
	subm	x, n1		; calculate n1:=x-px
	move	px, x		; we go there in one swell foop
	movei	ch1, am.rig	; using $[nC or $[C
	jrst	am.1arg

am.dHo:	setzb	px, py
	movei	ch1, am.LCA	;do LCA with args defaulted
	jrst	am.2lead

am.dLC:	movei	py, (y)
	movei	px, (x)
am.dl0:	jumpe	x, [	jumpe y, am.dHo		;we are going home
			movei	n1, 1(y)	;we are defaulting x
			movei	ch1, ";"
			call	am.arg
			jrst	am.dl5 ]
	jumpe	y, [	movei	ch1, ";"	;we are defaulting y
			call	am.2lead
			jrst	am.dl3 ]
	movei	ch1, ";"
	movei	n1, 1(y)
	call	am.arg
am.dl3:	movei	t1, 1(x)	; finish off the string
	call	putnum
am.dl5:	movei	ch1, am.LCA
	jrst	putCh1

; routines on this page are shared with VT-100

am.2lead:
	push	p, ch1
	movei	ch1, am.ldch	;send first lead character
	call	putch1
	movei	ch1, am.2ld	;send second lead character
	call	putch1
	pop	p, ch1		;then, send function code
	jrst	putch1

am.1arg:
	cain	n1, 1		; default argument of 1
	 jrst	am.2lead

am.arg:	push	p, ch1		;writes leadins, decimal argument, and char
	push	p, n1
	movei	ch1, am.ldch
	call	putCh1
	movei	ch1, am.2ld
	call	putCh1
	pop	p, t1
	call	putnum
	pop	p, ch1
	jrst	putCh1


am.dCP:	call	am.dHo		; Home cursor, then
	jrst	 am.dE1		; Erase to End Of Page
				;   (ANSI erase-screen doesn't move cursor)

am.dEL:	movei	ch1, am.eol
	jrst	 am.2lead

am.dEP:	jumpe	px, am.dE1	; move to left margin
	movei	ch1, CR
	call	px0Put
am.dE1:	movei	ch1, am.eop	;and erase to end of page
	call	am.2lead

; Try 31 ms. worst case:  bps / 300
; this may be too long for Ambassador.
	movei	ch1, am.pch	; padding
	move	n1, bps
	idivi	n1, =300
	jrst	putnc1

>;repeat 0

	; Ambassador Insert/Delete -- uses repeat counts for big win

am.dIL:	skipa	ch1, [am.il]	; send $[nL or $[L if n=1
am.dDL:	 movei	ch1, am.dl	; send $[nM to insert n lines
	jrst	am.RCarg

am.dIC:	skipa	ch1, [am.ic]	; send $[n@ to open space on this line
am.dDC:	 movei	ch1, am.dc	; send $[nP to delete the current character

am.RCarg:
	skipn	n1, RCount	; any repeat count?
	 jrst	am.2lead	; send $[<ch1> if n=0
	setzm	RCount		; clear repeat count
	jrst	am.1arg		; send $[n<ch1> or $[<ch1> if n=1



	LIT

	subttl Teleray display dependent routines

;				TELERAY
;				=======

deftty(tl,teleray)

	tl.mX	__ =79
	tl.mY	__ =23
	tl.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc

		; Teleray Display Commands

	tl.eol	__ "K"
	tl.IC	__ "P"
	tl.IL	__ "L"
	tl.LCA	__ "Y"
	tl.ldch  __ 33		;esc
repeat 0,<			;the following use VT52 codes
	tl.up	__ "A"
	tl.dow	__ "B"		;or LF
	tl.righ	__ "C"		;or space, which doesn't wrap
	tl.lef	__ "D"
	tl.hom	__ "H"
	tl.eop	__ "J"
>;repeat 0
	tl.CP	__ 14		;no leadin
	tl.DC	__ "Q"
	tl.DL	__ "M"
	tl.pch	__ RUB		;pad char



;***temporary***
tl.dBB:
tl.dEB:	movei	ch," "		;no blinking fields yet
	jrst	 tl.dch



tl.dCh:	trne	f, insert
	 call	 tl.dIC
	jrst	tl.dC1		;account and write character

tl.dCP:	movei	ch1, tl.CP	; Clear Screen
	call	 pxy0Pu
; Try 48 ms.:  (25 - 0)*bps Div 4700
	movei	n1, =25
	imul	n1, bps
	idivi	n1, =4700	; 48 ms.
	movei	ch1, tl.pch
	jrst	 putNC1		; Send that many

; tl.mov, tl.dLC, tl.dL0, tl.dHo, px0Put, tl.dUp, tl.dEL, tl.dc1
; ==============================================================
; use VT52 code
; =============

; the following routines are shared with HP26xx
; =============================================

hp.dEL:
tl.dEL:	movei	ch1, vt.eol	; Erase to End Of Line	;+pk;
	call	 vt.lead
; Try 4 ms. max:  (80 - px)*bps Div 1880
	movei	n1, =80
	subi	n1, (px)
	imul	n1, bps
	idivi	n1, =188000	; Fits in 1/2-wd
	movei	ch1, tl.pch
	jrst	 putNC1		; Send that many	;+pk;

hp.dEP:
tl.dEP:	jumpe	px, tl.dE1
	movei	ch1, CR
	call	px0Put
tl.dE1:	movei	ch1, vt.eop	; Erase to End Of Page
	call	 vt.lead
; Try 48 ms. worst case:  (25 - py)*bps Div 4700
	movei	n1, =25
	subi	n1, (py)
	imul	n1, bps
	idivi	n1, =4700	; Up to 48 ms.
	movei	ch1, tl.pch
	jrst	 putNC1		; Send that many	;+pk;

tl.dDL:	skipa	ch1, [tl.dl]	; Delete Line

tl.dIL: movei	ch1, tl.IL	; Insert Line
	call	 tl.xPut	; and indicate in col 1

; Try 57 ms. worst case:  (25 - py)*bps Div 4050
	movei	n1, =25
	subi	n1, (py)
	imul	n1, bps
	idivi	n1, =4050	; Up to 57 ms.

	movei	ch1, tl.pch
	jrst	 putNC1		; Send that many


	; Teleray Insert/Delete

tl.dIC:	skipa	ch1, [tl.ic]	; Insert Char

tl.dDC:	 movei	ch1, tl.dc	; Delete Char
;-pk;	jrst	 tl.lead
	call	 tl.lead				;+pk;
							;
; Try 4.5 ms. worst case:  (80 - px)*bps Div 162000	;
	movei	n1, =80					;
	subi	n1, (px)				;
	imul	n1, bps					;
	idivi	n1, =162000	; Fits in 1/2-word	;
	movei	ch1, tl.pch				;
	jrst	 putNC1		; Send that many	;+pk;


	LIT

	subttl Gillotine display-dependent routines

;			ALBATROSS, aka GILLOTINE
;			========================

deftty(gi,Gillotine)

	gi.mX	__ =79
	gi.mY	__ =23
	gi.fea	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc ; and others!

		; ALB Display Commands

	gi.left	__ 01	; ^A\
	gi.right__ 02	; ^B \
	gi.up	__ 03	; ^C  > cursor motion
	gi.dwn	__ 04	; ^D /
	gi.home	__ 05	; ^E/
	gi.LCA	__ 06	; ^F load cursor address
	gi.SI	__ 16	; ^N set bright
	gi.CI	__ 17	; ^O set normal intensity
	gi.rep	__ 22	; ^R load repeat count
	gi.DC	__ 24	; ^T delete character(s)
	gi.IC	__ 25	; ^U insert character(s)
	gi.DL	__ 26	; ^V delete line(s)
	gi.IL	__ 27	; ^W insert line(s)
	gi.CL	__ 30	; ^X clear line (not used)
	gi.CP	__ 31	; ^Y clear screen
	gi.LDX	__ 32	; ^Z cursor address within line
	gi.ldCh	__ 33	; ESC
	gi.EOL	__ 34	; ^\ clear to end of line
	gi.EOP	__ 35	; ^] clear to end of screen

  ; Command characters for ESCape sequences
	gi.wOff	__ "d"	; $d reset window to full screen
;	gi.cOff	__ "e"	; $e cursor off
	gi.cOn	__ "f"	; $f cursor on
	gi.page	__ "i"	; $i set page mode (normal inside)
	gi.scro	__ "j"	; $j set scroll mode

  ; Other characters
	gi.pch	__ RUB



; set page mode, clear italic, window.  Turn on cursor
gi.init:
	movei	ch1, gi.page
	call	 gi.lead

gi.rset:	movei	ch1, gi.CI
	call	 putCh1
	movei	ch1, gi.wOff
	call	 gi.lead
	movei	ch1, gi.cOn

gi.lead:	movei	ch2, gi.ldCh
	call	 putCh2		; first the lead character
	jrst	 putCh1		; then, send function code


; set scroll mode
gi.qui:	movei	ch1, gi.scro
	call	 gi.lead
	jrst	 gi.rset


gi.itn:	tloe	f, pital	; turn on italics
	 ret
	movei	ch1, gi.SI
	jrst	 putCh1

gi.itf:	tlzn	f, pital	; turn off italics
	 ret
	movei	ch1, gi.CI
	jrst	 putCh1

	

gi.dCh:	trne	f, insert
	 call	 gi.dIC
	trne	f, italic	; in italics?
	 jrst [	call gi.itn	; yes.  Make sure physically
		jrst gi.dc1 ]
	call	gi.itf
gi.dc1:	call	 putCh
	came	px, maxPX
	 aoja	px, cpopj	; INC(PX)
	setz	px,
	came	py, maxPY
	 aoja	py, cpopj	; INC(PY)
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 ret			; ..no
	skipa			; ..yes, simulate scroll

gi.dLF:				; for last line LF only
	 call	 gi.dHo		; simulate scroll
	call	 gi.dDL
	jrst	 gi.dLC
	

		; Alb Cursor Control

;;  NOTE:  CODE BELOW DOES NOT MAKE FULL USE OF  CR.  /pk

gi.mov:	movei	0, (x)
	addi	0, (y)

	movei	1, (delX)
	addi	1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
	caige	0, (1)
	 jrst	 gi.hok		; home wins over move
	caig	1, 3		; home loses
	 jrst	 relmov		; move wins.  Use common move routine
	jrst	 gi.trX		; LDX or LCA wins

gi.hok:	cail	0, 3		; close to home?
	 jrst	 gi.trX		; ..no, LDX or LCA
	call	 gi.dHo		; ..yes 
	jrst	 relmov		; use common move (w/o CR)


gi.trX:	caie	py, (y)		; same line?
	 jrst	 gi.dLC		; ..no
	jumpn	x, gi.dLX
	movei	ch1, cr		; CR will do
	jrst	 px0Put
	
gi.dLX:	movei	ch1, gi.ldX	; move within a line
gi.dL1:	call	 putCh1
	movei	px, (x)
	movei	ch1, 40(x)
	jrst	 putCh1


gi.dLC:	movei	ch1, gi.LCA	; do absolute move
	call	 gi.dL1
	movei	py, (y)
	movei	ch1, 40(y)
	jrst	 putCh1


		; More Alb Cursor Controls

gi.dRi:	camn	px, maxPX	; already at right margin?
	 ret			; ..yes, stick
	movei	ch1, gi.righ
	aoja	px, putCh1 	; INC(PX)
	

gi.dDo:	camn	py, maxPY
	 ret
	movei	ch1, gi.dwn
	aoja	py, putCh1	; INC(PY)


gi.dLe:	jumpe	px, cPopJ
	movei	ch1, gi.left
	soja	px, putCh1


gi.dUp:	jumpe	py, cPopJ
	movei	ch1, gi.up
	soja	py, putCh1


gi.dHo:	movei	ch1, gi.home	; home cursor 
	jrst	 pxy0Pu


		; Alb Insert, Delete, Erase

;;;  NOTE:  TELERAY TIMING IS USED FOR THE TIME BEING  /pk

gi.dIC:	skipa	ch1, [gi.ic]
gi.dDC:	 movei	ch1, gi.dc
	call	 gi.drep
; Try ~ 4.5 ms. worst case:  (80 - px)*bps Div 162000
	movei	n1, =80
	subi	n1, (px)
	imul	n1, bps
	idivi	n1, =162000	; Fits in 1/2-word
	movei	ch1, gi.pch
	jrst	 putNC1


gi.dIL:	skipa	ch1, [gi.IL]
gi.dDL:	 movei	ch1, gi.dl
	call	 gi.drep
; Try ~ 4.5 ?? ms. worst case:  100*bps Div 162000 (jqj)
	movei	n1, =80
	imul	n1, bps
	idivi	n1, =162000	; Fits in 1/2-word
	movei	ch1, gi.pch
	jrst	 putNC1
	
; send character in ch1, using repeat count value from RCount
gi.drep:
	skipn	n1, RCount
	 jrst	 putCh1		;no repeat count
	setzm	 RCount
	movei	ch2,gi.rep	;load repeat count
	call	 putCh2
	movei	ch2,40(n1)
	call	 putCh2
	jrst	 putCh1

gi.dEL:	movei	ch1, gi.EOl	; Erase to End Of Line
	call	 putCh1
; Try ~ 4 ms. max:  (80 - px)*bps Div 188000
	movei	n1, =80
	subi	n1, (px)
	imul	n1, bps
	idivi	n1, =188000	; Fits in 1/2-wd
	movei	ch1, gi.pch
	jrst	 putNC1		; Send that many


gi.dEP:	jumpe	px, gi.dp1
	movei	ch1, CR
	call	 px0Put
gi.dp1:	movei	ch1, gi.EOP	; Erase to End Of Page
gi.dp2:	call	 putCh1
; Try ~ 48 ms. worst case:  (25 - py)*bps Div 4700
	movei	n1, =25
	subi	n1, (py)
	imul	n1, bps
	idivi	n1, =4700	; Up to 48 ms.
	movei	ch1, gi.pch
	jrst	 putNC1		; Send that many


gi.dCP:	movei	ch1, gi.cp	; Clear Screen
	setzb	px, py
	jrst	 gi.dp2

	LIT
	subttl Heath display dependent routines

;				HEATH
;				=====

deftty(he,heath)

	he.mX	__ =79
	he.mY	__ =23
	he.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc+f%blm

		; Heath Display Commands

	he.bin	__ "@"		; begin insert mode
	he.ein	__ "O"		; end insert mode
	he.DC	__ "N"		;delete char.

	he.IL	__ "L"		; same as Teleray
	he.DL	__ "M"		; same as Teleray
	he.ldch  __ 33		;esc
repeat 0,<			;the following use VT52 codes
	he.up	__ "A"
	he.dow	__ "B"		;or LF, which scrolls
	he.righ	__ "C"		;or space, which doesn't wrap
	he.lef	__ "D"
	he.hom	__ "H"
	he.eop	__ "J"
	he.LCA	__ "Y"
	he.eol	__ "K"
>;repeat 0
	he.CP	__ "E"
	he.bli	__ "p"		;begin italic (reverse video) mode
	he.ebl	__ "q"		;end italic (reverse video) mode


; set insert and italic modes appropriately
he.SFM:	trne	f, insert	; inserting?
	 jrst [	call he.ion	; turn on  hardware  insert
		jrst he.sf0 ]
	call	 he.iof
he.sf0:	trne	f, italic	; italic mode
	 jrst	 he.itn		; yes.  turn on reverse video
	jrst	 he.itf		; no.  Make sure rev. video is off

; turn insert mode on
he.ion:	tloe	f, pinsrt	; in hardware insert mode already?
	 ret			; yes
	movei	ch1, he.bin
	jrst	 he.lead

he.iof:	tlzn	f, pinsrt	; turn insert mode off
	 ret
	movei	ch1, he.ein
	jrst	 he.lead

; turn italic mode on
he.itn:	tloe	f, pital	; in  hardware mode already?
	 ret			; yes
	movei	ch1, he.bli
	jrst	 he.lead

he.itf:	tlzn	f,pital		; turn italic mode off
	 ret
	movei	ch1, he.ebl
	jrst	 he.lead

he.ini:	tlo	f, pinsrt!pital	; assume in hardware insert, italic
;	jrst	 he.qui
he.qui:	call	 he.iof		; clear insert & italic modes
	jrst	 he.itf


; write a BOX character
he.dBx:	call	he.SFM		; set modes
	hrroi	ch1,[asciz/FiG/]
	call	putCom
	jrst	he.inx		; write character then account

; write an ordinary character in Ch
he.dCh:	call	he.SFM
	call	putCh
he.inx:	camge	px, maxPX
	 aoja	px, cpopj	; INC(PX)
	setz	px,
	camge	py, maxPY
	 aoja	py,he.dL0	; go to next line
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst	 he.dHo		; No.
	movei	ch1,CR
	call	putCh1		; to beginning of line
	jrst	he.dLF		; LF to scroll

; he.mov, he.dLC, he.dL0, he.dHo, he.xPut, and he.dUp
; ===================================================
; use VT52 code
; =============




; n.b. can't pad Heath for he.dCP, he.dEL, he.dEP

he.dCP:	movei	ch1, he.CP	; Clear Screen
	setzb	px, py
	jrst	 he.lead


he.dDL:	skipa	ch1, [he.dl]	; Delete Line

he.dIL: movei	ch1, he.IL	; Insert Line
	jrst	 he.xPut	; and indicate in col 1
;n.b. can't pad Heath.


	; Heath Insert/Delete char

he.dIC:	call	 he.ion		; Insert Char on
	movei	ch1, " "	; PutCh1 doesn't increment PX
	call	 putch1
	aoja	px,he.dLe	; So we increment here before jumping

he.dDC:	 movei	ch1, he.dc	; Delete Char
	jrst	 he.lead

	LIT

	subttl HP26xx display dependent routines

;				HP26XX
;				======

deftty(hp,hp26xx)

	hp.mX	__ =79
	hp.mY	__ =23
	hp.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc+f%ital+f%blm

		; HP26xx Display Commands

	hp.ldch  __ 33		;esc
repeat 0,<			;the following use VT52 codes
	hp.up	__ "A"
	hp.dow	__ "B"		;or LF, which scrolls
	hp.righ	__ "C"		;or space, which doesn't wrap
	hp.lef	__ "D"
	hp.hom	__ "H"
	hp.eop	__ "J"
>;repeat 0
repeat 0,<			;the following use Teleray codes
	hp.eol	__ "K"
	hp.IL	__ "L"
	hp.DL	__ "M"
>;repeat 0
	hp.LCA	__ "&"
	hp.DC	__ "P"
	hp.bbl	__ "A"		;begin rev. video (blink mode)
	hp.bit	__ "B"		;begin italics
	hp.efm	__ "@"		;end formatted area (rev. video or italic)
	hp.pch	__ RUB		;pad char

	hp.bin	__ "Q"		;begin insert mode
	hp.ein	__ "R"		;end insert mode


hp.qui:	ret


;temporary?
hp.dBB:
hp.dEB:	movei	ch1," "		;no blinking fields
	jrst	 hp.dCh


;set format based on ch1
hp.sfm:	push	p, ch1		; do format change
;	tlo	f, pblink	; removed by ejs, 10/2 Why set blink???
	movei	ch1, "&"
	call	 hp.lead
	movei	ch1, "d"
	call	 putch1
	pop	p, ch1
	jrst	 putch1

hp.ini:	tlz	f, pinsrt!pblink!pital	;start out not in hardware insert mode
	movei	ch1, "Z"	;clear display mode, etc.
	call	 hp.lead
	movei	ch1, hp.efm
	jrst	hp.sfm

hp.dCh:	trne	f, insert
	 jrst [	call hp.ion	;turn on insert mode in hardware
		jrst hp.dC0 ]
	call	 hp.iof
hp.dC0:	trnn	f, italic
	 jrst	 hp.dc1
	movei ch1,hp.bit	;turn on italics.  For us, blink!italic=italic
	tlon f,pital		;already hardware italic?
	 call hp.sfm		;no
	jrst hp.dc2
hp.dc1:	trne	f, blink	;in blink mode?
	 jrst [	movei ch1,hp.bbl
		tlon f,pblink	;in hardware blink mode?
		 call hp.sfm	;no.
		jrst hp.dc2 ]
hp.dc2:	call	 putCh		;send the character itself
	tlze	f, pblink!pital	;are either on physically?
	 jrst [	movei ch1,hp.efm ;turn off italics and blink now
		call hp.sfm	;this is quite inefficient for lines containing
		jrst hp.inX ]	;words in italics!
hp.inX:	camge	px, maxPX
	 aoja	px, cpopj	; INC(PX)
	setz	px,
	camge	py, maxPY
	 aoja	py, hp.dL0	; Put us at beginning of next line, for sure
	setz	py,
	trnn	f, tty		; Last line.  Want to scroll?
	 jrst	 hp.dHo		; ..no
	call	 hp.dUp		; ..yes, cursor to lower left corner
	jrst	 hp.dLF		; for last line LF only, to scroll

hp.ion:	tloe	f, pinsrt	; in insert mode already?
	 ret			; yes
	movei	ch1, hp.bin
	jrst	 hp.lead

hp.iof:	tlzn	f, pinsrt	; in hardware insert mode?
	 ret
	movei	ch1, hp.ein
	jrst	 hp.lead



hp.mov:	movei	zero, (x)	; calculate distance from home
	addi	zero, (y)

	skipe	t1, x		; if x=0, then can use CR
	 movei	t1, (delX)
	addi	t1, (delY)	; ac1:  bytes by incrementing

  ; what is the fastest move?
	cail	zero, (t1)
	 jrst	 hp.mok		; move wins over home
	cail	zero, 4		; close to home?
	 jrst	 hp.dLC		; ..no, do LCA
	call	 hp.dHo		; ..yes.  Do home followed by incremental
	jrst	 relmov		; move in X dimension, then Y if necessary

hp.mok:	caig	t1, 4		; home loses
	 jrst	 relmCR		; move wins.  Relative move w/ CR
;	jrst	 hp.dLC		; LCA wins

hp.dLC:	movei	py, (y)
	movei	px, (x)
hp.dL0:	movei	ch1, hp.LCA	; do absolute move
	call	hp.lead		; requires leadin
	movei	ch1, "a"	; <ESC>&a30c15R
	call	 putch1
	push p,1
	push p,2
	movei	t1, (py)		; send row
	call	 putnum
	movei	ch1, "y"
	call	 putch1
	movei	t1, (px)
	call	 putnum
	pop p,2
	pop p,1
	movei	ch1, "C"
	jrst	 putch1


; Routines  hp.dRi, hp.dDo, hp.dLe, hp.dUp, hp.dHo, hp.dEP, hp.dEL,
; =================================================================
; hp.lead, hp.dCP use VT52 routines
; =================================

; hp.dEL, hp.dEP, hp.dDL, hp.dIL use Teleray routines
; ===================================================


	; HP26xx Insert/Delete

hp.dIL: skipa 	 ch1,[tl.IL]
hp.dDL:	movei	 ch1,tl.dl
	call	 tl.xPut	; and indicate in col 1

; Try xx ms. worst case:  (25 - py)*bps Div 10000
	movei	n1, =25
	subi	n1, (py)
	imul	n1, bps
	idivi	n1, =10000	;

	movei	ch1, hp.pch
	jrst	 putNC1		; Send that many

hp.dIC:	call	 hp.ion		; Insert Char
	movei	ch1, " "
	aoja	px,putch1
	jrst	hp.dLe		; may need some padding


hp.dDC:	 movei	ch1, hp.dc	; Delete Char
	call	 hp.lead

; Try 4.5 ms. worst case:  (80 - px)*bps Div 1620
	movei	n1, =80
	subi	n1, (px)
	imul	n1, bps
	idivi	n1, =162000	; Fits in 1/2-word
	movei	ch1, hp.pch
	jrst	 putNC1		; Send that many


	LIT

	subttl Televideo 912 display dependent routines

;			TELEVIDEO 912
;			=============

deftty(tv,tvi)

	tv.mY== =23
	tv.mX== =79
	tv.FEA	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%lc+f%ital+f%cid

repeat 0,<			;the following use Soroc codes
	tv.bi== ")"		;esc )
	tv.ei== "("		;esc (
	tv.hom==ctl(^)
	tv.up==ctl(K)
	tv.dow==ctl(J)
	tv.right==ctl(L)
	tv.lef==ctl(H)
	tv.ldch==33
	tv.eol=="T"		;esc T
	tv.eop=="Y"		;esc Y
	tv.LCA=="="		;esc =
>;repeat 0
	tv.il=="E"		;esc E
	tv.dl=="R"		;esc R
	tv.dc=="W"		;esc W
	tv.ic=="Q"		;esq Q
	tv.CP==ctl(Z)
	tv.BB=="^"		;esc ^ begins blinking field
	tv.EB=="q"		;esc q ends blinking field
	tv.pch==RUB		;pad char

comment \
	Note that the Televideo 912/920 is almost a direct superset
	of the old Soroc IQ120.  Most of the Soroc code is used by
	the below.  Note also that this code (except the italic mode
	and blinking field?) should work correctly for the ADM31 and
	ADM42.
\



;***temporary***
tv.dBB:	movei	ch1, tv.bb	;begin blink
	jrst	 tv.lead	;requires leadin

tv.dEB:	movei	ch1, tv.eb	;end blink
	jrst	 tv.lead

tv.dCh:	trne f,insert		;if in insert mode, then
	 call tv.dIC		; make room
	jrst tv.dC0
	

tv.dDL:	movei ch1,tv.dl
	setz px,		;DL on tvi takes you to col 0.
	call tv.lead
	jrst tv.pad		;may want to use separate padding?

tv.dIL:	movei ch1,tv.il
	setz px,		;IL on tvi takes you to col 0.
	call tv.lead

;the following is definitely too long, but it works.
;try: (abs(15.-py)*bps) div 1200.
tv.pad:	movei n1,=15
	subi n1,(py)
	movm n1,n1
	imul n1,bps
	idivi n1,=1200
	movei ch1,tv.pch
	jrst putNC1


tv.dDC:	skipa	ch1, [tv.dc]	;Delete char
	
tv.dIC:	movei	ch1, tv.ic	;Insert char
	call	 tv.lead
	movei	n1, 10		;some padding for char ins/del too
	movei	ch1, tv.pch	; again, the amount is not right.
	call	 putNC1


tv.dCP:	movei ch1,tv.CP
	setzb px,py
	call tv.lead
	movei n1,=15		; too much padding
	movei ch1,tv.pch
	jrst putNC1

	LIT

	subttl Infoton 400 display dependent routines

;			      INFOTON 400
;			      ===========

deftty(in,Infoton)

	in.mX	__ =79
	in.mY	__ =23
	in.fea	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%lid+f%cid+f%lc

;		   INFOTON display commands

	in.roll  __ 121  ; Q

	in.home	__ 110	; H
	in.left	__ 104	; D
	in.dwn	__ 102	; B
	in.LCA	__ 110	; H
	in.eol	__ 116	; N
	in.unlo  __ 154  ; l
	in.up	__ 101	; A
	in.righ	__ 103	; C
	in.CP	__ 112	; J

	in.IC	__ 150	; h
	in.IL	__ 114	; L
	in.DC	__ 120	; P
	in.DL	__ 115	; M

	in.pch	__ 177

	in.ldch __ 33	; ESC



;The I400 has two physical modes of interest:
;  insert, in which all characters are inserted
;  roll, as usual.  In roll mode, insert character moves the whole
;	rest of the page, so we have to clear it to do insert.  In
;	non-roll mode, ins/del line is a no-op, so we set roll to
;	do these.  We use TTY in physical flags to indicate roll. 


in.quit:			;turn on tty, off others
	call in.iof		;insert off
	callret in.ton		;tty on

in.init:			;start in known state - all modes off
	tlo f,insert!tty	;pretend they are on now
	call in.iof
	callret in.tof

;here begin the routines to set and clear physical modes - tty and insert

in.tof:	tlzn f,tty		;is it on?
	 ret			;no.  No work needed
	movei ch1,"2"		;tty(roll) off: $ 2 Q
	call vt.lead		;put with ESC leadin
	movei ch1,in.roll
	callret putch1

in.ton:	tloe f,tty
	 ret			;already on
	movei ch1,in.roll	;tty(roll) on: $ Q
	callret vt.lead

in.ion:	tloe f,insert
	 ret
	movei ch1,"4"		;insert on: $ 4 h
	call vt.lead
	movei ch1,in.ic
	callret putch1

in.iof:	tlzn f,insert
	 ret
	movei ch1,"4"		;insert off: $ 4 l
	call vt.lead
	movei ch1,in.unlo
	callret putch1



in.dCh:	call in.chf		;will also INCX
	callret putCh		;line clearing handled by highlevel routine

in.chf:	;sets physical flags as requested in F and does INCX
	hlrz tmp,f		;geet actual flags
	trc tmp,(f)		;tmp _ request xor actual
	trnn tmp,insert		;is insert ok?
	jrst in.cht		;yes - check tty
	trne f,insert		;requested on?
	call in.ion		; yes - put it on
	trnn f,insert
	call in.iof		; no - put it off
in.cht:	trne f,insert		;tty is not critical if not in insert
	trnn tmp,tty		;is tty ok?
	jrst in.inX		;yes - done with checking
	trne f,tty		;requested on
	call in.ton		; yes - put it on
	trnn f,tty
	call in.tof		; no - put if off

in.inX:	came px,maxPX		;overflow line?
	 aoja px,cpopj		;no - incr x and exit
	setz px,		;now at LH side
	;callret incy		;on next line

in.inY:	came py,maxPY		;overflow screen?
	 aoja py,cpopj		;no - incr y and exit
	tlnn f,tty		;if not in roll mode
	 setz py,		;then now at top
	ret

in.move:	;move to x,y from px,py.  Has to choose between direct
	; cursor addressing (LCA) or moving with horizontal and
	; vertical moves.  On I400 home and then move is dominated
	; by LCA, so it need not be considered.
;first we compute the cost of moving with horizontal and vertical moves
	movei zero,(delx)		;number of ^H's
	caile x,(px)
	addi zero,1		;except if move right, needs $
	caile zero,3		;3 is maximum, $nX
	movei zero,3
	caile delx,=9		;excpet if bigger than 9, n is 2 digits
	addi zero,1
;  now the same for vertical
	movei 1,(dely)
	caile y,(py)
	addi 1,1
	caile 1,3
	movei 1,3
	caile dely,=9
	addi 1,1
;  now combine for total cost - 0 _ cost of move
	addi zero,(1)
;now compute cost of LCA
	movei 1,5		;5= $y;xH
	cain y,0
	subi 1,1		;but if y is zero, no y
	cain x,0
	subi 1,2		;if x is zero, no ;x
	caile y,=8		; [would be 9, but will add 1 later]
	addi 1,1		;if y is two digits, accounts
	caile x,=8
	addi 1,1
;now compare lca and move
	cail zero,(1)
	jrst in.dlc		;LCA is faster
;move is faster - now do it
;  horizontal move:
	movei zero,(px)
	subi zero,(x)		;0 _ - delta x
	cail zero,0		;if 0 to 2 inclusive
	caile zero,2
	jrst in.mx2		;outside that range
;  0 to -2: use ^H
in.mx1:	cain x,(px)		;while x <> px do
	jrst in.mvY
	call in.dle		;move left with ^H
	jrst in.mx1
;  outside 0 to -2, use $nX form
in.mx2:	call putesc		;$
	movei t1,(x)		;abs(delta x)
	subi t1,(px)
	movm t1,t1
	call in.pnm
	movei ch1,in.righ	;X appropriate to direction
	caig x,(px)
	movei ch1,in.left
	movei px,(x)		;account for move
	call putch1
;vertical move
in.mvY:	movei zero,(y)
	subi zero,(py)		;0 _ delta y
	cail zero,0		;if in range 0 to 2
	caile zero,2
	jrst in.my2		;not
in.my1:	cain y,(py)		;yes - use LF
	 ret
	call in.ddo
	jrst in.my1
in.my2:	call putesc
	movei t1,(y)
	subi t1,(py)
	movm t1,t1
	call in.pnm
	movei ch1,in.dwn
	caig y,(py)
	movei ch1,in.up
	movei py,(y)
	callret putch1

putesc:	movei ch1,33
	callret putch1

;put out a numeric argument
in.pnm:	caig t1,1		;one is default
	 ret			;so don't need it
	callret putnum		;write the number in 1, free format

in.dlc:	call putesc		;$ - do LCA - $y;xH
	movei t1,1(y)		;y
	caile t1,1		;    if y is 1, omit it
	call in.pnm
	movei t1,1(x)
	caig t1,1
	jrst in.dl1		;    if x is 1, omit it and ;
	movei ch2,";"		;;
	call putch2
	call in.pnm		;x
in.dl1:	movei ch1,in.lca		;H
	movei px,(x)
	movei py,(y)
	callret putch1

;here are the single cursor movement commands

in.dRi:	movei ch1,in.righ
	call vt.lead
	callret in.inX		;see where we are after move

in.ddo:	movei ch1,LF
	call putch1
	callret in.inY		;see where we are after move

in.dle:	jumpe px,cpopj		;if at left, don't do anything
	movei ch1,10
	soja px,putch1		;update px and go put out BS

in.dup:	jumpe py,cpopj		;if at top, don't do anything
	movei ch1,in.up
	soja py,vt.lead		;update py and put out with leadin

in.dho:	setzb px,py		;home
	movei ch1,in.home
	callret vt.lead

in.dLF: ; for last line LF only, to scroll 
	call in.ton		;turn on scroll if it is off
	movei ch1, LF
	callret putCh1


in.dIC:	call in.tof		;roll must be off
	call in.ion		;and insert on
	movei ch1,40		;insert a blank
	call putch1
	movei ch1,177		;pad
	call putch1
	movei ch1,10		;and back to starting position
	callret putch1

in.dIL:	call in.ton		;for insert-line, roll must be on
	movei ch1,in.il
	call vt.lead
	jrst in.dl2		;padding

in.dDC:	call in.tof		;roll must be off
	movei ch1,in.dc
	call vt.lead
	movei ch1,177
	callret putch1

in.dDL:	call in.ton		;roll must be on
	movei ch1,in.dl
	call vt.lead

in.dl2: move n1,bps		;padding
	idivi n1,=600
	movei ch1,in.pch
	callret putnc1

in.dEL:	movei ch1,in.eol	;erase to end of line
	callret vt.lead

;is this correct?
in.dEP:	jumpe px,in.dE1
	movei	ch1, CR
	call	px0Put
in.de1:	movei ch1,in.cp		;erase to end of page
	call vt.lead
	callret in.dl2		;pad

in.dcp:	setzb px,py
	movei ch1,"2"		;erase screen
	call vt.lead
	movei ch1,in.cp
	call putch1
	callret in.dl2		;pad

	LIT

	subttl Visual 200 display dependent routines
;			      VISUAL 200
;			      ==========

deftty(vi,Visual)

	vi.mX	__ =79
	vi.mY	__ =23
	vi.fea	__ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%lid+f%cid+f%lc

;		   VISUAL 200 display commands

	vi.home	__ 110	; H
	vi.left	__ 104	; D
	vi.dwn	__ 102	; B
	vi.LCA	__ 131	; Y
	vi.eol	__ 170	; x
	vi.eop	__ 171	; y
	vi.unlo  __ 152  ; j
	vi.up	__ 101	; A
	vi.righ	__ 103	; C
	vi.CP	__ 166	; v

	vi.IC	__ 151	; i
	vi.IL	__ 114	; L
	vi.DC	__ 117	; O
	vi.DL	__ 115	; M

	vi.pch	__ 177


	vi.ldch __ 33	; ESC




;The V200 has one physical mode of interest:
;  insert, in which all characters are inserted


vi.quit:
	callret vi.iof		;insert off

vi.init:tlo f,insert		;pretend insert is on, then
	callret vi.iof		; turn it off

;here begin the routines to set and clear physical modes - insert

vi.ion:	tloe f,insert		;turn on insert if not already
	 ret
	movei ch1,vi.ic
	callret vt.lead

vi.iof:	tlzn f,insert
	 ret
	movei ch1,vi.unlo
	callret vt.lead


vi.dCh:	call vi.chf		;will also INCX
	callret putCh

vi.chf:	;sets physical flags as requested in F and does INCX
	hlrz tmp,f		;actual flags
	trc tmp,(f)		;tmp _ request xor actual
	trnn tmp,insert		;is insert ok?
	jrst vi.inX		;yes - done with checking
	trne f,insert		;requested on?
	call vi.ion		; yes - put it on
	trnn f,insert
	call vi.iof		; no - put it off

vi.inX:	came px,maxPX		;overflow line?
	aoja px,cpopj		;no - incr x and exit
	ret			;yes - still at right side in real
				;VT52 mode

vi.inY:	came py,maxPY		;overflow screen?
	aoja py,cpopj		;no - incr y and exit
	ret			;still on bottom line (rolled)
;### should maybe back up one so doesnt actually roll?

vi.move:	;move to x,y from px,py.  Has to choose between direct
	; cursor addressing (LCA) or moving with horizontal and
	; vertical moves.  At the moment we are not considering home
	; and then move.
;first we compute the cost of moving with horizontal and vertical moves
	cain delx,0		;if to upper left, use home
	caie dely,0	
	jrst .+2
	jrst vi.dho
	movei zero,(delx)		;number of ^H's
	caile x,(px)
	lsh zero,1			;except if move right, needs $
;  now the same for vertical
	movei 1,(dely)
	caige y,(py)
	lsh 1,1
;  now combine for total cost - 0 _ cost of move
	addi zero,(1)
;now compare lca and move
	caige zero,4
	 jrst relmov		;move is faster - now do it
				;LCA is faster

vi.dlc:	movei px,(x)		;now are where requested
	movei py,(y)
	movei ch1,vi.lca		;$ - do LCA - $Yyx
	call vt.lead
	movei ch1,40(y)		;y
	call putch1
	movei ch1,40(x)		;x
	callret putch1

;here are the single cursor movement commands

vi.dRi:	movei ch1,vi.righ
	call vt.lead
	callret vi.inX		;see where we are after move

vi.ddo:	movei ch1,12
	call putch1
	callret vi.inY		;see where we are after move

vi.dle:	jumpe px,cpopj		;if at left, don't do anything
	movei ch1,10
	soja px,putch1		;update px and go put out BS

vi.dup:	jumpe py,cpopj		;if at top, don't do anything
	movei ch1,vi.up
	soja py,vt.lead		;update py and put out with leadin

vi.dho:	setzb px,py		;home
	movei ch1,vi.home
	callret vt.lead

vi.dLF: ; for last line LF only, to scroll 
	movei ch1, LF
	callret putCh1


vi.dIC:	call vi.ion		;insert must bbe on
	movei ch1,40		;insert a blank
	call putch1
	movei ch1,10		;and back to starting position
	callret putch1

vi.dIL:	movei ch1,vi.il
	call vt.lead
	jrst vi.dl2		;padding

vi.dDC:	movei ch1,vi.dc
	callret vt.lead

vi.dDL:	movei ch1,vi.dl
	call vt.lead
	;jrst vi.dl2
vi.dl2:	setz px,
	 move n1,bps
	caige n1,=9600
	ret
	movei ch1,177
	movei n1,2
	callret putnc1

vi.dEL:	movei ch1,vi.eol	;erase to end of line
	callret vt.lead


;is this right?
vi.dEP:	jumpe px,vi.dE1
	movei ch1,CR
	call px0put
vi.dE1:	movei ch1,vi.eop	;erase to end of page
	call vt.lead
	move n1,bps
	caige n1,=9600		;pad like delete lines
	ret
	movei ch1,177
	move n1,maxPY		;how many lines deleted?
	sub n1,py
	lsh n1,2		;*4
	callret putnc1		;that many pads

vi.dcp:	setzb px,py		;clear page
	movei ch1,vi.cp
	callret vt.lead

	LIT

	subttl NIH 5200 display dependent routines
;			      NIH 5200
;			      ========

deftty(ni,NIH)

	ni.mX	__ =79		;not user settable
	ni.mY	__ =26		;not user settable
	ni.fea	__ f%dca+f%home+f%udlr+f%eeol+f%lid+f%cid+f%lc

;		   NIH 5200

	ni.home	__ 121	; SOH Q
	ni.left	__ 10
	ni.dwn	__ 13
	ni.LCA	__ 1
	ni.eol	__ 125	; SOH U
	ni.up	__ 32
	ni.righ	__ 31

	ni.CP	__ 122	; SOH R
	ni.eins	__ 22	; end insert mode
	ni.bin	__ 131	; SOH Y -- begin insert 
	ni.DC	__ 126	; SOH V
	ni.IL	__ 115	; SOH M
	ni.DL	__ 114	; SOH L

	ni.pch	__ 177

	ni.bl  __ 37	; blink mode (not used?)
	ni.ebl __ 36	; end blink mode (not used?)
	ni.ldch __ 16	; SO

ife oneseg,<
	RELOC		;now low seg
>;ife oneseg

ni.numl __ =27
igncnt:	block 1		;char's to ignore in NIHD
gapsiz:	block 1		;size of gap in memory
filflg:	block 1		;fill needed on next char
wxc:	block ni.numl	;array of first clear position on screen each line

ife oneseg,<
	RELOC		;now hi seg
>;ife oneseg




;The NIH 5200 has one physical mode of interest:
;  insert, in which all characters are inserted


ni.qui:	hrli f,insert		;turn on tty, off others
	callret ni.iof		;insert off

ni.ini:	tlz f,-1		;start in known state - all modes off
	setzm igncnt
	setzm gapsiz
	setzm filflg
	setzm wxc		;clear array of knowledge about memory
	move tmp,[xwd wxc,wxc+1]
	blt tmp,wxc+ni.numl-1
	callret ni.iof

;here begin the routines to set and clear physical modes - insert

ni.ion:	movei ch1,ni.bin
	call nihld1
	tlo f,insert
	ret

ni.idof:
	tlne f,insert		;is insert on?
	 jrst ni.iof		;yes, turn off
	ret

ni.iof:	movei ch1,ni.eins
	call nih1
	tlz f,insert		;no more insert
	ret

ni.ton:
ni.tof:	ret			;no physical effect for tty


ni.bel:	movei ch1,BEL		;put out an even parity bell only!
	jrst nih1


ni.dCh:	call ni.chf		;put it in the right mode
	call nihch		;put out the char, and any fills
	movei tmp,1(px)		;how many char's there will be in line
	camle tmp,wxc(py)	;if cx > wxc[cy] then wxc[cy] _ cx
	movem tmp,wxc(py)
	call ni.inX		;now update px,py
	trnn f,insert		;if in insert, check for line overflow
	 ret			;otherwise just return
	move n1,wxc(py)
	jrst ni.di0		;check for overflow

ni.chf:	;sets physical flags as requested in F and does INCX - note that
        ;this assumes a scroll at the bottom of the screen
	hlrz tmp,f		;actual physical flags
	trc tmp,(f)		;tmp _ request xor actual
	trnn tmp,insert		;is insert ok?
	ret			;yes - done with checking
	trne f,insert		;requested on?
	call ni.ion		; yes - put it on
	trnn f,insert
	call ni.iof		; no - put it off
	ret

;ni.inc are used to account for real output.  This differs from the arrows,
;  because they will cause roll at the bottom of the screen, while using
;  arrows to move never will
ni.inX:	caie px,ni.mX		;overflow line?
	aoja px,cpopj		;no - incr x and exit
	setz px,		;yes - now at start of next line

ni.inY:	caie py,ni.my		;overflow screen?
	aoja py,cpopj		;no - incr y and exit
	move tmp,[xwd wxc+1,wxc] ;shift screen descr. up, like screen
	blt tmp,wxc+ni.numl-2
	setzm wxc+ni.numl-1
	ret			;still on bottom line (rolled)


ni.move:	;move to x,y from px,py.  Has to choose between direct
	; cursor addressing (LCA) or moving with horizontal and
	; vertical moves.  At the moment we are not considering home
	; and then move.
;first we compute the cost of moving with horizontal and vertical moves
	cain delx,0		;if to upper left, use home
	caie dely,0	
	jrst .+2
	jrst ni.dho
	movei zero,(delx)		;number of ^H's
;  now combine for total cost - 0 _ cost of move
	addi zero,(dely)
;now compare lca and move
	caige zero,3
	 jrst relmov		; do relative move
				;LCA is faster
ni.dlc:	movei px,(x)		;now are where requested
	movei py,(y)
ni.dl0:	call ni.idof	
	movei ch1,ni.lca		;do LCA
	call nih1
	movei ch1,(px)		;x
	trc ch1,177
	call nih1
	movei ch1,(py)		;y
	trc ch1,177
	call nih1
	setom filflg		;fill next char
	ret

;here are the single cursor movement commands

ni.dRi:	call ni.idof
	cain px,ni.mX		;at end of line?
	ret			;yes - stay where we are
	movei ch1,ni.righ
	aoja px,nih1		;update px and go put out move right

ni.ddo:	call ni.idof
	cain px,ni.my		;at end of screen?
	ret			;yes - stay where we are
	movei ch1,ni.dwn
	aoja py,nih1		;update py and go put out move down

ni.dle:	jumpe px,cpopj		;if at left, don't do anything
	call ni.idof
	movei ch1,ni.left
	soja px,nih1		;update px and go put out BS

ni.dup:	jumpe py,cpopj		;if at top, don't do anything
	call ni.idof
	movei ch1,ni.up
	soja py,nih1		;update py and put out with leadin

ni.dho:	call ni.idof
	setzb px,py		;home
	movei ch1,ni.home
	callret nihld1

ni.dLF: ; for last line LF only, to scroll 
	movei ch1, LF		;now put out LF
	call nih1
	jrst ni.inY		;and account


ni.dIC:	caml px,wxc(py)		;if beyond last character of line
	 ret			;then don't bother to do anything
	tlnn f,insert		;insert must be on
	 call ni.ion
	movei ch1,40		;insert a blank
	call nih1
	movei ch1,ni.left	;and back over it (loses at margin)
	call nih1
	aos n1,wxc(py)		;we now have one more char in line

;check for line overflow, and delete overflowed char if necessary
ni.di0:	caige py,ni.my		;if last line, never overflows
	 caig n1,ni.mx+1	;if not overflow to next line
	  ret			;we're OK
	movei py,1(py)
	movei px,0
	call ni.dl0		;go to beginning of overflow line
	movei ch1,ni.dc		;delete overflowed char
	callret nihld1

ni.dIL:	call ni.dCR		;NIH IL must be from col 1
	movei ch1,ni.il
	call nihld1
	movei n1,ni.my-1	;move down WXC array
ni.di1:	caige n1,(py)
	jrst ni.di2		;copy loop
	move tmp,wxc(n1)
	movem tmp,wxc+1(n1)
	soja n1,ni.di1
ni.di2: setzm wxc(py)		;clear info for new line
	ret

ni.dDC:	caml px,wxc(py)		;if after end of line,
	 ret			;we have nothing to do
	movei ch1,ni.dc
	call nihld1
	sosge wxc(py)		;we now have one fewer char in line
	setzm wxc(py)		;but not negative
	ret

ni.dDL:	call ni.dCR		;NIH dl must be from col 1
	movei ch1,ni.dl
	call nihld1		;del line
	movei n1,=80*=1440+=2850
	call nihdel		;pad it
	cail py,ni.my		;move up WXC array
	jrst ni.dl3		;if any
	hrli tmp,wxc+1(py)
	hrri tmp,wxc(py)
	blt tmp,wxc+ni.my-1
ni.dl3:	setzm wxc+ni.my		;clear last word
	ret

;special hack for dIL and dDL.  Assumes cursor up to date.
;I presume this is right (jqj)
ni.dCR:	jumpe px,cpopj		;already at col 1
	movei ch1,CR
	setz px,
	jrst nih1		;send the character with parity

;erase to end of page - there isn't any
ni.dep:	call ni.del		;erase this line
	hrrei n1,-ni.my(py)
	push p,n1		;save the counter where it wont get clobbered
ni.dp0:	aosl (p)		;done yet?
	 jrst ni.dp1		;yes
	addi py,1		;and go to beginning of next line
	setz px,		;...slowly
	call ni.dl0		;go there now
	call ni.del		;erase one line
	jrst ni.dp0		;go do another
ni.dp1:	pop p,(p)		;remove the counter from the stack
	ret

ni.dEL:	caml px,wxc(py)		;ignore if nothing more on line, or
	 ret			;  we just did it
	movei ch1,ni.eol	;no do the erase
	call nihld1
	movei n1,=1440		;compute delay time
	imul n1,wxc(py)
	addi n1,=2850
	call nihdel
	movem px,wxc(py)		;now cleared
	ret

ni.dcp:	call ni.idof
	setzb px,py		;clear page
	movei ch1,ni.cp
	call nihld1
	setzm wxc		;and clear data about page
	move tmp,[xwd wxc,wxc+1]
	blt tmp,wxc+ni.numl-1
	ret



;NIHD
;   movei ch1,char
;   pushj p,nihd
;See if we need pads after this character.  Should be called before
;putting out any characters.

;uses ch2,tmp.  Saves others


nihd:	push p,n1
	move tmp,px		;gapsize _ cx - wxc[cy]
	sub tmp,wxc(py)
	movem tmp,gapsiz
	sosl igncnt		;see if we should ignore
	 jrst xskip		;ignore this one
	skipn filflg
	 jrst xskip		;No fill needed here
	setzm filflg
	move ch2,ch1		;strip parity if any
	andi ch2,177
	caile ch2,40		;See if printing
	 cail ch2,177
	  jrst	xskip1		;not printing
	skipg n1,gapsiz		;if no gap, no fill needed
	 jrst xskip1
	imul n1,bps
	imuli n1,=1440
	idiv n1,bignum
	jumpe n1,xskip1
	push p,ch2
nihdl:	movei ch2,377
	pushj p,putch2
	sojge n1,nihdl
	pop p,ch2
xskip1:	movei tmp,2
	cain ch2,1		;cursor?
	 movem tmp,igncnt
	movei tmp,1
	cain ch2,16
	 movem tmp,igncnt
xskip:	pop p,n1
	ret

bignum: dec 10000000

nihdel:	imul n1,bps		;compute padding for given delay
	idiv n1,bignum
	addi n1,1
	movei ch2,377
nihdl2:	call putch2
	sojg n1,nihdl2
	ret

;nihld1 - char in ch1 with leadin
ni.lead:
nihld1:	push p,ch1		;put ch1 with leadin first
	movei ch1,16		;leadin
	call nih1
	pop p,ch1		;original char
	;fall into nih1

;nih1 - char in ch1 (parity calculation is fairly slow, but...)
nih1:	movei zero,(ch1)	;get the right parity
	lsh zero,-4		;copy char, then fold into 4 bits
	xori zero,(ch1)
	trce zero,14		;are left 2 bits both 0?
	 trnn zero,14		;or both 1?
	  xori ch1,200		;yes.  Change high bit
	trce zero,3		;are right bits both 0?
	 trnn zero,3		;or both 1?
	  xori ch1,200		;yes.  Change for even, restore for odd
	idpb ch1,Dbuf.p
	sosg dbuf.n		; Put  CH1
	 call forceO
	call nihd
	ret


nihCh:	move ch1,ch		;let only one routine have smarts
	callret nih1

	LIT
	subttl	Tektronix 4025 display dependent routines

;			Tektronix 4025
;			========= ====

deftty(tk,tk25)

; Tek 4025 commands are in the form of <lead-character><command-string>
; [<repeat-count>]<;>
; e.g `DOW23;  to go down 23 lines

	tk.mx  __ =79		;not user settable
	tk.my  __ =33		;not user settable

	tk.FEA	__ f%dca+f%home+f%udlr+f%clp+f%lid+f%cid+f%lc+f%blm

tk.box  __ "*"
tk.IC:	asciz/ICH/		; insert character
tk.DC:	asciz/DCH/		; delete char.
tk.IL:	asciz/ILI/		; insert line
tk.DL:	asciz/DLI/		; delete line
tk.rdo:	asciz/RDO/		; scroll down (for insert of top line)
tk.ldch __ "`"		       	; accent grave
tk.edch __ ";"	       		; end command
tk.up:	asciz/UP/		; up
tk.dow:	asciz/DOW/		; or LF, which scrolls
tk.rig:	asciz/RIG/		; or space, which doesn't wrap
tk.lef:	asciz/LEF/		
tk.hom:	asciz/JUM/		
tk.LCA	__ tk.hom
tk.CP:	asciz/ERA/		 
tk.res:	asciz/ATT A/		
; leadin for Tek 4025.  4025 is user programmable.  On master reset, it
; is assumes the leadin character is an exclamation point.  Well, this is
; questionable.  EMACS and MLAB already assume the leadin character is
; accent grave (`).  Thus, TV will assume accent grave for compatibility.

; send whole command (including leadin and terminator)
tk.lead:push p,ch1
	movei ch1,tk.ldch
	call putch1
	move ch1,(p)
	call putcom
	movei ch1,tk.edch
	call putch1
	pop p,ch1
	ret

;send only leadin and command
tk.ldx:	push p,ch1
	movei ch1,tk.ldch
	call putch1
	pop p,ch1
	jrst putcom

; send command terminator
tk.end:	push 	p,ch1
	movei	ch1,tk.edch
	call	putch1
	pop	p,ch1
	ret
	

tk.ini:	tlz	f, pblink	; start out not in hardware insert or italic
	hrroi	ch1,tk.res	; standard character attributes
	callret	tk.lead

; temporary -- blink mode maybe someday
;(not yet implemented)
tk.dSB:	tk.dCB:
	ret

tk.qui:	jrst	 tk.dCB		; clear blink mode

tk.dCh:	cain	Ch, tk.ldCh
tk.dBx:	 movei	Ch, tk.BOX	; translate accent-grave and ^Z to box
	trne	f, blink	; blink mode?
	 jrst	[call tk.dSB
		 jrst tk.dc0]
	call	tk.dCB		; no, turn off blink
tk.dc0:	trne	f, insert	; inserting?
	 jrst	[call tk.ion	; send the insert leadin
		 jrst tk.dc1]
	call	tk.iof
tk.dc1:	call	 putCh
	caie 	px,tk.mx	;overflow line?
	 aoja 	px,cpopj	;no - incr x and exit
	setz 	px,		;yes - now at start of next line
	jrst	tk.dDo		;by going down

tk.dCP:	hrroi	ch1, tk.CP	;clear screen
	setzb	px, py
	jrst	tk.lead


;	Tektronix Cursor movement

tk.mov:	cain	x,0		
	 caie	y,0
	jrst 	.+2
	 jrst	tk.dHo		; home if destination is 0,0

; here for absolute address (LCA)
; you can't do absolute cursor addressing in the "monitor space," only in the
; graphics workspace!

tk.dLC:	caie	y,(py)
	 call	tk.mvY		; move Y first
	cain	x,(px)
	 ret
				; then fall into move X
	jumpl	x,cpopj		; don't try for illegal x
	caile	x,tk.mX
	  ret
	hrroi	ch1,tk.rig	; assume move is to right
	caig	x, (px)		; ..but is it?
	 hrroi	ch1,tk.lef	; ..nope, left instead
	call	tk.ldx		; send leadin and command, don't terminate
	move	t1,x
	sub	t1,px
	movms	t1
	caie	t1,1
	 call	putnum
	movei	px,(x)
	jrst	tk.end

tk.mvY:	jumpl	y, cpopj	; don't lose on illegal y
	caile	y, tk.mY
	  ret
	hrroi	ch1,tk.dow	; assume move is down
	caig	y, (py)
	 hrroi	ch1,tk.up	; nope, move is up
	call	tk.ldx		; up/down move 
	move	t1,y
	sub	t1,py
	movms	t1
	caie	t1,1
	 call	putnum
	movei	py,(y)
	jrst	tk.end

; home the cursor
tk.dHo:	hrroi	ch1,tk.hom
	setzb	px,py
	jrst	tk.lead


;note:  since the TEK code does not use RELMOV or RELMCR, it does not need
;	tk.dRi or tk.dUp, and never uses repeat count features.
;	tk.dLe and tk.dDo are only called internally.

; move left.
tk.dLe:	hrroi	ch1, tk.lef
	sojge	px, tk.lead
	movei	px,tk.mX		;back up from beginning of line
	hrroi	ch1,tk.Up
	sojge	py,tk.lead
	addi	py,tk.mY+1
	call	tk.lead
	hrroi	ch1,tk.rig	;and move to EOL on this line
	call	tk.ldx
	movei	t1,tk.mX
	call	putnum
	jrst	tk.end

; move up.  ###Not used
tk.dUp:	hrroi	ch1,tk.up
	caig	 py,0
	 addi	py,tk.mY+1
	soja	py, tk.lead


;###Not used at present, luckily
tk.dRi:	hrroi	ch1, tk.righ
	aoj	px,
	caig	px,tk.mX
	 jrst	tk.lead
	hrroi	ch1,tk.dow
	subi	px,tk.mX+1
	aoj	py,
	caile	py,tk.mY
	 setz	py,
	call	tk.lead
	hrroi	ch1,tk.dLe	;now move to beginning of line (CR?)
	call	tk.ldx
	movei	t1,tk.mX+1
	call	putnum
	jrst	tk.end


;move down 1 line
tk.dDo:	hrroi	ch1, tk.dow
	aoj	py,
	caile py,tk.mY
	 setz py,
	jrst tk.lead

;	Tektronix Erase to end of...


tk.dEL:	movei	ch1," "
	movei	t1,tk.mX
	sub 	t1,px
	call	putch1
	sojg	t1,.-1
	jrst	tk.dLC


tk.dEP:	push	p,x
	setz	x,
	call	chkXY
	pop	p,x
	hrroi	ch1,tk.dl	;do it by deleting lots of characters
	movei	t1,tk.mY
	sub	t1,py
	cain	t1,1
	 jrst	tk.lead
	call	tk.ldx
	call	putnum
	jrst	tk.end


tk.dDL:	hrroi	ch1, tk.dl	; Delete Line
	jrst	tk.lead

; insert a line.  Tek inserts on the line BELOW the cursor, so have to move
; up, do the inserts, and move down
tk.dIL: cain	px,1
	 jrst	tk.dI1
	hrroi	ch1,tk.Up
	call	tk.lead
	hrroi	ch1,tk.IL
	skipg	2,RCount	;get count
	 jrst	tk.lead
	movei	1,1(2)
	setzb	px,RCount	;and clear repeat count
	call	tk.ldx
	call	putnum
	jrst	tk.end

;here for insert on top line of screen
tk.dI1: push	p,x
	setz	x,
	call	chkXY
	call	tk.dEL
	pop	p,x
	setz	px,
	ret

; scroll down a line
tk.scr:	hrroi	ch1,tk.rDo
	jrst	tk.lead

tk.dLF:	movei	ch1,LF
	callret	putch1


; 	Tektronix Insert/Delete char

tk.dIC:	call	 tk.ion		; Insert Char on
	movei	ch1, " "	; PutCh1 doesn't increment PX
	call	 putch1		; send the space
	aoj	px, 		; temporarily increment PX
	call	tk.dLe		; since tk.dLe decrements it
	tlz	f,pinsrt	; fake out hardware insert
	jrst	tk.ion		; and reenter hardware insert since tk.dLe
				; takes us out (lose!)

tk.dDC:	hrroi	ch1,tk.DC	; Delete character
	jrst	tk.lead

;  turn insert mode on/off
tk.ion:	tloe	f, pinsrt	; in hardware insert mode already?
	 ret			; yes
	hrroi	ch1,tk.IC	; enter insert mode
	jrst	tk.lead

;turn insert off by sending anything not a character
tk.iof:	tlzn	f, pinsrt
	 ret
	hrroi	ch1, tk.lef
	call	tk.lead
	hrroi	ch1,tk.rig
	jrst	tk.lead

	LIT

	subttl	ADDS Regent 60 Display Dependent Routines

;			ADDS Regent 60
;			==== ====== ==

deftty(ad,adds)

	ad.fea __ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc
	ad.mX  __ =79
	ad.mY  __ =23

	ad.hom __ 1     ;^A
	ad.lef __ 10	;^H
	ad.dow __ 12	;^J
	ad.rig __ 6	;^F
	ad.up  __ 32	;^Z
	ad.eop __ "k"	;ESC miniscule k
	ad.eol __ "K"	;ESC majuscule K
	ad.ic  __ "F"	;ESC F
	ad.dc  __ "E"	;ESC E
	ad.il  __ "M"	;ESC M
	ad.dl  __ "l"	;ESC miniscule l
	ad.lca __ "Y"	;ESC Y
	ad.ldch__ 33	;ESC
	ad.cp  __ 14	;^L
	ad.pch __ RUB	;pad with <delete>
	ad.att __ "0"	;ESC 0 <attribute-code> -- for attributes
	ad.res __ "V"	;ESC V to enter conversational mode


ad.qui:	ret


ad.ini:	movei	ch1,ad.res	; make sure we're in conversational mode
	jrst	ad.lead

ad.dCH:	trne	f,insert
	 jrst	[call ad.ion
		 jrst ad.dc0]
	call	ad.iof
ad.dc0:	call	putCH
	camge	px,maxPX
	 aoja	px,cpopj		;cursor OK
	setz	px,			;wrap around
	camge	py,maxPY		;OK vertically?
	 aoja	py, ad.dL0
	trnn	f,tty			;tty?
	 jrst	ad.dHo			;no, wrap
	call	ad.dL0

; fall through to scroll

ad.dLF:	movei	ch1,ad.dow
	jrst	putch1

;	ADDS cursor movement

ad.mov:	movei	(x)
	addi	(y)
	movei	t1,(delX)
	addi	t1,(delY)

; what's the fastest move?

	caile	t1,3		;don't go home
	 jrst	ad.dLC		;absolute move wins
	jrst	relmov		; do relative move, w/o CR for 

ad.dHo:	setzb	px,py
	call	ad.dl0		; do direct cursor addr
	jrst	relmov		; then move if necessary

ad.dRi:	caml	px, maxPX	; stick at right margin
	 ret
	movei	ch1,ad.rig
	aoja	px,putch1

ad.dDo:	caml	py, maxPY	; stick at bottom
	 ret
	movei	ch1,ad.dow
	aoja	py,putch1

ad.dLe:	jumple	px, cpopj	; stick at left
	movei	ch1,ad.lef
	soja	px,putch1

ad.dUp:	jumple	py, cpopj	; stick at top
	movei	ch1,ad.up
	soja	py,putch1


ad.dCP:	setzb	px,py
	movei	ch1,ad.cp
	jrst	putch1

ad.dEL:	movei	ch1,ad.eol
	jrst	ad.lead

ad.dEP:	jumpe	px,ad.de1
	movei	ch1, CR
	call	px0Put
ad.de1:	movei	ch1,ad.eop
	jrst	ad.lead

;	ADDS insert/delete

ad.dDl:	skipa	ch1,[ad.dl]

ad.dIl:	 movei	ch1,ad.il
	setz	px,
	jrst	ad.lead

ad.dIC:	call	ad.ion
	movei	ch1," "
	call	putch1
	aoja	px,ad.dLe

ad.dDc:	movei	ch1,ad.dc
	jrst	ad.lead

; turn insert on/off
ad.ion:	tloe	f,pinsrt
	 ret
	movei	ch1,ad.ic
	jrst 	ad.lead

ad.iof:	tlzn	f,pinsrt
	 ret
	movei	ch1,ad.ic		;end insert by sending the command again!
	jrst	ad.lead
	subttl	Concept-100 Display Dependent Routines

;			Concept-100
;			===========

deftty(cn,c100)

	cn.fea __ f%dca+f%home+f%udlr+f%eeol+f%eeos+f%clp+f%lid+f%cid+f%lc+f%ital+f%blm
	cn.mX  __ =79
	cn.mY  __ =23

	cn.hom __ "?"   ;ESC ?
 	cn.lef __ 10	;^H
	cn.dow __ 12	;^J
	cn.rig __ "="	;ESC =
	cn.up  __ ";"	;ESC ;
	cn.eop __ 3	;ESC ^C
	cn.eol __ 23	;ESC ^S 
	cn.ic  __ 20	;ESC ^P
	cn.dc  __ 21	;ESC ^Q
	cn.il  __ 22	;ESC ^R
	cn.dl  __ 2	;ESC ^B
	cn.lca __ "a"	;ESC a line,col
	cn.ldch__ 33	;ESC
	cn.cp  __ 14	;^L
	cn.pch __ RUB	;pad with <delete>
	cn.bbl __ "C"	;ESC C
	cn.ebl __ "c"	;ESC c
	cn.bit __ "G"	;ESC G
	cn.eit __ "g"	;ESC g
	cn.prg __ "U"	;ESC U - enter programmer mode



cn.qui:	ret

;***Is this right?***
cn.ini:	move	1,bps
	addi	1,=14400
	idivi	1,=32
	movem	1,sysOv			; system overhead in microseconds
	movei	ch1,cn.prg		; make sure we're in conversational mode
	jrst	cn.lead

cn.dCH:	trne	f,insert
	 jrst	[call cn.ion
		 jrst cn.dc0]
	call	cn.iof
cn.dc0:	trne	f,blink
	 jrst	[call cn.dSB
		 jrst cn.dc1]
	call	cn.dCB
cn.dc1:	trne	f,italic
	 jrst	[call cn.itn
		 jrst cn.dc2]
	call	cn.itf
cn.dc2:	call	putCH
	camge	px,maxPX
	 aoja	px,cpopj		;cursor OK
	setz	px,			;wrap around
	camge	py,maxPY		;OK vertically?
	 aoja	py,cn.dL0
	trnn	f,tty			;tty?
	 jrst	cn.dHo			;no, wrap
	call	cn.dL0

; fall through to scroll

cn.dLF:	movei	ch1,cn.dow
	jrst	putch1


;	Concept cursor movement

cn.mov:	movei	(x)
	addi	(y)
	movei	t1,(delX)
	addi	t1,(delY)

; what's the fastest move?

	caige	zero, (t1)
	 jrst	 cn.hOK		; home wins over move
	caig	t1, 3		; home loses
	 jrst	 relmov		; move wins.  Don't use CR?

cn.dLC:	movei	py, (y)
	movei	px, (x)
cn.dL0:	movei	ch1, cn.LCA	; do absolute move
	call	cn.lead		; requires leadin
	movei	ch1, " " (py)	; code for row
	call	 putCh1
	movei	ch1, " " (px)	; code for column
	jrst	 putCh1		; will RET
	

cn.hOK:	cail	zero, 3		; close to home?
	 jrst	 cn.dLC		; ..no, do LCA
	call	 cn.dHo		; ..yes 
	jrst	 relmov

cn.dHo:	movei	ch1, cn.hom	; home cursor 
	setzb	py, px
	jrst	cn.lead

cn.dRi:	movei	ch1,cn.rig
	came	px,maxPX
	 aoja	px,cn.lead
	skipa	px,[0]
cn.dDo:	 movei	ch1,cn.dow
	camn	py,maxPY
	 seto	py,		;we're lost
	aoja	py,putch1

cn.dLe:	movei	ch1,cn.lef
	sojge	px,putch1
	skipa	px,maxPX

cn.dUp:	 movei	ch1,cn.up
	sojge	py,cn.lead
	move	py,maxPY
	jrst	cn.lead

cn.dCP:	setzb	px,py
	movei	ch1,cn.cp
	call	putch1
	movei	1,cnpcw
	jrst	cn.pad

cn.dEL:	movei	ch1,cn.eol
	call	cn.lead
; enter here for padding for which no lines are moved (assume 1 line is moved)
cn.pd0:	push	p,3
	movei	1,cnpcle
	movei	2,=1000
	sub	2,sysOv
	idivi	1,(2)
	imul	1,bps
	idivi	1,=10000
	pop 	p,3
	move	2,1
	movei	ch1,cn.pch
	jrst	putNC1

cn.dEP:	jumpe	px,cn.dE1
	movei	ch1, CR
	call	px0Put
cn.dE1:	movei	ch1,cn.eop
	call	cn.lead
	movei	1,cnpcle
	jrst	cn.pad


;	Concept insert/delete

cnpcw __ =500
cnpcle __ =4000
cnpcid __ =4000
cnplid __ =750

; PAD, called with AC1: numerator constant from page G-2 of Concept manual
; 			in microseconds
; 1000X*(cn.Mx-px)/(1000-sysOv)*10000/bps gives number of pad characters
cn.pad:	push	p,3	
	movei	2,=1000
	sub	2,sysOv
	move	3,maxPY
 	subi	3,(py)
	imul	1,3
	idiv	1,2
	imul	1,bps
	idivi	1,=10000
	move	2,1
	pop	p,3
	movei	ch1,cn.pch
	jrst	putNC1

cn.dDl:	skipa	ch1,[cn.dl]

cn.dIl:	 movei	ch1,cn.il
	setz	px,
	call	cn.lead
	movei	1,cnplid
	jrst	cn.pad

cn.dIC:	call	cn.ion
	movei	ch1," "
	call	putch1
	call	cn.pd0
	aoja	px,cn.dLe

cn.dDc:	movei	ch1,cn.dc
	call	cn.lead
	jrst	cn.pd0

; turn insert on/off
cn.ion:	tloe	f,pinsrt
	 ret
	movei	ch1,cn.ic
	jrst 	cn.lead

cn.iof:	tlzn	f,pinsrt
	 ret
	setz	ch1,		; STUPID! Send ESC NULL to end insert
	jrst	cn.lead

cn.dSB:	tloe	f,pblink
	 ret
	movei	ch1,cn.bbl
	jrst	cn.lead

cn.dCB:	tlzn	f,pblink
	 ret
	movei	ch1,cn.ebl
	jrst	cn.lead

cn.itn:	tloe	f,pital
	 ret
	movei	ch1,cn.bit
	jrst	cn.lead

cn.itf:	tlzn	f,pital
	 ret
	movei	ch1,cn.eit
	jrst	cn.lead
	subttl *** End of Display Dependent Routines ***

;;	=====  End of Display Dependent Routines  =====

	subttl Dispatch tables

  ;; Macro to generate dispatch (JRST) tables indexed by DPY
  ; First argument is second part of xx.YYY label.  Second
  ; argument (optional) is default destination address.
  ; Example:  JRSTAB (DCP)  generates
  ;
  ;.dCP:  IFIW + Q.dCP
  ;	  IFIW + Gl.dCP
  ;	  IFIW + Dm.dCP
  ;	  IFIW + Hz.dCP
  ;	. . .
  ; to use:	JRST @.DCP(DPY)		;note that jump stays in-section

DEFINE	jrstab ' (name,default)  {	 
.'name:
    forall (\ttylst) {
ifdef ...`.'name,<	1b0 + ...`.'name >
ifndef ...`.'name,<ifdif <>,<default>,<	1b0 + default >
	ifidn <>,<default>,<printx  ...`.'name not defined
		1b0 + ...`.'name >
	>
	}
}

  ;; Macro to generate tables of constants indexed by DPY
  ;; Generates two halfword constants, display width and length
  ;; no defaults

dpysiz: forall (\ttylst) {
	...`.mX,,...`.mY
	}

  ;; Macro to generate a table of display features indexed by DPY.
  ;; Generates 36 1-bit fields, containing a 1 if the DPY has the
  ;; specified feature.
  ;; no defaults

dpyfea:	forall (\ttylst) {
	...`.FEA
	}
	subttl dpytab

;table, indexed by GTTYP value, of internal terminal type numbers

dpytab:	
ifn pandasw,<
	repeat 4,<t%tty>
	t%glass			; 4 - ADM-3A
	t%dm2500		; 5 - Datamedia 2500
	t%VT100			; 6 - VT132
	t%c100			; 7 - Concept 100
	repeat 2,<t%tty>	; 8, 9 - Default, Ideal
	0			; 10 - VT05
	t%glass			; 11 - VT50
	repeat 3,<t%tty>	; 12 - 14 LA30, GT40, LA36
	t%vt52			; 15 - VT52
	t%VT100			; 16 - VT100
	repeat 2,<t%tty>	; 17, 18 - LA38, LA120
	t%haz1500		; 19 - Hazeltine 1500
	repeat 2,<t%c100>	; 20, 21 - Concept 108, Concept Graphics 108
	t%glass			; 22 - Datamedia 1520
	t%iq120			; 23 - SOROC IQ120
	t%hp26xx		; 24 - HP26XX
	t%glass			; 25 - VC404
	repeat 2,<t%VT100>	; 26, 27 - WICAT, ANSI
	t%glass			; 28 - ADM-5
	repeat 3,<t%VT100>	; 29 - 31 - Selinar VT100, V1, V2 RETRO VT100
	t%glass			; 32 - ADDS Viewpoint
	t%tk25			; 33 - Tektronix 4025
	t%tvi			; 34 - TeleVideo 912
	repeat 2,<t%glass>	; 35, 36 - VT125, VK100
	t%VT100			; 37 - VT102
	t%heath			; 38 - H19
	repeat 2,<t%VT100>	; 39, 40 - VT131, VT200
	t%glass			; 41 - Glass teletype
	t%tty			; 42 - Tektronix 4014
>
ifn ecl,<
	repeat 5,<t%tty>	; 0 to 4 are not displays
	t%dm2500		; 5 - Datamedia
	t%imlac			; 6 - Imlac
	repeat 3,<t%tty>	; 7 - 11 are not displays
	repeat 3,<t%glass>	; 12 - 14 are glass ttys
	t%vt52			; 15 - DEC VT52
	t%hp26xx		; 16 - HP2640
	0			; 17 - free
	repeat 2,<t%glass>	; 20 - 21 glass ttys
	t%heath			; 22 - Heath H19
	repeat 4,<0>		; 23 - 26 are free
>	
ifn sri20,<
	repeat =4,<t%tty>	; 0 to 3 are not displays
	t%glass			; 4 - ADM3A et al
	t%dm2500		; 5 - DM2500
	t%hp26xx		; 6 - HP2645
	repeat 3,<t%tty>	; 7 - 9 are ttys
	t%glass			; 10 - VT05
	t%vt52			; 11 - VT50
	repeat 3,<t%tty>	; 12 - 14 are ttys
	t%vt52			; 15 - VT52
	t%vt52			; 16 - VT100
	repeat 3,<t%tty>	; 17 - 19 are ttys
	t%glass			; 20 - winning TEC (don't have the tables)
	t%haz1500		; 21 - virgin haz1500
	t%teleray		; 22 - Teleray 1061
	t%tk25			; 23 - Tek 4025
	t%glass			; 24 - Ann Arbor
	t%heath			; 25 - Heath H19
	t%imlac			; 26 - IMLAC PDS 1
	repeat 3,<t%glass>	; 27 - 29
> ;end ifn sri20
ifn sumex,<
	repeat =9,<t%tty>	; 0 to 8 are not displays
	t%tec			; 9 - TEC
	t%imlac			; 10 - Imlac
	t%dm2500		; 11 - dm2500
	t%glass			; 12 - undefined video terminal
	repeat 4,<t%tty>	; 13-16 not displays
	t%teleray		; 17 - Teleray 1061
	t%heath			; 18 - Heath H19
	t%Gillotine		; 19 - Albatross/Gillotine
	t%haz1500		; 20 - Hazeltine 1500 unmodified
	t%nih			; 21 - Nih-5200 (Delta Data)
	t%hp26xx		; 22 - HP 26xx series
	t%adds			; 23 - ADDS Regent 60
	t%c100			; 24 - Concept-100
> ; end ifn sumex
ifn stansw,<
	repeat 4,<t%tty>	; 0 to 3 are not displays
	t%glass			; 4 - Adm3
	t%dm2500		; 5 - Datamedia 2500
	t%hp26xx		; 6 - HP26xx
	t%haz1500		; 7 - Haz 1500
	repeat 2,<t%tty>	; 8,9 not displays
	0			; 10 - VT05
	t%glass			; 11 - VT50
	repeat 3,<t%tty>	; la30,gt40,la36
	t%vt52			; 15 - vt52
	t%VT100			; 16 - vt100
	t%tty			; 17 - LA38
	t%tty			; 18 - LA120
	t%tty			; 19 - Mod 43
	t%iq120			; 20 - Soroc IQ120--dumb
	t%Gillotine		; 21 - Albatross/Gillotine
	t%teleray		; 22 - Teleray 1061
	t%tk25			; 23 - Tek 4025
	t%glass			; 24 - should be Ann Arbor?
	t%heath			; 25 - Heath H19
	t%c100			; 26 - Concept 100
	t%glass			; 27 - should be IBM 3101
	t%tvi			; 28 - TVI 912
	t%glass			; 29 - Tek 4023
	t%glass			; 30 - Datamedia 1520
	t%ambassador		; 31 - Ambassador
>
ifn sum20,<
	repeat =5,<t%tty>	; 0 to 4 are not displays
	t%dm2500		; 5 - dm2500
	t%hp26xx		; 6  - hp2645
	t%haz1500		; 7  - Hazeltine 15XX
	repeat =7,<t%tty>	; 8-14 not displays
	t%vt52			; 15 - VT52
	t%tty			; 16 - not a display
	t%tec			; 17 - TEC
	t%Gillotine		; 18 - Albatross/Gillotine
	t%teleray		; 19 - Teleray 1061
	repeat 2,<t%tty>	; 20-21 not displays
	t%heath			; 22 - Heath H19
> ; end ifn sum20
ifn rutg,<
	t%tty			; 0 - tty33
	t%tty			; 1 - tty35
	t%tty			; 2 - tty37
	t%tty			; 3 - TI
	0			; 4 - unknown type
	t%dm2500		; 5 - Dm2500
	t%infoton		; 6 - I400
	t%glass			; 7 - DM1520
	t%tty			; 8 - Terminet
	t%tty			; 9 - Ideal
	t%glass			; 10 - VT05
	t%vt52			; 11 - VT50
	t%tty			; 12 - LA30
	0			; 13 - unknown type
	t%tty			; 14 - LA36
	t%vt52			; 15 - VT52
	repeat 6,<0>
	t%glass			; 22 - Hazeltine Mod 1
	t%haz1500		; 23 - Hazeltine 1500
	t%visual		; 24 - TV200
	t%nih			; 25 - NIH 5200 (Delta Data)
	t%heath			; 26 - Heath H19
	t%concept		; 27 - Concept 100
>; end ifn rutg
ldpytb==.-dpytab

	subttl DPYINI

;; 	Routines for the outside world to call, in SAIL or PASCAL format
;	======================================


ife pascal,<
DEFINE	enter	{jsp	tmp, enter.}
DEFINE	leave	{jsp	tmp, leave.}
DEFINE	jspRet	{jrst	 (tmp)}
>;ife pascal
ifn pascal,<
DEFINE	enter	{jsp	t1, enter.}
DEFINE	leave	{jsp	t1, leave.}
DEFINE	jspRet	{jrst	 (t1)}
>;ifn pascal

; procedure DPYINI -- Initialize the display *INTERNAL*
;           ======
;(n.b. Pascal version does not save ACs 2..3)
dpyIni:
  ; get display type

	movei	t1, -1		; Controlling terminal
	GTTYP			; Get Terminal TYPe

	movei	zero, t%tty	; assume TTY, 0
	caig	2, ldpytb	; in range?
	 move	zero, dpytab(2)	; yes.  Get internal type from table
	movem	zero, dpyTyp
	
  ; init output buffer pointers

	move	2, [point 7,Dbuf,-1]	;assume 7-bit bytes
	cain	zero, t%nih
	 move	2, [point 8,Dbuf,-1]	;except NIH uses 8-bit
	movem	2, Dbfn.p
	movei	2, Dbufsz*5-1
	cain	zero, t%nih
	 movei	2, Dbufsz*4-1
	movem	2, Dbfn.n		;default size

  ; get terminal speed
ifn tops20,<
	movei	2, 27		; Get speed
	MTOPR
	tlz	3, -1		; Just output rate
	caile	3, =9600
	 movei	3, =9600	; Assume 9600 for net i guess
>;ifn tops20
ife tops20,<			; Tenex only
ife sumex!ecl,<printx	Need default terminal speed...
	movei	3,=1200		;might as well assume 1200
>
ifn sumex,<
	movei	3,=2400
>
ifn ecl,<
	movei 3,=9600		; it's a KL10, right?
>
>;ife tops20
	movem	3,bps

  ; init flags, cursor, buffer, 

	call	 clrCur		; make cursor illegal
	call	 turnOn
	setzm	 flags
	setzm	 RCount		; no repeat count

	ENTER			; pick parameters

  ; set parameters:  width, height,
	movei	1, -1		; controlling terminal
ifn tops20,<
	movei	2, .morlw	; read line width
	MTOPR			; result is in n1 (3)
	movei	ch, -1(3)	; convert to internal notation
	movei	2, .morll	; read line length
	MTOPR
	movei	n1, -1(3)	; convert to internal notation
>;ifn tops20
ife tops20,<
	RFMOD
	ldb	ch,[point 7,2,17] ;pick up width
	subi	ch,1
	ldb	n1,[point 7,2,10] ;get length
	subi	n1,1
>;ife tops20
	caig	ch, =200
	 caige	ch, =30	;reasonable values for width?
	  hlrz	ch, dpysiz (dpy) ;no.  Use default width
	movem	ch, maxX	; virtual display
	movem	ch, maxPX	; physical display
	caig	n1, =200
	 caige	n1, =5		;reasonable values for length?
	  hrrz	n1, dpysiz (dpy) ;no.  Use default height
	movem	n1, maxY	; physical display
	movem	n1, maxPY	; virtual display


  ; set parameters: uc/lc
	setzm	 lcDpy
	move	zero, dpyfea (dpy)
	tlne	zero, (f%lc)	;does it have lower case?
	setom	 lcDpy		;0 if upper-case only, non-zero else

  ; device dependent initialization
	call	 @ .ini (dpy)

	LEAVE			; save once more

	jrst	 nexCom		; initialize NEXT and leave (will RET)

JRSTAB (ini)

	subttl Routines to return status variables

; (for languages, like Pascal, that don't support EXTERNAL variables.)

ifn pascal,<

; function RMAXCX -- return MaxCX *INTERNAL*
;          =====
rmaxcx:	skipa	t1, maxCX

; function RMAXCY -- return MaxCY *INTERNAL*
;          ======
rmaxcy:	move	t1, maxCY
	jrst	rdvar

; function RCX -- return CX *INTERNAL*
;          ===
rcx:	skipa	t1, CX

; function RCY -- return CY *INTERNAL*
;          ===
rcy:	move	t1, CY
	jrst	rdvar

; function RBPS -- return BPS *INTERNAL*
;          ====
rbps:	move	t1, bps

rdvar:	movem	t1, 1(p)	; return the result above stack top
	ret

; function HASLOW (Boolean NEWVAL) -- return old value of LCDpy  *INTERNAL*
;          ======		      [ use to force package to translate LC ]
haslow:	exch	2, lcdpy
	move	t1, 2		; result is returned in t1
	jrst	rdvar
>;ifn pascal


; function FTEST (Integer FEATURENUM) -- return true iff this display
;	   =====			 supports the specified feature.
;						*INTERNAL*
ftest:	move	t1, dpytyp
	move	zero, dpyfea(t1) ;get feature-word
ife pascal,<
	move	n1, -1(p)	;get featurenumber
>;ife pascal
	rot	zero, (n1)	;get it into the sign bit
	setz	t1,		;assume not set
	skipge	 zero		;it's set
ife pascal,<
	 seto	t1,
	move	zero, t1
	sub	p, [2,,2]
	jrst	@ 2(p)
>;ife pascal
ifn pascal,<
	 movei	t1, 1		;return TRUE.
	jrst	 rdvar
>;ifn pascal


	subttl Routines to set/clear Italic, Blink, and TTY modes

;;	The external routines of this page affect FLAGS only
;	  and not CX, CY.  No transmission.

; procedure SETITA -- set italic mode *INTERNAL*
;           ======
setIta:	movei	t1, doStIt
	jrst	 waveF

; procedure CLRITA -- clear italic mode *INTERNAL*
;           ======
clrIta:	movei	t1, doClIt
	jrst	 waveF


; procedure SETINS -- set insert mode *INTERNAL*
;           ======
setIns:	movei	t1, doStIn
	jrst	 waveF

; procedure CLRINS -- clear insert mode *INTERNAL*
;           ======
clrIns:	movei	t1, doClIn
	jrst	 waveF


; procedure SETTTY -- set tty mode *INTERNAL*
;           ======
setTTY:	movei	t1, doStTT
	jrst	 waveF

; procedure CLRTTY -- clear tty mode *INTERNAL*
;           ======
clrTTY:	movei	t1, doClTT

waveF:
	exch	f, flags	; pick up flags
	call	 (t1)		; AC1 points to clear/set flag routine
	exch	f, flags	; store the results safely
	ret

	subttl Cursor movement routines

;;	The external routines of this page affect CX, CY, and FLAGS
;	  but do not trasmit (note: cursor movement is delayed).

; procedure DORIGH -- move cursor right *INTERNAL*
;           ======
doRigh:	movei	t1, ..doRi
	jrst	 xyf

; procedure DODOWN -- move cursor down *INTERNAL*
;           ======
doDown:	movei	t1, ..doDo
	jrst	 xyf

; procedure DOLEFT -- move cursor left *INTERNAL*
;           ======
doLeft:	movei	t1, ..doLe
	jrst	 xyf

; procedure DOUP -- move cursor up *INTERNAL*
;           ====
doUp:	movei	t1, ..doUp
	jrst	 xyf


; procedure DOHOME -- move cursor home *INTERNAL*
;           ======
doHome:	movei	t1, ..doHo

xyf:	exch	x, cx		; switch relevant context
	exch	y, cy
	exch	f, flags
	call	 (t1)		; do the work
	exch	f, flags	; restore top-level context
	exch	y, cy
	exch	x, cx
	ret

	subttl Routines to ins/del line/char, cleol, cleop, etc.

;;	The external routines of this page transmit
;	  and possibly affect CX, CY, and FLAGS.

; procedure DOIC -- insert a character *INTERNAL*
;           ====
doIC:	movei	t1, ..doIC
	jrst	 ntr

; procedure DOIL -- insert a line *INTERNAL*
;           ====
doIL:	movei	t1, ..doIL
	jrst	 ntr

; procedure DODC -- delete a character *INTERNAL*
;           ====
doDC:	movei	t1, ..doDC
	jrst	 ntr

; procedure DODL -- delete a line *INTERNAL*
;           ====
doDL:	movei	t1, ..doDL
	jrst	 ntr


; procedure DOEEOL -- erase to end of line *INTERNAL*
;           ======
doEEOL:	movei	t1, ..doEL
	jrst	 ntr

; procedure DOEEOP -- erase to end of page *INTERNAL*
;           ======
doEEOP:	movei	t1, ..doEP
	jrst	 ntr

; procedure DOCL -- clear line *INTERNAL*
;           ====
doCL:	movei	t1, ..dCL
	jrst	 ntr

; procedure DOCP -- clear page *INTERNAL*
;           ====
doCP:	movei	t1, ..dCP
	jrst	 ntr


; procedure DOBB -- begin blinking field *INTERNAL*
;           ====
doBB:	movei	t1, ..doBB
	jrst	 ntr

; procedure DOEB -- end blinking field *INTERNAL*
;           ====
doEB:	movei	t1, ..doEB
	jrst	 ntr


; procedure SETBLI -- set blink mode *INTERNAL*
;           ======
setBli:	movei	t1, ..doSB
	jrst	 ntr
; procedure CLRBLI -- clear blink mode *INTERNAL*
;           ======
clrBli:	movei	t1, ..doCB

ntr:
ifn pascal,<
	push p,1
	ENTER
	pop p,1
>;ifn pascal
ife pascal,<
	ENTER
>;ife pascal
	call	 (t1)		; ..with address of routine in AC1
	LEAVE
	ret

	subttl TURNOF, TURNON, BINARY, CLRCUR, SETCUR, DPYOUT

; procedure TURNOF -- set TTY mode, clear all others, leave binary mode,
;           ======	clear DPYON, undefine DPYX/Y *INTERNAL*
turnOf:	skipn	 dpyOn
	 call	 turnOn		; will flush buffer
	ENTER
	hrri	f, tty		; tty mode only
	call	 chkXY		; bring cursor up-to-date
	call	 @ .OUT (dpy)	; for benefit of QTY
	call	 @ .qui (dpy)	; for benefit of ttys with settable modes
	call	 forceO
	setzm	 dpyOn
	movei	t1, -1
	movei	2, (px)		; set system's idea of cursor position
	hrli	2, (py)
	SFPOS
	RFMOD
	trz	2, 300
	tro	2, 100
	SFMOD			; set ASCII mode 
	LEAVE
	jrst	 clrCu1		; to clear cursor and exit

JRSTAB (qui)


; procedure TURNON -- flush and initialize DBUF, DPYON _ -1,
;           ======	 undefine DPYX/Y   *INTERNAL*
turnOn:
ifn pascal,<
	movem	2, ac2
>;ifn pascal
	movei	t1, -1
	RFMOD
	trz	2, 300
	SFMOD			; set binary mode 
	call	 dBufIn
	setom	 dpyOn
ifn pascal,<
	move	2, ac2
>;ifn pascal
	jrst	 clrCu2


; procedure CLRCUR -- Clear (clobber) cursor *INTERNAL*
;           ======
clrCur:	movei	zero, insert!blink
	andcam	 flags		; clear some modes
clrCu1:	movei	zero, 400000		; make cursor illegal 
	movem	zero, cx
	movem	zero, cy
clrCu2:	movei	zero, 200000		; ..and physical differ from logical
	movem	zero, dpyX		; ..for CHKXY to work
	movem	zero, dpyY
	ret


; procedure SETCUR (INTEGER x, y) -- Set cursor to column  X  row  Y
;           ======			 *INTERNAL*
setCur:	movei	zero, insert!blink!tty
	andcam	 flags		; clear some modes
ife pascal,<			; Sail version
	pop	p, 1		; save return address in AC1 
	pop	p, y
	andi	y, 177
	camg	y, maxY		; ignore invalid  y
	 movem	y, cy
	pop	p, x
	andi	x, 177		; convert to  x  value (complement)
	camg	x, maxX		; ignor invalid  x
	 movem	x, cx
	jrst	 (t1)		; return
>;ife pascal
ifn pascal,<
	movem	y, ac3		; save context
	movem	x, ac2
	skipl	y, 3		; new y is in 3.
	 camle	y, maxY		; in range?
	  move	y, CY		; No.  Use current.
	movem	y, CY
	skipl	x, 2		; new x is in 2.
	 camle	x, maxX		; in range?
	  move	x, CX		; No.  Use current.
	movem	x, CX
	move	y, ac3		; restore context
	move	x, ac2
	ret
>;ifn pascal

; procedure DPYOUT -- Force output of current dpy buffer *INTERNAL*
;           ======
dpyOut:	ENTER
	call	 chkXY		; bring cursor up-to-date
	call	 @ .OUT (dpy)	; for benefit of QTY
	call	 forceO
	LEAVE
	ret

JRSTAB (out,cpopj)		; default to doing nothing

	subttl DPYCHR, DPYNCH, DPYSTR

;; String interpreter

; procedure DPYCHR (INTEGER char) -- Display one CHARacter *INTERNAL*
;           ======
dpyChr:	ENTER
ife pascal,<
	move	ch, -1(p)
	call	 do
	LEAVE
	sub	p, [(2)2]
	jrst	@ 2(p)
>;ife pascal
ifn pascal,<
	move	ch, ac2		; character to output is in 2.
	call	do
	LEAVE
	ret
>;ifn pascal

; procedure DPYNCH (INTEGER n, char) -- Display  N  CHARacters *INTERNAL*
;           ======
dpyNCh:	ENTER
ife pascal,<
	skipn 	2, -2(p)	; save the count where it isn't stack-relative
	 jrst	dpyNX		; nothing to do
	movem	2, RCount	; (same place Pascal stuff expects it)
dpyN1:	move	ch, -1(p)	; char is on stack, still
>;ife pascal
ifn pascal,<
	skipn	2, ac2
	 jrst	dpyNX		; nothing to do
	movem	2, RCount
dpyN1:	move	ch, ac3		; pick up char (was in 3 when called)
>;ifn pascal
	call	do
	sosle	RCount		; change count
	 jrst	dpyN1		; If we have repeat counts, then need do this
				; only once for some functions.  If so, the
				; Low level routine will clear count
dpyNX:	setzm	RCount		; make sure RCount is no longer a counter
	LEAVE
ife pascal,<
	sub	p, [(3)3]	; return
	jrst	@ 3(p)
>;ife pascal
ifn pascal,<
	ret
>;ifn pascal


; procedure DPYSTR (STRING str) -- Display a STRing *INTERNAL*
;           ======
dpyStr:	ENTER
ife pascal,<
	hrres	 -1(sp)		; clean LH of STR length

dpySt1:	sosge	 -1(sp)
	 jrst	 dpySt2		; done
	ildb	ch, (sp)	; Next byte from STR
>;ife pascal
ifn pascal,<
 ifg pascal,<			; for Hedrick Pascal, supply length in 2nd arg
	push	p,3
 >;ifg pascal
 ifl pascal,<			; for Passgo, length is part of record
	push	p, 33(2)	; save length. 33*5=135.
 >;ifl pascal
	hrli	2, (<point 7,0>) ; make it a string pointer
	push	p, 2		; save addr of string
dpySt1:	sosge	 -1(p)
	 jrst	 dpySt2
	ildb	ch, (p)
>;ifn pascal
	call	 do
	jrst	 dpySt1

dpySt2:	LEAVE
ife pascal,<
	sub	sp, [(2)2]
>;ife pascal
ifn pascal,<
	sub	p, [2,,2]
>;ifn pascal
	ret

	subttl ENTER and LEAVE -- interfacing to Sail, etc.

  ; ENTER restores AC's when a display routine is entered

enter.:
ifn pascal,<
	move	zero, [2,,acblk+2] ; save top context
	blt	zero, acblk+16	; ACs x through sp
>;ifn pascal
	move	zero, [xwd dpyX, px] ; load AC's  PX, PY, X, Y, F, DPY
	blt	zero, dpy
	JSPRET


  ; LEAVE saves AC's before leaving a display routine

leave.:	move	zero, [xwd px, dpyX] ; store AC's  X, Y, PX, PY, F
	blt	zero, flags
ifn pascal,<
	move	zero, [acblk+2,,2] ; restore top-level context
	blt	zero, 16	; ACs x through sp
>;ifn pascal
	JSPRET


	LIT

	subttl Internal subroutines

;;		      Common internal routines
;		      ========================

	subttl forceO, dBufIn, putCh2, putNC1, putCh1, putCh, putnum

  ;	Current contents of output buffer are forced out.
  ;	Note:  An extra word at end for ASCIZ.
forceO:	skipn	 dpyOn
	 jrst	 dBufIn
	hrrz	zero, Dbuf.n	; remaining byte count
	camn	zero, Dbfn.n	; anything in buffer?
	 jrst	 dBufIn		; ..no
	push	p,3
	push	p,2
	move	3,zero
	sub	3,dBfn.n	; compute byte count
	setz	zero,
	idpb	zero, Dbuf.p	; zero byte to mark end of buffer [why?  jqj]
	movei	1,101
	move	2, dBfn.p	; string pointer to beginning
	SOUT			; faster-than-hell output
	pop	p,2
	pop	p,3

; EJS: Concept-100 terminals end insert mode with ESC NULL... must be 
;      able to output null to a terminal...arg!

dBufIn:	move	zero, Dbfn.p	; initialize the buffer
	movem	zero, Dbuf.p
	move	zero, Dbfn.n
	movem	zero, Dbuf.n
	ret


putCh2:	idpb	ch2, Dbuf.p
	sosg	 Dbuf.n		; Put  CH2
	 jrst	 forceO
	ret

putNC1:	sojl	n1, cpopj	; Put  N1  CH1's
	call	 putCh1
	jrst	 putNC1

pxy0Pu:	setz	py,		; used by Home and Clear
px0Put:	setz	px,
putCh1:	idpb	ch1, Dbuf.p
	sosg	 Dbuf.n		; Put  CH1
	 jrst	 forceO
	ret

putCh:	idpb	ch, Dbuf.p
	sosg	 Dbuf.n		; Put CH--buffer full?
	 jrst	 forceo		; ...yes
	ret

;PUTNUM -- write a positive number, using CH1, free format
; useful for terminals that do cursor addressing using ascii numerals
; to indicate position, e.g. HP.
;Call: number in 1 (t1).  Uses 1,2
;Ret:	+1 always
putnum:	idivi	t1, 12		; quotient to 1, remainder to 2
	push	p, 2		; save remainder
	skipe	1		; done enough divides?
	 call	putnum		; do some more
	pop	p, 2		; get back a remainder digit
	movei	ch1, "0"(2)	; convert to ascii
	jrst	putch1		; ship it

;PUTCOM -- write a string without updating px,py.  Useful for those
;terminals whose commands come in the form of strings (e.g. Tektronix
;4025)
;Call: Tenex string pointer in CH1
;Updates CH1
;Ret: +1 always
putcom:	push p,ch
	tlc ch1,-1
	tlcn ch1,-1
	 hrli ch1,440700
putcm0:	ildb ch,ch1
	jumpe ch,putcm1
	call putch
	jrst putcm0
putcm1:	pop p,ch
	ret


;RELMCR -- common routine called by many (but not all) of the display
;dependent routines to optimize relative cursor motion.
;call:	cursor not yet up to date.  Performs appropriate numbers of
;xx.dLe, xx.dRi, xx.dUp, xx.dDo.  Assumes that dpy has CR function.
relmCR:	jumpn	x, relmov	;if we aren't going to home itself,
				; then we won't use CR
	jumpe	px, relmvY	;we're already there
	movei	ch1, CR
	call	 px0Put		;send it, and set PX:=0
	jrst	 relmvY		;and move in Y dimension if necessary

;RELMOV -- common routine called by many (but not all) of the display
;dependent routines to optimize relative cursor motion.
;call:	cursor not yet up to date.  Performs appropriate numbers of
; xx.dLe, xx.dRi, xx.dUp, xx.dDo.  Does NOT assume that dpy has CR function.
;delX and delY contain the appropriate distance to move (first time
;  only).  This permits xx.dLe etc. to use the count to determine
; distance moved.
;This routine also ignores repeat-count features of terminals, and
; hence is suboptimal when the distance to move is more than about 4,
; but in such cases relative moves would be dominated by LCA.
relmov:	jumpl	x, relmvY	; prevent hanging in case of igl  X
	camg	x, maxX
relmX1:	 cain	x, (px)
	  jrst	 relmvY
	movei	t1, @.dRi(dpy)	; assume right move
	caig	x, (px)		; ..but is it?
	 movei	t1, @.dLe(dpy)	; ..nop, left instead
	call	 (t1)
	jrst	 relmX1

relmvY:	jumpl	y, cpopj
	camg	y, maxY
relmY1:	 cain	y, (py)		;are we there yet?
	  ret			;yes!
	movei	t1, @.dDo(dpy)
	caig	y, (py)
	 movei	t1, @.dUp(dpy)
	call	 (t1)		; up/down move 
	jrst	 relmY1

JRSTAB (dLe)
JRSTAB (dRi)
JRSTAB (dUp)
JRSTAB (dDo)

	LIT

	subttl String interpreter automaton

		; The String Interpreter Automaton
		; --- ------ ----------- ---------


doInit:	push	p, ch		; <<<, Auto-initialization
	call	 dpyIni
	pop	p, ch		; >>>

	; falls to  DO  a second time over


  ;; DO ONE BYTE.  Called by the routines declared internal in this
  ;;   subroutine package.  Entered with a frech byte in  CH.

do:	andi	ch, 177
	jumpe	ch, cpopj	; ignore NULL
	jrst	@ next		; RESUME--go to current state


doLCA:	trz	f, insert!blink!tty  ; leave insert, blink, tty modes
	jsr	 next

lcX:	trc	ch, 177		; convert to  x  value (complement)
	camg	ch, maxX	; ignor invalid  x
	 movei	x, (ch)
	jsr	 next

lcY:	trc	ch, 177		; convert to  y  value
	camg	ch, maxY	; ignor invalid  y
	 movei	y, (ch)

nexCom:	jsr	 next

  ;; This is where  JRST @ NEXT  at  DO + 2  usually takes us--with
  ;;   a fresh byte in  CH--to start the processing of the byte, 
  ;;   i.e., this is the initial state of the automaton

	caige	ch, 41
	 jrst	 dispat (ch)	; 0...40:  CTRL characters, Space
	caige	ch, 140
	 jrst	 doText		; 41...137:  punct, upper case
	cain	ch, 177
	 jrst	 doDEL		; 177:  DEL
	skipn	 lcDpy		; 140...176:  lower case
	 subi	ch, 40		; convert to upper
doText:	call	 chkXY		; let physical cursor catch up
	call	 @ .dCh (dpy)	; do display-dependent stuff
	jrst	 incX		; then move logical cursor

JRSTAB (dCh)


doESC:	jsr	 next		; go get next byte

	call	 nexCom		; set NEXT here, allows  $F  to  DOLCA
	trze	ch, 100		; translate 100..177 to 0..77, accept 1xx
	 caile	ch, "f"&77
	  ret			; out of range, ignor
	jrst	 dispat (ch)


doSP:	jrst	 doText		;+jqj (why did space depend on mode?)

	subttl INCX, INCY, etc

  ; INCX computes new (X,Y) resulting from transmission a text character
  ;  that is worth one space.  Old (X,Y) are assumed to be valid--they
  ;  have just been checked by CHKXY.
  ; If it is necessary to move to a new line in tty mode, then the line is
  ;  cleared.

incX:	came	x, maxX
	 aoja	x, cpopj
	setz	x,
;incY:
	came	y, maxY
	 aoja	y, lineOv	; clear new line
	trnn	f, tty		; is scrolling wanted?
	 setz	y,		; ..no, wrap around to top line
	ret
lineOv:	trnn	f, tty		; incX detected line overflow
	 ret			; not TTY mode, don't clear
	jrst	 doLF1		; tty mode, so clear newly entered line

resCXY:	trz	f, insert!blink!tty

chkXY:	caie	x, (px)
	 jrst	 moveXY
	cain	y, (py)
	 ret
moveXY:	jumpl	x, lost		; assure valid  (X,Y)
	jumpl	y, lost
	camg	x, maxX
	 camle	y, maxY
	  jrst	 lost
	movei	delX, (x)
	subi	delX, (px)
	movm	delX, delX
	movei	delY, (y)
	subi	delY, (py)
	movm	delY, delY
	jrst	 @ .mov (dpy)
JRSTAB (mov)

lost:	setz	x,		; invalid (X,Y)
	move	y, maxY
	call	 @ .dLC (dpy)	; LCA to get there for sure
	jrst	 doLF
JRSTAB (dLC)

	subttl control char dispatch table

dispat:	ret		; ^@  00, and ESC @ (and ESC ^@ if TEST)
	jrst	..doRi	; ^A  01, and ESC A (and ESC ^A if TEST)
	jrst	..doDo	; ^B  02, ......
	jrst	..doLe	; ^C  03

	jrst	..doUp	; ^D  04
	jrst	..doHo	; ^E  05
	jrst	doLCA	; ^F  06
	jrst	..bel	; ^G  07  BEL

	jrst	doBS	; ^H  10  BS
	jrst	doTAB	; ^I  11  TAB
	jrst	doLF	; ^J  12  LF
	jrst	doVT	; ^K  13  VT

	jrst	doFF	; ^L  14  FF
	jrst	doCR	; ^M  15  CR
	jrst	doStIt	; ^N  16  SO
	jrst	doClIt	; ^O  17  SI

	jrst	doStIn	; ^P  20
	jrst	doClIn	; ^Q  21
	jrst	..doIC	; ^R  22
	jrst	..doIL	; ^S  23

	jrst	..doDC	; ^T  24
	jrst	..doDL	; ^U  25
	jrst	..doEL	; ^V  26
	jrst	..doEP	; ^W  27

	jrst	..dCL	; ^X  30
	jrst	..dCP	; ^Y  31
	jrst	doBOX	; ^Z  32  SUB
	jrst	doESC	; ^[  33  ESC ($)

	ret		; ^\  34
	ret		; ^]  35
	ret		; ^^  36
	ret		; ^_  37

	jrst	doSP	; SP  40, and $` (and $ Sp if TEST)

  ; ESCape command dispatch continues below
	jrst	..doBB	; $a  141, (and $! if TEST)
	jrst	..doEB	; $b  142, (and $" if TEST)
	jrst	..doSB	; $c  143, (and $# if TEST)

	jrst	..doCB	; $d  144, (and $$--that's ESC DOLLAR--if TEST)
	jrst	doStTT	; $e  145, (and $% if TEST)
	jrst	doClTT	; $f  146, (and $& if TEST)

	subttl cursor movement

		; Cursor Movement (LCA on 2 pages up)

  ;; Note:  All cursor movement is delayed until something is printed


..doRi:	came	x, maxX		; RIGHT cursor
	 aoja	x, reset	; inc(x)
	setz	x,
..doDo:	came	y, maxY		; DOWN cursor
	 aoja	y, reset	; inc(y)
	setz	y,
	jrst	 reset


..doLe:	sojge	x, reset	; LEFT cursor--dec(x)
	move	x, maxX
..doUp:	sojge	y, reset	; UP cursor--dec(y)
	move	y, maxY
	jrst	 reset


..doHo:	setzb	x, y		; ..dCP  calls  ..doHo  for a reset
reset:	trz	f, insert!blink!tty
	ret

	subttl display commands

			; Display Commands

  ;; Insert/Delete

..doIC:	call	 resCXY		; Insert Character
	jrst	 @ .dIC (dpy)
JRSTAB (dIC)


..doIL:	call	 resCXY		; Insert Line
	jrst	 @ .dIL (dpy)
JRSTAB (dIL)


..doDC:	call	 resCXY		; Delete Character
	jrst	 @ .dDC (dpy)
JRSTAB (dDC)


..doDL:	call	 resCXY		; Delete Line
	jrst	 @ .dDL (dpy)
JRSTAB (dDL)


..doEL:	call	 resCXY		; Erase End Of Line
	jrst	 @ .dEL (dpy)
JRSTAB (dEL)


..doEP:	call	 resCXY		; Erase End Of Page
	jrst	 @ .dEP (dpy)
JRSTAB (dEP)


..dCL:	push	p, x		; Clear Line, <<<
	setz	x,
	call	 ..doEL
	pop	p, x		; >>>
	ret


..dCP:	call	 ..doHo		; Clear Page--home resets for us
	tro	f, tty
	jrst	 @ .dCP (dpy)
JRSTAB (dCP)

	subttl special character output

  ;; Special character output


doBOX:	call	chkXY		; bring cursor up to date
	call	@ .dBx(dpy)	; do display-dependent box character
	jrst	 incX		; account

doBx0:	movei	ch, "*"		; the default box character
	jrst	@ .dCh (dpy)	; call the display dependent routine

JRSTAB (dBx,doBx0)		; Default is write a "*"


..doBB:	call	chkXY		; bring cursor up to date
	call	 ..doSB		; Set blink mode if any
	call	@ .dBB(dpy)	; Write begin blinking field or space
	jrst	 incX		; Account for character written

doBB0:	movei	ch, " "		; By default, write a space
	jrst	@ .dCh (dpy)	; Use the display dependent routine to write it

JRSTAB (dBB,doBB0)		; By default, write a space


..doEB:	call	chkXY		; bring cursor up to date
	call	 ..doCB		; Clear blink mode if any
	call	@ .dEB(dpy)	; Write end blinking field or space
	jrst	 incX		; Account for character written

JRSTAB (dEB,doBB0)		; By default, write a space


  ;; Mode change commands.  Note 1:  DOSTIT, DOCLIT  are tty commands.
  ;;  Note 2:  Many other commands cause mode change as a side effect


; must not write a visible character to the display
..doSB:	tro	f, blink	; Set Blink mode
	jrst	 @ .dSB (dpy)

JRSTAB (dSB,cpopj)		; Default is do nothing


; must not write a visible character to the display
..doCB:	trz	f, blink	; Clear 7Blink mode
	jrst	 @ .dCB (dpy)

JRSTAB (dCB,cpopj)		; Default is do nothing


  ; INSERT and TTY modes are mutually exclusive

doStTT:	tro	f, tty		; Set TTY mode 
clInBl:	trza	f, insert!blink	; Clear Insert and Blink modes

doClIn:	 trz	f, insert	; Clear Insert mode 
	ret


doStIn:	tro	f, insert	; Set Insert mode (and clear TTY)

doClTT:	trz	f, tty		; Clear TTY mode 
	ret

	subttl "Teletype" commands

  ; Effect on modes:
  ;	("+" = set mode, "-" = clear mode, "." = no effect)
  ;
  ;		BEL  BS TAB  LF  VT  FF  CR  SO  SI
  ; Insert mode	 .   -   .   -   -   -   -   .   .
  ; Italic mode	 .   .   .   .   .   .   .   +   -
  ; Blink mode	 .   -   .   -   -   -   -   .   .
  ; TTY mode	 .   +   .   +   +   +   .   .   .


..bel:	call	 @ .bel (dpy)	; 7 - BEL
doBE0:	movei	ch, BEL
	jrst	 putCh
JRSTAB (bel,doBE0)		; By default, just put a bell in buffer
				; (note, we assume the bell is not printed)

doBS:	sojge	x, doStTT	; 10 - Back Space 
	aoja	x, doStTT


doTAB:	movei	ch, " "		; 11 - HT, horizontal TAB
doTAB1:	call	 doSP
	trne	x, 7
	 jrst	 doTAB1
	ret


 ;; doLF:			; 12 - Line Feed, look below  DOFF

doVT:	skipa	ch, ["."]	; 13 - Vertical Tab

doFF:	movei	ch, "-"		; 14 - Form Feed
	push	p, x		; <<<
	call	 doCRLF
draw:	call	 doText		; a line of .'s or -'s
	trne	x, 7
	 jrst	 draw
	pop	p, x		; >>>
	skipa

doCRLF:	 setz	x,		; a new line

doLF:	call	 doStTT		; 12 - Line Feed.  Does not use CH.
	came	y, maxY
	 aoja	y, doLF1	; LF within window
	call	 chkXY
	jrst	@ .dLF (dpy)	; LF from last line (to scroll)

JRSTAB (dLF)


doLF1:	push	p, f		; <<<, within-window line feed
	call	 ..dCL
	hrr	f, (p)		; restore top-level flags
	pop	p, (p)		; >>>
	ret


doCR:	setz	x,		; 15 - Carriage Return
	jrst	 clInBl


doStIt:	troa	f, italic	; 16 - ^N, shift out, Set Italic mode 
doClIt:	 trz	f, italic	; 17 - ^O, shift in, Clear Italic mode 
	ret


doDEL:	jumpe	x, ..bel	; 177 - Rub Out
	push	p, f		; <<<
	call	 doBS
	call	 ..doDC
	hrr	f, (p)		; restore only dpy-independent flags
	pop	p, (p)		; >>>
	ret

	subttl end of the world

endCod:
	LIT
endLit:

ife oneseg,<
	RELOC
>;ife oneseg

	VAR			; variables to low segment
dBuf:	block	<dBufSz+2>	; display buffer, 940 bytes
sysOv:	block	1		; system overhead
endVar:
ife oneseg,<
	RELOC
>;ife oneseg

	subttl TEST top level -- a separate program module

ifn test,<
prgend

extern	dpyIni,dpychr,dpyout,dpyNch

OPDEF	jsys	[104000000000]
OPDEF	call	[pushj 17,]
OPDEF	pbin 	[jsys	73]
OPDEF	haltf	[jsys	170]
OPDEF	psout	[jsys	76]
p_17
ESC_33

;this is a simple read-echo top level that gets chars from tty: and
;immediately passes them to the display package
go:	hrroi	1, [asciz %  WARNING:
  LOAD MODULE "<TV>DPY" WAS ASSEMBLED WITH "TEST" SWITCH ON!
%]
	PSOUT
	HALTF
	move	p, [iowd 100,pdl]
	call	 dpyIni		;reinitialize, in case restarting

play:	PBIN
	andi	1,177		;strip parity to make it 7-bit ascii
	movei	12, 0		;the arg count
	push	p, 1		;save the char. as arg for dpychr
	caie	1, ESC		;treat ESC specially
	 jrst	 play07		;not esc.  Just do the char.
	PBIN
	andi	1,177		;strip parity to make it 7-bit ascii
	cail	1, "0"
	 caile	1, "9"		;is it a digit?
	  jrst	 play05		;no
play01:	imuli	12,=10
	addi	12,-"0"(1)	;compute new count
	PBIN
	andi	1,177		;strip parity to make it 7-bit ascii
	cail	1, "0"
	 caile	1, "9"
	  skipa			;end of digits
	jrst	 play01
	caie	1, ESC		;<esc>55<esc>x is treated as <esc>55^X
	 jrst	 play02		;for now, <esc>1<esc>a is not <esc>a
	PBIN
	andi	1,37		;make it a control character right now
play02:	movem	12, (p)		;save count, overwriting ESC
	push	p, 1		;save display arg
	call	dpyNch		;do that many
	call	dpyout		;dump the buffer
	jrst play

;saw ESC
play05:	tro	1, 100		; treat $^A as ^A, and $! as $a for testing
	exch	1, (p)		;save another argument for next time 
	push	p, 1		;save ESC
	call	 dpychr		;transmit the ESC

play07:	call	 dpychr		;perform the function (logically)
	call	 dpyout		;force display updating
	jrst	 play

pdl:	block 100

	end go			;end of Main program.
>;ifn test

ife test,<
	end
>;ife test
;;;Local modes:
;;;Comment Begin:; 
;;;Comment Start:;
;;;Mode:Fail
;;;End:

	END
