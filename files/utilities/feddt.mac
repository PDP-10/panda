;
;	THIS IS A TOPS-20 ADAPTATION OF DAVE MCLURE'S
;	TOPS-10 PROGRAM DDT11-MAC
;
;;;0001;;;	NOV 22,1977 CHANGES TO MAKE FEDDT RUN ON REL.3
;		DO ALL CONVERSING WITH FE DEV IN 16-BIT MODE

SALL

UNIVERSAL	FEDDT
	SEARCH	MONSYM
	SEARCH	MACSYM

FLG=0
	F.FLIP==000001
	F.FLOP==000002
	F.LOPN==000004	;CURRENT LOCATION IS OPEN
	F.MOPN==000010	;MASK OPEN
	F.MASK==000020	;ESCAPE M TYPED
	F.IOCT==000200	;ASSEMBLING AN OCTAL NUMBER
	F.IDEC==000400	;ASSEMBLING A DECIMEL NUMBER
	F.IHEX==001000	;ASSEMBLING A HEX NUMBER
	F.ISIX==002000	;ASSEMBLING A SIXBIT SYMBOL
	F.SYMB==004000	;ASSEMBLING A SYMBOL
	F.CACH==010000	;USE CACHE IF POSSIBLE
	F..ESC==400000	;TYPED ESCAPE TWICE
T1=1
T2=T1+1
T3=T2+1
T4=T3+1
T5=T4+1
DOT=6	;CURRENT LOCATION
DOTFOO=7	;IN CASE IS 32 OR 48 BIT INSTRUCTION
LC=10		;LAST CHAR INPUT, SOMETIMES
EXPRESS=11	;BUILD EXPRESSIONS IN THIS AC
STATE=12
SYM=13	;POINTER TO SYMBOL BLOCK
SYMBOL=14	;CURRENT SYMBOL WE ARE BUILDING
P=17

EVSIZ==34000		;28K PDP-11 CORE

IO.RLB=1000
IO.WLB=400
SUBTTL	VARIOUS DEFINITIONS


OPDEF	CAL11.	[CALLI	125]
OPDEF	CAL78.	[CALLI 156]
OPDEF	NODUUO	[CALLI 157]
OPDEF	PJRST	[JRST]

;KL10 INSTRUCTION DEFINITIONS

OPDEF	EXTEND	[123000,,0]
OPDEF	MOVSLJ 	[016000,,0]

.JBSA== 120			;REL JOB STARTUP ADDR

;MACRO DEFINITIONS
DEFINE	TYPE	(X) <
	PUSH	P,T2
	MOVEI	T2,X
	PUSHJ	P,TSTRNG
	POP	P,T2
>

;
;	PROMPT SETS UP THE PROMPT BUFFER, AND TYPES
;	ITS ARGUMENT.
;
DEFINE PROMPT (X),<
	PUSH	P,T1
	PUSH	P,T2
	PUSH	P,T4
	PUSH	P,T5
	MOVEI	T1,20
	MOVE	T2,[440700,,X]
	PUSH	P,T2
	PUSHJ	P,TSTRNG
	POP	P,T2
	MOVEI	T4,20
	MOVE	T5,[440700,,OPNPMT]
	EXTEND	T1,OPNMOV
	HALTF
	POP	P,T5
	POP	P,T4
	POP	P,T2
	POP	P,T1
>

SUBTTL	JOB CONSTANTS

;REENTRY LOCATION
	.JBREN=:124

LOC	.JBREN
	LEVELR			;REENTRY POINT

;DDT11 VERSION NUMBER
		VWHO==1
		VDDT11==1
		VMINOR==1
		VEDIT==3
	.JBVER=:137


LOC	.JBVER
	BYTE (3)VWHO(9)VDDT11(6)VMINOR(18)VEDIT
RELOC	0

SUBTTL	STARTUP


DDT11::
	JFCL
	RESET
	SETZ	0		;ZERO 1ST AC
	MOVEI	17,1		;MAKE BLT POINTER
	BLT	17,17		;CLEAR ALL AC'S
	MOVE	P,[IOWD PDLEN,PDL]
	MOVE	T1,[0,,0]	;DEFAULT OUTPUT MODE IS SYMBOLIC
	MOVEM	T1,O.MODE
	SETZM	MEMORY
	SETZM	CACHEL		;HIGHEST ADDR IN CACHE
	JRST	LEVELR

SUBTTL	PORT AND NETWORK ROUTINES FROM DDT11

REPEAT 0,<
INI.00:
	TYPE	[ASCIZ \
respond with /PORT:# or /NODE:# or /NODE:name or /FILE\]
	PUSH	P,T1
	MOVX	T1,<.PRIIN>	;PRIMARY INPUT
	CFIBF			;CLEAR TYPE AHEAD
	POP	P,T1
INI.05:
	TYPE	[ASCIZ \
Input:	\]
	JSR	SIXIN		;SHOULD RETURN JUST "/"
	  JRST	INI.00
	JUMPN	T1,INI.00
	CAIE	T2,"/"
	  JRST	INI.00
	JSR	SIXIN		;GET COMMAND
	  JRST	INI.00
	MOVNI	T2,1		;BUILD MASK
INI.06:
	MOVSI	T3,-4
INI.07:
	MOVE	T4,[	SIXBIT	\FILE\
			SIXBIT	\NODE\
			SIXBIT	\PORT\
			SIXBIT	\WENABL\ ](T3)	;CHECK FOR MATCH
	AND	T4,T2
	CAMN	T1,T4		;MATCH ?
	  JRST	INI.08		;FOUND MATCH
	AOBJN	T3,INI.07
	LSH	T2,6		;ADJUST MASK
	JUMPN	T2,INI.06
	JRST	INI.00		;DON'T UNDERSTAND
INI.08:
	JRST	@[	RDDUMP
			INI.09
			INI.10
			INI.00 ](T3)
INI.09:	JSR	SIXIN		;GET NODE ARGUMENT
	  JRST	INI.00
	JSR	SIXOCT		;CONVERT TO NUMBER
	  JFCL
	MOVEM	T1,NODE#	;SAVE NODE NAME
	MOVEI	T1,1		;CODE TO LOCK
	LOCK	T1,
	  JRST	LOCKER
	JRST	LEVL.0
INI.10:	JSR	SIXIN		;GET SIXBIT ARGUMENT
	  JRST	INI.00
	JSR	SIXOCT		;CONVERT TO OCTAL
	  JRST	INI.00
	ANDI	T1,7
	MOVEM	T1,PORT#	;SAVE PORT NUMBER
>			;END OF REPEAT 0

SUBTTL	FRONT END DEVICE CONTROL
;
;OPNFE TAKES THE DEVICE SPECIFICATION (ASCIZ /FE3/, E.G.) IN T1
;AND SKIPS ON SUCCESS.
;
OPNFE:
	MOVEM	T1,FEFLG		;SET FLAG & NAME
	HRROI	T2,FEFLG
	MOVX	T1,GJ%SHT!GJ%OLD
	GTJFN
	PJRST	WARN
	MOVE	15,1		;SAVE JFN
;;;0001;;;MAKE 16-BIT MODE
	MOVE	2,[200000,,OF%WR!OF%RD] ;;;0001;;; BYTE SIZE,,OPEN WRITE
	OPENF
	POPJ	P,		;FAIL RETURN
	MOVEI	2,.MODTE	;OPEN DTE
	SETZ	3,
	MTOPR
	SETZM	MEMORY		;REALLY FROM PDP11 MEMORY
	AOS (P)
	POPJ	P,

SUBTTL	MAIN LOOP AND REENTY POINT

LEVELR:
	TYPE	[ASCIZ \[FEDDT]\]
LEVL.0:
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
LEVEL0:
	MOVX	T1,.PRIIN	;PRIMARY INPUT
	RFMOD			;READ TERM MODE
	IOR	T2,[TT%WKF!TT%WKN!TT%WKP!TT%WKA]
	SFMOD			;BREAK ON ALL CHARS
	SETZM	LPTFLG		;CLEAR TO LPT FLAG
	TRZ	FLG,F.LOPN!F.MASK!F.MOPN!F.CACH
	HLRS	ORADIX		;RESET OUTPUT RADIX
	HLRS	O.MODE		;RESET CURRENT OUTPUT MODE FROM PERMANENT
	HLRS	BYTCNT		;RESET REPETITION COUNT
LEVEL1:
	MOVE	P,[IOWD PDLEN,PDL]
	TRZ	FLG,F.SYMB!F.IOCT!F.IDEC!F.IHEX
LEVEL2:
	MOVEI	STATE,STATE0	;DISPATCH TABLE WHEN IDLE
LEVEL3:
	TRZ	FLG,F..ESC
	SETZM	INPOPR		;CLEAR INPUT OPERATOR
	SETZM	EXPRESS		;EXPRESSION WE HAVE BUILT
	SETZM	OCTIN#
	SETZM	DECIN#
	SETZM	HEXIN#
	SETZM	SYMBOL
	MOVE	T4,[POINT 6,SYMBOL]

LOOP:
	PUSHJ	P,GETCHR	;GET A COMMAND CHAR
	MOVEM	T1,T2
	ADD	T2,STATE
	JRST	@(T2)		;DISPATCH ON CHARACTER

SUBTTL	ILLEGAL CHARACTER

;HERE WHEN USER TYPES IN AN ILLEGAL CHARACTER
ILLCHR:
	TYPE	[BYTE (7)7,"?",7,11,7,0]
	PUSH	P,T1
	MOVX	T1,<.PRIIN>	;PRIMARY INPUT
	CFIBF			;CLEAR TYPE AHEAD
	POP	P,T1
	JRST	LEVEL1

SUBTTL	VARIOUS COMMAND ROUTINES

;HERE WHEN THE USER TYPES A TAB COMMAND
COMHT:
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	SKIPN	DOT,LSTADR	;IN CASE SET IN FUNNY WAY
	  MOVE	DOT,DATA	;LAST DATA BECOMES ADR
	JRST	COMLF1

;HERE WHEN THE USER TYPES A LINE FEED COMMAND
COMLF:
	SKIPE	DOTFOO
	  MOVE	DOT,DOTFOO
	SETZM	DOTFOO
	PUSH	P,T1
	MOVEI	T1,15		;RETURN CARRIAGE
	PUSHJ	P,TYPCHR
	POP	P,T1
	ADDI	DOT,2
	TRO	FLG,F.LOPN	;FLAG LOCATION IS OPEN
COMLF1:
	ANDI	DOT,177776	;FLUSH EXTRA BITS
	MOVE	T1,DOT
	PUSHJ	P,ADRTYP	;TYPE ADR
	MOVEI	T1,"/"
	PUSHJ	P,TYPCHR
COMLF2:
	PUSHJ	P,TABTYP
	MOVE	T1,DOT
	TRZ	FLG,F.CACH	;NOT CACHE, PLEASE
	PUSHJ	P,GETWRD
	  JRST	[	PUSHJ	P,CRLTYP
			TYPE	[ASCIZ \?OUT OF BOUNDS - \]
			PUSHJ	P,OCTYPE
			PUSHJ	P,CRLTYP
			JRST	LEVEL0	]
	MOVEM	T1,DATA		;SAVE DATA
	PUSHJ	P,DATYPE
	JRST	LEVEL2

SUBTTL	MORE COMMAND ROUTINES =, /, RUBOUT

;HERE WHEN USER TYPES =
EQUALS:	TRNN	FLG,F.LOPN	;IS LOCATION OPEN ?
	  JRST	ILLCHR		;NO SO ILLEGAL
	PUSH	P,O.MODE	;SAVE OUTPUT MODE
	MOVEI	T1,2		;OUTPUT AS NUMERIC
	HRRM	T1,O.MODE
	PUSH	P,BYTCNT
	SKIPN	T5,DOTFOO
	  HRRZ	T5,DOT
	SUBI	T5,-2(DOT)
	ANDI	T5,777777	;HALF WORD ONLY
	LSH	T5,-1
	HRRM	T5,BYTCNT
	PUSH	P,DOTFOO
	SETZM	DOTFOO
	MOVE	T1,DOT
	TRO	FLG,F.CACH	;USE CACHE IF POSSIBLE
	PUSHJ	P,GETWRD
	  JRST	CAL1ER
	MOVEM	T1,DATA
	PUSHJ	P,DATYPE	;TYPE DATA
	POP	P,DOTFOO
	POP	P,BYTCNT
	POP	P,O.MODE	;RESTORE OUTPUT MODE
	JRST	LOOP

;HERE WHEN USER TYPES / AT END OF A NUMBER
OPNLOC:	TRZE	FLG,F.MASK	;ASKING ABOUT THE MASK ?
	  JRST	[	PUSHJ	P,TABTYP
			HRRZ	T1,S.MASK	;GET THE MASK
			PUSHJ	P,RADTYP	;DISPLAY IT
			TRO	FLG,F.MOPN	;MAKS NOW OPEN
			PUSHJ	P,TABTYP
			JRST	LEVEL2	]
	PUSHJ	P,ACCUM
	HRRZ	DOT,EXPRESS
	SETZM	DOTFOO
	TRO	FLG,F.LOPN	;FLAG LOCATION IS OPEN
	JRST	COMLF2

;HERE WHEN USER TYPES A RUBOUT
COMRUB:
	TYPE	[ASCIZ \xxx	\]
	JRST	LEVEL1

SUBTTL	MORE COMMANDS ^, \, _

;HERE WHEN THE USER TYPES AN UP ARROW COMMAND
COMARR:
	PUSHJ	P,CRLTYP		;RETURN CARRIAGE
	SETZM	DOTFOO
	HRRZ	T1,BYTCNT		;NUMBER OF BYTES
	HRRZ	T2,O.MODE		;GET OUTPUT MODE
	CAIE	T2,0			;SYMBOLIC ?
	CAIN	T2,1			; OR ADDRESS ?
	  ASH	T1,1		;CONVERT WORD COUNT TO BYTES
	CAIN	T2,2		;OR NUMERIC
	  ASH	T1,1		;CONVERT WORD COUNT TO BYTES
	SUBI	DOT,(T1)
	JRST	COMLF1		;REST LIKE A LINE FEED COMMAND

;HERE WHEN THE USER TYPE A ^Z
COMCZ:
	HALTF			;QUIT
	JRST	LEVEL0		;CONTINUE

;HERE WHEN THE USER ENDS AN EXPRESSION WITH A BACKSLASH
COMBSE:
	PUSHJ	P,ACCUM		;FINISH ACCUMULATING EXPRESSION
	MOVE	T1,EXPRESS	;MAKES ADDRESS
	JRST	COMBS5
;HERE WHEN THE USER TYPES A BACKSLASH
COMBSL:
	SKIPN	T1,LSTADR
	  MOVE	T1,DATA
COMBS5:
	PUSHJ	P,TABTYP
	TRZ	FLG,F.CACH		;NO CACHE, PLEASE
	PUSHJ	P,GETWRD		;DO EXAMINE
	  JRST	[	PUSHJ	P,CAL1ER
			JRST	LEVEL0 ]
	MOVEM	T1,DATA
	PUSHJ	P,DATYPE
	JRST	LEVEL2

;HERE WHEN USER TYPE A BACK ARROW
BKARRW:
	PUSHJ	P,ACCUM		;FINISH ACCUMULATING EXPRESSION
	MOVE	T1,EXPRESS
	PUSHJ	P,ADRTYP	;AND TYPE OUT SYMBOL FOR IT
	PUSHJ	P,TABTYP
	JRST	LEVEL0		;AND DONE

SUBTTL	EXPRESSION ACCUMULATOR

ACCUM:
	SETZ	T1,
	TRZE	FLG,F.IOCT
	  MOVE	T1,OCTIN
	TRZE	FLG,F.IDEC
	  MOVE	T1,DECIN
	TRZE	FLG,F.IHEX
	  MOVE	T1,HEXIN
	TRZE	FLG,F.SYMB
	  PUSHJ	P,EVLSYM
ACCUM0:
	MOVE	T2,INPOPR	;GET INPUT OPERATOR
	XCT	[	ADD	EXPRES,T1
			SUB	EXPRES,T1
			IMUL	EXPRES,T1
			IDIV	EXPRES,T1
			IOR	EXPRES,T1
			AND	EXPRES,T1
			XOR	EXPRES,T1 ](T2)
	ANDI	EXPRESS,177777	;16 BITS ONLY
	MOVEI	STATE,STATEE
	SETZM	OCTIN
	SETZM	DECIN
	SETZM	HEXIN
	SETZM	SYMBOL
	MOVE	T4,[POINT 6,SYMBOL]
	POPJ	P,

SUBTTL	VARIOUS EXPRESSION TERMINATION ROUTINES

FINEXP:
	PUSHJ	P,ACCUM		;ACCUMULATE WHATEVER WE HAVE
	JRST	COMLF2

EXPLUS:
	TDZA	T1,T1		;CODE FOR NEXT TIME IS 0

EXPMIN:
	MOVEI	T1,1
	JRST	EXP.DO

EXPMUL:
	MOVEI	T1,2
	JRST	EXP.DO

EXPDIV:
	MOVEI	T1,3
	JRST	EXP.DO

EXPIOR:
	MOVEI	T1,4
	JRST	EXP.DO

EXPAND:
	MOVEI	T1,5
	JRST	EXP.DO

SUBTTL	EXPRESSION ACCUMULATOR CONTINUED

EXPXOR:
	MOVEI	T1,6
EXP.DO:
	PUSH	P,T1		;SAVE CODE FOR NEXT TIME
	PUSHJ	P,ACCUM		;ACCUMULATE EXPRESSION
	POP	P,INPOPR	;NEXT INPUT OPERATION
	JRST	LOOP		;THEN DONE

EXPEQU:
	PUSHJ	P,ACCUM		;ACCUMULATE EXPRESSION
	MOVE	T1,EXPRESS	;GET EXPRESSION
	PUSHJ	P,RADTYP
	PUSHJ	P,TABTYP
	JRST	LEVEL2

SLOWLM:
	PUSHJ	P,ACCUM		;ACCUMULATE EXPRESSION
	MOVE	T1,EXPRESS	;GET EXPRESSION
	HRRZM	T1,SBEGIN	;SET LOWER LIMIT FOR SEARCH
	JRST	LEVEL2
SUPLIM:
	PUSHJ	P,ACCUM		;ACCUMULATE EXPRESSION
	MOVE	T1,EXPRESS	;GET EXPRESSION
	HRRZM	T1,S..END	;SET UPPER LIMIT FOR SEARCH
	JRST	LEVEL2

SUBTTL	NUMBER ASSEMBLER

;HERE WHEN ASSEMBLING A OCTAL, DECIMEL OR HEX NUMBER

ASSNUM:
	MOVEI	STATE,STATEE
	MOVE	T2,OCTIN
	LSH	T2,3
	CAIL	T1,70
	  TRO	FLG,F.IDEC	;NUMBER IS DECIMEL
	ADDI	T2,-60(T1)
	MOVEM	T2,OCTIN
	MOVE	T2,DECIN
	IMULI	T2,^D10
	ADDI	T2,-60(T1)
	MOVEM	T2,DECIN
	MOVE	T2,HEXIN
	LSH	T2,4
	ADDI	T2,-60(T1)
	MOVEM	T2,HEXIN
	TRNN	FLG,F.IDEC!F.IHEX
	  TROA	FLG,F.IOCT
	  TRZ	FLG,F.IOCT
	JRST	ASYMB2

;HERE WHEN ASSEMBLING A SYMBOL
ASSYMB:
	MOVEI	STATE,STATEE
	TRO	FLG,F.SYMB
	TRZ	FLG,F.IDEC!F.IOCT!F.IHEX

ASYMB2:
	SUBI	T1,40		;CONVERT CHAR TO SIXBIT
	CAME	T4,[POINT 6,SYMBOL,35]
	  IDPB	T1,T4		;ADD CHAR TO SYMBOL
	JRST	LOOP

SUBTTL	SYMBOL TABLE ROUTINES

;HERE BECAUSE USER FINISHED SYMBOL WITH ":"
DEFSYM:
	TRNE	FLG,F.SYMB
	SKIPN	T1,SYMBOL		;SYMBOL HE DEFINED
	  JRST	ILLCHR
	HRRZ	T2,DOT		;CURRENT ADR
	PUSHJ	P,ADDSYM
	PUSHJ	P,TABTYP
	JRST	LEVEL1

;HERE TO EVALUATE A SYMBOL
EVLSYM:
	MOVE	T1,SYMBOL
	CAMN	T1,[SIXBIT \.\]
	  JRST	[	HRRZ	T1,DOT
			POPJ	P, ]
	PUSHJ	P,SYMFND	;TRY TO FIND SYMBOL
	  JRST	SYMERR
	HRRZ	T1,1(SYM)	;GET VALUE OF SYMBOL
	POPJ	P,

SYMERR:
	TYPE	[ASCIZ \U	\]
	JRST	LEVEL0

;HERE IF TERMINATES EXPRESSION WITH A CARRIAGE RETURN

STECR:
	PUSHJ	P,STEFIN	;STORE IF APPROPRIATE
	JRST	LEVEL0

;HERE TO DO DEPOSIT MAYBE AFTER CR OR LF OR UP ARROW
STEFIN:
	TRZE	FLG,F.MOPN	;IS MASK OPEN ?
	  JRST	SETMSK		;SET MASK
	TRZN	FLG,F.LOPN	;IS LOCATION OPEN ?
	  POPJ	P,		;NO SO JUST RETURN
	PUSHJ	P,ACCUM		;DO LAST MINUTE ACCUMULATION
	MOVE	T1,DOT		;GET ADR TO EXAMINE
	MOVE	T2,EXPRESS	;GET JUNK TO DEPOSIT
	PUSHJ	P,PUTWRD	;TRY TO DEPOSIT IT
	  PUSHJ	P,CAL1ER
	POPJ	P,

;HERE TO SET MASK
SETMSK:
	PUSHJ	P,ACCUM		;DO LAST MINUTE ACCUMULATION
	HRRM	EXPRESS,S.MASK	;SET MASK
	POPJ	P,

;HERE IF TERMINATES EXPRESSION WITH A LF
STELF:
	PUSHJ	P,STEFIN	;DEPOSIT LOCATION MAYBE
	JRST	COMLF		;DID DEPOSIT

;HERE IF TERMINATES EXPRESSION WITH AN UP ARROW
STEARR:
	PUSHJ	P,STEFIN
	JRST	COMARR

SUBTTL	ESCAPE ROUTINES

;HERE IS USER TYPES ESCAPE WHILE INPUTTING AN EXPRESSION
ESCEXP:
	PUSHJ	P,ACCUM		;ACCUMULATE EXPRESSION SO FAR

;HERE IF USER TYPES ESCAPE
ESCAPE:
	MOVEI	STATE,STATSC	;SET ESCAPE FLAG
	SETZ	T5,
	JRST	LOOP

ESCESC:
	TRO	FLG,F..ESC
	JRST	LOOP

;HERE TO ACCUMULATE NUMBER AFTER ESCAPE
ESC..0:
	IMULI	T5,^D10
	ADDI	T5,-60(T1)	;ACCUMULATE NUMBER
	JRST	LOOP

SUBTTL	VARIOUS ESCAPE ROUTINES (A-T)

ESC..A:
	MOVEI	T1,1		;SETTING ADDRESS MODE
	JRST	ESCMOD

ESC..B:
	MOVEI	T1,3		;SETTING BYTE MODE
	SKIPN	T5		;DID HE TYPE NUMBER ?
	  MOVEI	T5,2		;NO SO 2 BYTES
	JRST	ESCMOD

ESC..C:
	MOVEI	T1,2		;SETTING NUMERIC MODE
	JRST	ESCMOD

ESC..D:
	JRST	DUMP		;DUMP 11 ONTO DISK

ESC..E:
	MOVEI	T1,6		;RAD50 OUTPUT
	MOVEI	T5,1		;N/A
	JRST	ESCMOD

ESC..K:				;SUPPRESS SYMBOL
	TXNN	FLG,F..ESC	;IF TWO OF THEM
	JRST	ESCK1		; NO, ONLY ONE
	SETCMM	SUPSYM		;SUPPRESS ALL SYMBOLS
	JRST	LEVEL2		;AND RETURN
ESCK1:
	JUMPE	SYM,ILLCHR
	MOVE	T1,1(SYM)	;GET VALUE
	TLO	T1,SMF.SU	;SUPPRESS SYMBOL
	MOVEM	T1,1(SYM)
	PUSHJ	P,TABTYP
	JRST	LEVEL2		;AND RETURN

ESC..P:				;SET RELOCATION
	TXNN	FLG,F..ESC	;TWO ESCAPES & NO NUMBER IS CANCEL
	TLO	T5,200000	;MAKE SOME NON-ZERO VALUE
	MOVEM	T5,RELVAL	; AND SET UP RELOCATION
	PUSHJ	P,TABTYP	;TAB OVER
	JRST	LEVEL2		;AND KEEP GOING

ESC..R:	CAIG	T5,1		;IS RADIX REASONABLE ?
	  JRST	ILLCHR		;NO SO FLUSH REQUEST
	HRRM	T5,ORADIX	;YES SET NEW RADIX
	TRZE	FLG,F..ESC	;SETTING PERMANENT MODE ?
	  HRLM	T5,ORADIX	;YES
	PUSHJ	P,TABTYP
	JRST	LEVEL2		;AND KEEP GOING

ESC..S:	MOVEI	T1,0		;SETTING INSTRUCTION MODE
	JRST	ESCMOD

ESC..I:
	SKIPA	T1,[EXP 5]	;SETTING EBCDIC OUTPUT
ESC..T:
	MOVEI	T1,4		;SETTING ASCII OUTPUT
	SKIPN	T5		;DID USER SPECIFY NUMBER OF BYTES ?
	  MOVEI	T5,2		;DEFAULT IS 2
SUBTTL	MORE ESCAPE ROUTINES ($$)

ESCMOD:
	SKIPN	T5
	  MOVEI	T5,1		;DEFAULT IS ONLY ONE
	HRRM	T5,BYTCNT
	PUSHJ	P,TABTYP
	HRRM	T1,O.MODE	;SET CURRENT MODE
	TRZN	FLG,F..ESC
	  JRST	LEVEL2		;NOT SETTING PERMANENT MODE
	HRLS	BYTCNT		;LOCAL COUNT IS PERMANT COUNT
	HRLM	T1,O.MODE	;SET PERMANT MODE
	JRST	LEVEL2

SUBTTL	MORE ESCAPE ROUTINES (V)

;ESCAPE V - WATCH A LOCATION FOR VARIANCE
ESC..V:
	SKIPE	MEMORY
	  JRST	ILLCHR
	TRNN	FLG,F.LOPN	;IS LOCATION OPEN ?
	  JRST	ILLCHR		;GIVE USER "?"
	AOJ	T5,		;DON'T ALLOW ZERO (FILLS QUEUE)
	TXNN	FLG,F..ESC	;ONE $ OR TWO?
	IMULI	T5,^D100		;IN TENTHS OF A SEC UNLESS $$
ESC.V0:
	MOVE	T1,T5		;GET SLEEP AMOUNT
	DISMS			;DISMISS PROCESS
	MOVE	T1,DOT		;GET ADDRESS TO WATCH
	TRZ	FLG,F.CACH	;NO CACHE, PLEASE
	PUSHJ	P,GETWRD	;GET DATA
	  JRST	ILLCHR
	MOVE	T2,T1		;COPY DATA
	XOR	T2,DATA		;COMPARE TO LAST TIME
	AND	T2,S.MASK	;MASK OFF IRREVELANT BITS
	JUMPE	T2,ESC.V9	;BRANCH IF SAME AS BEFORE
	TYPE	[BYTE (7)15,12,0]
	PUSH	P,T1		;SAVE NEW DATA
	MOVEM	T1,DATA		;SAVE NEW DATA
	MOVE	T1,DOT		;GET ADDRESS
	PUSH	P,T5		;SAVE T5
	PUSHJ	P,ADRTYP
	TYPE	[ASCIZ \/	\]
	PUSHJ	P,DATYPE	;TYPE NEW DATA
	POP	P,T5		;
	POP	P,DATA		;IN CASE DATYPE CHANGED IT
ESC.V9:
	SKPINC			;HAS USER TYPED A CHARACTER ?
	JRST	ESC.V0		;NO SO KEEP WATCHING
	JRST	LEVEL2		;GO PROCESS NEXT COMMAND

SUBTTL	MORE ESCAPE ROUTINES (M,N,W)

ESC..M:
	TRO	FLG,F.MASK	;MASK IS OPEN
	MOVEI	STATE,STATEE	;EVALUATE AS AN EXPRESSION
	JRST	LEVEL3		;GET REST OF COMMAND

ESC..N:
	TROA	FLG,F.FLIP	;FLAG WE ARE DOING NOT SEARCH
	JRST	ESC..W		;AND SEARCH

ESC..O:				;HERE TO OPEN FE DEVICE
	TXNN	FLG,F..ESC	;TWO ALT-MODES?
	JRST	ILLCHR		; NO, ONLY ONE, USER CONFUSED
	JUMPL T5,ILLCHR		;ILLEGAL IF NEGATIVE DTE REQUESTED
	CAIL	T5,10		;FE0-7 ARE LEGAL
	JRST	ILLCHR		;ILLEGAL
	LSH	T5,17		;THIRD BYTE OF 5
	ADD	T5,FEDEV	;FRONT END DEVICE SPEC
	MOVE	T1,T5		;DEVICE TO OPEN
	SETOM	FEFLG		;SET FLAG FOR REMOTE EXAM/DEP
	PUSHJ	P,OPNFE		;OPEN THE FRONT END DEVICE
	JRST	[
		 PUSHJ P,WARN
		 JRST LEVEL2]
	PUSHJ P,CRLTYP		;RETURN CARRIAGE
	TYPE	[ASCIZ \[FEDDT - FRONT END PDP-11 CORE OPEN]\]
	PUSHJ P,CRLTYP		;AND RETURN CARRIAGE AGAIN
	JRST	LEVEL2		;DONE

SUBTTL	MORE ESCAPE ROUTINES

;HERE FOR (ALTMODE)W WHICH IS WORD SEARCH
ESC..W:
	TRZ	FLG,F.FLIP	;FLAG WE WANT MATCHES
	MOVE	T1,EXPRESS	;GET WHAT TO SEARCH FOR
	AND	T1,S.MASK
	MOVEM	T1,S.WORD
	MOVE	DOT,SBEGIN
	PUSH	P,T1		;SO WE CAN COME BACK TO ESC.W2
ESC.W2:				;.HERE WITH T1 ON STACK
	POP	P,T1		;.RESTORE T1 FROM TYPE CHECK
	MOVE	T1,DOT
	TRZ	FLG,F.CACH	;NO CACHE, PLEASE
	PUSHJ	P,GETWRD	;GET CURRENT LOC
	  JRST	ESCW.9
	MOVEM	T1,DATA		;SAVE DATA
	AND	T1,S.MASK	;MASK SOME OF THE BITS
	TRNE	FLG,F.FLIP	;ARE WE LOOKING FOR MATCH ?
	  JRST	[	CAMN	T1,S.WORD	;DON'T WANT MATCH
			  JRST	ESCW.8
			JRST	ESCW.6 ]
	CAME	T1,S.WORD
	  JRST	ESCW.8
ESCW.6:
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	MOVE	T1,DOT		;GET ADDRESS
	PUSHJ	P,ADRTYP
	TYPE	[ASCIZ \/	\]
	PUSHJ	P,DATYPE
	PUSH	P,T1		;SAVE T1
	MOVX	T1,<.PRIIN>	;.PRIMARY INPUT
	SIBE			;.CHECK IF TYPE AHEAD
	JRST	ESCW.T		;. YES
	POP	P,T1		;.  NO, RESTORE T1
;	[CODE CONTINUES ON NEXT PAGE]

SUBTTL	MORE OF ESCAPE W

;	[CODE MAY HAVE FALLEN THROUGH FROM LAST PAGE]

ESCW.8:
	ADDI	DOT,2
	CAMLE	DOT,S..END
	  JRST	ESCW.9
	PUSH	P,T1		;SAVE T1 FROM MASHING MONITOR
	MOVX	T1,<.PRIIN>	;.PRIMARY INPUT
	TRNN	DOT,377		;.DON'T DO TOO MANY JSYS'S
	SKIPA
	JRST	ESC.W2		;.DON'T DO SO MANY JSYS'S
	SIBE			;.SKIP IF NO TYPE AHEAD
	JRST	ESCW.T		;. TYPE AHEAD
	JRST	ESC.W2		;.NO TYPE AHEAD, GO ON
ESCW.9:
	PUSHJ	P,CRLTYP	;TYPE 2 C.R.LF.
	PUSHJ	P,CRLTYP	; "
	JRST	LEVEL2
ESCW.T:				;HERE WHEN INTER BY CHAR TYPED
	POP	P,T1
	JRST	ESCW.9

ESC..X:
	TXNN	FLG,<F..ESC>	;ONCE OR TWICE?
	JRST	RDCMP0		;USE IN CORE FILE
	JRST	RDCMPR		;TWICE, READ FILE

ESC..Y:				;ESCAPE Y
	TXNN	FLG,<F..ESC>	;TYPED ESCAPE ONCE OR TWICE?
	JRST	RDDUMP		; ONCE
	JRST	RDSYMB		; TWICE

;ROUTINE TO GET A WORD FROM THE PDP-11
; CALL	PUSHJ	P,GETWRD	;WITH ADR IN T1
;	ERROR RETURN
;	SUCCES	DATA IN T1
;
;	IF THE CACHE FLAG (F.CACH) IS ON, WE WILL TRY TO
;	GET THE WORD FROM THE CACHE. IF IT IS NOT IN THE
;	CACHE, WE WILL PUT IT IN IN EITHER CASE.
;
GETWRD:
	PUSH	P,T3
	PUSH	P,T4
	SETZ	T4,
	HRRZM	T1,T3
	MOVEI	T2,1		;FUNCTION 1
	SKIPN	T1,MEMORY	;DO I HAVE MEMORY IN CORE ?
	  JRST	GETWD1		;NO
	ROT	T3,-2		;4 ADDRS PER WORD
	ADDI	T1,(T3)		;ADD BASE ADDRESS
	CAML	T1,MEMLIM	;IS IT IN RANGE ?
	  JRST	GETWD5		;ERROR RETURN
GETWD0:
	JUMPGE	T3,.+3		;T3 SIGN ON IFF HIGH PART
	HRRZ	T1,(T1)
	JRST	GETWD3
	HLRZ	T1,(T1)
	JRST	GETWD3
;HERE TO DO STATION CONTROL TO GET DATA
GETWD1:
	SKIPN	FEFLG			;CHECK FOR REMOTE FE
	JRST	GETWD4			;IGNORE REQUEST
	TRNN	FLG,F.CACH		;ARE WE USING CACHE?
	JRST	GETWDC			; NO, GET WORD FROM CORE
	JUMPE	T3,GETWDC		;ZERO ALWAYS IN 11
	CAMGE	T3,CACHEA		;IN RANGE FOR CACHE?
	JRST	GETWDC			; NO
	CAMLE	T3,CACHEL		;CACHE LIMIT
	JRST	GETWDC			; OUT OF CACHE
	SUB	T3,CACHEA		;REL ADDR IN CACHE
	MOVE	T1,CACHE(T3)
	JRST	GETWD3			;AND RETURN
GETWDC:
	PUSH	P,T3			;SAVE ADDRESS
	MOVE	14,[BYTE (16)IO.RLB(8)"E","M"]
	MOVEM	14,PKT
	SETZM	PKT+1
	SETZM	PKT+2
	DPB	3,[POINT ^D16,PKT+2,15]
	MOVEI	3,2
	DPB	3,[POINT ^D16,PKT+2,31]
	MOVEI	1,0(15)
	MOVE	2,[442000,,PKT]	;;;0001;;;
	MOVNI	3,6		;;;0001;;;
	SOUT
	ERJMP	[PUSHJ P,WARN		;FAILED?
		 JRST GETWD4		;SO RETURN 
		]
	MOVEI	2,.MOEOF
	SETO	3,
	MTOPR
	ERJMP	[PUSHJ P,WARN		;FAILED?
		 JRST GETWD4		;SO RETURN
		]
	PUSHJ	P,GETPKT	;GET THE RETURN PACKET
	JRST	[	POP	P,T3	;ERROR OCCURRED
			JRST	GETWD4
		]
	LDB	1,[POINT ^D16,PKT1+3,15]
	POP	P,T3		;ADDR REQUESTED
	MOVE	T4,CACHEL	;OLD CACHE LIMIT
	ADDI	T4,2		;TEST FOR NEXT ADDR
	CAIN	T3,(T4)		;IS NEW ADDR JUST NEXT ONE?
	JRST	GETWNC		; YES, SO JUST ADD IT
	MOVEM	T3,CACHEA	; NO, FRESH ENTRY
	MOVEM	T3,CACHEL	;SO IS WHOLE CACHE
	JRST	GETWDD		;AND GO ON
GETWNC:
	MOVEM	T4,CACHEL	;NEW LIMIT
GETWDD:
	MOVE	T4,CACHEA	;START OF CACHE
	SUB	T3,T4		;PROPER ADDRESS
	MOVEM	T1,CACHE(T3)	;STORE INTO CACHE
GETWD3:
	AOS	-2(P)		;SKIP RETURN
GETWD4:
	POP	P,T4
	POP	P,T3
	POPJ	P,
GETWD5:
	SUB	T1,MEMORY	;BASE ADDRESS
	LSH	T1,2		;TRUE ANSWER FOR CORE SIZE
	JRST	GETWD4

GETPKT:	MOVE	2,[POINT 16,PKT1]	;;;0001;;;
	MOVNI	3,6	;;;0001;;;;GET THE FIXED PORTION
	SIN			;OF THE PACKET
	ERJMP	[PUSHJ P,WARN		;FAILED?
		 POPJ P,		;SO RETURN
		]
	LDB	3,[POINT 16,PKT1+2,32-1]
	JUMPLE	3,GETPK1	;IF ANY MORE
	LSH	3,-1		;;;0001;;;IN WORDS
	MOVN	3,3		;THEN
	SIN			;GET THE REST.
	ERJMP	[PUSHJ P,WARN		;FAILED?
		 POPJ P,		;SO RETURN
		]
GETPK1:
	LDB	T1,[POINT 8,PKT1+1,32-1]
	MOVN	T1,T1		;DOES THE RETURN STATUS
	ANDI	T1,377		;INDICATE
	TRNE	T1,200		;FAILURE ?
	AOS	(P)		;NO -- NORMAL RETURN
	POPJ	P,

SUBTTL	DEPOSIT IN PDP11 MEMORY

; CALL	PUSHJ	P,PUTWRD	;WITH ADR IN T1 & DATA IN T2
PUTWRD:
	PUSH	P,T3
	PUSH	P,T4
	MOVEM	T1,T3
	SKIPE	MEMORY		;DID WE READ A DUMP ?
	  JRST	GETWD4		;YES DON'T TRY ANYTHING
	SKIPN	FEFLG		;DID WE OPEN FE DEVICE?
	JRST	GETWD4		; NO, SO DIE
	SETZM	CACHEL		;INVALIDATE CACHE
	MOVE	14,[BYTE (16)IO.WLB(8)"E","M"]
	MOVEM	14,PKT
	DPB	T2,[POINT ^D16,PKT+3,15]
	MOVEI	2,2
	DPB	2,[POINT ^D16,PKT+2,31]
	DPB	3,[POINT ^D16,PKT+2,15]
	MOVNI	3,11	;;;0001;;;
	MOVEI	1,0(15)
	MOVE	2,[442000,,PKT]	;;;0001;;;
	SOUT
	MOVEI	2,.MOEOF
	SETO	3,
	MTOPR
	ERJMP	GETWD4		;ERROR, SO COMPLAIN
	PUSHJ	P,GETPKT	;GET THE RETURN PACKET
	JRST	GETWD4		;(ERROR)
	JRST	GETWD3		;SUCCESS

CAL1ER:
	TYPE	[ASCIZ \?\]
	PUSHJ	P,OCTYPE
	TYPE	[ASCIZ \?	\]
	POPJ	P,

SUBTTL	SYMBOL TABLE ROUTINES

;SYMBOLS ARE KEPT IN THREE WORD BLOCKS(ALPHABETIZED) STARTING AT LOCATION POINTED TO BY SYMBEG
; 1ST WORD IN BLOCK IS SIXBIT SYMBOL
; 2ND WORD IS HALF WORD FLAGS,,VALUE
	SMF.SU==000001	;SYMBOL IS SUPPRESSED(DEFINED WITH =)
	SMF.RG==000002	;SYMBOL IS A REGISTER VALUE
	SMF.IN==000010	;SYMBOL IS AN INSTRUCTION
	SMF.DD==000020	;LOW ORDER SIX BITS ARE DESTINATION
	SMF.SS==000040	;LOW ORDER 12 BITS ARE SSDD
	SMF.XX==000100	;LOWORDER 8 BITS ARE XXX(E.G. BR)
	SMF.SB==000200	;SOB TYPE ADDRESS
	SMF.RT==000400	;RTS TYPE REGISTER USAGE
	SMF.JS==001000	;JSR TYPE REGISTER USAGE
	SMF.EM==002000	;EMT TYPE ARGUMENT
	SMF.AS==004000	;ASH TYPE NN ARG
	SMF.PL==010000	;SET PROCESSOR LEVEL
; 3RD WORD IS LINK TO NEXT SYMBOL BLOCK

;HERE TO FIND A MATCH FOR A SYMBOL
; CALL	MOVE	T1,[SIXBIT \SYMBOL\]
;	PUSHJ	P,SYMFND
;	  ERROR RETURN
;	SUCCESS RETURN	SYM POINTS TO SYMBOL
SYMFND:
	SKIPN	SYM,SYMBEG		;GET ADR OF BEGINING OF SYMBOL TABLE
	  POPJ	P,			;CAN'T FIND SYMBOL
SYMFN1:
	CAMN	T1,(SYM)	;HAVE WE FOUND THE SYMBOL ?
	  JRST	CPOPJ1		;YES
	HRRZ	SYM,2(SYM)	;GET ADR OF NEXT SYMBOL BLOCK
	JUMPN	SYM,SYMFN1
	POPJ	P,		;CAN'T FIND SYMBOL

;HERE TO SEE IF WE CAN FIND A MATCH FOR AN INSTRUCTION
; CALL	MOVEI	T1,<VALUE>
;	PUSHJ	P,INVLFN
;	LOSE RETURN
;	WIN RETURN
INVLFN:
	SKIPN	SYM,SYMBEG		;ADDRESS OF FIRST SYMBOL BLOCK
	  POPJ	P,			;NO SYMBOL TABLE
INVLF1:
	MOVE	T2,1(SYM)		;GET SYMBOL VALUE
	TLNN	T2,SMF.IN		;IS THIS AN INSTRUCTION ?
	  JRST	INVLF8
	LDB	T3,[POINT 5,1(SYM),4]	;GET NUMBER OF BITS IN INSTRUCTION
	MOVE	T3,MASKTB-1(T3)		;GET MASK FOR INSTRUCTION
	AND	T3,T1			;MASK ARGUMENT
	CAIE	T3,(T2)			;IS THIS A MATCH ?
	  JRST	INVLF8			;NO
CPOPJ1:
	AOS	(P)			;FOR SKIP RETURN
CPOPJ:
	POPJ	P,

INVLF8:
	HRRZ	SYM,2(SYM)		;GET ADR OF NEXT SYMBOL BLOCK
	JUMPN	SYM,INVLF1
	POPJ	P,
MASKTB:	EXP	100000
	EXP	140000,160000,170000
	EXP	174000,176000,177000
	EXP	177400,177600,177700
	EXP	177740,177760,177770
	EXP	177774,177776,177777
SUBTTL	HERE TO FIND A NAME FOR A REGISTER

; CALL:	MOVEI	T1,#	;REGISTER NUMBER
;	PUSHJ	P,RGFNDN
;	LOSE
;	BINGO
RGFNDN:
	SKIPN	SYM,SYMBEG	;GET FIRST SYMBOL BLOCK ADR
	  POPJ	P,		;NO SYMBOL TABLE
RGFND1:
	MOVE	T2,1(SYM)	;GET SYMBOL VALUE
	TLNN	T2,SMF.RG	;IS THIS A REGISTER ?
	  JRST	RGFND8		;NO
	CAIE	T1,(T2)		;IS THIS WHAT WE WANTED ?
	  JRST	RGFND8		;NO
	AOS	(P)		;SKIP RETURN
	POPJ	P,
RGFND8:
	HRRZ	SYM,2(SYM)	;GET NEXT SYMBOL BLOCK
	JUMPN	SYM,RGFND1		;NOT YET
	POPJ	P,		;ERROR RETURN
SUBTTL	ADD A SYMBOL TO TABLE

; CALL	PUT SYMBOL IN T1, PUT VALUE AND FLAGS IN T2, MISC IN T3

ADDSYM:
	MOVE	SYM,SYMBEG	;GET ADDRESS OF FIRST SYMBOL BLOCK
ADSYM1:
	CAMN	T1,@SYM		;DOES THIS MATCH ?
	JRST	REPSYM		; YES, REPLACE SYMBOL
	HRRZ	SYM,2(SYM)	;GET ADDRESS OF NEXT SYMBOL BLOCK
	JUMPN	SYM,ADSYM1

;MAKE A NEW SYMBOL BLOCK
	MOVE	T4,TOPCOR	;PUT IT IN HIGH CORE SOMEWHERE
	ADDI	T4,3
	MOVEM	T4,TOPCOR	;UPDATE PTR
	SUBI	T4,3		;MAKE ADDRESS OF BLOCK AGAIN
	MOVE	SYM,SYMEND	;GET ADDRESS OF LAST SYMBOL BLOCK
	HRRZM	T4,2(SYM)
	HRRZM	T4,SYMEND
	MOVEM	T4,SYM
	MOVEM	T1,0(SYM)
	MOVEM	T2,1(SYM)
	SETZM	2(SYM)
	POPJ	P,

REPSYM:			;REPLACE OLD VALUE
	PUSH	P,T1		;SAVE SYMBOL NAME
	PUSH	P,T2		;AND NEW VALUE
	HRRZ	T1,1(SYM)	;GET OLD VALUE (NO FLAGS)
	CAIN	T1,(T2)		;SAME (DISREGARD FLAGS)?
	JRST	REPSY1		; YES
	MOVE	T1,-1(P)	; NO, GET OLD NAME
	PUSHJ	P,SIXTYP	;TYPE OLD NAME
	PUSHJ	P,TABTYP	;TAB OVER
	MOVE	T1,1(SYM)	;GET OLD VALUE
	PUSHJ	P,OCTYPE	;TYPE IN OCTAL
	PUSHJ	P,TABTYP	;TAB OVER
	HRRZ	T1,(P)		;GET NEW VALUE
	PUSHJ	P,OCTYPE	;TYPE OLD VALUE
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
REPSY1:
	POP	P,1(SYM)	;SET NEW VALUE
	POP	P,T1		;AND SYMBOL NAME
	POPJ	P,		;DONE

SUBTTL	MORE SYMBOL TABLE ROUTINES

;HERE TO FIND A NEAR MATCH FOR A VALUE
; CALL	MOVEI	T1,VALUE TO MATCH
;	PUSHJ	P,VALFND
;	  ERROR RETURN
;	RETURN WITH SYM SET UP
VALFND:
	SKIPE	SUPSYM		;SUPPRESS ALL SYMBOLS?
	POPJ	P,		; YES
	PUSH	P,T4
	SETZ	SYM,
	MOVE	T2,SYMBEG	;ADR OF FIRST SYMBOL BLOCK
VLFND1:
	MOVE	T3,1(T2)	;GET SYMBOL'S VALUE
	TRNE	T3,177777	;IS VALUE ZERO ?
	TLNE	T3,SMF.SU!SMF.IN!SMF.RG	;IS SYMBOL SUPPRESSED OR INSTRUCTION ?
	  JRST	VLFND7		;YES SO DON'T TRY IT
	CAIGE	T1,400(T3)	;IS SYMBOL VALUE MUCH LESS THAN DESIRED ?
	CAIGE	T1,(T3)		;IS SYMBOL VALUE .LE. DESIRED VALUE ?
	  JRST	VLFND7		;NO
	JUMPE	SYM,VLFND4
	CAIL	T4,(T3)		;IS SYMBOL BETTER THAN LAST MATCH ?
	  JRST	VLFND7		;NO
VLFND4:
	MOVE	SYM,T2		;BEST MATCH SO FAR
	HRRZ	T4,T3		;COPY VALUE FOR FUTURE REFERENCE
VLFND7:
	HRRZ	T2,2(T2)	;GET ADDRESS OF NEXT BLOCK
	JUMPN	T2,VLFND1
	SKIPE	SYM
	AOS	-1(P)
	POP	P,T4
	POPJ	P,


;HERE TO READ A SYMBOL TABLE FROM A LISTING

RDSYMB:
	PUSHJ	P,CRLTYP
	PROMPT	[ASCIZ \SYMBOL FILE:	\]
	PUSHJ	P,OPNFLA	;OPEN FILE TO READ SYMBOLS FROM
	JRST	LEVEL0
	MOVE	T1,[440700,,OPNSTR] ;USE STRING SPACE
	MOVE	T2,INJFN	;INPUT JFN
	MOVX	T3,<JS%TYP>
	SETZM	OPNSTR		;CLEAR BUFFER
	JFNS			;GET TYPE INTO OPNSTR
	HRROI	T2,-1		;ASSUME NOT A MAP
	MOVE	T1,[ASCII /MAP/]
	CAMN	T1,OPNSTR	;IS THIS A MAP?
	MOVEI	T2,11		; YES, IS A MAP
	MOVEM	T2,MAPCHR	;SO TREAT TABS NICELY
GETSC0:
	SETZ	T5,		;COUNT OF SYMBOLS
	SKIPL	MAPCHR		;IS THIS A MAP?
	JRST	GETSC1		; YES
	JSR	GETSCH
	CAIE	T1,14		;IS THIS A FORM FEED ?
	  JRST	GETSC0		;LOOK FOR ONE
GETSC1:
	JSR	GETSCH
	CAIE	T1,12		;IS THIS A LINE FEED ?
	  JRST	GETSC1		;LOOK FOR ONE
GETSC2:
	JSR	GETSCH
	CAIE	T1,12		;IS THIS A LINE FEED ?
	  JRST	GETSC2		;LOOK FOR ONE
GETSCY:				;HAVE A SYMBOL
	SETZB	T3,SYMBOL	;BUILD SYMBOL HERE
	MOVE	T2,[POINT 6,SYMBOL]
;	[CODE FALLS THROUGH TO NEXT PAGE]

;	[CODE MAY HAVE FALLEN THROUGH FROM LAST PAGE]
GETSCT:
	JSR	GETSCH		;GET CHAR
	SKIPG	MAPCHR		;IS THIS A MAP FILE?
	JRST	GETSCU		; NO
	CAMN	T1,MAPCHR	;IF MAP, IS THIS TAB?
	JRST	GETSCT		; YES, IGNORE TABS AT BEGINNING
	CAIN	T1,40		;OR IS IT SPACE AT LINE BEGIN?
	JRST	GETSCT		; YES, SO IGNORE IT
	CAIA			; NO, HAVE CHARACTER
GETSC3:
	JSR	GETSCH
GETSCU:
	CAIG	T1,40
	  JRST	GETSC4		;IF SO HAVE FINISHED SYMBOL
	CAIN	T1,75		;IF = FINISHED
	JRST	GETSC4
	CAMN	T1,MAPCHR	;IF MAP, IS THIS A TAB?
	JRST	GETSC4		; YES, MAY BE SYMBOL
	SUBI	T1,40		;CONVERT TO SIXBIT
	CAME	T2,[POINT 6,SYMBOL,35]	;FILLED WORD YET ?
	  IDPB	T1,T2		;NO SO KEEP FILLING
	JRST	GETSC3

SUBTTL	MORE OF READ SYMBOL TABLE

GETSC4:	CAIN	T1,75		;SYMBOLS END WITH SPACE OR =
	JRST	[	JUMPE	SYMBOL,GETSC2
			SETZ	T4,
			JRST	GETSC7]
	CAME	T1,MAPCHR	;IF MAP, MAY END WITH TAB
	CAIN	T1,40
	JRST	GETSCS		; NOW HAVE SYNBOL, GET VALUE
	  JRST	GETSC2		; NOT SYMBOL - FLUSH LINE
GETSCS:
	JUMPE	SYMBOL,GETSC2	;IF NO SYMBOL FLUSH LINE
	SETZ	T4,		;FLAGS
GETSC5:	JSR	GETSCH
	CAIN	T1,40
	  JRST	GETSC5
GETSC7:	CAIN	T1,"="
	  JRST	[	TRO	T4,SMF.SU	;SUPPRESSED SYMBOL
			JRST	GETSC5	]
	CAIN	T1,"%"
	  JRST	[	TRO	T4,SMF.RG	;REGISTER NAME
			JRST	GETSC5	]
	CAIL	T1,60
	CAILE	T1,67
	  JRST	GETSC2		;FLUSH REST OF LINE
GETSC6:
	IMULI	T3,^D8
	ADDI	T3,-60(T1)
GETSC9:
	JSR	GETSCH
	CAIL	T1,60
	CAILE	T1,67
	  CAIA
	JRST	GETSC6
	SKIPL	MAPCHR		;IS THIS A .MAP FILE?
	CAIE	T1,"-"		;HYPHENS FROM MAP?
	CAIA
	JRST	GETSC9		; YES, IGNORE THEM
	CAIN	T1,"R"		;IS IT RELOCATABLE?
	JRST	GETSCR		; YES, SO RELOCATE IT

SUBTTL	MORE OF READ SYMBOL TABLE

GETSC8:
	MOVE	T1,SYMBOL	;COPY SYMBOL
	HRRZ	T2,T3		;VALUE
	HRL	T2,T4		;FLAGS
	SETZ	T3,
	PUSH	P,SYMEND
	PUSHJ	P,ADDSYM
	POP	P,T1		;GET OLD SYMEND
	CAME	T1,SYMEND
	  AOS	T5		;COUNT SYMBOL
	SKIPG	T1,MAPCHR		;IS THIS A .MAP?
	JRST	GETSC2		; NO, FLUSH REST OF LINE
	CAIE	LC,40		;WAS LAST CHR SPACE OR
	CAMN	LC,T1		;WAS LAST CHR TAB?
	JRST	GETSCY		; YES, SO GET NEXT SYMBOL FROM MAP
	JRST	GETSC2		; NO, FLUSH REST OF LINE


SUBTTL	MORE SYMBOL TABLE INPUT

GETSCH:
	0
	PUSHJ	P,FILCHR	;GET CHAR FROM FILE
	JRST	GTSCH5		;DONE
	MOVE	LC,T1		;SAVE LAST CHR INPUT
	JRST	@GETSCH
GTSCH5:
	MOVE	T1,INJFN	;INPUT JFN
	CLOSF			;CLOSE FILE
	PUSHJ	P,WARN
	TYPE	[ASCIZ \ loaded \]
	MOVE	T1,T5
	PUSHJ	P,DECTYP
	TYPE	[ASCIZ \ symbols
\]
	JRST	LEVEL0

GETSCR:				;HERE TO TRY TO RELOCATE A SYMBOL
	SKIPL	MAPCHR		;IS THIS A MAP?
	JRST	GETSRR		; YES, SO JUST A FLAG
	SKIPN	T1,RELVAL	;DO WE HAVE A RELOCATION?
	JRST	GETSC2		; NO, SO DON'T STORE SYMBOL
	ADDI	T3,(T1)		; YES, SO ADD RELOCATION
GETSRR:
	JSR	GETSCH		;GET NEXT CHR FOR SEPR CHECK
	JRST	GETSC8		;AND RETURN TO LOOP


SUBTTL	FILE ROUTINES

;HERE TO OPEN A FILE TO READ
; CALL
;	PUSHJ	P,OPNFIL
;	  LOSE RETURN
;	WIN RETURN
OPNFIL:
	MOVEI	T1,<OPNJFN>		;LONG FORM
	MOVEI	T2,0			;FROM USER
	GTJFN			;GET JFN OF FILE
	JRST	[PUSHJ P,WARN
		 POPJ	P,]
	HRRZM	T1,INJFN		;SAVE INPUT JFN
	MOVE	T2,[17B9+OF%NWT+OF%RD]	;DUMP MODE
	OPENF
	JRST	[PUSHJ P,WARN
		 POPJ P,]
	AOS (P)			;SKIP RETURN
	POPJ	P,		;


OPNFLA:				;OPEN FILE IN ASCII
	MOVX	T1,<GJ%OLD!GJ%CFM!GJ%FNS!GJ%SHT>
	MOVE	T2,[.PRIIN,,.PRIOU]	;PRIMARY
	GTJFN			;GET JFN OF FILE
	JRST	[PUSHJ P,WARN
		 POPJ	P,]
	HRRZM	T1,INJFN		;SAVE INPUT JFN
	MOVE	T2,[07B5+OF%RD]	;18 BIT INPUT, READ ONLY
	OPENF
	JRST	[PUSHJ P,WARN
		 POPJ P,]
	AOS (P)			;SKIP RETURN
	POPJ	P,		;


SUBTTL	MORE FILE ROUTINES

;
;	WARN USER OF ERROR
;
WARN:
	SETZM	LPTFLG		;CLEAR TO LPT FLAG
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	TYPE	[ASCIZ \?FEDDT - \]
	MOVE T1,[.PRIOU]
	 MOVE T2,[.FHSLF,,-1]	;LAST ERR
	 SETZ T4,
	 ERSTR			;FULL MESSAGE
	 JFCL
	 JFCL
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE AGAIN
	POPJ	P,

;HERE TO GET NEXT CHAR FROM A FILE
FILCHR:
	PUSH	P,T2		;SAVE T2 FROM DESTR
	MOVE	T1,INJFN
	BIN			;INPUT CHR
	PUSH	P,T2		;CHR FROM FILE
	GTSTS			;GET INPUT FILE STATUS
	TLNN	T2,(GS%EOF)	;END-OF-FILE?
	AOS	-2(P)		; NO
	POP	P,T1		;RESTORE CHAR TO T1
	POP	P,T2		;RESTORE T2
	POPJ	P,

SUBTTL	SIXBIT TTY INPUT

GETCHR:
	PUSH	P,T2		;SAVE REG
	MOVX	T1,.PRIIN	;PRIMARY INPUT
	BIN			;BYTE IN
	MOVE	T1,T2		;CHR
	POP	P,T2
	JSR	GETCH0
	JRST	GETCHR
GETCH0:	0
	JUMPE	T1,@GETCH0	;FLUSH NULLS
	CAIN	T1,15		;IS THIS A CARRIAGE RETURN ?
	  JRST	[	PUSHJ	P,GETCHR	;GET LF
			MOVEI	T1,15	;MAKE LF
			JRST	.+1	]
	CAIL	T1,40+"A"	;CHECK FOR LOWER CASE
	CAILE	T1,40+"Z"
	  CAIA
	TRZ	T1,40		;CONVERT TO LOWER CASE
	POPJ	P,

SUBTTL	MORE TTY INPUT ROUTINES

;HERE TO GET A SIXBIT WORD FROM TTY
SIXIN:	0
	MOVE	T4,[POINT 6,T2]
	SETZ	T2,
SIXIN2:	PUSHJ	P,GETCHR	;GET A CHAR FROM TTY
	CAIN	T1,177
	  JRST	[	TYPE	[ASCIZ \xxx\]
			JRST	@SIXIN ]
	CAIL	T1,"0"
	CAILE	T1,"Z"
	  JRST	SIXIN9		;RETURN
	CAILE	T1,"9"
	CAIL	T1,"A"
	  CAIA
	JRST	SIXIN9		;RETURN
	SUBI	T1,40
	CAME	T4,[POINT 6,T2,35]	;HAVE WE ALREADY FILLED WORD ?
	  IDPB	T1,T4		;NOT YET
	JRST	SIXIN2
SIXIN9:	EXCH	T1,T2
	AOS	SIXIN
	JRST	@SIXIN

;HERE TO CONVERT SIXBIT TO OCTAL
SIXOCT:	Z
	MOVE	T4,[POINT 6,T1]
	SETZ	T2,
SIXOC1:	ILDB	T3,T4
	JUMPE	T3,SIXOC9
	CAIL	T3,20
	CAILE	T3,27
	  JRST	@SIXOCT		;CAN'T CONVERT
	IMULI	T2,^D8
	ADDI	T2,-20(T3)
	CAME	T4,[POINT 6,T1,35]	;DONE ALL OF WORD ?
	  JRST	SIXOC1
SIXOC9:	EXCH	T1,T2
	AOS	SIXOCT
	JRST	@SIXOCT
SUBTTL	TTY ROUTINES

;HERE TO DISPLAY CONTENTS OF T1 AS AN ADDRESS
ADRTYP:	ANDI	T1,177777	;SIXTEEN BITS ONLY PLEASE
	HRROM	T1,LSTADR	;SAVE LAST ADDRESS DISPLAYED
	PUSHJ	P,VALFND	;SEE IF WE CAN FIND A SYMBOL
	  JRST	RADTYP		;TYPE ADDR IN CURRENT RADIX
	PUSH	P,T1		;SAVE VALUE
	MOVE	T1,(SYM)	;GET SYMBOL NAME
	PUSHJ	P,SIXTYP	;TYPE SYMBOL
	POP	P,T1		;GET VALUE AGAIN
	SUB	T1,1(SYM)	;GET DISPLACEMENT
	ANDI	T1,177777	;STRIP EXTRA BITS
	JUMPE	T1,CPOPJ	;IF EXACT WE ARE DONE
	PUSH	P,T1		;SAVE REMAINDER
	MOVEI	T1,"+"
	PUSHJ	P,TYPCHR
	POP	P,T1
	JRST	RADTYP		;TYPE REST IN CURRENT RADIX

;HERE TYPE DATA
DATYPE:	HRRZ	T5,BYTCNT	;REPETITION COUNT
	SETZM	LSTADR
	SETZM	DOTFOO
	MOVE	T1,DATA		;GET DATA TO TYPE
	HRRZ	T2,O.MODE	;GET OUTPUT MODE
	JRST	@[DATINS
		  DATADR
		  DATNUM
		  DATBYT
		  DATASC
		  DATEBC
		  DATR50](T2)
DATNUM:	PUSHJ	P,RADTYP	;TYPE AS NUMERIC
	SOJLE	T5,DATYP8
	PUSHJ	P,BLANKT
	JSR	NXTDWD		;GET NEXT DATA WORD
	JRST	DATNUM
NXTDWD:	0
	SKIPN	DOTFOO			;DONE 2ND WORD YET
	  MOVE	DOTFOO,DOT
	ADDI	DOTFOO,2
	MOVE	T1,DOTFOO
	PUSHJ	P,GETWRD		;FIND WHAT NEXT WORD IS
	  JRST	DATYP8			;CAN'T READ NEXT WORD !
	MOVEM	T1,DATA
	JRST	@NXTDWD

SUBTTL	MORE TYPEOUT ROUTINES

;HERE TO TYPE DATA AS AN ADDRESS
DATADR:
	PUSHJ	P,ADRTYP
	SOJLE	T5,DATYP8	;HAVE WE DONE ENOUGH ?
	PUSHJ	P,BLANKT	;TYPE A SPACE TO SEPERATE FIELDS
	JSR	NXTDWD		;GET NEXT DATA WORD
	JRST	DATADR		;AND TYPE NEXT WORD
;HERE TO TYP DATA AS INSTRUCTIONS
DATINS:	PUSHJ	P,INVLFN	;SEE IF WE CAN FIND AN INSTRUCTION TO MATCH
	  JRST	DATNUM
	MOVE	T1,(SYM)	;GET INSTRUCTION NAME
	PUSHJ	P,SIXTYP
	MOVE	T5,1(SYM)	;GET FLAGS AGAIN
;	TLNN	T5,SMF.RT!SMF.JS!SMF.DD!SMF.XX!SMF.SS!SMF.SB!SMF.EM	;AND ADDRESS ARGUMENTS ?
;	  JRST	DATYP8		;NO SO DONE
	PUSHJ	P,BLANKT	;TYPE A BLANK
	TLNE	T5,SMF.PL	;SPL TYPE INSTRUCTION ?
	  JRST	[	LDB	T1,[POINT 3,DATA,35]	;GET ARGUMENT
			PUSHJ	P,OCTYPE
			JRST	DATYP8 ]
	TLNE	T5,SMF.EM	;EMT TYPE ARGUMENTS ?
	  JRST	[	LDB	T1,[POINT 8,DATA,35]	;GET ARGUMENT
			PUSHJ	P,RADTYP	;TYPE ARGUMENT AS NUMBER
			JRST	DATYP8 ]
	TLNE	T5,SMF.RT	;RTS TYPE ?
	  JRST	[	LDB	T1,[POINT 3,DATA,35]	;GET REG ADR
			PUSHJ	P,DATIN9	;TYPE REG NAME
			JRST	DATYP8	]
	TLNE	T5,SMF.JS	;JSR TYPE ?
	  JRST	[	LDB	T1,[POINT 3,DATA,29]
			PUSHJ	P,DATIN9	;TYPE REG NAME
			PUSHJ	P,COMTYP
			JRST	.+1 ]
	TLNE	T5,SMF.AS	;ASH TYPE NN ?
	  JRST	[	LDB	T1,[POINT 6,DATA,29]	;GET NN
			TRNE	T1,40			;CHECK FOR NEGATIVE
			  IORI	T1,177740		;EXTEND SIGN
			JRST	RADTYP ]
	TLNE	T5,SMF.SB	;SOB TYPE ?
	  JRST	[	LDB	T1,[POINT 3,DATA,29]	;GET REGISTER
			PUSHJ	P,DATIN9	;TYPE REG NAME
			PUSHJ	P,COMTYP
			LDB	T1,[POINT 6,DATA,35]	;GET OFFSET
			IMULI	T1,-2
			ADDI	T1,2(DOT)
			ANDI	T1,177777
			PUSHJ	P,ADRTYP
			JRST	DATYP8	]
	TLNN	T5,SMF.SS	;12BIT SSDD FORMAT ?
	  JRST	DATIN2		;NO
	LDB	T4,[POINT 6,DATA,29]	;GET SS CODE
	PUSHJ	P,DATIN8
	PUSHJ	P,COMTYP
DATIN2:	TLNN	T5,SMF.SS!SMF.DD	;IS THERE A 6 BIT DESTINATION CODE ?
	  JRST	DATIN4		;NO
	LDB	T4,[POINT 6,DATA,35]	;GET DD CODE
	PUSHJ	P,DATIN8
DATIN4:	TLNN	T5,SMF.XX	;IS THIS BR TYPE ADDRESSING ?
	  JRST	DATIN6		;NO
	LDB	T1,[POINT 8,DATA,35]	;GET OFFSET
	TRNE	T1,200		;CHECK FOR NEGATIVE OFFSET
	  IORI	T1,177400
	AOS	T1
	LSH	T1,1		;MAKE WORD ADDRESS
	ADD	T1,DOT
	ANDI	T1,177777	;16 BITS ONLY
	PUSHJ	P,ADRTYP	;TYPE ADDRESS
DATIN6:	JRST	DATYP8
DATIN8:	CAIN	T4,27		;CHECK FOR IMMEDIATE MODE
	  JRST	[	PUSHJ	P,HSHTYP	;TYPE A #
			SKIPN	DOTFOO
			  MOVE	DOTFOO,DOT
			ADDI	DOTFOO,2
			MOVE	T1,DOTFOO
			PUSHJ	P,GETWRD
			  POPJ	P,
			JRST	ADRTYP ]
	CAIN	T4,37		;CHECK FOR ABSOLUTE MODE
	  JRST	[	SKIPN	DOTFOO
			  MOVE	DOTFOO,DOT
			ADDI	DOTFOO,2
			MOVE	T1,DOTFOO
			PUSHJ	P,GETWRD
			  POPJ	P,
			JRST	ADRTYP ]
	TRNE	T4,10		;CHECK FOR DEFERRED MODE
	  PUSHJ	P,[	MOVEI	T1,"@"
			PJRST	TYPCHR ]
	CAIE	T4,77		;CHECK FOR RELATIVE DEFERRED MODE
	CAIN	T4,67		;CHECK FOR RELATIVE MODE
	  JRST	[	SKIPN	DOTFOO
			  MOVE	DOTFOO,DOT
			ADDI	DOTFOO,2
			MOVE	T1,DOTFOO
			PUSHJ	P,GETWRD
			  POPJ	P,
			ADD	T1,DOTFOO	;MAKE RELATIVE
			ADDI	T1,2
			JRST	ADRTYP ]
	LDB	T1,[POINT 3,T4,32]	;GET MODE
	CAIE	T1,4
	CAIN	T1,5
	  PUSHJ	P,MINTYP
	CAIL	T1,6		;CHECK FOR INDEX OR INDEX DEFERRED
	  JRST	[	SKIPN	DOTFOO
			  MOVE	DOTFOO,DOT
			ADDI	DOTFOO,2
			MOVE	T1,DOTFOO
			PUSHJ	P,GETWRD
			  POPJ	P,
			PUSHJ	P,ADRTYP
			JRST	.+2 ]
	TRNE	T1,6
	  PUSHJ P,[	MOVEI	T1,"("
			PJRST	TYPCHR ]
	LDB	T1,[POINT 3,T4,35]	;GET REGISTER VALUE
	PUSHJ	P,DATIN9	;TYPE REGISTER NAME
	TRNN	T4,60
	  POPJ	P,		;PLAIN REGISTER MODE
	MOVEI	T1,")"
	PUSHJ	P,TYPCHR
	LDB	T1,[POINT 3,T4,32]
	CAIE	T1,2
	CAIN	T1,3
	  PUSHJ	P,PLUTYP
	POPJ	P,
DATIN9:	PUSHJ	P,RGFNDN		;FIND REGISTERS NAME
	JRST	[ CAIN T1,6
	PJRST TYPSP
	CAIN	T1,7
	PJRST	TYPPC
	  		PUSHJ	P,PCNTYP	;TYPE A %
			PUSHJ	P,OCTYPE
			POPJ	P, ]
	MOVE	T1,(SYM)	;GET REGISTERS NAME
	JRST	SIXTYP

;HERE TO TYPE DATA AS ASCII TEXT
DATASC:	ANDI	T1,377
	MOVEM	T1,T3
	PUSHJ	P,DATAS3
	SOJLE	T5,DATYP8
	LDB	T1,[POINT 8,DATA,27]
	MOVEM	T1,T3		;SAVE IN CASE ILLEGAL
	PUSHJ	P,DATAS3
	SOJLE	T5,DATYP8
	JSR	NXTDWD		;GET NEXT DATA WORD
	JRST	DATASC
DATAS3:	ANDI	T1,177		;STRIP PARITY BIT
	CAIL	T1,40
	CAILE	T1,176
	CAIA			;SPECIAL HANDLING
	JRST	TYPCHR		;JUST TYPE CHARACTER
DATAS4:	PUSH	P,T3		;SAVE WEIRD CHARACTER
	MOVEI	T1,"<"
	PUSHJ	P,TYPCHR
	POP	P,T1		;GET CHAR
	PUSHJ	P,RADTYP
	MOVEI	T1,">"
	PJRST	TYPCHR
SUBTTL	TYPE DATA AS RAD50 TEXT
;
;	T1 HAS VALUE TO BE DECODED
;

DATR50:
	IDIVI	T1,50			;LETTER INTO T2
	PUSH	P,T2			;SAVE LETTER
	IDIVI	T1,50			;SECOND LETTER
	PUSH	P,T2
	MOVE	T2,T1
	PUSHJ	P,DATR5A		;TYPE 1ST LETTER
	POP	P,T2
	PUSHJ	P,DATR5A		;AND SECOND
	POP	P,T2
	PUSHJ	P,DATR5A		;AND THIRD
	POPJ	P,

DATR5A:
	PUSHJ	P,DATR5B		;CONVERT
	PUSHJ	P,TYPCHR
	POPJ	P,

DATR5B:
	MOVEI	T1,40			;ASSUME SPACE
	JUMPE	T2,[POPJ P,]		; YES, CORRECT IF ZERO
	MOVE	T1,T2			;ASSUME A-Z
	ADDI	T1,100			;IN ASCII
	CAIG	T2,32			;CHECK IF RIGHT
	POPJ	P,			; YES
	MOVEI	T1,"$"			;ASSUME DOLLAR
	CAIN	T2,33			;CHECK
	POPJ	P,			; YES, IS DOLLAR
	MOVEI	T1,"."
	CAIN	T2,34
	POPJ	P,			;YES, IS PERIOD
	MOVEI	T1,"#"			;UNDEFINED
	CAIN	T2,35			; ?
	POPJ	P,			; YES
	MOVE	T1,T2
	ADDI	T1,60-36		;MAKE INTO ASCII NUMBER
	POPJ	P,

SUBTTL	TYPE DATA AS EBCDIC TEXT

DATEBC:	PUSHJ	P,DATEB3
	SOJLE	T5,DATYP8
	LDB	T1,[POINT 8,DATA,27]
	PUSHJ	P,DATEB3
	SOJLE	T5,DATYP8
	JSR	NXTDWD		;GET NEXT DATA WORD
	JRST	DATEBC
DATEB3:	ANDI	T1,377
	MOVEM	T1,T3
	SETZ	T2,
	LSHC	T1,-2
	ROT	T2,2
	LDB	T1,[	POINT	8,EB.TRN(T1),7
			POINT	8,EB.TRN(T1),15
			POINT	8,EB.TRN(T1),23
			POINT	8,EB.TRN(T1),31 ](T2)
	PJRST	DATAS3

;HERE TO TYPE DATA AS BYTES
DATBYT:
	ANDI	T1,377
	PUSHJ	P,RADTYP
	SOJLE	T5,DATYP8
	MOVEI	T1,","
	PUSHJ	P,TYPCHR
	LDB	T1,[POINT 8,DATA,27]
	PUSHJ	P,RADTYP		;TYPE IN CURRENT RADIX
	SOJLE	T5,DATYP8
	MOVEI	T1,","
	PUSHJ	P,TYPCHR
	JSR	NXTDWD		;GET NEXT DATA WORD
	JRST	DATBYT
DATYP8:
	MOVEI	T1,"	"
	PJRST	TYPCHR

SUBTTL	TYPE T1 AS NUMBER

DECTYP:
	SKIPA	T3,[EXP ^D10]
OCTYPE:
	MOVEI	T3,^D8
	JRST	RADTY2
RADTYP:
	HRRZ	T3,ORADIX
	CAIE	T3,^D10
	  JRST	RADTY2
	PUSHJ	P,RADTY2
	MOVEI	T1,"."
	PJRST	TYPCHR
RADTY2:
RADTY5:
	IDIVI	T1,(T3)
	HRLM	T2,(P)
	SKIPE	T1
	PUSHJ	P,RADTY5
	HLRZ	T1,(P)
	IORI	T1,"0"
	CAILE	T1,"9"
	  ADDI	T1,7	;DOING HEX
	PJRST	TYPCHR

SIXTYP:
	MOVEM	T1,T2
SXTYP1:
	SETZ	T1,
	LSHC	T1,6
	ADDI	T1,40
	PUSHJ	P,TYPCHR
	JUMPN	T2,SXTYP1
	POPJ	P,

SUBTTL	TYPE VARIOUS CHARACTERS

SLTTYP:
	PUSH	P,T1
	MOVEI	T1,"/"
	PUSHJ	P,TYPCHR
	CAIA
TABTYP:
	PUSH	P,T1
	MOVEI	T1,"	"
TYPEIT:
	PUSHJ	P,TYPCHR
	POP	P,T1
	POPJ	P,

CRLTYP:
	PUSH	P,T1
	MOVEI	T1,15		;CARRIAGE RETURN
	PUSHJ	P,TYPCHR
	MOVEI	T1,12		;LINEFEED
	PJRST	TYPEIT

BLANKT:
	PUSH	P,T1
	MOVEI	T1," "
	PJRST	TYPEIT

COMTYP:
	PUSH	P,T1
	MOVEI	T1,","
	PJRST	TYPEIT

PCNTYP:
	PUSH	P,T1
	MOVEI	T1,"R"
	PJRST	TYPEIT

HSHTYP:
	PUSH	P,T1
	MOVEI	T1,"#"
	PJRST	TYPEIT

MINTYP:
	PUSH	P,T1
	MOVEI	T1,"-"
	PJRST	TYPEIT

PLUTYP:
	PUSH	P,T1
	MOVEI	T1,"+"
	PJRST	TYPEIT
;
TYPSP:
	PUSH	P,T1
	MOVEI	T1,"S"
	PUSHJ	P,TYPCHR
	MOVEI	T1,"P"
	PJRST	TYPEIT
;
TYPPC:
	PUSH	P,T1
	MOVEI	T1,"P"
	PUSHJ	P,TYPCHR
	MOVEI	T1,"C"
	PJRST	TYPEIT

	SUBTTL	MORE TYPEOUT ROUTINES

TYPCHR:
	PUSH	P,T1		;AT ENTRY, T1 HAS CHR TO TYPE
	PUSH	P,T2
	MOVE	T2,T1		;GET CHR
	SKIPE	LPTFLG		;DOING A DUMP ?
	  JRST	TYPCH3		;YES
	MOVX	T1,.PRIOU	;PRIMARY OUTPUT
	JRST	TYPCH4

TYPCH3:
	MOVE	T1,OUTJFN
TYPCH4:
	BOUT
	POP	P,T2
	POP	P,T1
	POPJ	P,

TSTRNG:				;T2 HAS PTR TO STRING
	PUSH	P,T1
	PUSH	P,T3
	MOVEI	T3,0		;STRING ASCIZ
	HRLI	T2,440700	;BYTE PTR
	MOVE	T1,OUTJFN	;IN CASE LPT OUTPUT
	SKIPN	LPTFLG		;ARE WE TO LPT?
	MOVX	T1,.PRIOU	; NO, PRIMARY OUTPUT
	SOUT			;OUTPUT STRING
	POP	P,T3
	POP	P,T1
	POPJ	P,

SUBTTL	LOCK CODE

LOCKER:	TYPE	[ASCIZ	\?LOCK UUO failed - code \]
	PUSHJ	P,OCTYPE
	HALTF		;RETURN TO MONITOR
	JRST	LEVEL0	;USER TYPED CONTINUE

NODERR:	TYPE	[ASCIZ	\?NODE UUO failed - code \]
	PUSHJ	P,OCTYPE
	HALTF		;RETURN TO MONITOR
	JRST	LEVEL0	;USER TYPED CONTINUE

SUBTTL	DUMP 11 TO FILE

DUMP:
	PUSHJ	P,OPNDMP	;OPEN OUTPUT FILE
	JRST	DUMP9		; ERROR?
	SETOM	LPTFLG		;SET TO LPT FLAG
	MOVE	DOT,SBEGIN	;WHERE TO BEGIN DUMP
	JRST	DUMP2
DUMP1:
	HRRZ	T1,DUMPA	;LAST ADDRESS WE TYPED
	ADDI	T1,20
	CAMLE	T1,DOT		;TIME TO TYPE ADR AGAIN ?
	  JRST	DUMP4
DUMP2:
	PUSHJ	P,CRLTYP
	PUSHJ	P,CRLTYP
	HRRZ	T1,DOT
	PUSHJ	P,ADRTYP
	PUSHJ	P,BLANKT
	MOVEI	T1,"="
	PUSHJ	P,TYPCHR
	PUSHJ	P,BLANKT
	HRRZ	T1,DOT
	PUSHJ	P,OCTYPE
	MOVEI	T1,":"
	PUSHJ	P,TYPCHR
	HRRZ	T1,DOT
	ANDI	T1,177760	;IN CASE WAS HIGH
	MOVEM	T1,DUMPA	;REMEMBER LAST ADR WE TYPED
	CAIA			;SO WE DO AN EXTRA TAB
DUMP4:
	TRNN	DOT,7
	  PUSHJ	P,TABTYP

DUMP7:
	MOVE	T1,DOT		;GET ADDRESS TO EXAMINE
	PUSHJ	P,GETWRD
	  JRST	DUMP8		;ALL DONE
	MOVEM	T1,DATA
	PUSHJ	P,DATYPE	;DUMP LOCATION
	SKIPE	DOTFOO
	  MOVE	DOT,DOTFOO
	ADDI	DOT,2		;ADVANCE TO NEXT WORD
	CAMG	DOT,S..END
	  JRST	DUMP1

SUBTTL	MORE DUMP TO FILE

DUMP8:
	PUSHJ	P,CRLTYP
	PUSHJ	P,CRLTYP
	MOVE	T1,OUTJFN
	CLOSF			;CLOSE THE OUTPUT FILE
	JFCL			;DON'T  CARE IF FAILED
	SETZM	LPTFLG		;NOT A DUMP ANYMORE
	PUSHJ	P,CRLTYP
	PUSHJ	P,CRLTYP
	JRST	LEVEL0
DUMP9:
	TYPE	[ASCIZ	\error writing dump\]
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	JRST	LEVEL0

OPNDMP:
	TYPE	[ASCIZ /
OUTPUT TO FILE:	/]
	MOVX	T1,<GJ%FOU!GJ%MSG!GJ%CFM!GJ%FNS!GJ%SHT>
	MOVE	T2,[.PRIIN,,.PRIOU]
	GTJFN			;GET JFN
	JRST	[PUSHJ	P,WARN
		 POPJ	P,]
	HRRZM	T1,OUTJFN	;LPT JFN
	MOVE	T2,[7B5+OF%WR]
	OPENF			;TRY TO OPEN IT
	JRST	[PUSHJ	P,WARN
		 POPJ	P,]
	SETOM	LPTFLG		;OUTPUT TO LPT FLAG
	AOS	(P)
	POPJ	P,

SUBTTL	COMPARE FILE WITH WHAT'S IN CORE

;
;	COMMAND FORM IS:
;	[FROM]<[TO]>$X
;	PROGRAM REQUESTS FILE WITH WHICH TO COMPARE,
;	AND THEN REQUESTS OUTPUT FILE
;
;	WE THEN READ THE INPUT FILE INTO SOME BUFFER,
;	AND COMPARE IT WITH THE PDP-11 BUFFER, AND
;	OUTPUT THE DIFFERENCES TO THE OUTPUT FILE.
;
RDCMPR:				;READ AND COMPARE
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	SKIPN	MEMORY		;MEMORY?
	JRST	[TYPE [ASCIZ \?FEDDT - NO PDP-11 MEMORY\]
		 PUSHJ	P,CRLTYP
		 JRST	LEVEL0]
	PROMPT	[ASCIZ \COMPARE WITH FILE:	\]
	PUSHJ	P,OPNFIL	;OPEN INPUT FILE
	JRST	LEVEL0		;FAILED
	PUSH	P,MEMORY	;SAVE MEMORY LOC
	PUSH	P,MEMLIM	;.END OF MEM TOO
	PUSH	P,S..END	;..ALSO SEARCH END
	MOVEI	T5,CMPBLK	;...COMPARE BLOCK
	PUSHJ	P,RDDMP		;...READ DUMP
	JFCL			;...FAILED?
	POP	P,S..END	;...RESTORE OLD CORE
	POP	P,MEMLIM	;..
	POP	P,MEMORY	;.
RDCMP0:
	PUSHJ	P,OPNDMP	;OPEN OUTPUT FILE
	JRST	LEVEL0		;FAILED
	SETOM	LPTFLG		;SET TO LPT FLAG
	SKIPN	MEMORY		;IN CASE FROM $X
	JRST	ILLCHR		;SO DING IF NO MEMORY
	MOVE	DOT,SBEGIN	;START ADDR
	MOVE	T3,DOT		;SET UP SOURCE 2
	LSH	T3,-2		;INTO COMPARE BLOCK
	ADD	T3,[442200,,CMPBLK]
RDCMP1:
	MOVE	T1,DOT		;GET FROM CORE
	PUSHJ	P,GETWRD	;GET WORD FROM 11
	JRST	RDCMP9		;FAILED?
	MOVEM	T1,DATA		;SAVE AS DATA
	ILDB	T4,T3		;COMPARE FILE
	CAME	T4,DATA		;SAME AS FILE?
	JRST	RDCMP3		; NO, WORRY
RDCMP2:
	ADDI	DOT,2		; YES, ALL OK
	CAMG	DOT,S..END	;CHECK
	JRST	RDCMP1		;NOT DONE YET
RDCMP9:				;
	MOVE	T1,OUTJFN	;OUTPUT JFN
	SETZM	LPTFLG		;CLEAR TO LPT FLAG
	CLOSF			;CLOSE OUTPUT FILE
	PUSHJ	P,WARN		;TELL USER WE LOST
	PUSHJ	P,CRLTYP
	JRST	LEVEL0		;AND RETURN

RDCMP3:				;HERE WHEN CORE NOT EQUAL TO FILE
	PUSH	P,T3		;SAVE BYTE PTR
	MOVE	T1,DOT		;GET ADDRESS
	PUSHJ	P,ADRTYP	;TYPE ADDRESS
	PUSHJ	P,SLTTYP	;TYPE SLASH TAB
	PUSHJ	P,DATYPE	;TYPE DATA TO USER
	PUSHJ	P,TABTYP	;TAB OVER
	MOVEM	T4,DATA		;STORE FILE VERSION
	PUSHJ	P,DATYPE
	PUSHJ	P,CRLTYP	;RETURN CARRIAGE
	POP	P,T3		;RESTORE BYTE PTR
	JRST	RDCMP2		;AND GO ON


SUBTTL	READ BINARY CORE DUMP FILE

RDDUMP:
	PROMPT	[ASCIZ /
INPUT FILE:	/]
	PUSHJ	P,OPNFIL
	JRST	LEVEL0		;FAILED, SO GO AWAY
	MOVEI	T5,MEMBLK	;GET FIRST FREE LOCATION
	PUSHJ	P,RDDMP		;READ BINARY FILE
	JRST	LEVEL0		;FAILED?
	MOVEI	T1,LEVELR	;NOW CHANGE STARTUP ADDRESS
	MOVEM	T1,.JBSA	;SO WE DON'T AUTO-CLOBBER
	JRST	LEVEL0		;WON!

SUBTTL	MORE READ BINARY DUMP

RDDMP:
	MOVEM	T5,MEMORY	;SAVE ADDRESS OF SIMULATED MEMORY
	SETZM	MEMLIM		;FIRST NONEXISTENT ADDRESS IN DUMP MEMORY
RDUMP0:
	MOVE	T5,MEMORY	;GET ADDR OF MEMORY
RDUMP1:
	MOVE	T1,INJFN	;GET INPUT JFN
	SIZEF			;GET SIZE OF FILE IN WORDS
	JRST	WARN		;LOST
	MOVNS	T3,T2		;I/O WORD FORMAT
	MOVE	T1,INJFN	;INPUT JFN
	MOVEI	T2,MEMPTR	;COMMAND LIST FOR DUMPI
	HRRM	T5,MEMPTR	;POINT TO MEMORY
	HRLM	T3,MEMPTR	;NEG SIZE TO READ
	SOS	MEMPTR		;IOWRD PTR
	DUMPI			;DUMP MODE INPUT
	PJRST	WARN		;COMPLAIN TO LOSER
	HLRE	T3,MEMPTR	;GET MEMORY SIZE
	MOVN	T3,T3		;NEGATE I/O PTR
	ADD	T3,MEMORY	;ADD MEMORY PTR
	MOVE	T5,T3
RDUMP9:				;END OF DUMP
	MOVE	T1,INJFN	;GET JFN OF INPUT FILE
	CLOSF			;CLOSE FILE
	PJRST	WARN		;FAILED, COMPLAIN
	ADDI	T5,3		;MULTIPLE OF 4
	TRZ	T5,3		;MULTIPLE OF 4
	HRRM	T5,S..END	;END FOR SEARCHES
	HRRM	T5,MEMLIM	;UPPER LIMIT
	TYPE	[ASCIZ \CORE SIZE IS \]
	MOVE	T1,MEMLIM
	SUB	T1,MEMORY	;PDP-11 ADDRESS, PLEASE
	LSH	T1,-11		;REDUCED TO K
	PUSHJ	P,DECTYP	;IN DECIMAL
	TYPE	[ASCIZ \K\]
	PUSHJ	P,CRLTYP
	AOS	(P)		;SKIP RETURN
	POPJ	P,

SUBTTL	EBCDIC TO ASCII

;TRANSLATION TABLE FROM EBCDIC TO ASCII

EB.TRN:	BYTE	(8)000,001,002,003,000,011,000,177		;000-007
	BYTE	(8)000,000,000,013,014,015,000,000		;010-017
	BYTE	(8)000,021,022,000,000,000,000,000		;020-027
	BYTE	(8)000,000,000,000,000,000,000,000		;030-037
	BYTE	(8)000,000,000,000,000,000,000,000		;040-047
	BYTE	(8)000,000,000,000,000,000,000,000		;050-057
	BYTE	(8)000,000,000,000,000,000,000,000		;060-067
	BYTE	(8)000,000,000,000,000,000,000,000		;070-077
	BYTE	(8)040,000,000,000,000,000,000,000		;100-107
	BYTE	(8)000,000,000,056,074,050,053,136		;110-117
	BYTE	(8)046,000,000,000,000,000,000,000		;120-127
	BYTE	(8)000,000,041,044,052,051,073,155		;130-137
	BYTE	(8)055,057,000,000,000,000,000,000		;140-147
	BYTE	(8)000,000,174,054,045,137,076,077		;150-157
	BYTE	(8)000,000,000,000,000,000,000,000		;160-167
	BYTE	(8)000,140,072,043,100,047,075,042		;170-177
	BYTE	(8)075,141,142,143,144,145,146,147		;200-207
	BYTE	(8)150,151,000,000,000,000,000,000		;210-217
	BYTE	(8)000,152,153,154,155,156,157,160		;220-227
	BYTE	(8)161,162,000,000,000,000,000,000		;230-237
	BYTE	(8)100,176,163,164,165,166,167,170		;240-247
	BYTE	(8)171,172,134,116,153,133,113,141		;250-257
	BYTE	(8)060,061,062,063,064,065,066,067		;260-267
	BYTE	(8)070,071,172,136,114,135,156,157		;270-277
	BYTE	(8)173,101,102,103,104,105,106,107		;300-307
	BYTE	(8)110,111,000,000,000,000,000,000		;310-317
	BYTE	(8)175,112,113,114,115,116,117,120		;320-327
	BYTE	(8)121,122,000,000,000,000,000,000		;330-337
	BYTE	(8)134,000,123,124,125,126,127,130		;340-347
	BYTE	(8)131,132,000,000,000,000,000,000		;350-357
	BYTE	(8)060,061,062,063,064,065,066,067		;360-367
	BYTE	(8)070,071,174,000,000,000,000,000		;370-377
REPEAT 0,<
	EXP LOOP,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;00-07
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;10-17
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;20-27
	EXP ILLCHR,ILLCHR,COMCZ ,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;30-37
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;40-47
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;50-57
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;60-67
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;70-77
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;100-107
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;110-117
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;120-127
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;130-137
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;140-147
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;150-157
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;160-167
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB	;170-177
>

SUBTTL	STATE TABLES

STATE0:	EXP LOOP  ,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;00-07
	EXP COMARR,COMHT ,COMLF ,ILLCHR,ILLCHR,LEVEL0,ILLCHR,ILLCHR	;10-17
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;20-27
	EXP EXPXOR,ILLCHR,COMCZ ,ESCAPE,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;30-37
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ASSYMB,ILLCHR,ILLCHR,ILLCHR	;40-47
	EXP ILLCHR,ILLCHR,ILLCHR,EXPLUS,ILLCHR,EXPMIN,ASSYMB,ILLCHR	;50-57
	EXP ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM	;60-67
	EXP ASSNUM,ASSNUM,ILLCHR,ILLCHR,ILLCHR,EQUALS,ILLCHR,ILLCHR	;70-77
	EXP ILLCHR,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;100-107
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;110-117
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;120-127
	EXP ASSYMB,ASSYMB,ASSYMB,ILLCHR,COMBSL,ILLCHR,COMARR,ILLCHR	;130-137
	EXP ILLCHR,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;140-147
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;150-157
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;160-167
	EXP ASSYMB,ASSYMB,ASSYMB,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB	;170-177
;STATE TABLE WHEN BUILDING AN EXPRESSION

STATEE:	EXP LOOP  ,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;00-07
	EXP ILLCHR,ILLCHR,STELF ,ILLCHR,ILLCHR,STECR ,ILLCHR,ILLCHR	;10-17
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;20-27
	EXP EXPXOR,ILLCHR,COMCZ ,ESCEXP,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;30-37
	EXP EXPLUS,EXPIOR,ILLCHR,ILLCHR,ASSYMB,ILLCHR,EXPAND,EXPDIV	;40-47
	EXP ILLCHR,ILLCHR,EXPMUL,EXPLUS,ILLCHR,EXPMIN,ASSYMB,OPNLOC	;50-57
	EXP ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM	;60-67
	EXP ASSNUM,ASSNUM,DEFSYM,ILLCHR,SLOWLM,EXPEQU,SUPLIM,ILLCHR	;70-77
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;100-107
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;110-117
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;120-127
	EXP ASSYMB,ASSYMB,ASSYMB,ILLCHR,COMBSE,ILLCHR,STEARR,BKARRW	;130-137
	EXP ILLCHR,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;140-147
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;150-157
	EXP ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB	;160-167
	EXP ASSYMB,ASSYMB,ASSYMB,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB	;170-177
;STATE TABLE WHEN USER TYPES ALTMODE

STATSC:	EXP LOOP,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;00-07
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;10-17
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;20-27
	EXP ILLCHR,ILLCHR,COMCZ ,ESCESC,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;30-37
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;40-47
	EXP ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;50-57
	EXP ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0	;60-67
	EXP ESC..0,ESC..0,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;70-77
	EXP ILLCHR,ESC..A,ESC..B,ESC..C,ESC..D,ESC..E,ILLCHR,ILLCHR	;100-107
	EXP ILLCHR,ESC..I,ILLCHR,ESC..K,ILLCHR,ESC..M,ESC..N,ESC..O	;110-117
	EXP ESC..P,ILLCHR,ESC..R,ESC..S,ESC..T,ILLCHR,ESC..V,ESC..W	;120-127
	EXP ESC..X,ESC..Y,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR	;130-137
	EXP ILLCHR,ESC..A,ESC..B,ESC..C,ESC..D,ESC..E,ILLCHR,ILLCHR	;140-147
	EXP ILLCHR,ESC..I,ILLCHR,ILLCHR,ILLCHR,ESC..M,ESC..N,ILLCHR	;150-157
	EXP ILLCHR,ILLCHR,ESC..R,ESC..S,ESC..T,ILLCHR,ESC..V,ESC..W	;160-167
	EXP ILLCHR,RDSYMB,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB	;170-177
SWLIST:	SIXBIT	\FILE\
	SIXBIT	\NODE\
	SIXBIT	\PATCH\
	SIXBIT	\PORT\
	Z

	LIT
	VAR
DEFINE	X	(VAL,BIT,NAME,FLAG) <
	EXP	.+1
	SIXBIT	\NAME\
	BYTE	(5)BIT(13)FLAG(18)VAL
>;END OF DEFINE X
SYMBEG:	X	000000,^D16,HALT,<SMF.IN>
	X	000001,^D16,WAIT,<SMF.IN>
	X	000002,^D16,RTI,<SMF.IN>
	X	000003,^D16,BPT,<SMF.IN>
	X	000004,^D16,IOT,<SMF.IN>
	X	000005,^D16,RESET,<SMF.IN>
	X	000006,^D16,RTT,<SMF.IN>
	X	000100,^D10,JMP,<SMF.IN!SMF.DD>
	X	000200,^D13,RTS,<SMF.IN!SMF.RT>
	X	000230,^D13,SPL,<SMF.IN!SMF.PL>
	X	000240,^D16,NOP,<SMF.IN>
	X	000241,^D16,CLC,<SMF.IN>
	X	000242,^D16,CLV,<SMF.IN>
	X	000244,^D16,CLZ,<SMF.IN>
	X	000250,^D16,CLN,<SMF.IN>
	X	000257,^D16,CCC,<SMF.IN>
	X	000261,^D16,SEC,<SMF.IN>
	X	000262,^D16,SEV,<SMF.IN>
	X	000264,^D16,SEZ,<SMF.IN>
	X	000270,^D16,SEN,<SMF.IN>
	X	000277,^D16,SCC,<SMF.IN>
	X	000300,^D10,SWAB,<SMF.IN!SMF.DD>
	X	000400,^D8,BR,<SMF.IN!SMF.XX>
	X	001000,^D8,BNE,<SMF.IN!SMF.XX>
	X	001400,^D8,BEQ,<SMF.IN!SMF.XX>
	X	002000,^D8,BGE,<SMF.IN!SMF.XX>
	X	002400,^D8,BLT,<SMF.IN!SMF.XX>
	X	003000,^D8,BGT,<SMF.IN!SMF.XX>
	X	003400,^D8,BLE,<SMF.IN!SMF.XX>
	X	004000,^D7,JSR,<SMF.IN!SMF.DD!SMF.JS>
	X	005000,^D10,CLR,<SMF.IN!SMF.DD>
	X	005100,^D10,COM,<SMF.IN!SMF.DD>
	X	005200,^D10,INC,<SMF.IN!SMF.DD>
	X	005300,^D10,DEC,<SMF.IN!SMF.DD>
	X	005400,^D10,NEG,<SMF.IN!SMF.DD>
	X	005500,^D10,ADC,<SMF.IN!SMF.DD>
	X	005600,^D10,SBC,<SMF.IN!SMF.DD>
	X	005700,^D10,TST,<SMF.IN!SMF.DD>
	X	006000,^D10,ROR,<SMF.IN!SMF.DD>
	X	006100,^D10,ROL,<SMF.IN!SMF.DD>
	X	006200,^D10,ASR,<SMF.IN!SMF.DD>
	X	006300,^D10,ASL,<SMF.IN!SMF.DD>
	X	006700,^D10,SXT,<SMF.IN!SMF.DD>
	X	010000,^D4,MOV,<SMF.IN!SMF.SS>
	X	020000,^D4,CMP,<SMF.IN!SMF.SS>
	X	030000,^D4,BIT,<SMF.IN!SMF.SS>
	X	040000,^D4,BIC,<SMF.IN!SMF.SS>
	X	050000,^D4,BIS,<SMF.IN!SMF.SS>
	X	060000,^D4,ADD,<SMF.IN!SMF.SS>
	X	070000,^D7,MUL,<SMF.IN!SMF.JS!SMF.DD>
	X	071000,^D7,DIV,<SMF.IN!SMF.JS!SMF.DD>
	X	072000,^D7,ASH,<SMF.IN!SMF.JS>
	X	073000,^D7,ASHC,<SMF.IN!SMF.JS>
	X	074000,^D7,XOR,<SMF.IN!SMF.JS!SMF.DD>
	X	075000,^D13,FADD,<SMF.IN!SMF.RT>
	X	075010,^D13,FSUB,<SMF.IN!SMF.RT>
	X	075020,^D13,FMUL,<SMF.IN!SMF.RT>
	X	075030,^D13,FDIV,<SMF.IN!SMF.RT>
	X	077000,^D7,SOB,<SMF.IN!SMF.SB>
	X	100000,^D8,BPL,<SMF.IN!SMF.XX>
	X	100400,^D8,BMI,<SMF.IN!SMF.XX>
	X	101000,^D8,BHI,<SMF.IN!SMF.XX>
	X	101400,^D8,BLOS,<SMF.IN!SMF.XX>
	X	102000,^D8,BVC,<SMF.IN!SMF.XX>
	X	102400,^D8,BVS,<SMF.IN!SMF.XX>
	X	103000,^D8,BCC,<SMF.IN!SMF.XX>
	X	103000,^D8,BHIS,<SMF.IN!SMF.XX>
	X	103400,^D8,BCS,<SMF.IN!SMF.XX>
	X	103400,^D8,BLO,<SMF.IN!SMF.XX>
	X	104000,^D8,EMT,<SMF.IN!SMF.EM>
	X	104400,^D8,TRAP,<SMF.IN!SMF.EM>
	X	105000,^D10,CLRB,<SMF.IN!SMF.DD>
	X	105100,^D10,COMB,<SMF.IN!SMF.DD>
	X	105200,^D10,INCB,<SMF.IN!SMF.DD>
	X	105300,^D10,DECB,<SMF.IN!SMF.DD>
	X	105400,^D10,NEGB,<SMF.IN!SMF.DD>
	X	105500,^D10,ADCB,<SMF.IN!SMF.DD>
	X	105600,^D10,SBCB,<SMF.IN!SMF.DD>
	X	105700,^D10,TSTB,<SMF.IN!SMF.DD>
	X	106000,^D10,RORB,<SMF.IN!SMF.DD>
	X	106100,^D10,ROLB,<SMF.IN!SMF.DD>
	X	106200,^D10,ASRB,<SMF.IN!SMF.DD>
	X	106300,^D10,ASLB,<SMF.IN!SMF.DD>
	X	110000,^D4,MOVB,<SMF.IN!SMF.SS>
	X	120000,^D4,CMPB,<SMF.IN!SMF.SS>
	X	130000,^D4,BITB,<SMF.IN!SMF.SS>
	X	140000,^D4,BICB,<SMF.IN!SMF.SS>
	X	150000,^D4,BISB,<SMF.IN!SMF.SS>
	X	160000,^D4,SUB,<SMF.IN!SMF.SS>
	EXP	Z
SYMEND:	EXP	.-3

IMPURE:
FEFLG:	0		;FLAG FOR REMOTE DTE EXAM/DEP
FEDEV:	ASCIZ /FE0:/
NODARG:	BLOCK	5
STCMSG:	BLOCK	20
STCIMS:	BLOCK	20
PKT:	BYTE	(16)0(8)"E","M"
	Z	0
	Z	0
PKT1:	BLOCK	5
MAPCHR:	200			;FAKE TAB CHR FOR MAP READINGS
SUPSYM:	0		;IF NON-ZERO, SUPPRESS ALL SYMBOLS
RELVAL:	0
OPNJFN:
	GJ%OLD!GJ%CFM!GJ%XTN		;0 - FLAGS
	.PRIIN,,.PRIOU			;1 - JFN
	0				;2 - DSK:
	0				;3 - DEFAULT DIRECTORY
	440700,,[ASCIZ \0DUMP11\]	;4 - DEFAULT FILE NAME
	440700,,[ASCIZ \BIN\]		;5 - DEFAULT EXTENSION
	0				;6 - PROTECTION
	0				;7 - ACCOUNT
	0				;10 - JFN OF NAME
	3				;11 - MORE TO COME
	440700,,OPNSTR			;12 - NOT USED, REALLY
	130				;13 - # BYTES IN ABOVE
	440700,,OPNPMT			;14 - PROMPT MESSAGE
OPNSTR:
	BLOCK	20
OPNPMT:
	BLOCK	20			;PROMPT GOES HERE
OPNMOV:
	MOVSLJ
	0
INJFN:	0
OUTJFN:	0
LPTFLG:	0		;OUTPUT TO LPT FLAG
DUMPA:	BLOCK	1		;LAST ADDRESS TYPED OUT

MEMORY:	EXP	Z		;ADDRESS OF DUMP MEMORY
MEMPTR:
	-EVSIZ,,0	;I/O PTR FOR DUMPI
	0		;END OF INPUT
MEMLIM:	EXP	Z		;HIGHEST LOCATION IN DUMP

DATA:	BLOCK	^D20
SBEGIN:	EXP	0	;FIRST ADDRESS FOR SEARCH
S..END:	EXP	0	;LAST ADDRESS FOR SEACRH
S.WORD:	EXP	0	;WORD TO SEARCH FOR
S.MASK:	EXP	177777		;MASP FOR WORD SEARCH
INPOPR:	EXP	0	;INPUT OPERATION (0=+,1=-,2=*,3=',4=!,5=&,6=^X)
BYTCNT:	XWD	1,1	;REPEITION COUNTS FOR OUPUT BYTES ETC.
O.MODE:	EXP	0	;OUTPUT MODE LH = PERMANENT, RH = CURRENT
			; (0=SYMBOLIC, 1=ADDRESS, 2=NUMERIC, 3=BYTES,
			;  4=ASCII TEXT, 5=EBCDIC TEXT)
ORADIX:	^D8,,^D8	;OUTPUT RADIX
			; LH IS PERMANENT SETTING, RH IS CURRENT
LSTADR:	Z		;LAST ADDRESS DISPLAYED
;THE CACHE IS SO WORK OVER SYNCHRONOUS LINE WILL BE FASTER
CACHEL:	0		;HIGHEST ADDRESS IN CACHE
CACHEA:	0		;ADDRESS REPRESENTED BY FIRST ADR IN CACHE
CACHE:	BLOCK	200
IFNDEF PDLEN <PDLEN=40>
PDL:	BLOCK	PDLEN
;	[END OF IMPURE SECTION]

TOPCOR:
	200000		;GOOD PLACE FOR USER SYMBOLS

LOC	100000		;PLACE FOR PDP-11 CORE
MEMBLK:
	BLOCK	35000		;28K PDP-11 MEMORY
LOC	300000		;PLACE FOR COMPARE BUFFER
CMPBLK:
	BLOCK	35000		;28K PDP-11 MEMORY


LOC	200000			;...
USRSYM:
	BLOCK	100000		;MAY AS WELL GET LOTS OF CORE

DDTEND:	END	DDT11
   