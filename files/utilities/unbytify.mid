;;June 1983, GZ@MIT-MC (MDC.GZ@MIT-OZ)		-*- Midas -*-
;;
;; @UNBYTIFY inputfile [outputfile]
;; Converts the input file so as to undo the effect of BYTIFY.
;; Both files can have wildcards. Wildcards in output filename mean use the
;; corresponding component of the original pre-BYTIFY filename (except for
;; the directory, where wildcards mean to use the input file's directory)
;; I.e. *.* (the default) means use the original filename and put it in
;; connected directory, while  <*>*.* would mean to use original filename
;; and put in the input file's directory. FOO.BAR.* would mean output as
;; FOO.BAR (in connected dir) with the original file's version number.
;; Switches: /LIST (default) /NOLIST - whether to list filename being processed

	title Undo a @BYTIFY, GZ@MIT-MC

.decsav

A=6
B=7
C=10
D=11
J=12
O=13
F=16
P=17

call=<pushj p,>
return=<popj p,>

define type &string
	hrroi 1,[asciz string]
	PSOUT
termin
define ltype *string
	hrroi 1,[asciz
string]
	PSOUT
termin

;;Right half of F
f%ijfn==000001			;Have input jfn
f%ojfn==000002			;Have output jfn
f%bsz== 000004			;Error in saved byte size
f%nlst==000010			;Don't list files
;;Left half of F
f%jcl==000001

pdlen==30
	.vector pdl(pdlen)

	.scalar injfn
	.scalar outjfn

strbsz==100
.vector strbuf(strbsz),atmbuf(strbsz),fname(strbsz)

cmdblk:	0,,cmdin1
	.priin,,0
	440700,,[asciz/BYTIFIED file: /]
	440700,,strbuf
	440700,,0
	0
	0
	440700,,atmbuf
	strbsz*5
	0

ingtb:	gj%old\gj%ifg
	0
	0			;.GJDEV
	0			;.GJDIR
	0			;.GJNAM
	440700,,[asciz/COM/]	;.GJEXT
	block .gjatr-.gjext

outgtb:	gj%fou\gj%ofg
	0
	0			;.GJDEV
	0			;.GJDIR
	440700,,[asciz/*/]	;.GJNAM
	440700,,[asciz/*/]	;.GJEXT
	block .gjatr-.gjext

define fdb fn,flags=0,next=0
	<fn_33>\<flags>+next
termin

infdb:	fdb .cmfil,,swifdb
	0 ? 0 ? 0 ? 0
outfdb:	fdb .cmfil,cm%hpp\cm%sdh,swifdb
	0 ? 440700,,[asciz/output filespec or carriage return for *.*/] ? 0 ? 0
cfmfdb:	fdb .cmcfm,,swifdb
	0 ? 0 ? 0 ? 0

swifdb:	fdb .cmswi,cm%hpp
	switab ? 440700,,[asciz/a switch,/] ? 0 ? 0

switab:	swicnt,,swicnt
	[asciz/LIST/],,[trz f,f%nlst]
	[cm%fw\cm%nor\cm%inv ? asciz/NO/],,0
	[asciz/NOLIST/],,[tro f,f%nlst]
swicnt==.-switab-1

docmd:	movei 1,cmdblk
	COMND
	tlne 1,(cm%nop)
	  jrst cmderr
	movei 4,(3)
	caie 4,swifdb
	  return
	hrrz 2,(2)
	xct (2)
	hlrz 2,3
	jrst docmd

cmderr:	push p,2
	ltype "?"
	pop p,2
	movei 1,.priou
	hrli 2,.fhslf
	setz 3,
	ERSTR
	  nop
	  nop
	jrst cmdini

begin:	reset
	move p,[-pdlen,,pdl-1]
	setz F,
	movei 1,.rsini
	rscan
	  jrst cmd
	movei 1,.rscnt
	rscan
	  jrst cmd
	skipg A,1
	  jrst cmd
jskip:	PBIN
	caie 1,^I
	 cain 1,40
	  tloa f,f%jcl
	sojg A,jskip

cmd:	movei 1,strbuf
	hrrm 1,cmdblk+.CMPTR
	movei 1,strbsz*5
	movem 1,cmdblk+.CMCNT
	setzm cmdblk+.CMINC
	trz f,777777
cmdini:	movei 1,.priou
	tlze F,f%jcl
	  movei 1,.nulio	;Don't prompt if reading RSCAN buffer
	hrrm 1,cmdblk+.CMIOJ
	movei 1,cmdblk
	movei 2,[.cmini_9,,0 ? 0 ? 0 ? 0 ? 0]
	COMND
cmdin1:	move p,[-pdlen,,pdl-1]
	move 1,injfn
	trne f,f%ijfn
	  RLJFN
	    nop
	move 1,outjfn
	trne f,f%ojfn
	  RLJFN
	    nop
	movei 1,ingtb
	movem 1,cmdblk+.CMGJB
	trz f,777777
cmd1:	movei 2,infdb
	call docmd
	movem 2,injfn
	tro f,f%ijfn
	movei 1,outgtb
	movem 1,cmdblk+.CMGJB
cmd2:	movei 2,outfdb
	call docmd
	movem 2,outjfn
	tro f,f%ojfn
cmd3:	movei 2,cfmfdb
	call docmd

unbyt:
;;Map input file
gfile:	trne f,f%nlst
	  jrst gfile1
	movei 1,.priou
	hrrz 2,injfn
	setz 3,
	JFNS
gfile1:	hrrz 1,injfn
	move 2,[2,,.fbbyv]
	movei 3,A		;Byte size in A, byte count into B
	GTFDB
	ldb A,[.BP fb%bsz,A]
	movei 1,44
	idiv 1,A
	movei 2,-1(1)
	add 2,B
	idiv 2,1
	move C,2		;Word count
	jumpe C,eoferr
	hrrz 1,injfn
	movei 2,of%rd
	OPENF
	  erjmp Lose
	movei 3,777(C)
	lsh 3,-9
	hrli 3,(pm%cnt\pm%cpy)
	move 2,[.fhslf,,inpag]
	hrlz 1,injfn
	PMAP
	  erjmp Lose
	movei 1,inbuf		;Make pages private so can close file
	move 2,C
mapf1:	moves (1)
	addi 1,1000
	subi 2,1000
	jumpg 2,mapf1
	move 1,injfn
	hrli 1,(co%nrj)
	CLOSF
	  erjmp Lose
	move B,[441000,,inbuf]	;B=input address
	move 1,(B)
	came 1,[sixbit/DSK8/]	;Flush COM header if any
	  jrst .+3
	    sojle C,eoferr
	    aoj B,
	move 1,(B)
	trz 1,77
	came 1,[sixbit/BYTIF/]
	  jrst [ltype "?Not a BYTIFIED file."
		jrst Die]
	sojle C,eoferr
	aoj B,
	move A,(B)		;A=byte count (32 bits)
	lsh A,-4
	sojle C,eoferr
	aoj B,
	imuli C,4		;Switch to byte input
	ildb D,B		;D=byte size
	caig D,44
	  caig D,0
	    jrst [ltype "%Bad byte size recorded in file, ignoring (May get junk at EOF)"
		  movei D,44
		  tro f,f%bsz
		  jrst .+1]
	soj C,
	move 2,[440700,,atmbuf]
gname:	sojl C,eoferr
	ildb 1,B
	idpb 1,2
	jumpn 1,gname
	trzn f,f%bsz
	  jrst gname1
	move 1,C		;No byte size, so can't tell how large the
	imuli 1,2		;file was -- use everything we've got
	idivi 1,9		;(Don't round up, BYTIFY outputs full words)
	move A,1
gname1: movei 1,44		;Adjust C to actual byte size
	idiv 1,D
	move 2,A		;2=# D-sized bytes
	addi 2,-1(1)
	idiv 2,1		;2=# full words needed to hold it
	imuli 2,44		;Number of 8-bit bytes needed to hold all the
	addi 2,7(3)		;words (since BYTIFY outputs full words)
	lsh 2,-3
	camle 2,C
	  jrst eoferr
	move C,2

	trne f,f%nlst
	  jrst ofile
	type " ("
	hrroi 1,atmbuf
	PSOUT
	movei 1,")
	PBOUT
ofile:	move 2,outjfn		;Build the output filename
	tlnn 2,(gj%nam\gj%ext\gj%ver)
	  jrst ofile1		;Not using original name at all
	movsi 1,(gj%fou\gj%ofg\gj%sht)
	hrroi 2,atmbuf
	GTJFN
	  erjmp Lose
	movei J,(1)
ofile1:	hrroi 1,fname
	move 2,outjfn ? tlne 2,(gj%dev) ? move 2,injfn ? movei 2,(2)
	move 3,[100000,,js%paf]
	JFNS
	move 2,outjfn ? tlne 2,(gj%dir) ? move 2,injfn ? movei 2,(2)
	move 3,[010000,,js%paf]
	JFNS
	move 2,outjfn ? tlne 2,(gj%nam) ? move 2,J ? movei 2,(2)
	move 3,[001000,,js%paf]
	JFNS
	move 2,outjfn ? tlne 2,(gj%ext) ? move 2,J ? movei 2,(2)
	move 3,[000100,,js%paf]
	JFNS
	move 2,outjfn ? tlne 2,(gj%ver) ? move 2,J ? movei 2,(2)
	move 3,[000010,,js%paf]
	JFNS
	move 2,outjfn
	move 1,J
	tlne 2,(gj%nam\gj%ext\gj%ver)
	  RLJFN
	    nop
;	movsi 1,(gj%new\gj%fou\gj%sht)
	hrloi 1,(gj%new\gj%fou\gj%sht)
	hrroi 2,fname
	GTJFN
	  erjmp Lose
	movei J,(1)		;<
	hrroi 1,[asciz/ --> /]
	trnn f,f%nlst
	  PSOUT
putf:	move O,[440400,,inbuf]	;Overwrite input file, what the hell
pdata:	sojl C,pdata1
	ildb 1,B
	lsh 1,-4
	idpb 1,O
	ldb 1,B
	idpb 1,O
	jrst pdata
pdata1:	trne f,f%nlst
	  jrst makef
	movei 1,.priou
	move 2,J
	setz 3,
	JFNS
makef:	move 1,J		;Make the output file
	movei 2,of%rd\of%wr
	OPENF
	  erjmp Lose
	jumpe A,oclose
	movei 1,44
	idiv 1,D
	move 2,A
	idiv 2,1
	jumpe 3,pdata2
	imul 3,D		;Pad last word with 0's for programs which dont
	movni 3,-1(3)		;pay attn to byte count
	movsi 1,400000
	ash 1,(3)
	andm 1,inbuf(2)
	aoj 2,
pdata2:	movei 3,777(2)
	lsh 3,-9
	hrli 3,(pm%cnt\pm%wr)
	hrlz 2,J
	move 1,[.FHSLF,,inpag]
	PMAP
	  erjmp Lose
oclose:	move 1,J
	hrli 1,(co%nrj\cz%nud)
	CLOSF
	  erjmp Lose
	dpb D,[.bp fb%bsz,3]
	movsi 2,(fb%bsz)
	move 1,J
	hrli 1,(cf%nud)\.fbbyv
	CHFDB
	move 3,A
	seto 2,
	move 1,J
	hrli 1,.fbsiz
	CHFDB
	move 1,J
	RLJFN
	  erjmp Lose
nextf:	trne f,f%nlst
	  jrst nextf1
	ltype ""
nextf1:	move 1,injfn
	GNJFN
	  skipa
	    jrst unbyt
	caie 1,GNJFX1
	  jrst Lose
	hrrz 1,cmdblk+.CMIOJ	;Have we issued a prompt?
	caie 1,.nulio
	  jrst Cmd		;Yup, so just ask again
Die:	HALTF
	jrst begin		;Let him restart

eoferr:	ltype "?Premature end of file"
	jrst Die

Lose:	ltype "?"
	movei 1,.priou
	hrloi 2,.fhslf
	setz 3,
	ERSTR
	  nop
	  jrst [ltype "?Error in error handler!"
		jrst Die]
	jrst Die

	VARIAB
Junk:	CONSTA

inpag==<.+777>_-9
inbuf==inpag_9

	end begin
