COMMENT  -*-SAIL-*- .=37331;
COMMENT <GERGELY.EXP>AMORT.SAI.39,  6-Nov-86 13:16:19, Edit by GERGELY;
BEGIN "amort"

COMMENT 

This program calculates mortgages and loans for a variety of different
conditions.

Copyright (C) by Peter J. Gergely.

This software is the sole property of the author and may not be copied
by any means  without the  expressed written consent  of the  authors.
This  program  may  be  used  by  any  university  or  any  non-profit
corporation with the restriction that  proper recognition be given  to
the author and the source of the program be known.

;

DEFINE monitorsw = true;       COMMENT Set true to monitor uses;

			       COMMENT Writes TO;

PRELOAD!WITH "PS:<GERGELY.WRK>AMORT.USERS"; STRING ARRAY appendfile[1:1];

PRELOAD!WITH
	" -- An Amortization Calculator  (7 January 1987)",
	"    by Peter J. Gergely";
STRING ARRAY title[1:2];

PRELOAD!WITH "(5.503)"; STRING ARRAY vers[1:1];

    REQUIRE "SAI:COMND.HDR" SOURCE!FILE;
    REQUIRE "SAI:SAILMACROS.SAI" SOURCE!FILE;
    REQUIRE "SAI:LONG.SAI" SOURCE!FILE;
    REQUIRE "SAI:RSCAN.HDR" SOURCE!FILE;
    REQUIRE "SAI:SORT.SAI" SOURCE!FILE;
    REQUIRE "<><>" DELIMITERS;

DEFINE MAX!array!size = <3000>;	! The maximum array size to use;

				! Define the assorted output devices;
DEFINE #dvdsk = <'0>;		Comment DISK;
DEFINE #dvmta = <'2>;		Comment MAGTAPE;
DEFINE #dvdta = <'3>;		Comment DECTAPE;
DEFINE #dvptr = <'4>;		Comment PAPER TAPE READER;
DEFINE #dvptp = <'5>;		Comment PAPER TAPE PUNCH;
DEFINE #dvdsp = <'6>;		Comment DISPLAY;
DEFINE #dvlpt = <'7>;		Comment LINE PRINTER;
DEFINE #dvcdr = <'10>;		Comment CARD READER;
DEFINE #dvfe = <'11>;		Comment FRONT END DEVICE;
DEFINE #dvtty = <'12>;		Comment TERMINAL;
DEFINE #dvpty = <'13>;		Comment PTY;
DEFINE #dvnul = <'15>;		Comment NULL DEVICE;
DEFINE #dvnet = <'16>;		Comment ARPA NETWORK;
DEFINE #dvplt = <'17>;		Comment PLOTTER;
DEFINE #dvcdp = <'21>;		Comment CARD PUNCH;
DEFINE #dvdcn = <'22>;		Comment DECNET ACTIVE COMPONENT;
DEFINE #dvsrv = <'23>;		Comment DECENT PASSIVE COMPONENT;
DEFINE #dvats = <'24>;		Comment APPLICATIONS TERMINAL SERVICE;
DEFINE #dvads = <'25>;		Comment AYDIN DISPLAY;
				! Define some macros for the command;
				! jsys stuff;

DEFINE check1 = <IF cm!err THEN CONTINUE "outerloop";
		IF cm!reparse THEN CONTINUE "innerloop">;

DEFINE check  = <IF cm!err THEN CONTINUE "outer command loop";
		 IF cm!reparse THEN CONTINUE "inner command loop">;

				! The various loan types;
DEFINE mortgage = <0>;
DEFINE loan = <1>;
DEFINE drea = <2>;

				! The various dynamic flags;
DEFINE flag!date = <1>;
DEFINE flag!interest = <2>;
DEFINE flag!principal = <3>;
DEFINE flag!generate = <4>;
DEFINE mode!day = <1>;
DEFINE mode!week = <2>;
DEFINE mode!month = <3>;
DEFINE mode!year = <4>;

DEFINE eleven!spaces = <"           ">;	! Eleven spaces;
DEFINE four!spaces = <"    ">;	! Four spaces;

INTEGER ochan,			! The output channel;
	start!pdate,END!pdate,	! Starting printing date, ending printing date;
	days!in!year,		! Number of days in current year;
	loan!flag,		! Nonzero if in loan calculation mode;
	pagecount,		! The current page count;
	term,			! Length of term in months;
	index,			! Temporary variable;
	profile!chan,		! Channel number for input profile;
	take!chan,		! to be used to store the take chan no.;
	starting!date,		! Starting date of the amortization;
	anniversary!month,	! Insertion month for anniversary payment;
	whichone,		! Temporary variable;
	brk,			! Dummy break character;
	logdir,			! The number of the login directory;
	key,			! Temporary variable;
	appendchan,		! Channel number for monitoring users;
	i,j,k,l,m,n,		! Temporary integers or indices;
	ii,jj,kk,ll,mm,nn,	! Temporary integers or indices;
	iii,jjj,kkk,lll,mmm,nnn;	! Temporary integers or indices;

BOOLEAN	feb29!flag,		! True if counting Feb. 29 in leap years;
	flag,flag1,flag2,flag3,	! Temporary flags;
	enabled!user,		! True if a privileged user;
	NOT!rescan,		! True if not from the rescan buffer;
	profile!flag,		! True if reading the user's profile;
	take!flag,		! True if doing a take command file;
	show!errors,		! True if errors are to be shown;
	month!flag,		! True if calc are fixed 12 months to a year;
	roundoff!flag;		! True if interest payment rounding is on;

STRING	text,text1,text2,text3,	! Temporary text variables;
	page!header,		! The header for each page;
	outfile,		! The name of the output file;
	line,word,		! Temporary text variables;
	connected!directory,	! The name of the connected directory;
	program!name,		! The name of this program as an .EXE;
	spaces,			! Storage for lots of spaces;
	profile!name,		! The full profile name;
	saveprofile!name,	! The save profiles name;
	temp;			! Temporary text variable;

REAL	principal,		! The principal;
	yearly!interest,	! Yearly interest as a decimal;
	anniversary!payment,	! The amount of anniversary payment;
	monthly!payment,	! The amount of payment per month;
	xx,yy,zz,x,y,z;		! Temporary real variables;

PRELOAD!WITH
	"Unk. ",
	"Jan. ","Feb. ","Mar. ",
	"Apr. ","May  ","June ",
	"July ","Aug. ","Sept.",
	"Oct. ","Nov. ","Dec. ";
	STRING ARRAY month[0:12];	! The months in a year;

PRELOAD!WITH
	30,
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31,
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31;
INTEGER ARRAY day!month[0:24];	! The number of days in a month;
				! For two complete years;
PRELOAD!WITH
	"Exit",
	"Calculate",
	"Output",
	"Loan",
	"Mortgage",
	"Principal",
	"Anniversary",
	"Term",
	"Interest",
	"Starting-date",
	"Payment",
	"Reset",
	"Show",
	"%Truncate",
	"%Roundoff",
	"Help",
	"%Leap-year",
	"Print",
	"Save",
	"Take",
	"Dynamic-Input",
	"Days",
	"%Daily","%Monthly";
	STRING ARRAY topcom[1:24];	! Top-level commands;

PRELOAD!WITH
	"365","366","29-365","28-366";
STRING ARRAY leapcom[1:4];	! The leap-year commands;

PRELOAD!WITH
	"Payment",
	"Schedule",
	"Principal",
	"Termination",
	"Interest";
STRING ARRAY calculatecom[1:5];	! The calculate commands;

PRELOAD!WITH
	"Abort",
	"Calculate",
	"Exit",
	"Save",
	"Show";
STRING ARRAY dynamiccom[1:5];	! The subcommands FOR dynamic mode;

PRELOAD!WITH
	"Day",
	"Week",
	"Month",
	"Year";
STRING ARRAY periodcom[1:4];	! The sucommands FOR dynamic generate command;
PRELOAD!WITH
	"Days",
	"Weeks",
	"Months",
	"Years";
STRING ARRAY periodscom[1:4];	! The sucommands FOR dynamic generate command;

PRELOAD!WITH
	"Date-Change",
	"Interest",
	"Principal",
	"Generate";
	STRING ARRAY flagcom[1:4];

PRELOAD!WITH
	"All",
	"Between",
	"Summary";
STRING ARRAY printcom[1:3];	! The print commands;

PRELOAD!WITH "First"; STRING ARRAY sprintcom[1:1];
PRELOAD!WITH "Last"; STRING ARRAY eprintcom[1:1];
PRELOAD!WITH
	"Commands",
	"Anniversary",
	"Calculate",
	"Exit",
	"Help",
	"Interest",
	"Loan",
	"Mortgage",
	"Output",
	"Payment",
	"Principal",
	"Reset",
	"Roundoff",
	"Show",
	"Starting-date",
	"Term",
	"Truncate",
	"Leap-year",
	"Print",
	"Save",
	"Take",
	"Days",
	"Dynamic-Input","Daily","Monthly";

STRING ARRAY helpcom[1:25];	! The help commands;

PRELOAD!WITH "Yes","No"; STRING ARRAY yesnocom[1:2];
PRELOAD!WITH
	"Mortgage",
	"Loan",
	"DREA Loan";
STRING ARRAY loan!type[0:2];	! The type of loans;

PRELOAD!WITH
	"Unknown",
	"DREA-Credit-Union";
STRING ARRAY loancom[1:2];	! The loan commands;

PRELOAD!WITH
	"DSK",
	"LPT",
	"NUL",
	"TTY";
	STRING ARRAY outputcom [1:4];	! The output devices that;
					! don't need a filename;

PRELOAD!WITH
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December";
STRING ARRAY monthcom[1:12];	! The months of year commands;


!<<OPEN-OUT and CLOSE-OUT -- open and close the output file respectively>>;
INTEGER PROCEDURE OPEN!out(STRING ofile);
BEGIN "OPEN out"
INTEGER ich;
ich _ OPENFILE(ofile,"AE");
IF (!skip! NEQ 0) OR (ich=-1)
    THEN
	BEGIN
	    ich _ OPENFILE(ofile,"WE");
	    IF (!skip! NEQ 0) OR (ich=-1)
	       THEN
	           BEGIN
		       ich _ OPENFILE("TTY:","WE");
		       PRINT ("% Couldn't open ",ofile,"for write or append.",
			      "  TTY: being used instead.",crlf);
		   END;
	END;
RETURN (ich);
END "OPEN out"; ! BEGIN ;

PROCEDURE close!out(REFERENCE INTEGER ich);
BEGIN "CLOSE out"
    boolean oflag;
    string s;
    IF (ich NEQ -1) THEN
	BEGIN "output check"
	    s _ JFNS(ich,'111110000001);
	    oflag _ CFILE(ich);
	    IF (NOT oflag)
		THEN
		    PRINT("% Failed to close ",s,crlf)
		    ELSE ich _ -1;
	END "output check"
	ELSE ich _ -1;
END "CLOSE out";

!<<LEAP!YEAR -- Returns TRUE if the given year is a leap year>>;
BOOLEAN PROCEDURE leap!year (INTEGER year);
BEGIN "leap!year"
    IF (((year MOD 400) = 0) OR (((year MOD 100) NEQ 0)
				 AND ((year MOD 4) = 0)))
	THEN RETURN (TRUE) ELSE RETURN (FALSE);
END "leap!year"; ! BEGIN ;

!<<CAPS -- Translates a lower case string to an upper case  one>>;
simple internal string procedure caps (value string A);

comment
  returns a string equal to A except all lower case
  alphabetic characters converted to upper case;

begin "caps"

  integer bp, L;
  string B;
  label x,y;

  define offset = "a"-"A";

  B := A & "X";		! make a guaranteed new copy;
  L := length(A);	! length of the string;
  bp := MEMORY[LOCATION(b)];	! and byte pointer to it;

  start!code "capitalize"

x:  sosge L;		! test for end of string;
     jrst y;		! if at end, exit;
    ildb  1,bp;		! get next char;
    cail  1,"a";	! see if it's between "a";
    caile 1,"z";	! ... and "z";
     jrst x;		! no, try next one;
    trz   1,offset;	! yes, capitalize it;
    dpb   1,bp;		! and deposit it back in the string;
    jrst  x;		! and go get another;
y:			! all done;

  end "capitalize";
  return (B[1 to inf-1])

end "caps";

!<<LIST!KEYWORDS -- Returns a string containing a sorted table of keywords.>>;

STRING PROCEDURE list!keywords
    (REFERENCE STRING ARRAY S; VALUE INTEGER width(72); INTEGER indent(0));
! S = list of keywords, width = terminal screen width, indent = spaces indented.;
BEGIN "list!keywords"
    INTEGER i,j,k,l,w,len,ii,jj;
    STRING ARRAY sort!array[1:ARRINFO(s,2)];	! dummy array to do sort in;
    STRING t;
    BOOLEAN SIMPLE PROCEDURE orderok (REFERENCE INTEGER i,j);
	RETURN ( alphabetized (caps(sort!array[i]),caps(sort!array[j])));

    t _ " ";
    WHILE (LENGTH(t) < indent) DO t _ t & t;
    IF (indent > 0) THEN t _ t[1 FOR indent] ELSE t _ NULL;
    width _ width - LENGTH(t);
    len _ ARRINFO(s,2);
    i _ 0;
    WHILE ((i _ i+1) LEQ len) DO sort!array[i] _ s[i];
    ii _ 1;
    jj _ len;
    strsort (sort!array,ii,jj,orderok);
    l _ 0;
    i _ 0;
    WHILE ((i_i+1) LEQ len)
	DO IF ((J _ LENGTH(sort!array[i])) > l) THEN l _ j;
    l _ l+3;
    j _ (width) DIV l;
    i _ 0;
    WHILE ((i _ i + 1) LEQ len)
	DO PRINT(IF (((i-1) MOD j) = 0) THEN t ELSE NULL,
		 sort!array[i],
		 IF ((i MOD j) neq 0)
		   THEN spaces[1 FOR (l-LENGTH(sort!array[i]))]
		   ELSE crlf);

END "list!keywords"; ! BEGIN ;



!<<GET!DATE -- gets the current month and year and returns the total number of months >>;

INTEGER PROCEDURE get!date (INTEGER odate);
BEGIN "get!date"
    STRING s;
    INTEGER i,j;
    s _ ODTIM(odate,'52400000000);	! Get the current time and date;
    i _ CVD(s[INF-3 TO INF]);		! Find the number of years;
    j _ CVD(s[INF-6 TO INF-5]);		! and the number of months;
    RETURN((i*12)+j+1);			! return the total number of months;
END "get!date";


!<<NMOD -- Calculates modulo from 1 to N instead of 0 to N-1>>;

INTEGER PROCEDURE nmod (INTEGER n, m (1));
BEGIN "nmod"
    INTEGER ans;
    ans _ n MOD m;
    IF (ans = 0) THEN RETURN(m) ELSE RETURN(ans);
END "nmod";

!<<CV!NUM -- Converts a REAL TO a STRING without leading 0's OR trailing ones>>;

STRING PROCEDURE cv!num (REAL x; INTEGER w(0), d(2));
BEGIN "cv!num"
    STRING text,s;
    INTEGER width, digits,l;
    GETFORMAT(width,digits);		! Save the current width and digits;
    SETFORMAT(w,d);			! Set the new ones;
    text _ CVF(x);			! Make a string out of the number;
    SETFORMAT(width,digits);		! Reset the width and digits;
    IF w=0 THEN
	BEGIN
	    l _ LOP(text);
	    WHILE (l=space AND (LENGTH(text) NEQ 0)) DO l _ LOP(text);
	    text _ l & text;
	END;				! Get rid of preceding blanks;
    RETURN(text);			! Return the number as a string;
END "cv!num";

!<<CV!INT -- Converts a integer TO a STRING without leading 0's OR trailing ones>>;

STRING PROCEDURE cv!int (REAL x; INTEGER w(0), d(0));
BEGIN "cv!int"
    STRING text;
    INTEGER width, digits;
    GETFORMAT(width,digits);		! Save the old width and digits;
    SETFORMAT(w,d);			! Set the new ones;
    text _ CVS(x);			! Convert the integer to text;
    SETFORMAT(width,digits);		! Reset the old width and digits;
    IF w=0 THEN
	BEGIN
	    l _ LOP(text);
	    WHILE (l=space AND (LENGTH(text) NEQ 0)) DO l _ LOP(text);
	    text _ l & text;
	END;				! Get rid of preceding blanks;
    RETURN(text);			! Return the number;
END "cv!int";

!<<PRINT!DATE -- Prints an integer date (format Years*12 + months) as date and year>>;

STRING PROCEDURE PRINT!date( INTEGER somedate(0));
BEGIN "print!date"
    INTEGER y,m;
    y _ (somedate - 1) DIV 12;		! Find the date;
    IF (y < 100) THEN y _ y + 1900;	! Less than 100 then 1900;
    m _ nmod(somedate,12);		! Get the month;
    RETURN(monthcom[m] & cv!int(y,5));	! Return the string;
END "print!date";

!<<PRINT!ok -- TRUE if date given is an element of [start!pdate, end!pdate]>>;

BOOLEAN PROCEDURE PRINT!ok( INTEGER somedate(-1));
BEGIN "print!ok"
    IF ((somedate GEQ start!pdate) AND (somedate LEQ END!pdate))
	THEN RETURN(TRUE)
	ELSE RETURN(FALSE);
END "print!ok";


!<<EFFECTIVE!INTEREST -- Calculates the effective interest for a given yearly interest, compounds, and fractional period>>;

REAL PROCEDURE effective!interest
    (VALUE REAL interest; INTEGER q!compounds, p!periods);
BEGIN "effective!interest"
    REAL ans;
    ans _ ((1.0 + (interest/q!compounds))^(q!compounds/p!periods)) - 1.0;
    RETURN(ans);
END "effective!interest";

!<<ROUNDOFF!CENTS -- Returns exact!value either rounded or truncated to the cents>>;

REAL PROCEDURE roundoff!cents
    (VALUE REAL exact; BOOLEAN rounding!flag);
BEGIN "roundoff!cents"
    REAL ans,x,y;
    IF rounding!flag
	THEN ans _ (exact * 100.0) DIV 1
	ELSE ans _ (exact * 100.0 - 0.5) DIV 1;
    RETURN(ans/100.0);
END "roundoff!cents";

!<<COMPOUND!INTEREST -- Calculates compound interest for DECIMAL!INTEREST over Q!compounds AND N!intervals>>;

REAL PROCEDURE compound!interest
    (VALUE REAL interest; INTEGER Q!compounds, N!intervals);
BEGIN "compound!interest"
    REAL ans;
    ans _ ((1.0 + interest/q!compounds)^(q!compounds * n!intervals)) - 1.0;
    RETURN(ans);
END "compound!interest";

!<<SPECIAL!INTEREST -- Calculates the interest FOR the past month IN LONG REAL>>;

! Long real is needed for the precision.  Unfortunately the code in;
! SAIL is not implemented fully or properly on the DEC-20, so single;
! step calculations are used and do work properly;

REAL PROCEDURE special!interest
    (REAL principal, interest; INTEGER month, loanflag;
     BOOLEAN roundflag; INTEGER year);
BEGIN "special!interest"
    LONG REAL ans1,ans2,ans3,ans4,ans5;
    REAL ans, q, dyear, dmon;

    IF (loanflag NEQ mortgage) THEN q _ 12 ELSE q _ 2;	! Loans are;
					! different from mortgages;
    IF month!flag
	THEN
	    BEGIN "month"
		dyear _ 12;
		dmon _ 1;
	    END "month"
	ELSE
	    BEGIN "daily"
		IF leap!year(year)
		    THEN
			BEGIN "leap year"
			    dyear _ days!in!year;	! Set up the leap years;
			    IF ((month NEQ 2) OR (NOT feb29!flag))
				THEN dmon _ day!month[month]
				ELSE dmon _ 29;
			END "leap year"
		    ELSE
			BEGIN "NOT leap year"
			    dyear _ 365.0;
			    dmon _ day!month[month]
			END "NOT leap year";
	    END "daily"; ! BEGIN ;

    CASE loanflag OF
	    BEGIN
		[1][2] BEGIN "loan"	! Special calculation for loans;
		    ans3 _ dble(interest);
		    ans3 _ ans3 / dble(dyear);
		    ans3 _ dmon*ans3;
		    ans5 _ ans3;	! Final ANSWER FOR interest IN ans5;
		END "loan";

		[0] BEGIN "mortgage"
		    ans3 _ dble(interest);
		    ans3 _ ans3 / dble(q);
		    ans3 _ ans3 + 1.0;
		    ans4 _ dble((2.0*dmon)/dyear);
		    ans1 _ ans3^ans4;
		    ans5 _ ans1 - dble(1.0);	! Final ANSWER FOR interest IN ans5;
		END "mortgage"
	    END;
	ans2 _ dble(principal)*ans5;	! Multiply the principal by;
					! the interest;
	ans _ roundoff!cents(sngl(ans2),roundflag);	! Round or;
					! truncate to the nearest penny ;
	RETURN (ans);			! Return;
    END "special!interest";

!<<DYNAMIC!INTEREST -- Calculates the interest FOR the past month IN LONG REAL>>;

! Long real is needed for the precision.  Unfortunately the code in;
! SAIL is not implemented fully or properly on the DEC-20, so single;
! step calculations are used and do work properly;

REAL PROCEDURE dynamic!interest
    (REAL principal, interest; INTEGER days, loanflag;
     BOOLEAN roundflag);
BEGIN "dynamic!interest"
    LONG REAL ans1,ans2,ans3,ans4,ans5;
    REAL ans, q, dyear, dmon;
    
    CASE loanflag OF
	    BEGIN
		[1][2] BEGIN "loan"	! Dynamic calculation for loans;
		    ans3 _ dble(interest);
		    ans3 _ ans3 / dble(365.0);
		    ans3 _ days*ans3;
		    ans5 _ ans3;	! Final ANSWER FOR interest IN ans5;
		END "loan";

		[0] BEGIN "mortgage"
		    ans3 _ dble(interest);
		    ans3 _ ans3 / dble(2.0);
		    ans3 _ ans3 + 1.0;
		    ans4 _ dble((2.0*days)/365.0);
		    ans1 _ ans3^ans4;
		    ans5 _ ans1 - dble(1.0);	! Final ANSWER FOR interest IN ans5;
		END "mortgage"
	    END;

	ans2 _ dble(principal)*ans5;	! Multiply the principal by;
					! the interest;
	ans _ roundoff!cents(sngl(ans2),roundflag);	! Round or;
					! truncate to the nearest penny ;
	RETURN (ans);			! Return;
    END "dynamic!interest";

!<<CALCULATE!PRINCIPAL -- Calculates the principal given the other unknowns>>;

REAL PROCEDURE calculate!principal (REAL payment (0.0), interest (0.0);
				  INTEGER term (0), loanflag (0));
BEGIN "calculate!principal"
    REAL ans,principal,monthly!interest,xi;
    IF ((payment LEQ 0.0) OR (interest LEQ 0.0) OR (term LEQ 0))
	THEN RETURN(0.0);		! Error check;
! Loans don't use the effective interest calculation;
    monthly!interest _ effective!interest(
			interest,IF (loanflag NEQ mortgage) THEN 12 ELSE 2,12);
    xi _ monthly!interest/(1.0 - (1.0+monthly!interest)^(-term));
    ans _ roundoff!cents(payment / xi,TRUE);
    RETURN(ans);
END "calculate!principal";

!<<CALCULATE!PAYMENT -- Calculates the monthly payment from the other unknowns>>;

REAL PROCEDURE calculate!payment (REAL principal (0.0), interest (0.0);
				  INTEGER term (0), loanflag (0));
BEGIN "calculate!payment"
    REAL ans,payment,monthly!interest,xi;
    IF ((principal LEQ 0.0) OR (interest LEQ 0.0) OR (term LEQ 0))
	THEN RETURN(0.0);		! Error check;
    monthly!interest _ effective!interest(
		       interest, IF (loanflag NEQ mortgage) THEN 12 ELSE 2,12);
! Calculate the interest factor xi ;
    xi _ monthly!interest/(1.0 - (1.0+monthly!interest)^(-term));
    ans _ roundoff!cents(principal * xi,TRUE);	! Calculate payment;
! Make sure that this payment covers the whole principal.  If not then;
! increment by one cent until this is true.;
    WHILE (roundoff!cents(ans/xi,TRUE) < principal)
	DO ans _ roundoff!cents(ans+.0101,TRUE);
    RETURN(ans);
END "calculate!payment";

!<<CALCULATE!TERM -- Calculates the duration of the Mortgage or Loan>>;

INTEGER PROCEDURE calculate!term (REAL principal (0.0), interest (0.0),
				  payment (0.0); INTEGER loanflag (0));
BEGIN "calculate!term"
    REAL ans,monthly!interest,xi,p1,p2;
    INTEGER ans1;

    IF ((principal LEQ 0.0) OR (interest LEQ 0.0) OR (monthly!payment LEQ 0.0))
	THEN RETURN(0);			! Error check;
    monthly!interest _ effective!interest(
			interest,IF (loanflag NEQ mortgage) THEN 12 ELSE 2,12);

    p1 _ 1.0 - (principal * monthly!interest / payment);	! Top value;
    p2 _ 1.0 + monthly!interest;	! Bottom value;
    IF ((p1 LEQ 0.0) OR (p2 LEQ 0.0)) THEN
	BEGIN
	    PRINT("% Payment too small to calculate the termination date.",crlf);
	    RETURN(0)
	END;
    
    ans _ - LOG(p1)/LOG(p2);		! Term is the (- logarithm) of;
					! the division of the two;
    IF (ans LEQ 0.0) THEN
	BEGIN
	    PRINT("% Impossible to calculate the termination date.",crlf);
	    RETURN(0)
	END;

    ans1 _ (ans DIV 1) - 1;		! Make it an integer;

	DO				! Check to make sure term is value;
	    BEGIN
		ans1 _ ans1 + 1;
		xi _ monthly!interest/(1.0 - (1.0+monthly!interest)^(-ans1));
	    END UNTIL (roundoff!cents(payment/xi,TRUE) GEQ principal);

    RETURN(ans1);
END "calculate!term";

!<<CALCULATE!INTEREST -- Calculates the interest for a the Mortgage or Loan>>;

REAL PROCEDURE calculate!interest (REAL principal (0.0);
				   INTEGER term (0);
				   REAL payment (0.0); INTEGER loanflag (0));
BEGIN "calculate!interest"
    REAL im, iy, iold, inew,tol;
    INTEGER counter,ans;
    REAL PROCEDURE fi (REAL x);		! Function of i;
	BEGIN "fi"
	    REAL f;
	    f _ principal*x + payment * compound!interest(x,1,(-term));
	    RETURN(f);
	END "fi";
    REAL PROCEDURE fdi (REAL x);	! Derivative function of i;
	BEGIN "fdi"
	    REAL fd;
	    fd _ principal - term*payment * (1.0 + x)^(-(term+1));
	    RETURN(fd);
	END "fdi";
    inew _ .15;				! Guesstimate an initial approx.;
    counter _ 0;			! Set counter;
    tol _ .0000001;			! And the tolerance;
    DO
	BEGIN
	   iold _ inew;			! Prepare for an iteration;
	   inew _ iold - (fi(iold)/fdi(iold));	! Do the iteration;
	   counter _ counter + 1;	! Increment the counter;
	END
	UNTIL ((ABS(inew - iold) LEQ tol)
	       OR (counter GEQ 100));	! Boundary condition;
    IF (counter GEQ 100) THEN
	PRINT("% Interest calculation did NOT converge.  Assuming last value.",
	      crlf);
    IF (loanflag NEQ mortgage)
	THEN iy _ inew * 12.0
	ELSE iy _ 2.0 * (((1.0 + inew)^6.0) - 1.0);
    ans _ (iy * 100000.0) DIV 1;
    RETURN(ans/100000.0);
END "calculate!interest";

!<<CALCULATE!SCHEDULE -- Calculates AND displays schedule>>;

PROCEDURE calculate!schedule (BOOLEAN roundflag (FALSE);
			      REAL principal (0.0), yint (0.0),
			      mpay (0.0); INTEGER term (0); REAL apay (0.0);
			      INTEGER amonth (0), loanflag (0));
BEGIN "calculate!schedule"
    STRING sdate,line;

    REAL  mint,
	    savings,yearly!savings,total!savings,
	    calendar!savings,
	    total!paid, total!interest, total!payment, remainder,
	    yearly!paid, yearly!interest, yearly!payment,
	    calendar!paid, calendar!interest, calendar!payment,
	    old!capital,cpay,
	    current!capital, current!payment, current!interest,
	    monthly!paid, monthly!interest;

    INTEGER REAL!date, mortgage!year, month!counter, REAL!month,REAL!year,
	    index,i,j,k,l,m,n,
	    header!done,
	    dev!type,
	    page!count;

    IF ((principal LEQ 0) OR (yint LEQ 0) OR (term LEQ 0)) THEN RETURN;

    IF mpay LEQ 0
	THEN mpay _ calculate!payment (principal, yint, term, loanflag);

    ochan _ OPEN!out(outfile);

    dev!type _ DEVTYPE(ochan);

    IF (dev!type NEQ #dvtty) THEN PRINT("Calculating Schedule ...",crlf);

    page!header _ CV!int(((term-1) DIV 12) + 1) & "-Yr. ";
    page!header _ page!header & loan!type[loanflag] & " Table  (Pv="; ! );
    page!header _ page!header & cv!num(principal) & ", Pmt=" & cv!num(mpay);
    page!header _ Page!header & ", i=" & cv!num(yint*100.0,0,4) & "%, ";
    IF month!flag
	THEN page!header _ page!header & "Lp=MON"
	ELSE
	    BEGIN
		page!header _ page!header & "Lp=" & cv!int(days!in!year);
		page!header _ page!header & (IF (feb29!flag AND (days!in!year = 365))
				 THEN "+"
				 ELSE IF ((NOT feb29!flag)
					  AND (days!in!year = 366)) THEN "-"
				      ELSE NULL);
	    END; ! BEGIN ;
    page!header _ page!header & ")  Page ";

    page!count _ 0;
    header!done _ 0;

    total!savings _ total!paid _ total!interest _ total!payment _ 0.0;
    savings _ remainder _ 0.0;
    calendar!savings _ calendar!paid _ calendar!interest _ calendar!payment _ 0.0;
    yearly!savings _ yearly!paid _ yearly!interest _ yearly!payment _ 0.0;
    current!capital _ principal;
    month!counter _ 0;
    mortgage!year _ -1;

    IF (starting!date = 0) THEN starting!date _ get!date(GTAD);

    WHILE (month!counter < term) DO
	BEGIN "schedule calculation"
	    old!capital _ current!capital;
	    IF (old!capital LEQ 0.0) THEN DONE "schedule calculation";
	    month!counter _ month!counter + 1;
	    i _ nmod(month!counter,12);
	    REAL!date _ starting!date + month!counter - 1;
	    REAL!year _ (REAL!date -1) DIV 12;
	    k _ nmod(REAL!date,12);
	    sdate _ month[k] & " " & cv!int(REAL!year,4);
	    current!interest _ special!interest(old!capital,yint,
						nmod(k-1,12),loanflag,
						roundflag,
						REAL!year);
	    cpay _ mpay;
	    IF (loanflag = drea)
		THEN
		    BEGIN
			current!payment _ cpay - current!interest;
			savings _ ((current!payment*100.00) MOD 100) / 100.0;
			current!payment _ current!payment - savings;
		    END
		ELSE
		    BEGIN
			current!payment _ cpay - current!interest;
			savings _ 0.0;
		    END;
	    
	    IF (current!payment > old!capital)
		THEN
		    BEGIN
			cpay _ current!interest + old!capital;
			current!payment _ old!capital;
			current!capital _ 0.0;
			savings _ 0.0;
		    END
		ELSE current!capital _ old!capital - current!payment;

	    calendar!interest _ calendar!interest + current!interest;
	    calendar!paid _ calendar!paid + cpay;
	    calendar!payment _ calendar!payment + current!payment;
	    calendar!savings _ calendar!savings + savings;

	    total!interest _ total!interest + current!interest;
	    total!paid _ total!paid + cpay;
	    total!payment _ total!payment + current!payment;
	    total!savings _ total!savings + savings;

	    yearly!interest _ yearly!interest + current!interest;
	    yearly!paid _ yearly!paid + cpay;
	    yearly!payment _ yearly!payment + current!payment;
	    yearly!savings _ yearly!savings + savings;

	    IF (PRINT!ok(REAL!date)) THEN
		BEGIN "PRINT information"
		    header!done _ header!done + 1;
		    IF ((i=1) OR (header!done = 1)) THEN
			BEGIN
			    j _ month!counter DIV 12;
			    IF (((j MOD 3) = 0) OR (header!done = 1))
				THEN CPRINT(ochan,
					    IF ((j>0)
						AND (dev!type NEQ #dvtty))
					            THEN ff & page!header
					            ELSE page!header,
					    page!count _ page!count + 1,
					    IF roundflag THEN " R" ELSE " T",
					    crlf);
					    CPRINT(ochan,crlf,
						   spaces[1 FOR 36],
						   "Year ",j,crlf);
					    CPRINT(ochan," Month",
						   "   Old Value",
						   "     Payment",
						   "    Interest",
						   "  Actual Pay",
						   IF (loanflag = drea)
						     THEN "   S/A" ELSE NULL,
						   "   New Value",
						   crlf);
					    mortgage!year _ j;
			END;
		    CPRINT(ochan,"  ",cv!int(i,2),"  ",
			   " ",cv!num(old!capital,11),
			   " ",cv!num(cpay,11),
			   " ",cv!num(current!interest,11),
			   " ",cv!num(current!payment,11),
			   IF (loanflag = drea)
			       THEN " " & cv!num(savings,5) ELSE NULL,
			   " ",cv!num(current!capital,11),
			   "  ",sdate,crlf);
		END "PRINT information";

	    IF (current!capital LEQ 0.0) THEN DONE "schedule calculation";

	    IF (k=amonth AND (apay NEQ 0)) THEN
		BEGIN "Anniversary payment"
		    current!payment _ cpay _ apay;
		    savings _ 0.0;
		    current!interest _ 0.0;
		    old!capital _ current!capital;
		    IF (current!payment > old!capital)
			THEN
			    BEGIN
				cpay _ current!interest + old!capital;
				current!payment _ old!capital;
				current!capital _ 0.0;
			    END
			ELSE current!capital _ old!capital - current!payment;

		    yearly!paid _ yearly!paid + cpay;
		    yearly!interest _ yearly!interest + current!interest;
		    yearly!payment _ yearly!payment + current!payment;
		    calendar!paid _ calendar!paid + cpay;
		    calendar!interest _ calendar!interest + current!interest;
		    calendar!payment _ calendar!payment + current!payment;
		    total!paid _ total!paid + cpay;
		    total!interest _ total!interest + current!interest;
		    total!payment _ total!payment + current!payment;

		    IF (PRINT!ok(REAL!date)) THEN
			CPRINT(ochan,"ANNIV ",
			       " ",cv!num(old!capital,11),
			       " ",cv!num(cpay,11),
			       " ",cv!num(current!interest,11),
			       " ",cv!num(current!payment,11),
			       IF (loanflag = drea)
			           THEN " " & cv!num(savings,5) ELSE NULL,
			       " ",cv!num(current!capital,11),
			       "  ",sdate,crlf);

		    IF (current!capital LEQ 0.0)
			THEN DONE "schedule calculation";
		END "Anniversary payment"; ! BEGIN ;
	    
	    IF ((k=12) AND (i NEQ 12) AND PRINT!ok(REAL!date)) THEN
		BEGIN "calendar summary"
		    CPRINT(ochan," Year ",cv!int(REAL!year,4),
			   "        ",
			   " ",cv!num(calendar!paid,11),
			   " ",cv!num(calendar!interest,11),
			   " ",cv!num(calendar!payment,11),
			   IF (loanflag = drea)
			        THEN " " &cv!num(calendar!savings,5) ELSE NULL,
			   "            ",
			   "  ",cv!int(REAL!year,4),
			   "  Year",crlf);
		    calendar!paid _ calendar!interest _ calendar!payment _ 0.0;
		    calendar!savings _ 0.0;
		END "calendar summary";

	    IF ((i=12) AND PRINT!ok(REAL!date)) THEN
		BEGIN "yearly summary"
		    CPRINT(ochan,"      ",
			   "            ",
			   " -----------",
			   " -----------",
			   " -----------",
			   IF (loanflag = drea) THEN " -----" ELSE NULL,
			   crlf);
		    CPRINT(ochan,"      ",
			   "            ",
			   " ",cv!num(yearly!paid,11),
			   " ",cv!num(yearly!interest,11),
			   " ",cv!num(yearly!payment,11),
			   IF (loanflag = drea)
			       THEN " " & cv!num(yearly!savings,5) ELSE NULL,
			   crlf);
		    yearly!paid _ yearly!interest _ yearly!payment _ 0.0;
		    yearly!savings _ 0.0;
		END "yearly summary";
	END "schedule calculation";

    IF ((nmod(month!counter,12) NEQ 12) AND PRINT!ok(REAL!date))
	THEN
	    BEGIN
		CPRINT(ochan,"      ",
		       "            ",
		       " -----------",
		       " -----------",
		       " -----------",
		       IF (loanflag = drea) THEN " -----" ELSE NULL,
		       crlf);
		CPRINT(ochan,"      ",
		       "            ",
		       " ",cv!num(yearly!paid,11),
		       " ",cv!num(yearly!interest,11),
		       " ",cv!num(yearly!payment,11),
		       IF (loanflag = drea)
			   THEN " " & cv!num(yearly!savings,5) ELSE NULL,
		       crlf);
	    END;

    i _ month!counter DIV 12;
    j _ month!counter MOD 12;

    PRINT(IF (current!capital NEQ 0) THEN "% " ELSE NULL,
	  "The ",IF (loanflag NEQ mortgage) THEN "loan " ELSE "mortgage ","was ",
	  IF(current!capital NEQ 0) THEN "NOT " ELSE NULL,
	  "paid after ",i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
	  " and ",j," month",IF (j NEQ 1) THEN "s" ELSE NULL,".",crlf);

    IF (dev!type NEQ #dvnul)
	THEN
	    BEGIN
		CPRINT(ochan,
		       IF (dev!type NEQ #dvtty) THEN ff & page!header
		           ELSE page!header,
		       page!count _ page!count + 1,
		       IF roundflag THEN " R" ELSE " T",
		       crlf,crlf,crlf);
		CPRINT(ochan,"    Final Totals after ",
		       i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
		       " and ",j," month",IF (j NEQ 1) THEN "s" ELSE NULL,
		       ".",crlf,crlf);
		CPRINT(ochan,
		       "	Interest   = ",cv!num(total!interest,11),crlf,
		       "	Repayment  = ",cv!num(total!payment,11),crlf,
		       "	Remainder  = ",cv!num(current!capital,11),crlf,
		       "	              ----------",crlf,
		       "	Total        ",
		       cv!num(total!interest+total!payment+current!capital,11),
		       crlf,
		       IF (loanflag = drea) THEN
		       crlf & "	On Account = " & cv!num(total!savings,11)
		       ELSE null,crlf);
	    END
	ELSE
	    BEGIN
		PRINT(crlf,"    Final Totals after ",
		      i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
		      " and ",j," month",IF (j NEQ 1) THEN "s" ELSE NULL,
		      ".",crlf,crlf);
		PRINT(
		      "	Interest   = ",cv!num(total!interest,11),crlf,
		      "	Repayment  = ",cv!num(total!payment,11),crlf,
		      "	Remainder  = ",cv!num(current!capital,11),crlf,
		      "	              -----------",crlf,
		      "	Total        ",
		      cv!num(total!interest+total!payment+current!capital,11),
		      crlf,
		      IF (loanflag = drea) THEN
		      crlf & "	On Account = " & cv!num(total!savings,11)
		      ELSE null,crlf);
	    END;
    CLOSE!out(ochan);
END "calculate!schedule";


!<<SHOW!SETTINGS -- Shows the settings to the default>>;

PROCEDURE show!settings;
BEGIN "show!settings"
    INTEGER i,j,k,l,width,digits;
    REAL x,y,z;
    STRING s,s1,s2;
    PRINT(loan!type[loan!flag], " Calculation with output to ",outfile,".",
	  crlf);
    i _ term DIV 12;
    j _ term MOD 12;
    PRINT("	Principal     = $",cv!num(principal,10),crlf);
    PRINT("	Payment       = $",cv!num(monthly!payment,10),crlf);
    PRINT("	Interest      =  ",cv!num(yearly!interest*100.0,10),"%",crlf);
    PRINT("	Term          =  ",i," year",IF i NEQ 1 THEN "s" ELSE NULL,
	  " and ",j," month",IF j NEQ 1 THEN "s" ELSE NULL,crlf);
    IF anniversary!payment>0 THEN
	PRINT ("	Anniversary payment = $",cv!num(anniversary!payment),
	       " in ",monthcom[anniversary!month],".",crlf);
    PRINT("	Starting Date =  ",IF starting!date=0 THEN "Unknown."
	  ELSE monthcom[nmod(starting!date,12)] & " "
	  & CVS((starting!date-1) DIV 12) & ".",crlf);
    IF ((term > 0) AND (starting!date > 0))
	THEN PRINT("	Last Payment  =  ",
		   monthcom[nmod((starting!date+term-1),12)] & " "
		   & CVS((starting!date+term-1) DIV 12) & ".",crlf);
    PRINT("	Calculations  =  ",IF roundoff!flag THEN "Normal"
	  ELSE "Truncated",crlf);
    PRINT("	Leap Years    =  ",days!in!year," days with ",
	  IF feb29!flag THEN "29" ELSE "28"," days in February.",crlf);
    PRINT("	Interest Calc =  ", IF month!flag THEN "MONTHLY--12 months / year."
	  ELSE "DAILY over past month.",crlf);

    IF ((start!pdate > 0) OR (END!pdate < infinity))
	THEN
	    IF (END!pdate = 0)
		THEN s _ "The summary only"
		ELSE
		    BEGIN "somedate"
			s _ "From ";
			IF (start!pdate = 0)
			    THEN s _ s & "the first payment"
			    ELSE s _ s & PRINT!date(start!pdate);
			s _ s & " to ";
			IF (END!pdate = infinity)
			    THEN s _ s & "the last payment"
			    ELSE s _ s & PRINT!date(END!pdate);
		    END "somedate"
	ELSE s _ "All of the schedule";
    PRINT("	Printout      =  ",s & ".",crlf);
END "show!settings";

!<<SAVESETTINGS -- Saves the current settings>> ;

SIMPLE PROCEDURE savesettings;
BEGIN "savesettings"
    INTEGER i,j,k,l,width,digits;
    REAL x,y,z;
    STRING s,s1,s2;
    INTEGER saveprofile;

    saveprofile _ OPENFILE (saveprofile!name, "WE");

    IF (!skip! NEQ 0) OR (saveprofile=-1)
	THEN
	    BEGIN
		IF show!errors
		    THEN PRINT("%  Cannot open file ",saveprofile!name, crlf);
		RETURN;
    END;

    CPRINT(saveprofile,"! ",JFNS(saveprofile,'111110000001),
	   " Created by ",DIRST(logdir)," on ",ODTIM(-1,-1),crlf);
    IF (loan!flag = 0)
	THEN CPRINT(saveprofile,"MORTGAGE",crlf)
	ELSE CPRINT(saveprofile,"LOAN ",loancom[loan!flag], crlf);
    i _ term DIV 12;
    j _ term MOD 12;
    CPRINT(saveprofile,"Principal     ",cv!num(principal,12),crlf);
    CPRINT(saveprofile,"Payment       ",cv!num(monthly!payment,12),crlf);
    CPRINT(saveprofile,"Interest      ",cv!num(yearly!interest*100.0,12,6),crlf);
    CPRINT(saveprofile,"Term          ",i," ",j,crlf);
    IF anniversary!payment>0 THEN
	CPRINT (saveprofile,
		"Anniversary   ",cv!num(anniversary!payment,12),
		" ",monthcom[anniversary!month],crlf);
    IF (starting!date NEQ get!date(GTAD)) AND (starting!date NEQ 0) 
	THEN
    CPRINT(saveprofile,"Starting-Date ",monthcom[nmod(starting!date,12)] & " "
	  & CVS((starting!date-1) DIV 12),crlf);

    IF ((start!pdate > 0) OR (END!pdate < infinity))
	THEN
	    IF (END!pdate = 0)
		THEN s _ "Summary"
		ELSE
		    BEGIN "somedate"
			s _ "Between ";
			IF (start!pdate = 0)
			    THEN s _ s & "First"
			    ELSE s _ s & PRINT!date(start!pdate);
			s _ s & " ";
			IF (END!pdate = infinity)
			    THEN s _ s & "Last"
			    ELSE s _ s & PRINT!date(END!pdate);
		    END "somedate"
	ELSE s _ "All";

    i _ GTJFN(outfile,1);

    IF (!skip! = 0) AND (i NEQ -1)
	THEN
	    BEGIN
		j _ DEVTYPE(i);
		IF (j=#dvlpt)
		    THEN CPRINT(saveprofile,"Output LPT",crlf)
		    ELSE IF (j=#dvtty)
			THEN CPRINT(saveprofile,"Output TTY",crlf)
			ELSE IF (j=#dvnul)
			    THEN CPRINT(saveprofile,"Output NUL",crlf)
			    ELSE CPRINT(saveprofile,"Output DSK",crlf);
		RLJFN(i);
    END;

    CPRINT(saveprofile,"Print ",s,crlf);
    CPRINT(saveprofile,IF roundoff!flag THEN "Roundoff" ELSE "Truncate",crlf);
    CPRINT(saveprofile,IF month!flag THEN "Monthly" ELSE "Daily",crlf);
    CPRINT(saveprofile,"Leap-Year ");
    IF (((days!in!year = 366) AND (NOT feb29!flag)) OR ((days!in!year = 365) AND feb29!flag))
	THEN CPRINT(saveprofile,
		    IF feb29!flag THEN "29" ELSE "28","-",days!in!year,
		    crlf)
	ELSE CPRINT(saveprofile,days!in!year,crlf);


    RELEASE(saveprofile,0);
END "savesettings"; ! BEGIN ;

!<<OUTPUT!HELP -- Outputs the help on the commands to the terminal.>>;

PROCEDURE output!help (INTEGER index (1));
BEGIN "Output!help"
    CASE index OF
	BEGIN "help"
	    ELSE PRINT("% No help available on subject.",crlf);

	 [1] PRINT( "The following commands are currently available:
	COMMANDS -- Types out this message.
	ANNIVERSARY -- Sets or deletes the anniversary payment.
	CALCULATE -- Either PAYMENT, SCHEDULE, or PRINCIPAL for the
		     amortization.
	DYNAMIC-INPUT -- Accepts an optional data file then enters
			 dynamic input mode.  If the data file is not
			 given, then dynamic mode is started
			 uninitialized.  In this mode data records may
			 be entered in the form of date and and
			 transaction.  A transaction may be one of an
			 amount paid, or DATE-CHANGE, INTEREST,
			 GENERATE, PRINCIPAL.
	EXIT -- Terminates this program. (Default if blank line is
		given).
	HELP -- Information on specific commands.
	INTEREST -- Sets the interest rate as a percentage.
	LEAP-YEAR -- (Invisible command) Sets the number of days in a
		     leap year, and the number of days in February.
	LOAN -- Specifies that the amortization is a loan.
	MORTGAGE -- Specifies that the amortization is a mortgage.
	OUTPUT -- Defines where the output from the schedule should go.
	PAYMENT -- Sets the monthly payment.
	PRINCIPAL -- Sets the amount of the amortization.
	PRINT -- Prints a specified subsection of the schedule.
	RESET -- Resets everything to the original state.
	ROUNDOFF -- (Invisible command) The amount of interest is
		 rounded to the nearest cent.
	SAVE -- Save the current settings in the given file.
	SHOW -- Show the current settings.
	STARTING-DATE -- Sets the starting month and year for the
		amortization.
	TAKE -- Take commands from the given file.
	TERM -- Defines the duration term of the amortization.
	TRUNCATE -- (Invisible command) The amount of interest is
		 rounded to the nearest cent.",crlf);	! Command;

	[2] PRINT( 
"The ANNIVERSARY command sets or cancels the amount of the
anniversary payment and when it is inserted into the schedule
calculation.  Giving 0 as an anniversary payment cancels its use.
The insertion month defaults to the month before the starting date.",
		  CRLF);		! "Anniversary";

	[3] PRINT(
"The CALCULATE command takes either PAYMENT, SCHEDULE, PRINCIPAL,
TERMINATION, or INTEREST as an argument.
	PAYMENT requires that the principal, yearly interest (as a
percentage), and the term be given.  The monthly payment is the returned
answer.
	PRINCIPAL requires that the payment, yearly interest and term be
given.  The starting principal is the returned answer.
	SCHEDULE requires that the principal, yearly interest, term, and
monthly payment (0 if unknown) be given.  It then proceeds to print the
schedule.
	TERMINATION requires that the principal, yearly interest, and
monthly payment be given.  This then return the duration of the
mortgage.
	INTEREST requirest that the principal, term, and monthly payment
be given.  The interest rate is returned as a percentage.",
		  crlf);			! "Calculate";
	[4] PRINT(
"The EXIT command terminates the program gracefully",crlf);	! "Exit";
	[5] BEGIN "Help"
	        PRINT("The HELP command has information on:",crlf,crlf);
		PRINT(list!keywords(helpcom,72,8));
            END "Help";
	[6] PRINT(
"The INTEREST command sets the interest rate for the amortization
calculations.",crlf);			! 6 "Interest";
	[7] PRINT(
"The LOAN command sets the program into loan calculation mode, which
implies different calculations than for MORTGAGES.  It takes an
optional argument specifying what type of loan calculations it will
make.  Typing a question mark will list which are valid.  UNKNOWN
implies that there are no special effects to be used.",crlf);	! 7 "Loan";
	[8] PRINT(
"The MORTGAGE command sets the program into mortgage calculation mode,
which implies different calculations than for LOANS.  The schedule
calculations are exact for the Toronto-Dominion Bank and the Royal Trust
Company (when using TRUNCATED schedule calculations).",crlf);	! 8 "Mortgage";
	[9] PRINT(
"The OUTPUT command redirects the output from the schedule calculations
to the desired device (DSK -- currently connected directory, LPT --
lineprinter, NUL -- no output, except for summary, TTY - your terminal)
or to some output file.",crlf);		! 9 "Output";
	[10] PRINT(
"The PAYMENT command sets (or recalculates, if given 0) the monthly
payment to the given value.",crlf);	! 10 "Payment";
	[11] PRINT(
"The PRINCIPAL command sets the amount of the mortgage or loan to the
given value.",crlf);			! 11 "Principal";
	[12] PRINT(
"The RESET command resets all the current values to the defaults.  The
principal, interest, anniversary payments, etc. are all set to zero.
the user's profile or init file is read if one exists.  The init file is
found on the user's login directory called ",PROGRAM!NAME,".INI",crlf);
		! 12 "Reset";
	[13] PRINT(
"The ROUNDOFF command sets the interest calculations to roundoff to the
nearest cent.  This command is invisible as the normal is to truncate to
the cent.",crlf);			! 13 "Roundoff";
	[14] PRINT(
"The SHOW command shows the values of all the different variables used
by the amortization program.",crlf);	! 14 "Show";
	[15] PRINT(
"The STARTING-DATE command sets the date of the first fixed payment for
the loan to the month and year given.",crlf);	! 15 "Starting-date";
	[16] PRINT(
"The TERM command sets the duration of the loan or mortgage to the given
number of years and months.",crlf);	! 16 "Term";
	[17] PRINT(
"The TRUNCATE command sets the interest calculations to truncate at the
cents.  This command is invisible as it is the normally used function.",
		   crlf);		! 17 "Truncate";
	[18] PRINT(
"The LEAP-YEAR command (invisible) sets up the mode of operation for
leap years.
The options are:
	365	365 days in the year and 28 days in February
	366	366 days in the year and 29 days in February
	29-365	365 days in the year and 29 days in February (Yech)
	28-366  366 days in the year and 28 days in February (Yech)",
		   crlf);

	[19] PRINT(
"The print command allows the user to print a subsection of the schedule
instead of the whole thing.  The commands are:
	PRINT All	Prints the complete schedule
	PRINT Between	Prints the schedule between the two given dates.
			The starting date may be either FIRST or a date
			and the ending date can be either LAST or a
			date.  The schedule will be printed between the
			two dates inclusive.
	PRINT Summary	Only the summary will be printed.",crlf);

	[20] PRINT(
"        SAVE will save the current settings in the specified file.  The
default is PS:<login directory>",PROGRAM!NAME,".INI.  Only those
functions that are different from the defaults set in the program are
written out. One commands that is always written out is:

	OUTPUT <device>		Where the output device is:
                                     DSK	for ANY DISK structure
                                     LPT	for the line printer
				     NUL	for the null device
				     TTY	for the terminal
				depending on the currently designated
				output file.

The user may change this with an editor after exiting the program.",crlf);
				! 20 SAVE;
	  [21] PRINT(
"        TAKE says to take a set of commands from the specified file.
The default file specs are DSK:<connected-directory>",PROGRAM!NAME,".CMD.",crlf);
				! 21 TAKE;
	  [22] PRINT (
"        DAYS calculates the absolute number of days between two dates.",crlf);
	  [23] print (
"        DYNAMIC-INPUT enters a mode whereby the user may give variable
payments keyed on the date of payment.  An optional
data file is requested when first entering this command.  The data file
contains records having a list of commands as typed during interactive
mode.  The following commands exist:

	Abort         - Exits this mode without saving the file, or
                        calculating the schedule.
	Calculate     - Calculates the schedule to TTY:.
	Exit          - Exits the mode normally.  This is the same as
                        typing a carriage return with no command on it.
	Save          - Saves the current status of dynamic mode into
                        the given filename.
	Show          - Shows the current commands given in dynamic
                        mode.

Also the following commands must be preceded by a transaction date:

	a payment amount - is the amount paid on that date.

	Date-Change   - Changes the date to the one given.  All other
                        commands from this point will be in reference to
                        this date.  This command must be the first one
                        in the command file or in interactive mode.  In
                        this case it sets the starting date for the
                        transactions.
	Generate      - Generates a set of fixed payments using the
                        transaction date as the starting point.  The
                        full command is 'date GENERATE payment N1 N2
                        PERIOD end-date', where N1 is the number of
                        payments to make in N2 PERIOD's, with PERIOD
                        being either DAY, WEEK, MONTH, or YEAR.  This
                        command then generates a set of transaction
                        dates and payments to correspond with this loop.
                        The GENERATE command is not saved, but all the
                        generated transactions will be if desired.
	Interest      - Changes the yearly interest to the one given.
                        If this is given between payments, the interest
                        is sum of the individual interest.
	Principal     - Changes the principal or the old capital to the
                        given value.

When this mode is exited, the user is prompted to save the file, and a
schedule is given automatically.",crlf);
	[24] PRINT(
"	DAILY specifies the method by which interest is calculated each
month.  Normal mortgages and loan interest is calculated at each payment
interval based on the number of days since the last payment. Another
form is MONTHLY, where each payment is equidistant from the other.",crlf);
	[25] PRINT(
"	MONTHLY specifies the method by which interest is calculated
each month.  This form specifies that each payment each month is just
one month, and there are 12 months to the year.  This mode should not be
used in Mortgage calculations as it does not reflect the Canadian
banking system.",crlf);
            [1000] BEGIN; END
    END "help";
END "Output!help";

!<<ODCNV -- returns the day, month, year, and day of week for a given date>>;
PROCEDURE odcnv(INTEGER idate; REFERENCE INTEGER iday,imonth,iyear,idow);
BEGIN "odcnv"
    INTEGER temp;
    temp _ 0;
    START!CODE "convert TO separate"
	move 2,idate;
	move 4,temp;
	jsys '222;		! ODCNV;
	hrrzm 2,imonth;
	hlrzm 2,iyear;
	hlrzm 3,iday;
	hrrzm 3,idow;
    END "convert TO separate"; ! START!CODE ;
    imonth _ imonth + 1;
    iday _ iday + 1;
    idow _ idow + 2;
    IF idow > 7 THEN idow _ idow - 7;	! Fix so sunday is 1;
END "odcnv"; ! BEGIN ;

!<<JUL!YEAR -- Returns the julian day for the given year.>>;
PROCEDURE jul!year(INTEGER idate; REFERENCE INTEGER iday,iyear);
BEGIN "jul!year"
    INTEGER temp;
    temp _ '040000000000;
    START!CODE "convert TO julian"
	move 2,idate;
	move 4,temp;
	jsys '222;		! ODCNV;
	hlrzm 2,iyear;
	hrrzm 2,iday;
    END "convert TO julian"; ! START!CODE ;
END "jul!year"; ! BEGIN ;

!<<DATE!DIFFERENCE -- Returns the difference in days of dt2-dt1>>;
INTEGER PROCEDURE date!difference (INTEGER dt1,dt2);
BEGIN "date!difference"
    INTEGER idt1, idt2, temp;
    INTEGER d1,d2,		! day;
	    y1,y2,		! year;
	    sum;		! Temporary sums;
    INTEGER i,j,k;

    idt1 _ dt1 LSH -18;
    idt2 _ dt2 LSH -18;

    IF (idt1 > idt2)
	then
	    BEGIN
		idt1 SWAP idt2;
		dt1 SWAP dt2;
	    END;
    sum _ idt2 - idt1;
    IF feb29!flag THEN RETURN(sum);
    jul!year(dt1,d1,y1);
    jul!year(dt2,d2,y2);
    IF d1 LEQ 59 THEN j _ y1 ELSE j _ y1+1;
    IF d2 > 59 THEN k _ y2 ELSE k _ y2-1;
!     PRINT("Date 1 (Day Year Y1)",d1," ",y1," ",j,crlf);
!     PRINT("Date 2 (Day Year Y2)",d2," ",y2," ",k,crlf);
    IF j > k THEN RETURN(sum);
    FOR i _ j upto k DO IF leap!year(i) THEN sum _ sum - 1;
    RETURN (sum);
END "date!difference";


!		Main program really starts here;
BEGIN "Main Program"
    INTEGER ARRAY help!comm[1:cm!size(helpcom)];
    INTEGER ARRAY yesno!comm[1:cm!size(yesnocom)];
    INTEGER ARRAY top!comm[1:cm!size(topcom)];
    INTEGER ARRAY loan!comm[1:cm!size(loancom)];
    INTEGER ARRAY output!comm[1:cm!size(outputcom)];
    INTEGER ARRAY calculate!comm[1:cm!size(calculatecom)];
    INTEGER ARRAY dynamic!comm[1:cm!size(dynamiccom)];
    INTEGER ARRAY period!comm[1:cm!size(periodcom)];
    INTEGER ARRAY periods!comm[1:cm!size(periodscom)];
    INTEGER ARRAY month!comm[1:cm!size(monthcom)];
    INTEGER ARRAY leap!comm[1:cm!size(leapcom)];
    INTEGER ARRAY print!comm[1:cm!size(printcom)];
    INTEGER ARRAY sprint!comm[1:cm!size(sprintcom)];
    INTEGER ARRAY eprint!comm[1:cm!size(eprintcom)];
    INTEGER ARRAY flag!comm[1:cm!size(flagcom)];

!<<DYNAMIC!INPUT -- The dynamic input subcommand is handled here.>>;
REAL PROCEDURE dynamic!input (INTEGER file!chan (0);
			 BOOLEAN roundflag (FALSE);
			 REAL principal (0.0), yint (0.0),
			 mpay (0.0); INTEGER term (0), loanflag (0));
BEGIN "dynamic!input"
    BOOLEAN file!flag, ctrl!h!off, saved!flag;
    INTEGER acount;		! Position counter into the array;
    INTEGER ARRAY ddays[1:MAX!array!size];
    INTEGER ARRAY drec!date[0:MAX!ARRAY!SIZE];
    REAL ARRAY drec!pay[0:MAX!ARRAY!SIZE];
    INTEGER ARRAY drec!flag[0:MAX!ARRAY!SIZE];
    INTEGER idate,datem;		! Temporary variables used IN the loop;
    INTEGER whichcom,j;
    REAL old!yint,xpay,initial!principal, carry!interest, default!pay;
    INTEGER start!date,END!date,frequency,interval,mode;

!<<SET!DYNAMIC!PAGE!HEADER -- Creates the page header for dynamic calculate schedule.>>;

PROCEDURE set!dynamic!page!header;
BEGIN "set!dynamic!page!header"
    page!header _ "Dynamic ";
    page!header _ page!header & loan!type[loanflag] & " Table  (Pv="; ! );
    page!header _ page!header & cv!num(principal);
    page!header _ Page!header & ", i=" & cv!num(yint*100.0,0,4) & "%, ";
    page!header _ page!header & "Lp=" & cv!int(days!in!year);
    page!header _ page!header & ")  Page ";
END "set!dynamic!page!header"; ! BEGIN ;

!<<CALCULATE!DYNAMIC -- Calculates the dynamic schedule.>>;

REAL PROCEDURE calculate!dynamic(REAL iprinc; STRING outfile);
BEGIN "calculate!dynamic"
    STRING sdate,line;

    REAL  mint,
	    savings,yearly!savings,total!savings,
	    calendar!savings,
	    total!paid, total!interest, total!payment, remainder,
	    yearly!paid, yearly!interest, yearly!payment,
	    calendar!paid, calendar!interest, calendar!payment,
	    old!capital,cpay,
	    current!capital, current!payment, current!interest,
	    monthly!paid, monthly!interest;

    INTEGER REAL!date, mortgage!year, pntr, REAL!month,REAL!year,
	    index,i,j,k,l,m,n,
	    header!done,
	    dev!type,
	    old!year,
	    ndays,
	    line!count,
	    last!pntr,
	    page!count;

INTEGER PROCEDURE output!dynamic!line (STRING aprefix(null),
				       adate(null),
				       aday(null),
				       aoldcap(null),
				       apay(null),
				       aint(null),
				       aapay(null),
				       aloan(null),
				       anew(null));
BEGIN "output!dynamic!line"
    IF (EQU(aprefix,NULL)) THEN aprefix _ "  ";
    IF (EQU(adate,null)) THEN adate _ eleven!spaces;
    IF (EQU(aday,null)) THEN aday _ four!spaces;
    IF (EQU(aoldcap,null)) THEN aoldcap _ eleven!spaces;
    IF (EQU(apay,null)) THEN apay _ eleven!spaces;
    IF (EQU(aint,null)) THEN aint _ eleven!spaces;
    IF (EQU(aapay,null)) THEN aapay _ eleven!spaces;
    IF (EQU(aloan,NULL) AND (loan!flag = drea)) THEN aloan _ "     ";

    CPRINT(ochan,aprefix,adate,
	   " ",aday,
	   " ",aoldcap,
	   " ",apay,
	   " ",aint,
	   " ",aapay,
	   IF (LENGTH(aloan) > 0) THEN " " & aloan ELSE NULL,
	   IF (LENGTH(anew) > 0) THEN " " & anew ELSE NULL,
	   crlf);
    RETURN(1);
END "output!dynamic!line"; ! BEGIN ;

INTEGER PROCEDURE output!line!header(INTEGER xdate(0); REAL xprinc(0.0));
BEGIN "output!line!header"
    INTEGER ii;
    CPRINT(ochan,crlf);
    ii _ 1 + output!dynamic!line(NULL,
				  "   Date    ",
				  "Days",
				  "  Old Value",
				  "    Payment",
				  "   Interest",
				  " Actual Pay",
				  IF (loanflag = drea) THEN "  S/A" ELSE NULL,
				  "  New Value");
    IF (xdate LEQ 0) THEN RETURN (ii);
    ii _ ii + output!dynamic!line(NULL,ODTIM(xdate,'010400000000),
				  NULL,NULL,NULL,NULL,NULL,NULL,
				  cv!num(xprinc,11));
    RETURN (ii);
END "output!line!header"; ! BEGIN ;

INTEGER PROCEDURE output!header(INTEGER xdate; REAL xprinc; BOOLEAN noskip (FALSE));
BEGIN "output!header"
	CPRINT(ochan,
	       IF noskip THEN page!header ELSE IF (dev!type NEQ #dvtty) THEN ff & page!header ELSE page!header,
	       page!count _ page!count + 1,
	       IF roundflag THEN " R" ELSE " T",
	       crlf);
	RETURN (2 + output!line!header(xdate,xprinc));
END "output!header"; ! BEGIN ;

INTEGER PROCEDURE output!calendar!summary (BOOLEAN xflag (TRUE));
BEGIN "output!calendar!summary"
    INTEGER jj;
    IF ((line!count+6) > 55)
	THEN line!count _ output!header(drec!date[pntr-1],old!capital);
    jj _ output!dynamic!line(NULL,NULL,NULL,NULL,
			     "-----------",
			     "-----------",
			     "-----------",
			     IF (loanflag = drea) THEN "-----" ELSE NULL,NULL);
    jj _ jj + output!dynamic!line(NULL,
				  " Year "&cv!int(old!year,4)&" ",
				  NULL,
				  NULL,
				  cv!num(calendar!paid,11),
				  cv!num(calendar!interest,11),
				  cv!num(calendar!payment,11),
				  IF (loanflag = drea) THEN cv!num(calendar!savings,5) ELSE NULL,
				  "  Year "&cv!int(old!year,4));
    calendar!paid _ calendar!interest _ calendar!payment _ 0.0;
    calendar!savings _ 0.0;
    old!year _ REAL!year;
    IF (NOT xflag)
	THEN RETURN (line!count + jj)
	ELSE RETURN (line!count + jj + output!line!header);
END "output!calendar!summary"; ! BEGIN ;

    yint _ old!yint;

    principal _ iprinc;

    IF ((principal LEQ 0) OR (yint LEQ 0) OR acount LEQ 0) THEN RETURN(iprinc);

    IF mpay LEQ 0
	THEN mpay _ calculate!payment (principal, yint, term, loanflag);

    IF (starting!date = 0) THEN RETURN(iprinc);

    ochan _ OPEN!out(outfile);

    dev!type _ DEVTYPE(ochan);

    IF (dev!type NEQ #dvtty)
	THEN PRINT("Calculating Dynamic Schedule ...",crlf);

    SET!dynamic!page!header;
    page!count _ 0;
    line!count _ infinity - 10;
    last!pntr _ 0;

    old!year _ (get!date(drec!date[0]) - 1) DIV 12;

    total!savings _ total!paid _ total!interest _ total!payment _ 0.0;
    savings _ remainder _ 0.0;

    calendar!savings _ calendar!paid _ calendar!interest _ calendar!payment _ 0.0;
    current!capital _ principal;
    pntr _ 0;
    carry!interest _ 0.0;

    WHILE (pntr < acount) DO
	BEGIN "schedule calculation"
	    old!capital _ current!capital;
	    IF (old!capital LEQ 0.0) THEN DONE "schedule calculation";
	    pntr _ pntr + 1;
	    REAL!date _ (get!date(drec!date[pntr]) - 1);
	    REAL!year _ (REAL!date - 1) DIV 12;

	    ndays _ date!difference(drec!date[pntr - 1],drec!date[pntr]);

	    IF (drec!flag[pntr] NEQ 0)
		THEN
		    BEGIN "Adjustments"
			CASE drec!flag[pntr] OF
			    BEGIN
				[flag!date] BEGIN "Date"
				    current!capital _ old!capital;
				    IF (line!count > 55)
					THEN line!count _ output!header(drec!date[pntr-1],
									old!capital);
				    IF old!year NEQ REAL!year
					THEN line!count _ output!calendar!summary;

				    line!count _ line!count
				      + output!dynamic!line("* ",
					     ODTIM(drec!date[pntr],'010400000000),
					     cv!int(ndays,4),
					     NULL, NULL, NULL, NULL, NULL,
					     cv!num(current!capital,11));

				    carry!interest _ 0.0;
				    last!pntr _ pntr;
				END "Date"; ! BEGIN ;

				[flag!principal] BEGIN "Principal"
				    current!capital _ drec!pay[pntr];
				    IF (line!count > 55)
					THEN line!count _ output!header(drec!date[pntr-1],
									old!capital);
				    IF old!year NEQ REAL!year
					THEN line!count _ output!calendar!summary;

				    line!count _ line!count
				      + output!dynamic!line("* ",
					     ODTIM(drec!date[pntr],'010400000000),
					     cv!int(ndays,4),
					     cv!num(old!capital,11),
					     NULL, NULL, NULL, NULL,
					     cv!num(current!capital,11));

				    carry!interest _ 0.0;
				    last!pntr _ pntr;
				END "Principal"; ! BEGIN ;

				[flag!interest] BEGIN "Interest"
				    current!interest _ dynamic!interest(old!capital,yint,
									ndays,loanflag,
									roundflag);

				    IF (line!count > 55)
					THEN line!count _ output!header(drec!date[pntr-1],
									old!capital);
				    IF old!year NEQ REAL!year
					THEN line!count _ output!calendar!summary;

				    line!count _ line!count + 1;

				    CPRINT (ochan,"* ",
					    ODTIM(drec!date[pntr],'010400000000),
					    " ",cv!int(ndays,4),
					    " Interest rate changed from ",
					    cv!num(yint*100.0,0,4),"% to ",
					    cv!num(drec!pay[pntr]*100.0,0,4),
					    "% ",IF (yint<0.10) THEN " " ELSE NULL,
					    IF (drec!pay[pntr] < 0.10) THEN " " ELSE NULL,
					    cv!num(current!capital,11),
					    crlf);

				    carry!interest _ carry!interest + current!interest;
				    yint _ drec!pay[pntr];
				    SET!dynamic!page!header;
				    last!pntr _ pntr;
				END "Interest"
			    END;
			CONTINUE "schedule calculation";
		    END "Adjustments"; ! BEGIN ;

	    current!interest _ dynamic!interest(old!capital,yint,
						ndays,loanflag,
						roundflag);
	    cpay _ drec!pay[pntr];

	    IF (loanflag = drea)
		THEN
		    BEGIN
			current!payment _ cpay - (current!interest + carry!interest);
			savings _ ((current!payment*100.00) MOD 100) / 100.0;
			current!payment _ current!payment - savings;
		    END
		ELSE
		    BEGIN
			current!payment _ cpay - (current!interest + carry!interest);
			savings _ 0.0;
		    END;
	    
	    IF (current!payment > old!capital)
		THEN
		    BEGIN
			cpay _ (current!interest + carry!interest) + old!capital;
			current!payment _ old!capital;
			current!capital _ 0.0;
			savings _ 0.0;
		    END
		ELSE current!capital _ old!capital - current!payment;

	    total!interest _ total!interest + (current!interest + carry!interest);
	    total!paid _ total!paid + cpay;
	    total!payment _ total!payment + current!payment;
	    total!savings _ total!savings + savings;

	    
	    IF (PRINT!ok(REAL!date)) THEN
		BEGIN "PRINT information"
		    IF (line!count > 55)
			THEN line!count _ output!header(drec!date[pntr-1],
							old!capital);
		    IF old!year NEQ REAL!year
			THEN line!count _ output!calendar!summary;

		    calendar!interest _ calendar!interest + (current!interest + carry!interest);
		    calendar!paid _ calendar!paid + cpay;
		    calendar!payment _ calendar!payment + current!payment;
		    calendar!savings _ calendar!savings + savings;

		    line!count _ line!count
		       + output!dynamic!line(NULL,
					     ODTIM(drec!date[pntr],'010400000000),
					     cv!int(ndays,4),
					     cv!num(old!capital,11),
					     cv!num(cpay,11),
					     cv!num(current!interest+carry!interest,11),
					     cv!num(current!payment,11),
					     IF (loanflag = drea)
					      THEN cv!num(savings,5) ELSE NULL,
					     cv!num(current!capital,11));

		    carry!interest _ 0.0;
		    last!pntr _ pntr;

		END "PRINT information";
	END "schedule calculation";

    IF (last!pntr NEQ 0)
	THEN
	    BEGIN
		pntr _ pntr + 1;
		old!capital _ current!capital;
		line!count _ output!calendar!summary(FALSE);
	    END;

    ndays _ date!difference(drec!date[0],drec!date[acount]);
    i _ ndays DIV 365;
    j _ ndays MOD 365;

    PRINT(IF (current!capital NEQ 0) THEN "% " ELSE NULL,
	  "The ",IF (loanflag NEQ mortgage) THEN "loan " ELSE "mortgage ",
	  "was ",
	  IF(current!capital NEQ 0) THEN "NOT " ELSE NULL,
	  "paid after ",i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
	  " and ",j," day",IF (j NEQ 1) THEN "s" ELSE NULL,".",crlf);

    IF (dev!type NEQ #dvnul)
	THEN
	    BEGIN
		CPRINT(ochan,
		       IF (dev!type NEQ #dvtty) THEN ff & page!header
		           ELSE page!header,
		       page!count _ page!count + 1,
		       IF roundflag THEN " R" ELSE " T",
		       crlf,crlf,crlf);
		CPRINT(ochan,"    Final Totals after ",
		       i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
		       " and ",j," day",IF (j NEQ 1) THEN "s" ELSE NULL,
		       ".",crlf,crlf);
		CPRINT(ochan,
		       "	Interest   = ",cv!num(total!interest,11),crlf,
		       "	Repayment  = ",cv!num(total!payment,11),crlf,
		       "	Remainder  = ",cv!num(current!capital,11),crlf,
		       "	              ----------",crlf,
		       "	Total        ",
		       cv!num(total!interest+total!payment+current!capital,11),
		       crlf,
		       IF (loanflag = drea) THEN
		       crlf & "	On Account = " & cv!num(total!savings,11)
		       ELSE null,crlf);
	    END
	ELSE
	    BEGIN
		PRINT(crlf,"    Final Totals after ",
		      i," year",IF (i NEQ 1) THEN "s" ELSE NULL,
		      " and ",j," day",IF (j NEQ 1) THEN "s" ELSE NULL,
		      ".",crlf,crlf);
		PRINT(
		      "	Interest   = ",cv!num(total!interest,11),crlf,
		      "	Repayment  = ",cv!num(total!payment,11),crlf,
		      "	Remainder  = ",cv!num(current!capital,11),crlf,
		      "	              -----------",crlf,
		      "	Total        ",
		      cv!num(total!interest+total!payment+current!capital,11),
		      crlf,
		      IF (loanflag = drea) THEN
		      crlf & "	On Account = " & cv!num(total!savings,11)
		      ELSE null,crlf);
	    END;

    CLOSE!out(ochan);
    RETURN (current!capital);
END "calculate!dynamic"; ! BEGIN ;

!<<SHOW!DYNAMIC -- Shows the currently defined dynamic transactions.>>;
PROCEDURE show!dynamic;
BEGIN "show!dynamic"
    IF (acount=-1) THEN RETURN;
    PRINT ("   Date     Payment",crlf,
	   "--------- ----------",crlf);
    PRINT (CRLF);

    FOR i _ 0 upto acount DO
	IF (drec!flag[i] = 0)
	    THEN PRINT (ODTIM(drec!date[i],datem)," ",cv!num(drec!pay[i],10),crlf)
	    ELSE 
		BEGIN
		    PRINT (ODTIM(drec!date[i],datem),
			   spaces[1 FOR 12],
			   flagcom[drec!flag[i]],
			   " ");
		    CASE drec!flag[i] OF BEGIN
			
			[flag!date] PRINT (crlf);
			[flag!interest] PRINT (cv!num(drec!pay[i]*100.0),"%",crlf);
			[flag!principal] PRINT (cv!num(drec!pay[i]),crlf)
		    END;
		END; ! BEGIN ;

    PRINT (crlf);
END "show!dynamic"; ! BEGIN ;

!<<SAVE!DYNAMIC -- Saves the currently defined dynamic transactions.>>;
PROCEDURE save!dynamic;
BEGIN "save!dynamic"
    INTEGER saveprofile;
    IF (acount=-1) THEN RETURN;
    saveprofile _ OPENFILE (saveprofile!name, "WE");

    IF (!skip! NEQ 0) OR (saveprofile=-1)
	THEN
	    BEGIN
		IF show!errors
		    THEN PRINT("%  Cannot open file ",saveprofile!name, crlf);
		RETURN;
    END;
    PRINT("Saving ",acount,IF acount NEQ 1 THEN " entry in " ELSE " entries in ",
	  JFNS(saveprofile,'111110000001),".",crlf);

    CPRINT(saveprofile,"! ",JFNS(saveprofile,'111110000001),
	   " Created by ",DIRST(logdir)," on ",ODTIM(-1,0),crlf);
    FOR i _ 0 upto acount DO
	IF (drec!flag[i] = 0)
	    THEN CPRINT (saveprofile,ODTIM(drec!date[i],datem)," ",cv!num(drec!pay[i],10),crlf)
	    ELSE 
		BEGIN
		    CPRINT (saveprofile,ODTIM(drec!date[i],datem)," ",flagcom[drec!flag[i]],
			   " ");
		    CASE drec!flag[i] OF BEGIN
			
			[flag!date] CPRINT(saveprofile, crlf);
			[flag!interest] CPRINT (saveprofile,cv!num(drec!pay[i]*100.0),crlf);
			[flag!principal] CPRINT (saveprofile,cv!num(drec!pay[i]),crlf)
		    END;
		END; ! BEGIN ;

    RELEASE(saveprofile,0);
    saved!flag _ TRUE;
    RETURN;
END "save!dynamic"; ! BEGIN ;

!<<EXIT!DYNAMIC -- exits dynamic mode, offering to save the transactions, and write out a schedule.>>;
REAL PROCEDURE exit!dynamic;
BEGIN "exit!dynamic"
    BOOLEAN ctrl!h!off;
    ctrl!H!off _ TRUE;
    IF NOT saved!flag
	THEN WHILE TRUE DO
	    BEGIN "outerloop"
		IF take!flag AND cm!eof THEN RETURN(initial!principal);
		IF take!flag
		    THEN cm!ini(NULL,ctrl!h!off)
		    ELSE cm!ini(IF not!rescan THEN "Save the dynamic data? "  ELSE NULL, ctrl!H!off);
		NOT!rescan _ TRUE;
		ctrl!H!off _ FALSE;
		WHILE TRUE DO
		    BEGIN "innerloop"
			INTEGER i;
			i _ cm!key(yesno!comm,NULL,"Yes");
			check1;
			cm!cfm;
			check1;
			IF i=1 THEN 
			    BEGIN
				saveprofile!name _ program!name & ".DAT";
				save!dynamic;
			    END; ! BEGIN ;
			DONE "outerloop";
		    END "innerloop"; ! BEGIN ;
		ctrl!H!off _ true;
	    END "outerloop"; ! BEGIN ;
    principal _ calculate!dynamic(initial!principal,outfile);
    PRINT (" Principal:  Open ($",cv!num(initial!principal),")  Close ($",
           cv!num(principal),").",crlf);
    RETURN (principal);
END "exit!dynamic"; ! BEGIN ;

!<<CREATE!TRANSACTION -- Creates an entry into the transaction matrix for later use.>>;
PROCEDURE create!transaction (INTEGER idate,iflag; REAL xpay);
BEGIN "create!transaction"
    acount _ acount + 1;

    IF acount > MAX!ARRAY!SIZE
	THEN 
	    BEGIN
		PRINT (ODTIM(idate,datem)," ",
		       IF (iflag NEQ 0) THEN flagcom[iflag] & " " ELSE NULL,
		       IF (iflag NEQ flag!date) THEN cv!num(xpay) ELSE NULL,
		       " exceeds internal array size.", crlf);
		 RETURN;
	    END;

    saved!flag _ FALSE;
    drec!date[acount] _ idate;
    IF (iflag = flag!interest) THEN drec!pay[acount] _ xpay/100.0 ELSE drec!pay[acount] _ xpay;
    IF ((iflag = 0) AND (xpay > 0.0)) THEN default!pay _ xpay;
    drec!flag[acount] _ iflag;

END "create!transaction"; ! BEGIN ;

!<<GET!DYNAMIC!COMMANDS -- Command loop parser for dynamic input mode.>>;
PROCEDURE get!dynamic!commands;
BEGIN "get!dynamic!commands"
    INTEGER iflag;
    ctrl!H!off _ TRUE;
    WHILE TRUE DO
	BEGIN "outer command loop"
	    IF FILE!flag AND cm!eof THEN
		BEGIN
		    RELEASE(file!chan);
		    file!flag _ FALSE;
		    saved!flag _ TRUE;
		    CONTINUE "outer command loop";
		END;
	    IF take!flag AND cm!eof THEN RETURN;
	    IF FILE!flag OR take!flag
		THEN cm!ini(NULL,ctrl!h!off)
		ELSE cm!ini(IF not!rescan THEN loan!type[loan!flag] & " Dynamic Input> "  ELSE NULL, ctrl!H!off);
	    NOT!rescan _ TRUE;
	    ctrl!H!off _ FALSE;
	    WHILE TRUE DO
		BEGIN "inner command loop"
		    INTEGER i,j,k;
		    REAL x;
		    cm#reset;
		    cm#tad("Transaction date",TRUE,TRUE,false);
		    cm#key(dynamic!comm);
		    cm#cfm("confirm to exit",TRUE);
		    i _ cm#call(NULL,TRUE,FALSE,TRUE);
		    check;
		    IF i=3
			THEN
			    IF FILE!flag
				THEN CONTINUE "outer command loop"
				ELSE RETURN;
		    IF take!flag AND cm!eof THEN RETURN;
		    IF FILE!flag AND cm!eof THEN
			BEGIN
			    RELEASE(file!chan);
			    file!flag _ FALSE;
			    saved!flag _ TRUE;
			    CONTINUE "outer command loop";
			END;

		    IF i=2
			THEN 
			    BEGIN "keywords"
				whichcom _ cm#int;
				CASE whichcom OF
				    BEGIN "which command"
					;
					BEGIN "Abort"
					    cm!noi("dynamic input level");
					    cm!cfm;
					    check;
					    acount _ -1;
					    saved!flag _ true;
					    RETURN;
					END "Abort";
					BEGIN "calculate"
					    REAL x;
					    STRING sx;
					    cm!noi("current schedule to TTY:");
					    cm!cfm;
					    x _ calculate!dynamic(initial!principal,"TTY:");
					    PRINT (" Principal:  Open ($",
					           cv!num(initial!principal),
						   ")  Close ($",
						   cv!num(x),
						   ").",crlf);
					    check;
					END "calculate"; ! BEGIN ;
					BEGIN "exit"
					    cm!noi("dynamic input level and update");
					    cm!cfm;
					    check;
					    return
					END "exit"; ! BEGIN ;
					BEGIN "save"
					    cm!noi("dynamic settings in");
					    index _ cm!fil(NULL,program!name&".dat",'440006000000);
					    check;
					    saveprofile!name _ JFNS(index,'111110000001);
					    RELEASE(index,0);
					    cm!cfm;
					    check;
					    save!dynamic;
					END "save";
					BEGIN "show"
					    cm!noi("the current settings");
					    cm!cfm;
					    check;
					    show!dynamic;
					END "show";

				    END "which command"; ! BEGIN ;
				DONE "inner command loop";
			    END "keywords"; ! BEGIN ;


		    idate _ cm#int;

		    cm#reset;
		    cm#flt("Payment amount",true);
		    cm#key(flag!comm);
		    k _ cm#CALL(cv!num(default!pay));
		    check;
		    IF (k = 1) THEN iflag _ 0 ELSE iflag _ cm#int;
		    CASE iflag OF
			BEGIN "Adjustment commands"
			    [0] BEGIN "Normal"
				xpay _ cm#REAL;
				cm!cfm;
				check;
			    END "Normal"; ! BEGIN ;
			    [flag!date] BEGIN "date"
				cm!noi ("change for calculations");
				cm!cfm;
				xpay _ 0.0;
				check;
			    END "date"; ! BEGIN ;

			    [flag!interest] BEGIN "interest"
				cm!noi(IF (loan!flag NEQ mortgage)
				       THEN "rate for the loan is"
				       ELSE "rate for the mortgage is");
				xpay _ cm!flt("Interest as a percentage",
					      CV!NUM(yearly!interest*100.0,0,5),TRUE);
				check;
				cm!cfm;
				check;
				IF (xpay<0)
				    THEN
					BEGIN
					    PRINT("% Illegal interest rate given.",crlf);
					    DONE "inner command loop";
					END;
			    END "interest"; ! BEGIN ;

			    [flag!principal] BEGIN "principal"
			         cm!noi("of");
				 xpay _ cm!flt(IF (loan!flag NEQ mortgage)
					       THEN "Amount of the loan"
					       ELSE "Amount of the mortgage",
					       CV!NUM(principal),TRUE);
				 check;
				 cm!cfm;
				 check;
				 IF (x < 0) THEN
				     BEGIN
					 PRINT("% Illegal number given.",crlf);
					 DONE "inner command loop";
				     END;
			    END "principal";

			    [flag!generate] BEGIN "generate"
			         start!date _ idate;
			         cm!noi("periodic payments of");
			         xpay _ cm!flt("Amount of payment");
				 check;
				 cm!noi("every");
				 frequency _ cm!num("How many times in interval",
						   "1");
				 check;
				 cm!noi("times in");
				 interval _ cm!num("Number of time increments",
						   "1");
				 check;
				 IF (interval NEQ 1)
				     THEN mode _ cm!key(periods!comm,
							NULL,"Months")
				     ELSE mode _ cm!key(period!comm,
							NULL,"Month");
				 check;
				 cm!noi("ending");
				 END!date _ cm!tad("Termination date",NULL,TRUE,TRUE,NULL);
				 check;
				 cm!cfm;
				 check;
				 IF (frequency LEQ 0) OR (interval LEQ 0)
				     then
					 BEGIN
					     PRINT(" Number given must be positive",crlf);
					     DONE "inner command loop";
					 END; ! BEGIN ;

				 IF (start!date LSH -18) > (END!date LSH -18)
				     THEN
					 BEGIN
					     PRINT(" Start date is after termination date",crlf);
					     DONE "inner command loop";
					 END; ! BEGIN ;

			    END "generate"

			END "Adjustment commands"; ! BEGIN ;

		    IF (acount = -1)
			THEN
			    BEGIN
				IF (iflag NEQ flag!date)
				    THEN 
					BEGIN
					    PRINT (ODTIM(idate,datem)," ",
						   IF (iflag NEQ 0) THEN flagcom[iflag] & " " ELSE NULL,
						   IF (iflag NEQ flag!date) THEN cv!num(xpay) ELSE NULL,
						   " given BEFORE a 'somedate DATE-CHANGE'",
						   crlf,
						   "% somedate DATE-CHANGE must the FIRST command",crlf);
					    DONE "inner command loop";
					END;
			    END
			ELSE 	
			    BEGIN 
				IF (((idate LSH -18) < (drec!date[acount] LSH -18)) AND (iflag NEQ flag!date))
				    THEN 
					BEGIN
					    PRINT (ODTIM(idate,datem)," ",
						   IF (iflag NEQ 0) THEN flagcom[iflag] & " " ELSE NULL,
						   IF (iflag NEQ flag!date) THEN cv!num(xpay) ELSE NULL,
						   " is not in ascending order",crlf);
					    DONE "inner command loop";
					END;
				IF ((iflag=0 OR iflag=flag!generate) AND (xpay < 0.0))
				    THEN 
					BEGIN
					    PRINT (ODTIM(idate,datem)," ",
						   IF (iflag NEQ 0) THEN flagcom[iflag] & " " ELSE NULL,
						   IF (iflag NEQ flag!date) THEN cv!num(xpay) ELSE NULL,
						   " has a negative payment",crlf);
					    DONE "inner command loop";
					END;

				IF (iflag=flag!generate) AND (frequency > MAX!array!size)
				    THEN
					BEGIN
					    PRINT (" Frequency exceeds maximum array size of ",MAX!array!size,
						   ".",crlf);
					    DONE "inner command loop";
					END; ! BEGIN ;

				IF (iflag=flag!generate)
				    THEN 
					CASE mode OF
					    BEGIN "modes"
						[mode!day] IF (frequency > interval)
						               THEN BEGIN PRINT ("Generate frequency greater than interval",
									   " specified",crlf);
							       DONE "inner command loop";
							       END;
						[mode!week] IF (frequency > (7 * interval))
						               THEN BEGIN PRINT ("Generate frequency greater than interval",
									   " specified",crlf);
							       DONE "inner command loop";
							       END;
						[mode!month] begin
							      INTEGER iday,imonth;
							      INTEGER iyear,idow;
							      INTEGER ndays;
							      odcnv(start!date,iday,imonth,iyear,idow);
							      IF (frequency > (28 * interval))
						               THEN BEGIN PRINT ("Generate frequency greater than interval",
									   " specified",crlf);
							       DONE "inner command loop";
							       END;
							     IF (iday > 28)
								 THEN
								     BEGIN
									 PRINT("% Problems will occur with day > number of days in February.",
									       crlf ,"% Choose a different date.",crlf);
									 DONE "inner command loop";
								     END;
							     END;
						[mode!year] IF (frequency > (365 * interval))
						               THEN BEGIN PRINT ("Generate frequency greater than interval",
									   " specified",crlf);
							       DONE "inner command loop";
							       END
					    END "modes"; ! BEGIN ;
			    END; ! BEGIN ;
			IF (iflag NEQ flag!generate)
			    THEN create!transaction(idate,iflag,xpay)
			    ELSE 
				BEGIN "generate table"
				    INTEGER times, remainder,stepsize,newdate,lastdate;
				    CASE mode OF
					BEGIN "mode generate"
					    [mode!day] 
					      BEGIN "day"
						  times _ interval DIV frequency;
						  remainder _ interval MOD frequency;
						  FOR i _ 1 upto frequency  DO ddays[i] _ times;
						  IF (remainder > 0)
						      THEN
							  FOR i _ 1 upto remainder
							      DO ddays[i] _ ddays[i] + 1;
						  i _ 0;
						  newdate _ start!date;
						  WHILE ((newdate LSH -18) LEQ (END!date LSH -18))
						      DO 
							  BEGIN "create entries"
							      create!transaction(newdate,0,xpay);
							      i _ i + 1;
							      IF (i>frequency) THEN i _ i - frequency;
							      lastdate _ newdate;
							      newdate _ newdate + (ddays[i] LSH 18);
							      IF (date!difference(lastdate,newdate) NEQ ddays[i])
								  THEN newdate _ newdate + '1000000;	! add a day;
							  END "create entries"; ! BEGIN ;

					      END "day";

					    [mode!week]
					      BEGIN "week"
						  interval _ interval * 7;
						  times _ interval DIV frequency;
						  remainder _ interval MOD frequency;
						  FOR i _ 1 upto frequency  DO ddays[i] _ times;
						  IF (remainder > 0)
						      THEN
							  FOR i _ 1 upto remainder
							      DO ddays[i] _ ddays[i] + 1;
						  i _ 0;
						  newdate _ start!date;
						  WHILE ((newdate LSH -18) LEQ (END!date LSH -18))
						      DO 
							  BEGIN "create entries"
							      create!transaction(newdate,0,xpay);
							      i _ i + 1;
							      IF (i>frequency) THEN i _ i - frequency;
							      lastdate _ newdate;
							      newdate _ newdate + (ddays[i] LSH 18);
							      IF (date!difference(lastdate,newdate) NEQ ddays[i])
								  THEN newdate _ newdate + '1000000;	! add a day;
							  END "create entries"; ! BEGIN ;
					
					      END "week";

					    [mode!month]
					      BEGIN "month"
						  INTEGER future!date;
						  i _ 0;
						  newdate _ start!date;
						  WHILE ((newdate LSH -18) LEQ (END!date LSH -18))
						      DO 
							  BEGIN "create entries"
							      create!transaction(newdate,0,xpay);
							      i _ i + 1;
							      IF (i>frequency) THEN i _ i - frequency;
							      IF (i = 1)
								  THEN
								      BEGIN "update date matrix"
									  INTEGER iday,imonth;
									  INTEGER iyear,idow;
									  INTEGER ndays;
									  odcnv(newdate,iday,imonth,iyear,idow);
									  future!date _ newdate;
									  ndays _ 0;
									  FOR j_0 upto interval-1 DO
									      BEGIN
										  k _ imonth + j;
										  IF (k > 12) THEN k _ k - 12;
										  future!date _ future!date + (day!month[k] LSH 18);
										  ndays _ ndays + day!month[k];
									      END; ! BEGIN ;

									  IF (date!difference(newdate,future!date) NEQ ndays)
									      THEN future!date _ future!date + '1000000;

									  times _ ndays DIV frequency;
									  remainder _ ndays MOD frequency;
									  FOR j _ 1 upto frequency
									      DO ddays[j] _ times;
									      IF (remainder > 0)
										  THEN
										      FOR j _ 1 upto remainder
											  DO ddays[j] _ ddays[j] + 1;

								      END "update date matrix"; ! BEGIN ;
							      lastdate _ newdate;
							      newdate _ newdate + (ddays[i] LSH 18);
							      IF (date!difference(lastdate,newdate) NEQ ddays[i])
								  THEN newdate _ newdate + '1000000;	! add a day;

							  END "create entries"; ! BEGIN ;
					      END "month";

					    [mode!year] 
					      BEGIN "year"
						  interval _ interval * 365;
						  times _ interval DIV frequency;
						  remainder _ interval MOD frequency;
						  FOR i _ 1 upto frequency  DO ddays[i] _ times;
						  IF (remainder > 0)
						      THEN
							  FOR i _ 1 upto remainder
							      DO ddays[i] _ ddays[i] + 1;
						  i _ 0;
						  newdate _ start!date;
						  WHILE ((newdate LSH -18) LEQ (END!date LSH -18))
						      DO 
							  BEGIN "create entries"
							      create!transaction(newdate,0,xpay);
							      i _ i + 1;
							      IF (i>frequency) THEN i _ i - frequency;
							      lastdate _ newdate;
							      newdate _ newdate + (ddays[i] LSH 18);
							      IF (date!difference(lastdate,newdate) NEQ ddays[i])
								  THEN newdate _ newdate + '1000000;	! add a day;
							  END "create entries"; ! BEGIN ;
					      END "year"
					END "mode generate"
				END "generate table"; ! BEGIN ;

		    DONE "inner command loop";
		END "inner command loop";
	    ctrl!H!off _ true;
	END "outer command loop"; ! BEGIN ;

END "get!dynamic!commands"; ! BEGIN ;

!<<	Top-level code for dynamic!input.>>;
    IF ((principal LEQ 0.0) OR (yint LEQ 0.0))
	THEN
	    BEGIN
		IF (principal LEQ 0.0)
		    THEN 
			PRINT("% The principal is undefined.",
			      "  Please fix before re-entering.",crlf)
		    ELSE
			PRINT("% The yearly interest is undefined.",
			      "  Please fix before re-entering.",crlf);
		RETURN (principal);
	    END;
    initial!principal _ principal;
    IF (days!in!year = 366)
	THEN PRINT ("% Calculations are assumed to be for a 365-day year",
		    crlf);

    datem _ '000400000000;		! date flags;

    saved!flag _ TRUE;
    acount _ -1;
    default!pay _ mpay;

    file!flag _ IF (file!chan GEQ 0) THEN TRUE ELSE FALSE;
    IF file!flag THEN cm!take(file!chan,otty,false);
    old!yint _ yint;		! Save the original yint;
    get!dynamic!commands;
    RETURN(exit!dynamic);
END "dynamic!input"; ! BEGIN ;



!<<GET!COMMANDS -- Top level command parsing.>>;
FORWARD PROCEDURE reset!settings;

PROCEDURE get!commands;
BEGIN "get!commands"
    BOOLEAN ctrl!h!off;
    ctrl!H!off _ TRUE;
    WHILE TRUE DO
	BEGIN "outer command loop"
	    IF profile!flag AND cm!eof THEN RETURN;
	    IF take!flag AND cm!eof THEN RETURN;
	    IF profile!flag OR take!flag
		THEN cm!ini(NULL,ctrl!h!off)
		ELSE cm!ini(IF not!rescan THEN loan!type[loan!flag] & "> "  ELSE NULL, ctrl!H!off);
	    NOT!rescan _ TRUE;
	    ctrl!H!off _ FALSE;
	    WHILE TRUE DO
		BEGIN "inner command loop"
		cm#reset;
		cm#key(top!comm);
		cm#cfm("confirm to exit",TRUE);
		i _ cm#call(NULL,TRUE,FALSE,TRUE);
		check;
		IF i=2 THEN IF profile!flag OR take!flag
		 THEN CONTINUE "outer command loop"
		 ELSE RETURN;
		IF profile!flag AND cm!eof THEN RETURN;
		IF take!flag AND cm!eof THEN RETURN;
		key _ cm#int;
		    CASE key OF
			BEGIN "commands"
			    ELSE BEGIN
				     cm!cfm;
				     check;
				     PRINT("% Inactive Command.",crlf);
			         END;

			   [1] BEGIN "exit"
			    cm!noi("program");
			    cm!cfm;
			    check;
			    DONE "outer command loop";
			    END "exit";

			   [2] BEGIN "calculate";
			    n _ cm!key(calculate!comm,NULL,"Payment");
			    check;
			    CASE n OF
				BEGIN "calculate commands"
				    [1] BEGIN "payment"
					cm!noi("for");
					x _ cm!flt(IF (loan!flag NEQ mortgage)
						   THEN "Amount of the loan"
						   ELSE "Amount of the mortgage",
						   CV!NUM(principal),TRUE);
					check;
					cm!noi("at");
					y _ cm!flt("Interest as a percentage",
						   CV!NUM(yearly!interest*100.0,0,5),TRUE);
					check;
					cm!noi("for");
					i _ cm!num("Term in years",CV!INT(term DIV 12),TRUE);
					check;
					cm!noi(IF i NEQ 1 THEN "years and" ELSE "year and");
					j _ cm!num("Number of months",
						   if (i neq (term DIV 12))
						   THEN "0" ELSE CV!int(term MOD 12),
						   TRUE);
					cm!noi(IF j NEQ 1 THEN "months" ELSE "month");
					cm!cfm;
					check;
					IF ((x < 0) OR (y<0) OR (i<0) OR (j<0))
					    THEN
						BEGIN
						    PRINT("% Illegal number given.",crlf);
						    DONE "inner command loop";
						END;
					yearly!interest _ y/100.0;
					term _ i*12 + ((j DIV 12) * 12) + (j MOD 12);
					principal _ x;
					monthly!payment _ calculate!payment(principal,yearly!interest,term,loan!flag);
					IF (monthly!payment NEQ 0.0) THEN
					    PRINT("Monthly payment = $",
						  cv!num(monthly!payment),crlf);
				END "payment"; ! BEGIN ;

				[2] BEGIN "schedule"
				    cm!noi("for");
				    x _ cm!flt(IF (loan!flag NEQ mortgage)
					       THEN "Amount of the loan"
					       ELSE "Amount of the mortgage",
					       CV!NUM(principal),TRUE);
				    check;
				    cm!noi("at");
				    y _ cm!flt("Interest as a percentage",
					       CV!NUM(yearly!interest*100.0,0,5),
					       TRUE);
				    check;
				    cm!noi("for");
				    i _ cm!num("Term in years",
					       CV!INT(term DIV 12),TRUE);
				    check;
				    cm!noi(IF i NEQ 1 THEN "years and"
					   ELSE "year and");
				    j _ cm!num("Number of months",
					       if (i neq (term DIV 12))
					       THEN "0"
					       ELSE CV!int(term MOD 12),
					       TRUE);
				    z _ 0;
				    cm!noi(IF j NEQ 1 THEN "months with"
					   ELSE "month with");
				    z _ cm!flt("Monthly Payment",
					       CV!NUM(monthly!payment), TRUE);

				    cm!cfm;
				    check;
				    IF ((x < 0) OR (y<0) OR (i<0) OR (j<0) OR (z<0))
					THEN
					    BEGIN
						PRINT("% Illegal number given.",crlf);
						DONE "inner command loop";
					    END;
				    yearly!interest _ y/100.0;
				    term _ i*12 + ((j DIV 12) * 12) + (j MOD 12);
				    principal _ x;
				    monthly!payment _ z;
				    IF monthly!payment=0 THEN
					BEGIN
					    monthly!payment _ calculate!payment(principal,yearly!interest,term,loan!flag);
					    IF (monthly!payment NEQ 0.0) THEN
						PRINT("Monthly payment = $",
						      cv!num(monthly!payment),
						      crlf);
					END;
				    calculate!schedule (roundoff!flag,
							principal,
							yearly!interest,
							monthly!payment,term,
							anniversary!payment,
							anniversary!month,
							loan!flag);
				END "schedule"; ! BEGIN ;

			    [3] BEGIN "principal"
				    cm!noi("for");
				    x _ cm!flt("Amount of the monthly payment",
					       CV!NUM(monthly!payment),TRUE);
				    check;
				    cm!noi("at");
				    y _ cm!flt("Interest as a percentage",
					       CV!NUM(yearly!interest*100.0,0,5),
					       TRUE);
				    check;
				    cm!noi("for");
				    i _ cm!num("Term in years",
					       CV!INT(term DIV 12),TRUE);
				    check;
				    cm!noi(IF i NEQ 1 THEN "years and"
					   ELSE "year and");
				    j _ cm!num("Number of months",
					       if (i neq (term DIV 12))
					       THEN "0"
					       ELSE CV!int(term MOD 12),
					       TRUE);
				    z _ 0;
				    cm!noi(IF j NEQ 1 THEN "months"
					   ELSE "month");
				    cm!cfm;
				    check;
				    IF ((x < 0) OR (y<0) OR (i<0) OR (j<0) OR (z<0))
					THEN
					    BEGIN
						PRINT("% Illegal number given.",crlf);
						DONE "inner command loop";
					    END;
				    yearly!interest _ y/100.0;
				    term _ i*12 + ((j DIV 12) * 12) + (j MOD 12);
				    monthly!payment _ x;
				    principal _ calculate!principal(monthly!payment,yearly!interest,term,loan!flag);
				    IF (principal NEQ 0.0) THEN
					PRINT("Principal = $",
					      cv!num(principal),crlf);
				END "principal";

			    [4] BEGIN "termination"
				    cm!noi("time for");
				    x _ cm!flt(IF (loan!flag NEQ mortgage)
					       THEN "Amount of the loan"
					       ELSE "Amount of the mortgage",
					       CV!NUM(principal),TRUE);
				    check;
				    cm!noi("at");
				    y _ cm!flt("Interest as a percentage",
					       CV!NUM(yearly!interest*100.0,0,5),
					       TRUE);
				    check;
				    cm!noi("with");
				    z _ cm!flt("Monthly Payment",
					       CV!NUM(monthly!payment), TRUE);
				    check;

				    cm!cfm;
				    check;

				    IF ((x < 0) OR (y<0) OR (z<0))
					THEN
					    BEGIN
						PRINT("% Illegal number given.",crlf);
						DONE "inner command loop";
					    END;

				    yearly!interest _ y/100.0;
				    monthly!payment _ z;
				    principal _ x;

				    term _ calculate!term(principal,
							  yearly!interest,
							  monthly!payment,
							  loan!flag);

				    IF (term NEQ 0) THEN
					BEGIN
					    i _ term DIV 12;
					    j _ term MOD 12;
					    PRINT("Termination in ",
					      i," year",
					      IF i NEQ 1 THEN "s" ELSE NULL,
					      " and ",j," month",
					      IF j NEQ 1 THEN "s" ELSE NULL);
					    IF (starting!date > 0)
						THEN PRINT(", with the last payment in ",
							   monthcom[nmod((starting!date+term-1),12)] & " "
							   & CVS((starting!date+term-1) DIV 12));
					    PRINT(".",crlf);
					END;
				END "termination";

				[5] BEGIN "interest"
				    cm!noi("for");
				    x _ cm!flt(IF (loan!flag NEQ mortgage)
					       THEN "Amount of the loan"
					       ELSE "Amount of the mortgage",
					       CV!NUM(principal),TRUE);
				    check;
				    cm!noi("for");
				    i _ cm!num("Term in years",
					       CV!INT(term DIV 12),TRUE);
				    check;
				    cm!noi(IF i NEQ 1 THEN "years and"
					   ELSE "year and");
				    j _ cm!num("Number of months",
					       if (i neq (term DIV 12))
					       THEN "0"
					       ELSE CV!int(term MOD 12),
					       TRUE);
				    z _ 0;
				    cm!noi(IF j NEQ 1 THEN "months with"
					   ELSE "month with");
				    z _ cm!flt("Monthly Payment",
					       CV!NUM(monthly!payment), TRUE);

				    cm!cfm;
				    check;
				    IF ((x < 0) OR (i<0) OR (j<0) OR (z<0))
					THEN
					    BEGIN
						PRINT("% Illegal number given.",crlf);
						DONE "inner command loop";
					    END;
				    term _ i*12 + ((j DIV 12) * 12) + (j MOD 12);
				    principal _ x;
				    monthly!payment _ z;
				    yearly!interest _ calculate!interest (
							principal,
							term,monthly!payment,
							loan!flag);
				    IF (yearly!interest NEQ 0.0) THEN
					PRINT("Yearly interest = ",
					      cv!num((Yearly!interest*100.00),
						     0,5)
					      ,crlf);

				END "interest"

				END "calculate commands"
			   END "calculate";

			 [3] BEGIN "output"
			  cm!noi("processed file to");
			  cm#reset;
			  cm#key(output!comm);
			  cm#fil(NULL,'440006000000,NULL,NULL,program!name,
				 "LST");
			  index _ cm#CALL(program!name & ".LST.-1");
			  check;
			  IF (index=1) THEN
			      BEGIN "keywords"
				  whichone _ cm#int;
				  CASE whichone OF
				      BEGIN
					  ;
					  cm!noi("the connected disk structure");
					  cm!noi("the lineprinter");
					  cm!noi("the null device");
					  cm!noi("the terminal")
				      END;
				  cm!cfm;
				  check;
				  CASE whichone OF
				      BEGIN
					  ;
					  outfile _ connected!directory & program!name & ".LST";
					  outfile _ "LPT:" & program!name;
					  outfile _ "NUL:" & program!name;
					  outfile _ "TTY:"
				      END;
			      END "keywords"
			      ELSE
				  BEGIN "output file"
				      whichone _ cm#int;
				      text _ JFNS(whichone,'111110000001);
				      RLJFN(whichone);
				      cm!cfm;
				      check;
				      outfile _ text;
				  END "output file";

			     CLOSE!out(ochan);
			  END "output";

			[4] BEGIN "Loan"
			 cm!noi("calculation mode for");
			 i _ cm!key(loan!comm,NULL,"Unknown");
			 check;
			 cm!cfm;
			 check;
			 loan!flag _ i;
			 IF (i = drea) THEN
			     BEGIN
				 PRINT("% Output is wider than 80 columns.",
				       crlf);
				 roundoff!flag _ TRUE;
			     END;
			 END "Loan";

			[5] BEGIN "Mortgage"
			 cm!noi("calculation mode");
			 cm!cfm;
			 check;
			 loan!flag _ 0;
			 END "Mortgage";

			[6] BEGIN "principal"
			    x _ cm!flt(IF (loan!flag NEQ mortgage)
				       THEN "Amount of the loan"
				       ELSE "Amount of the mortgage",
				       CV!NUM(principal),TRUE);
			    check;
			    cm!cfm;
			    check;
			    IF (x < 0) THEN
				    BEGIN
					PRINT("% Illegal number given.",crlf);
					DONE "inner command loop";
				    END;
			    principal _ x;
			   END "principal";

			[7] BEGIN "anniversary"
			 cm!noi("payment of");
			 y _ principal/10.0;
			 x _ cm!flt("Amount, maximum of $" & CV!NUM(y),
				    CV!NUM(anniversary!payment),TRUE);
			 check;
			 cm!noi("in");
			 j _ nmod(((starting!date - 1) MOD 12),12);
			 i _ cm!key(month!comm,"Insertion month,",
				    IF starting!date = 0 THEN
				    IF anniversary!month = 0 THEN NULL
				       ELSE monthcom[anniversary!month]
				    ELSE monthcom[j]);
			 check;
			 cm!cfm;
			 check;
			 IF x<0 THEN
			     BEGIN
				 PRINT("% Illegal anniversary payment.",crlf);
				 DONE "inner command loop"
			     END;
			 IF ((x>y) AND (y>0)) THEN
			     PRINT("% Anniversary payment ($",
				   cv!num(x),
			           ") is greater than 10% of principal ($",
				   cv!num(y),").",crlf);
			 anniversary!payment _ x;
			 anniversary!month _ i;
			 END "anniversary";

			[8] BEGIN "term"
			    cm!noi(IF (loan!flag NEQ mortgage)
				   THEN "for the loan is"
				   ELSE "for the mortgage is");
			    i _ cm!num("Term in years",CV!INT(term DIV 12),TRUE);
			    check;
			    cm!noi(IF i > 1 THEN "years and" ELSE "year and");
			    j _ cm!num("Number of months",
				       if (i neq (term DIV 12))
				       THEN "0" ELSE CV!INT(term MOD 12),
				       TRUE);
			    cm!noi(IF j NEQ 1 THEN "months"
				   ELSE "month");
			    cm!cfm;
			    check;
			    IF ((i<0) OR (j<0))
				THEN
				    BEGIN
					PRINT("% Illegal term given.",crlf);
					DONE "inner command loop";
				    END;
			    term _ i*12 + ((j DIV 12) * 12) + (j MOD 12);
			 END "term";

			[9] BEGIN "interest"
			    cm!noi(IF (loan!flag NEQ mortgage)
				   THEN "rate for the loan is"
				   ELSE "rate for the mortgage is");
			    y _ cm!flt("Interest as a percentage",
				       CV!NUM(yearly!interest*100.0,0,5),TRUE);
			    check;
			    cm!cfm;
			    check;
			    IF (y<0)
				THEN
				    BEGIN
					PRINT("% Illegal interest rate given.",crlf);
					DONE "inner command loop";
				    END;
			    yearly!interest _ y/100.0;
			 END "interest";

			[10] BEGIN "starting-date"
			    INTEGER i,l,k,j; STRING s;
			    cm!noi(IF (loan!flag NEQ mortgage)
				   THEN "for the loan is"
				   ELSE "for the mortgage is");
			    i _ cm!key(month!comm,"Starting month,",
				       monthcom[nmod(starting!date,12)]);
			    check;
			    j _ cm!num("Starting year",
				       CV!INT((starting!date-1) DIV 12)
				       ,TRUE);
			    check;
			    cm!cfm;
			    check;
			    IF ((i<0) OR (j<0))
				THEN
				    BEGIN
					PRINT("% Illegal starting date given.",crlf);
					DONE "inner command loop";
				    END;
			    j _ j + (i div 12);
			    i _ i MOD 12;
			    IF J<100 THEN j _ j + 1900;
			    starting!date _ j*12+i;
			 END "starting-date";

			[11] BEGIN "monthly payment"
			    cm!noi(IF (loan!flag NEQ mortgage)
				   THEN "for the loan is"
				   ELSE "for the mortgage is");
			    z _ cm!flt("Monthly Payment",
				       CV!NUM(monthly!payment),TRUE);
			    cm!cfm;
			    check;
			    IF (z<0)
				THEN
				    BEGIN
					PRINT("% Illegal monthly payment given.",crlf);
					DONE "inner command loop";
				    END;
			    monthly!payment _ z;
			    IF monthly!payment=0 THEN
				BEGIN
				    monthly!payment _ calculate!payment(principal,yearly!interest,term,loan!flag);
				    IF (monthly!payment NEQ 0.0) THEN
					PRINT("Monthly payment = $",
					      cv!num(monthly!payment),crlf);
				END;
			 END "monthly payment";

			[12] BEGIN "reset"
			 cm!noi("the current settings");
			 cm!cfm;
			 check;
			 reset!settings;
			 END "reset";

			[13] BEGIN "show"
			 cm!noi("the current settings");
			 cm!cfm;
			 check;
			 show!settings;
			 END "show";

			[14] BEGIN "truncate"
			 cm!noi("schedule calculations");
			 cm!cfm;
			 check;
			 roundoff!flag _ FALSE;
			 END "truncate";

			[15] BEGIN "roundoff"
			 cm!noi("schedule calculations");
			 cm!cfm;
			 check;
			 roundoff!flag _ TRUE;
			 END "roundoff";

			[16] BEGIN "Help"
			    cm!noi("on");
			    i _ cm!key(help!comm,"A command, ","Commands");
			    check;
			    cm!cfm;
			    check;
			    Output!help(i);
			    END "Help";

			[17] BEGIN "leap-year"
			    cm!noi("calculation type is");
			    i _ cm!key(leap!comm,NULL,"365");
			    check;
			    cm!cfm;
			    check;
			    CASE i OF
				BEGIN
				    [1] BEGIN
				          days!in!year _ 365;
					  feb29!flag _ FALSE;
					END;
				    [2] BEGIN
				          days!in!year _ 366;
					  feb29!flag _ TRUE;
					END;
				    [3] BEGIN
				          days!in!year _ 365;
					  feb29!flag _ TRUE;
					END;
				    [4] BEGIN
				          days!in!year _ 366;
					  feb29!flag _ FALSE;
					END
				END;
			    END "leap-year";

			[18] BEGIN "PRINT"
			         INTEGER whichone;
				 whichone _ cm!key(PRINT!comm,NULL,"ALL");
				 check;
				 CASE whichone OF
				     BEGIN
					 [1] BEGIN "ALL"
					     cm!noi("schedule");
					     cm!cfm;
					     check;
					     start!pdate _ 0;
					     END!pdate _ infinity;
					     END "ALL";

				         [3] BEGIN "summary"
					     cm!noi("only");
					     cm!cfm;
					     check;
					     start!pdate _ 0;
					     END!pdate _ 0;
					     END "summary";

					[2] BEGIN "Between"
					    INTEGER i,ii,j,jj,k,l;
					    cm#reset;
					    cm#key(sprint!comm);
					    cm#key(month!comm,"A month, ");
					    i _ cm#CALL("First");
					    check;
					    IF (i=1)
						THEN
						    BEGIN
							ii _ 0;
							cm!noi("payment and");
						    END
						ELSE
						    BEGIN
							j _ cm#int;
							k _ cm!num("A year",
								   NULL,
								   TRUE);
							check;
							IF (k<100) THEN
							    k _ k + 1900;
							ii _ (k*12)+j;
							cm!noi("and");
						    END;
					    cm#reset;
					    cm#key(eprint!comm);
					    cm#key(month!comm,"A month, ");
					    i _ cm#CALL("Last");
					    check;
					    IF (i=1)
						THEN
						    BEGIN
							jj _ infinity;
							cm!noi("payment");
						    END
						ELSE
						    BEGIN
							j _ cm#int;
							k _ cm!num("A year",
								   NULL,
								   TRUE);
							check;
							IF (k<100) THEN
							    k _ k + 1900;
							jj _ (k*12)+j;
						    END;
					    cm!cfm;
					    check;
					    start!pdate _ ii;
					    END!pdate _ jj;
					END "Between"
                                    END;
				    IF (start!pdate > END!pdate)
					THEN start!pdate SWAP END!pdate;
                                END "PRINT";

			[19] BEGIN "save"
			    cm!noi("settings in");
			    index _ cm!fil(NULL,profile!name,'440006000000);
			    check;
			    saveprofile!name _ JFNS(index,'111110000001);
			    RELEASE(index,0);
			    cm!cfm;
			    check;
			    savesettings;
			END "save";

			[20] BEGIN "take"
			    cm!noi("commands from");
			    IF (NOT take!flag) THEN 
				BEGIN
				    take!chan _ cm!fil(NULL,NULL,'120100000000,
						       NULL,NULL,NULL,
						       "CMD");
				    check;
				    cm!cfm;
				    check;
				    take!flag _ TRUE;
				    cm!take(take!chan,otty,false);
				    get!commands;
				    IF cm!abort
					THEN PRINT("% An error occurred in ",JFNS(take!chan,'1111100000001));
				    RELEASE(take!chan);
				    take!flag _ FALSE;
				END
			    ELSE IF (NOT profile!flag) THEN
				PRINT("% Cannot do a recursive take command",
				      crlf);
			    take!flag _ FALSE;
			END "take"; ! BEGIN ;

			[21] BEGIN "dynamic INPUT"
			    INTEGER start!date, i;
			    REAL x;
			    STRING sdate;
			    cm!noi("mode using");
			    cm#reset;
			    cm#fil("Data file",'120100000000,NULL,NULL,NULL,"DAT");
			    cm#cfm("Confirm for interactive mode",TRUE);
			    i _ cm#CALL;
			    check;
			    IF i=1
				THEN
				    BEGIN
					i _ cm#int;
					cm!cfm;
					check;
					x _ dynamic!input(i,
						      roundoff!flag,
						      principal,
						      yearly!interest,
						      monthly!payment,term,
						      loan!flag);
				    END ELSE x _ dynamic!input(-1,
						   roundoff!flag,
						   principal,
						   yearly!interest,
						   monthly!payment,term,
						   loan!flag);
			END "dynamic INPUT";

			[22] BEGIN "days"
			    INTEGER i,j,d;
			    cm!noi("between");
			    i _ cm!tad("Date 1",NULL,TRUE,TRUE,FALSE);
			    check;
			    cm!noi("and");
			    j _ cm!tad("Date 2",NULL,TRUE,TRUE,FALSE);
			    check;
			    d _ date!difference(i,j);
			    PRINT("Number of days = ",d,crlf);
			END "days";

			[23] BEGIN "daily"
			 cm!noi("interest calculations");
			 cm!cfm;
			 check;
			 month!flag _ false;
			 END "daily";

			[24] BEGIN "monthly"
			 cm!noi("interest calculations");
			 cm!cfm;
			 check;
			 month!flag _ true;
			 END "monthly";
			 
			[1000] BEGIN END
			END "commands";

		    DONE "inner command loop";
		END "inner command loop"; ! BEGIN ;
	    ctrl!H!off _ true;
	END "outer command loop"; ! BEGIN ;
    RETURN;
END "get!commands";

!<<RESET!SETTINGS -- Resets the settings to the default>>;

PROCEDURE reset!settings;
BEGIN "reset!settings"
    STRING s, s1, s2;
    INTEGER i,j,k;
    CLOSE!out(ochan);
    IF (ochan = -1) THEN outfile _ "TTY:";
    start!pdate _ 0; END!pdate _ infinity;
    feb29!flag _ FALSE;
    days!in!year _ 365;
    loan!flag _ 0;
    month!flag _ FALSE;
    take!flag _ FALSE;
    term _ 0;
    roundoff!flag _ FALSE;
    yearly!interest _ 0;
    principal _ 0;
    anniversary!payment _ 0;
    starting!date _ get!date(GTAD);
    anniversary!month _ 0;
    monthly!payment _ 0;

    profile!flag _ FALSE;
    !skip! _ 0;
    profile!chan _ GTJFN(profile!name,0);
    IF (!skip!=0) AND (profile!chan NEQ -1)
	THEN
	    BEGIN
	        profile!flag _ TRUE;
		cm!take(profile!chan,otty,false);	! Read the whole file until an eof;
		get!commands;
		RELEASE (profile!chan,0);
	    END;
    profile!flag _ FALSE;
END "reset!settings";

!<<	Command tables are built here, and main program top-level continues.>>;
    cm!tbuild (topcom,top!comm);
    cm!tbuild (loancom,loan!comm);
    cm!tbuild (helpcom,help!comm);
    cm!tbuild (yesnocom,yesno!comm);
    cm!tbuild (outputcom,output!comm);
    cm!tbuild (calculatecom,calculate!comm);
    cm!tbuild (dynamiccom,dynamic!comm);
    cm!tbuild (periodcom,period!comm);
    cm!tbuild (periodscom,periods!comm);
    cm!tbuild (monthcom,month!comm);
    cm!tbuild (leapcom,leap!comm);
    cm!tbuild (printcom,print!comm);
    cm!tbuild (sprintcom,sprint!comm);
    cm!tbuild (eprintcom,eprint!comm);
    cm!tbuild (flagcom,flag!comm);
    spaces _ " ";
    WHILE (LENGTH(spaces)<200) DO spaces _ spaces & spaces;

    ochan _ -1;

!	<<	Program starts here	>>;

j _ '400000000400;

START!CODE
    JSYS '147;			! The Reset Jsys;
    move 1,j;			! Get a channel FOR the process';
    setzm 2;			! execution area ;
    RMAP;
    HLRZM 1,i;

    setzm enabled!user;		! Find out if he is enabled at the top level;
    movei 1,'400000;
    RPCAP;
    trne 3,'600000;
    setom enabled!user;
END;

i _ SETCHAN(i,0,0);
program!name _ JFNS(i,'1000000001);
RELEASE(i,0);

    GJINF (logdir, i, brk);	! Get login directory;
    !skip! _ 0;
    profile!name _ DIRST (logdir + '40000000000) & program!name & ".INI";
    IF (!skip! NEQ 0) THEN profile!name _ "PS:<" & DIRST(logdir) & ">" & program!name & ".INI";
    connected!directory _ DIRST(i);
    IF (!skip! NEQ 0) THEN connected!directory _ "DSK:";


!<< Check the rescan buffer for any information to be used >>;
! if user followed program!name by a filename then set not!rescan to false;

    not!rescan _ TRUE;
    !SKIP! _ 0;
    line _ GETSCAN;
    j _ LENGTH(line);
    FOR i _ 1 UPTO j DO
	BEGIN
	    k _ LOP(LINE);
	    IF ((k=cr) OR (k=lf)) THEN
		BEGIN
		    line _ "";
		    DONE;
		END
		ELSE IF (k = space) THEN DONE
		    ELSE word _ word&k;
	END;
    IF (EQU(word,program!name)) AND (LENGTH(line)>0) THEN
	BEGIN
	    putscan(line);
	    START!CODE
		setzm !skip!;
		movei 1,0;		! Initialize the rscan for read;
		jsys '500;		! The RSCAN JSYS;
		movem 1,!skip!;
	    END; ! START!CODE ;
	    not!rescan _ FALSE;
	END ! BEGIN ;
    ELSE
	BEGIN
	    line _ getscan;
	    not!rescan _ TRUE;
	END; ! BEGIN ;

!<<Command loop -- Parses a line ala COMND JSYS style>>;

    IFC monitorsw THENC
        !skip! _ 0;
        appendchan _ OPENFILE(appendfile[1],"AHOE");
	IF ((appendchan=-1) OR (!skip! NEQ 0))
	    THEN
		BEGIN
		    !skip! _ 0;
		    appendchan _ OPENFILE(appendfile[1],"NWE");
		END;
	IF ((appendchan NEQ -1) AND (!skip!=0))
	    THEN
		BEGIN
		    INTEGER jn,tn,ln,cn;
	            STRING outstring;
		    jn _ GJINF(ln,cn,tn);
		    !skip! _ 0;
		    outstring _ program!name & vers[1] & " -- ";
		    outstring _ outstring & ODTIM(GTAD,0);
		    !skip! _ 0;
		    outstring _ outstring & ", Called by " & DIRST(ln);
		    !skip! _ 0;
		    outstring _ outstring & ", Job " & CVS(jn);
		    !skip! _ 0;
		    outstring _ outstring & " on TTY" & CVOS(tn) & ":";
		    !skip! _ 0;
		    IF ((ln LAND cn) NEQ ln) THEN
			outstring _ outstring & ", on " & DIRST(cn);
		    outstring _ outstring & "." & crlf;
		    CPRINT(appendchan,outstring);
		END;
	RELEASE(appendchan,0);
    ENDC

    PRINT(program!name,vers[1],title[1],crlf,
	  spaces[1 FOR LENGTH(program!name & vers[1])],title[2],crlf,
	  crlf);
    reset!settings;
    get!commands;

!	Program termination;
halt!f;
END "Main Program"
END "amort"
