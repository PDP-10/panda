; UPD ID= 6, SNARK:<6.1.ARPA-UTILITIES>IPHOST.MAC.6,   6-May-85 15:12:06 by PAETZOLD
;Remove some of ETHERNET STATUS from the BUGGY switch.
; UPD ID= 4, SNARK:<6.1.ARPA-UTILITIES>IPHOST.MAC.5,  26-Apr-85 20:17:41 by PAETZOLD
;Add AN20 command and ETHERNET STATUS command.  Most of the ETHERNET STATUS
;command is under IFN BUGGY switch until the NI JSYS works better.
; UPD ID= 3, SNARK:<6.1.ARPA-UTILITIES>IPHOST.MAC.4,   7-Mar-85 11:23:12 by PAETZOLD
;Output interface index in INFO NETWORK command.
;Add ENABLED and DISBABLED subcommands to INTERNET command.
; UPD ID= 2, SNARK:<6.1.ARPA-UTILITIES>IPHOST.MAC.3,   3-Feb-85 21:41:11 by PAETZOLD
;Get rid of the buggy switch and let filtering happen.
; UPD ID= 9, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.9,   1-Nov-84 20:58:51 by PAETZOLD
;Use new GTHST functionality for network interfaces.
;Rework lots of command now that we know all our addresses.
;Update the Help stuff.
;Some code clean up.
; UPD ID= 8, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.8,  16-Oct-84 16:10:58 by PAETZOLD
;No break mask in HSCFB3.
; UPD ID= 7, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.7,  26-Sep-84 07:57:47 by PAETZOLD
;Make sure filtering is not used until tested.
; UPD ID= 6, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.6,  25-Sep-84 16:20:45 by PAETZOLD
;Simplify and fix RETRIEVE
; UPD ID= 5, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.5,  22-Aug-84 21:43:53 by PAETZOLD
;Add Retrieve command.  No more FTNIDB.  Add VALID command.
;Add ENABLE and DISABLE commands.  Add MSDOS, VMS, and TAC OPSTAB entries.
; UPD ID= 4, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.4,  12-May-84 19:05:44 by PAETZOLD
;Implement  some  Ethernet  control commands. Add switches for flags in
;host command. Allow null mapping files.
; UPD ID= 3, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.3,   8-Apr-84 15:54:04 by PAETZOLD
;Change  format  of  CONVERT  command. Add CONVERT ETHERNET and CONVERT
;DECNET commands Use symbols  in  ANAUNV  for  GHT  formats.  Turn  off
;FTNIDB. Add support for the POKE command. Make HSDMPX and friends tell
;us about host status and downtimes.
; UPD ID= 1, SNARK:<TCPIP.5.4.UTILITIES>IPHOST.MAC.2,  20-Mar-84 20:02:32 by PAETZOLD
;Release  6.1.  Add support for the INTERNET-ETHERNET-MAPPING.TXT file.
;Add Support for HS%NET, HS%GAT, and .HSFUZ. Add PUSH command.
; UPD ID= 3, SNARK:<6.ARPA-UTILITIES>IPHOST.MAC.3,  21-Nov-83 10:01:48 by PAETZOLD
;Remove  REL6  switch.  Old  REL6 code is assembled in. Add INFORMATION
;(ABOUT) NETWORK (STATUS) command. Make ARPANET STATUS command use code
;from above.
; UPD ID= 2, SNARK:<6.ARPA-UTILITIES>IPHOST.MAC.2,  30-Oct-83 17:13:08 by PAETZOLD
;REL6 switch is off by default



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1985 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

DEFINE VTITLE(VW,VMA,VMI,VE),<
TITLE IPHOST - TCP/IP Host Utility - KWPaetzold - Version 'VMA'.'VMI'('VE')-'VW' ->

	SALL
	IF1 <TITLE IPHOST>
	IF2 <PRINTX PASS 2>
	IF2 <VTITLE \VWHO,\VMAJOR,\VMINOR,\VEDIT>

	SEARCH MONSYM,MACSYM,ANAUNV
	COPYRT 1985
	.REQUIRE SYS:MACREL.REL
	.DIRECTIVE FLBLST
	IFNDEF DEBUG,<DEBUG==0>
	IFN DEBUG,<LALL>
	IFNDEF BUGGY,<BUGGY==0>

	SUBTTL Non Executable Initialization

	DEFINE SYM(A,B),<A=B>
	DEFINE SYMS(A,B),<A==B>
	DEFINE DSYM(A,B),<IFNDEF A,<A=B>>
	DEFINE DSYMS(A,B),<IFNDEF A,<A==B>>

				;VERSION INFORMATION
	DSYMS VWHO,0		;WHO LAST HACKED
	DSYMS VMAJOR,6		;MAJOR VERSION NUMBER
	DSYMS VMINOR,1		;MINOR VERSION NUMBER
	DSYMS VEDIT,45		;EDIT NUMBER
	VERSIO==<VWHO>B2!<VMAJOR>B11!<VMINOR>B17!<VEDIT>B35

	SUBTTL AC Definitions

				;AC NAMES
	SYM F,0			;FLAGS
	SYM T1,1		;\
	SYM T2,2		; \
	SYM T3,3		;  \ TEMPORARY
	SYM T4,4		;  / ACS
	SYM T5,5		; /
	SYM T6,6		;/
	SYM X1,5		;TEMP AC
	SYM X2,6		;TEMP AC
	SYM NT,7		;NETWORK INTERFACE AOBJN POINTER
	SYM HT,7		;HOST TABLE ADDRESS
	SYM GW,7		;GATEWAY AOBJN POINTER
	SYM PT,7		;PROTOCOL TYPE AOBJN POINTER
	SYM NN,10		;NETWORK INTERFACE NAME STORAGE
	SYM GL,10		;GATEWAY ADDRESS AOBJN POINTER

	SYM QC,7		;QUEUEING CURRENT ITEM
	SYM QP,10		;QUEUEING PREVIOUS ITEM
	SYM QN,11		;QUEUEING NEXT ITEM
	SYM QO,12		;QUEUEING OLD ITEM

	SYM FP,15		;MACSYM'S FRAME POINTER
	SYM CX,16		;MACSYM'S TEMPORARY AC
	SYM P,17		;STACK POINTER

	SYMS AC0,0		;ALTERNATIVE AC NAMES
	SYMS AC1,1
	SYMS AC2,2
	SYMS AC3,3
	SYMS AC4,4
	SYMS AC5,5
	SYMS AC6,6
	SYMS AC7,7
	SYMS AC10,10
	SYMS AC11,11
	SYMS AC12,12
	SYMS AC13,13
	SYMS AC14,14
	SYMS AC15,15
	SYMS AC16,16
	SYMS AC17,17

	SUBTTL Flag and Macro Definitions

				;FLAGS
	MSKSTR F%INIT,F,1B0	;INITIALIZATION DONE
	MSKSTR F%NAME,F,1B1	;HOST NAMES LOADED
	MSKSTR F%HSOB,F,1B2	;BITCH ON HOST NAME ERRORS
	MSKSTR F%DIDB,F,1B3	;WE BITCH ON A HOST NAME ERROR
	MSKSTR F%WLDF,F,1B4	;WILD MATCH FOUND
	MSKSTR F%HOLY,F,1B5	;WE HAVE PRIVS FLAG
	MSKSTR F%SYML,F,1B6	;MONITOR SYMBOLS LOADED
	MSKSTR F%BIJ,F,1B7	;INPUT JFN EXISTS
	MSKSTR F%BIO,F,1B8	;INPUT JFN OPEN
	MSKSTR F%BOJ,F,1B9	;OUTPUT JFN EXISTS
	MSKSTR F%BOO,F,1B10	;OUTPUT JFN IS OPEN
	MSKSTR F%BULD,F,1B11	;BUILD COMMAND SET UP
	MSKSTR F%PUSH,F,1B12	;PUSH EXEC EXISTS
	MSKSTR F%BERR,F,1B13	;ERROR PARSING ETHERNET TEXT FILE
	MSKSTR F%IPSQ,F,1B15	;SPECIAL QUEUE IS ASSIGNED
	MSKSTR F%ICER,F,1B16	;RECEIVED AN ECHO REPLY
	MSKSTR F%WALL,F,1B17	;ALL NAMES MATCH FLAG
	MSKSTR F%ROJ,F,1B18	;RETRIEVE JFN EXISTS
	MSKSTR F%ROO,F,1B19	;RETRIEVE JFN OPEN
	MSKSTR F%TOJ,F,1B20	;TCP JFN EXISTS
	MSKSTR F%TOO,F,1B21	;TCP JFN OPEN
	MSKSTR F%VLD,F,1B22	;VALID COMMAND FLAG
	MSKSTR F%FLT,F,1B23	;RETRIEVE STUFF NEEDS TO FILTER
	MSKSTR F%BIN,F,1B24	;INITIAL RETRIEVE BUFFER FLAG
	MSKSTR F%ES1,F,1B25	;ETHERNET STATUS COMMAND FLAGS
	MSKSTR F%FILE,F,<F%BIO!F%BIJ!F%BOJ!F%BOO!F%ROO!F%ROJ!F%TOJ!F%TOO>
	
	DEFINE JSYSF,<ERCAL .JSYSF> ;ERROR HANDLING MACRO
	DEFINE JSYSC,<ERCAL .JSYSF> ;COMMAND ERROR HANDLING MACRO
	DEFINE NOERR,<ERJMP .+1>    ;ERROR IGNORING MACRO
	DEFINE ERSKP,<ERJMP .+2>    ;SKIP ON ERROR
	DEFINE SAVACS,<CALL .SAVAC> ;GO SAVE ACS

	DEFINE XLIST%,<
	XLIST.==XLIST.+1
	XLIST>

	DEFINE LIST%,<
	XLIST.==XLIST.-1
	IFE XLIST.,<LIST>>

	XLIST.==0

	SUBTTL Parameters

	DSYMS PDLSIZ,200	;STACK SIZE
	DSYMS TXTSIZ,^D500	;TEXT BUFFER SIZE
	DSYMS ATMSIZ,^D200	;ATOM BUFFER SIZE
	DSYMS DDTADR,770000	;DDT STARTING ADDRESS
	DSYMS NAMSIZ,^D39	;MAX SIZE OF A WILD HOST NAME
	DSYMS PGSIZ,1000	;SIZE OF A PAGE
	DSYMS POKTIM,^D50	;SLEEP TIME FOR POKE RECEIVES
	DSYMS POKNUL,^D100	;5 SECONDS 
	DSYMS POKSND,^D50	;SLEEP TIME FOR POKE SENDS
	DSYMS MXNETS,10		;MAXIMUM NUMBER OF SUPPORTED NETWORK INTERFACES
	DSYMS MXPTYP,^D16	;NUMBER OF NI PROTOCOL TYPES SUPPORTED

	DEFINE PG(S,L),<
	S=.LOC
	.LOC==.LOC+^D<L>*PGSIZ>
	.LOC==040000		;PAGE STORAGE STARTS AT PAGE 40

	PG INTNAM,1		;INTERFACE NAME TABLE
	PG UHSTNM,4		;USER HOST NAME TABLE
	PG UHSTNN,4		;USER HOST NICKNAME TABLE
	PG SHSTNM,8		;SERVER HOST NAME TABLE
	PG SHSTNN,8		;SERVER HOST NICKNAME TABLE
	PG GHSTNM,1   		;GATEWAY HOSTNAME TABLE
	PG GHSTNN,1   		;GATEWAY HOST NICKNAME TABLE
	PG NHSTNM,1    		;NETWORK NAME TABLE
	PG HSTNAM,16		;HOST NAME STRING STORAGE
	PG GWYBLK,1		;GATEWAY STATUS TABLE
	PG LNKSTG,4		;LINK TABLE STORAGE
	PG GHTBUF,5		;GATEWAY HOST TABLE BUFFER
	PG TCPBUF,1		;TCP DATA PAGE

	SUBTTL GHT Building Data Structure Definitions

	DEFSTR MPLNK,0,35,36	;LINK POINT
	DEFSTR MPINT,1,35,36	;INTERNET ADDRESS
	DEFSTR MPEA1,2,35,36	;ETHERNET ADDRESS WORD ONE
	DEFSTR MPEA2,3,35,36	;ETHERNET ADDRESS WORD TWO
	DEFSTR MPFLG,4,35,36	;GATEWAY CONTROL FLAGS
	LNKSZ==<$MPFLG-$MPLNK>+1 

	DEFINE TYPE(S),<
	HRROI T1,[ASCIZ\
S\]
	PSOUT>

	DEFINE TYPEN(S),<
	HRROI T1,[ASCIZ\S\]
	PSOUT>

	DEFINE NUMO(A,R,S),<
	XLIST%
	MOVE T2,A
	MOVEI T1,.PRIOU
	IFE <S>,<MOVEI T3,R>
	IFN <S>,<MOVX T3,<NO%LFL!<S>B17!<R>B35>>
	LIST%
	NOUT
	XLIST%
	 JSYSF
	LIST%>

	DEFINE NUMOZ(A,R,S),<
	XLIST%
	MOVE T2,A
	MOVEI T1,.PRIOU
	IFE <S>,<MOVEI T3,R>
	IFN <S>,<MOVX T3,<NO%ZRO!NO%LFL!<S>B17!<R>B35>>
	LIST%
	NOUT
	XLIST%
	 JSYSF
	LIST%>

	SUBTTL COMND JSYS Macros

	DEFINE CMD(N,D,F),<	;;MACRO TO DEFINE A COMMAND
	IFB <D>,<[		;;IF NO DISPATCH ADDRESS
	IFNB <F>,<CM%FW!F>	;;IF FLAGS
	ASCIZ\N\],,.'N>		;;COMMAND WITH DEFAULT ADDRESS
	IFNB <D>,<[		;;IF DISPATCH ADDRESS
	IFNB <F>,<CM%FW!F>	;;IF FLAGS
	ASCIZ\N\],,D>>		;;COMMAND WITH DISPATCH ADDRESS

	DEFINE DOCMD(FNC,DAT,DFT,HLP,BRK),< 	;;MACRO TO XCT A COMND FUNCTION
	DOCFLG==0				;;INITIALZE FLAGS
	IFNB <HLP>,<DOCFLG==DOCFLG!CM%SDH!CM%HPP>;;IF HELP STRING EXISTS
	IFNB <DFT>,<DOCFLG==DOCFLG!CM%DPP>	;;IF DEFAULT STRING EXISTS
	IFNB <BRK>,<DOCFLG==DOCFLG!CM%BRK>	;;IF BREAK MASK EXISTS
	MOVEI T2,[<FNC>B8!DOCFLG		;;FUNCTION CODE AND FLAGS
		  <DAT>				;;DATA WORD
		  IFB <HLP>,<Z>			;;IF NO HELP STRING
		  IFNB <HLP>,<-1,,[ASCIZ\HLP\]>	;;HELP STRING
		  IFB <DFT>,<Z> 		;;IF NO DEFAULT STRING
		  IFNB <DFT>,<-1,,[ASCIZ\DFT\]>	;;DEFAULT STRING
		  IFB <BRK>,<Z>			;;IF NO BREAK MASK
		  IFNB <BRK>,<EXP BRK>]		;;IF BREAK MASK
	CALL .DOCMD>				;;GO TO WORKER ROUTINE

	DEFINE DOCMDB(FNC,DAT,DFT,HLP,BRK),< 	;;MACRO TO XCT A COMND FUNCTION
	DOCFLG==0				;;INITIALZE FLAGS
	IFNB <HLP>,<DOCFLG==DOCFLG!CM%SDH!CM%HPP>;;IF HELP STRING EXISTS
	IFNB <DFT>,<DOCFLG==DOCFLG!CM%DPP>	;;IF DEFAULT STRING EXISTS
	IFNB <BRK>,<DOCFLG==DOCFLG!CM%BRK>	;;IF BREAK MASK EXISTS
	MOVEI T2,[<FNC>B8!DOCFLG		;;FUNCTION CODE AND FLAGS
		  <DAT>				;;DATA WORD
		  IFB <HLP>,<Z>			;;IF NO HELP STRING
		  IFNB <HLP>,<-1,,[ASCIZ\HLP\]>	;;HELP STRING
		  IFB <DFT>,<Z> 		;;IF NO DEFAULT STRING
		  IFNB <DFT>,<-1,,[ASCIZ\DFT\]>	;;DEFAULT STRING
		  IFB <BRK>,<Z>			;;IF NO BREAK MASK
		  IFNB <BRK>,<EXP BRK>]		;;IF BREAK MASK
	CALL .BOCMD>				;;GO TO WORKER ROUTINE

	DEFINE NOISE(S),<DOCMD .CMNOI,<-1,,[ASCIZ\S\]>>	;;NOISE WORDS
	DEFINE CNFIRM,<DOCMD .CMCFM>			;;CONFIRMATION

  	DEFINE DODSP,<		;;MACRO TO HANDLE KEYWORD DISPATCH
	HRRZ T2,(T2)		;;GET THE DISPATCH ADDRESS
	CALL (T2)>		;;AND GO THERE

	SUBTTL Impure Data

IF2 <IFN <CSBSIZ-<.CMGJB+1>>,<PRINTX ?PROBLEM WITH CSB AND CSBV>>
CSB:	BLOCK .CMGJB+1		;COMND STATE BLOCK
BCSB:	BLOCK .CMGJB+1		;BUILD COMMAND COMND STATE BLOCK
PDL:	BLOCK PDLSIZ		;STACK STORAGE
GTJFNB:	BLOCK .GJATR+1		;GTJFN BLOCK
ERRACS:	BLOCK 20		;ERROR AC STORAGE
ERRPC:	Z			;ERROR PC STORAGE
TXTBUF:	BLOCK <TXTSIZ/5>+1	;COMND TEXT BUFFER
ATMBUF:	BLOCK <ATMSIZ/5>+1	;COMND ATOM BUFFER
BXTBUF:	BLOCK <TXTSIZ/5>+1	;BUILD COMND TEXT BUFFER
BTMBUF:	BLOCK <ATMSIZ/5>+1	;BUILD COMND ATOM BUFFER
DBUGSW:	Z			;DEBUGING MODE SWITCH
MAXNET:	Z			;MAXIMUM NETWORK INDEX
LHOSTN:	BLOCK MXNETS		;OUR HOST NUMBER
LNETWN:	BLOCK MXNETS		;NETWORK NUMBER (PARALLEL TO LHOSTN)
BLDIJF:	Z			;MAPPING FILE INPUT JFN
BLDOJF:	Z			;MAPPING FILE OUTPUT JFN
RTRJFN:	Z			;RETRIEVAL FILE JFN
TCPJFN:	Z			;TCP JFN
PSHFRK:	Z			;FORK HANDLE FOR PUSHED EXEC
BUILDP:	Z			;PDL POINTER WHEN ENTERING BUILD STUFF
LNKHED:	Z			;HEAD OF LIST FOR LINKING MAPPING ENTRIES
LNKFST:	Z			;FIRST FREE LINK LOCATION
NTFCNM:	0,,MXNETS		;KEYWORD TABLE FOR NETWORK INTERFACES
	BLOCK MXNETS		;SPACE FOR ENTRIES
NIPTYP:	BLOCK MXPTYP+1		;SPACE FOR PROTOCOL TYPES
IPSQH:	Z			;INTERNET SPECIAL QUEUE HANDLE 

ASNIQB:				;ASNIQ% DESCRIPTOR BLOCK
	1B31			;ICMP PROTOCOL
	Z			;ALL 4N HOSTS
	Z			;OUR HOST NUMBER GOES HERE
	Z			;PORT NUMBERS
	Z			;PROTOCOL MASK
	Z			;4N HOST MASK
	Z			;LOCAL HOST MASK
	Z			;PORT MASK

SNDINB:				;SNDIN% BLOCK
	1+<.IPKDH-.IPKVR+1>+3	;SNDIN% - WORD COUNT
	4B3!5B7!0B15!^D32B31	;IP - VERSION, HDR LEN, TOS, DATAGRAM LEN
	0B15!2B18!0B31		;IP - SEG ID, DONT FRAGMENT, FRAGMENT OFFSET
	377B7!1B15!0B31		;IP - TIME TO LIVE, ICMP, PROTOCOL, IP CHKSUM
	Z			;SOURCE ADDRESS
	Z			;DESTIONATION ADDRESS
	10B7!0B15!<121253>B31	;ICMP - ECHO TYPE AND CHECKSUM
	<12525>B15!<12525>B31	;ICMP - SEQUENCE AND DESCRIPTOR
	<12525>B15!<12525>B31	;ICMP - ECHO REPLY DATA 

RCVINB:				;RCVIN% BLOCK
	1+20  			;RCVIN% - WORD COUNT
	BLOCK 20		;SPACE FOR MESSAGES

	SUBTTL Pure Data

XX==0
BITS:	REPEAT ^D36,<EXP 1B<XX>
		XX=XX+1>

PDLPTR:	IOWD PDLSIZ,PDL		;STACK POINTER

CSBV:				;COMMAND STATE BLOCK
	CM%RAI!RPARSE		;RAISE ALL INPUT TO UPPER CASE...REPARSE ADR
	.PRIIN,,.PRIOU		;IO DESIGNATORS
	-1,,[ASCIZ/IPHOST>/]	;PROMPT TEXT
	-1,,TXTBUF		;TEXT BUFFER POINTER
	-1,,TXTBUF		;FIRST INPUT TO PARSE
	EXP TXTSIZ		;SIZE OF TEXT BUFFER
	Z			;COUNT OF UNPARSED CHARACTERS
	-1,,ATMBUF		;ATOM BUFFER POINTER
	EXP ATMSIZ		;ATOM BUFFER SIZE
	EXP GTJFNB		;GTJFN BLOCK
	CSBSIZ==.-CSBV

BCSBV:				;COMMAND STATE BLOCK FOR BUILD COMMAND
	EXP BPARSE		;REPARSE ADDRESS
	Z			;NO JFNS
	-1,,[0]			;NO PROMPT
	-1,,BXTBUF		;TEXT BUFFER POINTER
	-1,,BXTBUF		;FIRST INPUT TO PARSE
	EXP TXTSIZ		;SIZE OF TEXT BUFFER
	Z			;COUNT OF UNPARSED CHARACTERS
	-1,,BTMBUF		;ATOM BUFFER POINTER
	EXP ATMSIZ		;ATOM BUFFER SIZE
	Z			;NO GTJFN BLOCK
	BCSBSZ==.-BCSBV

	SUBTTL Pure Data - 1822 Stuff

SYSTYP:				;OPERATING SYSTEM TYPE TABLE
	[ASCIZ/Unknown/]	;0
	[ASCIZ/Tenex/]		;1
	[ASCIZ/ITS/]		;2
	[ASCIZ/TOPS-10/]	;3
	[ASCIZ/Tip/]		;4
	[ASCIZ/Mtip/]		;5
	[ASCIZ/Elf/]		;6
	[ASCIZ/Ants/]		;7
	[ASCIZ/Multics/]	;10
	[ASCIZ/TOPS-20/]	;11
	[ASCIZ/Unix/]		;12
	[ASCIZ/Network/]	;13
	[ASCIZ/Fuzzball/]	;14
	[ASCIZ/VMS/]		;15
	[ASCIZ/TAC/]		;16
	[ASCIZ/MSDOS/]		;17
	TYPMAX=.-SYSTYP-1

RSN182:						;1822 Reason Codes
	-1,,[ASCIZ/Unknown (0)/]		;0
	-1,,[ASCIZ/Not ready/]			;1
	-1,,[ASCIZ/Tardy/]			;2
	-1,,[ASCIZ/Nonexistant/]		;3
	-1,,[ASCIZ/IMP reinitialization/]	;4
	-1,,[ASCIZ/Scheduled pm/]		;5
	-1,,[ASCIZ/Scheduled hardware work/]	;6
	-1,,[ASCIZ/Scheduled software work/]	;7
	-1,,[ASCIZ/Emergency restart/]		;8
	-1,,[ASCIZ/Power outage/]		;9
	-1,,[ASCIZ/Software breakpoint/]	;10
	-1,,[ASCIZ/Hardware failure/]		;11
	-1,,[ASCIZ/Scheduled down/]		;12
	-1,,[ASCIZ/Unknown (13)/]		;13
	-1,,[ASCIZ/Unknown (14)/]		;14
	-1,,[ASCIZ/Coming up/]			;15

WEKDAY:				; DAYS OF THE WEEK
	[ASCIZ/Sunday/]
	[ASCIZ/Monday/]
	[ASCIZ/Tuesday/]
	[ASCIZ/Wednesday/]
	[ASCIZ/Thursday/]
	[ASCIZ/Friday/]
	[ASCIZ/Saturday/]
	WEKMAX==.-WEKDAY-1

	SUBTTL Pure Data - Ethernet Status Stuff

NISTAT:				;ETHERNET CHANNEL STATES
	-1,,[ASCIZ/Undefined/]
	-1,,[ASCIZ/Virgin/]
	-1,,[ASCIZ/Reloading/]
	-1,,[ASCIZ/Reload Failed/]
	-1,,[ASCIZ/Initialized/]
	-1,,[ASCIZ/Running/]
	-1,,[ASCIZ/Dump requested/]
	-1,,[ASCIZ/Dump & Reload requested/]
	-1,,[ASCIZ/Broken/]
	-1,,[ASCIZ/Disabled/]
	-1,,[ASCIZ/Reload Requested/]
	NISTMX==.-NISTAT-1	;MAX VALUE 

NICONT:	-1,,[ASCIZ/Seconds since last zeroed:           /]
	-1,,[ASCIZ/Bytes received:                      /]
	-1,,[ASCIZ/Bytes sent:                          /]
	-1,,[ASCIZ/Datagrams received:                  /]
	-1,,[ASCIZ/Datagrams sent:                      /]
	-1,,[ASCIZ/Multicast bytes received:            /]
	-1,,[ASCIZ/Multicast datagrams received:        /]
	-1,,[ASCIZ/Datagrams sent, initially deferred:  /]
	-1,,[ASCIZ/Datagrams sent, single collision:    /]
	-1,,[ASCIZ/Datagrams sent multiple collisions:  /]
	-1,,[ASCIZ/Send failures:                       /]
	Z
	-1,,[ASCIZ/Receive failures:                    /]
	Z
	-1,,[ASCIZ/Unrecognized frame destination:      /]
	-1,,[ASCIZ/Data overrun:                        /]
	-1,,[ASCIZ/System buffer unavailable:           /]
	-1,,[ASCIZ/User buffer unavailable:             /]
	NICNMX==.-NICONT-1

NISFAL:				;SEND FAILURE BITS
	-1,,[ASCIZ/Loss of carrier/]
	-1,,[ASCIZ/Xmit buffer parity error/]
	-1,,[ASCIZ/Remote failure to defer/]
	-1,,[ASCIZ/Xmitted frame too long/]
	-1,,[ASCIZ/Open circuit/]
	-1,,[ASCIZ/Short circuit/]
	-1,,[ASCIZ/Collision detect check failed/]
	-1,,[ASCIZ/Excessive collisions/]
	NISFMX==.-NISFAL-1

NIRFAL:				;RECEIVE FAILURE BITS
	-1,,[ASCIZ/Free list parity error/]
	-1,,[ASCIZ/No free buffers/]
	-1,,[ASCIZ/Frame too long/]
	-1,,[ASCIZ/Framing error/]
	-1,,[ASCIZ/Block check error/]
	NIRFMX==.-NIRFAL-1

PICONT:
	-1,,[ASCIZ/Seconds since last zeroed/]
	-1,,[ASCIZ/Bytes received/]
	-1,,[ASCIZ/Datagrams received/]
	-1,,[ASCIZ/Bytes sent/]
	-1,,[ASCIZ/Datagrams sent/]
	-1,,[ASCIZ/User buffer unavailable/]

	SUBTTL Command Keyword Tables

CMDCFB:	<.CMKEY>B8<.+4>B35	;CFB FOR PRIMARY COMMANDS WHEN A WHEEL
	EXP PCMDS
	EXP 0,0
	<.CMKEY>B8
	EXP WCMDS
	EXP 0,0

WCMDS:	NWCMDS,,NWCMDS		;PRIMARY COMMANDS FOR WHEELS
	CMD AN2,<0>,CM%NOR     	;PREVENT A MATCH
	CMD AN20,,CM%INV	;AN20 MANIPULATION COMMANDS
	CMD BUILD,	 	;BUILD THE ETHERNET FILES
	CMD ETHERNET,		;CONTROL THE ETHERNET
	CMD INTERNET,		;INTERNET CONTROL
	CMD LOAD,		;LOAD TABLES
	CMD MDDT,,CM%INV	;GO TO MDDT
	CMD POKE,,CM%INV	;POKE ALL HOSTS WITH AN IP NOP
	CMD RETRIEVE,		;GET TABLES AND INFORMATION FROM THE NIC
	NWCMDS==.-WCMDS-1

PCMDS:	NPCMDS,,NPCMDS		;PRIMARY COMMANDS FOR NON WHEELS
	CMD CONVERT,		;CONVERT NUMBERS TO OTHER FORMATS
	CMD DDT,,CM%INV 	;GO TO DDT
	CMD DISABLE,,CM%INV	;DISABLE US
	CMD ENABLE,,CM%INV	;ENABLE US IF POSSIBLE
	CMD EXIT,		;RETURN TO LOWER FORK
	CMD HELP, 		;TYPE OUT HELP STRING
	CMD INFORMATION,	;DISPLAY INFORMATION
	CMD LOCAL,		;LOCAL HOST INFORMATION
	CMD NAME, 		;SPECIFIC HOST NAME INFORMATION
	CMD NUMBER,		;SPECIFIC HOST NUMBER INFORMATION
	CMD PUSH,		;PUSH TO A NEW EXEC
	CMD QUIT,.EXIT,CM%INV	;SAME AS EXIT
	CMD RELOAD,,CM%INV	;FORCE HOST TABLE RELOAD POINT
	CMD VALID,		;SAME AS NAME COMMAND BUT ONLY SHOW VALID STATUS
	CMD VERSION,,CM%INV	;VERSION INFORMATION
	NPCMDS==.-PCMDS-1

ACMDS:	NACMDS,,NACMDS		;INTERNET SUBCOMMANDS
	CMD BYPASS,.INETB	;BYPASS CONTROL
	CMD CYCLE,.INETC	;CYCLE ALL INTERFACES
	CMD DISABLE,.INETD	;DISABLE ALL INTERFACES
	CMD ENABLE,.INETE	;ENABLE ALL INTERFACES
	CMD INTERFACE,.INETF	;CHANGE INTERFACE STATUS
	CMD NETWORK,.INETW	;CHANGE NETWORK STATUS
	NACMDS==.-ACMDS-1

BYCMDS:	NBYCMD,,NBYCMD		;BYPASS SUBCOMMANDS
	CMD OFF,0		;OFF
	CMD ON,1		;ON
	NBYCMD==.-BYCMDS-1

INCMDS:	NINCMD,,NINCMD		;INITIALIZE SUBCOMMANDS
	CMD GATEWAY,.IGATE	;INITIALIZE GATEWAY TABLES
	CMD HOST,.IHOST		;INITIALIZE HOST TABLES
	NINCMD==.-INCMDS-1

	SUBTTL Command Keyword Tables Continued

SCMDS:	NSCMDS,,NSCMDS		;NETWORK STATE COMMANDS
	CMD CYCLE,1		;CYCLE
	CMD OFF,0		;OFF
	CMD ON,-1		;ON
	NSCMDS==.-SCMDS-1

CCMDS:	NCCMDS,,NCCMDS		;CONVERT COMMANDS
	CMD DECNET,		;DECNET NODE NUMBER
	CMD ETHERNET,.CETHE	;CONVERT ETHERNET NODE NUMBER
	CMD INTERNET,.CINTER   	;CONVERT INTERNET HOST NUMBER
	NCCMDS==.-CCMDS-1

HCMDS:	NHCMDS,,NHCMDS		;CONVERT HOST SUBCOMMANDS
	CMD DECIMAL,		;FROM DECIMAL
	CMD INTERNET,.HINTE	;FROM INTERNET OCTET FORMAT
	CMD OCTAL,		;FROM OCTAL
	NHCMDS==.-HCMDS-1

ICMDS:	NICMDS,,NICMDS		;INFORMATION COMMANDS
	CMD BYPASS,.BSTAT	;BYPASS STATUS COMMAND
	CMD GATEWAY,		;GATEWAY STATUS COMMAND
	CMD NETWORK,		;NETWORK STATUS COMMAND
	NICMDS==.-ICMDS-1

ECMDS:	NECMDS,,NECMDS		;ETHERNET SUBCOMMANDS
	CMD ARP,E.ARP		;ARP CONTROL 
	CMD INITIALIZE,E.INIT	;INITIALIZE ETHERNET HOST TABLE
	CMD IP,E.IP		;INTERNET CONTROL
	CMD STATUS,E.STAT	;REPORT ETHERNET STATUS
	NECMDS==.-ECMDS-1

EACMDS:	NEACMD,,NEACMD		;ENABLE/DISABLE SUBCOMMANDS
	CMD DISABLED,0		;DISABLE
	CMD ENABLED,1		;ENABLED
	NEACMD==.-EACMDS-1

BCMDS:	NBCMDS,,NBCMDS		;BUILD COMMAND KEYWORDS
	CMD HOST,		;HOST COMMAND
	NBCMDS==.-BCMDS-1

NNCMDS:	NNNCMD,,NNNCMD		;NAME SUBCOMMANDS
	CMD GATEWAY,.NGATE	;GATEWAY NAMES
	CMD NETWORK,.NNETW	;NETWORK NAMES
	CMD SERVER,.NSERV	;SERVER NAMES
	CMD USER,.NUSER		;USER NAMES
	NNNCMD==.-NNCMDS-1

HSCMDS:	NHSCMD,,NHSCMD		;HOST COMMAND SWITCHES
	CMD ARP,.HARP		;HOST DOES ARP
	CMD NOARP,.HNARP	;HOST DOES NOT DO ARP
	NHSCMD==.-HSCMDS

INSCMD:	NINSCM,,NINSCM		;INFORMATION NETWORK SUBCOMMANDS
	CMD ALL,		;ALL INTERFACES
	CMD INTERFACE,.INTRF	;A SPECIFIC INTERFACE
	NINSCM==.-INSCMD-1



ANCMDS:	NANCMS,,NANCMS		;SUBCOMMANDS FOR THE AN20
	CMD ASSERT,.ANASS	;TURN ON THE READY LINE
	CMD RESET,.ANRST	;RESET THE AN20
	CMD REVOKE,.ANREV	;TURN OFF THE READY LINE
	CMD STATUS,.ANSTS	;PRINT OUT DEVICE STATUS
	NANCMS==.-ANCMDS-1

HSWCFB:	<.CMSWI>B8!<.+4>B35	;CFB FOR HOST COMMAND SWITCHES
	EXP HSCMDS		;SWITCHES
	Z			;HELP 
	Z			;DEFAULT
	<.CMCFM>B8		;CONFIRM FUNCTION
	Z
	Z
	Z

RCMDS:	NRCMDS,,NRCMDS		;RETRIEVE COMMAND SUBCOMMANDS
	CMD GATEWAY,.RGATE	;RETRIEVE GATEWAY TABLE
	CMD HOST,.RHOST		;RETRIEVE HOST TABLE
	CMD OLD-HOST,.ROHST	;RETRIEVE OLD HOST TABLE
	NRCMDS==.-RCMDS-1

	SUBTTL Help Text

HLPTXT:	ASCIZ/
The following commands exist:

Command		Description
------------------------------------------------------------------------
CONVERT		Convert host numbers from one format to the other
		formats.

EXIT		Return to EXEC level.

HELP		Type this text.

INFORMATION 	Return information about network interface status.

LOCAL		Dump information about the local host.

NAME		Dump information about a specific host given the name or
		a group of hosts given a wild card string.

NUMBER		Dump information about a specific host given the number.
		The number is in the format aaa.bbb.ccc.ddd.

PUSH		Push to a new EXEC.

VALID		Return information on hosts with known status.  Same
		arguments as the NAME command.

/

HLPHLY:	ASCIZ /
The following privileged commands exist:

Command		Description
------------------------------------------------------------------------

BUILD		Build internet ethernet address translation files.

ETHERNET	Perform various Ethernet control functions.

INTERNET	Perform various Internet internet control functions.

LOAD		Reload monitor's copy of the host table.

RETRIEVE	Copy Host and Gateway tables from the NIC name server.

/

	SUBTTL Mainline

EVEC:				;ENTRY VECTOR
	JRST IPHOST		;STARTING ADDRESS
	JRST IPHSTR		;REENTER ADDRESS
	EXP VERSIO		;VERSION INFORMATION
	EVECL==.-EVEC		;LENGTH OF ENTRY VECTOR

IPHOST:				;STARTING ADDRESS
	RESET			;ALWAYS CLEAN UP
	MOVE P,PDLPTR 		;GET STACK POINTER
	SETZ F,			;RESET FLAGS
	MOVX T1,<CSBV,,CSB>	;GET BLT AC
	BLT T1,CSB+CSBSIZ-1	;INITIALIZE COMND STATE BLOCK
	CALL VEROUT		;OUTPUT THE VERSION INFORMATION
	MOVEI T1,.FHSLF		;THIS FORK
	RPCAP%			;GET MY PRIVS
	 JSYSF
	TXNE T3,SC%WHL!SC%OPR!SC%MNT ;ARE WE HOLY?
	 SETONE F%HOLY		;YES
	CALL LCLADR		;GET ALL OUR LOCAL ADDRESSES
	TYPE <>
	TYPE <>
	SETONE F%INIT		;SET THE INIT DONE FLAG
	JRST GETCMD		;AND GET THE FIRST COMMAND
IPHSTR:			 	;REENTER ADDRESS
	JE F%INIT,,IPHOST	;DO INIT NOW IF NEEDED

GETCMD:				;HERE TO START UP A COMMAND
	DOCMD .CMINI		;START UP A COMMAND
RPARSE:				;REPARSE DISPATCH ADDRESS
	MOVE P,PDLPTR		;REFRESH STACK POINTER
	CALL CLNJFN		;CLEAN UP LEFTOVER JFNS
	MOVE T1,IPSQH		;GET THE QUEUE HANDLE
	TMNE F%IPSQ		;SPECIAL QUEUE ASSIGNED?
	 RELIQ%			;YES SO RELEASE IT
	  JSYSF
	SETZRO F%IPSQ		;NO SPECIAL QUEUE ANYMORE
	JN F%HOLY,,RPARS2	;IF A WHEEL DO DIFFERENT STUFF
	DOCMD .CMKEY,PCMDS	;GET A PRIMARY COMMAND
	JRST RPARS3		;GO JOIN NORMAL FLOW
RPARS2:				;HERE IF WE ARE A WHEEL
	MOVEI T2,CMDCFB		;GET THE CFB ADDRESS
	CALL .DOCMD		;DO THE WORK WITH COMND
RPARS3:				;NORMAL COMMAND FLOW
	DODSP			;DISPATCH ON COMMAND
	JRST GETCMD		;AND GET ANOTHER COMMAND

	SUBTTL Local Address Handling

LCLADR:				;ROUTINE TO GET ALL OUR LOCAL ADDRESS INFO
	TYPE <>
	SETZM MAXNET		;ASSUME NO INTERFACES
	MOVEI T1,MXNETS		;GET NUMBER OF NETS SUPPORTED
	MOVEM T1,NTFCNM		;INTIALIZE THE INTERFACE KEYWORD TABLE
	MOVEI T1,.GTHLA		;LOCAL HOST NUMBERS FUNCTION
	MOVEI T3,LHOSTN		;DESTINATION ADDRESS
	MOVEI T4,MXNETS		;NUMBER OF NETWORKS WE SUPPORT
	GTHST%			;GET OUR HOST NUMBER
	 ERJMP LCLAD4		;HANDLE ERROR
	JUMPE T4,LCLAD4		;HANDLE NO DEFINED INTERFACES
	MOVEM T4,MAXNET		;SAVE THE NUMBER OF INTERFACES PRESENT
	MOVN NT,MAXNET		;GET THE NUMBER OF INTERFACES
	HRLZS NT		;GET THE COUNT INTO LEFT HALF
	MOVEI NN,INTNAM		;INITIALIZE INTERFACE NAME STORAGE POINTER
LCLAD1:				;INTERFACE NAME LOOP
	MOVE T1,LHOSTN(NT)	;GET THE HOST NUMBER
	MOVE T2,LHOSTN(NT)	;GET THE HOST NUMBER
	TXNN T2,<BYTE (4)0(8)200,0,0,0> ;CLASS A?
	 TXZ T1,<BYTE (4)0(8)0,377,377,377> ;YES
	TXNE T2,<BYTE (4)0(8)200,0,0,0> ;CLASS B?
	 TXNE T2,<BYTE (4)0(8)100,0,0,0> ;CLASS B?
	  SKIPA			;NOT CLASS B
	   TXZ T1,<BYTE (4)0(8)0,0,377,377> ;YES
	TXNE T2,<BYTE (4)0(8)200,0,0,0> ;CLASS C?
	 TXNN T2,<BYTE (4)0(8)100,0,0,0> ;CLASS C?
	  SKIPA			;NOT CLASS C
	   TXZ T1,<BYTE (4)0(8)0,0,0,377> ;YES
	MOVEM T1,LNETWN(NT)	;SAVE THE NETWORK NUMBER
	MOVEI T1,.GTHNS		;GET NAME STRING FUNCTION
	MOVEI T2,(NN)		;GET THE STRING ADDRESS
	TXO T2,<POINT 7,>	;MAKE IT A BYTE POINTER
	MOVE T3,LNETWN(NT)	;GET THE NETWORK NUMBER
	GTHST%			;GET THE NAME OF THIS NETWORK
	 ERJMP LCLAD2		;NO NAME FOR THIS NETWORK
	MOVEI T1,NTFCNM		;GET ADDRESS OF THE TABLE
	HRRZS T2		;ZERO THE LEFT HALF
	MOVEI T2,1(T2)		;BUMP THE ADDRESS BY ONE
	EXCH T2,NN		;FIX UP THE POINTERS
	HRLS T2			;NAME ADR INTO LEFT HALF
	HRR T2,NT		;PUT INTERFACE INDEX INTO RIGHT HALF
	TBADD%			;ADD THIS NAME TO THE TABLE
	 JSYSF			;HANDLE AND ERRORS
LCLAD2:				;HERE TO CHECK OUT THE NEXT INTERFACE
	AOBJN NT,LCLAD1		;LOOP FOR ALL THE INTERFACES
	MOVN NT,MAXNET		;GET THE HIGHEST NETWORK NUMBER
	HRLZS NT		;MAKE AN AOBJN POINTER
LCLAD3:				;LOOP FOR OUTPUTING ADDRESSES
	TYPE <Interface # >
	MOVEI T2,(NT)		;GET THE INTERFACE NUMBER
	NUMO T2,10,0		;OUTPUT THE NUMBER
	TYPEN <, net # >
	MOVE T1,LNETWN(NT)	;GET THE NETWORK NUMBER
	CALL OCTETS		;OUTPUT NETWORK NAME AND NUMBER
	TYPEN <, adr >
	MOVE T1,LHOSTN(NT)	;GET THE HOST NUMBER
	CALL OCTETS		;OUTPUT HOST NAME AND NUMBER
	AOBJN NT,LCLAD3		;LOOP FOR ALL THE INTERFACES
	RET			;RETURN TO CALLER WHEN ALL ARE DONE

LCLAD4:				;HERE WHEN IT APPEARS WE HAVE NO NETWORK
	TYPE <%Monitor does not support Internet or no interfaces defined>
	RET			;RETURN TO CALLER

	SUBTTL CLNJFN - Abort and/or Release Left Over JFNs

CLNJFN:				;ROUTINE TO CLEAN UP JFNS FROM COMMANDS
	MOVE T1,BLDIJF		;GET THE INPUT JFN
	TMNE F%BIJ		;NEED TO RELEASE THIS JFN?
	 RLJFN%			;YES SO RELEASE IT
	  JSYSF
	TMNE F%BIO		;NEED TO CLOSE THIS JFN?
	 CLOSF%			;YES SO CLOSE IT
	  JSYSF
	MOVE T1,BLDOJF		;GET THE OUTPUT JFN
	TMNE F%BOJ		;NEED TO RELEASE THIS?
	 RLJFN%			;YES SO DO IT
	  JSYSF
	TXO T1,CZ%ABT		;ABORT THIS JFN
	TMNE F%BOO		;NEED TO CLOSE THIS JFN?
	 CLOSF%			;YES SO DO IT
	  JSYSF
	MOVE T1,RTRJFN		;GET THE RETRIEVE JFN
	TMNE F%ROJ		;NEED TO RELEASE THIS?
	 RLJFN%			;YES SO DO IT
	  JSYSF
	TXO T1,CZ%ABT		;ABORT THIS JFN
	TMNE F%ROO		;NEED TO CLOSE THIS JFN?
	 CLOSF%			;YES SO DO IT
	  JSYSF
	MOVE T1,TCPJFN		;GET THE TCP JFN
	TMNE F%TOJ		;NEED TO RELEASE THIS?
	 RLJFN%			;YES SO DO IT
	  JSYSF
	TXO T1,CZ%ABT		;ABORT THIS JFN
	TMNE F%TOO		;NEED TO CLOSE THIS JFN?
	 CLOSF%			;YES SO DO IT
	  JSYSF
	SETZRO F%FILE		;RESET ALL THE FILE FLAGS
	RET

	SUBTTL COMND JSYS Handling Routine

.DOCMD:				;HERE FROM DOCMD MACRO
	MOVEI T1,CSB		;GET ADDRESS OF COMND STATE BLOCK
	COMND		 	;DO THE JSYS
	 ERJMP .JSYSC		;HANDLE REAL BAD ERRORS
	JE CM%NOP,T1,R		;DONE IF NO PARSE ERRORS
.JSYSC:				;HERE ON ERROR OR NOPARSE
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?>		;PROMPT ERROR STRING
	MOVEI T1,.PRIOU		;OUTPUT TO TTY
	MOVX T2,<.FHSLF,,-1>	;MY LAST ERROR
	SETZB T3,T4		;NO FUNNY LIMITS
	ERSTR			;OUTPUT THE ERROR STRING
	 NOERR			;HANDLE ERRORS
	 NOERR			;HANDLE ERRORS
	JRST GETCMD		;GO GET ANOTHER COMMAND

NEWLIN:				;HERE TO GET A NEW LINE IF NEEDED
	MOVEI T1,.PRIOU		;MY TTY
	RFPOS			;GET ITS POSITION
	 NOERR			;HANDLE ERRORS
	HRRZS T2		;ZERO LEFT HALF
	SKIPN T2		;ARE WE AT THE LEFT MARGIN?
	 RET			;YES SO RETURN
	TYPE <>		 	;NO SO GET A NEW LINE
	RET			;AND RETURN

	SUBTTL JSYS ERROR Handler and AC Save Facility

.JSYSF:				;HERE FROM JSYSF MACRO
	MOVEM AC17,ERRACS+AC17	;SAVE AC 17
	MOVEI AC17,ERRACS	;GET BLT AC
	BLT AC17,ERRACS+AC16	;SAVE ACS 0-16
	MOVE AC17,ERRACS+AC17	;GET AC 17 BACK
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?JSYS error at user PC >
	HRRZ T2,0(P)		;GET THE ERROR PC
	MOVEM T2,ERRPC		;SAVE THE ERROR PC
	NUMO T2,10		;OUTPUT THE ERORR PC
	TYPE <?>		;PROMPT THE ERROR STRING
	MOVEI T1,.PRIOU		;OUTPUT TO TTY
	MOVX T2,<.FHSLF,,-1>	;MY LAST ERROR
	SETZB T3,T4		;NO FUNNY LIMITS
	ERSTR			;OUTPUT THE ERROR STRING
	 NOERR			;HANDLE ANY ERRORS
	 NOERR			;HANDLE ANY ERRORS
	SKIPE DBUGSW		;ARE WE DEBUGING?
	 CALL TODDT 		;YES SO GO TO DDT
	JN F%INIT,,GETCMD	;IF WE HAVE INITED GO GET A COMMAND
KILLUS:
	HALTF			;OTHERWISE STOP
	JRST .-1		;WITHOUT CONTINUES

.SAVAC:				;ROUTINE TO SAVE ACS ON STACK
	ADJSP P,^D14		;GET ROOM ON THE STACK
	MOVEM AC16,0(P) 	;SAVE AC 16
	MOVEI AC16,-^D13(P)	;GET RIGHT HALF OF BLT AC
	HRLI AC16,AC1		;GET LEFT HALF OF BLT AC
	BLT AC16,-1(P)		;SAVE ACS 1-15
	MOVE AC16,0(P)		;RESTORE AC 16
	CALL @-^D14(P)		;GO BACK TO CALLER
.RSTAC:				;HERE TO RESTORE ACS
	SKIPA			;NON-SKIP RETURN
	AOS -^D15(P)		;SKIP RETURN...BUMP RETURN PC
	HRLI AC16,-^D13(P)	;GET BLT AC LEFT
	HRRI AC16,AC1		;GET BLT AC RIGHT
	BLT AC16,AC16		;RESTORE ACS
	ADJSP P,-^D15		;FIX UP THE STACK
	RET			;RETURN TO ORIGINAL

	SUBTTL Simple Commands

.EXIT:				;RETURN TO EXIT
	NOISE <FROM IPHOST>	;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	HALTF			;STOP
	RET			;ON CONTINUE RETURN

.HELP:				;HELP STRING TYPEOUT
	NOISE <WITH IPHOST>	;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	HRROI T1,HLPTXT		;GET HELP TEXT POINTER
	PSOUT			;AND OUTPUT IT
	JE F%HOLY,,R		;IF NOT HOLY WE ARE ALL DONE
	HRROI T1,HLPHLY		;GET HOLY HELP TEXT POINTER
	PSOUT			;AND OUTPUT IT
	RET			;AND GET ANOTHER COMMAND

.MDDT:				;GO TO MDDT
	NOISE <MODE>		;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	MDDT%			;GO TO MDDT
	 JSYSF			;HANDLE ERRORS
	RET			;GET ANOTHER COMMAND

.ENABL:				;ENABLE COMMAND
	NOISE <THIS PROCESS>
	CNFIRM			;MAKE SURE
	MOVEI T1,.FHSLF		;THIS FORK
	SETOB T2,T3		;ALL PRIVS
	EPCAP%			;ENABLE THEM
	 JSYSF
	JRST IPHOST		;NOW RESTART

.DISAB:				;DISABLE COMMAND
	NOISE <THIS PROCESS>
	CNFIRM			;MAKE SURE
	MOVEI T1,.FHSLF		;THIS FORK
	RPCAP%			;GET OUR PRIVS
	 JSYSF
	HLLZS T3		;TURN OFF SPECIAL PRIVS
	EPCAP%			;DISABLE THEM
	 JSYSF
	JRST IPHOST		;NOW RESTART

RSKP:	AOS (P)			;SKIP RETURN
R:	RET			;NON SKIP RETURN

	SUBTTL Reload Command

.RELOA:				;RELOAD HOST TABLES
	NOISE <INTERNAL HOST TABLES>
	CNFIRM			;MAKE SURE
	STKVAR <RLDTT>
	SETZM RLDTT		;ZERO THE TOTAL
	SETONE F%HSOB		;ALLOW BITCHING
	CALL HSTLDF		;LOAD THEM UP
	TYPE <Host tables loaded. >
	TYPE <>
	HRRZ T2,SHSTNM		;GET NUMBER OF SERVER HOSTS
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < server host names.>
	TYPE <>
	HRRZ T2,SHSTNN		;GET NUMBR OF SERVER NICKNAMES
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < server host nicknames.>
	TYPE <>
	HRRZ T2,UHSTNM		;GET NUMBER OF USER HOSTS
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < user host names.>
	TYPE <>
	HRRZ T2,UHSTNN		;GET NUMBER OF USER NICKNAMES
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < user host nicknames.>
	TYPE <>
	HRRZ T2,GHSTNM		;GET NUMBER OF GATEWAYS
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < Gateway names.>
	TYPE <>
	HRRZ T2,NHSTNM		;GET NUMBER OF NETWORK NAMES
	ADDM T2,RLDTT		;ADD TO THE TOTAL
	NUMO T2,12		;OUTPUT COUNT
	TYPEN < Network names.>
	TYPE <>
	NUMO RLDTT,12		;OUTPUT TOTAL NUMBER OF HOST NAMES
	TYPEN < names total.>
	TYPE <>
	TYPE <>
	RET			;AND GET ANOTHER COMMAND

	SUBTTL DDT Command and Routines

.DDT:				;GO TO UDDT
	NOISE <MODE>		;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	CALL TODDT		;GO TO DDT
	RET			;NON SKIP RETURN

TODDT:				;ROUTINE TO SEND US TO DDT
	CALL TODDT0		;CALL WORKER ROUTINE
	CALL DDTADR		;GO TO DDT
	RET			;RETURN FOR ANOTHER COMMAND

TODDT0:				;WORKER ROUTINE TO GET DDT
	SAVACS			;SAVE ACS SO DDT WILL GET THE CORRECT ACS
	MOVE T1,[.FHSLF,,<DDTADR/1000>]; SEE IF A PAGE OF DDT EXISTS
	RPACS%			;GET PAGE ACCESSABILITY
	 JSYSF
	JE PA%PEX,T2,TODDT1	;LOAD DDT IF PAGE DOES NOT EXIST
	MOVE T1,DDTADR		;GET DDT START LOCATION
	CAMN T1,[JRST DDTADR+2] ;LOOK LIKE A DDT?
	 JRST TODDT2		;YES, ENTER IT
TODDT1:				;HERE TO LOAD DDT
	MOVX T1,<GJ%OLD!GJ%SHT>	;NO, GET A JFN ON DDT
	HRROI T2,[ASCIZ/SYS:UDDT.EXE/] ;WHERE DDT LIVES
	GTJFN%			;GET A JFN ON DDT
	 JSYSF			;DDT NOT AVAILABLE
	HRLI T1,.FHSLF		;THIS FORK
	GET%			;LOAD DDT IN
	 JSYSF			;HANDLE ERRORS
	DMOVE T1,.JBSYM##	;GET SYMBOL TABLE POINTERS
	DMOVEM T1,@DDTADR+1	;AND SHOVE THEM INTO DDT
	MOVEI T1,.FHSLF		;DAMN GET% SETS THE EVEC TO BE DDT, SO
	MOVE T2,[EVECL,,EVEC]	;WE'LL SET IT BACK!
	SEVEC%			;SET THE ENTRY VECTOR
	 JSYSF			;HANDLE ERRORS
TODDT2:
	CALL NEWLIN		;GIVE US A NEW LINE
	TYPEN <[Type R$G to return to IPHOST]>
	TYPE <>
	RET			;RETURN...CALLER WILL PUT US IN DDT

	SUBTTL INTERNET Command

.INTER:				;INTERNET COMMAND
	DOCMD .CMKEY,ACMDS,<NETWORK> ;GET THE ARPANET COMMAND
	DODSP			;DISPATCH ON THE COMMAND
	RET			;RETURN TO CALLER AFTER SUBCOMMAND

.INETD:				;INTERNET DISABLE COMMAND
	NOISE <ALL INTERFACES>	;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	SETZ T1,		;OK SET FLAG FOR DISABLE
	CALL DONETS		;AND DO IT
	RET

.INETC:				;INTERNET CYCLE COMMAND
	NOISE <ALL INTERFACES>	;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	MOVEI T1,1		;OK SET FLAG FOR CYCLE
	CALL DONETS		;AND DO IT
	RET

.INETE:				;INTERNET ENABLE COMMAND
	NOISE <ALL INTERFACES>	;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	SETO T1,		;OK SET FLAG FOR ENABLE
	CALL DONETS		;AND DO IT
	RET

DONETS:				;WORKER ROUTINE FOR SETTING STATE OF ALL NETS
	STKVAR <DONTF>		
	MOVEM T1,DONTF		;SAVE THE FLAG
	MOVN NT,MAXNET		;GET THE HIGHEST NETWORK NUMBER
	HRLZS NT		;MAKE AN AOBJN POINTER
DONET2:				;TOP OF LOOP
	MOVEI T1,.IPSNT		;GET THE IPOPR FUNCTION
	MOVE T2,LNETWN(NT)	;GET THE NETWORK NUMBER
	MOVE T3,DONTF		;GET THE NEW STATE
	IPOPR%			;CHANGE NETWORK STATE
	 JSYSF
	AOBJN NT,DONET2		;LOOP FOR ALL INTERFACES
	RET			;AND RETURN

.INETF:				;INTERNET INTERFACE COMMAND
	NOISE <NUMBER>
	DOCMD .CMNUM,10		;INPUT A NUMBER
	MOVE NT,T2		;SAVE THE INTERFACE NUMBER
.INET1:				;COMMON CODE
	NOISE <IS>
	DOCMD .CMKEY,SCMDS,<ON>	;GET THE STATE COMMAND
	HRRE X1,0(T2)		;GET THE STATE CODE
	CNFIRM			;MAKE SURE THE USER WANTS THIS
	SKIPL NT		;IS INTERFACE NUMBER LEGIT?
	 CAML NT,MAXNET		;LEGIT NUMBER?
	  JRST .INET2
	MOVEI T1,.IPSNT		;GET THE IPOPR FUNCTION
	MOVE T2,LNETWN(NT)	;GET THE NETWORK NUMBER
	MOVE T3,X1		;GET THE NEW STATE
	IPOPR%			;CHANGE NETWORK STATE
	 JSYSF
	RET			;RETURN TO CALLER

.INET2:
	TYPE <?No such interface>
	TYPE <>
	TYPE <>
	RET

.INETW:				;INTERNET NETWORK COMMAND
	DOCMD .CMKEY,NTFCNM	;GET THE INTERFACE NAME
	HRRZ NT,(T2)		;GET THE INDEX
	JRST .INET1		;JOIN COMMON CODE

.INETB:				;INTERNET BYPASS COMMAND
	STKVAR <BYPFLG>
	DOCMD .CMKEY,BYCMDS,<STATUS> ;GET A KEYWORD
	HRRE T2,0(T2)		;GET THE ACTION FLAG?
	MOVEM T2,BYPFLG		;SAVE THE FLAG
	CNFIRM			;CONFIRM THE COMMAND
	MOVE T2,BYPFLG		;GET THE FLAG BACK
	MOVEI T1,.IPSIB		;SET BYPASS STATE
	IPOPR%			;CHANGE THE BYPASS STATE
	 JSYSF
	RET			;GET ANOTHER COMMAND

	SUBTTL LOAD Command

.LOAD:				;LOAD TABLES COMMAND
	DOCMD .CMKEY,INCMDS,<HOST> ;GET A KEYWORD
	DODSP			;DISPATCH ON THE KEYWORD
	RET			;RETURN FOR ANOTHER COMMAND

.IGATE:				;ARPANET INITIALIZE GATEWAY (TABLES) COMMAND
	NOISE <TABLES>		;HELP OUT THE USER
	CNFIRM			;MAKE SURE THE USER WANTS THIS
	MOVEI T1,.IPGWY		;INITIALIZE GATEWAY FUNCTION
	IPOPR%			;PERFORM THE FUNCTION
	 JSYSF			;HANDLE ERRORS
	RET			;AND RETURN FOR ANOTHER COMMAND

.IHOST:				;ARPANET INITIALIZE HOST (TABLES) COMMAND
	NOISE <TABLES>		;HELP OUT THE USER
	CNFIRM			;MAKE SURE
	MOVEI T1,.IPINI		;INTIALIZE HOST TABLE FUNCTION
	IPOPR%			;PERFORM THE FUNCTION
	 JSYSF
	SETONE F%HSOB		;ALLOW BITCHING
	CALL HSTLDF		;RELOAD INTERNAL HOST TABLES
	RET			;GET ANOTHER COMMAND

	SUBTTL Push Command

.PUSH:				;PUSH TO A NEW EXEC COMMAND
	NOISE <TO A NEW EXEC>
	CNFIRM			;MAKE SURE USER WANTS THIS
	JN F%PUSH,,.PUSH3	;HERE WHEN WE ALLREADY HAVE AN EXEC
	STKVAR <PSHJFN>
	MOVX T1,<GJ%SHT!GJ%OLD> ;FILE MUST EXIST
	HRROI T2,[ASCIZ/DEFAULT-EXEC:/] ;GET JFN FOR EXEC
	GTJFN%			;GET A JFN ON THE EXEC
	 ERSKP			;SKIP ON ERROR
	  JRST .PUSH2		;WE FOUND IT....
	MOVX T1,<GJ%SHT!GJ%OLD> ;FILE MUST EXIST
	HRROI T2,[ASCIZ/SYSTEM:EXEC.EXE/] ;GET JFN FOR EXEC
	GTJFN%			;GET A JFN ON THE EXEC
	 JSYSF			;HANDLE ERRORS
.PUSH2:				;HERE WHEN WE HAVE THE EXEC JFN
	MOVEM T1,PSHJFN 	;SAVE THE JFN
	MOVX T1,<CR%CAP>	;CFORK FLAGS
	CFORK%			;MAKE A FORK FOR THE EXEC
	 JSYSF			;HANDLE ERRORS
	MOVEM T1,PSHFRK 	;SAVE THE FORK HANDLE
	HRL T1,PSHFRK		;GET THE FORK HANDLE
	HRR T1,PSHJFN		;GET THE JFN
	GET%			;LOAD THE EXEC INTO THE FORK
	 JSYSF			;HANDLE ERRORS
	MOVE T1,PSHFRK		;GET THE FORK HANDLE
	SETZ T2,		;OFFSET ZERO IN ENTRY VECTOR
	SFRKV%			;START UP THE PUSHED EXEC
	 JSYSF			;HANDLE ERRORS
	SETONE F%PUSH		;SET THE PUSH FLAG
	JRST .PUSH4		;GO WAIT FOR THE EXEC TO STOP
.PUSH3:				;HERE WHEN FORK ALLREADY EXISTED
	MOVE T1,PSHFRK		;GET THE FORK HANDLE
	TXO T1,SF%CON		;CONTINUE THE FORK
	SFORK%			;CONTINUE
	 JSYSF
.PUSH4:				;HERE TO WAIT FOR EXEC TERMINATION
	MOVE T1,PSHFRK		;GET THE FORK HANDLE
	WFORK%			;WAIT FOR THE INFERIOR TO DIE
	 JSYSF			;HANDLE ERRORS (VERY WIERD)
	RET			;RETURN TO CALLER

	SUBTTL Version Command

.VERSI:				;VERSION COMMAND
	NOISE <INFORMATION>	;HELP OUT USER
	CNFIRM			;MAKE SURE USER WANTS THIS
	CALL VEROUT		;OUTPUT VERSION INFORMATION
	TYPE <>
	TYPE <>
	RET			;RETURN TO CALLER

VEROUT:				;ENTRY POINTER TO OUTPUT VERSION
	TYPE <IPHOST - TOPS-20AN TCP/IP Host Utility Program - Version >
	MOVEI T2,VMAJOR		;GET THE MAJOR VERSION NUMBER
	NUMO T2,10		;OUTPUT MAJOR VERSION
	MOVEI T2,VMINOR		;GET MINOR VERSION NUMBER
	JUMPE T2,VEROU2		;IF ZERO SKIP IT
	TYPEN <.>		;DELIMIT
	MOVEI T2,VMINOR		;GET THE MINOR VERSION NUMBER
	NUMO T2,10		;OUTPUT MINOR VERSION NUMBER
VEROU2:
	MOVEI T2,VEDIT		;GET EDIT NUMBER
	JUMPE T2,VEROU3		;IF ZERO SKIP IT
	TYPEN <(>		;DELIMIT
	MOVEI T2,VEDIT		;GET THE EDIT NUMBER
	NUMO T2,10		;OUTPUT THE EDIT NUMBER
	TYPEN <)>		;DELIMIT
VEROU3:
 	MOVEI T2,VWHO		;GET THE WHO CODE
	JUMPE T2,R		;IF ZERO SKIP IT
	TYPEN <->		;DELIMIT
	MOVEI T2,VWHO		;GET THE WHO CODE
	NUMO T2,10		;OUTPUT THE WHO CODE
	RET			;RETURN TO CALLER

	SUBTTL AN20 Definitions

	SYMS PI,4      		;PI SYSTEM DEVICE CODE
	SYMS ANI,520		;AN20 INPUT SIDE DEVICE CODE
	SYMS ANO,524		;AN20 OUTPUT SIDE DEVICE CODE
	SYMS IDR,0		;INPUT DATA REG.
	SYMS IWAR,1		;INPUT WORD COUNT REG.
	SYMS IVAR,2		;INPUT VECTOR ADDRESS REG.
	SYMS ODR,0		;OUTPUT DATA REG.
	SYMS OWAR,1		;OUTPUT WORD COUNT REG.
	SYMS OVAR,2		;OUTPUT VECTOR ADDRESS REG.

	OPDEF PIOFF [CONO PI,0]	; TURN ON INTERRUPTS
	OPDEF PION  [CONO PI,277] ; TURN ON INTERRUPTS AGAIN


	SUBTTL AN20 Commands

.AN20:				;AN20 COMMAND
	DOCMD .CMKEY,ANCMDS,<STATUS>
	DODSP			;DISPATCH ON IT
	RET			;AND RETURN

.ANSTS:				;AN20 STATUS COMMAND
	CNFIRM			;MAKE SURE
	TRVAR <RIDR,RODR,RIVAR,ROVAR,RIWAR,ROWAR,RICSR,ROCSR>
	CALL LOADRG		;GET THE REGISTERS
	IFSKP.
	   CALL DUMPRG		;DUMP THE REGISTERS
	   CALL READRG		;INTERPRET THE REGS.
	ELSE.
	   TYPE <%No AN20 Detected>
	ENDIF.
	TYPE <>
	TYPE <>
	RET			;AND RETURN

.ANASS:				;AN20 ASSERT COMMAND
	NOISE <READY LINE>
	CNFIRM
	USRIO%			;GET MAGIC MODE
	 JSYSF
	CONO ANI,<<IVAR>B29>	;SELECT THE REGISTER
	DATAO ANI,[002000,,0]	;TURN ON THE READY LINE
	HRRZS 0(P)		;MAKE SURE USRIO TURNS OFF
	RET			;AND RETURN

.ANREV:				;AN20 REVOKE COMMAND
	NOISE <READY LINE>
	CNFIRM
	USRIO%			;GET MAGIC MODE
	 JSYSF
	CONO ANI,<<IVAR>B29>	;SELECT THE REGISTER
	DATAO ANI,[Z]		;TURN OFF THE READY LINE
	HRRZS 0(P)		;MAKE SURE USRIO TURNS OFF
	RET			;AND RETURN

.ANRST:				;AN20 RESET COMAND
	NOISE <READY LINE>
	CNFIRM
	USRIO%			;GET MAGIC MODE
	 JSYSF
	CONO ANI,200000		;TURN ON THE RESET BIT
	HRRZS 0(P)		;MAKE SURE USRIO TURNS OFF
	RET			;AND RETURN

	SUBTTL AN20 Status Code

LOADRG:
	USRIO%			;TURN ON USER IO MODE
	 JSYSF
	SKIP NOPI1		;TOUCH RIGHT STUFF TO PREVENT PAGE FAULTS
	SKIP LOADR2
	SKIP RIDR
	SKIP ROCSR
	PIOFF			;TAKE THE PLUNGE AND SIEZE THE MACHINE
NOPI1:	CONI ANI,RICSR		;GET INPUT SIDE STUFF
	CONI ANO,ROCSR		;GET OUTPUT SIDE STUFF
	SKIPN RICSR		;ANYTHING READ ON CONI?
	 SKIPE ROCSR		
	  SKIPA			;YES
	   JRST LOADR2		;NO AN10 AROUND SO BITCH
	CONO ANI,<<IDR>B29>	;SELECT IDR REGISTER
	DATAI ANI,RIDR		;READ REG
	CONO ANI,<<IWAR>B29>	;SELECT IWAR REGISTER
	DATAI ANI,RIWAR		;READ REG
	CONO ANI,<<IVAR>B29>	;SELECT IVAR REGISTER
	DATAI ANI,RIVAR		;READ REG
	HRRZ T1,RICSR		;GET OLD STATUS REGISTER
	TRZ T1,740000		;MAKE SURE TERRIBLE BITS NOT SET
	CONO ANI,(T1)		;RESTORE STATE OF ANI DEVICE
	CONO ANO,<<ODR>B29>	;SELECT ODR REGISTER
	DATAI ANO,RODR		;READ REG
	CONO ANO,<<OWAR>B29>	;SELECT OWAR REG
	DATAI ANO,ROWAR		;READ IT
	CONO ANO,<<OVAR>B29>	;SELECT OVAR REG
	DATAI ANO,ROVAR		;READ IT
	HRRZ T1,ROCSR		;GET STATUS REG BEFORE WE PLAYED
	CONO ANO,(T1)		;PUT ANO DEVICE BACK
	AOS 0(P)		;SKIP RETURN
LOADR2:	PION			;RELEASE THE MACHINE
	HRRZS 0(P)		;MAKE SURE USRIO TURNS OFF
	RET			;AND RETURN



DUMPRG:				;DUMP OUT REGISTERS
	TYPE < ICSR/ >
	MOVE T1,RICSR
	CALL REGOUT
	TYPEN <	OCSR/ >
	MOVE T1,ROCSR
	CALL REGOUT

	TYPE < IDR/  >
	MOVE T1,RIDR
	CALL REGOUT
	TYPEN <	ODR/  >
	MOVE T1,RODR
	CALL REGOUT

	TYPE < IWAR/ >
	MOVE T1,RIWAR
	CALL REGOUT
	TYPEN <	OWAR/ >
	MOVE T1,ROWAR
	CALL REGOUT

	TYPE < IVAR/ >
	MOVE T1,RIVAR
	CALL REGOUT
	TYPEN <	OVAR/ >
	MOVE T1,ROVAR
	CALL REGOUT
	RET

REGOUT:				;OUTPUT REGISTERS
	STKVAR <RGOUT>
	MOVEM T1,RGOUT		;SAVE THE DATA
	HLRZ T2,RGOUT		;GET THE LEFT HALF
	NUMOZ T2,10,6		;OUTPUT IT
	TYPEN <,,>
	HRRZ T2,RGOUT		;GET THE RIGHT HALF
	NUMOZ T2,10,6		;OUTPUT IT
	RET			;AND RETURN



READRG:				;READ AND INTERPRET AN20 REGISTERS
	TYPE <>
	MOVX T1,<1B19>		;IMP READY BIT
	TDNE T1,RICSR		;IMP READY?
	IFSKP.
	   TYPE < IMP ready line is on.>
	ELSE.
	   TYPE < IMP ready line is off.>
	ENDIF.
	MOVX T1,<1B10>		;AN20 READY BIT
	TDNN T1,RIVAR		;IS THE AN20 READY BIT ON?
	IFSKP.
	   TYPE < AN20 ready line is on.>
	ELSE.
	   TYPE < AN20 ready line is off.>
	ENDIF.
	MOVX T1,<1B4>		;DISTANT BIT
	TDNN T1,RICSR		;DISTANT CONNECTION?
	IFSKP.
	   TYPE < AN20 has a distant connection to the IMP.>
	ENDIF.
	MOVX T1,<1B5>		;LOCAL BIT
	TDNN T1,RICSR		;LOCAL CONNECTION?
	IFSKP.
	   TYPE < AN20 has a local connection to the IMP.>
	ENDIF.
	RET

	SUBTTL Routine to Load Host Names

HSTLDF:				;ENTRY POINT TO FORCE LOADING
	SETZRO F%NAME		;RESET THE NAME FLAG
	JRST HSTLD2		;AND JOIN LOADING CODE

HSTLOD:				;ROUTINE TO LOAD HOST NAMES
	TMNE F%NAME		;ARE NAMES ALLREADY LOADED?
	 RET			;YES SO JUST RETURN
HSTLD2:				;HERE TO FORCE A NAME LOAD
	SETZRO F%DIDB		;TURN OFF THE DID BITCH FLAG
	SETZM UHSTNM		;ZERO HOST TABLE WORDS
	SETZM UHSTNN
	SETZM SHSTNM
	SETZM SHSTNN
	SETZM GHSTNM
	SETZM GHSTNN
	SETZM NHSTNM
	MOVEI T5,HSTNAM		;INITIALIZE HOST NAME STORAGE POINTER
	MOVEI T1,.GTHSZ		;GTHST GENERAL FUNCTION
	GTHST			;GET NUMBER OF HOST NAMES
	 JSYSF
	MOVE T6,T2		;SAVE AOBJN POINTER
HSTLD3:				;HOST NAME LOADING LOOP
	MOVEI T1,.GTHIX		;HOST NAME FROM INDEX FUNCTION
	HRRO T2,T5		;GET LOCATION TO STORE THE HOST NAME
	HRRZ T3,T6		;GET INDEX
	GTHST			;GET NAME AND INFORMATION ABOUT HOST
	 JSYSF			;HANDLE ERRORS
	IBP T2			;INCREMENT THE BYTE POINTER
	JE HS%SRV,T4,HSTLD4	;IS THIS HOST A SERVER?
	MOVEI T1,SHSTNM		;YES SO ASSUME NOT A NICKNAME
	TXNE T4,HS%NCK		;IS THIS A NICKNAME?
	 MOVEI T1,SHSTNN	;YES SO GET NICKNAME TABLE
	JRST HSTLD5		;JOIN COMMON CODE
HSTLD4:				;HERE IF HOST IS NOT A SERVER
	JN HS%GAT,T4,HSLD41	;IS THIS NAME A GATEWAY?
	JN HS%NET,T4,HSLD42	;IS THIS NAME A NETWORK?
	MOVEI T1,UHSTNM		;NO AND NO.  MUST JUST BE A USER.  
	TXNE T4,HS%NCK		;IS THIS A NICKNAME?
	 MOVEI T1,UHSTNN	;YES SO GET NICKNAME TABLE
	JRST HSTLD5		;JOIN COMMON CODE
HSLD41:				;HERE FOR A GATEWAY
	MOVEI T1,GHSTNM		;GET THE TABLE HEAD
	TMNE HS%NCK,T4		;IS THIS A NICKNAME?
	 MOVEI T1,GHSTNN	;GET THE HEAD FOR A NICKNAME
	JRST HSTLD5		;JOIN COMMON CODE
HSLD42:				;HERE FOR A NETWORK
	MOVEI T1,NHSTNM		;GET THE TABLE HEAD
HSTLD5:
	AOS (T1)		;BUMP ENTRY AVAILABLE COUNT
	HRRZS T2		;ZERO THE LEFT HALF
	AOJ T2,			;BUMP THE ADDRESS
	EXCH T2,T5		;SAVE NEW NAME ADDRESS
	HRLZS T2 		;PUT ADDRESS INTO LEFT HALF
	HRR T2,T6		;SAVE INDEX IN RIGHT HALF
	TBADD			;ADD ENTRY TO THE TABLE
	 ERSKP			;SKIP ON ERRORS
	JRST HSTLD6		;NO ERROR SO CONTINUE ON
	MOVEI T1,.FHSLF		;MYSELF
	GETER%			;GET MY LAST ERROR
	 JSYSF			;TRAP ERRORS
	HRRZS T2		;ZERO THE LEFT HALF
	CAIE T2,TADDX2		;ENTRY ALLREADY EXIST?
	 CALL .JSYSF		;NO SO GIVE AN ERROR
	TMNN F%HSOB		;CAN WE BITCH ABOUT IT?
	 JRST HSTLD6		;NO
	TYPE <%Duplicate host name ">
	MOVEI T1,.GTHIX		;INDEX TO HOST NAME FUNCTION
	MOVEI T2,.PRIOU		;OUTPUT TO TTY
	HRRZ T3,T6		;GET THE HOST INDEX
	GTHST%			;OUTPUT THE HOST NAME
	 JSYSF
	TYPEN <" encountered.>
	SETONE F%DIDB		;FLAG THAT WE BITCHED
HSTLD6:				;HERE FOR NEXT ENTRY
	AOBJN T6,HSTLD3		;LOOP FOR ALL HOSTS
	SETONE F%NAME		;TURN ON THE NAMES LOADED FLAGS
	SETZRO F%HSOB		;TURN OFF BITCH FLAG
	TMNN F%DIDB		;DID WE BITCH?
	 RET			;NO
	TYPE <>			;YES SO EXTRA CRLFS
	TYPE <>
	RET			;RETURN TO CALLER

	SUBTTL Host Lookup COMND Function Block

HSTCFB:				;COMND FUNCTION BLOCK FOR HOST NAMES
	<.CMKEY>B8!CM%BRK!CM%HPP!<.+5>B35
	NNCMDS
	-1,,[ASCIZ/

 Host Name Type
 --------------

/]
	Z
	EXP HSTCBM
	<.CMKEY>B8!CM%HPP!<.+5>B35
	SHSTNM
	-1,,[ASCIZ/

 Server Host Name
 ----------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP UHSTNM
	-1,,[ASCIZ/

 User Host Name
 --------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP SHSTNN
	-1,,[ASCIZ/

 Server Host Nickname
 --------------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP UHSTNN
	-1,,[ASCIZ/

 User Host Nickname
 ------------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP GHSTNM
	-1,,[ASCIZ/

 Gateway Name
 ------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP GHSTNN
	-1,,[ASCIZ/

 Gateway Nickname Name
 ---------------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP NHSTNM
	-1,,[ASCIZ/

 Network Name
 ------------

/]
	Z
	Z
	<.CMTXT>B8!CM%HPP!CM%SDH
	Z
	-1,,[ASCIZ/a wild card string

/]
	Z
	Z



HSCFB2:
	<.CMKEY>B8!CM%BRK!CM%HPP!<.+5>B35
	NNCMDS
	-1,,[ASCIZ/

 Host Name Type
 --------------

/]
	Z
	EXP HSTCBM
	<.CMKEY>B8!CM%HPP!<.+5>B35
	SHSTNM
	-1,,[ASCIZ/

 Internet Host Name
 ------------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP<.+5>B35
	EXP SHSTNN
	-1,,[ASCIZ/

 Internet Host Nickname
 ----------------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP GHSTNM
	-1,,[ASCIZ/

 Gateway Name
 ------------

/]
	Z
	Z
	<.CMKEY>B8!CM%HPP!<.+5>B35
	EXP NHSTNM
	-1,,[ASCIZ/

 Network Name
 ------------

/]
	Z
	Z
	<.CMTXT>B8!CM%HPP!CM%SDH
	Z
	-1,,[ASCIZ/a wild card string

/]
	Z
	Z

HSTCBM:	EXP -1,0,0,0



HSCFB3:				;COMND FUNCTION BLOCK FOR HOST NAMES
	<.CMKEY>B8!CM%DPP!<.+4>B35
	EXP SHSTNM
	Z
	-1,,[ASCIZ/SRI-NIC/]
	<.CMKEY>B8
	EXP SHSTNN
	Z
	Z

INTCFB:	<.CMKEY>B8!CM%DPP!<.+4>B35
	EXP NTFCNM
	Z
	-1,,[ASCIZ/ALL/]
	<.CMKEY>B8
	EXP INSCMD
	Z
	Z

	SUBTTL NAME Command

.VALID:				;VALID COMMAND
	NOISE <HOST STATUS INFORMATION FOR>
	SETONE F%VLD		;SET THE VALID FLAG
	JRST .NAME0		;JOIN COMMON CODE

.NAME:				;HOST NAME COMMAND
	NOISE <OF HOST IS>     	;HELP OUT THE USER
	SETZRO F%VLD		;RESET THE VALID COMMAND
.NAME0:				;HERE ALSO FROMT THE VALID COMMAND
	CALL HSTLOD		;LOAD HOST NAMES IF NEEDED
	MOVEI T2,HSTCFB		;GET THE HOST NAME FUNCTION BLOCK
	SKIPN UHSTNM		;ANY USER HOSTS?
	 SKIPE UHSTNN		;ANY USER HOST NICKNAMES?
	  JRST .NAME1		;YES OR YES
	SKIPN GHSTNN		;ANY GATEWAY NICKNAMES?
	 MOVEI T2,HSCFB2	;NO SO GET ALTERNATE BLOCK
.NAME1:
	CALL .DOCMD		;LOOKUP THE HOST NAME
	CAIL T2,NNCMDS		;POSSIBLE HOST TYPE?
	 CAIG T2,NNCMDS+NNNCMD	;?
	  JRST .NAME7		;YES SO HANDLE IT
	CAIL T2,UHSTNM		;POSSIBLE HOST NAME?
	 CAIL T2,HSTNAM		;POSSIBLE HOST NAME?
	  JRST .NAME2		;NO SO IT MUST BE A QUOTED STRING
	HRRZ T5,(T2)		;GET THE HOST INDEX
	CNFIRM			;MAKE SURE
	MOVE T1,T5		;GET THE INDEX INTO CORRECT AC
 	CALL HSDMPX		;OUTPUT INFORMATION ON THIS HOST
	TYPE <>
	TYPE <>
	RET			;RETURN TO CALLER

.NAME2:				;HERE ON A QUOTED STRING
	TRVAR <<NAMQST,<NAMSIZ/5+1>>>
	SETZRO F%WLDF		;INITIALIZE THE WILD FLAG
	MOVX T1,<POINT 7,ATMBUF> ;GET THE DESTINATION POINTER
	MOVX T2,<POINT 7,NAMQST> ;GET THE TARGET POINTER
.NAME3:				;LOOP FOR COPYING THE ATOM BUFFER
	ILDB T3,T1		;GET A BYTE
	IDPB T3,T2		;PUT THE BYTE
	JUMPN T3,.NAME3		;LOOP UNTIL A NULL BYTE
	CNFIRM			;MAKE SURE THE USER WANTS THIS FUNCTION
	MOVEI HT,SHSTNM		;SERVER HOSTS
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
	MOVEI HT,UHSTNM		;USER HOSTS
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
	JN F%VLD,,.NAME4	;IF A VALID COMAND DO NOT DO NICKNAMES
;xxxxx	JN F%WLDF,,.NAME4	;IF WE FOUND MATCHES DO NOT CHECK NICKNAMES
	MOVEI HT,SHSTNN		;SERVER HOST NICKNAMES
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
	MOVEI HT,UHSTNN		;USER HOST NICKNAMES
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
				;...

	SUBTTL NAME Command Continued

				;...
.NAME4:				;HERE TO LOOK FOR GATEWAY MATCHES
	MOVEI HT,GHSTNM		;GATEWAYS
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
	JN F%WLDF,,.NAME5	;ANY MATCHES FOUND?
	MOVEI HT,GHSTNN		;NO SO SEARCH GATEWAY NICKNAMES
	CALL NAMWLD		;AND DUMP INFO ON THEM
.NAME5:				;HERE FOR NETWORKS
	MOVEI HT,NHSTNM		;NETWORKS
	CALL NAMWLD		;DUMP INFORMATION ON ANY MATCHES
	JN F%WLDF,,.NAME6	;MATCHES FOUND?
	TYPE <%No matches found.>
.NAME6:
	TYPE <>
	TYPE <>
	RET

.NAME7:				;HERE ON A HOST TYPE
	SETZRO F%WLDF		;ZERO THE MATCH FOUND FLAG
	SETONE F%WALL		;ALL NAMES MATCH FLAG ON
	DODSP			;DISPATCH ON THE HOST NAME
	RET			;AND GET ANOTHER COMMAND

	SUBTTL Host Name Type Handling

.NSERV:				;SERVER HOSTS
	CNFIRM			;MAKE SURE
	MOVEI HT,SHSTNM		;SERVER HOST NAMES
	CALL NAMWLD		;DUMP THEM
	JN F%WLDF,,R		;IF ANY FOUND RETURN
	MOVEI HT,SHSTNN		;SERVER HOST NICKNAMES
	CALL NAMWLD		;DUMP THEM
	RET			;RETURN FOR ANOTHER COMMAND

.NUSER:				;USER HOSTS
	CNFIRM			;MAKE SURE
	MOVEI HT,UHSTNM		;USER HOST NAMES
	CALL NAMWLD		;DUMP THEM
	JN F%WLDF,,R		;IF ANY FOUND RETURN
	MOVEI HT,UHSTNN		;USER HOST NICKNAMES
	CALL NAMWLD		;DUMP THEM
	RET			;RETURN FOR ANOTHER COMMAND

.NGATE:				;GATEWAYS
	CNFIRM			;MAKE SURE
	MOVEI HT,GHSTNM		;GATEWAY HOST NAMES
	CALL NAMWLD		;DUMP THEM
	JN F%WLDF,,R		;IF ANY FOUND RETURN
	MOVEI HT,GHSTNN		;GATEWAY HOST NICKNAMES
	CALL NAMWLD		;DUMP THEM
	RET			;RETURN FOR ANOTHER COMMAND

.NNETW:				;NETWORKS
	CNFIRM			;MAKE SURE
	MOVEI HT,NHSTNM		;NETWORK HOST NAMES
	CALL NAMWLD		;DUMP THEM
	RET

	SUBTTL NAMWLD - Routine to Search Tables for Wild Matches

NAMWLD:				;ROUTINE TO LOOK FOR WILD MATCHES
				;HT/ HOST TABLE ADDRESS
	SKIPN (HT)		;ANY ENTRIES?
	 RET			;NO SO RETURN NOW
	HRRZ T1,(HT)		;GET THE NUMBER OF ENTRIES
	JUMPE T1,R		;IF NO ENTRIES JUST RETURN
	MOVNS T1		;GET THE NEGATIVE ENTRY COUNT
	MOVEI HT,1(HT)		;BUMP THE ADDRESS OF THE TABLE
	HRL HT,T1		;BUILD THE AOBJN WORD
NAMWL2:				;LOOP FOR CHECKING HOST NAMES
	JN F%WALL,,NAMWL3	;IF EVERYTHING MATCHES WE HAVE A WIN
	MOVX T1,.WLSTR		;THIS IS A WILD STRING COMPARE
	HRROI T2,NAMQST		;THE WILD STRING ADDRESS
	HLRO T3,(HT)		;GET THE NON WILD STRING
	WILD%			;DOES IT MATCH?
	 JSYSF
	JUMPE T1,NAMWL3		;YES
        AOBJN HT,NAMWL2		;NO SO KEEP LOOKING
	RET			;RETURN AFTER ALL ENTRIES
NAMWL3:				;HERE WHEN WE HAVE A MATCH
	SETONE F%WLDF		;SET THE WILD FLAG
	HRRZ T1,(HT)		;GET THE INDEX
	CALL HSDMPX		;DUMP INFORMATION ON HOST
	AOBJN HT,NAMWL2		;KEEP LOOKING
	RET			;RETURN AFTER ALL ENTRIES

	SUBTTL LOCAL and NUMBER Commands

.LOCAL:				;LOCAL HOST COMMAND
	NOISE <HOST INFORMATION> ;HELP OUT THE USER
	CNFIRM			;MAKE SURE USER WANTS THIS
	MOVE T1,LHOSTN		;GET THE LOCAL HOST NUMBER
	CALL HSDMPN		;DUMP THIS HOST NUMBER
	TYPE <>
	TYPE <>
	RET			;RETURN FOR ANOTHER COMMAND

.NUMBE:				;HOST NUMBER COMMAND
	STKVAR <HSTNUM>
	NOISE <OF HOST>         ;HELP OUT THE USER
	SETZM HSTNUM		;ZERO THE HOST NUMBER WORD
	MOVX T6,<POINT 8,HSTNUM,3> ;GET NEAT BYTE POINTER
	MOVEI T5,4		;FOUR OCTETS
.NUMB2:				;OCTET LOOP
	DOCMD .CMNUM,12,0,<DECIMAL OCTET>
	IDPB T2,T6		;DEPOSIT THE OCTET
	SOJLE T5,.NUMB3		;ALL FOUR OCTETS YET?
	DOCMD .CMTOK,<-1,,[ASCIZ\.\]>,<.> ;NO SO PARSE A COMMA
	JRST .NUMB2		;WE NEED FOUR OCTETS
.NUMB3:				;HERE WHEN WE HAVE THE HOST NUMBER
	CNFIRM			;MAKE SURE USER WANTS THIS
	MOVEI T1,.GTHHN		;NAME CHECKING FUNCTION
	MOVE T3,HSTNUM		;GET THE HOST NUMBER
	GTHST			;GET THE STATUS OF THIS HOST
	 ERJMP .NUMB4		;ON ERROR ASSUME NOT FOUND
	MOVE T1,HSTNUM		;GET THE HOST NUMBER
	CALL HSDMPN		;DUMP THIS HOST NUMBER
	TYPE <>
	TYPE <>
	RET			;RETURN FOR ANOTHER COMMAND
.NUMB4:				;HERE WHEN HOST NOT FOUND
	TYPE <%NAME FOR HOST NOT FOUND>
	TYPE <>
	TYPE <>
	RET			;GET ANOTHER COMMAND

	SUBTTL CONVERT Commands

.CONVE:				;CONVERT COMMAND
	DOCMD .CMKEY,CCMDS,<INTERNET> ;GET A KEYWORD
	DODSP			;DISPATCH ON IT
	RET			;AND RETURN FOR ANOTHER COMMAND

.CETHE:				;CONVERT ETHERNET COMMAND
	STKVAR <<NIENN,2>>
	NOISE <ADDRESS>
	MOVEI T5,5		;READ SIX HEX OCTETS
	MOVX T6,<POINT 8,NIENN> ;GET THE BYTE POINTER
CETHE2:				;OCTET READING LOOP
	DOCMD .CMFLD,,<00>,<two hex digits>,HEXBRK ;READ IN THE OCTET
	MOVX T1,<POINT 7,ATMBUF> ;GET THE POINTER
	CALL HEXRED		;READ HEX FROM THE ATOM BUFFER
	 JRST CETHE3		;ERROR READING HEX
	IDPB T1,T6		;DEPOSIT THE OCTET
	JUMPE T5,CETHE4		;IF LAST BYTE WE ARE DONE
	DOCMD .CMTOK,<-1,,[ASCIZ/-/]>,<->,<a dash> ;GET A HYPHEN
	SOJA T5,CETHE2		;GO READ THE NEXT OCTET
CETHE3:				;HERE ON A HEX READ ERROR
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?Command error reading HEX Ethernet address.>
	TYPE <?>
	HRROI T1,ATMBUF		;GET A POINTER TO THE TEXT BUFFER
	PSOUT%			;OUTPUT THE TEXT BUFFER
	RET			;RETURN FOR ANOTHER COMMAND

CETHE4:				;HERE WHEN WE HAVE THE HEX
	NOISE <TO DECNET NODE NUMBER>
	CNFIRM
	LDB T3,[POINT 16,1+NIENN,15] ;GET THE DECNET NODE NUMBER
	DPB T3,[POINT 8,T3,19]	;MOVE THE LOW ORDER BYTE TO HIGH
	LSH T3,-10		;SHIFT IT OVER
	DMOVE T1,NIENN		;GET THE ETHERNET ADDRESS
	CALL NIDCNP		;PRINT OUT THE TRANSLATION
	RET			;AND RETURN FOR ANOTHER COMMAND



.DECNE:				;CONVERT DECNET COMMAND
	STKVAR <DCNDN,<DCNEN,2>>
	NOISE <NODE NUMBER>
	DOCMD .CMNUM,12,,<area number> ;GET THE AREA NUMBER
	SETZM DCNDN		;ZERO THE DECNET NODE NUMBER FOR DEPOSITS
	DPB T2,[POINT 6,DCNDN,25] ;DEPOSIT THE AREA NUMBER
	DOCMD .CMTOK,<-1,,[ASCIZ/./]>,<.> ;GET THE DELIMITOR
	DOCMD .CMNUM,12,,<node number> ;GET THE LOCAL NUMBER
	DPB T2,[POINT 10,DCNDN,35] ;DEPOSIT THE LOCAL NODE NUMBER
	NOISE <TO ETHERNET ADDRESS>
	CNFIRM			;MAKE SURE
	MOVE T2,DCNDN		;GET THE DECNET NODE NUMBER
	DPB T2,[POINT 8,T2,19]	;PUT LOW ORDER BYTE INTO HIGH ORDER BYTE
	LSH T2,-10		;AND MOVE OVER ALL 16 BITS
	SETZM DCNEN		;ZERO CELL FOR BYTE DEPOSITS
	SETZM 1+DCNEN
	DPB T2,[POINT 16,1+DCNEN,15] ;PUT THE DECNET PART BACK IN CORRECT ORDER
	MOVX T1,<BYTE (4)12,12,0,0,0,4,0,0> ;GET DECNET FIRST PART
	IORM T1,DCNEN		;AND DEPOSIT IT
	DMOVE T1,DCNEN		;GET THE ETHERNET ADDRESS
	MOVE T3,DCNDN		;GET THE DECNET ADDRESS
	CALL NIDCNP		;OUTPUT THE INFORMATION
	RET



NIDCNP:				;OUTPUT ETHERNET DECNET ADDRESSES
	STKVAR <NIDNA,<NIDNI,2>>
	DMOVEM T1,NIDNI		;SAVE THE ETHERNET ADDRESS
	MOVEM T3,NIDNA		;SAVE THE DECNET ADDRESS
	CALL NEWLIN		;GET A NEW LINE
	TYPE < Decnet node number: >
	LDB T2,[POINT 6,NIDNA,25] ;GET THE AREA NUMBER
	NUMO T2,12,0		;OUTPUT THE AREA NUMBER
	TYPEN <.>		;DELIMIT
	LDB T2,[POINT 10,NIDNA,35] ;GET THE LOCAL NUMBER
	NUMO T2,12,0		;OUTPUT THE LOCAL NUMBER
	TYPEN < is Ethernet address: >
	MOVE T5,[POINT 4,NIDNI]	;GET THE BYTE POINTER
	MOVEI T6,^D11		;INIT THE COUNT
	JRST NIDCN3		;NO DELIMTOR FIRST TIME
NIDCN2:				;HEX OUTPUT LOOP
	TRNE T6,1		;IS IT ODD?
	 PBOUT%			;YES SO OUTPUT THE DELMITOR
NIDCN3:				;ENTRY POINT FOR LOOP
	ILDB T1,T5		;GET A BYTE
	ADJBP T1,[POINT 7,[ASCIZ/0123456789ABCDEF/],6]
	LDB T1,T1		;TRANSLATE TO HEX
	PBOUT%			;OUTPUT THE HEX CHARACTER
	MOVEI T1,"-"		;GET A DELIMITOR
	CAIN T6,6		;IS THE COUNT SIX?
	 IBP T5			;YES SO AN EXTRA BYTE INCREMENT
	SOJGE T6,NIDCN2		;LOOP FOR ALL HEX BYTES
	TYPE <>
	TYPE <>
	RET			;RETURN FOR ANOTHER COMMAND



.CINTER:			;CONVERT INTERNET COMMAND
	TRVAR <CNVHNM>
	NOISE <HOST NUMBER IN>
	DOCMD .CMKEY,HCMDS,<INTERNET> ;ASK FOR THE NUMBER TYPE
	DODSP			;DISPATCH ON THE KEYWORD
	CALL NEWLIN		;GET A NEW LINE
	TYPE < Internet: >
	MOVX T5,<POINT 8,CNVHNM,3> ;GET NEAT BYTE POINTER
	MOVEI T6,4		;FOUR OCTETS
	JRST CONVE2		;JOIN COMMON CODE
CONVE1:
	TYPEN <.>		;DELIMIT WITH A DOT
CONVE2:
	ILDB T2,T5		;GET AN OCTET
	NUMO T2,12		;OUTPUT THE OCTET IN DECIMAL
	SOJG T6,CONVE1		;LOOP FOR FOUR OCTETS
	TYPEN <, Decimal: >
	NUMO CNVHNM,12,0	;OUTPUT HOST NUMBER IN DECIMAL
	TYPEN <, Octal: >
	NUMO CNVHNM,10,0	;OUTPUT HOST NUMBER IN OCTAL
	TYPE <>
	TYPE <>
	RET			;GET ANOTHER COMMAND

.HINTE:				;CONVERT INTERNET COMMAND
	NOISE <FORMAT>
	MOVX T6,<POINT 8,CNVHNM,3> ;GET NEAT BYTE POINTER
	MOVEI T5,4		;FOUR OCTETS
INTER1:				;OCTET LOOP
	DOCMD .CMNUM,12,0,<DECIMAL OCTET>
	IDPB T2,T6		;DEPOSIT THE OCTET
	SOJLE T5,INTER2		;ALL FOUR OCTETS YET?
	DOCMD .CMTOK,<-1,,[ASCIZ\.\]>,<.> ;NO SO PARSE A COMMA
	JRST INTER1		;WE NEED FOUR OCTETS
INTER2:				;HERE WHEN WE HAVE THE HOST NUMBER
	CNFIRM			;MAKE SURE USER WANTS THIS
	RET			;RETURN TO CALLER

.OCTAL:				;CONVERT OCTAL COMMAND
	NOISE <FORMAT>
	DOCMD .CMNUM,10		;GET THE OCTAL HOST NUMBER
	MOVEM T2,CNVHNM		;SAVE THE HOST NUMBER
	CNFIRM			;MAKE SURE USER WANTS THIS
	RET

.DECIM:				;CONVERT DECIMAL COMMAND
	NOISE <FORMAT>
	DOCMD .CMNUM,12 	;GET THE DECIMAL HOST NUMBER
	MOVEM T2,CNVHNM		;SAVE THE HOST NUMBER
	CNFIRM			;MAKE SURE USER WANTS THIS
	RET

	SUBTTL Host Information Dumping Routines

HSDMPN:				;HOST DUMPER FROM HOST NUMBER
				;T1/ HOST NUMBER
	STKVAR <F4NIDX,F4NHST,F4NSTS,SYSIDX>
	MOVEM T1,F4NHST		;SAVE HOST NUMBER
	MOVEI T1,.GTHHN		;HOST NUMBER FOR HOST STATUS FUNCTION
	MOVE T3,F4NHST		;GET THE HOST NUMBER
	GTHST			;GET THE HOST STATUS
	 JSYSF
	MOVEM T4,F4NSTS		;SAVE THE STATUS
	JRST HSTDM1		;JOIN COMMON CODE

HSDMPX:				;HOST DUMPER
				;T1/ HOST INDEX
	STKVAR <F4NIDX,F4NHST,F4NSTS,SYSIDX>
	MOVEM T1,F4NIDX		;SAVE THE 4N HOST INDEX
	MOVEI T1,.GTHIX		;HOST FUNCTION GIVEN INDEX
	MOVEI T2,.NULIO		;OUTPUT TO BIT BUCKET
	MOVE T3,F4NIDX		;GET THE HOST INDEX
	GTHST			;GET INFO ON THIS HOST
	 JSYSF			;HANDLE ERRORS
	MOVEM T3,F4NHST		;SAVE 4N HOST NUMBER
	MOVEM T4,F4NSTS		;FOREIGN HOST STATUS
	TMNE F%VLD		;ONLY WANT VALID HOSTS?
	 TXNE T4,HS%VAL		;WANT VALID.  IS THIS VALID?
	  SKIPA			;VALID OR WE WANT ALL
	   JRST HSTDM7		;WANT VALID AND THIS IS NOT VALID
	JE HS%NCK,T4,HSTDM1	;IS THIS A NICKNAME?
	TYPE < >		;YES SO GET A NEW LINE
	MOVEI T1,.GTHIX		;GET THE INDEX TO NAME FUNCTION CODE AGAIN
	MOVEI T2,.PRIOU		;OUTPUT TO TTY
	MOVE T3,F4NIDX		;GET THE NAME INDEX
	GTHST			;OUTPUT THE HOST NICKNAME
	 JSYSF
	TYPEN < is a nickname for:>
HSTDM1:
	TYPE < >		;GET A NEW LINE
	MOVX T5,<POINT 8,F4NHST,3> ;GET NEAT BYTE POINTER
	MOVEI T6,4		;FOUR OCTETS
	JRST HSTDM3		;JOIN COMMON CODE

	SUBTTL Host Information Dumping Routines Continued

HSTDM2:
	TYPEN <.>		;DELIMIT WITH A DOT
HSTDM3:
	ILDB T2,T5		;GET AN OCTET
	NUMO T2,12		;OUTPUT THE OCTET IN DECIMAL
	SOJG T6,HSTDM2		;LOOP FOR FOUR OCTETS
	TYPEN < >		;DELIMIT
	MOVEI T1,.GTHNS		;PRIMARY HOST NAME FUNCTION
	MOVEI T2,.PRIOU		;OUTPUT TO TTY
	MOVE T3,F4NHST		;GET THE HOST NUMBER
	GTHST			;OUTPUT THE HOST NAME
	 JSYSF			;HANDLE ERRORS
	MOVE T5,F4NSTS		;GET THE STATUS WORD
	HRROI T1,[ASCIZ/, Network/]
	TXNE T5,HS%NET		;NETWORK?
	 PSOUT			;YES SO OUTPUT IT
	HRROI T1,[ASCIZ/, Gateway/]
	TXNE T5,HS%GAT		;GATEWAY?
	 PSOUT			;YES SO OUTPUT IT
	HRROI T1,[ASCIZ/, Server/]
	TXNE T5,HS%SRV		;SERVER?
	 PSOUT			;YES SO OUTPUT IT
	HRROI T1,[ASCIZ/, User/]
	TXNE T5,HS%USR		;USER?
	 PSOUT			;YES SO OUTPUT IT
	HRROI T1,[ASCIZ/, Self/]
	TXNE T5,HS%SLF		;SELF?
	 PSOUT			;YES SO OUTPUT IT
	LDB T1,[POINTR T5,HS%STY] ;GET SYSTEM TYPE CODE
	CAILE T1,TYPMAX		;KNOWN NUMBER?
	 SETZ T1,		;NO
	JUMPE T1,HSTDM4		;IF NULL THEN RETURN
	HRRO T1,SYSTYP(T1)	;GET THE SYSTEM TYPE STRING
	MOVEM T1,SYSIDX		;SAVE THE INDEX
	TYPEN <, >		;DELIMIT
	MOVE T1,SYSIDX		;GET THE POINTER BACK
	PSOUT			;AND OUTPUT SYSTEM TYPE
HSTDM4:
	MOVE T5,F4NSTS		;GET THE STATUS WORD
	JE HS%VAL,T5,HSTDM7	;IS IT VALID?
	JE HS%UP,T5,HSTDM5	;YES, IS IT UP?
	TYPEN <, Up>		;YES, TELL THEM IT IS UP
	JRST HSTDM7		;AND DONT CHECK THE REST
HSTDM5:				;HERE TO CHECK FOR A REASON
	JN <HS%DAY!HS%HR!HS%MIN!HS%RSN>,T5,HSTDM8 ;DO WE KNOW ANYTHING ABOUT IT?
	TYPEN <, Down>		;NO
	JRST HSTDM7		;JOIN REST OF FLOW
HSTDM8:
	TYPEN <,>
	TYPE <  Down>		;TELL USER IT IS DOWN
	JE HS%RSN,T5,HSTDM6	;DO WE KNOW WHY?
	TYPEN <, >		;YES SO PROMPT THE OUTPUT
	LOAD T1,HS%RSN,T5	;GET THE REASON
	MOVE T1,RSN182(T1)	;GET THE REASON
	PSOUT%			;AND OUTPUT IT
HSTDM6:				;HERE TO CHECK FOR A POSSIBLE UP TIME
	LOAD T1,<HS%DAY!HS%HR!HS%MIN>,T5 ;GET THE WHEN CODE
	JUMPE T1,HSTDM7		;DO WE KNOW WHEN?
	CAIN T1,7777		;MORE THAN A WEEK?
	 JRST HSTDM9		;YES
	CAIN T1,7776		;UNSPECIFIED?
	 JRST HSDM11		;YES
	TYPEN <, Back up >	;LESS THAN A WEEK
	LOAD T1,HS%DAY,T5	;GET DAY BACK UP AGAIN
	CAILE T1,WEKMAX		;LEGIT DAY CODE?
	 JRST HSDM10		;NO
	HRRO T1,WEKDAY(T1)	;GET DAY OF WEEK STRING
	PSOUT%			;OUTPUT THE DAY OF THE WEEK
	JRST HSDM10		;JOIN FLOW
HSTDM9:				;HERE WHEN NOT UP FOR A LONG TIME
	TYPEN < Back up in more than a week>
	JRST HSTDM7		;JOIN FLOW
HSDM11:				;HERE WHEN UNSPECIFIED
	TYPEN < Back up time unknown>
	JRST HSTDM7
HSDM10:				;HERE AFTER DAY OF THE WEEK OUT
	TYPEN < >		;DELIMIT
	LDB T2,[POINTR T5,HS%HR] ;GET HOUR BACK UP
	NUMO T2,12		;OUTPUT THE HOUR
	TYPEN <:>
	LDB T2,[POINTR T5,HS%MIN] ;GET NUMBER OF INTERVALS
	IMULI T2,5		;MAKE MINUTES
	NUMOZ T2,12,2		;OUTPUT MINUTES
	TYPEN < GMT>		;OUTPUT THE TIMEZONE
HSTDM7:				;HERE AFTER STATUS STUFF
	RET			;WE ARE ALL DONE

	SUBTTL Monitor Symbol Support

	DEFINE LODSYM(NAME,MODULE),<
	SYMCNT==SYMCNT+1
	NAME: Z
	IF2 <RELOC SYMNAM+SYMCNT-1
	SQUOZE 0,NAME
	RELOC
	RELOC SYMODL+SYMCNT-1
	SQUOZE 0,MODULE
	RELOC>>
	SYMCNT==0

SYMVAL:	LODSYM GWTAB,STG	;TABLE OF SYMBOLS WE NEED
	LODSYM MAXGWA,IPIPIP

SYMNAM:	BLOCK SYMCNT		;SYMBOL NAMES
SYMODL:	BLOCK SYMCNT		;SYMBOL MODULES

SYMLOD:				;ROUTINE TO LOAD SYMBOLS
	TMNE F%SYML		;SYMBOLS LOADED?
	 RET			;YES
	MOVX T5,<-SYMCNT,,0>	;GET AOBJN POINTER
SYMLOP:
	MOVEI T1,.SNPSY		;LOOKUP SYMBOL FUNCTION
	MOVE T2,SYMNAM(T5)	;GET THE SYMBOL NAME
	MOVE T3,SYMODL(T5)	;GET THE MODULE NAME
	SNOOP% 			;LOOKUP THE MONITOR SYMBOL
	 JSYSF
	MOVEM T2,SYMVAL(T5)	;SAVE THE SYMBOL VALUE
	AOBJN T5,SYMLOP		;LOOP FOR ALL SYMBOLS
	SETONE F%SYML		;SYMBOLS ARE LOADED
	RET			;RETURN TO CALLER

MONRED:				;READ WORDS FROM THE MONITOR
	STKVAR <<XPKBLK,.XPUAD+1>>
	MOVEM T1,.XPUAD+XPKBLK	;SAVE THE DESTINATION ADDRESS
	MOVEM T2,.XPMAD+XPKBLK	;SAVE THE SOURCE ADDRESS
	MOVEM T3,.XPCN1+XPKBLK	;SAVE THE WORD COUNT
	MOVEI T1,XPKBLK		;GET THE ADDRESS OF THE BLOCK
	MOVEI T2,.XPUAD+1	;GET THE LENGTH OF THE ARG BLOCK
	MOVEM T2,.XPABL+XPKBLK	;SAVE THE BLOCK LENGTH
	MOVEI T2,.XPPEK		;GET THE FUNCTION CODE
	MOVEM T2,.XPFNC+XPKBLK	;SAVE THE FUNCTION CODE
	XPEEK%			;GET WORDS FROM THE MONITOR
	 JSYSF
	RET			;RETURN TO CALLER

	SUBTTL Information Command

.INFOR:				;INFORMATION COMMAND
	NOISE <ABOUT>		;HELP OUT THE USERS
	DOCMD .CMKEY,ICMDS,NETWORK ;ASK FOR A KEYWORD
	DODSP			;DISPATCH ON THE KEYWORD
	RET			;AND RETURN TO CALLER

.BSTAT:				;INFORMATION (ABOUT) BYPASS (STATUS)
	JE F%HOLY,,R		;NO OP IF NOT HOLY
	NOISE <STATUS>
	CNFIRM
	TYPE < Internet bypass is >
	MOVEI T1,.IPRIB		;READ BYPASS STATE
	IPOPR%			;GET THE BYPASS STATE
	 JSYSF
	HRROI T1,[ASCIZ/enabled/]
	SKIPN T2		;ENABLED?
	 HRROI T1,[ASCIZ/disabled/]
	PSOUT
	TYPE <>
	TYPE <>
	RET			;GET ANOTHER COMMAND

.GATEW:				;INFORMATION (ABOUT) GATEWAY (STATUS)
	JE F%HOLY,,PRVCMD	;NEED PRIVS
	CALL SYMLOD		;LOAD SYMBOLS IF NEEDED
	NOISE <STATUS>
	CNFIRM			;MAKE SURE THE USER WANTS THIS
	CALL GWYRPT		;DO THE GATEWAY REPORT
	RET			;AND RETURN TO CALLER

PRVCMD:				;HERE WHEN A PRIV'ED COMMAND WAS NOT FILTERED
	CALL NEWLIN		;NO
	TYPE <%This command requires priviledges.>
	TYPE <>
	TYPE <>
	RET			;JUST RETURN



.NETWO:				;INFORMATION (ABOUT) NETWORK 
	MOVEI T2,INTCFB		;GET THE CFB ADDRESS
	CALL .DOCMD		;DO THE COMND JSYS
	CAILE T2,NTFCNM		;NAMED NETWORK INTERFACE?
	 CAILE T2,NTFCNM+MXNETS+1 ;NAMED NETWORK INTERFACE?
	  JRST .NETW2		;NOT A NAMED INTERFACE
	HRRZ NT,0(T2)		;GET THE INTERFACE INDEX
	CNFIRM			;MAKE SURE THE USER WANTS THIS
.NETW1:				;OUTPUT INFORMATION ON A NETWORK
	CALL NETSTS		;OUTPUT THE STATUS FOR DESIRED NETWORK
	TYPE <>
	TYPE <>
	RET			

.NETW2:				;HERE WHEN NOT A NAMED INTERFACE
	DODSP			;DISPATCH ON THE KEYWORD
	RET			;GET THE NEXT COMMAND

.INTRF:				;INFORMATION NETWORK INTERFACE COMMAND
	NOISE <NUMBER>		;HELP OUT THE USER
	DOCMD .CMNUM,10,<0>	;GET THE INTERFACE NUMBER
	MOVE NT,T2		;SAVE THE NUMBER FOR A WHILE
	CNFIRM			;MAKE SURE USER WANTS THIS
	SKIPL NT		;IS INTERFACE NUMBER LEGIT?
	 CAML NT,MAXNET		;LEGIT NUMBER?
	  SKIPA			;NO
	   JRST .NETW1		;GO OUTPUT STATUS OF THIS INTERFACE
	TYPE <?No such interface>
	TYPE <>
	TYPE <>
	RET

.ALL:				;INFORMATION NETWORK ALL COMMAND
	NOISE <INTERFACES>
	CNFIRM			;MAKE SURE
	MOVN NT,MAXNET		;GET THE NUMBER OF INTERFACES
	HRLZS NT		;GET AOBJN POINTER
.ALL2:				;AOBJN LOOP
	CALL NETSTS		;OUTPUT STATUS ON THE NETWORK
	TYPE <>
	AOBJN NT,.ALL2		;LOOP FOR ALL INTERFACES
	TYPE <>
	RET			;GO GET ANOTHER COMMAND

	SUBTTL NETSTS - Routine to Output Network Status

NETSTS:				;OUTPUT NETWORK STATE
	STKVAR <<DCASTS,7>>
	MOVEI T1,.GTHNT		;GET NETWORK STATUS FUNCTION
	MOVE T2,LNETWN(NT)	;GET THE NETWORK NUMBER
	MOVEI T3,DCASTS		;GET ADDRESS OF THE FIRST WORD
	MOVSI T4,-7		;GET SEVEN WORDS OF STATUS
	GTHST%			;GET NETWORK STATUS
	 ERJMP NETSTE		;HANDLE THE ERROR
	TYPE <Interface #>
	MOVEI T2,(NT)		;GET THE INTERFACE INDEX
	NUMO T2,10,0		;OUTPUT THE INTERFACE INDEX
	TYPEN < for network >
	MOVE T1,LNETWN(NT)	;GET THE NETWORK NUMBER AGAIN
	CALL OCTETS		;OUTPUT THE ADDRESS
	HRROI T1,[ASCIZ/ is up/] ;ASSUME INTERFACE IS UP
	SKIPN 0+DCASTS		;INTERFACE DOWN?
	HRROI T1,[ASCIZ/ is down/] ;YES
	SKIPLE 0+DCASTS		;CYCLING?
	HRROI T1,[ASCIZ/ is cycling/] ;YES
	PSOUT			;OUTPUT THE NETWORK INTERFACE STATE
	TYPE <Interface output is >
	HRROI T1,[ASCIZ/enabled/] ;ASSUME OUTPUT ENABLED
	SKIPN 3+DCASTS		;OUTPUT DISABLED?
	HRROI T1,[ASCIZ/disabled/] ;YES
	PSOUT			;OUTPUT THE OUTPUT STATE
	TYPE <Network service is >
	HRROI T1,[ASCIZ/enabled/] ;ASSUME ENABLED INTERFACE
	SKIPN 1+DCASTS		;INTERFACE DISABLED?
	HRROI T1,[ASCIZ/disabled/] ;YES
	SKIPLE 1+DCASTS		;CYCLING
	HRROI T1,[ASCIZ/cycling/] ;YES
	PSOUT			;OUTPUT THE SERVICE STATE
	SKIPG 4+DCASTS		;GET NETWORK CYCLE TIME
	 JRST NETST2		;NO CYCLE TIME
	TYPE <Last interface cycle transition: >
	MOVEI T1,.PRIOU		;OUTPUT TO THE TTY
	MOVE T2,4+DCASTS	;GET THE CYCLE TIME
	SETZ T3,		;NORMAL FORMAT
	ODTIM%			;OUTPUT THE DATE AND TIME
	 JSYSF
NETST2:
	SKIPG 5+DCASTS		;GET NETWORK OFF TIME
	 JRST NETST3
	TYPE <Last network interface off transition: >
	MOVEI T1,.PRIOU		;OUTPUT TO THE TTY
	MOVE T2,5+DCASTS	;GET THE OFF TIME
	SETZ T3,		;NORMAL FORMAT
	ODTIM%			;OUTPUT THE DATE AND TIME
	 JSYSF
NETST3:
	SKIPG 6+DCASTS		;GET NETWORK ON TIME
	 RET			;AND RETURN
	TYPE <Last network interface up transition: >
	MOVEI T1,.PRIOU		;OUTPUT TO THE TTY
	MOVE T2,6+DCASTS	;GET THE ON TIME
	SETZ T3,		;NORMAL FORMAT
	ODTIM%			;OUTPUT THE DATE AND TIME
	 JSYSF
	RET

NETSTE:				;HERE ON AN ERROR FROM THE STATUS GTHST%
	TYPE <%No interface on that network>
	RET			;AND RETURN

	SUBTTL GWYRPT - Routine to Report Gateway Status

GWYRPT:				;GATEWAY REPORT
	STKVAR <GWYADR>
	MOVEI T1,GWYADR		;GATEWAY ADDRESS
	MOVE T2,GWTAB		;GET ADDRESS OF THE GATEWAY TABLE
	MOVEI T3,1		;ONE WORD
	CALL MONRED		;GET A WORD FROM THE MONITOR
	MOVN GW,MAXGWA		;GET THE NUMBER OF GATEWAYS
	HRLZS GW		;MAKE IT AN AOBJN POINTER
GWYRPL:				;GATEWAY REPORTING LOOP
	MOVEI T1,GWYBLK		;STORE INTO GATEWAY BLOCK AREA
	MOVE T2,GWYADR		;GET THE ADDRESS OF THE GATEWAY TABLE
	ADDI T2,(GW)		;ADD IN THE GATEWAY OFFSET
	MOVEI T3,1		;WE ONLY WANT ONE WORD
	CALL MONRED		;GET A WORD FROM THE MONITOR
	SKIPN GWYBLK		;DO WE HAVE A GATEWAY BLOCK ADDRESS?
	 JRST GWYRPX		;NO
				;WE FOUND A GATEWAY BLOCK
	MOVEI T1,GWYBLK		;STORE INTO GATEWAY BLOCK AREA
	MOVE T2,GWYBLK		;GET THE BLOCK ADDRESS
	MOVEI T3,GWBKSZ		;GET THE BLOCK SIZE
	CALL MONRED		;READ WORDS FROM THE MONITOR
	 			;WE HAVE A COPY OF THE GATEWAY BLOCK
	TYPE < Gateway No. >	
	HRRZ T2,GW		;GET THE GATEWAY NUMBER
	NUMO T2,12		;OUTPUT THE GATEWAY NUMBER
	TYPEN <. status is >
	HRROI T1,[ASCIZ/up/]	;ASSUME THE GATEWAY IS UP
	TMNN GWUP,+GWYBLK	;IS THE GATEWAY UP?
	 HRROI T1,[ASCIZ/down/]	;NO
	PSOUT			;OUTPUT THE GATEWAY STATE
	TYPEN <, type is >
	LOAD T1,GWTYP,+GWYBLK	;GET THE GATEWAY TYPE
	CAILE T1,GWYMAX		;KNOWN GATEWAY TYPE?
	 SETZ T1,		;NO SO UNKNOWN
	MOVE T1,GWYTBL(T1)	;GET THE TYPE STRING
	PSOUT			;OUTPUT THE GATEWAY TYPE
				;...

	SUBTTL GWYRPT Continued

				;...
	TYPEN <, successful pings >
	LOAD T2,GWSPC,+GWYBLK	;GET THE PING COUNT
	NUMO T2,12,0		;OUTPUT THE PING COUNT
	TYPEN <.>		;IT WAS DECIMAL OUTPUT
	TYPE < Connected Address >
	MOVE T1,.GWILS+GWYBLK	;GET THE CONNECTED ADDRESS
	CALL ADROUT		;OUTPUT THE ADDRESS
	MOVEI GL,GWYBLK+.GWILS+1 ;GET ADDRESS OF GATEWAY ADDRESSES
	HRLI GL,-MXGWIC		;MAKE AN AOBJN POINTER
GWYALP:				;GATEWAY ADDRESS LOOP
	SKIPN T1,(GL)		;GET THE ADDRESS
	 JRST GWYALX		;NO ADDRESS HERE
	TYPE < Alernate Address  >
	MOVE T1,(GL)		;GET THE ADDRESS
	CALL ADROUT		;OUTPUT THE ADDRESS
GWYALX:
	AOBJN GL,GWYALP		;LOOP FOR ALL ADDRESSES
	TYPE <>
GWYRPX:				
	AOBJN GW,GWYRPL		;LOOP FOR ALL GATEWAYS
	TYPE <>
	RET



GWYTBL:				;GATEWAY TYPES
	-1,,[ASCIZ/unknown/]
	-1,,[ASCIZ/prime/]
	-1,,[ASCIZ/dumb/]
	-1,,[ASCIZ/host/]
	-1,,[ASCIZ/always-up/]
	GWYMAX==.-GWYTBL

ADROUT:				;ADDRESS OUTPUT ROUTINE
	STKVAR <ADRHST>
	MOVEM T1,ADRHST		;SAVE THE HOST ADDRESS
	MOVE T5,[POINT 8,ADRHST,3] ;GET THE BYTE POINTER
	MOVEI T6,4		;FOUR BYTES
ADROUL:				;ADDRESS OUTPUT LOOP
	ILDB T2,T5		;GET A BYTE
	NUMO T2,12,0		;OUTPUT THE OCTET
	MOVEI T1,"."		;GET A DOT
	CAIE T6,1		;IS THIS THE LAST OCTET?
	 PBOUT			;NO SO OUTPUT THE DOT
	SOJG T6,ADROUL		;LOOP FOR ALL FOUR OCTETS
	TYPEN < (>		;PROMPT
	MOVEI T1,.GTHNS		;HOST NAME FUNCTION
	MOVEI T2,.PRIOU		;OUTPUT TO THE TTY
	MOVE T3,ADRHST		;GET THE HOST ADDRESS
	GTHST%			;OUTPUT THE HOST NAME
	 ERJMP ADROU2		;ASSUME NO HOST NAME IF NOT FOUND
	TYPEN <)>
	RET
ADROU2:				;HERE WHEN HOST NAME NOT FOUND
	TYPEN <unknown name)>
	RET			;AND RETURN TO CALLER

	SUBTTL Retrieve Command and Support Routines

.RETRI:				;RETRIEVE COMMAND
	TRVAR <RRBYT,RRHST,RRPRT,RRCMD,<RRBUF,<^D100/5+1>>>
	SETZRO F%FLT		;DO NOT NEED FILTERING
	DOCMD .CMKEY,RCMDS,<HOST> ;GET A KEYWORD
	DODSP			;DISPATCH ON THE KEYWORD
	RET			;RETURN FOR ANOTHER COMMAND

RRHOST:				;READ HOST NAME AND PORT PAIR
	NOISE <TABLE FROM>	;HELP OUT THE USER
	CALL HSTLOD		;GET HOST NAMES
	MOVEI T2,HSCFB3		;GET THE CFB ADDRESS
	CALL .DOCMD		;GET THE HOST NAME
	HRRZ T1,0(T2)		;GET THE INDEX
	MOVEI T1,.GTHHI		;HOST INDEX TO NUMBER TRANSLATION
	HRRZ T3,0(T2)		;GET THE INDEX
	GTHST%			;GET THE NUMBER
	 JSYSF
	MOVEM T3,RRHST		;SAVE THE HOST NUMBER
	NOISE <ON PORT>
	DOCMD .CMNUM,12,<101>	;GET THE PORT NUMBER
	MOVEM T2,RRPRT		;SAVE THE PORT NUMBER
	NOISE <INTO FILE>	;HELP OUT THE USER
	RET			;RETURN TO THE CALLER

RHOSTF:				;HERE TO GET THE FILE JFN OPEN
	MOVEM T2,RTRJFN		;SAVE THE JFN
	SETONE F%ROJ		;FLAG THAT THE JFN IS ASSIGNED
	CNFIRM			;MAKE SURE
	MOVE T1,RTRJFN		;GET THE JFN
	MOVX T2,<7B5!OF%WR>	;WE WANT TO WRITE THIS FILE
	OPENF%			;OPEN UP THE FILE FOR IO
	 JSYSF
	SETONE F%ROO		;JFN IS OPEN
	SETZRO F%ROJ		;RESET JFN IS ASSIGNED
	RET			;RETURN TO THE CALLER

RHOSTC:				;HERE TO CLOSE UP THE FILE
	MOVE T1,RTRJFN		;GET THE JFN
	CLOSF%			;CLOSE THE FILE
	 JSYSF
	SETZRO F%ROO		;JFN IS NO LONGER OPEN
	RET			;AND GET ANOTHER COMMAND


	SUBTTL Retrieve Command Subcommands

.RHOST:				;RETRIEVE HOST (TABLE)
	CALL RRHOST		;GET THE HOST NUMBER AND PORT
	DOCMD .CMOFI,,<HOSTS.TXT> ;GET A FILE TO OUTPUT INTO
	CALL RHOSTF		;GO OPEN UP THE FILE
	HRROI T1,[ASCIZ/ALL/]	;COMMAND TO SEND TO THE NIC
	MOVEM T1,RRCMD		;SAVE THE NIC COMMAND POINTER
	SETONE F%FLT		;WE NEED FILTERING
	CALL NICRED		;READ IN THE FILE
	CALL RHOSTC		;CLOSE THE FILE
	RET			;AND GET NEXT COMMAND

.RGATE:				;RETRIEVE GATEWAY (TABLE)
	CALL RRHOST		;GET THE HOST NUMBER AND PORT
	DOCMD .CMOFI,,<INTERNET.GATEWAYS> ;GET A FILE TO OUTPUT INTO
	CALL RHOSTF		;GO OPEN UP THE FILE
	HRROI T1,[ASCIZ/ALL-INGWAY/] ;COMMAND TO SEND TO THE NIC
	MOVEM T1,RRCMD		;SAVE THE NIC COMMAND POINTER
	CALL NICRED		;READ IN THE FILE
	CALL RHOSTC		;CLOSE THE FILE
	RET			;AND GET NEXT COMMAND

.ROHST:				;RETRIEVE OLD-HOST (TABLE)
	CALL RRHOST		;GET THE HOST NUMBER AND PORT
	DOCMD .CMOFI,,<HOSTS.TXT> ;GET A FILE TO OUTPUT INTO
	CALL RHOSTF		;GO OPEN UP THE FILE
	HRROI T1,[ASCIZ/ALL-OLD/] ;COMMAND TO SEND TO THE NIC
	MOVEM T1,RRCMD		;SAVE THE NIC COMMAND POINTER
	SETONE F%FLT		;WE NEED FILTERING
	CALL NICRED		;READ IN THE FILE
	CALL RHOSTC		;CLOSE THE FILE
	RET			;AND GET NEXT COMMAND

	SUBTTL Retrieve Command TCP Routines

NICRED:				;ROUTINE TO OPEN A TCP CONNECTION TO THE NIC
	STKVAR <NICRP,NICRC>
	CALL TCPGTJ		;GET THE TCP JFN
	CALL TCPOPN		;OPEN THE TCP CONNECTION
	CALL TCPSND		;SEND THE COMMAND
	TYPE < [ Receiving TCP data >
	SETZRO F%BIN		;INITIAL RETRIEVE BUFFER NOT READ
NICRD0:				;READ LOOP
	MOVE T1,TCPJFN		;GET THE NETWORK JFN
	MOVX T2,<POINT 7,TCPBUF> ;GET THE INITIAL POINTER
	MOVEM T2,NICRP		;SAVE THE POINTER
	MOVNI T3,<5*^D512>	;ASK FOR A PAGE OF DATA
	MOVEM T3,NICRC		;SAVE THE COUNT
	SIN%			;READ IN A PAGE OF DATA
	 ERJMP NICRD3		;HERE WHEN WE GET AN ERROR
	JE F%FLT,,NICRD2	;NEED FILTERING?
	JN F%BIN,,NICRD2	;YES.  ALLREADY READ FIRST BUFFER?
NICRD1:				;REMOVE PREFIX LOOP
	AOS NICRC		;FIX THE COUNT BY ONE
	ILDB T1,NICRP		;GET A BYTE
	CAIE T1,":"		;GOT A COLON?
	 JRST NICRD1		;NO SO KEEP GOING
NICRD2:				;HERE TO OUTPUT THE BUFFER
	MOVE T1,RTRJFN		;GET THE RETRIEVE FILE JFN
	MOVE T2,NICRP		;SOURCE POINTER
	MOVE T3,NICRC		;ASK FOR A PAGE OF DATA
	SOUT%			;DUMP IT TO THE FILE
	 JSYSF
	TYPEN <.>		;TELL USER WE ARE STILL DOING WORK
	SETONE F%BIN		;INITIAL RETRIEVE BUFFER NOW READ
	JRST NICRD0		;LOOP IT UNTIL DONE
NICRD3:				;HERE WHEN WE GOT A READ ERROR
	JE F%FLT,,NICRD6	;FILTERING?
	JE F%BIN,,NICRD6	;PREFIX FILTERED?
NICRD4:				;SUFFIX COLON SEARCHING LOOP
	LDB T1,T2		;GET A BYTE
	CAIN T1,":"		;IS IT A COLON?
	 JRST NICRD5		;YES
	SETO T1,		;GET A -1
	EXCH T1,T2		;SWITCH ACS
	IBP T2,T1		;BACKUP THE BYTE POINTER ONE BYTE
	AOSGE NICRC		;FIX UP THE COUNT
	 JRST NICRD4		;KEEP LOOKING FOR THE COLON
	JRST NICRD6		;HERE WHEN NO COLON FOUND
NICRD5:				;SUFFIX LF SEARCH LOOP
	LDB T1,T2		;GET A BYTE
	CAIN T1,"J"-100		;LINE FEED?
	 JRST NICRD6		;YES
	SETO T1,		;GET A -1
	EXCH T1,T2		;SWITCH ACS
	IBP T2,T1		;BACKUP THE BYTE POINTER ONE BYTE
	AOSGE NICRC		;FIX UP THE COUNT
	 JRST NICRD5		;KEEP LOOKING FOR THE COLON
NICRD6:				;HERE TO OUTPUT THE LAST BUFFER
	MOVE T1,RTRJFN		;GET THE RETRIEVE JFN
	MOVN T2,NICRC		;GET THE COUNT WE TRIED TO READ
	ADD T3,T2		;HOW MANY BYTES DID WE READ?
	MOVE T2,NICRP		;SOURCE POINTER
	SKIPE T3		;DID WE READ ANY?
	 SOUT%			;YES SEND THEM OUT
	  JSYSF			;GET ANY OUTPUT ERRORS
	TYPEN < ] [OK]>
	CALL TCPCLS		;CLOSE THE TCP CONNECTION
	TYPE <>
	TYPE <>
	RET			;AND RETURN

	SUBTTL Retrieve Command TCP Routines Continued

TCPSND:				;SEND THE COMMAND TO THE NIC
	MOVE T1,TCPJFN		;GET THE JFN
	MOVE T2,RRCMD		;GET THE COMMAND STRING
	SETZB T3,T4		;ASCIZ
	SOUT%			;SEND THE COMMAND TO THE NIC
	 JSYSF
	HRROI T2,[ASCIZ/
/]				;GET A CRLF
	SOUTR%			;FORCE THE BUFFER OUT
	 JSYSF
	RET			;AND RETURN

TCPERR:				;HERE ON TCP OPENF AND CLOSF ERRORS
	TYPEN < [ Failed:  >	;PROMPT ERROR STRING
	MOVEI T1,.PRIOU		;OUTPUT TO TTY
	MOVX T2,<.FHSLF,,-1>	;MY LAST ERROR
	SETZB T3,T4		;NO FUNNY LIMITS
	ERSTR			;OUTPUT THE ERROR STRING
	 NOERR			;HANDLE ANY ERRORS
	 NOERR			;HANDLE ANY ERRORS
	TYPEN < ]>
	TYPE <>
	TYPE <>
	JRST GETCMD		;GET ANOTHER COMMAND



TCPGTJ:				;HERE TO GTJFN THE TCP CONNECTION
	HRROI T1,RRBUF		;GET INITIAL GTJFN STRING ADDRESS
	HRROI T2,[ASCIZ/TCP:./]	;DEVICE NAME
	SETZB T3,T4		;PLAIN ASCIZ
	SOUT%			;APPEND THE STRING
	 JSYSF
	MOVE T2,RRHST		;GET THE HOST NUMBER
	MOVEI T3,10		;IN OCTAL
	NOUT%			;APPEND THE HOST NUMBER
	 JSYSF
	MOVEI T2,"-"		;GET THE SEPARATOR
	IDPB T2,T1		;APPEND THE SEPARATOR
	MOVE T2,RRPRT		;GET THE PORT NUMBER
	MOVEI T3,12		;IN DECIMAL
	NOUT%			;APPEND THE PORT NUMBER
	 JSYSF
	HRROI T2,[ASCIZ/;CONNECTION:ACTIVE;PERSIST:10;TIMEOUT:10/] ;GET ATRIBUTES
	SETZB T3,T4		;ASCIZ
	SOUT%			;APPEND THE ATTRIBUTES
	 JSYSF
	MOVX T1,GJ%SHT		;SHORT MODE GTJFN
	HRROI T2,RRBUF		;GET THE STRING ADDRESS
	GTJFN%			;GET THE NETWORK JFN
	 JSYSF
	SETONE F%TOJ		;FLAG THAT TCP JFN EXISTS
	MOVEM T1,TCPJFN		;SAVE THE JFN
	RET

TCPOPN:				;HERE TO OPEN THE TCP CONNECTION
	TYPE < [ Opening TCP connection ]>
	MOVE T1,TCPJFN		;GET THE JFN
	MOVX T2,<10B5!<.TCMWI>B9!OF%RD!OF%WR> ;GET OPENF FLAGS
	OPENF%			;OPEN UP THE CONNECTION
	 ERJMP TCPERR
	SETONE F%TOO		;FLAG THAT TCP JFN IS OPEN
	SETZRO F%TOJ		;FLAG THAT TCP JFN IS NOT JUST GTJFN'ED
	TYPEN < [OK]>		;FLAG SUCCESS
	RET			;RETURN TO CALLER

TCPCLS:				;HERE TO CLOSE THE TCP CONNECTION
	TYPE < [ Closing TCP connection ]>
	MOVE T1,TCPJFN		;GET THE TCP JFN
	CLOSF%			;CLOSE THE CONNECTION
	 ERJMP TCPERR
	TYPEN < [OK]>
	SETZRO F%TOO		;FLAG THAT IT IS CLOSED
	RET

	ENDTV.

	SUBTTL Ethernet Command

.ETHER:				;ETHERNET COMMAND
	DOCMD .CMKEY,ECMDS	;GET A SUBCOMMAND
	DODSP			;DISPATCH ON THE COMMAND
	RET			;RETURN TO CALLER

E.INIT:				;ETHERNET INITIALIZE COMMAND
	NOISE <ADDRESS MAPPING FILE>
	CNFIRM			;MAKE SURE
	MOVEI T1,.IPIGH		;GET THE FUNCTION CODE
	IPOPR%			;RELOAD THE ETHERNET MAPPING FILE
	 JSYSF			;HANDLE ERRORS
	RET			;GET ANOTHER COMMAND

E.ARP:				;ETHERNET ARP COMMAND
	STKVAR <EARPT>
	NOISE <PROTOCOL IS>
	DOCMD .CMKEY,EACMDS,ENABLED ;FIND OUT WHAT THE USER WANTS
	HRRZ T2,0(T2)		;GET THE FLAG
	MOVEM T2,EARPT		;SAVE THE FLAG
	CNFIRM			;MAKE SURE THE USER WANTS THIS
	MOVEI T1,.IPNAP		;GET THE FUNCTION CODE
	MOVE T2,EARPT		;GET WHAT THE USER WANTED
	IPOPR%			;ENABLE OR DISABLE ARP ON THE NI
	 JSYSF			;HANDLE ERRORS
	RET			;GET ANOTHER COMMAND

E.IP:				;ETHERNET IP COMMAND
	STKVAR <IPPT>
	NOISE <PROTOCOL IS>
	DOCMD .CMKEY,EACMDS,ENABLED ;FIND OUT WHAT THE USER WANTS
	HRRZ T2,0(T2)		;GET THE FLAG
	MOVEM T2,IPPT		;SAVE THE FLAG
	CNFIRM			;MAKE SURE THE USER WANTS THIS
	MOVEI T1,.IPNIP		;GET THE FUNCTION CODE
	MOVE T2,IPPT		;GET WHAT THE USER WANTED
	IPOPR%			;ENABLE OR DISABLE IP ON THE NI
	 JSYSF			;HANDLE ERRORS
	RET			;GET ANOTHER COMMAND

	SUBTTL ETHERNET STATUS Command

E.STAT:				;ETHERNET STATUS COMMAND
	NOISE <INFORMATION>
	CNFIRM			;MAKE SURE
	CALL NIRCI		;READ AND REPORT CHANNEL INFORMATION
	TYPE <>
	CALL NIRCC		;READ CHANNEL COUNTERS
	CALL NIRPL		;GET THE PORTAL LIST
IFN BUGGY,<
	MOVX PT,<<-MXPTYP>,,1>	;INITIALIZE THE AOBJN POINTER
ESTAT2:				;PORTAL SCANNING LOOP
	SKIPN NIPTYP(PT)	;PORTAL OPEN?
	IFSKP.			;YES
	   TYPE <>		;EXTRA CRLF
	   CALL NIRPC		;READ PORTAL COUNTERS
	ENDIF.
	AOBJN PT,ESTAT2		;FOR FOR ALL PROTOCOL TYPES
>
	TYPE <>
	TYPE <>
	RET			;AND RETURN

	SUBTTL Ethernet Read Channel Info

NIRCI:				;READ CHANNEL INFORMATION
	STKVAR <<NRCIB,.EIHRD+2>>
	MOVEI T1,1+NRCIB       	;GET ADDRESS OF BLOCK
	HRLI T1,NRCIB		;MAKE IT A BLT AC
	SETZM NRCIB		;ZERO THE FIRST WORD
	BLT T1,.EIAR2+NRCIB	;ZERO THE REST OF THE WORDS
	MOVX T1,<.EIHRD+2,,.EIRCI> ;GET THE FUNCTION CODE
	MOVEM T1,NRCIB		;SET IT IN THE BLOCK
	MOVEI T1,NRCIB		;GET THE ARG BLOCK ADDRESS
	NI%			;GET THE INFORMATION FROM THE MONITOR
	 JSYSF
	TYPE < Current channel state is: >
	MOVE T1,.EISTA+NRCIB  	;GET THE CHANNEL STATE
	ANDX T1,<EI%EXS>	;GET THE VALID BITS ONLY
	CAILE T1,NISTMX		;KNOWN STATE?
	 SETZ T1,		;NO
	MOVE T1,NISTAT(T1)	;GET THE STATUS STRING
	PSOUT%			;OUTPUT CHANNEL STATE
	TYPE < Current channel address:  >
	DMOVE T1,.EIPHY+NRCIB	;GET THE ADDRESS
	CALL HEXOUT		;OUTPUT THE ADDRESS IN HEX
	TYPE < Hardware channel address: >
	DMOVE T1,.EIHRD+NRCIB	;GET THE HARDWARE ADDRESS
	CALL HEXOUT		;OUTPUT IT ALSO
	RET			;AND RETURN

	SUBTTL Ethernet Read Channel Counters

NIRCC:				;READ CHANNEL COUNTERS
	SAVEAC <T5>
	STKVAR <<NRCCB,<.EIAR2+1>>,<NRCCD,<.ECUBU+1>>>
	MOVEI T1,1+NRCCB       	;GET ADDRESS OF BLOCK
	HRLI T1,NRCCB		;MAKE IT A BLT AC
	SETZM NRCCB		;ZERO THE FIRST WORD
	BLT T1,.EIAR2+NRCCB	;ZERO THE REST OF THE WORDS
	MOVX T1,<<.EIAR2+1>,,.EIRCC> ;GET THE FUNCTION CODE
	MOVEM T1,0+NRCCB	;SET IT
	MOVEI T1,.ECUBU		;GET THE BUFFER SIZE
	MOVEM T1,.EIAR1+NRCCB	;SET IT
	MOVEI T1,NRCCD		;GET THE BUFFER ADDRESS
	MOVEM T1,.EIAR2+NRCCB	;SET IT
	MOVEI T1,NRCCB		;GET THE ARG BLOCK ADDRESS
	NI%			;GET THE DATA FROM MONITOR
	 JSYSF
	MOVEI T5,1+NRCCD	;GET THE DATA ADDRESS
	MOVSI T5,<-.ECUBU>	;MAKE IT AN AOBJN POINTER
NIRCCL:				;THIS IS THE LOOP
	SKIPN T1,NICONT(T5)	;GET THE DESCRIPTOR STRING
	IFSKP.
	   TYPE < >		;NEW LINE
	   HRRO T1,NICONT(T5)	;MAKE IT A BYTE POINTER
	   PSOUT%		;OUTPUT THE STRING
	    JSYSF
	   MOVEI T2,1+NRCCD	;GET THE DATA ITEM ADDRESS
	   ADDI T2,(T5)		;ADD IN THE AOBJN POINTERR
	   MOVE T2,(T2)    	;GET THE DATA ITEM
	   NUMO T2,12		;OUTPUT THE ITEM IN DECIMAL
	ENDIF.
	AOBJN T5,NIRCCL		;LOOP FOR ALL ITEMS
				;...


				;...
	SKIPN .ECSFM+NRCCD	;AND SEND FAILURE BITS?
	SKIPE .ECRFM+NRCCD	;OR ANY RECEIVE FAILURE BITS?
	IFNSK.			;YES
	   TYPE <>		;DO AN EXTRA CRLF
	ENDIF.
	SKIPN T5,.ECSFM+NRCCD	;SEND FAILURES?
	IFSKP.			;YES
	   TYPE < Send failures due to: >
	   MOVEI T1,NISFAL	;GET FAILURE MASK STRINGS
	   MOVEI T2,<POS(EC%LOC)> ;GET THE FIRST BIT POSITION
	   MOVEI T3,<POS(EC%LOC)+NISFMX> ;GET THE LAST BIT POSITION
	   CALL NIRMSK		;OUTPUT THE MASK BITS
	ENDIF.
	SKIPN T5,.ECRFM+NRCCD	;RECEIVE FAILURES?
	IFSKP.			;YES
	   TYPE < Receive failures due to: >
	   MOVEI T1,NIRFAL	;GET FAILURE MASK STRINGS
	   MOVEI T2,<POS(EC%FLE)> ;GET THE FIRST BIT POSITION
	   MOVEI T3,<POS(EC%FLE)+NIRFMX> ;GET THE LAST BIT POSITION
	   CALL NIRMSK		;OUTPUT THE MASK BITS
	ENDIF.
	RET			;AND RETURN TO CALLER
	ENDSV.



NIRMSK:				;ROUTINE TO OUTPUT FAILURE BIT MASKS
	STKVAR <NRMSB,NRMSL,NRMSS> ;T5 HAS THE MASK, T1 HAS ADR OF STRINGS
	SETZRO F%ES1		;RESET THE FLAG
	SUB T1,T2		;MAKE IT SO WE CAN USE DIRECT OFFSETS
	MOVEM T1,NRMSS		;SAVE THE STRING ADDRESS
	MOVEM T2,NRMSB		;SAVE THE FIRST BIT POSITION
	MOVEM T3,NRMSL		;SAVE THE LAST BIT POSITION
	MOVE T1,NRMSB		;GET THE FIRST BIT
NIRMLP:				;THIS IS THE LOOP
	MOVE T1,T5		;GET THE BIT MASK
	JFFO T1,NIRML2		;DID WE FIND A BIT SET?
	RET			;NO SO RETURN
NIRML2:				;HERE WHEN WE FOUND A BIT
	MOVE T1,BITS(T2)	;GET THE BIT MASK
	TDZ T5,T1		;TURN OFF THE BIT IN QUESTION
	CAML T2,NRMSB		;IS THE BIT WITHIN RANGE?
	CAMG T2,NRMSL		;?
	IFNSK.			;HERE WHEN WITHIN RANGE
	   TMNN F%ES1		;IS THE FLAG ON?
	   IFSKP.		;YES
	      BLOCK.
	         SAVEAC <T1,T2,T3,T4>
	         TYPEN <, >    	;TYPE OUT A DELIMITOR
	      ENDBK.
	   ENDIF.
	   SETONE F%ES1		;SET THE FLAG
	   MOVE T1,NRMSS       	;GET ADDRESS OF THE STRING TABLE
	   ADDI T1,(T2)		;GET THE OFFSET
	   MOVE T1,(T1)		;GET THE STRING
	   PSOUT%	       	;AND OUTPUT IT
	    JSYSF
	ENDIF.
	JRST NIRMLP		;DO THE NEXT BIT
	ENDSV.

	SUBTTL Ethernet Read Portal Stuff

NIRPL:				;READ PROTOCOL LIST
	SETZM NIPTYP		;ZERO THE FIRST WORD
	MOVX T1,<NIPTYP,,NIPTYP+1> ;GET THE BLT AC
	BLT T1,NIPTYP+MXPTYP	;ZERO THE WHOLE BLOCK
	STKVAR <<NRPLB,<.EIAR2+1>>>       
	MOVEI T1,1+NRPLB       	;GET ADDRESS OF BLOCK
	HRLI T1,NRPLB		;MAKE IT A BLT AC
	SETZM NRPLB		;ZERO THE FIRST WORD
	BLT T1,.EIAR2+NRPLB	;ZERO THE REST OF THE WORDS
	MOVX T1,<<.EIAR2+1>,,.EIRPL> ;GET THE FUNCTION CODE
	MOVEM T1,0+NRPLB	;SET IT
	MOVX T1,<EI%GBL>	;GET THE GLOBAL FLAG BIT
	MOVEM T1,.EIFLG+NRPLB	;SET IT
	MOVEI T1,MXPTYP		;GET THE BUFFER LENGTH
	MOVEM T1,.EIAR1+NRPLB	;SET IT
	MOVEI T1,NIPTYP		;GET THE BUFFER ADDRESS
	MOVEM T1,.EIAR2+NRPLB	;SET IT
	MOVEI T1,NRPLB		;GET THE ARG BLOCK ADDRESS
	NI%			;GET THE PORTAL LIST
	 JSYSF
	RET			;RETURN TO CALLER
	ENDSV.

NIRPC:				;READ PORTAL COUNTERS
	STKVAR <<NRPCB,<.EIAR2+1>>,<NRPCD,<.EPUBU+1>>>
	MOVEI T1,1+NRPCB       	;GET ADDRESS OF BLOCK
	HRLI T1,NRPCB		;MAKE IT A BLT AC
	SETZM NRPCB		;ZERO THE FIRST WORD
	BLT T1,.EIAR2+NRPCB	;ZERO THE REST OF THE WORDS
	MOVX T1,<<.EIAR2+1>,,.EIRPC> ;GET THE FUNCTION CODE
	MOVEM T1,0+NRPCB	;SET IT
	HRRZ T1,NIPTYP(PT)	;GET THE PORTAL ID
	TXO T1,<EI%GBL>		;GET THE GLOBAL FLAG BIT
	MOVEM T1,.EIFLG+NRPCB	;SET IT
	HLRZ T1,NIPTYP(PT)	;GET THE JOB NUMBER
	MOVEM T1,.EIJOB+NRPCB	;SET IT
	MOVEI T1,.EPUBU		;GET THE BUFFER SIZE
	MOVEM T1,.EIAR1+NRPCB	;SET IT
	MOVEI T1,NRPCD		;GET THE BUFFER ADDRESS
	MOVEM T1,.EIAR2+NRPCB	;SET IT
	MOVEI T1,NRPCB		;GET THE ARG BLOCK ADDRESS
	NI%			;GET THE DATA FROM MONITOR
	 JSYSF
	MOVEI T5,1+NRPCD	;GET THE DATA ADDRESS
	MOVSI T5,<-.EPUBU>	;MAKE IT AN AOBJN POINTER
NIRPCL:				;THIS IS THE LOOP
	TYPE < >		;NEW LINE
	HRRO T1,PICONT(T5)	;MAKE IT A BYTE POINTER
	PSOUT%			;OUTPUT THE STRING
	 JSYSF
	MOVEI T2,1+NRPCD	;GET THE DATA ITEM ADDRESS
	ADDI T2,(T5)		;ADD IN THE AOBJN POINTERR
	MOVE T2,(T2)    	;GET THE DATA ITEM
	NUMO T2,12		;OUTPUT THE ITEM IN DECIMAL
	AOBJN T5,NIRPCL		;LOOP FOR ALL ITEMS
	RET			;AND RETURN TO CALLER
	ENDSV.

	SUBTTL Build Command

.BUILD:				;BUILD COMMAND
	NOISE <ETHERNET MAPPINGS FROM>
	DOCMD .CMIFI,,<SYSTEM:INTERNET-ETHERNET-MAPPINGS.TXT>
	MOVEM T2,BLDIJF		;SAVE THE JFN
	SETONE F%BIJ		;INPUT JFN EXISTS
	MOVE T1,BLDIJF		;GET THE JFN
	MOVX T2,<7B5!OF%RD>	;WE WANT TO READ THIS FILE
	OPENF%			;OPEN IT UP
	 JSYSC			;HANDLE ERROR LIKE A COMMAND ERROR
	SETONE F%BIO		;INPUT JFN IS OPEN
	SETZRO F%BIJ		;SO TURN OFF THIS
	NOISE <TO>
	DOCMD .CMOFI,,<SYSTEM:INTERNET-ETHERNET-MAPPINGS.BIN>
	MOVEM T2,BLDOJF		;SAVE THE OUTPUT JFN
	SETONE F%BOJ		;OUTPUT JFN EXISTS
	MOVE T1,BLDOJF		;GET THE OUTPUT JFN
	MOVX T2,<44B5!OF%WR>	;WE WANT TO WRITE THIS FILE
	OPENF%			;OPEN UP THE OUTPUT FILE FOR IO
	 JSYSC			;HANDLE ERROR LIKE A COMMAND ERROR
	SETONE F%BOO		;OUTPUT JFN IS OPEN
	SETZRO F%BOJ		;SO TURN OFF THIS
	CNFIRM
	CALL IPNIRD		;READ THE FILE
	 RET			;ERROR RETURN
	SETZRO F%BIO		;FLAG THAT INPUT IS NO LONGER OPEN
	MOVE T1,BLDIJF		;GET THE INPUT JFN
	CLOSF%			;CLOSE IT
	 JSYSF			;HANDLE ERROR
	CALL IPNIWR		;WRITE THE NEW FILE
	SETZRO F%BOO		;FLAG THAT OUTPUT IS NO LONGER OPEN
	MOVE T1,BLDOJF		;GET THE OUTPUT JFN
	CLOSF%			;CLOSE IT
	 JSYSF
	RET			;AND RETURN TO CALLER

	SUBTTL Ethernet Mapping Text File COMND Processing

.BOCMD:				;HERE FROM DOCMDB MACRO
	MOVEI T1,BCSB		;GET ADDRESS OF COMND STATE BLOCK
	COMND		 	;DO THE JSYS
	 ERJMP BOCMD2		;HANDLE REAL BAD ERRORS
	JE CM%NOP,T1,R		;IF NOT A NO PARSE THEN WE ARE DONE
BOCMD2:				;HERE ON ERROR OR NOPARSE
	MOVEI T1,.FHSLF		;THIS FORK
	GETER%			;GET THE ERROR CODE
	HRRZS T2		;ZERO THE RIGHT HALF
	CAIN T2,IOX4		;EOF?
	 JRST BPFEOF		;YES
	CALL NEWLIN		;UH OH...GET A NEW LINE
	TYPEN <?Command error processing mapping input file>
	TYPE <?>
	MOVEI T1,.PRIOU		;OUTPUT TO TTY
	MOVX T2,<.FHSLF,,-1>	;MY LAST ERROR
	SETZB T3,T4		;NO FUNNY LIMITS
	ERSTR			;OUTPUT THE ERROR STRING
	 NOERR			;HANDLE ERRORS
	 NOERR			;HANDLE ERRORS
	TYPE <?>
	HRROI T1,BXTBUF		;GET A POINTER TO THE TEXT BUFFER
	PSOUT%			;OUTPUT THE TEXT BUFFER
	SETONE F%BERR		;SET THE ERROR FLAG
	JRST IPNIR3

	SUBTTL Ethernet Mapping Text File Parsing

IPNIRD:				;HERE TO READ THE TEXT FILE
	MOVEM P,BUILDP		;SAVE THE STACK POINTER
	JN F%BULD,,IPNIR2	;INITED BCSB YET?
	MOVX T1,<BCSBV,,BCSB>	;NO SO GET A BLT AC
	BLT T1,BCSB+BCSBSZ-1	;INIT THE CSB
	SETONE F%BULD		;FLAG THAT WE HAVE DONE THIS
IPNIR2:				;HERE WHEN BCSB INITED...INIT THE ENTRY QUEUE
	MOVEI T1,LNKHED		;GET INITIAL VALUE FOR QUEUE HEAD POINTER
	MOVEM T1,LNKHED		;AND SAVE IT
	MOVEI T1,LNKSTG		;GET FIRST STORAGE LOCATION
	MOVEM T1,LNKFST		;AND SAVE IT IN PROPER PLACE
				;FIX THE CSB FOR INPUT FROM THE JFN
	HRLZ T1,BLDIJF		;GET THE INPUT JFN
	HRRI T1,.NULIO		;NO OUTPUT
	MOVEM T1,BCSB+.CMIOJ	;SAVE THE IO DESIGNATORS
	SETZRO F%BERR		;RESET BUILD ERROR FLAG
IPNIR3:				;HERE TO GET A COMMAND
	MOVE P,BUILDP		;REFRESH THE STACK
	JN F%BERR,,R		;ERROR RETURN
	DOCMDB .CMINI		;START UP A COMMAND
BPARSE:				;REPARSE ADDRESS
	MOVE P,BUILDP		;REFRESH THE STACK
	DOCMDB .CMKEY,BCMDS	;GET A KEYWORD
	DODSP			;DISPATCH ON THE KEYWORD
	JE F%BERR,,IPNIR3	;IF NO ERROR GET ANOTHER COMMAND
	RET			;NON SKIP...ERROR RETURN

BPFEOF:				;HERE WHEN WE FOUND THE EOF
	MOVE P,BUILDP		;FIX UP THE STACK
	JE F%BERR,,RSKP		;SUCCESS RETURN IF NO ERROR
	RET			;OTHERWISE ERROR RETURN

	SUBTTL Ethernet Mapping File Processing - HOST Command

.HOST:				;HERE ON THE HOST COMMAND
	TRVAR <BHSTFL,BHSTIA,<BHSTHX,2>>
	SETZM BHSTFL		;ZERO OUT THE FLAG WORD
	SETZM BHSTIA		;ZERO OUT THE INTERNET ADDRESS
	SETZM BHSTHX		;ZERO OUT THE HEX NUMBER
	SETZM 1+BHSTHX		;ZERO OUT THE HEX NUMBER
	MOVEI T5,5		;READ SIX HEX OCTETS
	MOVX T6,<POINT 8,BHSTHX> ;GET THE BYTE POINTER
.HOST2:				;OCTET READING LOOP
	DOCMDB .CMFLD,,,,HEXBRK	;READ IN THE OCTET
	MOVX T1,<POINT 7,BTMBUF> ;GET THE POINTER
	CALL HEXRED		;READ HEX FROM THE ATOM BUFFER
	 JRST .HOST3		;ERROR READING HEX
	IDPB T1,T6		;DEPOSIT THE OCTET
	JUMPE T5,.HOST4		;IF LAST BYTE WE ARE DONE
	DOCMDB .CMTOK,<-1,,[ASCIZ/-/]> ;GET A HYPHEN
	SOJA T5,.HOST2		;GO READ THE NEXT OCTET
.HOST3:				;HERE ON AN ERROR READING HEX
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?Command error reading HEX Ethernet address.  Build aborted.>
	TYPE <?>
	HRROI T1,BXTBUF		;GET A POINTER TO THE TEXT BUFFER
	PSOUT%			;OUTPUT THE TEXT BUFFER
	SETONE F%BERR		;SET THE ERROR FLAG
	JRST IPNIR3		;ABORT THE READ

.HOST4:				;HERE TO GET THE INTERNET PORTION OF ADR
	MOVEI T5,3		;FOUR OCTETS
	MOVX T6,<POINT 8,BHSTIA,3> ;GET THE TARGET POINTER
.HOST5:				;OCTET READING LOOP
	DOCMDB .CMNUM,12	;GET A DECIMAL OCTET
	IDPB T2,T6		;DEPOSIT THE OCTET
	JUMPE T5,.HOST6		;DO WE HAVE ALL THE OCTETS?
	DOCMDB .CMTOK,<-1,,[ASCIZ/./]> ;NO SO PARSE A DOT
	SOJA T5,.HOST5		;KEEP READING IN OCTETS
.HOST6:				;HERE WHEN WE HAVE ALL THE OCTETS
	MOVEI T2,HSWCFB		;GET THE CFB WE WANT
	CALL .BOCMD		;GET A SWITCH OF A CONFIRM
	HRRZS T3		;ZERO THE LEFT HALF
	LDB T3,[POINT 9,(T3),8]	;GET THE FUNCTION CODE
	CAIN T3,.CMCFM		;WAS IT A CONFIRM?
	 JRST .HOST7		;YES
	DODSP			;NO SO DISPATCH ON THE SWITCH
	JRST .HOST6		;AND LOOP UNTIL A CONFIRM OR ERROR

.HOST7:				;HERE WHEN THE LINE IS CONFIRMED
	CALL ADDENT		;STORE THE ENTRY (RETURNS T1)
	CALL QUEENT		;QUEUE UP THE ENTRY (T1 HAS ENTRY ADDRESS)
	RET			;AND RETURN TO CALLER

.HARP:				;ARP SWITCH
	MOVX T1,GH%DMB		;ARP POSSIBLE FLAG
	ANDCAM T1,BHSTFL	;SAY THAT THIS HOST CAN DO ARP
	RET			;AND RETURN

.HNARP:				;NOARP SWITCH
	MOVX T1,GH%DMB		;ARP POSSIBLE FLAG
	IORM T1,BHSTFL		;SAY THAT THIS HOST CAN NOT DO ARP
	RET			;AND RETURN

	SUBTTL Ethernet Mapping Binary File Generation Routines

QUEENT:				;QUEUE UP AN ENTRY
	MOVE QC,T1		;INIT THE CURRENT ITEM
	MOVE QP,LNKHED		;INIT PREVIOUS ITEM
	MOVEI QO,LNKHED		;INIT OLD ITEM
QUEENL:				;LINKING LOOP
	CAIN QP,LNKHED		;PREVIOUS AT THE END?
	 JRST QUEENP		;YES SO INSERT BEFORE PREVIOUS
	LOAD T1,MPINT,(QC)	;GET CURRENT INTERNET ADR
	LOAD T2,MPINT,(QP)	;GET PREVIOUS INTERNET ADR
	CAMN T1,T2		;ARE THEY THE SAME?
	 JRST QUEERR		;YES ERROR
	CAMG T1,T2		;CURRENT BIGGER THAN PREVIOUS?
	 JRST QUEENP		;NO SO INSERT BEFORE PREVIOUS
	LOAD QN,MPLNK,(QP)	;GET THE NEXT ITEM
	CAIN QN,LNKHED		;END OF THE LIST?
	 JRST QUEENN		;YES SO INSERT BEFORE THE NEXT
	LOAD T3,MPINT,(QN)	;GET NEXT INTERNET ADR
	CAMN T1,T3		;ARE THE THE SAME?
	 JRST QUEERR		;YES SO ERROR
	CAMG T1,T3		;CURRENT BIGGER THAN NEXT?
	 JRST QUEENN		;NO SO INSERT BEFORE THE NEXT
	MOVE QO,QP		;NO SO OLD IS THE PREVIOUS
	MOVE QP,QN		;AND PREVIOUS IS THE NEXT
	JRST QUEENL		;SO KEEP CHASING DOWN THE LIST

QUEENP:				;HERE TO INSERT BEFORE PREVIOUS
	STOR QC,MPLNK,(QO)	;OLD POINTS TO CURRENT
	STOR QP,MPLNK,(QC)	;CURRENT POINTS TO PREVIOUS
	RET			;AND RETURN

QUEENN:				;HERE TO INSERT BEFORE THE NEXT
	STOR QN,MPLNK,(QC)	;CURRENT POINTS TO NEXT
	STOR QC,MPLNK,(QP)	;PREVIOUS POINTS TO CURRENT
	RET			;AND RETURN

QUEERR:				;HERE ON A QUEUEING ERROR
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?Duplicate Internet address encountered.  Build aborted.>
	TYPE <?>
	HRROI T1,BXTBUF		;GET A POINTER TO THE TEXT BUFFER
	PSOUT%			;OUTPUT THE TEXT BUFFER
	SETONE F%BERR		;SET THE ERROR FLAG
	JRST IPNIR3		;ABORT THE READ

	SUBTTL Ethernet Mapping Binary File Writing

IPNIWR:				;WRITE THE BINARY FILE
	SETZ T1,		;ZERO THE CHECKSUM AC
	MOVEI T2,GHTBUF+NIHMHL	;DETERMINE THE FIRST LOCATION FOR HOST INFO
	MOVE QC,LNKHED		;GET THE HEAD OF THE LINKED LIST
	CAIN QC,LNKHED		;IS THE LIST EMPTY?
	 JRST IPNIW3		;YES
IPNIW2:				;TOP OF LINK CHASING LOOP
	LOAD T3,MPINT,(QC)	;GET THE INTERNET ADDRESS
	ADD T1,T3		;ADD IT TO THE CHECKSUM
	MOVEM T3,.NIINT(T2)	;STORE IT AWAY
	LOAD T3,MPEA1,(QC)	;GET THE FIRST ETHERNET ADR WORD
	ADD T1,T3		;ADD IT TO THE CHECKSUM
	LOAD T4,MPEA2,(QC)	;GET THE SECOND ETHERNET ADR WORD
	ADD T1,T4		;ADD IT TO THE CHECKSUM
	DMOVEM T3,.NIEN1(T2)	;STORE THEM AWAY
	LOAD T3,MPFLG,(QC)	;GET THE FLAGS WORD
	ADD T1,T3		;ADD IT TO THE CHECKSUM
	MOVEM T3,.NIGCF(T2)	;STORE THEM AWAY
	LOAD QC,MPLNK,(QC)	;GET THE NEXT ENTRY
	CAIN QC,LNKHED		;END OF LIST?
	 JRST IPNIW3		;YES
	ADDI T2,NIHMDL		;BUMP THE HOST INFO INDEX
	JRST IPNIW2		;AND KEEP CHASING DOWN THE LIST
IPNIW3:				;HERE WHEN ALL HOST INFO STORED AWAY
	MOVEM T1,GHTBUF+.NICHK	;STORE AWAY THE CHECKSUM
	SUBI T2,<GHTBUF-NIHMDL>	;GET THE POSITIVE LENGTH
	MOVN T3,T2		;POSITION IT FOR THE SOUT
	SUBI T2,NIHMHL		;SUBTRACT THE HEADER LENGTH
	MOVEM T2,GHTBUF+.NILEN	;SAVE THE LENGTH AWAY
	MOVX T1,<VERSIO>	;GET OUR VERSION
	MOVEM T1,GHTBUF+.NIMIR	;STORE IT AWAY
	GTAD%			;GET THE TIME AND DATE
	MOVEM T1,GHTBUF+.NIGTD	;STORE IT AWAY
	MOVE T1,BLDOJF		;GET THE OUTPUT JFN
	MOVX T2,<POINT 36,GHTBUF> ;GET THE SOURCE POINTER
	SOUT%			;WRITE THE BUFFER TO THE FILE
	 JSYSF
	RET

	SUBTTL Misc Routines

HEXBRK:	777777,,777760		;MAGIC BREAK MASK FOR HEX
	777774,,001760
	403777,,777760
	403777,,777760

HEXRED:				;READ IN HEX FROM ATOM BUFFER POINTED BY T1
	CALL HEXRDB		;GET A BYTE
	 RET			;ERROR
	MOVEI T3,(T2)		;SAVE THE BYTE
	CALL HEXRDB		;GET A BYTE
	 RET			;ERROR
	ILDB T1,T1		;GET ANOTHER BYTE
	JUMPN T1,R		;IF NOT NULL THEN AN ERROR
	LSH T3,4		;MAKE ROOM
	ADDI T3,(T2)		;ADD IN THE SECOND NIBBLE
	MOVEI T1,(T3)		;AND PUT IT IN THE CORRECT AC
	RETSKP			;SUCCESS RETURN

HEXRDB:				;GET A HEX BYTE
	ILDB T2,T1		;GET A BYTE
	CAIL T2,"0"		;FROM ZERO
	 CAILE T2,"9"		;TO NINE?
	  JRST HEXRB2		;NO
	SUBI T2,60		;CONVERT FROM ASCII
	RETSKP			;AND SUCCESS RETURN
HEXRB2:				;HERE WHEN THE CHARACTER IS NOT 0-9
	CAIL T2,"A"+40		;FROM LITTLE A
	 CAILE T2,"F"+40       	;TO LITTLE F?
	  SKIPA			;NO
	   TXZ T2,40		;YES SO MAKE IT UPPER CASE
	CAIL T2,"A"		;FROM A
	 CAILE T2,"F"		;TO F?
	  RET			;NO SO ERROR
	SUBI T2,67		;YES SO CONVERT TO A REAL NUMBER
	RETSKP			;AND SUCCESS RETURN

ADDENT:				;HERE TO QUEUE UP AN ENTRY
	MOVEI T1,LNKSZ		;GET THE SIZE OF AN ENTRY
	EXCH T1,LNKFST		;GET THE FIRST FREE ENTRY
	ADDM T1,LNKFST		;AND SAVE THE NEW ENTRY
				;STORE INFORMATION IN THE BLOCK
	MOVE T2,BHSTIA		;GET THE INTERNET ADDRESS
	STOR T2,MPINT,(T1)	;SAVE IT IN THE BLOCK
	DMOVE T2,BHSTHX		;GET THE ETHERNET ADDRESS
	STOR T2,MPEA1,(T1)	;SAVE THE FIRST WORD
	STOR T3,MPEA2,(T1)	;SAVE THE SECOND WORD
	MOVE T2,BHSTFL		;GET THE FLAG WORD
	STOR T2,MPFLG,(T1)	;SAVE THE FLAG WORD
	RET			;RETURN TO CALLER



OCTETS:				;OUTPUT INTERNET ADDRESS FROM T1
	STKVAR <OCTAD>
	MOVEM T1,OCTAD		;SAVE THE ADDRESS
	MOVEI X1,4		;FOUR OCTETS
	MOVX X2,<POINT 8,OCTAD,3> ;BYTE POINTER
OCTET1:				;OCTET LOOP
	ILDB T2,X2		;GET AN OCTET
	NUMO T2,12,0		;OUTPUT THE DECIMAL OCTET
	MOVEI T1,"."		;GET A DOT
	CAIE X1,1		;LAST OCTET?
	 PBOUT%			;NO SO OUTPUT THE DOT
	SOJG X1,OCTET1		;DO ALL FOUR OCTETS
	TYPEN < [>
	MOVEI T1,.GTHNS		;RETURN NAME STRING FUNCTION
	MOVEI T2,.PRIOU		;OUTPUT TO THE TTY
	MOVE T3,OCTAD		;GET THE ADDRESS
	GTHST%			;OUTPUT THE NAME
	 ERSKP			;SKIP ON ERROR
	  JRST OCTET2		;NO ERROR
	TYPEN <unknown>		;SAY WE DO NOT KNOW THE NAME
OCTET2:
	TYPEN <]>
	RET			;AND RETURN TO CALLER 

HEXOUT:				;ROUTINE TO OUTPUT HEX ETHERNET ADDRESSES
	SAVEAC <T5,T6>
	STKVAR <<HXADR,2>>	;ADDRESS IS IN T1 AND T2
	DMOVEM T1,HXADR		;SAVE THE ADDRESS
	MOVEI T5,6		;SIX OCTETS
	MOVEI T6,HXADR		;GET POINTER TO THE BYTES
	HRLI T6,(POINT 8,0)	;MAKE THIS A BYTE POINTER
HEXLOP:				;HEX OUTPUT LOOP
 	ILDB T1,T6		;GET AN OCTET
	CALL HEXWRK		;OUTPUT IT IN HEX
	MOVEI T1,"-"		;GET A DELIMITOR
	CAIE T5,1		;IS THIS THE LAST OCTET?
	 PBOUT%			;NO SO OUTPUT THE DELIMITOR
	SOJG T5,HEXLOP		;LOOP UNTIL DONE
	RET			;DONE SO RETURN

HEXWRK:				;WORKER ROUTINE FOR HEX ADDRESSES
	MOVEI T3,2		;TWO CHARACTERS
HEXWR2:
	IDIVI T1,^D16		;DIVIDE BY THE RADIX
	PUSH P,T2		;SAVE REMAINDER, A CHARACTER
	SOSE T3			;IF A IS NOW ZERO, UNWIND THE STACK
	 CALL HEXWR2		;CALL SELF AGAIN, REDUCE A
	POP P,T1		;GET CHARACTER
	ADJBP T1,[350700,,[ASCII/0123456789ABCDEF/]]
	LDB T1,T1		;CONVERT HEX CODE TO ASCII
	PBOUT%			;OUTPUT THE ASCII CHARACTER
	 JSYSF
	RET

	SUBTTL Poke Command

.POKE:				;POKE COMMAND
	STKVAR <POKNNN,POKCNT>
	NOISE <ALL KNOWN HOSTS FOR STATUS INFORMATION>
	DOCMD .CMNUM,12,<1>,<number of times to poke>
	JUMPG T2,.POKE2		;MAKE SURE IT IS LEGAL
	CALL NEWLIN		;GET A NEW LINE
	TYPEN <?Command error - Illegal count.>
	JRST GETCMD		;GET A NEW COMMAND
.POKE2:
	MOVEM T2,POKNNN		;SAVE THE COUNT
	CNFIRM			;MAKE SURE HE WANTS THIS
	MOVX T1,AQ%ICM!ASNIQB	;GET THE BLOCK ADDRESS
	SETZB T2,T3		;ZERO THESE ACS
	ASNIQ%			;ASSIGN INTERNET QUEUE
	 JSYSF
	MOVEM T1,IPSQH		;SAVE THE QUEUE NUMBER
	SETONE F%IPSQ		;FLAG THAT WE HAVE THE QUEUE
.POKE3:
	CALL DOPOKS		;DO ALL THE POKES
	SOSLE POKNNN		;DONE YET?
	 JRST .POKE3		;NOPE
	MOVE T1,IPSQH		;YUP SO GET THE QUEUE HANDLE 
	RELIQ%			;RELEASE THE QUEUE
	 JSYSF
	SETZRO F%IPSQ		;NO SPECIAL QUEUE ANYMORE
	RET			;RETURN TO CALLER

	SUBTTL DOPOKS - Actual Poke Routine

DOPOKS:				;HERE TO DO ALL THE POKES
	MOVEI T1,.GTHSZ		;GTHST GENERAL FUNCTION
	GTHST			;GET NUMBER OF HOST NAMES
	 JSYSF
	MOVE T5,T2		;SAVE AOBJN POINTER FOR USE
DOPOK1:				;AOBJN LOOP 
	MOVEI T1,.GTHHI		;GET HOST NUMBER FROM INDEX
	MOVEI T3,(T5)		;GET THE INDEX
	GTHST%			;GET THE NUMBER OF A HOST
	 JSYSF
	JN <HS%NCK!HS%NET>,T4,DOPOK2 ;IS IT ONE WE SHOULD IGNORE?
	MOVE T1,T3		;NO, MOVE THE NUMBER FOR POKHST
	CALL POKHST		;POKE THE HOST
DOPOK2:				;BOTTOM OF THE LOOP
	CALL POKRCV		;RECEIVE A MESSAGE IF AVAILABLE
	 NOP			;DO NOT CARE AT THIS POINT
	AOBJN T5,DOPOK1		;LOOP FOR ALL KNOWN HOSTS
DOPOK3:				;RECEIVING LOOP
	MOVEI T1,POKNUL		;NUMBER OF NON RCVINS WE WILL TOLERATE
	MOVEM POKCNT		;PUT THIS IN POKCNT
DOPOK4:				;LOOP 
	CALL POKRCV		;GET A MESSAGE
	 SKIPA			;NONE AVAILABLE
	  JRST DOPOK3		;TRY TO GET ANOTHER
	SOSG POKCNT		;SHOULD WE KEEP TRYING?
	 RET			;NO SO WE ARE ALL DONE
	MOVEI T1,POKTIM		;GET THE SLEEP TIME
	DISMS%			;GO TO SLEEP FOR A WHILE
	 JSYSF
	JRST DOPOK4		;TRY TO RECEIVE


	SUBTTL POKRCV - Routine to Receive Echo Replies

POKRCV:				;HERE TO RECEIVE AN ICMP MSG
	MOVE T1,IPSQH		;GET THE QUEUE HANDLE
	TXO T1,RIQ%NW		;DO NOT WAIT
	MOVEI T2,RCVINB		;GET THE RECEIVE BUFFER POINTER
	SETZ T3,		;MBZ
	RCVIN%			;GET AN INTERNET DATAGRAM
	 ERSKP			;HANDLE ERRORS
	  JRST POKRC2		;NO ERROR
	JUMPL T1,R		;RETURN WHEN NO BUFFER
	CALL .JSYSF		;NO SO TREAT AS A REAL ERROR.  NEVER RETURNS
	HALTF%			;NEVER DO THIS

POKRC2:				;HERE WHEN BUFFER AVAILABLE
	SETONE F%ICER		;SET THE FLAG
	LDB T1,[POINT 32,1+RCVINB+.IPKSH,31] ;GET THE HOST NUMBER
	CALL HSDMPN		;DUMP INFORMATION ABOUT THIS HOST
	RETSKP			;SKIP RETURN

	SUBTTL POKHST - Routine to send ICMP Echo Message

POKHST:				;SEND ICMP ECHO MESSAGE
	SETZM SNDINB+1+.IPKDH	;SAVE TARGET HOST NUMBER
	DPB T1,[POINT 32,SNDINB+1+.IPKDH,31]
	JN F%ICER,,POKHS2	;DID WE RECEIVE AN ECHO REPLY?
	MOVEI T1,POKSND		;NO SO GET A TIME INTERVAL
	DISMS%			;SNOOZE
POKHS2:
	SETZRO F%ICER		;RESET THE FLAG
	MOVE T1,IPSQH		;GET THE QUEUE HANDLE
	MOVEI T2,SNDINB		;GET THE BUFFER DESRIPTOR ADDRESS
	SETZ T3,		;MBZ
	SNDIN%			;SEND THE IP DATAGRAM OFF
	 JSYSF			;HANDLE ERRORS
	RET

	SUBTTL Final Stuff

IFE DEBUG,<XLIST>
...LIT:	LIT			;LITERALS
IFE DEBUG,<LIST>

	END <EVECL,,EVEC>	;THATS ALL FOLKS
