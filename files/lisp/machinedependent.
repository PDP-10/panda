(FILECREATED "18-Aug-84 14:42:20" <NEWLISP>MACHINEDEPENDENT..164 60229  

      changes to:  (VARS MACHINEDEPENDENTCOMS SORTCOMS FILENAMECOMS PRINTNUMCOMS WAITFORINPUTCOMS)
		   (MACROS CCONS CLIST UNPACKFILE1 UNPACKFILE2 WAITN WAITFILE)

      previous date: "17-Aug-84 23:37:05" <NEWLISP>MACHINEDEPENDENT..163)


(PRETTYCOMPRINT MACHINEDEPENDENTCOMS)

(RPAQQ MACHINEDEPENDENTCOMS [(COMS (* from HIST)
				   (VARS DUMPSTATSCOMS)
				   (ADDVARS [AFTERSYSOUTFORMS (SETQ CONSOLETIME0 (CLOCK 0))
							      (SETQ CPUTIME0 (CLOCK 2))
							      (SETQ GREETCLK (CLOCK 3))
							      (SETQ LASTEXEC NIL)
							      (SETQ HOSTNAME (MKATOM (HOSTNAME)))
							      (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
							      (SETLINELENGTH)
							      (COND ((NEQ SYSTEMTYPE (SETQ SYSTEMTYPE (SYSTEMTYPE)))
								     (SELECTQ SYSTEMTYPE (TOPS20 (SETQQ SYSOUT.EXT EXE)
												 (SETQQ EDITCHARACTERS
													(J A L Y K)))
									      (TENEX (SETQQ SYSOUT.EXT SAV)
										     (SETQQ EDITCHARACTERS
											    (J X Z Y N)))
									      (SHOULDNT))
								     (RESETTERMCHARS)
								     (APPLY (QUOTE SETTERMCHARS)
									    EDITCHARACTERS]
					    [BEFORESYSOUTFORMS (SETQ CONSOLETIME (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
														 CONSOLETIME0)))
							       (SETQ CPUTIME (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
													 CPUTIME0]
					    (RESETFORMS (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
							(SETLINELENGTH))
					    (LISPXMACROS (EXEC (PROGN (OR (NLSETQ (SETQ LASTEXEC (SUBSYS LASTEXEC)))
									  (SETQ LASTEXEC (SUBSYS)))
								      LASTEXEC))
							 (CONTIN (SUBSYS T)))
					    (LISPXCOMS CONTIN)
					    [BEFOREMAKESYSFORMS (HERALD (SETQ HERALDSTRING
									      (CONCAT (OR NAME (COND ((EQ (GETATOMVAL (QUOTE 
														    BYTELISPFLG))
													  T)
												      "INTERLISP-MAXC")
												     (T "INTERLISP-10")))
										      "  "
										      (SUBSTRING (SETQ TEM (DATE))
												 1
												 (IPLUS 2 (STRPOS (QUOTE -)
														  TEM 4)))
										      " ..."]
					    (PREGREETFORMS (COND ((NEQ SYSTEMTYPE (SETQ SYSTEMTYPE (SYSTEMTYPE)))
								  (SELECTQ SYSTEMTYPE (TOPS20 (SETQQ SYSOUT.EXT EXE)
											      (SETQQ EDITCHARACTERS
												     (J A L Y K)))
									   (TENEX (SETQQ SYSOUT.EXT SAV)
										  (SETQQ EDITCHARACTERS (J X Z Y N)))
									   (SHOULDNT))
								  (RESETTERMCHARS)
								  (RESETTERMCHARS ASKUSERTTBL)))
							   (SETQ HOSTNAME (MKATOM (HOSTNAME)))
							   (STATINIT)))
				   (FNS GREETFILENAME)
				   (VARS (GREETDIRECTORY)
					 (GREETFILE (QUOTE INIT))
					 (GREETEXT (QUOTE LISP)))
				   (GLOBALVARS GREETDIRECTORY GREETFILE GREETEXT))
			     (COMS (FNS PRINTARRAY DISPLAYTERMP SETLINELENGTH SETNM RANDACCESSP U-CASEP U-CASE L-CASE L-CASE1 
					SUBATOM GCGAG)
				   (VARS [SYSTEMTERMTYPES (QUOTE ((15 . VT52)
								  (16 . VT100]
					 OPENFNS
					 (GCGAG 40)
					 GCMESS1 GCMESS2 GCMESS3 GCMESS4 GCMESS5 GCMESS6 GCMESS7)
				   (P (GCGAG GCGAG)))
			     (COMS (FNS CHECKNIL))
			     (COMS (FNS RETEVAL RETAPPLY STKEVAL STKAPPLY DUMMYFRAMEP REALFRAMEP REALSTKNTH)
				   (VARS (SPAGHETTIFLG T)
					 (**RETEVAL)))
			     (COMS (FNS LISPXSTATS LISPXSTATS1 LISPXWATCH STATINIT ADDSTATS)
				   (PROP 10MACRO LISPXWATCH)
				   (INITVARS (SYSTATS)))
			     [COMS (* NOTE: definitions for RESETRESTORE, RESETVARS, RESETVAR, and RESETSAVE are in 
				      machinedependent because they are different for deep vs shallow bound systems)
				   (FNS RESETRESTORE RESETSAVE RESETVAR)
				   (BLOCKS (NIL RESETRESTORE RESETSAVE RESETVAR (GLOBALVARS RESETVARSLST]
			     (COMS * SORTCOMS)
			     (VARS MAX.INTEGER MIN.INTEGER (MAX.FLOAT (MKATOM (QUOTE "1.70141182E38")))
				   (MIN.FLOAT (FMINUS MAX.FLOAT)))
			     (FNS INTEGERLENGTH)
			     (COMS * FILENAMECOMS)
			     (COMS * PRINTNUMCOMS)
			     (COMS * WAITFORINPUTCOMS)
			     (FNS LISTFILES1)
			     (BLOCKS (NIL RETEVAL RETAPPLY STKEVAL STKAPPLY (LINKFNS . T)
					  (GLOBALVARS **RETEVAL)
					  (LOCALVARS . T))
				     (NIL DUMMYFRAMEP REALFRAMEP REALSTKNTH (GLOBALVARS OPENFNS)
					  (LOCALVARS . T)
					  (LINKFNS . T))
				     (NIL SETNM RANDACCESSP SETLINELENGTH (GLOBALVARS TTYLINELENGTH)
					  DISPLAYTERMP PRINTARRAY (LOCALVARS . T)
					  (NOLINKFNS . T))
				     (NIL ADDSTATS STATINIT (GLOBALVARS SYSTATS STATARRAY)
					  LISPXWATCH
					  (LOCALVARS . T))
				     (LISPXSTATS LISPXSTATS LISPXSTATS1 (GLOBALVARS SYSTATS CONSOLETIME CONSOLETIME0 EDITIME 
										    CPUTIME CPUTIME0 FIXTIME))
				     (NIL GCGAG (LOCALVARS . T)
					  (GLOBALVARS GCGAG GCMESS1 GCMESS2 GCMESS3 GCMESS4 GCMESS5 GCMESS6 GCMESS7))
				     (NIL U-CASEP U-CASE L-CASE L-CASE1 (LOCALVARS . T)
					  (LINKFNS . T)
					  (GLOBALVARS CHCONLST)))
			     (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA RESETSAVE ADDSTATS)
												   (NLAML RESETVAR)
												   (LAMA PACKFILENAME])



(* from HIST)


(RPAQQ DUMPSTATSCOMS ((E (SETQ CONSOLETIME (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
									   CONSOLETIME0)))
			 (SETQ CPUTIME (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
								   CPUTIME0)))
			 (SETQ CONSOLETIME0 (CLOCK 0))
			 (SETQ CPUTIME0 (CLOCK 2)))
		      (VARS CPUTIME (CPUTIME0 (CLOCK 2))
			    CONSOLETIME
			    (CONSOLETIME0 (CLOCK 0))
			    EDITIME SYSTATS RESPELLS)
		      (ARRAY STATARRAY)
		      (P (STATINIT T))))

(ADDTOVAR AFTERSYSOUTFORMS (SETQ CONSOLETIME0 (CLOCK 0))
			   (SETQ CPUTIME0 (CLOCK 2))
			   (SETQ GREETCLK (CLOCK 3))
			   (SETQ LASTEXEC NIL)
			   (SETQ HOSTNAME (MKATOM (HOSTNAME)))
			   (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
			   (SETLINELENGTH)
			   (COND ((NEQ SYSTEMTYPE (SETQ SYSTEMTYPE (SYSTEMTYPE)))
				  (SELECTQ SYSTEMTYPE (TOPS20 (SETQQ SYSOUT.EXT EXE)
							      (SETQQ EDITCHARACTERS (J A L Y K)))
					   (TENEX (SETQQ SYSOUT.EXT SAV)
						  (SETQQ EDITCHARACTERS (J X Z Y N)))
					   (SHOULDNT))
				  (RESETTERMCHARS)
				  (APPLY (QUOTE SETTERMCHARS)
					 EDITCHARACTERS))))

(ADDTOVAR BEFORESYSOUTFORMS (SETQ CONSOLETIME (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
									      CONSOLETIME0)))
			    (SETQ CPUTIME (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
								      CPUTIME0))))

(ADDTOVAR RESETFORMS (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
		     (SETLINELENGTH))

(ADDTOVAR LISPXMACROS (EXEC (PROGN (OR (NLSETQ (SETQ LASTEXEC (SUBSYS LASTEXEC)))
				       (SETQ LASTEXEC (SUBSYS)))
				   LASTEXEC))
		      (CONTIN (SUBSYS T)))

(ADDTOVAR LISPXCOMS CONTIN)

(ADDTOVAR BEFOREMAKESYSFORMS (HERALD (SETQ HERALDSTRING (CONCAT (OR NAME (COND ((EQ (GETATOMVAL (QUOTE BYTELISPFLG))
										    T)
										"INTERLISP-MAXC")
									       (T "INTERLISP-10")))
								"  "
								(SUBSTRING (SETQ TEM (DATE))
									   1
									   (IPLUS 2 (STRPOS (QUOTE -)
											    TEM 4)))
								" ..."))))

(ADDTOVAR PREGREETFORMS (COND ((NEQ SYSTEMTYPE (SETQ SYSTEMTYPE (SYSTEMTYPE)))
			       (SELECTQ SYSTEMTYPE (TOPS20 (SETQQ SYSOUT.EXT EXE)
							   (SETQQ EDITCHARACTERS (J A L Y K)))
					(TENEX (SETQQ SYSOUT.EXT SAV)
					       (SETQQ EDITCHARACTERS (J X Z Y N)))
					(SHOULDNT))
			       (RESETTERMCHARS)
			       (RESETTERMCHARS ASKUSERTTBL)))
			(SETQ HOSTNAME (MKATOM (HOSTNAME)))
			(STATINIT))
(DEFINEQ

(GREETFILENAME
  [LAMBDA (USER)                   (* lmm "23-FEB-83 21:19")
    (INFILEP (PACKFILENAME (QUOTE DIRECTORY)
			   (COND
			     [(EQ USER T)
			       (OR GREETDIRECTORY (SELECTQ (SYSTEMTYPE)
							   (TOPS20 (QUOTE INTERLISP:))
							   (QUOTE <LISP>]
			     (T USER))
			   (QUOTE NAME)
			   GREETFILE
			   (QUOTE EXTENSION)
			   GREETEXT])
)

(RPAQQ GREETDIRECTORY NIL)

(RPAQQ GREETFILE INIT)

(RPAQQ GREETEXT LISP)
(DECLARE: DOEVAL@COMPILE DONTCOPY

(ADDTOVAR GLOBALVARS GREETDIRECTORY GREETFILE GREETEXT)
)
(DEFINEQ

(PRINTARRAY
  [LAMBDA (V)                                   (* edited: "20-JUL-83 12:36")
    (PROG (A N M N1 FLG ORIG)
          [COND
	    ([AND (LITATOM V)
		  (ARRAYP (SETQ A (EVALV V (QUOTE PRINTARRAY]
	      (printout NIL "(SETQ " .P2 V ,)
	      (printout NIL "(READARRAY " (SETQ N (ARRAYSIZE A))
			" (QUOTE "
			(SETQ N1 (ARRAYTYP A))
			") "
			(SETQ ORIG (ARRAYORIG A))
			")")
	      (PRINTOUT NIL ")" T))
	    ((ARRAYP V)
	      (SETQ A V)
	      (SETQ N (ARRAYSIZE A))
	      (SETQ N1 (ARRAYTYP A))
	      (SETQ ORIG (ARRAYORIG A)))
	    (T (RETURN (HELP (CONS V (QUOTE (not array]
          (PRIN1 (QUOTE %())
          (SETQ M 1)
      LP  (COND
	    ((NOT (IGREATERP M N))
	      (PRINT (ELT A M))
	      (AND (IGREATERP M N1)
		   (ELTD A M)
		   (SETQ FLG T))
	      (SETQ M (ADD1 M))
	      (GO LP))
	    ((NULL (PRINT FLG))
	      (GO OUT)))
          (SETQ M (ADD1 N1))
      LP1 (COND
	    ((NOT (IGREATERP M N))
	      (PRINT (ELTD A M))
	      (SETQ M (ADD1 M))
	      (GO LP1)))
      OUT (PRIN1 (QUOTE %)))
          (RETURN A])

(DISPLAYTERMP
  [LAMBDA (DIRECTEDTYPE)           (* lmm "23-FEB-83 23:27")

          (* * Returns the terminal type number. Uses the jsys GTTYP.)


    (PROG [(TYPE (OR DIRECTEDTYPE (SELECTQ (SYSTEMTYPE)
					   ((TOPS20 TENEX)
					     (JSYS 303Q 777777Q NIL NIL 2))
					   (VAX (0Syscall 32 1 \SPEEDBLOCK)
                                   (* record speed etc for later)
						(MKATOM (GETENV "TERM")))
					   NIL]
          (SETQ TYPE (CDR (FASSOC TYPE SYSTEMTERMTYPES)))
          [COND
	    ((LISTP TYPE)
	      (SETQ TYPE (EVAL TYPE]
          (RETURN TYPE])

(SETLINELENGTH
  [LAMBDA (N)                                          (* rmk: "22-MAY-81 13:07")
    (COND
      [N (SETQ TTYLINELENGTH N)
	 (JSYS 217Q 100Q (LOGOR (LLSH N 22Q)
				(LOGAND -177000001Q (JSYS 107Q 100Q NIL NIL 2))))]
      ((ILESSP (SETQ TTYLINELENGTH (LOGAND 127 (LRSH (JSYS 107Q 100Q 0 0 2)
						     18)))
	       10)                                     (* compute ttylinelength from tenex.)
	(SETQ TTYLINELENGTH 72)))
    (LINELENGTH TTYLINELENGTH T])

(SETNM
  [LAMBDA (NAME)
    (JSYS 210Q (SIXBIT NAME))])

(RANDACCESSP
  [LAMBDA (FILE)                                            (* lmm "30-MAY-78 23:45"
)
    (AND (LITATOM FILE)
	 (ASSEMBLE NIL
	           [CQ (VAG (OPNJFN (SETQ FILE (OPENP (OR FILE (INPUT]
	           (MOVEI 2 , 0)
	           (JSYS 24Q)
	           (TLNN 2 , 20000Q)
	           (SKIPA 1 , ' NIL)
	           (VAR (HRRZ 1 , FILE])

(U-CASEP
  [LAMBDA (X)                                               (* lmm " 3-JUL-78 21:32"
)

          (* equivalent to (EQUAL X (U-CASE X)) or 
	  (COND ((LISTP X) (AND (U-CASEP 
	  (CAR X)) (OR (NULL (CDR X)) 
	  (U-CASEP (CDR X))))) (T (NOTANY 
	  (DCHCON X CHCONLST) (FUNCTION 
	  (LAMBDA (X) (AND (IGREATERP X 96) 
	  (ILESSP X 123))))))))


    (COND
      [(LISTP X)
	(AND (U-CASEP (CAR X))
	     (OR (NULL (CDR X))
		 (U-CASEP (CDR X]
      (T (ASSEMBLE NIL
	           (CQ X)
	           (STE (QUOTE STPTT))
	           (HLRZ 1 , 2 (1))
	           (FASTCALL UPATM)
	       LP  (JUMPE 4 , TRUE)                         (* no more chars, must 
						be uppercase)
	           (ILDB 2 , 3)
	           (CAIL 2 , (CHCON1 "a"))
	           (CAILE 2 , (CHCON1 "z"))
	           (SOJA 4 , LP)
	           (SKIPA 1 , KNIL)
	       TRUE(HRRZ 1 , KT])

(U-CASE
  [LAMBDA (X)                      (* lmm "11-SEP-78 18:27")
    (COND
      [(LISTP X)
	(CONS (U-CASE (CAR X))
	      (AND (CDR X)
		   (U-CASE (CDR X]
      (T (PROG (TEM LST ANY)
	       [MAP (SETQ LST (DCHCON X CHCONLST))
		    (FUNCTION (LAMBDA (LST)
			(FRPLACA LST (FCHARACTER (COND
						   ((AND (IGREATERP (SETQ TEM (CAR LST))
								    96)
							 (ILESSP TEM 123))
						     (SETQ ANY (IPLUS TEM -32)))
						   (T TEM]
	       (RETURN (COND
			 ((NOT ANY)
			   X)
			 ((STRINGP X)
			   (APPLY (FUNCTION CONCAT)
				  LST))
			 (T (PACK LST])

(L-CASE
  [LAMBDA (X FLG)                               (* wt: 11-MAR-77 22 34)
    (COND
      [(LISTP X)
	(CONS (L-CASE (CAR X)
		      FLG)
	      (AND (CDR X)
		   (L-CASE (CDR X)
			   FLG]
      (T (L-CASE1 (DCHCON X CHCONLST)
		  FLG X])

(L-CASE1
  [LAMBDA (LST CAP X)                           (* wt: " 7-JUL-80 22:17")
    (PROG (Z ANY)

          (* Converts all alphabetic characters in LST to lower-case. If CAP is T first alphabetic character is converted to 
	  uppercase)


          [MAP LST (FUNCTION (LAMBDA (LST)
		   (FRPLACA LST (FCHARACTER
			      (COND
				[(AND (IGREATERP (SETQ Z (CAR LST))
						 64)
				      (ILESSP Z 91))
                                                (* Z is an uppercase character)
				  (COND
				    (CAP        (* capitalize first character)
					 (SETQ CAP NIL)
					 Z)
				    (T (SETQ ANY (IPLUS Z 32]
				((AND CAP (IGREATERP Z 96)
				      (ILESSP Z 123))
				  (SETQ CAP NIL)
				  (SETQ ANY (IDIFFERENCE Z 32)))
				(T Z]
          (RETURN (COND
		    ((AND X (NOT ANY))|
		      X)
		    ((STRINGP X)
		      (APPLY (QUOTE CONCAT)
			     LST))
		    (T (PACK LST])

(SUBATOM
  [LAMBDA (X N M)
    (MKATOM (SUBSTRING X N M (CONSTANT (CONCAT])

(GCGAG
  [LAMBDA (MESSAGE)                                         (* wt: "11-MAR-79 21:00")
    (PROG1 GCGAG (COND
	     ((NULL (SETQ GCGAG MESSAGE))
	       (GCMESS 1)
	       (GCMESS 2)
	       (GCMESS 3)
	       (GCMESS 4)
	       (GCMESS 5)
	       (GCMESS 7))
	     ((OR (EQ GCGAG T)
		  (SMALLP GCGAG))
	       (GCMESS 1 GCMESS1)
	       (GCMESS 2 GCMESS2)
	       (GCMESS 3 GCMESS3)
	       (GCMESS 4 GCMESS4)
	       (GCMESS 5 (OR (SMALLP GCGAG)												     |
			     GCMESS5))												     |
	       (GCMESS 6 GCMESS6)
	       (GCMESS 7 GCMESS7))
	     ((EQ GCGAG (QUOTE OLD))
	       (GCMESS 1 "GC: 
")
	       (GCMESS 2 "
")
	       (GCMESS 3 ", ")
	       (GCMESS 4 " FREE CELLS")
	       (GCMESS 5 40)
	       (GCMESS 6 " PAGES LEFT")
	       (GCMESS 7 "
"))
	     ((LISTP GCGAG)
	       (GCMESS 1)
	       (GCMESS 2 (CAR GCGAG))
	       (GCMESS 3)
	       (GCMESS 4)
	       (GCMESS 5)
	       (GCMESS 7 (CDR GCGAG)))
	     (T (GCMESS 1)
		(GCMESS 2 GCGAG)
		(GCMESS 3)
		(GCMESS 4)
		(GCMESS 5)
		(GCMESS 7])
)

(RPAQQ SYSTEMTERMTYPES ((15 . VT52)
			(16 . VT100)))

(RPAQQ OPENFNS (SETQ AND OR COND SELECTQ PROG PROGN PROG1 ARG SETARG ERSETQ NLSETQ RESETFORM RESETLST RESETVARS RPTQ SAVESETQ SETN 
		     UNDONLSETQ XNLSETQ APPLY*))

(RPAQQ GCGAG 40)

(RPAQQ GCMESS1 "
collecting ")

(RPAQQ GCMESS2 "
")

(RPAQQ GCMESS3 ", ")

(RPAQQ GCMESS4 " free cells")

(RPAQQ GCMESS5 40)

(RPAQQ GCMESS6 " pages left")

(RPAQQ GCMESS7 "
")
(GCGAG GCGAG)
(DEFINEQ

(CHECKNIL
  [LAMBDA NIL                      (* DD: "24-Nov-81 19:41")
    (COND
      ((OR (CAR (QUOTE NIL))
	   (CDR (QUOTE NIL))
	   (GETPROPLIST (QUOTE NIL))
	   (GETD (QUOTE NIL))
	   (GETATOMVAL (QUOTE NIL)))
	[RESETFORM (PRINTLEVEL 2 12Q)
		   (MAPC (QUOTE (CAR CDR GETD GETPROPLIST GETATOMVAL))
			 (FUNCTION (LAMBDA (Z)
			     (COND
			       ((APPLY* Z NIL)
				 (PRIN1 Z T)
				 (PRIN1 " of NIL was clobbered with " T)
				 (PRINT (APPLY* Z NIL)
					T T]
	(FRPLNODE NIL NIL)
	(PUTD NIL NIL)
	(SETPROPLIST NIL NIL)
	(SETATOMVAL NIL NIL)
	(PRIN1 "- now restored.
" T)))
    (COND
      ((OR (NEQ (CAR T)
		T)
	   (NEQ (GETATOMVAL T)
		T))
	[RESETFORM (PRINTLEVEL 2 12Q)
		   (MAPC (QUOTE (CAR GETATOMVAL))
			 (FUNCTION (LAMBDA (Z)
			     (COND
			       ((NEQ (APPLY* Z T)
				     T)
				 (PRIN1 Z T)
				 (PRIN1 " of T was clobbered with " T)
				 (PRINT (APPLY* Z T)
					T T]
	(SETATOMVAL T T)
	(FRPLACA T T)
	(PRIN1 "- now restored.
" T])
)
(DEFINEQ

(RETEVAL
  [LAMBDA (POS FORM FLG INTERNALFLG)                        (* wt: 17-FEB-76 2 22)
    (ENVEVAL FORM POS (SETQ **RETEVAL (STKNTH -1 POS **RETEVAL))
	     FLG T])

(RETAPPLY
  [LAMBDA (POS FN ARGS FLG INTERNALFLG)                     (* wt: 17-FEB-76 2 22)
    (ENVAPPLY FN ARGS POS (SETQ **RETEVAL (STKNTH -1 POS **RETEVAL))
	      FLG T])

(STKEVAL
  [LAMBDA (POS FORM FLG INTERNALFLG)                        (* wt: 17-FEB-76 2 22)
    (ENVEVAL FORM POS NIL FLG])

(STKAPPLY
  [LAMBDA (POS FN ARGS FLG INTERNALFLG)                     (* wt: 17-FEB-76 2 22)
    (ENVAPPLY FN ARGS POS NIL FLG])

(DUMMYFRAMEP
  [LAMBDA (POS)                                             (* lmm: "31-JAN-77 20:36:01")
                                                            (* this function is not 
						called, I don't think)
    (NOT (REALFRAMEP POS NIL])

(REALFRAMEP
  [LAMBDA (POS INTERPFLG)          (* lmm "16-DEC-81 13:13")

          (* Value is T if user did write a call to the function at POS, and either INTERPFLG is T, or else the functio call 
	  would also exist if compiled)


    (DECLARE (LOCALVARS . T))
    (PROG (NAME)
          (RETURN (SELECTQ (SETQ NAME (COND
			       ((STACKP POS)
				 (STKNAME POS))
			       (T POS)))
			   (*PROG*LAM 
                                   (* *PROG*LAM is dummy frame except when previous frame is EVALA)
				      (EQ (STKNTHNAME -1 POS)
					  (QUOTE EVALA)))
			   ((*ENV* NOLINKDEF1)
                                   (* *ENV* is generated by ENVEVAL etc. NOLINKDEF1 is from linked function calls 
				   that are being filled in)
			     NIL)
			   [EVAL (OR (ILESSP (STKNARGS POS)
					     2)
				     (NOT (FMEMB (STKARG 2 POS)
						 (QUOTE (INTERNAL SELECTQ]
			   [APPLY (OR (ILESSP (STKNARGS POS)
					      3)
				      (NEQ (QUOTE INTERNAL)
					   (STKARG 3 POS]
			   (COND
			     [(LITATOM NAME)
			       (COND
				 ((FMEMB NAME OPENFNS)
				   INTERPFLG)
				 (T (AND (OR (NEQ (NTHCHAR NAME 1)
						  (QUOTE *))
					     (NEQ (NTHCHAR NAME -1)
						  (QUOTE *)))
					 (OR (NEQ (STKNARGS POS)
						  1)
					     (NEQ (STKARG 1 POS)
						  (STKNTHNAME -1 POS))
					     (NOT (FGETD NAME))
					     (CDR (SETQ POS (ARGLIST NAME)))
					     (NEQ (CAR POS)
						  (PACK (LIST NAME (QUOTE #0]
			     ((LISTP NAME)
			       T])

(REALSTKNTH
  [LAMBDA (N POS INTERPFLG OLDPOS)                          (* wt: 15-NOV-76 19 49)

          (* skips back N (or -N) real frames on the stack.
	  i.e. frames for which (REALFRAMEP POS INTERPFLG) is 
	  true)


    (PROG (POS0 STEP)
          (SETQ STEP (COND
	      ((MINUSP N)
		-1)
	      ((ZEROP N)
		(HELP))
	      (T 1)))
          (SETQ POS0 (STKNTH STEP POS OLDPOS))
      LP  [COND
	    ((REALFRAMEP POS0 INTERPFLG)
	      (COND
		((ZEROP (SETQ N (IDIFFERENCE N STEP)))
		  (RETURN POS0]
          (COND
	    ((SETQ POS0 (STKNTH STEP POS0 POS0))
	      (GO LP)))
          (RETURN NIL])
)

(RPAQQ SPAGHETTIFLG T)

(RPAQQ **RETEVAL NIL)
(DEFINEQ

(LISPXSTATS
  [LAMBDA (RETURNVALUESFLG)                                 (* wt: " 9-SEP-78 23:24")
    (PROG (X)
          [SETQ X
	    (NCONC
	      [MAPCONC
		SYSTATS
		(FUNCTION (LAMBDA (X)
		    (AND
		      [OR (NLISTP X)
			  (AND (CDR X)
			       (NOT (ZEROP (CAR (SETQ X (CONS [OPENR (LOC (GETATOMVAL (CAR X]
							      (CDR X]
		      (LIST X]
	      (LIST NIL (LISPXSTATS1 (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
								     CONSOLETIME0))
				     (QUOTE (CONSOLE TIME)))
		    (LISPXSTATS1 EDITIME (QUOTE (OF IT IN THE EDITOR)))
		    NIL
		    (LISPXSTATS1 (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
							     CPUTIME0))
				 (QUOTE (CPU TIME)))
		    (LISPXSTATS1 (OPENR (LOC FIXTIME))
				 (QUOTE (OF IT IN DWIM]
          (RETURN (COND
		    (RETURNVALUESFLG X)
		    (T [MAPC X (FUNCTION (LAMBDA (X)
				 (AND X (LISPXPRIN1 X T))
				 (LISPXTERPRI T]
		       T])

(LISPXSTATS1
  [LAMBDA (X Y)
    (SETQ X (IQUOTIENT X 1000))
    (CONS (PACK (LIST (IQUOTIENT X 3600)
		      (QUOTE :)
		      (IQUOTIENT (IREMAINDER X 3600)
				 60)
		      (QUOTE :)
		      (IREMAINDER X 60)))
	  Y])

(LISPXWATCH
  [LAMBDA (STAT N)
    (AND (ARRAYP STAT)
	 (VAG (CLOSER (LOC STAT)
		      (IPLUS (OPENR (LOC STAT))
			     (OR N 1])

(STATINIT
  [LAMBDA (ARRAY)                  (* lmm "15-NOV-82 15:07")
                                   (* Used by LISPX. Included in ASSEMBLE because of LOC/VAG.)
    (PROG (TEM)
          [COND
	    ((NULL ARRAY)
	      (/SETATOMVAL (QUOTE STATARRAY)
			   (ARRAY (LENGTH SYSTATS)
				  (QUOTE FIXP]
          (SETQ TEM 1)
          (MAPC SYSTATS (FUNCTION (LAMBDA (X)
                                   (* Makes the value of the statistic, e.g. LISPXSTATS, be the corresponding slot 
				   in STATARRAY.)
		    (AND (LISTP X)
			 (/SETATOMVAL (CAR X)
				      (VAG (IPLUS (LOC STATARRAY)
						  (SETQ TEM (ADD1 TEM])

(ADDSTATS
  [NLAMBDA STATLST                 (* lmm "18-FEB-83 22:48")
                                   (* EAch statistic is a list -
				   e.g. (LISPXSTATS LISPX INPUTS), (UNDOSAVES UNDO SAVES))
    (AND (ARRAYP STATARRAY)
	 (PROG ((OLDA STATARRAY))
	       (/SETATOMVAL (QUOTE SYSTATS)
			    (APPEND SYSTATS STATLST))
	       (STATINIT)
	       (SETQ N (ARRAYSIZE OLDA))
	       (for I from 1 to (IMIN (ARRAYSIZE OLDA)
				      (ARRAYSIZE STATARRAY))
		  do (SETA STATARRAY I (ELT OLDA I)))
	       (RETURN STATLST])
)

(PUTPROPS LISPXWATCH 10MACRO [(X N)
			      (ASSEMBLE NIL (CQ X)
					[E (COND ((QUOTE N)
						  (CEXP2 (QUOTE (VAG (FIX N]
					(STN (QUOTE ARRAYT))
					(E (STORIN (COND [(QUOTE N)
							  (QUOTE (ADDM 2 , 0 (1]
							 (T (QUOTE (AOS 0 (1])

(RPAQ? SYSTATS )



(* NOTE: definitions for RESETRESTORE, RESETVARS, RESETVAR, and RESETSAVE are in 
machinedependent because they are different for deep vs shallow bound systems)

(DEFINEQ

(RESETRESTORE
  [LAMBDA (RESETVARSLST0 RESETSTATE)                        (* wt: "30-JUL-79 22:28")

          (* Goes down RESETVARSLST doing restoration until it gets to NIL or RESETVARSLST0. RESETSTATE is either NIL, ERROR, 
	  or RESET, depending on whether restoration is at normal (successful) completion of a RESETLST, following an error or
	  control-E, or following a control-D)


    (PROG (RESETZ OLDVALUE)
      LP  (COND
	    ((AND RESETVARSLST (NOT (TAILP RESETVARSLST RESETVARSLST0)))
	      (SETQ RESETZ (CAR RESETVARSLST))
	      (SETQ RESETVARSLST (CDR RESETVARSLST))
	      [COND
		((LISTP (CAR RESETZ))
		  [SETQ OLDVALUE (COND
		      ((CDR RESETZ)
			

          (* occurs for RESETSAVE's when second aagument is specified.
	  In this case, (CADR RESETZ) is the value of the saving form,
	  i.e. the first argument to RESETSAVE.)


			(CADR RESETZ))
		      (T (CADAR RESETZ]
		  (APPLY (CAAR RESETZ)
			 (CDAR RESETZ)))
		((STACKP (CADR RESETZ))|
		                                            (* see coment in resetsave)|
		  (SELECTQ RESETSTATE|
			   (RESET                           (* there was a rebinding, and therefore the restoration 
|
							    was done automatically by unwinding.)|
				  NIL)|
			   [(NIL ERROR)|
			     (COND|
			       ((EQP (STKSCAN (CAR RESETZ))|
				     (CADR RESETZ))|
				 (SETATOMVAL (CAR RESETZ)|
					     (CDDR RESETZ]|
			   (SHOULDNT))|
		  (RELSTK (CADR RESETZ)))|
		(T (SETATOMVAL (CAR RESETZ)|
			       (CDDR RESETZ]|
	      (GO LP])

(RESETSAVE
  [NLAMBDA RESETX                                           (* wt: "30-JUL-79 22:36")

          (* for use under a RESETLST. If RESETX is atmic, like RESETVAR, otherwise like RESETFORM, i.e. performs the 
	  resetting and saving associated with these functions. The restoration aad errorset protectionis done by RESETLST.
	  Note that its value is not any particularly useful quanitty. When used a la RESETFORM, can take a second argument 
	  whose value (computed before firt argument) is restoration form, e.g. (RESETSAVE (SETSEPR --) 
	  (LIST (QUOTE SETSEPR) (GETSEPR))) (RESETSAVE NIL form) means just add value of form to RESETVARLST>)


    (SETQ RESETVARSLST (CONS [COND
			       [(AND (CAR RESETX)
				     (ATOM (CAR RESETX)))
				 |
|
          (* in shallow binding, there are two mechanism for "rebinding" global variables, namely resetvars, which just |
	  rebinds, and restsave which resets and saves previous values. these can interact, e.g. (resetlst |
	  (resetvars -- (resetsave on-of the rebound variables)) have to know when exit resetlst whether or not binding has |
	  already been restored.))|
|
|
				 (PROG1 [CONS (CAR RESETX)
					      (CONS (STKSCAN (CAR RESETX))|
						    (GETATOMVAL (CAR RESETX]|
					(SETATOMVAL (CAR RESETX)|
						    (EVAL (CADR RESETX)|
							  (QUOTE INTERNAL]|
			       [(CDR RESETX)
				 

          (* CADR of the entry put on resetvarslst is the value of the saving form. The variable OLDVALUE is bound to this 
	  value during restoration. This makes it more convenient for the estoration to be conditional, e.g. the user can 
	  perform (RESETSAVE (FOO mumble) (QUOTE (AND pred (FIE OLDVALUE)))))


				 (LIST (EVAL (CADR RESETX))
				       (EVAL (CAR RESETX]
			       (T (LIST (LIST (COND
						((EQ (CAAR RESETX)
						     (QUOTE SETQ))
						  (CAR (CADDAR RESETX)))
						(T (CAAR RESETX)))
					      (EVAL (CAR RESETX]
			     RESETVARSLST])

(RESETVAR
  [NLAMBDA (RESETX RESETY RESETZ)                           (* wt: "30-JUL-79 22:38")
    (PROG (MACROX MACROY)

          (* Permits evaluation of a form while resetting a top level variable, and provides for the variable to be 
	  automatcally restored after valuation. In this way, the user pays when he wants to 'rebind' a globalvariable, but 
	  does not have to pay for the possiblity, as would be the case if variables such as DFNFLG, LISPXHISTORY, etc. were 
	  not global, i.e. were looked up. In the event of a control-D, or control-C reenter, the variabes will still be 
	  restored by EVALQT. Note that STKEVALs will not do the right t on variables reset by RESETVAR.)


          (SETQ MACROX (SETQ RESETVARSLST (CONS (CONS RESETX (CONS (STKSCAN RESETX)|
								   (GETATOMVAL RESETX)))|
						RESETVARSLST)))
          (SETQ MACROY (ERRORSET (LIST (QUOTE PROGN)
				       (LIST (QUOTE SETATOMVAL)|
					     (LIST (QUOTE QUOTE)
						   RESETX)
					     RESETY)
				       RESETZ)
				 (QUOTE INTERNAL)))
          (SETATOMVAL (CAAR MACROX)|
		      (CDDAR MACROX))|
          (SETQ RESETVARSLST (CDR MACROX))
          [COND
	    (MACROY (RETURN (CAR MACROY]
          (ERROR!])
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL RESETRESTORE RESETSAVE RESETVAR (GLOBALVARS RESETVARSLST))
]

(RPAQQ SORTCOMS [(FNS SORT SORT1 ALPHORDER MERGE)
		 (BLOCKS (MERGE MERGE ALPHORDER (NOLINKFNS . T))
			 (SORT SORT SORT1 ALPHORDER (LOCALFREEVARS COMPAREFN)
			       (NOLINKFNS . T))
			 (NIL ALPHORDER (LOCALVARS . T])
(DEFINEQ

(SORT
  [LAMBDA (DATA COMPAREFN)
    (COND
      [(NLISTP DATA)
	(COND
	  (DATA (ERROR (QUOTE "DATA NOT LIST:")
		       DATA]
      (T (OR COMPAREFN (SETQ COMPAREFN (FUNCTION ALPHORDER)))
	 (FRPLACD (LAST DATA)
		  NIL)
	 (SORT1 DATA])

(SORT1
  [LAMBDA (DATA END)                                        (* lmm "11-SEP-78 02:54"
)
    (COND
      ((OR (EQ DATA END)
	   (EQ (CDR DATA)
	       END))
	DATA)
      (T (PROG ((LIS DATA)
		(ALT DATA)
		TEM)

          (* Split DATA by setting ALT to one cell before its 
	  midpoint. DATA remains EQ to the original list.)


	   LP  (COND
		 ((AND (NEQ (SETQ LIS (CDR LIS))
			    END)
		       (NEQ (SETQ LIS (CDR LIS))
			    END))
		   (SETQ ALT (CDR ALT))
		   (GO LP)))
	       (SETQ TEM (SORT1 DATA (CDR ALT)))
	       (SORT1 (SETQ LIS (CDR ALT))
		      END)

          (* Merge DATA thru ALT with LIS 
	  (= (CDR ALT)) up to END. This is a little tricky 
	  because DATA must remain EQ to its original value.)


	   ALP (COND
		 ((EQ TEM LIS)
		                                            (* Exhausted first 
						list.)
		   (RETURN DATA)))
	   BLP (COND
		 ((SELECTQ COMPAREFN
			   [T (ALPHORDER (COND
					   ((LISTP (CAR TEM))
					     (CAAR TEM))
					   (T (CAR TEM)))
					 (COND
					   ((LISTP (CAR LIS))
					     (CAAR LIS))
					   (T (CAR LIS]
			   (ALPHORDER (ALPHORDER (CAR TEM)
						 (CAR LIS)))
			   (APPLY* COMPAREFN (CAR TEM)
				   (CAR LIS)))
		   (SETQ TEM (CDR TEM))
		   (GO ALP)))

          (* Move first element of second list 
	  (LIS = (CDR ALT)) to before first element of first 
	  list (TEM). This must be done by exchanging the CARs
	  and then patching up the CDRs, to retain the EQ 
	  property. This is a 'critical section' in that data 
	  will be lost if a hard interrupt occurs, but it 
	  cannot be interrupted by ^H because it does no 
	  function calls.)


	       [COND
		 [(EQ TEM ALT)
		                                            (* Special case.)
		   [FRPLACA TEM (PROG1 (CAR LIS)
				       (FRPLACA LIS (CAR TEM]
		   (SETQ LIS (CDR (SETQ TEM (SETQ ALT LIS]
		 (T [FRPLACD ALT (PROG1 (CDR LIS)
					(FRPLACA TEM (PROG1 (CAR LIS)
							    (FRPLNODE2 LIS TEM)
							    (FRPLACD TEM LIS]
		    (SETQ TEM LIS)
		    (SETQ LIS (CDR ALT]
	       (COND
		 ((NEQ LIS END)
		   (GO BLP)))                               (* Exhausted second 
						list.)
	       (RETURN DATA])

(ALPHORDER
  (LAMBDA (A B)                                             (* lmm "25-DEC-78 12:31")

          (* ALPHORDER compares two items from a list being sorted, returns T if they are in order, i.e. if it is ok to place 
	  A before B in the final list. Order of precedence is numbers, literals, and everything else.
	  Numbers are sorted by size; literals (strings, atoms and pnames) are sorted character by character by the magnitude 
	  of the character code (straight alphabetization is a subset of this) and other types are not sorted among 
	  themselves.)


    (COND
      ((FLOATP A)
	(OR (NOT (NUMBERP B))
	    (NOT (FGREATERP A B))))
      ((FIXP A)
	(COND
	  ((FLOATP B)
	    (NOT (FGREATERP A B)))
	  (T (OR (NOT (FIXP B))
		 (NOT (IGREATERP A B))))))
      ((NUMBERP B)
	NIL)
      ((OR (LITATOM A)
	   (STRINGP A))
	(OR (NOT (OR (STRINGP B)
		     (LITATOM B)))
	    (ASSEMBLE NIL
		      (CQ A)
		      (STE STPTT)
		      (HLRZ 1 , 2 (1))
		      (FASTCALL UPATM)
		      (PUSHNN (3)
			      (4))
		      (CQ B)
		      (STE STPTT)
		      (HLRZ 1 , 2 (1))
		      (FASTCALL UPATM)
		      (NREF (MOVE 5 , -1))
		      (NREF (MOVE 6 , 0))
		      (POPNN 2)

          (* At last the basic alphabetizer. Ac6 has NCHARS A; ac5 has byte pointer to A; ac4 has NCHARS B 
	  (from this call to UPATM), ac3 has byte pointer to B.)


		  LP  (SOJL 6 , SUCCEED)                    (* A won because shorter)
		      (SOJL 4 , FAIL)                       (* B won because shorter.)
		      (ILDB 1 , 5)
		      (ILDB 2 , 3)
		      (CAMN 1 , 2)
		      (JRST LP)                             (* Chars the same, try again.)
		      (CAML 1 , 2)                          (* A and B have different spellings.
							    Compare magnitude of character byte and exit with 
							    result.)
		  FAIL(SKIPA 1 , KNIL)
		  SUCCEED
		      (HRRZ 1 , KT))))
      ((OR (ATOM B)
	   (STRINGP B))
	NIL)
      (T T))))

(MERGE
  [LAMBDA (A B COMPAREFN)                                   (* lmm " 5-JAN-78 19:31"
)
    (PROG (ATAIL BTAIL)
          [COND
	    ((NULL B)
	                                                    (* MERGE will work if 
						either arg is NIL.)
	      (RETURN A))
	    ((NULL A)
	      (RETURN B))
	    ((NLISTP B)
	                                                    (* No possible meaning 
						here; user must be in 
						error.)
	      (ERRORX (LIST 4 B)))
	    ((NLISTP A)
	      (ERRORX (LIST 4 A)))
	    ([NOT (SELECTQ COMPAREFN
			   (T (ALPHORDER (CAAR A)
					 (CAAR B)))
			   (NIL (ALPHORDER (CAR A)
					   (CAR B)))
			   (APPLY* COMPAREFN (CAR A)
				   (CAR B]
	      

          (* (CAR A) must be before (CAR B) at LOOP (see comment below). If not, swap A and B. -
	  The SELECTQ compares the next things on A and B.)


	      (SETQ A (PROG1 B (SETQ B A]
          (SETQ ATAIL A)

          (* It is desireable to make the value of the merged 
	  list available to the user not only as the return 
	  from MERGE, but also on both the CONSES given as 
	  arguments. To this end, the MERGE is actually 
	  performed on the lists A and 
	  (CONS (CAR B) (CDR B)), so that when we return, the 
	  original B may be smashed with 
	  (CAR A) and (CDR A).)


          (SETQ BTAIL (CONS (CAR B)
			    (CDR B)))

          (* Whenever we pass LOOP, we know that ATAIL is 
	  LISTP, BTAIL is LISTP, and (CAR ATAIL) belongs 
	  before (CAR BTAIL). We therefore look to see if 
	  there is anything more on ATAIL;
	  if not, tie on BTAIL and return.
	  Otherwise, compare (CADR ATAIL) to 
	  (CAR BTAIL). If ATAIL wins, just take one CDR and go
	  around. But if BTAIL wins, then we swap 
	  variable/structures: ATAIL is rplacd'd to the 
	  structure that was on BTAIL, and BTAIL is bound to 
	  the old CDR of ATAIL. We then take the CDR and go 
	  around. Observe that this swapping preserves the 
	  assumptions made at LOOP.)


      LOOP[COND
	    [(NLISTP (CDR ATAIL))
	      (FRPLACD ATAIL BTAIL)
	      (RETURN (FRPLACA (FRPLACD B (CDR A))
			       (CAR A]
	    [(SELECTQ COMPAREFN
		      (NIL (ALPHORDER (CADR ATAIL)
				      (CAR BTAIL)))
		      (T (ALPHORDER (CAADR ATAIL)
				    (CAAR BTAIL)))
		      (APPLY* COMPAREFN (CADR ATAIL)
			      (CAR BTAIL]
	    (T (FRPLACD ATAIL (PROG1 BTAIL (SETQ BTAIL (CDR ATAIL]
          (SETQ ATAIL (CDR ATAIL))
          (GO LOOP])
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: MERGE MERGE ALPHORDER (NOLINKFNS . T))
(BLOCK: SORT SORT SORT1 ALPHORDER (LOCALFREEVARS COMPAREFN)
	(NOLINKFNS . T))
(BLOCK: NIL ALPHORDER (LOCALVARS . T))
]

(RPAQQ MAX.INTEGER 34359738367)

(RPAQQ MIN.INTEGER -34359738368)

(RPAQ MAX.FLOAT (MKATOM (QUOTE "1.70141182E38")))

(RPAQ MIN.FLOAT (FMINUS MAX.FLOAT))
(DEFINEQ

(INTEGERLENGTH
  [LAMBDA (N)                                               (* edited: "18-OCT-82 21:45")
    (ASSEMBLE NIL
	      (CQ (VAG (FIX N)))
	      (MOVM 1 , 1)                                  (* Makes negatives positive)
	      (JFFO 1 , ONE)
	      (CQ2 (VAG 44Q))
	  ONE (MOVEI 1 , 44Q)
	      (SUB 1 , 2)
	      (ADDI 1 , ASZ])
)

(RPAQQ FILENAMECOMS [(FNS FULLNAME OPENFILE PACKFILENAME UNPACKFILENAME FILENAMEFIELD LASTCHPOS)
		     (DECLARE: EVAL@COMPILE DONTCOPY (PROP MACRO CCONS CLIST)
			       (PROP MACRO UNPACKFILE1 UNPACKFILE2))
		     (VARS FILENAMEFIELDS)
		     (BLOCKS (NIL UNPACKFILENAME LASTCHPOS FILENAMEFIELD OPENFILE PACKFILENAME FULLNAME (LOCALVARS . T)
				  (LINKFNS . T)
				  (GLOBALVARS FILENAMEFIELDS])
(DEFINEQ

(FULLNAME
  [LAMBDA (X RECOG)                                         (* lmm "16-OCT-78 04:21")
    (PROG (JFN)
          (OR (LITATOM X)
	      (ERRORX (LIST 14 X)))
          (RETURN (PROG1 [JFNS (SETQ JFN (OR [GTJFN X NIL (SELECTQ RECOG
								   (OLDEST -2)
								   ((OLD/NEW NEWEST)
								     0)
								   NIL)
						    (SELECTQ RECOG
							     ((NIL OLD OLDEST)
							       32769)
							     (NEW 131073)
							     ((OLD/NEW NEWEST)
							       1)
							     (ERRORX (LIST 27 RECOG]
					     (RETURN]
			 (RLJFN JFN])

(OPENFILE
  [LAMBDA (FILE ACCESS RECOG BYTESIZE MACHINE.DEPENDENT.PARAMETERS)
                                   (* lmm "26-FEB-82 22:54")
    (PROG ([OPENFBITS (LOGOR (LLSH (OR BYTESIZE 7)
				   30)
			     (SELECTQ ACCESS
				      (INPUT 65536)
				      (OUTPUT 32768)
				      (BOTH 98304)
				      (APPEND 8192)
				      (ERRORX (LIST 27 ACCESS]
	   (EOL (QUOTE CRLF)))
          [MAPC MACHINE.DEPENDENT.PARAMETERS
		(FUNCTION (LAMBDA (X)
		    (SETQ OPENFBITS (LOGOR [SELECTQ X
						    (THAWED 1024)
						    (WAIT 512)
						    ((DON'T.CHANGE.READ.DATE DON'T.CHANGE.DATE)
						      256)
						    (COND
						      ((LISTP X)
							(SELECTQ (CAR X)
								 (MODE (LLSH (CADR X)
									     26))
								 ((EOL END-OF-LINE-CONVENTION)
								   (SETQ EOL (CADR X))
								   0)
								 0]
					   OPENFBITS]
          [ASSEMBLE NIL
		    [CQ (SETQ FILE (OPENF FILE OPENFBITS (SELECTQ
					    (OR RECOG (SETQ RECOG (SELECTQ ACCESS
									   (INPUT (QUOTE OLD))
									   (OUTPUT (QUOTE NEW))
									   ((BOTH APPEND)
									     (QUOTE OLD/NEW))
									   NIL)))
					    (OLD 
                                   (* old file only)
						 100001000000Q)
					    (OLDEST 
                                   (* old file only , default version -2)
						    100001777776Q)
					    (NEW 
                                   (* new file only -
				   default version -1)
						 -377776000001Q)
					    ((OLD/NEW NEWEST)
                                   (* either old or new; default version is oldest)
					      1000000Q)
					    (ERRORX (LIST 33Q RECOG]
		    (CQ (COND
			  ((NEQ EOL (QUOTE CRLF))
			    (ASSEMBLE NIL
				      (MOVSI 2 , (LRSH (BIT 2)
						       22Q))
				      (IORM 2 , FCHAR (FX]
          (RETURN FILE])

(PACKFILENAME
  [LAMBDA N                                                 (* rmk: " 1-MAR-82 09:17")
                                                            (* Note: DEVICE and STRUCTURE are identical but are for 
							    TENEX and TOPS20 respectively.)
    (COND
      ((AND (EQ N 1)
	    (LISTP (ARG N 1)))                              (* spread argument list)
	(APPLY (QUOTE PACKFILENAME)
	       (ARG N 1)))
      (T (PROG (HOST DEVICE STRUCTURE DIRECTORY NAME EXTENSION VERSION TEMPORARY PROTECTION ACCOUNT
		     (I 1)
		     PACKLIST VAR VAL (BLIP ""))
	       (DECLARE (SPECVARS HOST DEVICE STRUCTURE DIRECTORY NAME EXTENSION VERSION TEMPORARY 
				  PROTECTION ACCOUNT))
	   LP  (COND
		 ((NOT (IGREATERP I N))
		   (COND
		     ((LISTP (SETQ VAR (ARG N I)))
		       (SETQ VAL (CDR VAR))
		       (SETQ VAR (CAR VAR)))
		     ((NOT (IGREATERP (SETQ I (ADD1 I))
				      N))
		       (SETQ VAL (ARG N I)))
		     (T (SETQ VAL)))
		   (OR (STRINGP VAL)
		       (ATOM VAL)
		       (ERRORX (LIST 27 VAL)))              (* fields must be atom)
		   [COND
		     ((OR (EQ VAR (QUOTE BODY))
			  (AND (EQ VAR (QUOTE DIRECTORY))
			       (STRPOS (QUOTE :)
				       VAL)))               (* either BODY or DIRECTORY with a STRUCTURE attached)
		       (MAP (UNPACKFILENAME (COND
					      ((LISTP VAL)
                                                            (* The PACKFILENAME checks the list for errors)
						(PACKFILENAME VAL))
					      (T VAL)))
			    [FUNCTION (LAMBDA (X)
				(OR (EVALV (CAR X))
				    (SET (CAR X)
					 (OR (CADR X)
					     BLIP]
			    (FUNCTION CDDR)))
		     [(FMEMB VAR FILENAMEFIELDS)
		       (OR (EVALV VAR)
			   (SET VAR (OR VAL BLIP]
		     (T (ERRORX (LIST 27 VAR]
		   (SETQ I (ADD1 I))
		   (GO LP)))
	       [MAPC FILENAMEFIELDS (FUNCTION (LAMBDA (X)
			 (COND
			   ((EQ (EVALV X)
				BLIP)
			     (SET X]
	       [COND
		 (TEMPORARY (SETQ TEMPORARY (MKATOM TEMPORARY))
			    (COND
			      ([AND (EQ (SYSTEMTYPE)
					(QUOTE TOPS20))
				    (NULL VERSION)
				    (FMEMB TEMPORARY (QUOTE (S ;S]
				(SETQ VERSION -1)
				(SETQ TEMPORARY T]
	       (RETURN (PACK (NCONC (AND HOST (CLIST (QUOTE {)
						     HOST
						     (QUOTE })))
				    [AND (OR DEVICE (SETQ DEVICE STRUCTURE))
					 (SELECTQ (MKATOM DEVICE)
						  [(NUL NUL: NIL:)
						    (CCONS (SELECTQ (SYSTEMTYPE)
								    (TOPS20 (QUOTE NUL:))
								    (QUOTE NIL:]
						  (CLIST DEVICE (COND
							   ((NEQ (NTHCHAR DEVICE -1)
								 (QUOTE :))
							     (QUOTE :))
							   (T BLIP]
				    [AND DIRECTORY (COND
					   ((EQ (NTHCHAR DIRECTORY 1)
						(QUOTE <))
					     (CCONS DIRECTORY))
					   (T (CLIST (QUOTE <)
						     DIRECTORY
						     (QUOTE >]
				    (AND NAME (CCONS NAME))
				    (AND (OR EXTENSION VERSION)
					 (CLIST (COND
						  ((AND EXTENSION (EQ (NTHCHAR EXTENSION 1)
								      (QUOTE %.)))
						    BLIP)
						  (T (QUOTE %.)))
						(OR EXTENSION BLIP)))
				    (AND VERSION (PROGN (OR (FIXP VERSION)
							    (SELECTQ (NTHCHAR VERSION 1)
								     [(%. ;)
								       (SETQ VERSION
									 (SUBSTRING VERSION 2 -1
										    (CONSTANT
										      (CONCAT]
								     NIL))
							(CLIST (SELECTQ (SYSTEMTYPE)
									(TOPS20 (QUOTE %.))
									(QUOTE ;))
							       VERSION)))
				    (AND PROTECTION (CLIST (COND
							     ((EQ (NTHCHAR PROTECTION 1)
								  (QUOTE ;))
							       BLIP)
							     ((EQ (NTHCHAR PROTECTION 1)
								  (QUOTE P))
							       (QUOTE ;))
							     (T (QUOTE ";P")))
							   PROTECTION))
				    (AND ACCOUNT (CLIST (COND
							  ((EQ (NTHCHAR ACCOUNT 1)
							       (QUOTE ;))
							    BLIP)
							  ((EQ (NTHCHAR ACCOUNT 1)
							       (QUOTE A))
							    (QUOTE ;))
							  (T (QUOTE ";A")))
							ACCOUNT))
				    (AND TEMPORARY (CLIST (QUOTE ;)
							  (SELECTQ TEMPORARY
								   ((S ;S)
								     (QUOTE S))
								   T])

(UNPACKFILENAME
  [LAMBDA (FILE ONEFIELDFLG)       (* lmm "30-SEP-81 10:24")
    (OR (LITATOM FILE)
	(STRINGP FILE)
	(ERRORX (LIST 27 FILE)))
    (PROG (TEM (POS 1)
	       INEXT INVERS VAL CODE)
          (OR FILE (RETURN))
          [COND
	    ((AND (EQ (NTHCHARCODE FILE 1)
		      (CHARCODE {))
		  (SETQ TEM (LASTCHPOS (CHARCODE })
				       FILE 2)))
	      (UNPACKFILE1 (QUOTE HOST)
			   2
			   (SUB1 TEM))
	      (SETQ POS (ADD1 TEM]
          [COND
	    ((SETQ TEM (LASTCHPOS (CHARCODE :)
				  FILE POS))
                                   (* all device returned have : on it so that NIL: will work)
	      (UNPACKFILE1 (SELECTQ (SYSTEMTYPE)
				    (TOPS20 (QUOTE STRUCTURE))
				    (QUOTE DEVICE))
			   POS TEM)
	      (SETQ POS (ADD1 TEM]
          (SELCHARQ (NTHCHARCODE FILE POS)
		    [(< >)
		      (COND
			((SETQ TEM (LASTCHPOS (CHARCODE >)
					      FILE POS))
			  (UNPACKFILE1 (QUOTE DIRECTORY)
				       (ADD1 POS)
				       (SUB1 TEM))
			  (SETQ POS (ADD1 TEM)))
			((SETQ TEM (LASTCHPOS (CHARCODE ESC)
					      FILE POS))
			  (UNPACKFILE1 (QUOTE DIRECTORY)
				       (ADD1 POS)
				       (SETQ POS TEM]
		    NIL)
          (OR (SETQ CODE (NTHCHARCODE FILE (SETQ TEM POS)))
	      (RETURN (DREVERSE VAL)))
      NAMELP
          (SELCHARQ CODE
		    (%.            (* delimits end of NAME or EXTENSION)
			(UNPACKFILE1 (COND
				       ((NOT INEXT)
					 (SETQQ INEXT NAME))
				       (T (SETQQ INVERS EXTENSION)))
				     POS
				     (SUB1 TEM))
			(SETQ POS (ADD1 TEM)))
		    ((! ;)         (* delimits end of NAME EXTENSION VERSION or special field)
		      (UNPACKFILE2 POS TEM)
		      (SETQ POS (ADD1 TEM)))
		    (NIL (UNPACKFILE2 POS TEM)
			 (RETURN (DREVERSE VAL)))
		    NIL)
          (SETQ CODE (NTHCHARCODE FILE (add TEM 1)))
          (GO NAMELP)
      OUT (RETURN VAL])

(FILENAMEFIELD
  [LAMBDA (FILE FIELDNAME)         (* lmm "22-APR-81 22:00")
    (UNPACKFILENAME FILE (SELECTQ FIELDNAME
				  ((VERSION GENERATION)
				    (QUOTE (VERSION GENERATION)))
				  ((DEVICE STRUCTURE)
				    (QUOTE (DEVICE STRUCTURE)))
				  FIELDNAME])

(LASTCHPOS
  [LAMBDA (CH STR START)           (* lmm " 3-DEC-80 23:48")
    (PROG (RESULT NC)
          (OR START (SETQ START 1))
          (while (SETQ NC (NTHCHARCODE STR START)) do (COND
							((EQ CH NC)
							  (SETQ RESULT START)))
						      (add START 1))
          (RETURN RESULT])
)
(DECLARE: EVAL@COMPILE DONTCOPY 

(PUTPROPS CCONS MACRO ((X Y)
		       (FRPLNODE (CONSTANT (CONS))
				 X Y)))

(PUTPROPS CLIST MACRO [X (AND X (LIST (QUOTE CCONS)
				      (CAR X)
				      (CONS (QUOTE CLIST)
					    (CDR X])


(PUTPROPS UNPACKFILE1 MACRO [LAMBDA (NAM ST END)            (* lmm "22-APR-81 22:21")
			      (PROG NIL
				    [COND
				      (ONEFIELDFLG (COND
						     ((EQMEMB NAM ONEFIELDFLG)
						       (SETQ VAL (SUBATOM FILE ST END))
						       (GO OUT))
						     (T (RETURN]
				    (SETQ VAL (CONS (SUBATOM FILE ST END)
						    (CONS NAM VAL])

(PUTPROPS UNPACKFILE2 MACRO [LAMBDA (POS TEM)               (* lmm "22-APR-81 21:47")
			      (UNPACKFILE1 [COND
					     ((NOT INEXT)
					       (SETQ INVERS (QUOTE ;))
					       (SETQQ INEXT NAME))
					     ((NOT INVERS)
					       (SETQQ INVERS ;)
					       (QUOTE EXTENSION))
					     (T (SELCHARQ (AND (EQ INVERS (QUOTE ;))
							       (NTHCHARCODE FILE POS))
							  (P (QUOTE PROTECTION))
							  (A (add POS 1)
							     (QUOTE ACCOUNT))
							  ((T S)
							    (QUOTE TEMPORARY))
							  (QUOTE VERSION]
					   POS
					   (SUB1 TEM])
)

(RPAQQ FILENAMEFIELDS (HOST DEVICE STRUCTURE DIRECTORY NAME EXTENSION VERSION TEMPORARY PROTECTION ACCOUNT))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL UNPACKFILENAME LASTCHPOS FILENAMEFIELD OPENFILE PACKFILENAME FULLNAME (LOCALVARS . T)
	(LINKFNS . T)
	(GLOBALVARS FILENAMEFIELDS))
]

(RPAQQ PRINTNUMCOMS [(FNS CPRINTNUM FLTFMT NUMFORMATCODE PRINTNUM)
		     (PROP 10MACRO FLTFMT PRINTNUM)
		     (VARS (NILNUMPRINTFLG))
		     [DECLARE: FIRST (P (MOVD? (QUOTE FLTFMT)
					       (QUOTE OLDFLTFMT]
		     (BLOCKS (NIL PRINTNUM NUMFORMATCODE (LOCALVARS . T)
				  (GLOBALVARS MACSCRATCHSTRING NILNUMPRINTFLG))
			     (NIL CPRINTNUM FLTFMT (LOCALVARS . T])
(DEFINEQ

(CPRINTNUM
  [LAMBDA (FN ARGS)                                         (* lmm "26-SEP-78 15:05"
)

          (* Compiles calls for PRINTNUM and FLTFMT 
	  efficiently if the format is quoted or constant)


    (PROG ((ARG1 (CAR ARGS)))
          (RETURN (COND
		    [(AND (LISTP (SELECTQ (CAR (LISTP ARG1))
					  (QUOTE (SETQ ARG1 (CADR ARG1)))
					  (CONSTANT (SETQ ARG1 (EVAL ARG1)))
					  NIL))
			  (LISTP (CDR ARG1)))
		      (CONS FN (CONS [COND
				       ((EQ FN (QUOTE FLTFMT))
					 (CDR (NUMFORMATCODE ARG1)))
				       (T (KWOTE (NUMFORMATCODE ARG1]
				     (CDR ARGS]
		    (T (QUOTE IGNOREMACRO])

(FLTFMT
  [LAMBDA (FORMATBITS)                                      (* wt: "10-SEP-78 15:06")
    (OLDFLTFMT (COND
		 [(EQ (CAR (LISTP FORMATBITS))
		      (QUOTE FLOAT))
		   (CDR (NUMFORMATCODE FORMATBITS (CONSTANT (NUMFORMATCODE]
		 (T FORMATBITS])

(NUMFORMATCODE
  (LAMBDA (FORMAT SMASHCODE)                                (* lmm "26-SEP-78 15:05")

          (* Converts FORMAT to a machine-dependent number-printing format code. -
	  On the 10, the code is a cons whose car is either FLOAT or FIX and whose cdr is a large integer whose bits are 
	  interpretable by the FLOUT or NOUT JSYSes, respectively. If SMASHCODE is supplied, then the new code is smashed into
	  the old structure.)


    (COND
      ((NLISTP FORMAT)
	(CONS NIL (IPLUS 10000)))
      ((TYPEP (CDR FORMAT)
	      18)
	FORMAT)
      (T (COND
	   ((NOT (TYPEP (CDR (LISTP SMASHCODE))
			18))
	     (SETQ SMASHCODE (CONS NIL (IPLUS 10000)))))
	 (SELECTQ (CAR (LISTP FORMAT))
		  (FLOAT (PROG ((WIDTH (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
				(DECPART (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
				(EXPART (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
				(PAD0FLAG (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
				(ROUND (CAR (LISTP (SETQ FORMAT (CDR FORMAT))))))
                                                            (* Creates format code for FLOUT.)
			       (COND
				 ((NOT EXPART)
				   (SETQ EXPART 0))
				 ((IGREATERP EXPART 0)
				   (SETQ EXPART (IPLUS EXPART 2))))
                                                            (* Leave room for E+)
			       (CAR (FRPLACA SMASHCODE (QUOTE FLOAT)))
			       (FREPLACEFIELD 608174080 (CDR SMASHCODE)
					      (LOGOR (COND
						       (PAD0FLAG 
                                                            (* 64 means go to freeformat on overflow)
								 (CONSTANT (LLSH 16448 18)))
						       (T (CONSTANT (LLSH 64 18))))
						     (COND
						       ((NOT DECPART)
							 (SETQ DECPART 0)
							    (* If NIL, then no decimal point)
							 (SETQ WIDTH (ADD1 WIDTH))
							    (* Fieldwidths are wrong for integer printing.)
							 0)
						       (T (CONSTANT (LLSH 2048 18))))
						     (COND
						       ((ZEROP EXPART)
							 0)
						       (T 
                                                            (* Print E+ for positive exponents)
							  (CONSTANT (LLSH 640 18))))
						     (LLSH (OR ROUND 0)
							   18)
						     (LLSH (IDIFFERENCE WIDTH (IPLUS EXPART DECPART 1)
									)
							   12)
						     (LLSH DECPART 6)
						     EXPART))
                                                            (* The 0 is also left-shifted in ROUND to avoid the 
							    boxing when ROUND is specified.)
			       (COND
				 ((IGREATERP (IPLUS DECPART EXPART)
					     WIDTH)
				   (ERROR "Decimal field too wide" (CONS WIDTH DECPART))))))
		  (FIX (PROG ((WIDTH (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
			      (RADIX (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
			      (PAD0FLAG (CAR (LISTP (SETQ FORMAT (CDR FORMAT)))))
			      (LEFTFLUSHFLAG (CAR (LISTP (SETQ FORMAT (CDR FORMAT))))))
                                                            (* Creates format code for NOUT.)
			     (COND
			       ((NOT RADIX)
				 (SETQ RADIX 10)))
			     (CAR (FRPLACA SMASHCODE (QUOTE FIX)))
			     (FREPLACEFIELD 608174080 (CDR SMASHCODE)
					    (LOGOR (COND
						     ((MINUSP RADIX)
						       (SETQ RADIX (IMINUS RADIX))
						       (CONSTANT (LLSH 131072 18)))
						     (T 0))
						   (COND
						     (LEFTFLUSHFLAG 0)
						     (T (CONSTANT (LLSH 32768 18))))
						   (COND
						     (PAD0FLAG 
                                                            (* All digits on overflow)
							       (CONSTANT (LLSH 24576 18)))
						     (T (CONSTANT (LLSH 8192 18))))
						   (LLSH WIDTH 18)
						   RADIX))))
		  (ERRORX (LIST 27 FORMAT)))
	 SMASHCODE))))

(PRINTNUM
  [LAMBDA (FORMAT NUMBER FILE)                              (* lmm "24-SEP-78 02:07"
)
    (PROG (ENDPOS WIDTH [FORMATCODE (COND
				      ((TYPEP (CDR (LISTP FORMAT))
					      18)
					FORMAT)
				      (T (NUMFORMATCODE FORMAT (CONSTANT (NUMFORMATCODE]
		  FLOATFLAG CODE)
          (SETQ FLOATFLAG (EQ (CAR FORMATCODE)
			      (QUOTE FLOAT)))
          (SETQ CODE (CDR FORMATCODE))
          [SETQ WIDTH (COND
	      (FLOATFLAG (IPLUS (FFETCHFIELD 31159484416 CODE)
				(FFETCHFIELD 12989759488 CODE)
				(FFETCHFIELD 6547308544 CODE)
				(FFETCHFIELD 104857600 CODE)))
	      (T (FFETCHFIELD 19448987648 CODE]
          (SETQ ENDPOS (IPLUS WIDTH (POSITION FILE)))       (* The correction for 
						POINT is wrong if 
						POINT=0~=FIELD2)
          (PRIN1 [COND
		   ((AND (NULL NUMBER)
			 NILNUMPRINTFLG)
		     (SPACES (IDIFFERENCE WIDTH (NCHARS NILNUMPRINTFLG))
			     FILE)
		     NILNUMPRINTFLG)
		   (T (ASSEMBLE NIL
			        (CQ CODE)
			        (MOVE 1 , 0 (1))

          (* Get the bits whether fixed or float.
	  Note: NOUT formatcodes are never SMALLP)


			        (PUSHN)
			        [CQ (COND
				      (FLOATFLAG (ASSEMBLE NIL
						           (CQ (VAG (FLOAT NUMBER)))
                                                            (* Guarantee 
						normalization)
						           (FSC 1 , 0)))
				      [(FLOATP NUMBER)
					(VAG (FIX (FPLUS NUMBER (COND
							   ((MINUSP NUMBER)
							     -.5)
							   (T .5]
				      (T (VAG NUMBER]
			        (PUSHN)
			        (CQ MACSCRATCHSTRING)
			        (PUSHJ CP , UPATM)
			        (MOVES 0 (3))
			        (MOVE 4 , 3)
			        (MOVE 1 , 3)                (* Destination in ac1 
						specifies bytes in 
						MACSCRATCHSTRING)
			        (POPN 2)
			        (POPN 3)
			        (VAR (HRRZ 5 , FLOATFLAG))
                                                            (* Test FLOATFLAG in 5)
			        (CAMN 5 , KNIL)
			        (JUMPA FIXED)
			        (JSYS 233Q)
			        (CAIN 3 , 600660Q)
			        (JUMPA OK)
			        (JUMPA ERROR)               (* Overflow OK)
			    FIXED
			        (JSYS 224Q)
			        (CAIN 3 , 600410Q)
			        (JUMPA OK)                  (* Overflow OK)
			    ERROR
			        (CQ (ERRORX (LIST 33Q FORMAT)))
			    OK  (MOVEI 2 , 0)
			        (IDPB 2 , 1)                (* deposit null byte at 
						end)
			    )
		      (STRCONC1 (CONSTANT (CONCAT]
		 FILE)
          (TAB ENDPOS 0 FILE)
          (RETURN NUMBER])
)

(PUTPROPS FLTFMT 10MACRO (ARGS (CPRINTNUM (QUOTE FLTFMT)
					  ARGS)))

(PUTPROPS PRINTNUM 10MACRO (ARGS (CPRINTNUM (QUOTE PRINTNUM)
					    ARGS)))

(RPAQQ NILNUMPRINTFLG NIL)
(DECLARE: FIRST 
(MOVD? (QUOTE FLTFMT)
       (QUOTE OLDFLTFMT))
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL PRINTNUM NUMFORMATCODE (LOCALVARS . T)
	(GLOBALVARS MACSCRATCHSTRING NILNUMPRINTFLG))
(BLOCK: NIL CPRINTNUM FLTFMT (LOCALVARS . T))
]

(RPAQQ WAITFORINPUTCOMS ((FNS WAITFORINPUT WAITN WAITFILE)
			 (DECLARE: EVAL@COMPILE DONTCOPY (P (LOAD? (QUOTE <LISPUSERS>CJSYS.COM)
								   (QUOTE SYSLOAD)))
				   (ADDVARS (DONTCOMPILEFNS WAITN WAITFILE))
				   (PROP 10MACRO WAITN WAITFILE))
			 (BLOCKS (NIL WAITFORINPUT (LOCALVARS . T)
				      (GLOBALVARS DISMISSINIT DISMISSMAX)))
			 (VARS DISMISSINIT DISMISSMAX)))
(DEFINEQ

(WAITFORINPUT
  [LAMBDA (FILE)                                            (* lmm "30-SEP-78 22:35"
)

          (* wait for input from FILE or T -
	  if FILE is number then rather than waiting for file,
	  wait for number seconds)


    (COND
      ((READP T))
      ((NUMBERP FILE)
	(WAITN FILE))
      ((READP FILE)
	FILE)
      (T (WAITFILE FILE])

(WAITN
  [LAMBDA (X)                                               (* lmm "26-SEP-78 16:39"
)
                                                            (* This is a dummy 
						definition, since WAITN 
						compiles open)
    (PROG ((W DISMISSINIT))
      LP  (COND
	    ((READP T)
	      (RETURN T))
	    ((ILEQ X 0)
	      (RETURN))
	    (T (COND
		 ((IGREATERP W X)
		   (SETQ W X)))
	       (DISMISS W)
	       (SETQ X (IDIFFERENCE X W))
	       (SETQ W (IPLUS W (LRSH W 4)
			      1))
	       (COND
		 ((IGREATERP W DISMISSMAX)
		   (SETQ W DISMISSMAX)))
	       (GO LP])

(WAITFILE
  [LAMBDA (X)                                               (* lmm "26-SEP-78 16:04"
)
                                                            (* This is a dummy 
						definition, since 
						WAITFILE compiles open)
    (PROG ((W DISMISSINIT))
      LP  (COND
	    ((READP T)
	      (RETURN T))
	    ((READP FILE)
	      (RETURN FILE))
	    (T (DISMISS W)
	       (SETQ W (IPLUS W (LRSH W 4)
			      1))
	       (COND
		 ((IGREATERP W DISMISSMAX)
		   (SETQ W DISMISSMAX)))
	       (GO LP])
)
(DECLARE: EVAL@COMPILE DONTCOPY 
(LOAD? (QUOTE <LISPUSERS>CJSYS.COM)
       (QUOTE SYSLOAD))


(ADDTOVAR DONTCOMPILEFNS WAITN WAITFILE)


(PUTPROPS WAITN 10MACRO ((N)
			 (ASSEMBLE NIL (PUSHNN (0)
					       (0)
					       (0))
				   (CQ (VAG (FIX N)))
				   (NREF (MOVEM 1 , 0))
				   (CQ (VAG (FIX DISMISSINIT)))
				   (NREF (MOVEM 1 , -1))
				   (CQ (VAG (FIX DISMISSMAX)))
				   (NREF (MOVEM 1 , -2))
				   LP
				   (MOVEI 1 , 64)
				   (JS SIBE)
				   (JRST TRUE)
				   (* something waiting in input buffer, we are done)
				   (NREF (SKIPG 0))
				   (JRST FALSE)
				   (NREF (MOVE 1 , -1))
				   (NREF (CAMLE 1 , 0))
				   (NREF (MOVE 1 , 0))
				   (JS DISMS)
				   (MOVN 3 , 1)
				   (NREF (ADDM 3 , 0))
				   (LSH 1 , -4)
				   (NREF (ADD 1 , -1))
				   (ADDI 1 , 1)
				   (NREF (CAMLE 1 , -2))
				   (NREF (MOVE 1 , -2))
				   (NREF (MOVEM 1 , -1))
				   (JRST LP)
				   TRUE
				   (SKIPA 1 , ' T)
				   FALSE
				   (HRRZ 1 , ' NIL)
				   EXIT
				   (POPNN 3))))

(PUTPROPS WAITFILE 10MACRO ((FILE)
			    (ASSEMBLE NIL (PUSHNN (0)
						  (0)
						  (0))
				      [CQ (VAG (FIX (OPNJFN FILE (QUOTE INPUT]
				      (NREF (MOVEM 1 , 0))
				      (CQ DISMISSINIT)
				      (NREF (MOVEM 1 , -1))
				      (CQ DISMISSMAX)
				      (NREF (MOVEM 1 , -2))
				      LP
				      (MOVEI 1 , 64)
				      (JS SIBE)
				      (JRST TRUE)
				      (NREF (MOVE 1 , 0))
				      (JS SIBE)
				      (JRST RFILE)
				      (NREF (MOVE 1 , -1))
				      (JS DISMS)
				      (LSH 1 , -4)
				      (NREF (ADD 1 , -1))
				      (ADDI 1 , 1)
				      (NREF (CAMLE 1 , -2))
				      (NREF (MOVE 1 , -2))
				      (NREF (MOVEM 1 , -1))
				      (JRST LP)
				      RFILE
				      (VAR (SKIPA 1 , FILE))
				      TRUE
				      (HRRZ 1 , ' T)
				      EXIT
				      (POPNN 3))))
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL WAITFORINPUT (LOCALVARS . T)
	(GLOBALVARS DISMISSINIT DISMISSMAX))
]

(RPAQQ DISMISSINIT 500)

(RPAQQ DISMISSMAX 5000)
(DEFINEQ

(LISTFILES1
  [LAMBDA (FILE)                                            (* lmm "17-Aug-84 23:35")
    (TENEX (CONCAT (SELECTQ (SYSTEMTYPE)
			    (TENEX "LIST")
			    "PRINT ")
		   FILE "


"])
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL RETEVAL RETAPPLY STKEVAL STKAPPLY (LINKFNS . T)
	(GLOBALVARS **RETEVAL)
	(LOCALVARS . T))
(BLOCK: NIL DUMMYFRAMEP REALFRAMEP REALSTKNTH (GLOBALVARS OPENFNS)
	(LOCALVARS . T)
	(LINKFNS . T))
(BLOCK: NIL SETNM RANDACCESSP SETLINELENGTH (GLOBALVARS TTYLINELENGTH)
	DISPLAYTERMP PRINTARRAY (LOCALVARS . T)
	(NOLINKFNS . T))
(BLOCK: NIL ADDSTATS STATINIT (GLOBALVARS SYSTATS STATARRAY)
	LISPXWATCH
	(LOCALVARS . T))
(BLOCK: LISPXSTATS LISPXSTATS LISPXSTATS1 (GLOBALVARS SYSTATS CONSOLETIME CONSOLETIME0 EDITIME CPUTIME CPUTIME0 FIXTIME))
(BLOCK: NIL GCGAG (LOCALVARS . T)
	(GLOBALVARS GCGAG GCMESS1 GCMESS2 GCMESS3 GCMESS4 GCMESS5 GCMESS6 GCMESS7))
(BLOCK: NIL U-CASEP U-CASE L-CASE L-CASE1 (LOCALVARS . T)
	(LINKFNS . T)
	(GLOBALVARS CHCONLST))
]
(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA RESETSAVE ADDSTATS)

(ADDTOVAR NLAML RESETVAR)

(ADDTOVAR LAMA PACKFILENAME)
)
(PUTPROPS MACHINEDEPENDENT COPYRIGHT (NONE))
(DECLARE: DONTCOPY
  (FILEMAP (NIL (7495 7895 (GREETFILENAME 7507 . 7892)) (8087 14679 (PRINTARRAY 8099 . 9213) (DISPLAYTERMP 9217 . 9819) (SETLINELENGTH
 9823 . 10316) (SETNM 10320 . 10381) (RANDACCESSP 10385 . 10753) (U-CASEP 10757 . 11670) (U-CASE 11674 . 12279) (L-CASE 12283 . 
12557) (L-CASE1 12561 . 13503) (SUBATOM 13507 . 13588) (GCGAG 13592 . 14676)) (15180 16200 (CHECKNIL 15192 . 16197)) (16202 19331 (
RETEVAL 16214 . 16395) (RETAPPLY 16399 . 16586) (STKEVAL 16590 . 16723) (STKAPPLY 16727 . 16865) (DUMMYFRAMEP 16869 . 17136) (
REALFRAMEP 17140 . 18676) (REALSTKNTH 18680 . 19328)) (19392 21963 (LISPXSTATS 19404 . 20339) (LISPXSTATS1 20343 . 20576) (
LISPXWATCH 20580 . 20720) (STATINIT 20724 . 21384) (ADDSTATS 21388 . 21960)) (22425 27422 (RESETRESTORE 22437 . 24071) (RESETSAVE 
24075 . 26140) (RESETVAR 26144 . 27419)) (27780 34904 (SORT 27792 . 28046) (SORT1 28050 . 30325) (ALPHORDER 30329 . 32370) (MERGE 
32374 . 34901)) (35305 35685 (INTEGERLENGTH 35317 . 35682)) (36099 45175 (FULLNAME 36111 . 36680) (OPENFILE 36684 . 38541) (
PACKFILENAME 38545 . 42626) (UNPACKFILENAME 42630 . 44559) (FILENAMEFIELD 44563 . 44847) (LASTCHPOS 44851 . 45172)) (47097 54395 (
CPRINTNUM 47109 . 47764) (FLTFMT 47768 . 48041) (NUMFORMATCODE 48045 . 51795) (PRINTNUM 51799 . 54392)) (55261 56821 (WAITFORINPUT 
55273 . 55658) (WAITN 55662 . 56277) (WAITFILE 56281 . 56818)) (58931 59158 (LISTFILES1 58943 . 59155)))))
STOP
