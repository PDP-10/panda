(FILECREATED "11-Jul-84 23:27:40" <NEWLISP>LMMAC..156 39415  

      changes to:  (VARS LMMACCOMS)

      previous date: "24-NOV-82 23:22:42" <NEWLISP>LMMAC..155)


(* Copyright (c) 1982, 1984 by Xerox Corporation)

(PRETTYCOMPRINT LMMACCOMS)

(RPAQQ LMMACCOMS [(COMS * SPELLFILECOMS)
		  (COMS * FILEWONTOPENCOMS)
		  (COMS * PMAPCOMS)
		  (COMS * FILEINFOCOMS)
		  (FNS)
		  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)
											(NLAML)
											(LAMA])

(RPAQQ SPELLFILECOMS ((* File name spelling correction)
		      (FNS SPELLFILE SPELLFILE1 LGTJFN FINDFILE)
		      (BLOCKS (NIL FINDFILE SPELLFILE LGTJFN SPELLFILE1 (LOCALVARS . T)
				   (GLOBALVARS DWIMFLG NOSPELLFLG SPELLFILE USERNAME DIRECTORIES)))
		      (VARS (SPELLFILE (ARRAY 5)))
		      (ADDVARS [ERRORTYPELST (23 (SPELLFILE (CADR ERRORMESS]
			       (DIRECTORIES NIL LISP)
			       (LISPUSERSDIRECTORIES LISPUSERS LISP))))



(* File name spelling correction)

(DEFINEQ

(SPELLFILE
  [LAMBDA (FILE NOPRINTFLG NSFLG DIRLST)
                                   (* lmm "24-NOV-82 23:22")
    (AND FILE (PROG ((FIELDS (UNPACKFILENAME FILE))
		     JFN VAL TEM EXT DIR NAM VER (DIRS (OR DIRLST DIRECTORIES))
		     (APPFLG (QUOTE MUST-APPROVE))
		     DEV
		     (NSFLG (OR NSFLG NOSPELLFLG (NULL DWIMFLG)))
		     FIL)
		    (DECLARE (SPECVARS DIR NAM EXT VER JFN))
		FLDLP
		    (COND
		      (FIELDS (SELECTQ (CAR FIELDS)
				       (NAME (SETQ NAM (CADR FIELDS)))
				       (VERSION (SETQ VER (CADR FIELDS)))
				       (EXTENSION (SETQ EXT (CADR FIELDS)))
				       (DIRECTORY (SETQ DIR (CADR FIELDS)))
				       (DEVICE (OR [AND (NULL DEV)
							(SETQ DIRS (GETPROP (SETQ DEV (CADR FIELDS))
									    (QUOTE DIRECTORIES]
						   (RETURN)))
				       (RETURN))
			      (SETQ FIELDS (CDDR FIELDS))
			      (GO FLDLP)))
		    [COND
		      ((OR DIR DEV VER)
			(SETQ FIL (PACKFILENAME (QUOTE NAME)
						NAM
						(QUOTE EXTENSION)
						EXT))
			(COND
			  ([AND [SETQ TEM (OR (INFILEP FIL)
					      (AND DIR (INFILEP (PACKFILENAME (QUOTE DIRECTORY)
									      DIR
									      (QUOTE NAME)
									      NAM
									      (QUOTE EXTENSION)
									      EXT]
				(SOME (GETPROP FIL (QUOTE FILEDATES))
				      (FUNCTION (LAMBDA (X TAIL)
					  (COND
					    ((AND (EQ (CDR X)
						      TEM)
						  (STREQUAL (CAR X)
							    (FILEDATE TEM)))
                                   (* already did this correction)
					      (SETQ VAL TEM)
					      (SETQ APPFLG (QUOTE NO-MESSAGE)))
					    ((AND (EQ (CDR X)
						      FILE)
						  (STREQUAL (CAR X)
							    (FILEDATE TEM)))
					      (SETQ VAL TEM)
					      (/ATTACH (CONS (CAR X)
							     VAL)
						       TAIL)
					      (SETQ APPFLG (QUOTE NEEDNOTAPPROVE]

          (* attacks problem where sombody wants a specific file, e.g. makefile wants the source, the file is around, but with
	  a different verson number, e.g. was ftped from maxc, and user didnt loadfrom symbolic but instead just started 
	  editing with compiled file having been loaded. something like this might be useful on maxc as well.
	  however, occurs far less frequently since would require deleting of the original file as well as copying it 
	  somewhere else)

                                   (* works by looking to see if latest verson of rootname in fact has some filedate
				   as requested file.)
			    (GO RET)))
			(COND
			  (DIR     (* user supplied directory)
			       (COND
				 ((DIRECTORYNAMEP DIR)
				   (GO SPELLNAME))
				 ([AND (NOT NSFLG)
				       (FIXSPELL DIR 70 DIRS (QUOTE NO-MESSAGE)
						 NIL
						 (FUNCTION (LAMBDA (DR)
						     (AND (SETQ JFN (LGTJFN DR NAM EXT VER 32768))
							  (RETFROM (QUOTE FIXSPELL)
								   JFN]
				   (GO JRET))
				 (T (RETURN]
		DIRLP
		    [COND
		      [DIRS (COND
			      ((SETQ JFN (LGTJFN [SELECTQ (CAR DIRS)
							  (NIL USERNAME)
							  (T (DIRECTORYNAME T T))
							  (COND
							    [(EQ (CHCON1 (CAR DIRS))
								 (CHARCODE <))
							      (SUBSTRING
								(CAR DIRS)
								2
								(COND
								  ((EQ (NTHCHARCODE (CAR DIRS)
										    -1)
								       (CHARCODE >))
								    -2)
								  (T -1]
							    (T (CAR DIRS]
						 NAM EXT VER 32768))
				[SETQ APPFLG (COND
				    ((OR NOPRINTFLG DEV)
				      (QUOTE NO-MESSAGE))
				    (T (QUOTE NEEDNOTAPPROVE]
				(GO JRET))
			      (T (SETQ DIRS (CDR DIRS))
				 (GO DIRLP]
		      (T (AND [LISTP (SETQ TEM (GETPROP FILE (QUOTE FILEDATES]
			      (LITATOM (CDAR TEM))
			      (SETQ VAL (INFILEP (CDAR TEM)))
			      (GO RET]
		SPELLNAME
		    (COND
		      (NSFLG (RETURN)))
		    (SETA SPELLFILE 2 (SETQ JFN (LOGAND [SETA SPELLFILE 3
							      (OR (COND
								    (EXT 
                                   (* extension misspelled)
									 (LGTJFN DIR NAM
										 (QUOTE *)
										 VER 32833)))
								  (PROGN 
                                   (* name misspelled)
									 (LGTJFN DIR (QUOTE *)
										 EXT VER 32833))
								  (PROGN 
                                   (* Can't have both name and extension misspelled)
									 (RETURN NIL]
							262143)))
		    (SETA SPELLFILE 5 (COND
			    (EXT 150994945)
			    (T 134217729)))
		    (SETA SPELLFILE 1 (FUNCTION SPELLFILE1))
		    [COND
		      ([NOT (SETQ VAL (FIXSPELL (OR FIL FILE)
						NIL SPELLFILE (QUOTE NO-MESSAGE]
			(RETURN))
		      (FIL (SETQ VAL (PACKFILENAME (QUOTE BODY)
						   VAL
						   (QUOTE DIRECTORY)
						   DIR
						   (QUOTE DEVICE)
						   DEV
						   (QUOTE VERSION)
						   VER]
		    (GO RET)
		JRET(SETQ VAL (JFNS JFN))
		    (RLJFN JFN)
		RET (RETURN (AND (OR (EQ APPFLG (QUOTE NO-MESSAGE))
				     (FIXSPELL1 FILE VAL (EQ APPFLG (QUOTE MUST-APPROVE))
						NIL APPFLG))
				 VAL])

(SPELLFILE1
  (LAMBDA (ARR)                                 (* lmm "29-JUL-78 02:37"
)
    (AND (ELT ARR 3)
	 (PROG1 (JFNS (ELT ARR 2)
		      (ELT ARR 5)
		      (CONSTANT (CONCAT)))
		(OR (ASSEMBLE NIL
			      (CQ (VAG (ELT ARR 3)))
			      (JSYS 17Q)
			      (SKIPA 1 , KNIL)
			      (CQ T))
		    (SETA ARR 3 NIL))))))

(LGTJFN
  (LAMBDA (DIR NAME EXT VER FLAGS)                          (* lmm "23-OCT-78 01:31")
                                                            (* get JFN with given fields)
    (ASSEMBLE NIL
	      (PUSHNN (= 0)
		      (= 377777377777Q)
		      (= 0)
		      (= 0)
		      (= 0)
		      (= 0)
		      (= 0)
		      (= 0))

          (* gtjfn block are -
	  e flags,,version -
	  e+1 injfn,,outjfn -
	  e+2 device -
	  e+3 directory -
	  e+4 name -
	  e+5 extension -
	  e+6 protection -
	  e+7 account)


	      (CQ (VAG (OR FLAGS 0)))
	      (NREF (HRLM 1 , -7))
	      (CQ (VAG (OR VER 0)))
	      (NREF (HRRM 1 , -7))
	      (MOVE 2 , XXXMHC)
	      (CQ DIR)
	      (CAMN 1 , KNIL)
	      (JRST NODIR)
	      (NREF (MOVEM 2 , -4))
	      (PUSHJ CP , SUBROUTINE)
	  NODIR
	      (CQ NAME)
	      (NREF (MOVEM 2 , -3))
	      (PUSHJ CP , SUBROUTINE)
	      (CQ EXT)
	      (CAMN 1 , KNIL)
	      (JRST NOEXT)
	      (MOVEI 3 , 56Q)
	      (DPB 3 , 2)                                   (* store a "." at end of NAME)
	      (PUSHJ CP , SUBROUTINE)
	  NOEXT
	      (NREF (MOVEI 1 , -7))
	      (MOVEI 2 , 0)
	      (NREF (EXCH 2 , -3))                          (* make the NAME be the main string pointer, and leave 
							    default name empty)
	      (JSYS 20Q)                                    (* GTJFN)
	      (SKIPA 1 , KNIL)
	      (FASTCALL MKN)
	      (JRST OUT)
	  SUBROUTINE
	      (LDTY 3)
	      (CAIN 3 , STPTT)
	      (JRST UPAT)
	      (CAIN 3 , ATOMT)
	      (JRST DOATM)
	      (PUSHN 2)
	      (CQ (MKSTRING (AC)))
	      (POPN 2)
	      (JRST UPAT)
	  DOATM
	      (HLRZ 1 , 2 (1))
	  UPAT(FASTCALL UPATM)

          (* UPATM takes a string or pname in ac1, preserves acs 1 and 2 and returns a byte pointer in ac3 and a byte count in
	  ac4.)


	      (JUMPE 4 , NOCHARS)
	  SUBROUTINE1
	      (ILDB 1 , 3)
	      (IDPB 1 , 2)
	      (SOJG 4 , SUBROUTINE1)
	  NOCHARS
	      (IDPB 4 , 2)                                  (* Add NULL byte on end to terminate.)
	      (RET)
	  RETNIL
	      (CQ NIL)
	  OUT (POPNN 10Q))))

(FINDFILE
  [LAMBDA (FILE NSFLG DIRLST)      (* lmm "24-NOV-82 23:13")
    (COND
      ((AND (FILENAMEFIELD FILE (QUOTE DIRECTORY))
	    (INFILEP FILE)))
      (DIRLST (SPELLFILE FILE T NSFLG DIRLST))
      ((INFILEP FILE))
      ((SPELLFILE FILE T NSFLG])
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL FINDFILE SPELLFILE LGTJFN SPELLFILE1 (LOCALVARS . T)
	(GLOBALVARS DWIMFLG NOSPELLFLG SPELLFILE USERNAME DIRECTORIES))
]

(RPAQ SPELLFILE (ARRAY 5))

(ADDTOVAR ERRORTYPELST (23 (SPELLFILE (CADR ERRORMESS))))

(ADDTOVAR DIRECTORIES NIL LISP)

(ADDTOVAR LISPUSERSDIRECTORIES LISPUSERS LISP)

(RPAQQ FILEWONTOPENCOMS ((ALISTS (ERRORTYPELST 9))))

(ADDTOVAR ERRORTYPELST [9 (PROG NIL (OR (IEQP (GETER)
					      196696)
					(RETURN))
				LP
				(AND (SELECTQ (STKNAME ERRORPOS)
					      (INFILE NIL)
					      ((OUTFILE DRIBBLE)
					       T)
					      (OPENFILE (SELECTQ (STKARG 3 ERRORPOS)
								 (OLD NIL)
								 (NEW T)
								 (SELECTQ (STKARG 2 ERRORPOS)
									  ((INPUT BOTH)
									   NIL)
									  (OUTPUT T)
									  NIL)))
					      ((OPENF *PROG*LAM)
					       (STKNTH -1 ERRORPOS ERRORPOS)
					       (GO LP))
					      NIL)
				     (NOT (FILENAMEFIELD (CADR ERRORMESS)
							 (QUOTE VERSION)))
				     (RETURN (PACKFILENAME (QUOTE VERSION)
							   (ADD1 (FILENAMEFIELD (OUTFILEP
										  (CADR ERRORMESS))
										(QUOTE VERSION)))
							   (QUOTE BODY)
							   (CADR ERRORMESS])

(RPAQQ PMAPCOMS ((FNS MAPPAGE MAPWORD DOMAPPAGE MAPBUFFERCOUNT ADDMAPBUFFER CLEARMAP UNMAPBUFFER 
		      LOCKMAP UNLOCKMAP MAPAFTERCLOSE RESTOREMAP FINDPTRSBUFFER INITPMAP 
		      CHECKSYSOUTMAP)
		 (FNS WORDCONTENTS SETWORDCONTENTS /SETWORDCONTENTS WORDOFFSET)
		 (MACROS WORDCONTENTS SETWORDCONTENTS WORDOFFSET)
		 (VARS (DEFAULTMAPFILE)
		       (LASTMAPPAGE (VAG 261632)))
		 (ADDVARS (GAINSPACEFORMS ((ILESSP 1 (MAPBUFFERCOUNT))
					   "deallocate PMAP buffers"
					   (CLEARMAP T NIL T)))
			  (BEFORESYSOUTFORMS (CHECKSYSOUTMAP)))
		 (DECLARE: DONTCOPY (FNS SEEBUF)
			   EVAL@COMPILE
			   (P (LOAD? (QUOTE <LISPUSERS>CJSYS.COM)
				     (QUOTE SYSLOAD)))
			   (MACROS DOPMAP)
			   (RECORDS BUFFER)
			   (I.S.OPRS INBUFS)
			   (ADDVARS (DONTCOMPILEFNS SEEBUF)))
		 (P (AND (GETD (QUOTE INITPMAP))
			 (INITPMAP)))
		 (BLOCKS (NIL FINDPTRSBUFFER (LOCALVARS . T)
			      (GLOBALVARS MAPBUFFERQUEUE)
			      (BYTECOMPFLG))
			 (NIL WORDCONTENTS SETWORDCONTENTS /SETWORDCONTENTS ADDMAPBUFFER
			      (GLOBALVARS RESETVARSLST)
			      CLEARMAP DOMAPPAGE (GLOBALVARS USERFORKS)
			      INITPMAP MAPWORD LOCKMAP MAPAFTERCLOSE MAPPAGE MAPBUFFERCOUNT 
			      WORDOFFSET RESTOREMAP UNLOCKMAP (LOCALVARS . T)
			      UNMAPBUFFER))))
(DEFINEQ

(MAPPAGE
  (LAMBDA (PAGE# FILE)                          (* lmm "18-SEP-78 00:28"
)

          (* Searchs the LRU queue for a buffer into which 
	  PAGE# of FILE is currently mapped.
	  If found, it moves that buffer to the front of the 
	  queue. If not found, DOMAPPAGE is responsible for 
	  mapping in the page into the last available buffer 
	  and re-calling MAPPAGE to move it to the beginning)



          (* (ASSEMBLE NIL (CQ (VAG PAGE#)) 
	  (CQ2 FILE) (FASTCALL MAPPAGE 1)))


    (COND
      ((AND (IEQP (fetch PAGE# of MAPBUFFERQUEUE)
		  PAGE#)
	    (EQ (fetch FILE of MAPBUFFERQUEUE)
		FILE))
	(fetch GETBLK of MAPBUFFERQUEUE))
      (T (PROG ((PREV MAPBUFFERQUEUE)
		BUF)
	   LP  (COND
		 ((EQ (SETQ BUF (fetch NEXT of PREV))
		      (VAG 0))
		   (RETURN (DOMAPPAGE FILE PAGE#)))
		 ((AND (IEQP (fetch PAGE# of BUF)
			     PAGE#)
		       (EQ (fetch FILE of BUF)
			   FILE))
		   (INTERRUPTABLE (PROG1 (INTERRUPTABLE)
					 (replace NEXT of PREV
					    with (fetch NEXT
						    of BUF))
					 (replace NEXT of BUF
					    with MAPBUFFERQUEUE)
					 (SETQ MAPBUFFERQUEUE BUF)))
		   (RETURN (fetch GETBLK of BUF)))
		 (T (SETQ PREV BUF)
		    (GO LP))))))))

(MAPWORD
  (LAMBDA (FILEADR FILE)                                    (* lmm "20-OCT-78 01:16")
                                                            (* (ASSEMBLE NIL (CV FILEADR) 
							    (CQ2 FILE) (FASTCALL MAPWORD 1)))
    (WORDOFFSET (MAPPAGE (LOGAND (LRSH FILEADR 9)
				 32767)
			 FILE)
		(LOGAND FILEADR 511))))

(DOMAPPAGE
  (LAMBDA (FILE PAGE#)                                      (* lmm "26-FEB-79 23:18")
    (PROG ((PMAPPROP (GETPROP FILE (QUOTE PMAP)))
	   BUFFER)
          (OR PMAPPROP (COND
		((NOT (LITATOM FILE))
		  (COND
		    ((OR (SMALLP FILE)
			 (AND (FIXP FILE)
			      (OR (IEQP FILE 262143)
				  (GETHASH FILE USERFORKS))))
		      (SETQ PMAPPROP FILE))
		    ((AND (LISTP FILE)
			  (EQ (CAR FILE)
			      (QUOTE PMAP)))
		      (SETQ PMAPPROP (CADR FILE)))
		    (T (ERRORX (LIST 27 FILE)))))
		((NEQ FILE (SETQ FILE (OR (COND
					    (FILE (OPENP FILE))
					    (DEFAULTMAPFILE)
					    (T (ERROR "No DEFAULTMAPFILE")))
					  (ERRORX (LIST 13 FILE)))))
		                                            (* will just retry)
		  (RETURN (MAPPAGE PAGE# FILE)))
		((NOT (ZEROP (BITS 9 17 (JS DVCHR (SETQ PMAPPROP (OPNJFN FILE))
					    NIL NIL 1))))
		  (ERROR FILE "can't map non-disk file"))
		((NOT (BIT 1 (JS GTSTS PMAPPROP 0 NIL 2)))
		  (ERROR FILE "must be open for input to map"))
		(T                                          (* first time this file has been mapped)
		   (PUT FILE (QUOTE PMAP)
			(OPNJFN FILE))
		   (WHENCLOSE FILE (QUOTE AFTER)
			      (FUNCTION MAPAFTERCLOSE)
			      (QUOTE BEFORE)
			      (FUNCTION CLEARMAP)))))
          (for B inbufs MAPBUFFERQUEUE when (IEQP (fetch LockCount of B)
						  0)
	     do (SETQ BUFFER B) finally (OR BUFFER (SETQ BUFFER (ADDMAPBUFFER NIL T))))
          (OR (type? BUFFER BUFFER)
	      (SHOULDNT))
          (replace FILE of BUFFER with (VAG 0))             (* so that an interrupt will not leave buffer invalid)
          (COND
	    ((FIXP PMAPPROP)
	      (JS PMAP (XWD PMAPPROP PAGE#)
		  (XWD 400000Q (LLSH (LOC (fetch GETBLK of BUFFER))
				     -11Q))
		  (XWD 160000Q 0)))
	    (T (DOPMAP -1 -1 (fetch GETBLK of BUFFER))
	                                                    (* clear page)
	       (APPLY* PMAPPROP FILE PAGE# (fetch GETBLK of BUFFER))))
          (replace PAGE# of BUFFER with PAGE#)
          (replace FILE of BUFFER with FILE)                (* now let MAPPAGE do the LRU)
          (RETURN (MAPPAGE PAGE# FILE)))))

(MAPBUFFERCOUNT
  [LAMBDA (ONLYUNLOCKED)                                    (* rmk: " 2-DEC-79 14:05")
    (for B inbufs MAPBUFFERQUEUE count (OR (NOT ONLYUNLOCKED)
					   (IEQP (fetch LockCount of B)
						 0])

(ADDMAPBUFFER
  [LAMBDA (TEMP ERROR)                                      (* rmk: "15-DEC-79 17:21")

          (* Attempts to allocate a new buffer. If it fails, causes an error if ERROR, otherwise returns NIL.
	  If TEMP, does a resetsave to de-allocate the buffer.)


    (PROG (NEWBUF LOC (B MAPBUFFERQUEUE))
      LP  [OR (NLSETQ (SETQ LOC (GETBLK 1)))
	      (COND
		(ERROR (COND
			 ((IGREATERP (SETQ LOC (SETSBSIZE))
				     50)
			                                    (* steal from swapping buffer!)
			   (SETSBSIZE (SUB1 LOC)))
			 (T (ERROR "UNABLE TO ALLOCATE PMAP BUFFER")))
		       (GO LP))
		(T (RETURN]
          (while (NEQ (SETQ NEWBUF (fetch NEXT of B))
		      (VAG 0))
	     do (SETQ B NEWBUF))                            (* find last buffer)
          (replace NEXT of B with (SETQ NEWBUF (create BUFFER
						       GETBLK _ LOC)))
          [COND
	    (TEMP (RESETSAVE NIL (LIST (FUNCTION UNMAPBUFFER)
				       NEWBUF T]
          (RETURN NEWBUF])

(CLEARMAP
  (LAMBDA (FILE PAGES RELEASE)                  (* lmm "18-SEP-78 00:27"
)

          (* Clears PAGES of FILE from the buffers, and 
	  de-allocates those buffers if RELEASE.
	  Overrides the lock counts.)


    (AND (LITATOM FILE)
	 (NEQ FILE T)
	 (SETQ FILE (COND
	     (FILE (OR (OPENP FILE)
		       FILE))
	     (T DEFAULTMAPFILE))))
    (for BUFFER inbufs MAPBUFFERQUEUE
       when (AND (OR (EQ FILE T)
		     (EQ FILE (fetch FILE of BUFFER)))
		 (OR (NULL PAGES)
		     (for P inside PAGES
			thereis (IEQP P (fetch PAGE# of BUFFER)))))
       do (UNMAPBUFFER BUFFER RELEASE))
    FILE))

(UNMAPBUFFER
  (LAMBDA (BUFFER RELEASE)                      (* lmm "30-SEP-78 04:07"
)
    (PROG (LOC)
          (OR (TYPE? BUFFER BUFFER)
	      (SHOULDNT))
          (replace FILE of BUFFER with (VAG 0))
          (replace LockCount of BUFFER with 0)
          (DOPMAP -1 -1 (SETQ LOC (fetch GETBLK of BUFFER)))
          (COND
	    ((AND RELEASE (NEQ LOC LASTMAPPAGE))
                                                (* Don't release page 
						777Q.)
	      (COND
		((EQ BUFFER MAPBUFFERQUEUE)
		  (SETQ MAPBUFFERQUEUE (fetch NEXT of BUFFER)))
		(T (for B inbufs MAPBUFFERQUEUE
		      when (EQ (fetch NEXT of B)
			       BUFFER)
		      do (replace NEXT of B
			    with (fetch NEXT
				    of (fetch NEXT of B)))
			 (RETURN))))
	      (replace BUFFERSEAL of BUFFER with 0)
	      (COND
		(LOC (replace GETBLK of BUFFER with NIL)
		     (RELBLK LOC 1))))))))

(LOCKMAP
  (LAMBDA (PTR)                                 (* lmm " 6-OCT-78 06:54"
)
    (add (fetch LockCount of (FINDPTRSBUFFER PTR))
	 1)
    PTR))

(UNLOCKMAP
  [LAMBDA (PTR)                                             (* rmk: " 2-DEC-79 14:07")
                                                            (* Decrements the lock counter for the buffer whose 
							    location contains PTR. If PTR=T, sets all lockcounts to 
							    0)
    (DECLARE (USEDFREE MAPBUFFERQUEUE))
    [COND
      ((EQ PTR T)
	(for B inbufs MAPBUFFERQUEUE do (replace LockCount of B with 0)))
      (T (change (fetch LockCount of (FINDPTRSBUFFER PTR))
		 (COND
		   ((IGREATERP DATUM 0)
		     (SUB1 DATUM))
		   (T 0]
    PTR])

(MAPAFTERCLOSE
  (LAMBDA (FILE)                                (* lmm "14-SEP-78 22:41"
)

          (* An afterclose function for pmapped files.
	  The Whenclose is done automatically the first time 
	  the file is pmapped.)


    (DECLARE (USEDFREE DEFAULTMAPFILE))
    (CLEARMAP FILE)
    (REMPROP FILE (QUOTE PMAP))
    (COND
      ((EQ FILE DEFAULTMAPFILE)
	(SETQ DEFAULTMAPFILE NIL)))))

(RESTOREMAP
  (LAMBDA (FILE)                                            (* edited: "16-APR-79 16:35")

          (* If this is made a RESTORE function for a pmapped file, it will restore the mapped in pages from this file into 
	  their buffer locations after a sysout. It is called by PERMSTATUS if the file has been made "permanent")


    (COND
      ((GETPROP FILE (QUOTE PMAP))
	(for BUFFER (JFN _(PUTPROP FILE (QUOTE PMAP)
				   (OPNJFN FILE)))
	   inbufs MAPBUFFERQUEUE when (EQ FILE (fetch FILE of BUFFER))
	   do (DOPMAP (fetch PAGE# of BUFFER)
		      JFN
		      (fetch GETBLK of BUFFER)))))))

(FINDPTRSBUFFER
  (LAMBDA (PTR NOERRORFLG)                      (* lmm "10-OCT-78 02:29"
)

          (* given a pointer to a mapped location, return the 
	  buffer which contains that pointer.
	  Causes error if no such buffer 
	  (thus this is used as a checking function too))


    (bind (P _(VAG (LOGAND (LOC PTR)
			   261632)))
       for B inbufs MAPBUFFERQUEUE when (EQ P (fetch GETBLK
						 of B))
       do (RETURN B) finally (AND (NOT NOERRORFLG)
				  (ERROR PTR "not a MAPPAGE pointer"))))
)

(INITPMAP
  (LAMBDA NIL                                   (* lmm "25-SEP-78 00:29"
)                                               (* called only when PMAP
						is loaded to initialize 
						the world.)
    (OR (type? BUFFER (GETATOMVAL (QUOTE MAPBUFFERQUEUE)))
	(SETQ MAPBUFFERQUEUE (create BUFFER
				     GETBLK _ LASTMAPPAGE)))))

(CHECKSYSOUTMAP
  (LAMBDA NIL                                   (* lmm "10-OCT-78 03:06"
)
    (for BUFFER inbufs MAPBUFFERQUEUE
       do (COND
	    ((NEQ (fetch LockCount of BUFFER)
		  0)
	      (COND
		((OR (NOT (LITATOM (fetch FILE of BUFFER)))
		     (NOT (GETPROP (fetch FILE of BUFFER)
				   (QUOTE STATUSFN)))
		     (EQ (fetch GETBLK of BUFFER)
			 LASTMAPPAGE))

          (* locked in page will not be restored correctly 
	  after re-open -
	  dunno what to do but print warning)


		  (printout T T "** Warning: " (fetch FILE
						  of BUFFER)
			    
	 "has locked map page but will not be restored after SYSIN"
			    T)))))
	  (COND
	    ((EQ (fetch GETBLK of BUFFER)
		 LASTMAPPAGE)                   (* whether or not it is 
						locked, since SYSOUT 
						will smash the lock)
	      (replace FILE of BUFFER with (VAG 0)))))))
)
(DEFINEQ

(WORDCONTENTS
  (LAMBDA (PTR)                                 (* lmm "15-SEP-78 02:53"
)
    (OPENR (LOC PTR))))

(SETWORDCONTENTS
  (LAMBDA (PTR N)                               (* lmm "18-SEP-78 00:26"
)
    (FINDPTRSBUFFER PTR)
    (CLOSER (LOC PTR)
	    N)))

(/SETWORDCONTENTS
  (LAMBDA (PTR N)                               (* lmm "18-SEP-78 00:26"
)
    (AND LISPXHIST (UNDOSAVE (LIST (FUNCTION /SETWORDCONTENTS)
				   PTR
				   (WORDCONTENTS PTR))))
    (SETWORDCONTENTS PTR N)))

(WORDOFFSET
  (LAMBDA (PTR N)                               (* lmm "15-SEP-78 02:54"
)
    (VAG (IPLUS (LOC PTR)
		N))))
)
(DECLARE: EVAL@COMPILE 

(PUTPROPS WORDCONTENTS 10MACRO ((PTR)
				(FETCHFIELD 608174080 PTR)))

(PUTPROPS SETWORDCONTENTS 10MACRO ((PTR N)
				   (REPLACEFIELD 608174080 PTR N)))

(PUTPROPS WORDOFFSET 10MACRO ((PTR N)
			      (VAG (IPLUS (LOC PTR)
					  N))))
)

(RPAQQ DEFAULTMAPFILE NIL)

(RPAQ LASTMAPPAGE (VAG 261632))

(ADDTOVAR GAINSPACEFORMS ((ILESSP 1 (MAPBUFFERCOUNT))
			  "deallocate PMAP buffers"
			  (CLEARMAP T NIL T)))

(ADDTOVAR BEFORESYSOUTFORMS (CHECKSYSOUTMAP))
(DECLARE: DONTCOPY 
(DEFINEQ

(SEEBUF
  (LAMBDA NIL                                               (* lmm "18-SEP-78 00:28")
    (DECLARE (USEDFREE MAPBUFFERQUEUE))
    (for B inbufs MAPBUFFERQUEUE do (OR (type? BUFFER B)
					(PRINTOUT T "*** not a valid buffer ***" T))
				    (printout T B 3 "[GETBLK = " (fetch GETBLK of B)
					      4 "LockCount = " (fetch LockCount of B)
					      4 "FILE = " (fetch FILE of B)
					      4 "PAGE# = " (fetch PAGE# of B)
					      4 "NEXT = " (fetch NEXT of B)
					      "]" T))))
)
EVAL@COMPILE 
(LOAD? (QUOTE <LISPUSERS>CJSYS.COM)
       (QUOTE SYSLOAD))

(DECLARE: EVAL@COMPILE 

(PUTPROPS DOPMAP 10MACRO ((SOURCEPAGE# SOURCEJFN LOCATION)
			  (JS PMAP (XWD SOURCEJFN SOURCEPAGE#)
			      (XWD 400000Q (LLSH (LOC LOCATION)
						 -11Q))
			      (XWD 140000Q 0))))
)

[DECLARE: EVAL@COMPILE 

(BLOCKRECORD BUFFER ((BUFFERSEAL BITS 18)
		     (LockCount BITS 18)
		     (PAGE# INTEGER)
		     NIL FILE NIL GETBLK NIL NEXT)
		    (TYPE? (IEQP (fetch BUFFERSEAL OF DATUM)
				 142694))
		    (CREATE (WORDOFFSET (ARRAY 5 2 (VAG 0))
					2))
		    BUFFERSEAL _ 142694 

          (* FILE and PAGE# are that of the currently mapped in contents. Whenever a page is mapped into a BUFFER, these 
	  fields are changed to reflect the contents. This is a BLOCKRECORD instead of an ARRAYBLOCK to make sure that the 
	  field locations stay consistent with the LISP.MAC code. NEXT is the pointer to the next BUFFER in the chain.
	  BUFFERSEAL is a value which is used to test if something is really a buffer (better than NTYP test). The current 
	  value is "BUF" in sixbit)

)
]

(DECLARE: EVAL@COMPILE 
[I.S.OPR (QUOTE INBUFS)
	 NIL
	 (QUOTE (first I.V. _ BODY by (fetch NEXT of I.V.)
		       until
		       (EQ I.V. (VAG 0]
)


(ADDTOVAR DONTCOMPILEFNS SEEBUF)
)
(AND (GETD (QUOTE INITPMAP))
     (INITPMAP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL FINDPTRSBUFFER (LOCALVARS . T)
	(GLOBALVARS MAPBUFFERQUEUE)
	(BYTECOMPFLG))
(BLOCK: NIL WORDCONTENTS SETWORDCONTENTS /SETWORDCONTENTS ADDMAPBUFFER (GLOBALVARS RESETVARSLST)
	CLEARMAP DOMAPPAGE (GLOBALVARS USERFORKS)
	INITPMAP MAPWORD LOCKMAP MAPAFTERCLOSE MAPPAGE MAPBUFFERCOUNT WORDOFFSET RESTOREMAP UNLOCKMAP
	(LOCALVARS . T)
	UNMAPBUFFER)
]

(RPAQQ FILEINFOCOMS [(DECLARE: FIRST (ADDVARS (NOSWAPFNS GFUST SFUST SETFDB)))
		     (FNS GETFILEINFO SETFILEINFO LONGGTJFN FIGTJFNL SETFDB GFUST SFUST)
		     (DECLARE: DONTCOPY (MACROS SETFILEEOL GETFILEEOL))
		     (BLOCKS (NIL SFUST GFUST SETFDB (LOCALVARS . T)
				  (GLOBALVARS MACSCRATCHSTRING))
			     (NIL GETFILEINFO SETFILEINFO LONGGTJFN FIGTJFNL (GLOBALVARS 
										 MACSCRATCHSTRING 
											 HOSTNAME])
(DECLARE: FIRST 

(ADDTOVAR NOSWAPFNS GFUST SFUST SETFDB)
)
(DEFINEQ

(GETFILEINFO
  [LAMBDA (FILE ATTRIB SCRATCH)    (* lmm "27-FEB-82 07:56")
    (PROG ((JFN FILE)
	   TEMP GTJFLG)
          (SELECTQ ATTRIB
		   (EOL            (* PROPERTY OF FX RAHER THAN JFN)
			(RETURN (GETFILEEOL FILE)))
		   NIL)
          [AND (SMALLP JFN)
	       (NOT (BIT 12Q (JS GTSTS JFN NIL NIL 2)))
	       (SETQ JFN (ERRORX (LIST 33Q JFN]
          [COND
	    ((EQ ATTRIB (QUOTE DELETED))

          (* This is special cased because if FILE has a version number and is not a "known" file to lisp and the file is 
	  deleted then TENEX/TOPS20 via the GTJFN for output in OPENP would "expunge" the old file)


	      [COND
		((NOT (SMALLP JFN))
		  (SETQ JFN (OR (SETQ GTJFLG (GTJFN FILE NIL NIL 101001Q))
				(ERRORX (LIST 27Q FILE]
	      (RETURN (PROG1 (BIT 3 (JS GTFDB JFN (XWD 1 1)
					1 1))
			     (COND
			       (GTJFLG (RLJFN JFN]
          [COND
	    ((NOT (SMALLP JFN))
	      (SETQ JFN (OR (AND FILE (ASSEMBLE NIL
					        (CQ FILE)
					        (HRRZ 2 , KNIL)
					        (FASTCALL OPENP)
					        (CAMN 1 , KNIL)
					        (JRST OUT)
					        (HRRZ 1 , FILEN (3))
					        (ADDI 1 , ASZ)
					    OUT))
			    (OR (SETQ GTJFLG (SELECTQ ATTRIB
						      [(INVISIBLE ARCHIVED OFF-LINE)
							(COND
							  ((EQ (SYSTEMTYPE)
							       (QUOTE TOPS20))
							    (LONGGTJFN FILE NIL NIL 100000Q 10000Q))
							  (T (RETURN NIL]
						      (GTJFN FILE NIL NIL 100001Q)))
				(ERRORX (LIST 27Q FILE]
          [SETQ TEMP (SELECTQ ATTRIB
			      ((WRITEDATE IWRITEDATE)
				(JS GTFDB JFN (XWD 1 14Q)
				    1 1))
			      ((READDATE IREADDATE)
				(JS GTFDB JFN (XWD 1 15Q)
				    1 1))
			      ((CREATIONDATE ICREATIONDATE)
				(JS GTFDB JFN (XWD 1 13Q)
				    1 1))
			      (LENGTH (JS GTFDB JFN (XWD 1 12Q)
					  1 1))
			      (OPENBYTESIZE (AND (NULL GTJFLG)
						 (BIT 0 (JS GTSTS JFN 0 0 2))
						 (JS RFBSZ JFN NIL NIL 2)))
			      ((BYTESIZE PERMBYTESIZE)
                                   (* Permanent)
				(BITS 6 13Q (JS GTFDB JFN (XWD 1 11Q)
						1 1)))
			      (PROTECTION (BITS 22Q 43Q (JS GTFDB JFN (XWD 1 4)
							    1 1)))
			      (SIZE (BITS 22Q 43Q (JS GTFDB JFN (XWD 1 11Q)
						      1 1)))
			      (PAGES (JS SIZEF JFN NIL NIL 3))
			      (ACCESS (AND (NULL GTJFLG)
					   (SELECTQ (BITS 1 4 (JS GTSTS JFN 0 0 2))
						    ((3 15Q)
						      (QUOTE BOTH))
						    ((11Q 10Q)
						      (QUOTE INPUT))
						    (5 (QUOTE OUTPUT))
						    (4 (QUOTE APPEND))
						    NIL)))
			      (INVISIBLE (BIT 14Q (JS GTFDB JFN (XWD 1 1)
						      1 1)))
			      (ARCHIVED (BIT 13Q (JS GTFDB JFN (XWD 1 1)
						     1 1)))
			      (OFF-LINE (BIT 15Q (JS GTFDB JFN (XWD 1 1)
						     1 1)))
			      (AUTHOR (SELECTQ (SYSTEMTYPE)
					       (TENEX (USERNAME (BITS 0 21Q (JS GTFDB JFN
										(XWD 1 6)
										1 1))
								SCRATCH))
					       (TOPS20 (GFUST JFN SCRATCH))
					       NIL))
			      (IAUTHOR (SELECTQ (SYSTEMTYPE)
						(TENEX (BITS 0 21Q (JS GTFDB JFN (XWD 1 6)
								       1 1)))
						(TOPS20 (USERNUMBER (GFUST JFN SCRATCH)))
						NIL))
			      [MODE (AND (BIT 0 (JS GTSTS JFN 0 0 2))
					 (BITS 40Q 43Q (JS GTSTS JFN 0 0 2)]
			      (ERRORX (LIST 33Q ATTRIB]
          (COND
	    (GTJFLG (RLJFN JFN)))
          (RETURN (SELECTQ ATTRIB
			   ((WRITEDATE READDATE CREATIONDATE)
			     (AND (NOT (ZEROP TEMP))
				  (GDATE TEMP NIL SCRATCH)))
			   TEMP])

(SETFILEINFO
  [LAMBDA (FILE ATTRIB VALUE)      (* lmm "27-FEB-82 07:37")
    (PROG (JFN (OPENFLG T))
          (SELECTQ ATTRIB
		   (EOL            (* ATTRIBUTE OF FX RATHER THAN JFN)
			(RETURN (SETFILEEOL FILE VALUE)))
		   NIL)
          [SETQ JFN (OR (SMALLP FILE)
			(AND FILE (OPENP FILE)
			     (OPNJFN FILE))
			(PROGN (SETQ OPENFLG NIL)

          (* we have to do a GTJFN, but the kind of GTJFN and flags differ depending on the type of ATTRIB we are requesting 
	  information about. The default is to do a GTJFN requesting an OLD file.)


			       (SETQ JFN (OR (SELECTQ ATTRIB
						      (DELETED (GTJFN FILE NIL NIL 101001Q))
						      [(INVISIBLE ARCHIVED OFF-LINE)
							(COND
							  ((EQ (SYSTEMTYPE)
							       (QUOTE TOPS20))
							    (LONGGTJFN FILE NIL NIL 100000Q 10000Q))
							  (T (RETURN]
						      (GTJFN FILE NIL NIL 100001Q))
					     (RETURN NIL]
          (RETURN (PROG1 (COND
			   ((SELECTQ ATTRIB
				     [(WRITEDATE IWRITEDATE READDATE IREADDATE CREATIONDATE 
						 ICREATIONDATE)
				       (PROG (DATE)
					     (COND
					       ([NULL (SETQ DATE (OR (AND (FIXP VALUE)
									  VALUE)
								     (IDATE VALUE]
						 (OR OPENFLG (RLJFN JFN))
						 (RETURN NIL)))
					     (RETURN (SETFDB JFN (SELECTQ ATTRIB
									  ((WRITEDATE IWRITEDATE)
									    14Q)
									  ((READDATE IREADDATE)
									    15Q)
									  ((CREATIONDATE 
										    ICREATIONDATE)
									    13Q)
									  (SHOULDNT))
							     -1 DATE]
				     (LENGTH (SETFDB JFN 12Q -1 VALUE))
				     (OPENBYTESIZE 
                                   (* For this opening)
						   (AND OPENFLG (JSYS 46Q JFN VALUE)
							T))
				     (BYTESIZE 
                                   (* Permanently)
					       (SETFDB JFN 11Q (CONSTANT (LLSH 77Q 30Q))
						       (LLSH VALUE 30Q)))
				     (PROTECTION (SETFDB JFN 4 777777Q VALUE))
				     [DELETED (SETFDB JFN 1 (CONSTANT (LLSH 1 40Q))
						      (COND
							(VALUE (LLSH 1 40Q))
							(T 0]
				     (INVISIBLE (SELECTQ (SYSTEMTYPE)
							 [TOPS20 (SETFDB
								   JFN 1 (CONSTANT (LLSH 1 27Q))
								   (COND
								     (VALUE (CONSTANT (LLSH 1 27Q)))
								     (T 0]
							 NIL))
				     (AUTHOR (SELECTQ
					       (SYSTEMTYPE)
					       [TENEX (PROG [(USERNUMBER (COND
									   ((FIXP VALUE)
									     VALUE)
									   ((OR (LITATOM VALUE)
										(STRINGP VALUE))
									     (USERNUMBER VALUE))
									   (T NIL]
							    (RETURN (AND USERNUMBER
									 (SETFDB JFN 6 -1000000Q
										 (LLSH USERNUMBER 22Q]
					       [TOPS20 (RESETVARS [(USERNAME (COND
									       ((FIXP VALUE)
										 (USERNAME VALUE))
									       ((LITATOM VALUE)
										 (MKSTRING VALUE))
									       ((STRINGP VALUE)
										 VALUE)
									       (T NIL]
							          (RETURN (AND USERNAME
									       (SFUST JFN USERNAME]
					       NIL))
				     NIL)
			     T)
			   (T NIL))
			 (OR OPENFLG (RLJFN JFN])

(LONGGTJFN
  [LAMBDA (FILE EXT VER FLAGS AUXFLAGS)         (* J.Vittal: 
						"31-Jan-81 10:42")

          (* this is only called if we are a TOPS-20.
	  We must determine first which system is being run.)

                                                (* first get some sort of 
						jfn)
    (SELECTQ (SYSTEMTYPE)
	     (TOPS20 (FIGTJFNL FILE EXT VER FLAGS AUXFLAGS))
	     NIL])

(FIGTJFNL
  (LAMBDA (FILE EXT V FLAGS AUXFLAGS)                       (* lmm " 6-NOV-78 18:03")

          (* General scheme: create a table on numberstack to use for long GTJFN call. Below table write the strings for the 
	  name and extension, converting internal alt-modes to control F'S.)

                                                            (* Modified to take care of the case with the 20 where 
							    you can have auxiliary flags.)
    (PROG NIL
          (SETQ FLAGS (LOGOR (OR FLAGS 0)
			     4))
          (COND
	    ((EQ 46 (CHCON1 EXT))                           (* User specified an extension like ".SAV" and the 
							    period will cause GTJFN to die.
							    Take of the period.)
	      (SETQ EXT (SUBSTRING EXT 2 -1))))
          (ASSEMBLE NIL
		    (CQ (VAG (OR V 0)))
		    (PUSHNN (1)
			    (= 377777377777Q)
			    (= 0)
			    (= 0)
			    (= 0)
			    (XXXMHC)
			    (XXXMHC)
			    (= 0)
			    (= 0)
			    (= 0))
		    (CQ (VAG FLAGS))
		    (NREF (HRLM 1 , -11Q))
		    (CQ (VAG (OR AUXFLAGS 0)))
		    (NREF (HRLM 1 , 0))
		    (CQ (SELECTQ (NTYP EXT)
				 (30Q EXT)
				 (14Q (CDR (VAG (IPLUS 2 (LOC EXT)))))
				 (MKSTRING EXT)))
		    (MOVE 2 , XXXMHC)
		    (PUSHJ CP , SUBROUTINE)
		    (NREF (MOVEM 2 , -3))                   (* First word of table is FLAGS,,VERSION.)
		    (CQ (SELECTQ (NTYP FILE)
				 (30Q                       (* STRINGP, nothing to do.)
				      FILE)
				 (14Q                       (* Atom, get pname)
				      (CDR (VAG (IPLUS 2 (LOC FILE)))))
				 NIL))                      (* NOTE WELL THAT XXXMHC IS REALLY IOFNMP)
                                                            (* 'DEFAULT EXTENSION' word of table.
							    We store there a byte pointer to the part of the 
							    numberstack immediately below this table.)
		    (CAMN 1 , KNIL)
		    (JRST OUT)
		    (NREF (MOVE 2 , -3))                    (* This should be zero. I'm using it for a temp, to hold
							    the 'MAIN STRING POINTER', i.e. the pointer to the FILE 
							    arg.)
		    (PUSHJ CP , SUBROUTINE)
		    (NREF (SETZB 2 , -2))
		    (NREF (EXCH 2 , -3))                    (* See, I told you.)
		    (CQ EXT)

          (* Special case: if EXT was NIL, we have actually given "NIL" for the default extension. Remedy situation by zeroing
	  the word of the table, to indicate system default for that field (in the case of the extension, that's no 
	  extension.))


		    (CAMN 1 , KNIL)
		    (NREF (SETZM -4))
		    (NREF (MOVEI 1 , -11Q))
		    (JSYS 20Q)                              (* GTJFN)
		    (SKIPA 1 , KNIL)
		    (PUSHJ CP , MKN)
		OUT (POPNN 12Q)
		    (CQ (RETURN (AC)))
		SUBROUTINE
		    (FASTCALL UPATM)

          (* UPATM takes a string or pname in ac1, preserves acs 1 and 2 and returns a byte pointer in ac3 and a byte count in
	  ac4.)


		SUBROUTINE1
		    (ILDB 1 , 3)
		    (CAIE 4 , 1)
		    (CAIE 1 , 33Q)
		    (SKIPA)                                 (* Convert alt-modes to control F'S unless last char)
		    (HRRZI 1 , 6)
		    (IDPB 1 , 2)
		    (SOJG 4 , SUBROUTINE1)
		    (IDPB 4 , 2)                            (* Add NULL byte on end to terminate.)
		    (RET)))))

(SETFDB
  (LAMBDA (JFN INDEX MASK VALUE)                            (* edited: "29-Oct-78 14:24")
    (PROG (INDEXANDJFN)
          (SETQ INDEXANDJFN (LOGOR JFN (LLSH INDEX 18)))
          (RETURN (AND (ASSEMBLE NIL
			         (CQ (VAG VALUE))
			         (PUSHN 1)
			         (CQ (VAG MASK))
			         (PUSHN 1)
			         (CQ (VAG INDEXANDJFN))
			         (POPN 2)
			         (POPN 3)
			         (JSYS 64Q)                 (* CHFDB)
			         (JUMP 16Q , RNIL)          (* return nil if fail)
			         (SKIPA 1 , KT)
			     RNIL(HRRZ 1 , KNIL))
		       (JFNS JFN))))))

(GFUST
  (LAMBDA (JFN STRPTR)                                      (* edited: " 5-Nov-78 15:50")
    (ASSEMBLE NIL
	      (CQ (VAG JFN))
	      (PUSHN)
	      (CQ MACSCRATCHSTRING)
	      (FASTCALL UPATM)
	      (MOVE 2 , 3)
	      (POPN 1)
	      (JSYS 550Q)                                   (* GFUST -- Release 3 and up Get File User STring)
	      (JUMP 16Q , RETNIL)
	      (MOVE 1 , 2)
	      (MOVEI 2 , 0)
	      (IDPB 2 , 1)                                  (* just insert an extra null, just in case)
	      (CQ (COND
		    ((STRINGP STRPTR)
		      (STRCONC1 STRPTR))
		    (T (STRCONC0))))
	      (JRST OUT)
	  RETNIL
	      (CQ NIL)
	  OUT)))

(SFUST
  (LAMBDA (JFN VALUE)                                       (* lmm " 6-NOV-78 18:05")
    (ASSEMBLE NIL
	      (CQ (VAG JFN))
	      (PUSHN)
	      (CQ (RPLSTR0 VALUE))
	      (CQ MACSCRATCHSTRING)
	      (FASTCALL UPATM)
	      (MOVE 2 , 3)
	      (POPN 1)
	      (JSYS 551Q)                                   (* SFUST -- Release 3 and up Set File User STring)
	      (JUMP 16Q , RETNIL)
	      (CQ T)
	      (JRST OUT)
	  RETNIL
	      (CQ NIL)
	  OUT)))
)
(DECLARE: DONTCOPY 
(DECLARE: EVAL@COMPILE 

(PUTPROPS SETFILEEOL 10MACRO ((FILE VALUE)
			      (ASSEMBLE NIL (CQ (OR FILE (OUTPUT)))
					(MOVE 2 , KNIL)
					(FASTCALL OPENP)
					(MOVSI 2 , (LRSH (BIT 2)
							 18))
					(CQ VALUE)
					(CAME 1 , ' CR)
					(JRST NOTCR)
					(IORM 2 , FCHAR (3))
					(JRST OUT)
					NOTCR
					(CAME 1 , ' CRLF)
					(JRST UNK)
					(ANDCM 2 , FCHAR (3))
					(JRST OUT)
					UNK
					(CQ NIL)
					OUT)))

(PUTPROPS GETFILEEOL 10MACRO ((FILE)
			      (ASSEMBLE NIL (CQ (OR FILE (OUTPUT)))
					(MOVE 2 , KNIL)
					(FASTCALL OPENP)
					(MOVSI 2 , (LRSH (BIT 2)
							 18))
					(MOVE 1 , ' CRLF)
					(TDNE 2 , FCHAR (3))
					(MOVE 1 , ' CR))))
)
)
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: NIL SFUST GFUST SETFDB (LOCALVARS . T)
	(GLOBALVARS MACSCRATCHSTRING))
(BLOCK: NIL GETFILEINFO SETFILEINFO LONGGTJFN FIGTJFNL (GLOBALVARS MACSCRATCHSTRING HOSTNAME))
]
(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA )
)
(PUTPROPS LMMAC COPYRIGHT ("Xerox Corporation" 1982 1984))
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1020 8872 (SPELLFILE 1032 . 6025) (SPELLFILE1 6029 . 6367) (LGTJFN 6371 . 8586) (
FINDFILE 8590 . 8869)) (11411 21801 (MAPPAGE 11423 . 12646) (MAPWORD 12650 . 13009) (DOMAPPAGE 13013 .
 15315) (MAPBUFFERCOUNT 15319 . 15563) (ADDMAPBUFFER 15567 . 16624) (CLEARMAP 16628 . 17255) (
UNMAPBUFFER 17259 . 18152) (LOCKMAP 18156 . 18310) (UNLOCKMAP 18314 . 18955) (MAPAFTERCLOSE 18959 . 
19365) (RESTOREMAP 19369 . 20044) (FINDPTRSBUFFER 20048 . 20570) (INITPMAP 20574 . 20916) (
CHECKSYSOUTMAP 20920 . 21798)) (21803 22453 (WORDCONTENTS 21815 . 21930) (SETWORDCONTENTS 21934 . 
22087) (/SETWORDCONTENTS 22091 . 22322) (WORDOFFSET 22326 . 22450)) (23011 23606 (SEEBUF 23023 . 23603
)) (25946 38226 (GETFILEINFO 25958 . 29492) (SETFILEINFO 29496 . 32616) (LONGGTJFN 32620 . 33017) (
FIGTJFNL 33021 . 36400) (SETFDB 36404 . 37025) (GFUST 37029 . 37724) (SFUST 37728 . 38223)))))
STOP
