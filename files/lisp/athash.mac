;<NEWLISP>ATHASH.MAC;1     2-JUN-78 14:16:54    EDIT BY MASINTER
; save and restore AC7 around CONSGC call for byte lisp
;<NEWLISP>ATHASH.MAC;2    17-FEB-78 12:40:23    EDIT BY MASINTER
; fix problem in hash-table overflow when partially empty entry encountered
;BATHSH.MAC    September 22, 1976 edit by Masinter
; move BCONS, BCOLLCT to BYTE.MAC
;<NEWLISP>ATHASH.MAC.105    21-Apr-77 19:00:57    EDIT BY HARTLEY
; FIX REHASH PROBLEM WHEN DIDNT GET AS MANY PAGES AS DESIRED
;<NEWLISP>ATHASH.MAC;3    19-Nov-76 03:19:35    EDIT BY HARTLEY
;FIX REHASH AGAIN
;<HARTLEY>ATHASH.MAC;6    16-Jun-76 15:44:52    EDIT BY HARTLEY
;<NEWLISP>ATHASH.MAC;5    22-May-76 01:16:47    EDIT BY HARTLEY
;<HARTLEY>ATHASH.MAC;5     7-May-76 01:28:13    EDIT BY HARTLEY
;FIX REHASHER
;<HARTLEY>ATHASH.MAC;4    20-Apr-76 16:38:23    EDIT BY HARTLEY
;INSTALL MOST RECENT REHASHER
;<HARTLEY>ATHASH.MAC;1    20-FEB-76 23:27:21    EDIT BY HARTLEY
;<META>ATHASH.MAC;6    20-DEC-75 06:49:59    EDIT BY LEWIS
; ADD USER ENTRY FOR VCTOAT
;<HARTLEY>ATHASH.MAC;1     8-OCT-75 17:08:12    EDIT BY HARTLEY
;FIX VCTOAT
;<HARTLEY>NEWNEW.MAC;3    27-SEP-75 02:45:27    EDIT BY HARTLEY
;<HARTLEY>NEWNEW.MAC;1    25-SEP-75 01:46:31    EDIT BY HARTLEY
;<HARTLEY>NEW.MAC;4    27-AUG-75 18:53:07    EDIT BY HARTLEY

;CONS WITH SEVERAL ENTRIES

CONSS1:	POP PP,2		;CONS STACK AND AC1
	JRST CONS21
CONSNL:	SKIPA 2,KNIL		;CONS AC1 AND NIL
CONS21:	EXCH 1,2		;CONS AC2,AC1
CONS:	HRLI 2,0(1)
	SKIPN 1,FRELST
	CALL CONSN		;NO SPACE - CURRENT PAGE
CONSN2:	HRRZ 3,0(1)		;NEW FREE
	HRRZM 3,FRELST		;UPDATE FREE
	MOVSM 2,0(1)		;STORE THE GOODS
	AOS CNSCNT
	SOS 2,FRECNT
	CAME 2,FREBRK
	RET
	TLO F,CNSFLG
	MOVE 2,RSTBK		;SET TO BREAK AT NEXT FN CALL
	MOVEM 2,FNCALL
	RET

CONSF:	PUSH PP,2
IFDEF MAXC,<PUSH CP,CBS
	PUSH CP,7>
	CALL CONSGC
IFDEF MAXC,<POP CP,7
	POP CP,CBS>
	POP PP,2
CONSN:	SKIPE 3,LSTCNS
	HRRZS BTT(3)		;SHOW PAGE FULL
	HRRZ 4,ENDCOR
	LSH 4,-LPS
	AOS 3,NEWCNS
CONSN3:	CAIL 3,0(4)
	JRST CONSF
	HRRZ 1,TYPTAB(3)
	CAIE 1,LISTT
CONSN4:	AOJA 3,CONSN3
	MOVEM 3,NEWCNS
	MOVEM 3,LSTCNS
	HLRZ 1,BTT(3)
	JUMPE 1,CONSN4		;NO SPACE ON PAGE
	HRRZM 1,FRELST
	RET


; Collect list -- will be used for mapcar etc. called with FASTCALL
; 1/new item
; 2/collect list or NIL
; collect(x y) = (if y=NIL then (x_<y>)::1_x else (x::1_<y ! x::1>)::1)
COLLCT:	HRLI 2,0(1)		; New item,,collect list or nil
	SKIPN 1,FRELST		; Allocate new cell--ptrs in 2 in case of GC
	CALL CONSN
	MOVEI 3,(2)
	CAME 3,KNIL		; Is collect list empty?
	JRST COLLC2		; No.
	HRRI 2,0(1)		; Yes, circularize
	JRST CONSN2

COLLC2:	HLR 2,0(2)		; New CDR(collect list) = previous CDR = ptr to head
	HRLM 1,0(3)		; RPLACD previous CDR to new cell
	JRST CONSN2


;ROUTINES FOR COMPILED CODE - CALLED JSP 6,

;SKIP IF ATOM 

SKA:	LDT TP,1
	CAIL TP,ATOMT
	CAILE TP,SMALLT
	JRST 0(6)	;NOT ATOM
	JRST 1(6)

SKNA:	LDT TP,1
	CAIL TP,ATOMT
	CAILE TP,SMALLT
	JRST 1(6)
	JRST 0(6)

;SKIP IF NUMBER

SKNM:	LDT TP,1
	CAIL TP,FLOATT
	CAILE TP,SMALLT
	JRST 0(6)
	JRST 1(6)

SKNNM:	LDT TP,1
	CAIL TP,FLOATT
	CAILE TP,SMALLT
	JRST 1(6)
	JRST 0(6)

;SKIP IF FIXED NUMBER

SKI:	LDT TP,1
	CAIL TP,FIXT
	CAILE TP,SMALLT
	JRST 0(6)
	JRST 1(6)

SKNI:	LDT TP,1
	CAIL TP,FIXT
	CAILE TP,SMALLT
	JRST 1(6)
	JRST 0(6)
;SKIP IF LIST

SKLST:	LDT TP,1
	CAIE TP,LISTT
	JRST 0(6)
	JRST 1(6)

SKNLST:	LDT TP,1
	CAIN TP,LISTT
	JRST 0(6)
	JRST 1(6)

; SKIP IF LITATOM

SKLA:	LDT TP,1
	CAIE TP,ATOMT
	JRST 0(6)
	JRST 1(6)

SKNLA:	LDT TP,1
	CAIN TP,ATOMT
	JRST 0(6)
	JRST 1(6)

;SKIP IF ARRAY

SKAR:	LDT TP,1
	CAIE TP,ARRAYT
	JRST 0(6)
	JRST 1(6)

SKNAR:	LDT TP,1
	CAIN TP,ARRAYT
	JRST 0(6)
	JRST 1(6)

;SKIP IF STRING POINTER
SKSTP:	LDT TP,1
	CAIE TP,STPTT
	JRST 0(6)
	JRST 1(6)

SKNSTP:	LDT TP,1
	CAIN TP,STPTT
	JRST 0(6)
	JRST 1(6)

;SKIP IF STACK POINTER

SKSTK:	LDT TP,1
	CAIE TP,STKPT
	JRST 0(6)
	JRST 1(6)

SKNSTK:	LDT TP,1
	CAIN TP,STKPT
	JRST 0(6)
	JRST 1(6)
; HASH SYMBOL TABLE ROUTINE
;PNAME IN 1
;FIRST WORD OF HASH TABLE IS XWD NO. ENTRIES,SIZE-1


;ENTER. IF SYMBOL NOT PRESENT, ENTER IT AND SKIP.
;OTHERWISE (FOR LOOKUP AND ENTER) RETURN ADDRESS OF HASH TABLE
;ENTRY IN 1

HENTER:	SETZM HENTO		;RECLAIMED CELL
HENT1:	MOVEI 6,0(1)		;PNAME, CONVERT TO BYTE POINTER
	HRLI 6,440700
	ILDB 7,6		;LENGTH
HENT1A:	PUSH CP,6
	PUSH CP,7
HENT1B:	MOVEI 5,0		;COMPUTE HASH IN 5
HENT2:	ILDB 1,6
	ADDI 5,0(1)
	IMUL 5,HASHC
	SOJG 7,HENT2		;COUNT CHARS
	TRNN 5,777776		;TEST FOR RESERVED NUMBER
	ADDI 5,555550
	MOVS 3,5		;3 USED FOR RE-HASHING
	MOVEI 1,0(3)
	LSH 1,-LPS
	IDIV 1,NHP
	MOVEM 2,HENTID		;SAVE FOR VALUE CELL CREATOR
	ADDI 2,ATOMHT
	PUSH CP,1(2)		;SAVE ADDR OF PAGE TO BE PROBED
	MOVEI 1,NPS*2		;PROBE COUNT
	MOVEM 1,HENTC
	JRST HENT4


HENT3:	SOSG HENTC		;COUNT NUMBER OF PROBES
	JRST ATMRH		;TOO MANY - TABLE FULL - REHASH
	MUL 3,HASHC		;REHASH FOR ANOTHER PROBE
	ROTC 3,^D20
HENT4:	MOVEI 1,0(3)		;COMPUTE PROBE ADDRESS WITHIN PAGE
	ANDI 1,MPS		;PREVIOUSLY COMPUTED
	ADD 1,0(CP)
	HLRZ 2,0(1)		;EXTRA HASH BITS
	CAIG 2,1		;UNUSED ENTRY IF 1 OR 0
	JRST HENT5
	CAIE 2,0(5)
	JRST HENT3		;EXTRA BITS NOT EQUAL
	HRRZ 4,0(1)		;PNAME POINTER CELL ADDRESS
	HLRZ 4,0(4)		;STRING POINTER
	HRRZ 2,-2(CP)		;ADDREESS OF PROTOTYPE STRING
	SUBI 2,0(4)
	HRLI 2,4
	HRRZ 7,-1(CP)		;LENGTH OF STRING
HENT8B:	MOVE 6,0(4)
	CAME 6,@2
	JRST HENT3
	ADDI 4,1
	SUBI 7,5
	JUMPGE 7,HENT8B
HENTR:	SUB CP,BHC+3		;FLUSH TEMPS
	RET

HENT5:	JUMPE 2,HENT6		;JUMP IF EMPTY ENTRY
	SKIPGE 2,HENTO
	JRST HENTR		;1 MEANS "OLD" ENTRY WHEN REHASHING
	SKIPN 2			;RECLAIMED ENTRY
	MOVEM 1,HENTO		;REMEMBER IT IF FIRST ONE
	JRST HENT3

HENT6:	SKIPLE 2,HENTO		;MAKE NEW ENTRY. USE RECLAIMED?
	MOVEI 1,0(2)		;YES
	HRLZM 5,0(1)		;STORE EXTRA HASH BITS
	MOVSI 2,1		;INCREMENT COUNT OF ENTRIES IN TABLE
	ADDM 2,ATOMHT
HENT7:	AOS -3(CP)		;SKIP RETURN
	JRST HENTR

U HENTO				;ADDRESS OF RECLAIMED CELL AND L/E FLAG
U HENTC				;PROBE COUNT
U HENTID

HASHC:	XWD 240501,202405	;HASH CONSTANT

HASERR:	ERROR0 14,RESET		;HASH TABLE FULL


;REHASH ATOM HASH TABLE

ATMRH:	MOVEI 6,MAXNHT		; DONT LET TOTAL EXCEED MAXNHT
	SUB 6,NHP
	JUMPLE 6,HASERR		;ALREADY AT MAX
	CAML 6,MINHT		;GET LESSOR OF REMAINING ALLOWED AND MIN
	HRRZ 6,MINHT
	MOVEM 6,ATMTT		;ACTUAL # NEW PAGES
	HRRZ 5,NHP
	MOVEI 5,ATOMHT+1(5)
	MOVEI 7,HASHTT
	PUSH CP,5
ATMRH3:	CALL MTPG		;GET SOME MORE PAGES
	 JRST ATMRC			;NOT ENUF PAGES
	HRRZM 7,TYPTAB(4)
	LSH 4,LPS
	MOVEM 4,@0(CP)
	CALL CLRPG2
	AOS 0(CP)
	SOJG 6,ATMRH3
ATMRC:	HRRZ 2,ATMTT
	SUBI 2,0(6)		;# PAGES ACTUALLY GOT
	JUMPE 2,HASERR		;NONE - ERROR
	SUB CP,BHC+2		;FLUSH TWO TEMP
	INTOFF
	HRRZ 1,NHP
	MOVEM 1,ATMTT		;SAVE OLD NHP
	ADDI 2,0(1)
	MOVEM 2,NHP		;UPDATE NHP FOR CALLS TO HENT
	LSH 2,LPS
	SUBI 2,1
	MOVEM 2,ATOMHT		;AND CLEAR # ENTRIES
ATMRH1:	HRRZ 2,ATOMHT(1)
	MOVEI 3,MPS
	HRLI 2,3
	SKIPL HENTO		;EXPAND WITHIN AN EXPAND??
	JRST ATMRH2
ATMRH4:	HLLZ 4,@2		;YEP - NO RECLAIMED ENTRIES
	JUMPE 4,ATMRH5
	MOVSI 4,1		;PUT ONES IN LEFT OF ALL BUT EMPTIES
	HLLM 4,@2
ATMRH5:	SOJGE 3,ATMRH4
	JRST ATMRH6
ATMRH2:	MOVE 4,@2		;MARK ACTIVE ENTRIES WITH 1 IN LH
	TRNE 4,-1		; IF RH IS 0, CLEAR IT TOO
	TLNN 4,-2
	SKIPA 4,[0]		;AND CLEAR RECLAIMED ENTRIES
	HRLI 4,1
	MOVEM 4,@2
	SOJGE 3,ATMRH2
ATMRH6:	SOJG 1,ATMRH1
	HRRZ 1,ATMTT		;OLD NHP
ATMR3:	HRRZ 2,ATOMHT(1)
	MOVEI 3,MPS
	HRLI 2,3
ATMR2:	SKIPN 4,@2
	JRST ATMRS		;EMPTY SLOT
	TLNE 4,-2
	JRST ATMRS		;NEW ENTRY IN PLACE
	SETZM @2		;CLEAR THE SLOT
	PUSH CP,2
	PUSH CP,3
	PUSH CP,4
ATMR5:	HLRZ 1,0(4)		;PNAME PTR
	SETOM HENTO
	CALL HENT1		;AND FIND THE NEW HOME
	 JRST ATMRF		;NOT YET
	POP CP,4
	HRRM 4,0(1)		;STORE IN NEW HOME
	CALL ATMRVC		;AND ADJUST VALUE CELL INDEX
	POP CP,3
	POP CP,2
ATMRS:	SOJGE 3,ATMR2
	SOSLE 1,ATMTT
	JRST ATMR3
	MOVE 6,-1(CP)
	MOVE 7,0(CP)
	SETZM HENTO		;RESTORE STATE FOR ORIGINAL HASH
	INTON
	JRST HENT1B

ATMRF:	HRRZ 4,0(CP)		;NEW HOME IS OCCUPIED
	HRLI 4,0(5)		;STORE IT ANYWAY
	EXCH 4,0(1)		; AND FIND HOME FOR FORMER OCCUPANT
	EXCH 4,0(CP)		;LEAVE OCCUPANT ON STACK
	CALL ATMRVC		;FIX VALUE CELL INDEX OF ORIG.
	MOVSI 2,1
	ADDM 2,ATOMHT		;COUNT ENTRY
	HRRZ 4,0(CP)
	JRST ATMR5

ATMRVC:	HRRZ 2,0(4)		;VCELL PTR
	JUMPE 2,ATMRX		;NO VALUE CELL
	ANDI 1,MPS
	HRRZ 3,HENTID
	LSH 3,LPS
	IORI 1,0(3)	;INDEX INTO HASH TABLE
	HRRZ 3,ATOMHT		;REDUCE TO 13 BITS IF GREATER
ATMRV2:	CAIG 3,17777
	JRST ATMRV1
	LSH 3,-1
	LSH 1,-1
	JRST ATMRV2
ATMRV1:	LSH 1,5
	HRLM 1,0(2)
ATMRX:	RET

U ATMTT
U MINHT

; SET NUMBER PAGES TO ADD TO HASH TABLE

MINHSH:	CALL IUNBOX
	CAILE 1,MAXNHT/2
	JRST FALSE		;TOO BIG
	EXCH 1,MINHT
	JRST MKN

; USER ENTRY FOR VCTOAT

UVC2AT:	STN 1,VCELL		;IS ARG A VALUE CELL?
	CALL VCTOAT		;YES - CONVERT TO AN ATOM.
	RET	;NOTE THAT IF ARG NOT VCELL, THE ARG IS RETURNED.
		;THIS LETS YOU JUST CALL VCTOAT WHENEVER IN DOUBT.
		;IE, ARGS IN COMPILED CODE MIGHT BE REAL ATOMS
		;(FOR LOCAL ARGS) OR VALUE CELLS.


;GIVEN VALUE CELL PTR, FIND CORRESP. ATOM
;VCELL IN 1, RESULT IN 1

VCTOAT:	HLRZ 2,0(1)		;GET ATOM INDEX FROM VALUE CELL
	LSH 2,-5
	HRRZ 3,ATOMHT
	CAILE 3,17777
	JRST VCAT1		;CHECK IF MORE THAN 13 BITS OF ATOMS
	MOVEI 3,0(2)
	LSH 2,-LPS
	ANDI 3,MPS
	ADD 3,ATOMHT+1(2)		;HASH ENTRY LOC
VCAT3:	HRRZ 1,0(3)		;GET ATOM PTR
	SUBI 1,2		;ADJUST TO ATOM HEAD
	RET

VCAT1:	LSH 3,-1		;TOO MANY ATOMS - SEARCH A BIT
	LSH 2,1
	CAILE 3,17777
	JRST VCAT1
	MOVEI 3,0(2)
	LSH 2,-LPS
	ANDI 3,MPS
	ADD 3,ATOMHT+1(2)	;FIRST HASH ENTRY LOC
VCAT2:	HRRZ 2,0(3)		;GET ATOM
	HRRZ 2,0(2)		;VALUE CELL
	CAIE 1,0(2)		;CORRECT VALUE CELL?
	AOJA 3,VCAT2		;NO - TRY AGAIN - MUST SUCCEED
	JRST VCAT3
