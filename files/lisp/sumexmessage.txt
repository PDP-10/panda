 8-JUL-76 14:17:52-PDT,496;000000000001
Date:  8 JUL 1976 1417-PDT
From: TEITELMAN

added new function SETLINELENGTH which asks tenex what it thinks
the line length is. SETLINELENGTH is invoked automatically
following a sysin. thus if you are running via a chat connection with
a small font, lisp will know that the line can be longer.
SETLINELENGTH sets the variable TTYLINELENGTH. all places in
the system where output is to go to a terminal used to do a
(LINELENGTH 72). it now does a (LINELENGTH TTYLINELENGTH)

-------
12-JUL-76 01:09:45-PDT,281;000000000001
Date: 12 JUL 1976 0109-PDT
From: MASINTER
Subject: record
To:   Teitelman, Kaplan

New feature: the record operations

FFETCH, FREPLACE, and /REPLACE are now implemented. E.g.

(ffetch FOO of X) will translate as a (fetch FOO of X) in a 
FAST context.

Larry
-------
12-JUL-76 01:15:26-PDT,775;000000000001
Date: 12 JUL 1976 0115-PDT
From: MASINTER
Subject: record: user supplied FAST/UNDOABLE versions of ACCESSFNS
To:   Kaplan, teitelman

The user can supply FAST or UNDOABLE versions of ACCESSFNS forms
in the following manner. An ACCESSFNS record looks like

(ACCESSFNS record.name ((field.name fetchdef replacedef) ...]

As before, "fetchdef" and "replacedef" can be either a function 
name, a lambda expression, or a form in terms of the variables
DATUM (and NEWVALUE).

In addition, they can be property lists with the properties
FAST/UNDOABLE or STANDARD, e.g.

(ACCESSFNS LITATOM
  (DEF (STANDARD GETD FAST FGETD) (STANDARD PUTD UNDOABLE /PUTD]

forms in terms of DATUM/NEWVALUE and function names may be freely
mixed in the property list.

-------
12-JUL-76 01:47:40-PDT,608;000000000001
Date: 12 JUL 1976 0147-PDT
From: MASINTER
Subject: record feature
To:   Teitelman, Kaplan

There is a new record type, ARRAYBLOCK. An ARRAYBLOCK declaration
is very much like a DATATYPE declaration, except that the objects
one deals with are arrays. As with DATATYPE's, the actual order
of the fields of the ARRAYBLOCK may be shuffled around in order
to satisfy garbage collector constraints (for arrays, this means
that the pointers actually come last).

For example,

(ARRAYBLOCK FOO ((F1 INTEGER) (F2 FLOATING) (F3 POINTER)
		 (F4 BETWEEN -30 -2) (F5 BITS 12) (F6 FLAG)]

Larry
-------
12-AUG-76 21:05:41-PDT,826;000000000001
Date: 12 AUG 1976 2105-PDT
From: TEITELMAN
Subject: LOADCOMP
To:   KAPLAN, MASINTER, BOBROW
cc:   LEWIS at BBNE


new feature:
there is a function called LOADCOMP of two arguments, FILE and LDFLG.
LOADCOMP effectively looks at FILE and
makes all necessary changes to NOFIXFNSLST, NOFIXVARSLST, etc.
so that the material in thatfile is "noticed" for the purposes
of dwimifying. All expressions under a DECLARE:
EVAL@COMPILE are also evaluated. Thus, if you are building
a "system", and want to compile one file, you simply have
to LOADCOMP the other files.

note: LOADCOMP does not look atDEFLIST's or PUTPROPS
unless they are under a DECLARE: . it also does not
read in the function definitions, but
uses the file map, and/or skread so it does not
perform a lot of unnecessary conses.

warren
-------
28-SEP-76 14:08:45-PDT,2089;000000000001
Date: 28 SEP 1976 1408-PDT
From: TEITELMAN
Subject: PRINNDEF, TAB ETC.
To:   WEISSMAN at BBND


a change was made some time ago butti guess this is the firt
net release to get out with it. there is a minor incompatibility
but it provides new capability hitherto not available.

ussd to be the case thatprintdef alwayscaaled
TAB giving it the position of its (PRINTDEF's)
LEFT argument (which defaults to 0).
TAB would do a terpri and space over if you
were already beyond thatpoint. thus the net effect was if
you were beyond the indicated column, you always got
a free TERPRI. However, thi meant that it was not
possible to do something like the following:
print several atoms on a line, and then start a printdef
without either havng it go to a new line, or having
its left maagin unnecessarily far in, e.g. supppose
you wanted to prettyprint a history event, say one inw hich
you did DEFINEQ((FOO (LAMBDA (X) --))
you would print DEFINEQ, and then call PRINTDEF on
its argument. however, either you would then be
forced to go to a new line or else have to specify LEFT
to be greater than the current position.

the way printdef now works is that it calls
TAB but in a way so that a terpri is not done if
you are already beyond thatposition, i.e. it is a nop.
(this is indicated by value ofminspaces for TAB being T.)

the manual does not specifically say what printdef does
initially if you are already beyond its left hand margin,
and there was no way i could get the intended effect without
making this change.

the solution from your standpoint if you want printdef to
always staat a new line if it is beyond LEFT
is simply to first prform (TAB LEFT).


to summarize, you can now call printdef and start printing
an  xpression on the same line, wheres befor you couldnt, i.e.
you can print


.....     (FOO (LAMBDA (X)
    (COND
      ((--  etc.

if you want to always start a new line, either perform
a TERPRI first, or else perform a (TAB N), which will
perform the terpri only if you are already beyond N.

warren
-------
15-NOV-76 20:16:48-PST,1708;000000000001
Date: 15 NOV 1976 2016-PST
From: TEITELMAN
Subject: REALFRAMPE AND DUMMYFRAMEP
To:   LISP


here is latest situaton:

there is a function DUMMYFRAMEP(POS) which is T if the user
never wrote a call to the function at POS, e.g. in interlisp-10
DUMMYFRAMEP is T for *PROG*LAM frames, *ENV* frames, and
FOOBLOCK frames.

DUMMYFRAMEP is used in break for matching in the baktracelst,
so that the baktraclest does not have to have dummyframes in it.
however, baktrace will still print dummyframes that
are not included in a sequence that matches baktrace.
(question - maybe this sould be suppressed on BT but
not !BT or some such?)

there is a function REALFRAMEP(POS INTERPFLG) which is
T if POS corresponds to a real frame, i.e. the user did
write a call to POS, and furthermore either INTERPFLG is T,
or else POS is a frame thatwould be there interpreted or
compiled both. For example, for the frame corresponding
to COND, REALFRAMEP(POS T) is T, but REALFRAMEP(POS) is NIL.

REALSTKNTH(N POS INTERPFLG OLDPOS) skips
back N or -N frames for which (REALFRAMEP POS INTERPFLG) is T.


Thus, REALFRAMEP and REALSTKNTH can be used to write
functions which work on interpreted or compiled
code. For examppe, REALSTKNTH i s used in
READLINEP, the function which checks to see if you
are under a call to readlne. Used to be the case that
if you had a lispxuserfn which was not compiled, READLINEP
didnt work correctly.


DUMMYFRAMEP, REALFRAMEP, and REALSTKNTH are in LOADUP
on NEWLISP. DUMMYFRAMEP probably belons in the VM.
not sure about the relationship betteen realframep and
the vm.

note difference in sign between dummyframep and realframep.


warren

-------
27-FEB-77 15:12:17-PST,208;000000000001
Date: 27 FEB 1977 1512-PST
From: MASINTER
To:   teitelman
cc:   HThompson

new CIRCL on <NEWLISP> fixing bug in COPYALL so that it copies user
data types.

{a RETURN was left out}.

Larry
-------
24-MAR-77 14:51:16-PST,1361;000000000001
Date: 24 MAR 1977 1451-PST
From: MASINTER
Subject: changes to HELPSYS
cc:   teitelman

This is a brief summary of the changes that I made to HELPSYS:

a) I performed a large number of local-optimizations; i.e. played
smart compiler. For example, I changed (PRIN1 (PACK (LIST A B))) to
(PRIN1 A) (PRIN1 B); I also got rid of some of the code which was not used.


b) I fixed the situation in which HELPSYS would occasionally
put out a naked carriage return without line-feed, causing overprinting.

c) I fixed two or three situations where HELPSYS would cause non-numeric
arg errors.

d) I simplified the interrupt structure as follows: control-O (or whatever
character was assigned to OUTPUTBUFFER) is redefined when in HELPSYS
to mean to stop the current type-out. This eliminates all confusion
about when it is safe to type the interrupts-- it is always safe
to type a control-O.

e) Finally, I fixed HELPSYS so that it will not mess up if the
HELPSYS files are not available (this used to cause several anomalous
conditions, e.g. it would close the current input file).

In general, performance should be slightly improved, a few bugs
fixed and no new bugs introduced; however, HELPSYS is still
quite flakey in that it often answers with irrelavant information
or formats that information in an unusual way.

Larry
-------
25-MAR-77 22:44:22-PST,843;000000000001
Date: 25 MAR 1977 2244-PST
From: TEITELMAN
Subject: iterative operator extension
To:   LISP
cc:   WILBER at SRI-KL, VITTAL at BBN



it is now possible to redefine built in iterative oprators
using i.s.opr. to refer to the original definition, one uses
the flag ORIGINAL (similar to prettyprint, compiler, editor conventions)>
E.G.
i.s.opr(while NIL (WHEN FOO ORIGINAL WHILE BODY))
could be used to extend the definition of
WHILE to include a FOO check.

note thatin the case thatthe i.s.opr is already defined via a
property list definiton, e.g. collect, do, count, etc.
then if you redefiie it, ORIGINAL will not be abe
to obtai the original definition. ORIGINAL is primarily
intended for redefining and/or extending built in opratrs,
such as WHILE, TO, IN, and (i hope it works) FOR, BIND, etc.

warren


-------
19-Mar-78 23:01:10-PST,1372;000000000001
Date: 19 Mar 1978 2301-PST
From: White
Subject: LISP function library prototype
To:   siglunch:

As I discussed during SIGLUNCH a few weeks ago, I have created a
prototype system which acts as a LISP function library. The system
deals with LISP functions and files. Every function available is
placed into one or more categories, or files, according to some
common features of the functions. A user can perform tasks which
provide information about the files and functions; and then select
subsets of the functions to be placed on a separate file for use in
other LISP systems.

Anyone can use the system by running <WCW>UTIL , which causes you to
first be asked if you want to see "task timing info in terminal
output". Since, in this application, you are probably not interested
in recording the execution time of the various tasks, you should
answer this question with a "N". Next you will be asked "what do you
want to do?". At this point, you may ask for any of the tasks known
to the program; and you can find out what is available by typing "?".

Please take some time to try out what is currently in the system, and
then send me your comments and suggestions.  There are probably a lot
of things that can be done, depending on how useful they might be.
Please SNDMSG to WHITE, or call me at 7-4878 or (415)961-4837.

Bill White
-------
18-Apr-78 10:48:50-PST,570;000000000001
Date: 18 Apr 1978 1048-PST
From: Vanmelle
Subject: Re: LISP things
To:   Achenbach

In response to your message sent 18 Apr 1978 1014-PST

Yep, that's right.  It's a homemade lisp that lacks some of the larger
lisp packages (e.g. compiler and masterscope).  It is somewhere between
the tiny <lisp>carhart and the huge <lisp>lisp.  It is quite unofficial;
we use it just for mycin.  I once discussed with Suzanne the possibility
of making it available to the general community, but since <lisp> is
chronically over allocation we never did.

	Bill
-------
18-Apr-78 12:34:04-PST,520;000000000001
Mail from PARC-MAXC rcvd at 18-Apr-78 1234-PST
Date: 18 APR 1978 1227-PST
From: MASINTER at PARC-MAXC
Subject: lisp consulting
To:   Achenbach at SUMEX-AIM

Well, feel free to send me any questions you have.
I would like to continue the arrangement that
I had with Suzanne (all user complaints would
go thru her, but any question she couldn't handle
she would send to me). 

I occasonally get questions directly from
SUMEX users; I will forward copies of them
to you to keep you posted.

Larry
-------
26-Apr-78 23:06:52-PST,352;000000000001
Mail from PARC-MAXC rcvd at 26-Apr-78 2306-PST
Date: 26 APR 1978 2258-PST
From: MASINTER at PARC-MAXC
Subject: CARHART.SAV
To:   Fisher at SUMEX-AIM
cc:   Achenbach at SUMEX-AIM, smith at SUMEX-AIM

Fritz: I made a new CARHART.SAV which corresponded with
the latest NNLISP, and FTP'd it to <LISP>CARHART.SAV;80402
at SUMEX.

Larry
-------
 2-May-78 15:08:03-PDT,658;000000000001
Date:  2 May 1978 1508-PDT
From: Fisher
Subject: LISP MAINTENANCE AND DENDRAL MAINTENANCE
To:   ACHENBACH
cc:   FISHER, SMITH

	DENNIS WANTS ME TO PREPARE A SHORT REPORT ON HOW LISP IS MAINTAINED
SO THAT CHANGES IN LISP AND SLISP WILL CAUSE US AS LITTLE DIFFICULTY AS
POSSIBLE. I DON'T KNOW THAT THERE IS MUCH THAT WE CAN DO ABOUT LISP
BUT WE SHOULD BE ABLE TO WARN THE CHEMISTS THAT VERSION A AND B CAN'T LOAD
EACH OTHERS COMPILED FILES. THIS IS THE CASE CURRENTLY WITH SUBSYS LISP AND 
LISP LISP. THEREFORE IT WILL EVENTUALLY BE A PROBLEM. THE <LISP>CARHART.SAV
WHICH IS THE "SAME" AS <SUBSYS>SLISP ALSO CAN'T LOAD EACH OTHERS FILES.
-------
20-Dec-78 15:32:29-PST,1202;000000000001
Mail from PARC-MAXC2 rcvd at 20-Dec-78 1532-PST
Date: 20 Dec 1978 3:26 pm (Wednesday)
From: Masinter at PARC-MAXC
Subject: Re: FRPLNODE2
In-reply-to: Your message of 20 Dec 1978 1317-PST.
To: Achenbach at SUMEX-AIM
cc: masinter at PARC

You might even want to get into the loop of making up the 'small lisp' yourself
(I believe the MYCIN people regularly load up their own lisp system starting
with the system files from PARC; you might even arrange with Bill van Melle to
share the disk space somehow).

Bill is familiar with the proceedure. What you need to do is to start with
[parc-maxc2]<netlisp>loadup.sav, have all of the needed .COM files around (for
the files which are on SYSFILES inside CARHART.SAV which are not in
SYSFILES in LOADUP.SAV; I don't know what they are), and then say

LOADUP((names of those files))
MAKESYS(CARHART.SAV;version number).


I think the files that you need for CARHART lisp include
DATATYPE.COM, MAC.COM, BREAK.COM, HELPDL.COM, ADVISE.COM,
although I am sure there are more (which you can find out by comparing the
values of SYSFILES).

Larry

(p.s. I will fix the compiler so that it doesn't generate FRPLNODE2's in the
future).

18-Jan-79 12:07:56-PST,1446;000000000001
Mail from CMU-10A rcvd at 18-Jan-79 1207-PST
Date:    18 Jan 1979 1506-EST
From:    DAVID.NEVES(A310DN10) at CMU-10A 
Subject: relaim & storage
To:      achenbach at SUMEX-AIM
cc:      neves at SUMEX-AIM

Below is a note I sent last month.  I would really like to know  what
is going on with reclaim and storage.  If you can't help could
you suggest someone at PARC or BBN who might?

____________________________________________________________
-------
13-Dec-78 09:02:17-PST,938;000000000000
Date: 13 Dec 1978 0902-PST
From: Neves
Subject: Lisp garbage collection and storage stats.
To:   achenbach
cc:   neves

Paul Kline told me that you were the person to ask if one had questions
about Interlisp on Sumex.  I am working with a knowledge acquisition
system written in Lisp.  What I am trying to do is to get an idea
of how much storage each new piece of knowledge takes up in CORE when
it is created.  What I thought of doing was to add X pieces of knowledge after
doing a RECLAIM() andf STORAGE() and then do another RECLAIM()
and STORAGE().  However,  it seems as though whenever I do a RECLAIM it
somehow thinks I am using more storage even if I did nothing after
the previous RECLAIM  except for perhaps a call to STORAGE.  i.e.
it says I am using up to 700 words of List space more.  If RECLAIM
is doing these wierd things I can't get the statistics I need.

Any suggestions?     Thanks, dave.
-------
24-Jan-79 12:10:50-PST,796;000000000001
Mail from BBN-TENEXD rcvd at 24-Jan-79 1210-PST
Date: 24 Jan 1979 1512-EST
From: HARTLEY at BBN-TENEXD
Subject: RECLAIM AND STORAGE
To:   ACHENBACH at SUMEX-AIM, NEVES at SUMEX-AIM
cc:   MASINTER at PARC, LEWIS

IF I UNDERSTAND THE MESSAGE CORRECTLY THE QUESTION IS:
HOW COME THE AMOUNT OF LIST SPACE USED INCREASSES SUBSTANTIALLY
BETWEEN SEQUENTIAL RECLAIM() STORAGE(). I JUST TRIED IT
AND FIND AN INCREASE OF ABOUT 500 LIST CELLS IN USE EACH TIME.
THE REASON IS THAT THE RESULTS OF THE CALL TO STORAGE
ARE STORED ON THE HISTORY LIST - AND MUST TAKE THAT MUCH 
SPACE TO DO SO. IF YOU USE CONTROL-W (I.E. ^W(STORAGE)) THEN
THERE IS NO INCREASE.
	ALICE
P.S. WHILE THE GC MAY DO ODD THINGS ABOUT ALLOCATING MOADDITIONAL
STORAGE - IT DOES NOTHING ODD ABOUT STORAGE USED .
-------
 9-Feb-79 12:00:45-PST,550;000000000001
Mail from PARC-MAXC2 rcvd at 9-Feb-79 1200-PST
Date:  9 FEB 1979 1200-PST
From: TEITELMAN at PARC-MAXC2
Subject: pattern matching
To:   ACHENBACH at SUMEX-AIM, JMILLER at SUMEX-AIM


as the new manual now states, pattern match is contained
in the file match.com and is not a standard part of the
lisp loadup which is why it is in section 24).
therefore, your site should also ftp the file match.com
from netlisp, if users want to use the paatern match compiler,
and install thatfile either on <lisp> or <lispusers>.


warren
-------
21-Jul-79 15:33:44-PDT,608;000000000001
Date: 21 JUL 1979 1533-PDT
From: TEITELMAN
Subject: recordaccess
To:   lisp

Mail-from: Arpanet host BBN-TENEXD rcvd at 21-JUL-79 1500-PDT
Date: 21 Jul 1979 1753-EDT
Sender: YONKE at BBN-TENEXD
Subject: documentation for RECORDACCESS
From: YONKE at BBN-TENEXD
To: Teitelman at PARC-MAXC2
Message-ID: <[BBN-TENEXD]21-Jul-79 17:53:54.YONKE>

The parameter list for RECORDACCESS (p. 23.36) in the manual
is not in the same order as the real function.  It should read:

	recordaccess[field;value;dec;type;newvalue]

Should be changed whenever a new manual gets generated.

Martin

-------
24-Jul-79 13:21:40-PDT,190;000000000001
Date: 24 JUL 1979 1321-PDT
From: KAPLAN
Subject: Manual description of EDITE talks about NEWFILE?, not MARKASCHANGED
To:   TEITELMAN, LISP

SHould be changed in next edition.
-------
 6-Aug-79 14:19:56-PDT,143;000000000001
Date:  6 AUG 1979 1419-PDT
From: KAPLAN
Subject: ADDBUFFER is really called ADDMAPBUFFER; manual should be changed
To:   LISP


-------
21-Sep-79 13:57:55-PDT,471;000000000001
Date: 21 SEP 1979 1357-PDT
From: KAPLAN
Subject: Manual error
To:   LISP
cc:   TEITELMAN

The manual on p. 14.2 says that INFILEP is the filename if the
file can be opened for input.  This is false.  It merely indicates that
the file exists.  Whether or not you can open it depends on whether you
(or someone else) has it open for output at the time you do the INFILE.

I.e., a non-NIL INFILEP does not mean you won't get a file won't open
error.

-------
24-Sep-79 23:31:34-PDT,1115;000000000001
Date: 24 SEP 1979 2331-PDT
From: TEITELMAN
Subject: new error numbers and interpreter
To:   LEWIS at BBND
cc:   DEUTSCH, LISP, WILLIE-SUE


(1) whenever a u.b.a error occurs the error number will be set
to 44 (error string = UNBOUND ATOM) with culprit the atom.
note thatif dwim corrects the error, no error occurs and error number
is not set. however, if an error is going to occur, whether or
not it will cause a brak, the error number will be set.


(2) whenever an undefined car of form occurs, error number will
be 45 (error string = UNDEFINED CAR OF FORM), and culprit is the form.

(3) whenever an undefined function in aply occurs,
error number 46, culprit is list[fn;args]

(4) whenever user types control-e, error nummer will be 47, errorstring=
CONTROL-E.

the purpose of this is to allow programs to be written in lisp
which can detect what caused an error, and thus be made sufficiently
robust to use as servers.  

willie-sue, you should install these 4 new errors and errorstrings.
you dont have to do anything else since is all aken care f in helpdl.

warren
-------
21-Nov-79 00:57:00-PST,1042;000000000001
Date: 21 NOV 1979 0057-PST
From: KAPLAN
Subject: New MASTERSCOPE on <NEWLISP>  - ANALYZEUSERFNS
To:   TEITELMAN, LISP
cc:   MASINTER

I added a hook to the masterscope function analyzer so that the user
could specify his own computations.

After a function has been analyzed, masterscope looks at the variable
ANALYZEUSERFNS.  If it is non-nil, it is assumed to be a list of functions.
Each of them is applied in turn to the function-name, function-definition,
and analysis data list for the function just analyzed.  The function should
return a new data list (or perhaps just the old one if all that is intened
is side-effecting).

This is the hook that is needed to add various user defined relations to
masterscope.  The MSHASH package will be able to store the argument
list of a function so that DESCRIBE won't have to rummage around for it
if the function is not loaded.  Also, DECL will be able to store the
RETURNS declaration for a function so that inter-function declarations
can be checked.

--Ron
-------
23-Nov-79 22:57:49-PST,886;000000000001
Date: 23 NOV 1979 2257-PST
From: KAPLAN
Subject: DESCRIBELST in masterscope
To:   teitelman
cc:   lisp, masinter

there is also a new masterscope on <NEWLISP>.  I modified the dESCRIBE
command so that the user can specify additional information
that he would like to include in a functions description, other than
the information that is already provided by the system.

DESCRIBELST is a list each of whose elements is a pair conisting of
a string descriptor and a form.  The form is evaluated (it can refer to the
name of the funtion being described by the free variable FN), and if it
returns a non-NIL value, the description string is printed followd by
the items in the value in the standard describe format.

Example:  To include the types used by a function in the describe, the entry
("types:  " (GETRELATION FN '(USE TYPE) T) would suffice.

--Ron
-------
15-Dec-79 17:24:20-PST,342;000000000001
Date: 15 DEC 1979 1724-PST
From: KAPLAN
Subject: ADDMAPBUFFER
To:   TEITELMAN
cc:   LISP

The manual says that it returns T if successful.  That should be changed to
"non-NIL".  

I had corrected LMMAC to obey the manual's description, but that led to
bug in pmapping.  I have reverted to the earlier definition.

--RON
-------
17-Dec-79 21:43:44-PST,620;000000000001
Date: 17 DEC 1979 2143-PST
From: KAPLAN
Subject: SELECTC - SELECT on constant
To:   LISP
cc:   TEITELMAN

This function lies somewhere between SELECTQ and SELECT (which previously
existed but wasn't documented).  With SELECTC, the selection keys are
evaluated when called from interpreted code, just like SELECT.  Unlike
SELECT, the keys are also evaluated at compile-time to form a SELECTQ.

The form of a selection clause is either 
1.  an atom or list of atoms, whose values are treated as the keys.
2.  a list of lists, the elements of which are forms whose values are treated
as the keys.

-------
17-Dec-79 23:50:59-PST,467;000000000001
Date: 17 DEC 1979 2350-PST
From: KAPLAN
Subject: SELECTC again
To:   lisp

Description is now:

SELECTC is like SELECTQ except that it evaluates the key positions of its
arguments to obtain the actual keys for a selectq-type comparison.

This evaluation is done at compile-time to produce a SELECTQ form--the
keys are in a sense compile time constants.

Note that the argument syntax for SELECTC differs from the
undocumented function SELECT.
-------
18-Mar-80 07:14:44-PST,449;000000000001
Date: 18 MAR 1980 0714-PST
From: KAPLAN
Subject: New filepkg type property:  WHENUNFILED
To:   TEITELMAN, MASINTER, GOLDMAN at ISIE
cc:   LISP

<NEWLISP>FILEPKG allows for a new filepkg type proprty WHENUNFILED.
Parallel to WHENFILED, its valu is a list of functions that will be applied
to name, type, and file whenever an item named name of type type is
removed from file by the function DELFROMFILES (or DELFROMFILE).

--Ron
-------
18-Jul-80 12:02:37-PDT,1533;000000000001
Date: 18 JUL 1980 1202-PDT
From: KAPLAN
Subject: New FILEPKG on <NEWLISP>
To:   TEITELMAN
cc:   LISP

I changed the way the FILES command works so that it puts out an
expression that interprets the arguments at load-time instead of dump-time.
In particular, this means that the load-time compile.ext will be used, so
that the appropriate choice between COM and DBYTE will be made.

The format of the command is checked at dump-time, by the function MAKEFILESCOMS,
to make sure that there is no striking error.

The expression put out on the file is of the form
(FILESLOAD . arguments to the FILES command), where FILESLOAD is a new
function that interprets the command.

Another change:  The ARRAY command will now report that it contains
variables (as per a request by Larry).

This request raises another issue about the ARRAY command, however:  why have
it at all.  It seems to me that the VARS command should be smart
enough to know that if the user asks for a variable with an array value to
be dumped, he does not want to see #123456 on the file.  The VARS command
itself should be able to convert to what the ARRAY command current does
in case the value is an array.  (Then, for backward compatibility, we could
make ARRAY just be a synonym for VARS, and eventually have it drop from
the documentation.)

This proposed cleanup must be implemeneted in PRETTY (I think in PRETTYVAR1).
If you go along with this, let me know and I will make the appropriate
cleanups in FILEPKG.

--Ron
-------
22-Aug-80 16:08:15-PDT,2634;000000000001
Date: 22 Aug 1980 1608-PDT
From: Rindfleisch
Subject: NOTES ON XEROX LISP MACH DEMO
To:   SUMEX STAFF:

In response to the message sent  22 Aug 1980 1148-PDT from Cmiller

Following are some notes on the Xerox LISP machine demo last night:

1) Xerox machine tech specs

			DOLPHIN (D0)   		DORADO

IC technology		Schottky TTL		ECL
Address space		4M 16-bit words 	4M 16-bit words 
			(extendable to 16M) 	(extendable to 16M) 
Micro store		4K 36-bit words 	4K 34-bit words 
Microcode cycle time	200 nsec		60 nsec
Datapath		16 bits			16 bits
Main memory		198K - 768K 16-bit wds	512K 16-bit words
						(expandable to 16M)
Memory access time	1 usec			1.4 usec
Cache size		n/a			4K 16-bit wds
						(4-way set associative)
Cache access		n/a			120 nsec
Display			808 x 606 bit map	808 x 606 bit map 
Disk			Shugart SA4008		Trident T-80
			(20M bytes)		(80M bytes)
Net connection		Ethernet		Ethernet 
Cost (internal Xerox)	$15K			$60K

2)  Bill Clancey had GUIDON running on the Dolphin for the demo and
    his subjective feel was like SUMEX under a 3-5 load average.  Thus
    the Dolphin is roughly a KA-10.  He has not run extensively on the
    Dorado to calibrate its feel.

3)  The MIT CADR was demonstrated.  It was hard to calibrate its speed
    since it does not run INTERLISP and hence no benchmark is possible
    for a system we have experience with.  I have the impression it is
    roughly KA-10 speed.  Apparently Richard Greenblatt is still trying
    to set up a company to sell them and he is talking about something
    like half price compared to Symbolics, Inc.  That may or may not be
    real

3)  Peter Szolovits gave me some details on the current Zenith NU
    status.  MIT has 10 of them now.  They use the half speed MC68000
    chip w/o virtual addressing currently.  That will be upgraded as
    Motorola hardware makes it possible.  The machine is designed with
    a 32-bit wide internal bus -- in anticipation of either INTEL's
    coming 32-bit system or the 32-bit Motorola chip.  There are some
    packaging problems in the display and disk that cause overheating
    (these should be easily fixed).  They have an operating system, akin
    to UNIX, just working (it is written in C -- compiler runs on the
    VAX).  Note the difference between this approach and the Xerox
    machine where LISP is the environment w/o underlying operating
    system.  The NU system will support multiple processes.  It will
    come connected to one of the MIT-peculiar networks (not Ethernet).
    It is too early for any benchmarks yet.

Tom R.
-------
10-Sep-80 15:59:34-PDT,1529;000000000001
Mail from SU-SCORE rcvd at 10-Sep-80 1559-PDT
Date: 10 Sep 1980 1558-PDT
From: CSD.FREEMAN at SU-SCORE
Subject: INTERLISP Q
To: achenbach at SUMEX-AIM

I am writing a display representation language editor and for various
reasons have decided not to put the display package in the editor, like
the existence of terminal independent dpy packages, the capabilities of
altos, the advantages of local dpy for remote editing, etc., and want
to start a program running concurrently with INTERLISP. Since it is
to run while INTERLISP is running, SUBSYS isn't the right thing, but
it is close. To communicate between the two programs I'm going to use
pty's, thus (INFILE Pty#:) (OUTFILE Pty#:) seem to be just what I want.
I plan on using the following scheme to start the dpy program.
    1) Use (INFILP file) to verify/expand the file name
    2) Use (OPENFILE file INPUT NIL 36) to open the file
    3) Use (OPNJFN file) to get the jfn to pass to some ASSEMBLE code
	that will start the program running on a fork.
    4) The program will then sti the pty# to interlisp and it will
	use INFILE/OUTFILE as above.

My question is basically, what is wrong with the scheme, assuming that
I really do want ptys and a concurrent dpy program?  Should I avoid
ASSEMBLE as much as possible and use (JS ...) when possible?  What about
jsys errors?

The alto and other non-local versions will have the dpy package "above"
INTERLISP, so all this will be unused, but for now....

Thanks for your help,
andy
-------
25-Sep-80 14:58:21-PDT,727;000000000001
Date: 25 Sep 1980 1458-PDT
From: White
Subject: INTERLISP comments
To:   ACHENBACH
cc:   RINDFLEISCH, WHITE

I have encountered a peculiar feature (bug ?) in interlisp regarding 
comments loaded from files when NORMALCOMMENTSFLG is NIL.

It appears that  comments which begin with some special characters are
not loaded as comment pointers (ie. their full text is loaded) even though
NORMALCOMMENTSFLG is NIL.  This can be demonstrated using the file
<WHITE>COMTEST.  The variable SCHARS in this file is a list of all the
characters which defeat the setting of NORMALCOMMETSFLG.

Please let me know what is going on here.  I really would like to have
all my comments loaded as comment pointers. 
Bill
-------
 6-Oct-80 11:19:59-PDT,2907;000000000001
Date:  6 Oct 1980 1119-PDT
From: Achenbach
Subject: Your comment problem
To:   WHITE

Bill --

	Here's Masinter's answer to the comment question.  See if this
does any good.

******


Mail from PARC-MAXC rcvd at 6-Oct-80 1109-PDT
Date: 6 Oct 1980 10:55 PDT
From: Masinter at PARC-MAXC
Subject: Re: Is this how comments should work?
In-reply-to: Achenbach's message of 1 Oct 1980 1346-PDT
To: Achenbach at SUMEX-AIM, White at SUMEX-AIM
cc: masinter at MAXC2

Apparently, READCOMMENT checks explicitly for CLisp characters and the
paren characters, in order to avoid some situations where the form beginning
with the comment character is not really a comment. The simplest thing for you
to do, if you want to override this, is to redefine READCOMMENT.

_PF READCOMMENT
{from <LISP>ASSIST.;69}
(READCOMMENT
 [LAMBDA (FL RDTBL LST) (* --) 
  (PROG (X START END NCHARS POS TEM FLG FL1 N)
     [COND
      ((OR (NULL LST)
        (CAR LST)
        (EQ FL T)
        (EQ NORMALCOMMENTSFLG T)
        (NOT (RANDACCESSP FL))) (* --) 
       (RETURN (TCONC LST COMMENTFLG]
     (SETQ FLG (ILESSP (SETQ N (POSITION FL))
              26)) (* --) 
     (SETQ POS (GETFILEPTR FL))
     (COND
      ([SELECTQ (SETQ TEM (RATOM FL RDTBL))
           ((%( %) %[ %] %" ' %. DECLARATIONS: E)
            T)
           (COND
            ((NUMBERP TEM)
             T)
            ((EQ TEM COMMENTFLG)
             NIL)
            ((AND CLISPFLG CLISPCHARRAY (STRPOSL CLISPCHARRAY TEM))
             T)
            (T (SELECTQ (PEEKC FL)
                  ((%) %] _)
                   T)
                  NIL] (* --) 
       (GO NO)))
     (SETFILEPTR FL (SETQ START (IPLUS POS -2)))
     [COND
      ((EQ N 2) (* --) 
       (SETFILEPTR FL (SETQ START (IPLUS START -2] (* --) 
     [COND
      ((EQ (SKREAD FL)
        (QUOTE %])) (* --) 
       (SETFILEPTR FL POS)
       (RETURN (TCONC LST COMMENTFLG]
     (SETQ NCHARS (IDIFFERENCE (SETQ END (GETFILEPTR FL))
                  START))
     (SETFILEPTR FL (SUB1 END)) (* --) 
     (COND
      ([AND NORMALCOMMENTSFLG (OR (AND (BOUNDP
NORMALCOMMENTSFLG)
                      (OPENP (SETQ FL1 (EVALV NORMALCOMMENTSFLG))
                          (QUOTE OUTPUT)))
                    (OPENP (SETQ FL1 NORMALCOMMENTSFLG)
                       (QUOTE OUTPUT] (* --) 
       (SETQ TEM (GETFILEPTR FL1))
       (COPYBYTES FL FL1 START END) (* --) 
       (SETFILEPTR FL (SUB1 END))
       (SETQ START TEM)
       (SETQ FL NORMALCOMMENTSFLG)))
     [RETURN (LCONC LST (create COMMENTBOX
                  START _(CONS (IQUOTIENT START 1000)
                         (IREMAINDER START 1000))
                  NCHARS _ NCHARS
                  FLG _ FLG
                  FILE _(OR FL (INPUT]
   NO (SETFILEPTR FL POS)
     (RETURN (TCONC LST COMMENTFLG])
NIL

*****


/Mike
-------
10-Nov-80 01:40:27-PST,663;000000000001
Date: 10 Nov 1980 0140-PST
From: White
Subject: LISP comments
To:   ACHENBACH
cc:   WHITE

Mail from PARC-MAXC rcvd at 9-Nov-80 2221-PST
Date: 9 Nov 1980 22:25 PST
From: Masinter at PARC-MAXC
Subject: Re: COMMENTS
In-reply-to: Your message of 6 Nov 1980 1218-PST
To: White@SUMEX-AIM
cc: masinter

I got  the message, but haven't had time to extract the definition of
READCOMMENT. It's on [maxc2]<lisp>ASSIST, if you want to extract it
yourself. I imagine the COMMENTBOX record is on that file also. I don't
know enough about it to help you further -- Warren Teitelman wrote it.

Larry

Mike,

Can you get this info for me?? 
Bill
-------
 7-Apr-81 07:54:05-PST,540;000000000001
Date:  7 Apr 1981 0754-PST
From: Quayle
Subject: Lisp output files
To:   ACHENBACH
cc:   student1


Mike,

	When the Interlisp manual refers to the primary file, i.e. the
terminal, when the output functions are give a file argument of either T
or  NIL  is that output actually going to the Primary output file
(jfn 101) or is actually going to JFN 777777?  We have reason to believe
that it is the latter, but would like to know for sure.  If that
is the case, then is there any way for a user to change it?

C.Q.
-------
13-Apr-81 10:37:28-PST,1132;000000000001
Mail-from: ARPANET host PARC-MAXC rcvd at 13-Apr-81 1037-PST
Date: 13 Apr 1981 10:33 PST
From: Masinter at PARC-MAXC
Subject: New version of Interlisp-10 on [parc-maxc]<NETLISP>NETLISP.SAV
To: CSD.GENESERETH at SU-SCORE
To: ACHENBACH@SUMEX-AIM, Tucker@SUMEX-AIM
To: DDYER@ISI, CROCKER@ISI, MARK@ISI
To: Wilber@SRI, HENDRIX@SRI
To: Lewis@bbnd, Hartley@bbnd, Yonke@bbnd
To: RBATES@ISIC
To: GOLDMAN@ISIE
To: CROCKER@ISIB
To: VITTAL@BBN, GREENFELD@BBN,YONKE@BBND
To: Pepin@USC-ECL, JAMES@USC-ECL
To: Masinter, Teitelman
To: GOODRICH@I4-TENEX
To: barstow@SUMEX-AIM
To: INTERLISP@SU-AI
To: SOWIZREL@RAND-UNIX
To: HEDRICK@RUTGERS-10
To: CSd.Dea@SU-SCORE
To: RWW@SU-AI, REF@SU-AI
To: GREEN@SCI-ICS, LISP@SCI-ICS
cc: LispCore^
Reply-to: Masinter

There is a new release of Interlisp-10 available on
[PARC-MAXC]<NETLISP>NETLISP.SAV;139. You may
FTP the file using account GUEST password PARC.

I believe that our list of Interlisp-10 liasons is probably out of date.
If you get this message and should not be on the list, or if you know
of someone who should be on the list and is not, please reply.

Larry
15-Oct-82 14:43:46-PDT,10791;000000000001
Date: 02 Apr 1978 1443-PDT
From: PARC
Subject: CHANGES 80402
To: LISP


Note: some of the changes described below are not brand new but
have been in the system for several months without official
documentation. 


Type Names

By and large, Interlisp has now been converted to use type NAMES
(as returned by TYPENAME), in addition to, or in some cases instead
of, type numbers (as returned by NTYP). Functions such as RECLAIM,
MINFS, DEFEVAL, etc. now accept type names as well as type number,
e.g. you can say MINFS(5000 STRINGP). Prettyprintype macros operate
off of type names. The garbage collector and STORAGE print out
descriptive information, using type names, rather than type
numbers.



New Greeting Conventions

Due to problems of incompatibilities with TOPS-20 oerating system,
we have changed the Interlisp greeting convention. Each site should
now have on its <LISP> directory an INIT.LISP file which contains
the system-wide initialization. The INIT.LISP file can be a file
written with MAKEFILE, or WRITEFILE. If a user wants to be greeted
by firstname, he must set the variable FIRSTNAME in his own
INIT.LISP file. (If he also for his birthday to be duly noted, he
must add the expression (date . "Happy Birthday") to GREETLST,
where date is a string, e.g. "20-OCT" or " 5-MAY" (note leading
space in latter date)).

  
I/O related changes

End of file - the default to close a file when an eof is
encountered by an input operation is still in effect. However, this
operation is now performed in ERRORX, rather than in the guts of
lisp, so that the user can override this by handling the eof error
himself via an entry on ERRORTYPELST that does a RETFROM.

Null character - i.e. character(0), now can be read (it previously
was filtered out at a low level). It is initially a separator
character.

FILE NOT FOUND, FILE WON'T OPEN - these errors used to cover a
variety of sins, and have been cleaned up considerably. They now
correspond to the following four errors:

FILE SYSTEM RESOURCES EXCEEDED (error 22) - whole disk full, disk
quota exceeded, directory full, too many jfn's, jsb full.

FILE NOT FOUND (error 23) - the file is really not there, i.e. no
such directory, no such name, no such extensions etc.

PROTECTION VIOLATION (error 41) - attempt to open a file that you
have no access too. Includes reference to unassigned device.

BAD FILE NAME (error 42) - includes true garbage such as illegal
character in file specification, two ;'s in a row, etc. 

FFILEPOS - now takes an additional(( optional)) argument,
CASEARRAY, which should be an (ARRAY 128 128). EAch character in
the file and in the pattern is mapped "thru" CASEARRAY in the sense
that character N is turned into character (ELT CASEARRAY N+1)
before matching. Thus to do upper and lower case equivalence, one
can give FFILEPOS an array where N -> N except that lower case
characters map to upper case characters. Similarly, to search for
an atom in a file when you don't know whether it is delimited by
space, carriage return, or parens, search for " atom " and use a
CASEARRAY in which all separators and break characters map to the
same character.

There are still some known bugs with respect to carriage returns
not being inserted by print at the right place. These will
hopefully be
fixed in later releases.



DWIM related changes

FIXSPELLDEFAULT - specifies the default for spelling corrections.
Initially Y. FIXSPELLDEFAULT is rebound to N when under an explicit
call to DWIMIFY or when compiling, so that the default on spelling
corrections in this case will be No, i.e. you can walk away from
your terminal and dwim won't take any liberties with your program.


FIXSPELLREL - determines the default for closeness measure for
spelling correction, e.g. setting FIXSPELLREL to 100 has the effect
of only considering spelling corrections with zero mistakes.
FIXSPELLREL is initially 70.

NOSPELLFLG - if non-NIL, and also not T, means to suppress spelling
correction in programs, but enable it on type-in.


FIXSPELL - TIEFLG can now be one of NIL, PICKONE, LIST, or
EVERYTHING. If a tie occurs, and TIEFLG=NIL, FIXSPELL returns NIL.
If TIEFLG=PICKONE, FIXSPELL picks the first one. If TIEFLG=LIST,
returns list of candidates. If TIEFLG=EVERYTHING (new feature), all
candidates above REL are returned, regardless of whether some are
better than others.

DWIMIFY - now takes a third argument, QUIETFLG, which can be used
to suppress printout so that DWIMIFY can be called from a program.

DWIMIFY - can be told about constructs which bind variables, e.g.
LAMBDA, PROG, RESETVARS, etc. by including the atom BINDS on the
INFO property for car of the form. DWIMIFY will then assume that
CADR of the form is a binding list, which can be either NIL, an
atom, a list of atoms, or a list of atoms and lists (like prog
bindings). DWIMIFY will process the binding list in the obvious way
and then dwimify CDDR of the expression. 

I.S.OPR - can now be used to redefine built in iterative oeprators,
and still refer to the original definition via the flag ORIGINAL,
e.g. i.sopr(WHILE NIL (WHEN FOO ORIGINAL WHILE BODY)) could be used
to extend the definition of WHILE to include a FOO CHECK. 

I.S.OPR - Whenever an i.s.opr has been redefined, all expressions
using that i.s.opr that have been translated will have their
translations cleared automatically, and hence be retranslated.

I.S.OPR - i.s.opr's can now be defined which contain a mixture of
upper and lower case letters, e.g. I.S.OPR(OutOf --). DWIM will
recognize both the upper case version, and the mixed upper/lower
case version as it appears in the call to I.S.OPR, and CLISPIFY
will convert back to the mixed version when LCASEFLG is T..

MACROCHARS - new option in ASKUSER, similar to PROMPTON,
COMPLETEON, etc. MACROCHARS takes a list of dotted pairs of
character and form. When the corresponding character is typed, and
it does not match any of the current keys, and is on MACROCHARS,
form is evaluated and nothing else happens. For example, ? could
have been implemented that way.

In addition, a number of bugs have been fixed in CLISPIFY, DWIMIFY,
RECORD, and MATCH 


Miscellaneous

control-T - now prints out information about what functions the
program is in at the time control-T is typed, in the form RUNNING
(or IOWAIT) IN fn1 IN fn2 IN fn3, LOAD nnn.nn, or, in the case of a
garbage collection, COLLECTING, LOAD nnn.nn. Don't be alarmed if
occasionally fn1 is not the name of a function, e.g. RUNNING IN _
IN EVALQT...

Break within a break - if a break occurs on a user function within
in a break in a situation where a loop would occur, e.g. by
breaking on a function called via BREAKRESETFORMS, the break
messages is printed, and the body of the function evaluated (rather
than going into the break and looping), and the computation
proceeds. On other types of breaks, e.g. an undefined function on
BREAKRESETFORMS, BREAKRESETFORMS is rebound to NIL and HELP called.

U-CASE, L-CASE - now can be given a list as an argument, and return
a list consisting of the result of upper/lower casing each element
of the list.

PACK* - lambda nospread for doing pack, i.e. (PACK* x1 x2 ... xn)
equivalent to (PACK (LIST x1 x2 ... xn)).

SYSOUTFILE - is the name of the last sysout. SYSOUT[] will perform
a sysout onto a (new version of) the value of SYSOUTFILE.
SYSOUTFILE is initially WORK.SAV

SYSOUT.EXT - specifies the default extension for sysouts when none
is supplied. SYSOUT.EXT is initially SAV. (TOPS-20 sites should set
SYSOUT.EXT to EXE in their LISP.INIT file).

RECOMPILEDEFAULT - specifies default for recompiling when FNS=NIL
and CFILE=NIL. RECOMPILEDEFAULT is initially EXPRS for backwards
compatibility, but for some applications, the user might find
setting it to CHANGES more desirable, to specify recompiling
everything that had changed.

New DECLARE: tags - EVAL@LOADWHEN, EVAL@COMPILEWHEN, COPYWHEN
permit compile/run time determination of what to do with the
expressions in a DECLARE:. The expression following the tag in
question is evaluated, and its value determines the sign of the
tag. e.g. (DECLARE: EVAL@LOADWHEN FOO (P (PRINT "HI" T))  ) will
print HI if the value of FOO at load time is non-nil.

BEFORESYSOUTFORMS - a list of expressions to be evaluated before a
sysout a la AFTERSYSOUTFORMS.

MAKEFILEFORMS - a list of expressions to be evaluated before
calling PRETTYDEF. MAKEFILE now rebinds PRETTYTRANFLG, PRETTYFLG,
and CLISPIFYPRETTYFLG, and under a RESETLST evaluates each
expression on MAKEFILEFORMS and then calls PRETTYDEF. This gives
the user a place to add things to be done before each file is
dumped, and by doing them with a RESETSAVE, have the effects
restored when the MAKEFILE is finished, or aborted. For example,
MAKEFILEFORMS is initialized to contain the expression (AND (NEQ
(LINELENGTH) FILELINELENGTH) (RESETSAVE (LINELENGTH
FILELINELENGTH))).
 
PROMPTCHARFORMS - a list of expressions to be evaluated each time
that PROMPTCHAR is called and is about to (but before it does)
print the promptcharacter. The variables HISTORY, and ID are bound
to the history and id respectively, so that you can put expressions
on PROMPTCHARFORMS which get executed only at the top level or only
in the editor, etc. by testing ID. The variable PROMPTSTR is what
will be printed before the promptcharacter. If after evaluating
each form on PROMPTCHARFORMS, either ID or PROMPTSTR have been set
to NIL, they are not printed.

HISTORYSAVEFORMS - a list of expressions to be evaluated each time
HISTORYSAVE is called. The variables HISTORY and ID are bound to
the history and ID, and the variable EVENT is the current, i.e.
about to be executed, event. 

Note that PROMPTHCHARFORMS and HISTORYSAVEFORMS let you effectively
bracket each interaction with the user.

#UNDOSAVES - if negative, means continue saving until |#UNDOSAVES|
have been recorded, and then simply stop saving and discard the
information without interacting with the user, i.e. same as if the
user were asked to continue saving and said No.

CPLISTS - now has an extra argument, IGNORECOMMENTSFLG, which if T
means comments will be ignored for the purposes of comparison, i.e.
if one function has a comment where the other doesn't, it won't
throw the entire match off. 

BREAKDOWN - BRKDWNTYPE can now be a list of things to be measured.
Also, if BRKDWNCOMPFLG is non-NIL, the calls to BRKDWN2 are
expanded in-line leading to more precise measurements, but at
substantial cost in code space.

In addition, a number of bugs have been fixed in the compiler and
MASTERSCOPE.


-------
 2-Oct-83 18:47:13-PDT,521;000000000001
Return-Path: MASINTER.PA@PARC-MAXC.ARPA
Received: from PARC-MAXC.ARPA by SUMEX-AIM.ARPA with TCP; Sun 2 Oct 83 18:47:11-PDT
Date: 2 OCT 83 18:37 PDT
From: MASINTER.PA@PARC-MAXC.ARPA
Subject: HELPSYS
To: schmidt@sumex-aim.ARPA
cc: lispsupport.PA@PARC-MAXC.ARPA, white@sumex-aim.ARPA,
 lane@sumex-aim.ARPA

HELPSYS got removed from the loadup; it never worked properly even
with the 1978 manual. We are planning a replacement, although I don't
have an accurate estimate as to when it will be released.

Larry
