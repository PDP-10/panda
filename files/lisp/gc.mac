;<NEWLISP>GC.MAC.2, 15-Oct-81 10:52:29, Edit by LEWIS
; more for frank
;[BBND]<LEWIS>GC.MAC.1,  2-Oct-81 16:31:56, Ed: LEWIS
; a little extension of the thing for frank
;<NEWLISP>GC.MAC;4    18-MAY-79 11:09:24    EDIT BY MASINTER
; add maxc-only GCINST changes once more
;[BBN-TENEXD]<NEWLISP>GC.MAC.1,  7-May-79 13:03:01, Ed: LEWIS
; Fix tightgc stuff to work correctly
;[BBN-TENEXD]<NEWLISP>GC.MAC.1, 17-Jan-79 10:29:43, Ed: LEWIS
;[BBN-TENEXD]<NEWLISP>GC.MAC.1, 30-Aug-78 17:40:01, Ed: HARTLEY
;FIX STRING/GC BUG WHEREBY LAST STRING COULD BE SMASHED
;<NEWLISP>GC.MAC;3    29-JUN-78 03:21:59    EDIT BY MASINTER
; more GC message stuff
;[BBN-TENEXD]<NEWLISP>GC.MAC.17, 30-Jun-78 22:49:53, Ed: HARTLEY
;<NEWLISP>GC.MAC;2    28-JUN-78 00:11:10    EDIT BY MASINTER
; modify GC message code
;<NEWLISP>GC.MAC;19     6-JUN-78 02:02:43    EDIT BY MASINTER
;Fix hash table code increment
;<NEWLISP>GC.MAC;17     5-JUN-78 11:37:46    EDIT BY MASINTER
; restore AC3 at REHSHS since HSHLMT uses it
;[BBN-TENEXD]<LEWIS>GC.MAC.1,  1-Jun-78 21:53:05, Ed: LEWIS
; FIX REHASH TO INIT COUNT PROPERLY
;[BBN-TENEXD]<LEWIS>GC.MAC.1, 30-May-78 14:28:05, Ed: LEWIS
; PUT UPDATING BACK IN
;[BBN-TENEXD]<LEWIS>GC.MAC.1, 15-May-78 13:47:28, Ed: LEWIS
; REMOVE UPDATING OF HASH ARRAY COUNT DURING GC.
;[BBN-TENEXD]<NEWLISP>GC.MAC.11,  3-May-78 15:30:12, EDIT BY LEWIS
; fix "clear count" in rehash to -1 instead of zero
;<NEWLISP>GC.MAC;3    21-APR-78 15:46:27    EDIT BY MASINTER
; fix double AOS NLISTW in IFDEF MAXC
;<NEWLISP>GC.MAC.6    20-Apr-78 22:35:36    EDIT BY LEWIS
; disable interrupts in makesys
;<NEWLISP>GC.MAC.2    11-Jul-77 20:07:03    EDIT BY HARTLEY
;FIX CHASLS, CHASAT, CHASSP TO USE LESS STACK
;<NEWLISP>GC.MAC.1    21-Apr-77 12:27:39    EDIT BY HARTLEY
; MAKE STACK PAGES NON-SYSTEM
;<HARTLEY>20GC.MAC.6    18-Feb-77 21:44:58    EDIT BY HARTLEY
;STUFF FOR TOPS20 EDIT AND INTERRUPCHARS
;<HARTLEY>20GC.MAC;2     7-Feb-77 00:02:05    EDIT BY HARTLEY
;<NEWLISP>GC.MAC;4    18-Nov-76 22:17:37    EDIT BY HARTLEY
;ADD ENTRY TO CLRPG
;<HARTLEY>GC.MAC;1    12-Oct-76 02:39:10    EDIT BY HARTLEY
; FIX SHUFFLER TO LET GO OF RESERVED PAGES AT PROPER TIME
;<HARTLEY>GC.MAC;34    29-Jun-76 02:39:16    EDIT BY HARTLEY
;FIXED SWPSTK FOR MULTI SEGMENTS
;<HARTLEY>GC.MAC;33    21-May-76 02:36:07    EDIT BY HARTLEY
;<NEWLISP>GC.MAC;4    12-May-76 18:27:13    EDIT BY HARTLEY
;FIX TO REHASH SYSTEM HASH ARRAYS IF THEY HAVE BEEN WRITTEN
;<HARTLEY>GC.MAC;28     7-May-76 01:59:59    EDIT BY HARTLEY
;SET TO BREAK WHEN FEWER THAN MINREM WDS LEFT - ANY TYPE
;<META>GC.MAC;16    25-Mar-76 03:08:46    EDIT BY HARTLEY
;FIX INTON  OMISSION WHEN NO SPACE LEFT
;<HARTLEY>GC.MAC;1    20-FEB-76 23:09:52    EDIT BY HARTLEY
;CHANGE POSITION OF MARK BIT IN STACK FRAMES - SO FLFR WORKS
;<META>GC.MAC;11    18-FEB-76 01:50:00    EDIT BY HARTLEY
;FIX PROBLEM WHERIN AC'S GET CLOBBERED BY BRREST
;<META>GC.MAC;10     6-FEB-76 03:14:45    EDIT BY HARTLEY
;FIX MAKESYS STACK UNWIND PROBLEM.
;<META>GC.MAC;9     5-FEB-76 16:23:22    EDIT BY LEWIS
; fixed typo in alice's last edit
;<HARTLEY>GC.MAC;23    13-JAN-76 23:28:25    EDIT BY HARTLEY
; FIX MAKESYS TO CLEAR VC FREE LIST, ETC.
;<HARTLEY>GC.MAC;23    13-JAN-76 03:28:55    EDIT BY HARTLEY
;FIX BUG IN SHARED VALUE CELL SCAN
;<META>GC.MAC;5    21-DEC-75 09:12:03    EDIT BY LEWIS
; When updating BTT entries, do the ones for value cells too!!!
;<HARTLEY>NGC.MAC;2    29-SEP-75 18:43:04    EDIT BY HARTLEY
;<HARTLEY>NEWGC.MAC;7    27-SEP-75 02:47:44    EDIT BY HARTLEY
;<HARTLEY>NEWGC.MAC;5    24-SEP-75 18:41:49    EDIT BY HARTLEY
;ADD STUFF FOR CREATING VALUE CELLS
;<HARTLEY>GC.MAC;12    28-AUG-75 16:57:10    EDIT BY HARTLEY
; FOR IMMEDIATE TYPE NUMS, NEW CONS
;<HARTLEY>GC.MAC;6    26-AUG-75 03:25:48    EDIT BY HARTLEY
;<LEWIS>GC.MAC;4    30-JUN-75 16:24:17    EDIT BY LEWIS
; ADD INSTANT INTERRUPT VARIABLES
;<DLISP>GC.MAC;27     4-JUN-75 15:52:20    EDIT BY HARTLEY
;CHANGE ECP CHECK TO STKEND CHECK
;<DLISP>GC.MAC;26    29-MAY-75 01:27:27    EDIT BY HARTLEY
;<DLISP>GC.MAC;25    29-MAY-75 00:54:22    EDIT BY HARTLEY
; FIX CLOBBERING OF LEFT HALF PREX
;<DLISP>GC.MAC;23    27-MAY-75 03:31:50    EDIT BY HARTLEY
;<DLISP>GC.MAC;21    27-MAY-75 02:10:07    EDIT BY HARTLEY
;<DLISP>GC.MAC;19    26-MAY-75 19:14:23    EDIT BY HARTLEY
;FIX VERY SLOW STACK CHASE - AND FINAL STACK SWEEP
;<DLISP>GC.MAC;18    26-MAY-75 18:41:13    EDIT BY HARTLEY
;<DLISP>GC.MAC;15    15-MAY-75 22:02:37    EDIT BY HARTLEY
;<DLISP>GC.MAC;14    15-MAY-75 18:52:51    EDIT BY HARTLEY
;<DLISP>GC.MAC;13    14-MAY-75 21:06:56    EDIT BY LEWIS
; MAKE GC LOOK AT BOT HALVS OF EVATAB FOR PRINTING USER DATA TYPES
;<DLISP>GC.MAC;12     8-MAY-75 00:31:32    EDIT BY HARTLEY
;<DLISP>GC.MAC;11     8-MAY-75 00:05:16    EDIT BY HARTLEY
;<DLISP>GC.MAC;9     1-MAY-75 02:47:26    EDIT BY HARTLEY
; FIX THE LONG STRING BUG
;<DLISP>GC.MAC;8     5-APR-75 15:56:20    EDIT BY HARTLEY
; FIX BAD RECOVERY FROM STACK OVERFLOW.
;<NEWLISP>GC.MAC;2    25-NOV-74 04:35:25    EDIT BY HARTLEY
; FIX MAKESYS
;<DLISP>GC.MAC;6    24-OCT-74 23:28:24    EDIT BY HARTLEY
;<DLISP>GC.MAC;5    17-OCT-74 23:55:46    EDIT BY HARTLEY
;<DLISP>ZIT.;1    17-OCT-74 04:49:53    EDIT BY HARTLEY
; FIX SHUFFLER'S USAGE OF STACK
;<DLISP>GC.MAC;2     8-SEP-74 20:23:40    EDIT BY LEWIS
; FIX FIX TO MOVPGJ AND FIX UCKMRK TO SAVE AND RESTORE AC3
;<HARTLEY>NNGC.MAC;46    27-AUG-74 22:29:04    EDIT BY HARTLEY
;<HARTLEY>NNGC.MAC;42    22-AUG-74 01:46:22    EDIT BY HARTLEY
;<HARTLEY>NNGC.MAC;41    18-AUG-74 04:41:17    EDIT BY HARTLEY
;<FLIP>GC.MAC;10     2-AUG-74 01:21:56    EDIT BY LEWIS
; FIXED PAGE MOVER SO OLD PLACE IS NOT DELETED TILL AFTER THE MOVE
;<FLIP>GC.MAC;9    21-JUL-74 18:35:48    EDIT BY LEWIS
; MORE MERGE
;<FLIP>GC.MAC;2     6-JUL-74 19:39:41    EDIT BY LEWIS
; FIXED SFRKB
;<LEWIS>GC.MAC;11    27-JUN-74 05:00:36    EDIT BY LEWIS
;<LEWIS>GC.MAC;8    25-JUN-74 02:11:42    EDIT BY LEWIS
;<LEWIS>GC.MAC;6    20-JUN-74 21:37:44    EDIT BY LEWIS
; MERGED SPAG. CHANGES
;<LEWIS>GC.MAC;1     6-JUN-74 04:18:23    EDIT BY LEWIS
; ADDED STRING INPUT
;<GOODWIN>GC.MAC;29    30-APR-74 05:04:30	EDIT BY GOODWIN
; - INSTALL SWAPPER.
;<LEWIS>GC.MAC;1     9-APR-74 23:34:09	EDIT BY LEWIS
;<HARTLEY>GC.MAC;7    25-FEB-74 19:21:43	EDIT BY HARTLEY
;<HARTLEY>GC.MAC;5    19-FEB-74 20:47:22	EDIT BY HARTLEY
;<FLIP>GC.MAC;1    17-FEB-74 02:59:21	EDIT BY LEWIS


;20 AUG 74, 1742:
; GARBAGE COLLECTOR


U BTT,NPM	; BIT	TABLE TABLE
		; CONTAINS PTR TO BIT TABLE FOR EACH PAGE THAT NEEDS ONE

GP=CP		; USE	CP FOR	GC PDP
SYSBIT==100		;BIT IN LEFT TYPTAB ENTRY DENOTING SHARED DATA
PVTBIT==200		;TYPTAB BIT FOR ONCE SHARED, BECOME PRIVATE
FIXBIT==400		;TYPTAB BIT FOR NOT MOVABLE
RPGBIT==1		;BIT IN LEFT TYPTAB FOR PAGE MOVING TO
CHGMSK==777000		;MASK FOR PG DEST IN LEFT TYPTAB

MINREM==30		;MINIMUM FREE STORAGE TO CONTINUE - ELSE ERROR

U GCTYP,4		; TYPE BEING COLLECTED, + 3 MESSAGES
U BGNPAG	;FIRST DATA PAGE:BGNCOR/NPS;LEFT IS -# PAGES
U NFRECH	;NUMBER OF FREE STRING CHARACTERS
U IGP		;INITIAL GP
U GCAC2,14	;SAVED AC'S 2-15
U XMINAR	;TEMP LOC OF REAL MINARR
U CMPTYP	;TYPE COMPACTING, 0 IF NONE
U CMPFN		;FN TO CHANGE POINTER FOR COMPACTING TYPE
U INIFN		;FN TO INITIALIZE NEW PAGES FOR COMPACTING TYPE
U FRSTNP	;FIRST NEW PAGE OF A GROUP
U NNP		;NUMBEROF NEW PAGES IN GROUP
U SYSCHK	;FLAG NON ZERO IF CONSISTENCY OF PAGE ACCESS BITS
		;... NEEDS CHECKING
U VCPGS		;-#VALUE CELL PGS,,LOWEST PAGE
		;... ALLOCATED FROM TOP OF CORE
HIPG==776		;HIGHEST PAGE USABLE BY VALUE CELLS

; Special MAXC opcodes for bit table stuff
IFDEF MAXC,<
	DEFINE BCHASE <CHASE 1,CHASX>	; Chase pointer
	DEFINE JCHASE <CHASE 1,PCHASX
			POPJ GP,>
	DEFINE SBTLU(A)		; Return if pointer A already in bit table
<	BTLU 1,0		; Otherwise mark the bit table
	POPJ GP,
	IORM 1,0(A)
>

	DEFINE JBTLU(A,B)
<	BTLU 1,0
	JUMPA B
	IORM 1,0(A)
>
>

IFNDEF MAXC,<
	DEFINE BCHASE <PUSHJ GP,CHAS>
	DEFINE JCHASE <JRST CHAS>
	DEFINE SBTLU(A)
<	PUSHJ GP,BTLU
	TDOE 1,0(A)
	POPJ GP,
	MOVEM 1,0(A)
>

	DEFINE JBTLU(A,B)
<	PUSHJ GP,BTLU
	TDOE 1,0(A)
	JRST B
	MOVEM 1,0(A)
>
>
;DATA TYPE TABLES ETC.

MTYPN==77		;MAX TYPE NUMBER
NTYPN==100		;NUMBER OF TYPE NUMBERS
MSYST==36		;MAX. DATA TYPE USED BY SYSTEM (STRINGS)

U TYPBLK,NTYPN		;TABLE OF POINTERS TO TYPE INFO FOR EACH TYPE
			;...LATER MAY ALSO CONTAIN TYPE NAME

;RELATIVE LOCATIONS OF INFO IN TABLES

TSIZ==0			;ENTRY SIZE IN LEFT
TBITS==0		;DESCRIPTION BITS IN RIGHT
TCHAS==1		;CALL TO CHASE ROUTINE
TUDE==2			;ROUTINE TO UPDATE POINTERS IN FIXED LENGTH
			;...ENTRY
TSWP==2			;ROUTINE TO UPDATE POINTERS IN WHOLE REGION
			;...OF CONTIGIOUS TYPE
TINI==3			;ROUTINE TO INITIALIZE A PAGE
TCKM==TINI+1		;ROUTINE TO CHECK IF MARKED
TMIN==TCKM+1		;MINFS FOR TYPE
TNPG==TMIN+1		;INITIAL NNUMBER OF PAGES ALLOCATED
TFRE==TNPG+1		;FREE POINTER
TNFR==TFRE+1		;NUMBER WORDS(OR ENTRIES) FREE
TNWD==TNFR+1		;NUMBER WORDS(OR ENTRIES ) USED
 NTWN==TNWD+1		;# WORDS OF INFO FOR NORMAL TYPES
TPLN==TNWD+1		;ROUTINE TO PLAN FOR CONTIGUOUS TYPE
TCHG==TPLN+1		;ROUTINE TO CHANGE POINTER TO CONT. TYPE
TMOV==TCHG+1		;ROUTINE TO COMPACT DATA
TBGN==TMOV+1		;ADDR. OF BEGINNING OG REGION
TEND==TBGN+1		;ADDR. OF END OF REGION
TNEXT==TEND+1		;POINTER TO NEXT INFO BLOCK, 0 IF NONE
 NTWC==TNEXT+1		;# WORD OF INFO FOR VAR. LENGTH TYPES

BGEN==1			; BIT IN BITS FOR GENERAL TYPE (E.G. ARRAY)
BCONT==2		; BIT IN BITS FOR CONTIGUOUS TYPE

;MORE DATA TYPE TABLES

U USEBLK,<<MTYPN-MSYST-1>*NTWN>	;HOLDS TYPBLKS FOR USER DATA TYPES
U TYPSIZ,NTYPN			;HOLDS SIZE INFO FOR USER DATA TYPES
U EVATAB,NTYPN	;TABLE OF FNS TO BE CALLED TO EVAL/PRINT EACH TYPE.
		;-1 IF TYPE CANNOT BE CHANGED.
U TYPNAM,NTYPN		; HOLDS TYPE NAMES
IFDEF OOP,<
U OBJTNS,NTYPN	;TABLE OF TYPES THAT SAYS IF THEY ARE APPLYABLE OBJECTS
>

;ACCESS MACROS

	DEFINE GTB (RA,TA)
<	BB=0
	IFG TA,<
	IFL TA-20,<
	BB=-1
	HRRZ RA,TYPBLK(TA)>>

	IFE BB,<
	HRRZ RA,TA
	HRRZ RA,TYPBLK(RA)>>

	DEFINE MINFS (RA, TA)
	<GTB RA,TA
	HRRZ RA,TMIN(RA)>

	DEFINE NFRE (RA,TA)
	<GTB RA,TA
	HRRZ RA,TNFR(RA)>


;TABLES USED TO INITIALIZE TYPBLK INFO

NI1==7		;# OF PARAMS IN INITIALIZATION TABLES FOR NORMAL TYPES
NI2==3		;ADDITIONAL # OF PARAMS FOR CONTIGUOUS TYPES

TARR:	BCONT+BGEN
	PUSHJ GP,CHASAR
	PUSHJ GP,SWPARR
	PUSHJ GP,CLRPG
	PUSHJ GP,CKARR
	2000			;MINFS
	NAR
	PUSHJ GP,PLANAR
	PUSHJ GP,CHGARR
	PUSHJ GP,MOVARR

TLIST:	XWD 1,0
	PUSHJ GP,CHASLS
	PUSHJ GP,UDLIST
	JFCL
	PUSHJ GP,CKBIT
	2000
	NLW

TFIX:	XWD 1,0
	PUSHJ GP,CHASFX
	JFCL R
	JFCL
	PUSHJ GP,CKBIT
	1000
	NNM

TFLT:	XWD 1,0
	PUSHJ GP,CHASFL
	JFCL R
	JFCL
	PUSHJ GP,CKBIT
	1000
	NFN

TATM:	XWD 3,0
	PUSHJ GP,CHASAT
	PUSHJ GP,UDATM
	JFCL
	PUSHJ GP,CKAT
	2000
	NAT

TPNAM:	BCONT
	PUSHJ GP,MARKPN
	JFCL R
	PUSHJ GP,CLRPG
	PUSHJ GP,CKPN
	1000
	NPN
	PUSHJ GP,PLANPN
	PUSHJ GP,CHGPN
	PUSHJ GP,MOVPN

TSTR:	BCONT
	PUSHJ GP,MARKST
	JFCL R
	PUSHJ GP,CLRPG
	PUSHJ GP,CKPN
	1000
	NST
	PUSHJ GP,PLNSTR
	PUSHJ GP,CHGPN
	PUSHJ GP,MOVSTR

TSTPT:	XWD 1,0
	PUSHJ GP,CHASSP
	PUSHJ GP,UDSTPT
	JFCL
	PUSHJ GP,CKBIT
	1000
	NSP

THANDL:	XWD 1,0
	PUSHJ CP,CHASHD		;CHASE
	JFCL R		;UPDATE HANDLE
	JFCL
	PUSHJ GP,CKBIT
	1000
	NHDL
	HDLCHS==000400		;BIT IN LEFT HANDLE MEANING CHAS DONE

TSTKP:	XWD 1,0
	PUSHJ CP,CHASEP
	JFCL R		;NO UPDATE(YET)??
	JFCL
	PUSHJ CP,CKBIT
	1000			;MINFS
	NSTKP			;# INIT PGS

TVCELL:	XWD 1,0
	PUSHJ CP,CHASVC
	PUSHJ CP,UDRITE
	JFCL
	PUSHJ CP,CKBIT
	1000
	NVC

U TUSER,NI1			;WANT FOLLOWING TO BE REMOTE
				;... CAUSE THE SIZE MUST BE SET
FOO1:
	LOC	TUSER
	XWD	0,0
	PUSHJ	GP,UCHAS
	PUSHJ	GP,UDUSER
	JFCL
	PUSHJ	GP,UCKMRK
	1000
	1
	RELOC	FOO1

DEFINE IARRAY
	<TI=TARR
	ILOC=ARRBLK
	U ARRBLK,NTWC
	ENDAR=ARRBLK+TEND
	FREEAR=ARRBLK+TFRE
	MINARR=ARRBLK+TMIN
	NARRW=ARRBLK+TNWD
>

DEFINE ILIST
	<TI=TLIST
	ILOC=LSTBLK
	U LSTBLK,NTWN
	FRECNT=LSTBLK+TNFR
	MINLW=LSTBLK+TMIN
	NLISTW=LSTBLK+TNWD
	FRELST=LSTBLK+TFRE
>
DEFINE IFIX
	<TI=TFIX
	ILOC=FIXBLK
	U FIXBLK,NTWN
	FREENM=FIXBLK+TFRE
>
DEFINE IFLOAT
	<TI=TFLT
	ILOC=FLTBLK
	U FLTBLK,NTWN
	FREEFL=FLTBLK+TFRE
>
DEFINE IATOM
	<TI=TATM
	ILOC=ATMBLK
	U ATMBLK,NTWN
	FREEAT=ATMBLK+TFRE
	NATM=ATMBLK+TNWD
>

DEFINE IHANDL
	<TI=THANDL
	ILOC=HDLBLK
	U HDLBLK,NTWN
	FREHDL=HDLBLK+TFRE
	NHDLW=HDLBLK+TNWD
>

DEFINE ISTKP
	<TI=TSTKP
	ILOC=STKBLK
	U STKBLK,NTWN
	FRESTK=STKBLK+TFRE
	NSTKPW=STKBLK+TNWD
>

DEFINE IPNAM
	<TI=TPNAM
	ILOC=PNBLK
	U PNBLK,NTWC
	BGNPN=PNBLK+TBGN
	ENDPN=PNBLK+TEND
	FREEPN=PNBLK+TFRE
>
DEFINE ISTRNG
	<TI=TSTR
	ILOC=STRBLK
	U STRBLK,NTWC
	BGNSTR=STRBLK+TBGN
	ENDSTR=STRBLK+TEND
	FREESTR=STRBLK+TFRE
>
DEFINE ISTPT
	<TI=TSTPT
	ILOC=STPBLK
	U STPBLK,NTWN
	FREESP=STPBLK+TFRE
	NSTPTW=STPBLK+TNWD
>

DEFINE IVCELL
	<TI=TVCELL
	ILOC=VCBLK
	U VCBLK,NTWN
	FREEVC=VCBLK+TFRE
	NVCW=VCBLK+TNWD
>


DEFINE TYPSET (TYP)
<	I'TYP
	MOVEI 2,TYP'T
	MOVEI 7,ILOC
	MOVEM 7,TYPBLK(2)
	MOVEI 10,TI
	PUSHJ GP,GCTBS
>
;TYPBLK SETUP ROUTINE
;ENTER 2 TYPE, 6 # PAGES, 7 LOC. TYPBLK, 10 LOC. OF INIT. VALUES

GCTBS:	MOVEI 5,0(7)
	HRLI 5,0(10)
	BLT 5,NI1-1(7)		;MOVE FIRST STUFF INTO BLOCK
	SETZM TFRE(7)		;CLEAR SOME MORE
	SETZM TNFR(7)
	SETZM TNWD(7)
	HRRZ 6,TNPG(7)
	MOVE 1,TBITS(7)
	TRNN 1,BCONT
	JRST GETFPG		;NORMAL TYPE, GET PAGES
	MOVEI 5,TPLN(7)
	HRLI 5,NI1(10)
	BLT 5,TPLN+NI2-1(7)
	SETZM TNEXT(7)
GCTBC:	MOVEI 10,0(2)		;GET PAGES FOR CONTIGUOUS TYPE
	MOVEI 5,0(6)		;# PAGES
	PUSHJ GP,MTPGSX		;FIND CONTIG. PAGES
	 JRST GCTBE		;NOT ENUF
	MOVNI 6,0(6)		;PAGE IS IN 4, # PAGES IN 6
	HRLI 4,0(6)
	MOVEI 3,0(4)
	MOVEM 10,TYPTAB(4)	;SET TYPTAB FOR PAGES
	AOBJN 4,.-1
	LSH 4,LPS
	MOVEM 4,TEND(7)
	LSH 3,LPS
	MOVEM 3,TBGN(7)
	MOVEM 3,TFRE(7)
	POPJ GP,

GCTBE:	TMSG GCEM3
	HALTF

GCEM3:	SIXBIT @STORAGE FULL/@


STPTGC:	MOVEM 1,GCSTPT		;SAVE STRINGPOINTER
	MOVEI 1,STPTT
	CALL GC1
STGCA:	MOVE 1,GCSTPT
GCRET:	RET

STRGC:	MOVEM 1,GCSTPT
	MOVEI 1,STRNGT
	CALL GC1
	MOVEI 1,440700
	HRLM 1,FREEST		;STEP TO FIRST BYTE IN FREE
	HRRZ 1,FREEST
	MOVNI 1,0(1)
	ADD 1,ENDSTR
	IMULI 1,5
	MOVEM 1,NFRECH		;NO. FREE CHARACTERS
	CALL DOINT1		;NOW SEE IF INTERRUPT REQUESTED
	JRST STGCA
U GCTIMT	;'CAUSE OF REMOVAL OF NP
IFDEF MAXC,<U GCINST>
U GCSTPT
U GCOCF
U GCOPP
U GCOCP
U SWPFLG


CONSGC:	MOVEI 1,LISTT
	JRST GC1

INTGC:	MOVEI 1,FIXT
	JRST GC1

ARRGC:	EXCH 1,MINARR		;1 HAS NUMBER WORDS NEEDED
	MOVEM 1,XMINAR		;SAVE OLD MINARR
	CAML 1,MINARR
	MOVEM 1,MINARR		;GET MAX OF ARG AND ORIG. MINARR
	MOVEI 1,ARRAYT
	JRST GC1

ATOMGC:	MOVEI 1,ATOMT
GC1:	MOVEM 1,GCTYP
	JSYS	SWPFIX		;MAKE SURE SWAPPING IS OK
	MOVE 1,[XWD 2,GCAC2]
	BLT 1,GCAC2+13		;SAVE AC'S 2-15
	GETJRT			;GET CURRENT RUNTIME
	MOVEM	1,GCTIMT	;INSTEAD OF USING NP
IFDEF MAXC,<
	RICTR 1,7	; READ INSTRUCTION COUNTER
	EXCH 1,GCINST
	SUBM 1,GCINST
>
	TLZ F,CNSFLG		; DON'T GCTRAP
;------------------
;print initial GC message
; "gc:" type "cr" nnnnn "free words" nnnn "pages left"   CR
;  ^1         ^2            ^3	  ^4 	^5	 ^6

	PUSH GP,PREX
	SKIPN 1,GCMES1
	 JRST GC1M2
; special feature for DLISP
	STN 1,ATOM
	 JRST [ HRRZ 3,1(1)		; FGETD
		STE 3,ARRAY		; ARRAY?
		 JRST .+1		; NO
		MOVE TP,0(3)
		CAME TP,[JSP 7,ENTER0]	; function of no args?
		 JRST .+1		; no
		PUSHJ CP,3(3)		; call with PUSHJ
		JRST GC1XT]
; end special feature for DLISP

	MOVE 2,KT
	CALL PRIN1
; print type name/number
	MOVE 1,GCTYP
	HRRZ 1,TYPNAM(1)
	JUMPE 1,GC1M1A
	MOVE 2,KT
	CALL PRIN1
	JRST GC1M2

GC1M1A:	MOVE 1,GCTYP
	CALL PNO10

GC1M2:	SKIPN 1,GCMES2
	 JRST GC1XT
	MOVE 2,KT
	CALL PRIN1

GC1XT:	POP GP,PREX

; ------------------
GC1A:	INTOFF			;SHUT OFF TERMINAL INTERRUPTS
	TRO F,GCFLG		;NOTE GC NOW IN PROGRESS
	SETZM FORKH		;NOTE NO FORK CREATED YET
	SETZM SWPFLG		;NOTE NOT SWEEPING YET (FOR SCNSAR)
	MOVE 1,CF
	MOVEM 1,GCOCF		;SAVE CF
	SETCPO CP,1		;CLOSE-OUT CF FOR CONVENIENCE
	HRLM PP,0(CP)		;PPO
	MOVEM CP,CF		;FLG THAT NOT IN REAL FRAME
	MOVEM CP,GCOCP		;USED TO CHECK IF CP MOVES
	MOVEM PP,OPP		;SAVE PP TOO FOR STK OVERFLOW
	MOVEM PP,GCOPP		;THIS ONE IS UNCHANGED - 
GC11:	TLZ F,GCCF+GCMF+GCPF	;CLEAR GC FLAGS
	SETZM CMPTYP
	MOVE 1,BGNCOR	;GATHER INFO ABOUT PAGE ASSIGNMENTS
	MOVE 2,ENDCOR
	LSHC 1,-LPS
	MOVEM 1,NEWCNS
	HRLI 1,0(1)
	MOVSI 2,0(2)
	SUB 1,2
	MOVEM 1,BGNPAG
	MOVSI 7,-NTYPN
GC12:	HRRZ 6,TYPBLK(7)		;CLEAR COUNTS OF THINGS IN USE
	JUMPE 6,GC13
	PUSH PP,TNWD(6)		;SAVE OLD COUNT OF WORDS IN USE
	SETZM TNWD(6)
GC13:	AOBJN 7,GC12


PPSCAN:	HRRZ 1,GCOCF		;CHASE CURRENT FRAME
	PUSHJ GP,CHSSTK
	JRST INTSCN

INTSS:	HRRZ 1,0(2)
	PUSH GP,2
	BCHASE
	POP GP,2
	AOBJN 2,INTSS
	POPJ GP,

INTSCN:	MOVE 2,UCTVRP
	PUSHJ GP,INTSS			;SCAN INTERRRUPT VARS
	MOVE 2,[XWD -NKCELL,KNIL]
	PUSHJ GP,INTSS	;SCAN INTERNAL TABLE
	MOVE 2,[XWD -NFILES-1,FILEA]	;ONE EXTRA FOR STRING INPUT
	PUSHJ GP,INTSS
	MOVE 2,[XWD -NTYPN,OBJTNS]
	PUSHJ GP,INTSS			;SCAN AUX OBJ FNS
	MOVE 2,[XWD -2*NTYPN,EVATAB]	;SCAN EVAL/PRINT TABLE + TYPENAME
EVTSCN:	HRRZ 1,0(2)
	PUSH GP,2
	BCHASE
	MOVE 2,0(GP)
	HLRZ 1,(2)
	BCHASE
	POP GP,2
	AOBJN 2,EVTSCN


ATSCAN:	HRRZ 7,NHP   ;SCAN ATOMS, USING HASH TABLE
ATS4:	HRRZ 5,ATOMHT(7)	;PAGE
	MOVEI 6,MPS
	HRLI 5,6
ATS1:	HRRZ 1,@5
	JUMPE 1,ATS3	;ENTRY NOT USED
	HRRZI 1,-2(1)	;HASH ENTRY -2 IS THE ATOM
	HLRZ 4,0(1)		;CHECK CDR
	CAME 4,KNIL
	JRST ATS2	; CDR USED
	HRRZ 4,1(1)	;CHECK FN
	CAME 4,KNIL
	JRST ATS2		;FN USED
	GTVALC 4,1		;DO IT HAVE A VALUE CELL
	JUMPE 4,ATS3
	CAMN 4,KNIL
	JRST ATS3		;NOPE
	HRRZ 4,0(4)		;HAS VCELL - CHECK CONTENTS
	CAME 4,KNOB
ATS2:	BCHASE			;SOMETHING USED, CHASE
ATS3:	SOJGE 6,ATS1
	SOJG 7,ATS4

SHRSCN:	PUSHJ GP,SHRPG		;SCAN AND CHASE FROM SHARED PAGES
	 PUSHJ GP,SHRSAR	;ARRAY PAGE
	 PUSHJ GP,SHRSL		;LIST PAGE
	 PUSHJ GP,SHRSAT	;ATOM PAGE
	 PUSHJ GP,SHRSSP	;STRING POINTER PAGE
	 PUSHJ GP,SHRSTP		;STACK PTR PAGE
	 PUSHJ GP,SHRSVC		;VALUE CELL PAGE
	 PUSHJ GP,SHRUCH	;USER DATA TYPE PAGE
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SHRSHC		; CHASE PTRS ON SHARED/PVT SHADOW PAGES

	MOVE 1,GCSTPT
	PUSHJ GP,MARKST		;MARK STRING ABUILDING IF ANY
	TLZ F,GCF		;DO SONG AND DANCE FOR HASH ARRAYS
HASHS1:	PUSHJ GP,SCNHA
	 PUSHJ GP,HSHCH		;XCT'ED FOR EACH ELEMENT OF ARRAY
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPUHD		;FINISH CHASING SHADOW ARRAYS
	TLZE F,GCF		;ANYTHING NEW CHASED?
	JRST HASHS1
	PUSHJ GP,SCNHA
	 PUSHJ GP,HSHREC		;RECLAIM UNUSED ENTRIES
	CALL HDLPG
	 CALL HDLCLR		;CLEAR CHASED BITS FROM HANDLES
	JRST GCS


;FIND BEGINNING OF ARRAY, ARRAY PO	NTER IN 1

FBA:	PUSH GP,3
	HRRZ 3,TYPBLK+ARRAYT
FBA3:	CAML 1,TBGN(3)
	CAML 1,TFRE(3)
	JRST FBAB		;NO SUCH ARRAY THIS SPACE, TRY NEXT
	MOVEI 2,0(1)
	LSH 2,-LPS
FBA1:	HRRZ 3,BTT(2)
	CAIN 3,0
	SOJA 2,FBA1		;NO ENTRY FOR THIS PAGE, BACK UP
	CAIGE 1,0(3)
	SOJA 2,FBA1		;ENTRY THIS PAGE TOO BIG, BACK UP
FBA2:	CAIN 1,0(3)
	JRST FBAX
	MOVEI 2,0(3)
	ADD 3,0(3)		;BEG OF NEXT ARRAY
	CAIL 2,0(3)
	JRST FBABAD		;LENGTH LESS OR EQ 0
	CAIL 1,0(3)
	JRST FBA2
	MOVEI 1,0(2)
FBAX:	POP GP,3
	POPJ GP,

FBAB:	HRRZ 3,TNEXT(3)
	JUMPG 3,FBA3
FBABAD:	MOVEI 1,0		;NO MORE ARRAY SPACES, RETURN 0
	JRST FBAX

UFBA:	CALL FBA		;USER ENTRY
	JUMPN 1,R
	MOVE 1,KNIL		;RETURN NIL IF NO SUCH
	RET

;REHASH HASH ARRAY - AFTER POINTERS HAVE BEEN UPDATED
;ARRAY IN 1

REHSHG:	MOVEI 6,0(1)
	HRLI 1,200000
	SKIPE FORKH
	JRST REHG3
	CFORK
	JRST GCERR
	MOVEM 1,FORKH
REHG3:	HRRZ 4,PPTRP		;PAGES 0 TO PPTRP+1 SAME BOTH FORKS
	ADDI 4,1
	MOVSI 1,400000
	HRLZ 2,FORKH
	MOVSI 3,160000		;ACCESS RWE
REHG1:	PMAP
	ADDI 2,1
	CAILE 4,1(1)
	AOJA 1,REHG1
	MOVEI 1,0(6)		;PAGES CONTAINING ARRAY
	LSH 1,-LPS		;MAP TO ATOMHT ON UP
	HRLI 1,400000
	HRRZ 4,0(6)
	ADDI 4,0(6)
	LSH 4,-LPS		;PAGE ON WHICH ARRAY ENDS - THIS FORK
REHG2:	PMAP
	ADDI 2,1
	CAIL 4,1(1)
	AOJA 1,REHG2
	MOVEI 3,HIPG
	SUB 3,PPTRP
	LSH 3,LPS-1		;ADDRESS NEW VERSION, OTHER FORK
	HRRZ 2,PPTRP
	LSH 2,LPS
	MOVEI 4,0(6)
	ANDI 4,MPS
	ADDI 4,NPS(2)		;ADDR OLD VERSION - OTHER FORK
	MOVE 1,FORKH
	SETZ 2,
	SFACS
	MOVEI 2,REHSHF
	SFORK
	WFORK
	RET

U FORKH

REHSHF:	HRRZ 2,0(4)
	MOVEM 2,0(3)
	MOVE 2,1(4)
	MOVEM 2,1(3)
	PUSH CP,4
	CALL REHSHS
	POP CP,4
	HRLI 4,0(1)		;MOVE NEW TO OLD
	HRRZ 1,0(4)
	ADDI 1,-1(4)
	BLT 4,0(1)
	HALTF


;USER REHASH - 1 OLD ARRAY, 2 NEW ARRAY

UREHSH:	STN 1,LIST
	CARA 1,1
	STE 1,ARRAY
	 ERROR1 34,RESET
	STN 2,LIST
	CARA 2,2
	STE 2,ARRAY
	 JRST UREH2E
	MOVEI 3,0(2)
	MOVEI 4,0(1)
REHSHS:	PUSH PP,3		;REHASH SUBROUTINE - 3 NEW ARRAY, 4 OLD
	MOVEI 1,0(3)		;INIT NEW COUNT
	CALL HSHLMT
	MOVE 3,0(PP)	; since HSHLMT smashes 3
	MOVEI 2,3(3)
	HRLI 2,2(3)		;CLEAR NEW ARRAY
	SETZM 2(3)
	HRRZ 1,0(3)
	ADDI 1,-1(3)
	BLT 2,0(1)
	HRRZ 3,0(4)
	MOVNI 3,0(3)
	HRLI 4,0(3)
	ADD 4,BHC+2
REHS2:	HLRZ 2,0(4)
	CAIG 2,1		;USED?
	JRST REHS1
	HRRZ 3,0(4)		;YES - REHASH IT
	HRRZ 1,0(PP)
	PUSH PP,4
	CALL HSHENT
	POP PP,4
REHS1:	AOBJN 4,REHS2
	POP PP,1		;RETURRN NEW ARRAY
	RET

UREH2E:	MOVE 1,2
	ERROR1 34,RESET

;MAKE SHARED SYSTEM
;REALLY SHOULD INCLUDE GC AND FLUSH UNUSED PAGES

NPPG==<GCIE+777>B44		;NUMBER PROGRAM PAGES

IFE TEN50,<
MKSYS:	MOVE 3,FREETB
	ADDI 3,3*NTWC	;ROOM FOR 3 MORE TYPBLKS?
	CAMLE 3,ENDTB
	JRST MKSYSQ		;NO GET A PAGE
	CALL IOFN
	MOVEM 2,SYSJFN		;SAVE FILE NAME
	MOVSI 1,400001
	GTJFN
	JRST FALSE
	PUSH CP,1		;SAAVE JFN
	MOVE 2,[XWD 440000,100000]	;36BIT WRITE
	OPENF
	 JRST	[POP CP,1
		 RLJFN
		  JFCL
		 JRST FALSE]
	MOVEI 1,400000		;THIS FORK
	DIR			;DISABLE INTERRUPTS
			;THEY GET TURNED ON AGAIN WHEN THE MKSYS RUNS
	GTAD
	MOVEM 1,SYSDAT		;REMEMBER WHEN SYSTEM CREATED
	MOVE 1,KL20F
	MOVEM 1,SYSSYS		;AND WHAT OPER. SYSTEM CREATED ON
	HLRE 4,BGNPAG
	MOVNM 4,SYSPGS		;NNUMBER OF SYSTEM PAGES
	MOVE 2,[XWD -NPPG,1]
	CALL MKSYS1		;SET SYSBITS
	MOVEI 5,MTYPN
MKSY12:	HRRZ 4,TYPBLK(5)
	JUMPE 4,MKSY13
	HRRZ 3,TBITS(4)
	TRNE 3,BCONT
	CALL MKSYSR		;RELEASE UNUSED SPACE
MKSY13:	SOJG 5,MKSY12
	MOVE 2,BGNPAG
	CALL MKSYS1
	MOVE 2,VCPGS		;DO VALUE CELL PGS TOO
	CALL MKSYS1
	JRST MKSYS6

MKSYSR:	MOVE 1,TFRE(4)		;RELEASE UNUSE SPACE - CONTIG. TYPES
	ADDI 1,MPS
	ANDI 1,-NPS
	MOVEI 3,0(1)
	EXCH 3,TEND(4)
	LSH 1,-LPS
MKSY11:	CAMG 3,TEND(4)
	RET
	SETZM TYPTAB(1)
	SETZM BTT(1)
	SUBI 3,NPS
	AOJA 1,MKSY11

MKSYS1:	SKIPN 1,LSTCNS
	JRST MKSYSP
	HRRZ 3,FRELST		;GET PAGE FREE PTR BACK TO BTT
	HRLM 3,BTT(1)
	SETZM LSTCNS
	SETZM FRELST
MKSYSP:	HRRZ 1,TYPTAB(2)
	JUMPE 1,MKSYS2		;UNUSED
	CAIN 1,BTABT
	JRST MKSYS2
	CAIN 1,LISTT		;IF LIST -
	JRST MKSYSL
MKSYSN:	PUSH CP,2
	MOVEI 1,0(2)
	HRLI 1,400000
	RPACS			;READ PAGE ACCESSS
	HLLZ 3,2
	POP CP,2
	TLNN 3,010000
	JRST MKSYS2		;PAGE DOENST EXIST
	MOVE 1,TYPTAB(2)
	TLZ 1,PVTBIT
	TLO 1,SYSBIT
	MOVEM 1,TYPTAB(2)
MKSYS2:	AOBJN 2,MKSYSP
	POPJ CP,

MKSYSL:	HLRZ 5,BTT(2)
	SETZ 3,
	JUMPE 5,MKSYSO
	HRRZ 5,0(5)		;SEE IF PAGE EMPTY
	AOJA 3,.-2
MKSYSO:	CAIE 3,NPS
	JRST MKSYSM
	SETZM TYPTAB(2)		;YES - RELEASE PAGE
	SETZM BTT(2)
	JRST MKSYS2
MKSYSM:	HRRZS BTT(2)		;CLEAR LEFT BTT SO CONS WONT USE
	JRST MKSYSN

MKSYS6:	HRRZ 1,FREEAT		;CLEAR STUFF ON FREE LISTS
MKSYSC:	HRRZ 2,0(1)		;... SO WONT CAUSE TROUBLE LATER
	SETZM 0(1)
	SETZM 1(1)
	SETZM 2(1)
	SKIPE 1,2
	JRST MKSYSC
	MOVSI 2,-NTYPN		;LOOK FOR ALL TYPES IN USE
MKSYS5:	HRRZ 1,TYPBLK(2)
	JUMPE 1,MKSYS3
	MOVE 3,TBITS(1)
	TRNN 3,BCONT
	JRST MKSYSD
	MOVSI 3,0(1)		;CONNTIG. TYPE
	HRR 3,FREETB
	HRRZI 4,0(3)
	BLT 3,NTWC-1(4)		;MOVE TYPE INFO TO NEW SPACE
	MOVEM 4,TNEXT(1)	;NEXT PTS TO IT
	ADDI 4,NTWC
	MOVEM 4,FREETB
	SETZM TBGN(1)
	SETZM TEND(1)
	JRST MKSYS4
MKSYSD:	HLRZ 3,TSIZ(1)
	CAIE 3,1		;FOR ALL TYPES OF SIZE 1
	JRST MKSYS4
	HRRZ 3,TFRE(1)		;... CLEAR FREE LIST
	JUMPE 3,MKSYS4
MKSYDD:	HRRZ 4,0(3)
	SETZM 0(3)
	SKIPE 3,4
	JRST MKSYDD
MKSYS4:	SETZM TFRE(1)		;ALL TYPES SET FREEPTR
	SETZM TNFR(1)		;...AND COUNT 0
MKSYS3:	AOBJN 2,MKSYS5
	MOVE 1,HISHAD		;BUMP HISHAD (LIKE ENDCOR) TO
	TRZ 1,777		;PAGE BOUNDARY
	ADDI 1,1000
	EXCH 1,HISHAD		;MAYBE TRZ SHOULD BE TRZE?
	LSH 1,-LPS		;NOW SET SYSBITS FOR SHADOW PAGES
	HRRZI 2,FSYSBT
	CALL SFRKB
	SOJGE 1,.-2
	SETOM ZORGJQ		;FLAG TELLS SYSOUE IT'S A MAKESYS
	POP GP,SYSJFN		;IN PROGRESS AS AGAINST A SYSOUT
	JRST SYSOUE

MKSYSB:	MOVEI 1,LISP2		;RESET ENTRY VECTOR
	HRRM 1,EVEC
	MOVEI 1,RESETE
	HRRM 1,EVEC+1
	MOVSI 10,-NTYPN		;GO THRU ALL TYPES
MKSYS7:	HRRZ 7,TYPBLK(10)
	JUMPE 7,MKSYS8
	SETZM TNWD(7)
	MOVEI 2,0(10)		;TYPE
	HRRZ 6,TNPG(7)		;PAGES NEEDED
	MOVE 3,TBITS(7)
	TRNE 3,BCONT
	JRST MKSYS9
	PUSHJ CP,GETFPG
MKSYS8:	AOBJN 10,MKSYS7
	SETOM SYSCHK
	HRRZ 1,KT
	JRST GCIS

MKSYS9:	PUSH CP,10
	PUSHJ CP,GCTBC
	POP CP,10
	JRST MKSYS8

MKSYSA:	MOVEI CP,10
	CALL UNPROT
	SETK20			;SET TOPS 20 FLAG
	CALL SETINT		;DONE IN LISP2
	JSP 7,RESTK
	SETZM CF
	CALL MKSYSB
	CALL CLSALL
	CALL RESTCB		;Restore swapping buffer per tables.
				;Superfluous since we're gonna reset.
	MOVE 1,[XWD MYFRKS+1,SWFRKS]	;A LA SYSINR.
	BLT 1,SWFRKS+NSWFRKS-1
	JRST LISP2

;LIKE EVERYTHING ELSE THE TEMPS AREA IS NOW WRITE PROTECTED, BUT IT
;HAS TO BE WRITTEN EVEN BEFORE WE GET THE WTRP STUFF WIRED UP.
;HENCE WE EXPLICITLY UNPROTECT THESE PAGES NOW.

UNPROT:	HRRZI 5,BEGTMP		;VERY TRICKY! BEGIN NOT WITH A SWEEP
	HRRZI 1,(5)		;FROM PAGE 0 BECAUSE SETTING ITS
	CALL UNPRT1		;PVTBIT WOULD TRAP. SO BEGIN WITH PAGE
				;WHERE PVTBITS ARE KEPT. UNPRT1 MUST
				;THEREFORE DO SPACS BEFORE BITS RESET.
				;USES FACT THAT TYPTAB=BEGTMP!
	ADDI 5,1000
	CAIG 5,ENDTMP+NCP+NPP	;UNPROTECT STACKS TOO!
	 JRST .-4
	SETZ 1,
	CALL UNPRT1		;NOW GET PAGE 0. THE REST CAN BE LEFT
	RET			;FOR WTRP.

UNPRT1:	LSH 1,-LPS
	HRLI 1,400000
	RPACS
	TLO 2,400		;SET CW BIT
	TLNE 2,10000		;BUT PAGE MUST EXIST.
	 SPACS
	HLRZ 2,TYPTAB(1)
	IORI 2,PVTBIT
	TRZ 2,SYSBIT
	HRLM 2,TYPTAB(1)
	RET


MKSYSQ:	PUSH CP,1
	MOVEI 1,ASZ+1
	CALL GETBLK
	MOVEM 1,FREETB
	ADDI 1,NPS
	MOVEM 1,ENDTB
	POP CP,1
	JRST MKSYS

U MKSYST,5
U SYSSYS		;SYSTEM ON WHICH MAKESYS CREATED
>	;END OF IFE TEN50
U SYSPGS		;# DATA PAGES ASSIGNED AT MKSYS TIME
U FREETB
U ENDTB
NTB=11*NTWC
U XTRATB,NTB

;SUBFNS FOR DETERMINING STORAGE ALLOCATION AND USE

;FIND # WORDS IN USE FOR DATA TYPE
;FOR NON-CONTIG. TYPES RESULT IS AS OF LAST GC

INUSE:	CALL IUNBOX
	HRRZ 2,TYPBLK(1)
	JUMPE 2,FALSE		;RETURN NIL IF NO SUCH TYPE
	MOVE 3,TBITS(2)
	TRNN 3,BCONT
	JRST INUSEA
	HRRZ 1,TFRE(2)		;CONTIG. TYPE
	SUB 1,TBGN(2)		;USE FRE-BGN
	JRST MKN

INUSEA:	HLRZ 3,3		;ENTRY SIZE
	MOVE 1,TNWD(2)		;TIMES ENTRIES IN USE
	IMULI 1,0(3)
	JRST MKN

;FIND # WDS ASSIGNEED TO DATA TYPE
;SECOND ARG T, COUNT SYSTEM ONLY

ASSED:	SETZ 5,
	CAME 2,KNIL
	MOVSI 5,SYSBIT
	CALL IUNBOX
	SETZ 4,
	MOVE 2,BGNPAG
	CAIN 1,VCELLT
	MOVE 2,VCPGS
	CAIN 1,2
	MOVSI 2,-NPM
ASSED1:	MOVE 3,TYPTAB(2)
	XOR 3,5
	TLNE 3,SYSBIT
	JRST ASSED2		;DONT COUNT SYSTEM PAGES
	MOVEI 3,0(3)
	CAIN 3,0(1)
	ADDI 4,NPS
ASSED2:	AOBJN 2,ASSED1
	MOVEI 1,0(4)
	JRST MKN


;FIND ALL PAGES WITH SYSBIT SET THAT HAVE BECOME PRIVATE
;CALLS TO ROUTINES FOR VARIOUS DATA TYPES FOLLOW CALL TO SHRPG
;USED FOR SCAN AND SWEEP OF SHARED DATA

SHRPG:	IFE TEN50,<
	MOVE 7,BGNPAG
	CALL SHRPG1
	MOVE 7,VCPGS
	CALL SHRPG1
	SETZM SYSCHK
	POP GP,1
	JRST 7(1)

SHRPG1:	MOVE 6,TYPTAB(7)
	TLNN 6,SYSBIT
	JRST SHRPG2		;NOT SYSTEM PAGE - IGNORE
	TLNE 6,PVTBIT
	JRST SHRPG4
	MOVEI 1,0(7)
	CALL SYSCH		;MAKE SURE BITS ARE RIGHT
	 JRST SHRPG2		;PAGE IS PROTECTED
SHRPG4:	MOVEI 6,0(6)		;SOMEBODY CHANGED IT
	MOVE 1,-1(GP)
	CAIN 6,ARRAYT		;DOES PAGE NEED SCANNING?
	ADDI 1,1
	CAIN 6,LISTT
	ADDI 1,2
	CAIN 6,ATOMT
	ADDI 1,3
	CAIN 6,STPTT
	ADDI 1,4
	CAIN 6,STKPT
	ADDI 1,5
	CAIN 6,VCELLT
	ADDI 1,6
	CAIG	6,MSYST		;USER TYPE?
	JRST	.+3		;NO
	CAIL	6,MTYPN		;MAYBE - CHECK SOME MORE
	ADDI	1,7		;YES
	CAME 1,-1(GP)
	XCT -1(1)		;CALL APPROPRIATE ROUTINE IF ANY
SHRPG2:	AOBJN 7,SHRPG1
	RET
>

SYSCH:	IFE TEN50,<
	SKIPN SYSCHK		;ALL THIS IS TO AVOID BEING SCREWED
	RET		;BY USER WHO DOEES SSAVE NOTT SYSOUT
	PUSH PP,1		;MAKE SURE SHARED PAGES STILL WRITE 
	PUSH PP,2
	HRLI 1,400000		;...PROTECTED
	RPACS
	TLNN 2,040600		;COPY ON WRITE, WRITE, OR PRIVATE
	JRST SYSCH1		;OK
	MOVSI 2,PVTBIT		;NOT PROTECTED , SET PRIVATE BIT
	IORM 2,TYPTAB(1)
	AOS 0(GP)		;SKIP IF PAGE NOT PROTECTED
SYSCH1:	POP PP,2
	POP PP,1
>
	RET

;SCAN AND CHASE FROM SHARED LIST PAGE - PAGE IN 7

SHRSL:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
SHRSL1:	CARA 1,5
	BCHASE
	CDRA 1,5
	BCHASE
	AOBJN 5,SHRSL1
	POPJ GP,

;SCAN AND CHASE FROM SHARED ATOM PAGE - PAGE IN 7

SHRSAT:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS/3
SHSAT1:	MOVEI 1,0(5)
	PUSHJ GP,CHSAT1
	ADDI 5,2
	AOBJN 5,SHSAT1
	POPJ GP,

;SCAN AND CHASE FROM SHARED STRING POINTERPAGE - PAGE IN 7

SHRSSP:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
SHRSS1:	MOVE 1,0(5)
	PUSHJ GP,MARKST
	AOBJN 5,SHRSS1
	POPJ GP,

;SCAN AND CHASE FROM SHARED ARRAY PAGE - PAGE IN 7

SHRSAR:	PUSHJ GP,SCNSAR
	 PUSHJ CP,CHLIST
	POPJ GP,


;SCAN AND CHASE FROM SHARED VALUE CELL PAGE

SHRSVC:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
SHRVC1:	HRRZ 1,0(5)
	JUMPE 1,SHRVC2		;IGNORE 0'S
	BCHASE			; Chase value
SHRVC2:	AOBJN 5,SHRVC1
	POPJ GP,

;SCAN AND CHASE FROM SHARED STK PTR PAGE

SHRSTP:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
	HRRZ 1,0(5)
	PUSHJ GP,CHSSTK		;GO CHASE STACK
	AOBJN 5,.-2
	POPJ GP,

;SCAN AND CHASE FROM USER DATA TYPE PAGE - PAGE IN 7

SHRUCH:	HRRZ	3,TYPTAB(7)	;GET TYPE NUMBER
	PUSH	GP,TYPSIZ(3)	;SAVE NUMBER OF BOXED WORDS
	HLRM	3,0(GP)		;CLEAR STATUS BITS
	HRRZ	3,TYPBLK(3)
	HLRZ	3,TSIZ(3)	;GET NUMBER OF WORDS/ITEM
	MOVEI	5,NPS
	IDIVI	5,0(3)		;COMPUTE NUMBER OF ITEMS/PAGE
	PUSH	GP,5		;AND SAVE IT
	PUSH	GP,3
	MOVEI	5,0(7)		;CONVERT PAGE NUMBER OT ADDRESS
	LSH	5,LPS
USHRC2:	MOVEI	1,0(5)
	PUSHJ	GP,UCHAS4	;GO CHASE THE BOXED WORDS
	ADD	5,0(GP)		;BUMP ADDRESS
	SOSLE	-1(GP)		;DECREMENT COUNTER
	JRST	USHRC2		;AND LOOP
	SUB	GP,BHC+3	;POP JUNK
	POPJ	GP,
UCHAS4:	PUSH	GP,-3(GP)	;SET UP FOR TO USE UCHAS CODE
	JRST	UCHAS2

				;MARKING DONE AND ACTIVE UNITS COUNTED
				;NOW SEE IF SHUFFLING OR COMPACTING
				;ARE REQUIRED
GCS:	MOVE 2,GCTYP
	HRRZ 1,TYPBLK(2)
	MOVEI 3,BCONT
	TDNN 3,TBITS(1)
	JRST GCP1
GCEXP:	MOVEM 2,CMPTYP
	SETZM NNP	;COMPACT AND EXPAND A REGION
	PUSH GP,1
	MOVE 2,TEND(1)
	SUB 2,TBGN(1)	;NUMBER OF WORDS AVAILABLE
	SUB 2,TNWD(1)	;- # USED IS NUMBER FREE
	MOVEM 2,TNFR(1)
	CAML 2,TMIN(1)
	JRST GCEXP1	;ENOUGH FREE, JUST COMPACT
	MOVN 5,2
	ADD 5,TMIN(1)
	ADDI 5,MPS
	LSH 5,-LPS	;NUMBER OF ADDITIONAL PAGES REQUIRED
	MOVE 6,TBGN(1)
	LSH 6,-LPS
	MOVE 7,TEND(1)
	SUBI 7,1
	LSH 7,-LPS
	PUSHJ GP,ADJMT
	MOVEM 1,FRSTNP
	MOVEM 2,NNP
	MOVE 1,0(GP)
	MOVE 2,TINI(1)
	MOVEM 2,INIFN
GCEXP1:	XCT TPLN(1)
	POP GP,1
	MOVE 2,TCHG(1)
	MOVEM 2,CMPFN
	MOVE 2,TBITS(1)
	TRNE 2,BGEN
	TRNE 2,-1
	TLO F,GCPF
	TLO F,GCCF

GCP1:	SETOM SWPFLG		;FLAG SWWEEP PHASE (FOR SCNSAR)
	TLNN F,GCPF		;BEFORE HANDLE BITS GET CLEARED
	JRST .+3
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPHDB		;UPDATE PTRS IN NON-SYS SHADOW ARRAYS
	CALL STKPPG		;FLUSH STACK ASSOC. W/ UNMARKED
	 CALL STKFLQ		;... STACK POINTERS
	CALL SWPSTK		;SWEEP STACK (TO CLEAR MARKS ETC.)
	 CALL UDLIST
	 CALL UDRITE
	PUSHJ GP,SWPATH		;SWEEP ATOM HASH TABLE
	PUSHJ GP,SWPFX		;SWEEP FIXED LENGTH TYPES
	PUSHJ GP,SWPARR
	TLNN F,GCPF+GCCF
	JRST PPRS1
	PUSHJ GP,SHRPG		;SWEEP SHARED DATA THAT HAS CHANGED
	 PUSHJ GP,SWPSAR
	 PUSHJ GP,SWPSL
	 PUSHJ GP,SWPSAT
	 PUSHJ GP,SWPSSP
	 JFCL		;NO UPDATES NEEDED FOR STK PTRS
	 PUSHJ GP,SWPSVC
	 PUSHJ GP,SWPSUS
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPHDA		;UPDATE PTRS IN SYS/PVT SHADOW ARRAYS
	MOVE 4,UCTVRP
	PUSHJ GP,INTRS			;RESCAN INTERRUPT VARS
	MOVE 4,[XWD -NKCELL,KNIL]	;IF POINTERS ARE CHANGING
	PUSHJ GP,INTRS	;RESCAN INTERNAL TABLES
	MOVE 4,[XWD -NFILES-1,FILEA]
	PUSHJ GP,INTRS
	MOVE 4,[-NTYPN,OBJTNS]
	PUSHJ GP,INTRS
	MOVE 4,[XWD -2*NTYPN,EVATAB]
EVTUPD:	MOVE 1,0(4)
	PUSHJ GP,CHG2P
	MOVEM 1,0(4)
	AOBJN 4,EVTUPD
	JRST PPRS3

INTRS:	HRRZ 1,0(4)
	PUSHJ GP,CHGPTR
	HRRM 1,0(4)
	AOBJN 4,INTRS
	POPJ GP,


PPRS3:	SOS 1,ENDBT
	PUSHJ GP,CHGPTR
	ADDI 1,1
	EXCH 1,ENDBT
	CAMN 1,FREEBT
	JRST PPRS31		;FREEBT IS AT END
	HRRZ 1,FREEBT
	PUSHJ CP,CHGPTR
PPRS31:	HRRZM 1,FREEBT

PPRS1:	MOVE 1,GCTYP
	MOVE 2,XMINAR
	CAIN 1,ARRAYT		;IF COLLECTING ARRAYS
	MOVEM 2,MINARR		;RESTORE MINARR TO PERMANENT VALUE
	HRRZ 2,TYPBLK(1)
	PUSH GP,TNFR(2)	;SAVE FREE COUNT FOR TYPE COLLECTING
	PUSHJ GP,MOVARR		;JUST CLEARS GC PTR IF NOTHING MOVING
	TLNN F,GCMF+GCCF
	JRST PPRS2
	PUSHJ GP,MOVSTR
	PUSHJ GP,MOVPN
	PUSHJ GP,MOVPGS

PPRS2:	MOVEI 2,MTYPN
PPRS4:	HRRZ 7,TYPBLK(2)
	JUMPE 7,PPRS6
	MOVE 3,TBITS(7)
	POP PP,5		;OLD # WORDS IIN USE
	TRNE 3,BCONT		;LOOK FOR NON-CONTIG. TYPES
	JRST PPRS6
	HLRZ 3,3		;ENTRY SIZE
	MOVE 6,TMIN(7)
	CAMN 2,GCTYP		;TYPE COLLECTING?
	JRST PPRS5		;YES - GET MINFS
	SKIPE TITEGC		;CAN OTHER TYPES GROW?
	JRST PPRS6		;NO
	MOVE 4,TNWD(7)		;OTHER TYPES
	SUB 4,5			;...SEE IF GROWING
	JUMPLE 4,PPRS6		;IF WORDS USED DECREASING DONT GET MORE
	ASH 4,2			;4 * INCREASE
	IMULI 4,0(3)		;* SIZE
	CAIGE 4,0(6)
	ASH 6,-1		;INCREASE<1/4 MINFS,GET 1/2 MINFS
PPRS5:	MOVE 5,TNFR(7)		;ENTRIES FREE
	IMULI 5,0(3)		;WORDS FREE
	SUBI 6,0(5)
	ADDI 6,MPS
	ASH 6,-LPS		;PAGES NEEDED
	JUMPLE 6,PPRS6
	PUSH GP,2
	PUSHJ GP,GETFPG
	POP GP,2
PPRS6:	SOJGE 2,PPRS4

GCXIT:	SKIPE 1,FORKH		;WAS FORK CREATED?
	KFORK			;YES, KILL IT
	SETZM FRELST
	SETZM LSTCNS
	POP GP,1
	MOVEM 1,GCTYP+1		; # WORDS COLLECTED, THIS TYPE
	MOVE 1,GCTYP
	HRRZ 1, TYPBLK(1)
	HRRZ 1,TNFR(1)
	MOVEM 1,GCTYP+2
	MOVE 4,BGNPAG
	SETZ 1,
	HRRZ 2,TYPTAB(4)
	TRNN 2,MTYPN
	ADDI 1,1
	AOBJN 4,.-3
	MOVN 3,ENDCOR
	LSH 3,-LPS
	ADD 3,VCPGS
	ADDI 1,0(3)
	MOVEM 1,GCTYP+3
;--------------
	PUSH GP,PREX
	SKIPN 1,GCMES3		; "free words"
	JRST GCXM4

; special feature for DLISP
	STE 1,SMALL
	 JRST GCXM3
	SUBI 1,ASZ
	MOVEM 1,UINTCH
	MOVE 1,RSTBK
	MOVEM 1,FNCALL
	TRO F,INTFLG
	JRST GCXMX
; end special feature for DLISP

GCXM3:	MOVE 1,GCTYP+1
	CALL PNO10		;PRINT OLD FREE COUNT
	MOVE 1,GCMES3
	MOVE 2,KT
	CALL PRIN1

GCXM4:	SKIPN 1,GCMES4
	JRST GCXM5
	MOVE 1,GCTYP+2
	CALL PNO10
	MOVE 1,GCMES4
	MOVE 2,KT
	CALL PRIN1

GCXM5:	SKIPE GCMES6	; "pages left"
	SKIPN 6,GCMES5	; min # pages left
	 JRST GCXM7
	MOVE 1,GCTYP+3
	CAILE 1,-ASZ(6)
	 JRST GCXM7
	TYPEQ <, >
	CALL PNO10
	MOVE 1,GCMES6
	MOVE 2,KT
	CALL PRIN1

GCXM7:	SKIPN 1,GCMES7
	 JRST GCXMX
	MOVE 2,KT
	CALL PRIN1
GCXMX:	POP GP,PREX

;------------
GCX1:	MOVEI 2,0(CP)
	CAIG 2,OVEND
	CAILE 2,OVCP
	JRST .+2
	JSP 7,OVFIX		;CP OVERFLEW-FIX UP
	HRRZ 4,GCOCP
	CAME CP,GCOCP		;CHECK FOR WATERMELON SEED
	JSYS RECP		;YES- GET CP RESTORED
	HRRZ 4,GCOPP
	CAME PP,GCOPP
	JSYS REPP		;FIX UP PP IF OVERFLEW
	MOVE 1,GCOCF
	MOVEM 1,CF
	HRRZ 2,0(CP)		;HERE IS ANOTHER HORRIBLE KLUDGE
	CAIE 2,BRREST		;BECAUSE OF SWAPPER
	JRST GCX13
	HLRZ 3,FLGWD+2(1)	;NEED TO DO BRREST NOW ,IT CLOBBERS ACS
	MOVEM 3,GCOPP		;REMEMBER REAL RET 
	MOVEI 3,GCX12
	HRLM 3,FLGWD+2(1)
	RET			;DO BRREST - COME BACK TO .+1
GCX12:	PUSH CP,GCOPP		;AND GET REAL RET BACK ON STACK
	MOVEM BR,GCAC2+BR-2	;SO BR WILL BE OK ON EXIT
GCX13:	IFDEF MAXC,<
	CALL DSFBLP
	RICTR 1,7
	ADDM 1,GCINST
>
	GETJRT			;CALCULATE TIME OF GC
	SUB 1,GCTIMT	;CALCULATE TIME OF GC
	ADDM 1,GCRT
	MOVS 1,[XWD 2,GCAC2]	;RESTORE ACS 2 - 15
	BLT 1,15
	MOVE 1,GCTYP
	CAIN 1,STRNGT
	 RET			;Strings not quite done - delay int.
	CALL	DOINT1		;Clear interrupt system.
	RET
DOINT1:	TRZ F,GCFLG		;CLEAR GC IN PROGRESS
	INTON
	MOVE 1,GCTYP
	HRRZ 1,TYPBLK(1)
	HRRZ 1,TNFR(1)
	CAIL 1,MINREM
	RET
	SKIPE 1,RESPG		;FREE THE RESERVED PAGE
	SETZM TYPTAB(1)		;IF IT STILL EXISTS
	SETZM RESPG
	ERROR0 37,RESET		;NOT ENUF SPACE - BREAK

;GET NEW PAGES FOR FIXED LENGTH TYPES
;ENTER 6 # PAGES, 7 TYPBLK PTR, 2 TYPE

GETFPG:	HRRZ 1,TFRE(7)
	CAIN 2,LISTT
	SETZ 1,			;LISTS HAVE  ONE PAGE FREELISTS
GCNPG:	HLRZ 3,TSIZ(7)
	PUSHJ GP,NEWPGG
	 POPJ GP,		;NO MORE PAGES AVAIL
	CAIN 2,LISTT
	JRST GCNPL
	MOVEM 1,TFRE(7)
GCNP1:	HLRZ 5,TSIZ(7)
	MOVEI 4,NPS
	IDIVI 4,0(5)
	ADDM 4,TNFR(7)		;UPDATE FREE COUNT
	SOJG 6,GCNPG
	POPJ GP,

GCNPL:	MOVEI 5,0(1)
	LSH 5,-LPS
	HRLM 1,BTT(5)
	MOVEI 1,0
	JRST GCNP1
;SCAN FOR POINTERS ON SHARED ARIAY PAGE
;ROUTINE TO EXECOTE FOR EACH POINTER ON PAGE FOLLOWS CALL

SCNSAR:	MOVEI 1,0(7)
	LSH 1,LPS
	PUSH GP,1		;PAGE BEG
	MOVEI 6,NPS(1)
	PUSH GP,6		;PAGE END+1
	PUSHJ GP,FBA
	JUMPE 1,SWSAX		;NO SUCH ARRAY
	MOVEI 5,0(1)
SWSAR3:	HLRE 6,0(5)
	JUMPG 6,.+2
	HRRZ 6,0(5)
	JUMPLE 6,SWSAX		;LEN 0 OR LESS, NO SUCH ARRAY
	ADDI 6,0(5)		;ADDR OF END OF POINTERS
	HRRZ 4,1(5)
	ADDI 4,0(5)		;ADDR OF BEG OF POINTERS
	CAMGE 4,-1(GP)		;BELOW PAGE BEG?
	MOVE 4,-1(GP)		;YES - STEP TO PAGE BEG
	CAML 4,0(GP)		;PAST PAGE END?
	JRST SWSAX		;YES - QUIT
	CAML 6,0(GP)
	MOVE 6,0(GP)		;STOP AT LESSER OF END PTRS AND PAGE
SWSAR2:	CAIL 4,0(6)
	JRST SWSAR1
	XCT @ -2(GP)		;CALL ROUTINE WITH LOC OF POINTER IN 4
	AOJA 4,SWSAR2
SWSAX:	SUB GP,BHC+2
	AOS 0(GP)
	POPJ GP,

SWSAR1:	SKIPGE 6,0(5)		;HASH ARRAY?
	SKIPN SWPFLG		;SWEEPING?
	JRST SWSAR4		;NONE OF ABOVE
	MOVEI 6,-1(6)		;ADDR LAST PTR IN ARRAY
	ADDI 6,0(5)
	LSH 6,-LPS		;SEE IF ANY MORE PVT PGS THIS ARRAY
SWSAR6:	CAIG 6,0(7)
	JRST SWSAR5		;NO MORE PVT PGS, REHASH NOW
	HLRZ 3,TYPTAB(6)
	TRNE 3,PVTBIT		;PVT? - GUARANTEED TO BE SYS
	JRST SWSAR4		;IS PVT - DONT REHASH YET
	SOJA 6,SWSAR6		;NOT SYS&PVT - LOOK MORE
SWSAR5:	PUSH GP,5
	MOVEI 1,0(5)
	MOVEI 4,0(5)
	ANDI 4,-NPS
	HRRZ 6,0(5)		;MAKE SURE WHOLE ARRAY IS PVT
	ADDI 6,-1(5)
SWSAR7:	MOVES 0(6)		;ELSE REHASH WONT WORK - YECH
	SUBI 6,NPS
	CAIL 6,0(4)
	JRST SWSAR7
	CALL REHSHG		;REHASH IT
	POP GP,5
SWSAR4:	ADD 5,0(5)		;NEXT ARRAY
	MOVEI 5,0(5)
	JRST SWSAR3
GCF2==100000



;MOVE THE PAGES SCHEDULED TO MOVE

MOVPGS:	TLNN F,GCMF
	JRST MOVPG5
	MOVE 4,BGNPAG
MOVPG7:	HRRZ 1,BTT(4)
	JUMPE 1,.+3
	PUSHJ GP,CHGPT1		;UPDATE PTRS IN RIGHT HALF BTT
	HRRM 1,BTT(4)
	AOBJN 4,MOVPG7
	MOVE 4,VCPGS		;NOW BTT FOR VC PAGES
MOVPGV:	HRRZ 1,BTT(4)
	JUMPE 1,.+3
	PUSHJ GP,CHGPT1
	HRRM 1,BTT(4)
	AOBJN 4,MOVPGV
	MOVE 1,PPTRP
	HRLI 1,400000
	RMAP
	MOVEM 1,MT
	MOVEM 2,AT
	MOVNI 1,1
	MOVE 2,PPTRP
	HRLI 2,400000
	MOVEI 3,0		;FOR KL-20
	PMAP
MOVPG8:	TLZ F,GCF+GCF2
	MOVE 4,BGNPAG
MOVPGD:	MOVEI 1,0(4)
	LDB 5,CHGPTP		;DEST OF PAGE
	JUMPE 5,MOVPGB		;MOVING?
	HRRZ 3,TYPTAB(5)
	JUMPE 3,.+3
	CAIE 3,77
	JRST MOVPG9
	TLO F,GCF2
MOVPGJ:	MOVE 6,BTT(1)		;YES - SAVE BTT
	MOVE 7,TYPTAB(1)	;AND TYPTAB FOR SOURCE PAGE
	SETZM BTT(1)
	SETZM TYPTAB(1)
	TLZ 7,RPGBIT
	CAME 5,PPTRP
	TLZ 7,CHGMSK
	MOVEM 6,BTT(5)
	MOVEM 7,TYPTAB(5)
	MOVEM 1,PS
IFE TEN50,<
	HRLI 1,400000
	RPACS
	MOVE 10,2
	TLNE 2,200		;SOURCE PRIVATE?
	JRST MOVPG3		;YES
	RMAP		;GET MAP OF SOURCE PAGE
	MOVE 3,2		;ACCESS
	MOVE 2,5		;DEST PAGE
	HRLI 2,400000
	PMAP		;MAP FROM SOURCE TO DEST
	MOVE 2,PS		;;FLUSH SOURCE FROM FORK
	HRLI 2,400000
	MOVNI 1,1
	MOVEI 3,0		;FOR KL-20
	PMAP
	JRST MOVPGB
>
MOVPG3:	HRLZ 1,PS		;BLT SOURCE TO DEST
	HRRI 1,0(5)
	LSH 1,LPS
	MOVEI 2,0(1)
	BLT 1,MPS(2)
MOVPGB:	AOBJN 4,MOVPGD
	TLZN F,GCF
	JRST MOVPGM
	TLZE F,GCF2
	JRST MOVPG8
	JRST MOVPGK
MOVPGM:
IFE TEN50,<
	MOVE 1,MT
	MOVE 3,AT
>
	MOVE 2,PPTRP
	MOVEI 4,BLOCKT
	MOVEM 4,TYPTAB(2)
IFE TEN50,<
	HRLI 2,400000
	PMAP
>
MOVPG5:	MOVE 1,FRSTNP	;MOVING DONE NOW SET UP NEW PAGES
	MOVE 2,CMPTYP
	MOVE 3,NNP
	JUMPE 3,R
MOVPG4:	MOVEM 2,TYPTAB(1)
	HRRZS BTT(1)
	XCT INIFN
	ADDI 1,1
	SOJG 3,MOVPG4
	POPJ GP,
MOVPG9:	TLO F,GCF
	JRST MOVPGB

MOVPGK:	MOVE 4,BGNPAG
MOVPGN:	MOVEI 1,0(4)
	MOVE 6,TYPTAB(4)
	TLNE 6,RPGBIT
	TLNN 6,CHGMSK
	JRST MOVPGL
	MOVE 5,PPTRP
	MOVE 4,BGNPAG
	SUB 4,BHC+1
	JRST MOVPGJ
MOVPGL:	AOBJN 4,MOVPGN
	HALTF		;SHOULDNT HAPPEN


CLRPG:	MOVEI 4,0(1)	;CLEAR PAGE IN 1
	LSH 4,LPS
CLRPG2:	MOVSI 5,0(4)	;ENTRY TO CLEAR PG ADDRESSED BY 4
	HRRI 5,1(4)
	SETZM 0(4)
	BLT 5,MPS(4)
	POPJ GP,

U MT
U AT
U PS
;FIND C(5) OR FEWER EMPTY PAGES (WITHOUT BIT TABLES)
;AND JUGGLE TILL THEY FOLLOW THE GROUP FROM B THRU E
;B IN 6, E IN 7

B==6
E==7
OG==10

ADJMT:	MOVEM 5,ADJT	;SAVE ORIGINAL COUNT
	MOVEI 4,0(E)
	PUSHJ GP,MTPA	;FIRST TRY IMMEDIATELY AFTTER E
	 JRST .+2
	JRST ADJMT3
	MOVE 1,GCTYP
	CAIE 1,STRNGT
	CAIN 1,PNAMT
	JRST ADJMTB
	JRST ADJMT9
ADJMTB:	MOVE 5,ADJT	;FAILING THAT TRY FOR GROUP BIG ENOUGH
	ADDI 5,1(E)	;FOR B THRU E + NEW PAGES
	SUBI 5,0(B)
	PUSHJ GP,MTPGS
	 JRST ADJMT9
ADJMTR:	TLO F,GCMF
	MOVEI 1,0(B)	;SET PAGES TO MOVE
ADJMTA:	DPB 4,CHGPTP
	ADDI 1,1
	CAIG 1,0(E)
	AOJA 4,ADJMTA
	MOVEI 1,1(4)
	JRST ADJMT8
ADJMT9:	MOVE 11,ADJT
ADJMT1:	PUSHJ GP,MTPG		;GET AN EMPTY PAGE
	 JRST ADJMT2
	HRRZI 2,77	;MAGIC RESERVED TYPE
	MOVEM 2,TYPTAB(4)
	PUSH PP,4	;REMEMBER PAGE NUMBER OF NEW PAGE
	SOJG 11,ADJMT1
ADJMT2:	MOVNI 2,0(11)	;- NUMBER REMAINING TO GET
	ADDB 2,ADJT	;+ NUMBER REQUESTED
	JUMPE 2,ADJMT7	;IS NUMBER FOUND, IF 0 RETURN
	TLO F,GCMF+GCPF		;FLAGS INDICATE PAGES SHUFFLING
	MOVEI 4,1(E)		;ARE ENUF PAGES FOLLOWING E
ADJML4:	PUSHJ GP,MOVQ		;... SINGLE AND MOVABLE?
	 JRST SHFPG
	ADDI 4,1
	SOJG 2,ADJML4
	MOVEI 4,1(E)
	ADD 4,ADJT
	MOVEI 1,1(E)		;YES - MOVE THEM TO EMPTY PAGES
	HRRZ 2,ADJT
ADJML6:	HRRZ 3,TYPTAB(1)
	CAIN 3,77
	AOJA 1,ADJML6		;ALREDY EMPTY - DONT MOVE
	JUMPE 3,.-1
	POP PP,3
	CAIGE 3,0(4)		;DONT MOVE TO PAGES AFTER E
	CAIGE 3,1(E)
	JRST .+2
	JRST ADJML5
	DPB 3,CHGPTP
	ADDI 1,1
ADJML5:	SOJG 2,ADJML6
ADJMT7:
ADJMT3:	MOVEI 1,1(E)		;FIRST NEW PAGE
ADJMT8:	MOVE 2,ADJT		;# NEW PAGES
	POPJ GP,

;SIMPLE WAYS FAIL, TRY BIG SHUFFLE

SHFPG:	SKIPN 2,ADJT		;FLUSH STACK OF RESERVED PAGES
	JRST SHFPG9
	POP PP,3
	SETZM TYPTAB(3)
	SOJG 2,.-2
SHFPG9:	SETZM SHFTMP
	MOVE 4,BGNPAG		;MAKE TABLE OF HOLES
SHFTBA:	PUSHJ GP,SHFTBS		;MOVABLE?
	 JRST SHFTBB		;NO
	PUSH PP,4		;YES - SAVE PAGE
	MOVEI 1,0
	JRST SHFTB9
SHFTB8:	PUSHJ GP,SHFTBS		;AND FIGURE OUT LENGTH
	JRST SHFTBC
SHFTB9:	ADDI 1,1
	AOBJN 4,SHFTB8
SHFTBC:	HRLM 1,0(PP)		;SAVE LENGTH
	SOS SHFTMP		;COUNT # HOLES STACKED
SHFTBB:	AOBJN 4,SHFTBA
	PUSH PP,SHFTMP		;SAVE NEG. COUNT OF # HOLES
	SETZM SHFTMP
	MOVE 4,BGNPAG		;NOW MAKE TABLE OF CONTIG. CHUNKS
SHFPG5:	MOVE 3,TYPTAB(4)		;... ON CP
	TLNE 3,SYSBIT+FIXBIT
	JRST SHFPG1
	HRRZ 3,TYPBLK(3)
	JUMPE 3,SHFPG1
	HRRZ 2,TBITS(3)
	TRNN 2,BCONT		;CONTIGUOUS?
	JRST SHFPG1		;NO
	PUSH CP,4		;YES - SAVE FIRST PAGE
	AOS SHFTMP		;COUNT CHUNKS
SHFPG3:	JUMPE 3,SHFPG1
	HRRZ 1,TBGN(3)		;LOOK FOR CHUNK OF WHICH
	HRRZ 2,TEND(3)		;THIS IS THE BEGINNING
	LSHC 1,-LPS
	HRRZ 3,TNEXT(3)
	CAIE 1,0(4)
	JRST SHFPG3
	SUBI 2,0(1)		;# PAGES IN CHUNK
	HRLI 2,0(2)
	MOVEI 1,0
	CAIN B,0(4)		;IS THIS THE CHUNK THATS EXPANDING?
	MOVE 1,ADJT		;... IF SO AUGMENT LENGTH
	ADD 4,2
	ADD 2,1
	HRLM 2,0(CP)		;SAVE LENGTH
	JUMPL 4,SHFPG5
SHFPG1:	AOBJN 4,SHFPG5

SHFPG6:	HRRZ 1,0(PP)		;SET UP STUFF FOR FIND
	HRLI 1,PP
	HLL 1,@1
	PUSH CP,1		;1ST HOLE SIZ,,INDEX TO FIRST HOLE
	PUSH CP,SHFTMP		;COUNT OF # CHUNKS (>0)
	PUSHJ GP,FIND
	 JRST SHUFB
	PUSH PP,BGNPAG		;SHUFFLE SINGLE PAGES
	MOVE 1,BGNPAG
SHUF1:	MOVE 2,TYPTAB(1)
	TLNN 2,RPGBIT		;PAGE MOVING TO HERE?
	JRST SHUF2		;NO - OK
	LDB 2,CHGPTP		;YES
	JUMPN 2,SHUF2		;IF THIS PAGE GOING OUT, THEN OK
	HRRZ 2,TYPTAB(1)
	JUMPE 2,SHUF2
	CAIN 2,77
	JRST SHUF2
	EXCH 1,0(PP)		;FIND PLACE TO PUT THIS ONE
SHUF5:	MOVE 2,TYPTAB(1)
	TLNE 2,RPGBIT
	JRST SHUF4		;YES
	MOVEI 2,0(2)
	CAIE 2,77
	JUMPN 2,SHUF3
SHUFG:	MOVSI 2,RPGBIT		;EMPTY OR RESERVED
	IORM 2,TYPTAB(1)
	MOVEI 2,0(1)
	EXCH 1,0(PP)
	DPB 2,CHGPTP
SHUF2:	AOBJN 1,SHUF1
	MOVN 1,-1(PP)
	SUB PP,BHC+2(1)
	MOVEI 1,0(E)
	LDB 2,CHGPTP
	SKIPE 2
	MOVEI 1,0(2)
	ADDI 1,1
	JRST ADJMT8

SHUF3:	LDB 2,CHGPTP		;PG GOING SOMEPLACE?
	JUMPN 2,SHUFG		;YES - USE IT
SHUF4:	AOBJN 1,SHUF5		;NO TRY NEXT
	HALTF			;SCREWED UP

SHUFB:	MOVN 1,0(PP)
	SUB PP,BHC+1(1)
	MOVE 4,BGNPAG
SHUFB1:	HRRZ 3,TYPTAB(4)
	CAIN 3,77
	SETZM TYPTAB(4)
	AOBJN 4,SHUFB1
	MOVE 5,ADJT
	ADDI 5,1(E)
	SUBI 5,0(B)
	PUSHJ GP,MTPGS		;TRY AT END NOW
	 JRST SHUFB3
	JRST ADJMTR		;SUCCESS

SHUFB3:	SOSLE 5,ADJT		;FAILS - TRY FOR ONE LESS PAGE
	JRST ADJMT
	JRST ADJMT8		;GIVE UP

;PAGE IN 4 - SKIP IF NON-CONTIGUOUS,NON-BLOCK, NON-SYSTEM,
;NON-FIXED - RESERVED OR EMPTY ALSO OK

MOVQ:	MOVE 3,TYPTAB(4)
	TLNE 3,SYSBIT+FIXBIT
	POPJ GP,
	MOVEI 3,0(3)
	CAIE 3,STACKT
	CAIN 3,BLOCKT
	POPJ GP,
	CAIN 3,77
	JRST RSKIP
	JUMPE 3,RSKIP
	HRRZ 3,TYPBLK(3)
	HRRZ 3,TBITS(3)
	TRNN 3,BCONT
RSKIP:	AOS 0(GP)		;SKIP IF OK
	POPJ GP,

;PAGE IN 4 - SKIP IF NON-FIXED,NON-SYSTEM, I.E.MOVABLE

SHFTBS:	MOVE 3,TYPTAB(4)
	TLNE 3,SYSBIT+FIXBIT
	POPJ GP,
	MOVEI 3,0(3)
	CAIE 3,BLOCKT
	CAIN 3,STACKT
	RET
	JRST RSKIP

;FIND HOLES TO PUT CONTIG. CHUNKS IN
;ARGS ARE ON CP AS FOLLOWS
; CHUNK LEN,,FIRST PAGE
; CHUNK ..
; ...
; HOLE REMAINDER,,INDEX TO HOLE DESC.
; # CHUNKS
; RETURN
; INDEX TO CURRENT CHUNK - INITIALLY FIRST

FIND:	PUSH CP,1		;GARBAGE
FIND11:	MOVN 1,-2(CP)		;# CHUNKS
	MOVEI 1,-3(1)		;INDEX TO FIRST CHUNK
	MOVEM 1,0(CP)
FIND1:	CAIL 1,-3		;ALL TRIED?
	JRST FIND4		;YES
	HRLI 1,CP
	HLRZ 2,@1		;LENGTH OF CHUNK
	HLRZ 3,-3(CP)		;AND LENGTH OF REMAINDER THIS HOLE
	CAIG 2,0(3)		;FITS?
	JRST FIND2		;YES
FIND6:	AOS 1,0(CP)
	JRST FIND1

FIND2:	HRRZ 3,-2(CP)
	CAIG 3,1		;ONLY ONE CHUNK?
	JRST FINDG		;YES - DONE
	MOVNI 2,3(3)		;NO
	HRLI 2,CP
	MOVE 1,@1
FIND3:	MOVE 4,@2		;STACK CHUNKS FOR NEXT CALL
	CAMN 4,1
	JRST FIND5
	PUSH CP,4
FIND55:	SOJG 3,FIND3
	MOVE 4,@2
	HLLZ 1,1
	SUB 4,1		;UPDATE REM,,HOLE PTR
	PUSH CP,4		;STACK IT
	PUSH CP,@2		;# CHUNKS
	SOS 0(CP)
	PUSHJ GP,FIND		;GO ROUND AGIN
	 JRST FIND6		;FAILURE - TRY NEXT ALT.
FINDG:	AOS -1(GP)		;GOOD RETURN - SKIP
	HRRZ 1,0(CP)
	HRLI 1,CP
	MOVN 1,@1
	TRC 1,-1
	MOVE 3,-3(CP)		;HOLE REM,,
	HLRZ 4,3		;REM
	HRLI 3,PP
	MOVE 2,@3		;ORIG HOLE SIZ,,1ST PAGE
	HLRZ 3,2		;SIZE
	ADDI 2,0(3)
	SUBI 2,1(4)		;  ,,HOLE BEG-REM+ORIG SIZ-1
	HLL 2,1
	HRLZ 3,ADJT
	CAIN B,1(1)
	ADD 2,3
	MOVSI 3,RPGBIT
FIND7:	AOBJP 1,FINDB
	AOBJP 2,FIND9
	MOVEI 5,0(1)
	CAIN 5,0(2)
	JRST FIND7		;GOING WHERE IT IS
	DPB 2,CHGPTP
FIND9:	IORM 3,TYPTAB(2)
	JRST FIND7

FIND5:	AOS 2
	HRLI 2,CP
	JRST FIND55


FIND4:	HRRE 1,-3(CP)		;TRY NEXT HOLE
	ADDI 1,1
	JUMPE 1,FINDB
	HRLI 1,PP
	HLL 1,@1
	MOVEM 1,-3(CP)
	JRST FIND11

FINDB:	HRRZ 2,-1(CP)
	HRRZ 3,-2(CP)
	SUB CP,BHC+4(3)
	JRST 0(2)

U SHFTMP	; TEMPORARY 'CAUSE OF REMOVAL OF NP
U ADJT	;TEMPORARY
CHGPTP:	POINT 9,TYPTAB(1),8
;TRY TO FIND C(5) CONTIGUOUS EMPTY PAGES
; RETURN SKIPPING WITH FIRST PAGE IN 4 IF OK

MTPGXX:	MOVEI 5,1
MTPGSX:	HRRZ 4,SYSPGS		;ENTRY TO GET  PAGES ABOVE SYSTEM
	HRLI 4,0(4)
	ADD 4,BGNPAG
	JUMPL 4,MTPGS2
	JRST MTPGS7
MTPG:	MOVEI 5,1	;ENTRY TO GET 1 PAGE
MTPGS:	MOVE 4,BGNPAG
MTPGS2:	HRRZ 2,TYPTAB(4)
	TRNN 2,77
	JRST MTPGS1
MTPGS6:	AOBJN 4,MTPGS2
MTPGS7:	MOVEI 4,-1(4)	;NONE IN ASSIGNED CORE
	PUSHJ GP,MTPA	;TRY FOLLOWING ASSIGNED CORE
	 POPJ GP,
	MOVEI 4,1(4)
	JRST RSKIP

MTPGS1:	PUSH GP,5	;FOUND AN EMPTY PAGE
	SOJE 5,MTPGS4
	PUSHJ GP,MTPA	;LOOK FOR N-1 AFTER IT
	 JRST MTPGS3
MTPGS4:	POP GP,5
	MOVEI 1,77	;SUCCESS, RESERVE FIRST PAGE FOUND
	MOVEM 1,TYPTAB(4)
	MOVEI 4,0(4)	;CLEAR LEFT
	JRST RSKIP
MTPGS3:	POP GP,5
	JRST MTPGS6

;FIND C(5) CONTIGUOUS EMPTY PAGES FOLLOWING PAGE IN 4
;IF SUCCESSFUL RESERVE PAGES AND SKIP

MTPA:	MOVEI 2,0(4)
	ADDI 2,0(5)
	HRRZ 3,VCPGS
	CAIL 2,0(3)
	POPJ GP,	;WILL BUMP INTO VCELLS
	MOVE 2,ENDCOR
	LSH 2,-LPS
	MOVEI 3,0(4)
MTPA1:	ADDI 3,1
	CAIL 3,0(2)
	JRST MTPA2
	HRRZ 1,TYPTAB(3)
	TRNE 1,77
	POPJ GP,
	SOJG 5,MTPA1
MTPA3:	MOVEI 1,77
	CAIG 3,0(4)
	JRST RSKIP
	MOVEM 1,TYPTAB(3)
	SOJA 3,.-3
MTPA2:	PUSHJ CP,GETPG
	 POPJ GP,
	HRLZI 1,-1
	ADDM 1,BGNPAG
	SOJE 5,MTPA3
	ADDI 3,1
	JRST MTPA2

;GENERAL CHASE

CHRITE:	HRRZ 1,0(4)	;CHASE RITE HALF OF WD REF'D BY 4
CHAS:	MOVEI 2,0(1)
	LSH 2,-LPS		;GET PAGE
	MOVE 2,TYPTAB(2)
	TLNE 2,SYSBIT		;SHARED?
CHASR:	POPJ GP,		;YES - DONT CHASE
CHASX:	HRRZ 2,TYPBLK(2)	;GET TYPBLK ENTRY
	JUMPE 2,CHASR		;NONE - DONT CHASE
	JRST @TCHAS(2)		;CALL CHASE ROUTINE FOR TYPE

IFDEF MAXC,<
; Enter here when a CHASE is followed immediately by a POPJ to avoid
; unnecessary pushing on the stack.
PCHASX:	SUB GP,BHC+1
	HRRZ 2,TYPBLK(2)
	JUMPE 2,CHASR
	JRST @TCHAS(2)
>


; CHASE LIST , CHECK	IF MARKED, IF	SO QUIT
; ... IF NOT , MARK AND CHASE
;PTR IN 1

CHASLS:	HRLM 1,0(GP)
IFDEF MAXC,<
	SBTLU 2
>
IFNDEF MAXC,<
	ROT 1,-LPS
	HRRZ 2,BTT(1)		;ADDR OF BIT TABLE
	HRRI 1,0
	ROT 1,LPS-5		;REL WORD IN BIT TABLE
	ADDI 2,0(1)	;ABSL WORD	IN BIT	TABEL
	HRRI 1,0
	ROT 1,5		;GET BIT NUMBER BACK
	MOVE 1,GCBITS(1)	;GET THE BIT
	TDOE 1,0(2)
	POPJ GP,	;ALREADY SET
	MOVEM	1,0(2)	;NOT SET, PUT IT IN
>
	AOS NLISTW
	HLRZ 1,0(GP)
	CARA 1,1
	BCHASE
	HLRZ 1,0(GP)
	CDRA 1,1
	JCHASE


GCBITS:	QQ==0
	REPEAT 40,<1B<QQ>
QQ==QQ+1
>
;MARK ARRAY AND CHASE POINTERS, ARRAY POINTER IN 1
;ARRAY OVERHEAD
;	REL LOC OF RELOC BITS,,LENGTH
;	G.C. POINTER,,REL LOC OF POINTERS

CHASAR:	PUSHJ GP,FBA		;GET BEGINNING OF ARRAY
	JUMPE 1,CHSARX		;NO SUCH ARRAY
	HLRZ 2,1(1)
	CAIN 2,0(1)
	POPJ GP,	;GC PTR=SELF, ALREDY DONE
	JUMPN 2,GCERR	;NOT ZERO,ARRAYS CONFUSED
	HRLM 1,1(1)	;SET GC PTR TO SELF
	HRRZ 2,0(1)	;COUNT ARRAY WORDS IN USE
	ADDM 2,NARRW
	SKIPG 0(1)		;HASH ARRAY?
	JRST CHASHA
	CALL SWP1AR
	 CALL CHLIST
CHSARX:	POPJ GP,

CHASHA:	CALL SWP1AR
	 CALL CHASH1
	POPJ GP,

GCERR:	TMSG GCEM1
	POPJ GP,

GCEM1:	SIXBIT @ARRAYS FOULED/@

CHASH1:	HLRZ 1,0(4)
	CAIG 1,1
	POPJ GP,		;ENTRY UNUSED
	LDT 2,1
	CAIN 2,ATOMT
	JRST CHASH5		;ATOMS STAY
	CAIN 2,SMALLT
	JRST CHASH4		;SMALL NUMBERS STAY
	PUSHJ GP,CKMARK		;OTHER TYPES STAY IF OTHER REFERENCES
	 POPJ GP,		;NOT MARKED
CHASH4:	HRRZ 1,0(4)		;MARKED - CHASE VALUE
	JCHASE

CHASH5:	BCHASE
	JRST CHASH4

;CHASE WORD WITH PTRS IN BOTH HALVES - ADDR OF WORD IN 4

CHLIST:	HRRZ 1,0(4)
	BCHASE
	HLRZ 1,0(4)
IFDEF MAXC,<JUMPE 1,.+2
	CHASE 1,PCHASX>
IFNDEF MAXC,<JUMPN 1,CHAS>
	POPJ GP,

IFNDEF MAXC,<
;BIT TABLE LOOKUP
;GIVEN	PTR IN	1 RETURNS BIT	IN 1
;AND PTR TO WORD IN BIT TABLE IN 2

BTLU:	ROT 1,-LPS
	HRRZ 2,BTT(1)		;ADDR OF BIT TABLE
	HRRI 1,0
	ROT 1,LPS-5		;REL. WORD IN BIT TABLE
	ADDI 2,0(1)		;ABSL WORD	IN BIT	TABLE
	HRRI 1,0
	ROT 1,5			;BIT NUMBER
	MOVE 1,GCBITS(1)	;THE BIT
	POPJ GP,
>

;CHASE NUMBERS

CHASFL:
CHASFX:	MOVEI 3,TNWD(2)
CHASNM:	SBTLU(2)
	AOS @3
	POPJ GP,


;CHASE	ATOMS

CHASAT:	MOVEI 3,0(1)
	PUSHJ GP,CKATM		;GET BITS
	TDOE 2,0(1)		;MARKED?
	POPJ GP,		;YES - RETURN
	MOVEM 2,0(1)		;NO - MARK IT
	AOS NATM		;COUNT IT
	HLRZ 1,1
	SUBM 3,1		;NORMALIZE ORIG. PTR
CHSAT1:	HRLM 1,0(GP)		;ENTRY FROM SHARE SCAN
	GTVALC 1,1
	STE 1,VCELL		;?? SHOULDNT NEED TO CHECK
	JRST CA2		;NO VALUE CELL
	CALL CHASV1		;CHASE VALUE CELL
CA2:	HLRZ 1,0(GP)
	HRRZ 1,1(1)		;CHASE FN
	BCHASE
	HLRZ 1,0(GP)
	HLRZ 1,2(1)		;CHASE PNAME
	BCHASE
	HLRZ 1,0(GP)
	CDRA 1,1		;CHASE CDR AND RETURN
	JCHASE

;CHECK IF ATOM MARKED,
; ENTER WITH PTR IN 1
;RETURN BIT WORD IN 1, THE BIT IN 2

CKATM:	MOVEI 2,0(1)
	LSH   2,-LPS
	PUSH GP,BTT(2)		;BIT TABLE ADDR FOR PAGE
	ANDI 1,MPS
	IDIVI 1,3
	HRLM 2,0(GP)		;SAVE REMAINDER TO ADJUST ORIG. PTR
	LSHC 1,-5
	ADDM 1,0(GP)
	ROT 2,5
	MOVE 2,GCBITS(2)	;THE BIT
	POP GP,1		;REMAINDER,,ADDR OF BITS
	POPJ GP,

;
;MARK PNAME, USES 35TH BIT
; A WORD IS MARKED IF ANY PART OF IT IS USED
;ASSUME  PNAME PAGES ARE CONTIGUOUS 
;AND PNAMES FREELY OVERLAP PAGE BOUNDARIES
;ENTER	WITH POINTER IN 1

MARKPN:	MOVE 3,GCTYP
	CAIE 3,PNAMT
	POPJ GP,	;DONT MARK IF NOT COLLECTING PNAMES
	HLRZ 2,0(1)
	LSH 2,-13	;GET NO OF	CHARS FROM FIRST BYTE
	AOJA 2,MAST3	;IF COUNT DOESNT INCLUDE ITSELF


;CHASE VALUE CELL

CHASVC:	PUSH GP,1
	CALL CHASV1		;CHASE VALUE
	POP GP,1
	CALL VCTOAT		;FIND THE ATOM
	JRST CHASAT		; AND CHASE IT TOO

;CHASE THE VALUE IN A VALUE CELL - BUT DONT DO THE CORRESP. ATOM

CHASV1:	MOVEI 3,0(1)
	SBTLU(2)
	AOS NVCW		;COUNT IT
	HRRZ 1,0(3)		;GET VALUE
	JCHASE

;CHASE STRING POINTER

CHASSP:	HRLM 1,0(GP)
	SBTLU 2
	AOS NSTPTW		;NOT MARKED, COUNT
	HLRZ 1,0(GP)
	MOVE 1,0(1)		;GET STRING POINTER
MARKST:	MOVE 2,GCTYP		;MARK STRING
	CAIN 2,STRNGT
	JRST MAST2
	CAIE 2,PNAMT
	POPJ GP,		;NOT COLLECTING STRINGS, DONT BOTHER
MAST2:	MOVE 3,1
	TLZ 1,777770
	IDIVI 1,5		;GET ADDRESS
	LSH 3,-^D21		;GET CHAR COUNT
	ADDI 2,0(3)		;+ INITIAL CHAR POS
	MOVEI 3,0(1)
	LSH 3,-LPS
	MOVE 3,TYPTAB(3)
	TLNE 3,SYSBIT
	POPJ GP,		;DONT MARK ON SHARED PAGES
	MOVEI 3,0(3)		;CHECK TYPE
	CAME 3,GCTYP		;TYPE COLLECTING?
MASTX:	POPJ GP,		;NO - QUIT
MAST3:	HRRZ 3,TYPBLK(3)
	JUMPE 2,MASTX		;LENGTH 0, QUIT
MAST1:	HRL 1,0(1)
	TLOE 1,1		;MARKED?
	JRST .+3
	HLRM 1,0(1)		;NO - MARK BIT 35
	AOS TNWD(3)		;AND COUNT WORD ***FIX SO NOT NEEDED
	SUBI 2,5
	JUMPLE 2,MASTX
	AOJA 1,MAST1

;CHAS A HANDLE

CHASHD:	PUSH GP,1
	JBTLU 2,CHSHD1		; Mark and jump if already marked
	AOS NHDLW		;COUNT IT
	POP GP,1
CHSHD2:	TLOE F,HDLFLG		;IN A HANDLE CHASE?
	RET			;YES - QUIT
	MOVSI 2,HDLCHS		;NO - MARK HANDLE AS CHASED
	IORM 2,0(1)
	HRLI BR,(1)		;SAVE BOXED HANDLE IN LH OF BR
	MOVE 1,0(1)		;GET HANDLE
	CALL GFRKB		;GET BITS FOR PAGE
	TRNE 2,FSYSBT		;ARRAY SYSTEM?
	JRST CHSHD3		;YES - QUIT
	CALL SWAPIN		;RH OF BR GETS BUFFADR OF BLOCK.
	HRRZI 1,(BR)		;OTHER AC'S PRESERVED.
	CALL SWP1AR		;FIND ALL PTR WORDS IN THE ARRAY
	 CALL CHLIST		;AND CHASE EM
CHSHD3:	TLZ F,HDLFLG
	RET

CHSHD1:	POP GP,1
	MOVE 2,0(1)
	TLNE 2,HDLCHS	;CHASED?
	RET			;YES - QUIT
	JRST CHSHD2		;NO - TRY

;CHASE STACK POINTER

CHASEP:	PUSH GP,1
	JBTLU 2,CHSEP1
	AOS NSTKPW		;COUNT
	POP GP,1
	MOVE 1,0(1)		;GET THE GOODS
CHSSTK:	JUMPE 1,CHSSK1
	LDT 2,1
	CAIE 2,STACKT
CHSSK1:	POPJ GP,		;NOT STACK PTR
	GETFGC 2,1
	TROE 2,FGCBIT		;CHECK IF MARKED
	JRST CHSSK1		;YES - DONE
	SETFGC 2,1
	PUSH GP,1
	PUSHJ GP,SWPFRM		;SWEEP THE FRAME
	 PUSHJ GP,CHLIST
	 PUSHJ GP,CHRITE
CHSSK3:	HRRZ 1,0(GP)
	GETCL 2,1
	GETAL 1,1
	CAIE 1,0(2)
	CALL CHSSTK
	POP GP,1
	GETCL 1,1
	JRST CHSSTK

CHSEP1:	POP GP,1
	RET


;SWEEP A FRAME CALL PUSHJ GP,SWPFRM WITH FRAME IN 1
;		     PUSHJ GP, THING TO DO TO WORDS WITH 2 PTRS
;		     PUSHJ GP, THING TO DO TO RITE HALF

SWPFRM:	PUSH GP,4		;PRESERVE 4
	PUSH GP,1
	GETBAS 4,1		;CHASE BASIC FRAME
	GETNAR 2,1
;	LDB 3,[POINT NFRESZ,NARWD(1),8]	;GET # FREE PTRS
;	ADDI 2,0(3)
	MOVNI 2,1(2)		;NEG LENGTH BASIC FRAME
	ADDI 4,1
	HRLI 4,0(2)
	XCT @-2(GP)		;DO IT TO BOTH HALVES
	AOBJN 4,.-1
	HRRZ 1,0(GP)
	GETPPO 3,1		;CHASE P-TEMS
	GETPPI 4,1
	SUBM 4,3		;- # TEMS
	JUMPE 3,CHSSK2
	ADDI 4,1
	HRLI 4,0(3)
CHSSK4:	XCT @-2(GP)		;DO IT TO BOTH HALVES
	AOBJN 4,CHSSK4
CHSSK2:	HRRZ 4,0(GP)		;CHASE C-TEMS
	GETCPO 3,4
	SUBM 4,3
	HRLI 4,-1(3)
	ADD 4,BHC+FLGWD+1
	AOS -2(GP)		;TO PICK UP OPER FOR RIGHT HALF
	JUMPG 4,CHSSK7
CHSSK8:	HLRZ 1,0(4)
	CAIN 1,NMBLIP
	JRST CHSSK5
	XCT @-2(GP)
CHSSK6:	AOBJN 4,CHSSK8
CHSSK7:	POP GP,1
	POP GP,4
	AOS 0(GP)
	RET

CHSSK5:	HRRZ 3,0(4)
	HRLI 3,0(3)
	ADD 4,3			;SKIP NUMBERS
	JRST CHSSK6

;CHASE A USER DATA TYPE
;POINTER IN 1

UCHAS:	MOVEM	1,UCHSTM	;SAVE FOR WHEN WE NORMALIZE
	PUSHJ	GP,UGTBIT	;GET BITS
	TDOE	2,0(1)		;MARKED?
	POPJ	GP,		;YES - RETURN
	MOVEM	2,0(1)		;NO - MARK IT
	HLRZ	1,1
	EXCH	1,UCHSTM	;NORMALIZE
	SUB	1,UCHSTM
	HRRZ	2,TYPBLK(3)
	AOS	TNWD(2)
	HRRZ	3,TYPSIZ(3)
	PUSH	GP,3		;SAVE NUMBER OF BOXED ITEMS
UCHAS2:	SOSGE	0(GP)		;DECREMENT COUNT, DONE?
	JRST	UCHAS3		;YES
	PUSH	GP,1		;SAVE POINTER
	CDRA	1,1		;CHASE CDR
	BCHASE
	CARA	1,0(GP)		;CHASE CAR
	SOSL	-1(GP)		;DECREMENT COUNT, DONT CHASE IF DONE
	BCHASE
	POP	GP,1
	AOJA	1,UCHAS2	;BUMP THE POINTER AND LOOP
UCHAS3:	SUB	GP,BHC+1	;"POP" JUNK
	POPJ	GP,

U UCHSTM	;JUST A TEMP FOR NORMALIZING.

;"GET BIT" FOR A USER DATA TYPE
;PTR IN 1
;RETURNS BIT WORD IN 1, BIT IN 2, TYPE IN 3

UGTBIT:	MOVEI	2,0(1)		;COMPUTE TYPE NUMBER
	LSH	2,-LPS
	HRRZ	3,TYPTAB(2)
	PUSH	GP,BTT(2)	;BIT TABLE ADDR FOR PAGE
	ANDI	1,MPS
	HRRZ	2,TYPBLK(3)
	HLRZ	2,TSIZ(2)	;GET SIZE
	IDIV	1,2		;DIVIDE BY SIZE

	HRLM	2,0(GP)		;SAVE THE REMAINDER TO ADJUST ORIG. PTR
	LSHC	1,-5
	ADDM	1,0(GP)
	ROT	2,5
	MOVE	2,GCBITS(2)	;THE BIT
	POP	GP,1		;REMAINDER,,ADDR OF BITS
	POPJ	GP,

;SCAN FOR HASH ARRAYS - ROUTINE TO XCT FOR EACH ENTRY FOLLOWS CALL

SCNHA:	MOVE 5,TYPBLK+ARRAYT
	HRRZ 4,TFRE(5)
	MOVEM 4,SCNEND
	HRRZ 4,TBGN(5)
SCNHA3:	CAML 4,SCNEND
	JRST RSKIP
	SKIPL 3,0(4)
	JRST SCNHA2		;NOT HASH ARRAY
	HLRZ 2,1(4)
	JUMPE 2,SCNHA2		;ARRAY NOT USED
	MOVNI 3,-2(3)
	HRLI 3,0(3)
	HRRI 3,2(4)
SCNHA1:	HLRZ 1,0(3)
	CAILE 1,1		;CHECK FOR UNUSED ENTRY
	XCT @0(GP)		;CALL ROUTINE - ARRAY 4,ELT 3, LEFT 1
	AOBJN 3,SCNHA1
	MOVEI 4,0(3)
	JRST SCNHA3

SCNHA2:	ADDI 4,0(3)
	JRST SCNHA3

U SCNEND


;FANCY HASH CHASE

HSHCH:	PUSHJ GP,CKMARK		;PTR MARKED?
	 JRST HSHCHR		;NO DONT BOTHE WITH VAL
	HRRZ 1,0(3)		;YES
	PUSHJ GP,CKMARK		;IS VAL ALREADY MARKED?
	 JRST .+2
	JRST HSHCHR		;YES - NOTHING TO DO
	TLO F,GCF		;NO - SET FLAG
	PUSH GP,3
	HRRZ 1,0(3)		;AND CHASE IT
	BCHASE
	POP GP,3
HSHCHR:	POPJ GP,

HSHREC:	PUSHJ GP,CKMARK
	JRST .+2
	JRST HSHCHR
	MOVSI 1,-2		;ENTRY UNSED - DELETE IT
	ADDM 1,0(4)
	MOVSI 1,1
	MOVEM 1,0(3)
	POPJ GP,


;ROUTINES TO CHECK IF VARIOUS TYPES MARKED
;THESE ARE ONLY USED BY HASH ARRAY SONG AND DANCE

CKMARK:	MOVEI 2,0(1)
	LSH 2,-11
	MOVE 2,TYPTAB(2)
	TLNE 2,SYSBIT
	JRST CKSKP
	HRRZ 2,TYPBLK(2)
	JUMPE 2,CKSKP		;NON EXISTENT TYPES(SMALL)ALWAYS MARKED
	JRST @TCKM(2)

CKBIT:	IFDEF MAXC,<BTLU 1,0>
IFNDEF MAXC,<PUSHJ GP,BTLU
	TDNE 1,0(2)>
CKSKP:	AOS 0(GP)
	POPJ GP,

CKAT:	PUSHJ GP,CKATM
	TDNE 2,0(1)
	AOS 0(GP)
	POPJ GP,

CKARR:	PUSH GP,3
	CALL FBA
	POP GP,3
	HLRZ 2,1(1)
	JUMPE 2,R
	JRST CKSKP

CKPN:	MOVE 2,0(1)
	TRNE 2,1
	AOS 0(GP)
	POPJ GP,

;GENERAL USER DATA TYPE

UCKMRK:	PUSH	GP,3
	PUSHJ	GP,UGTBIT	;GET THE BIT
	POP	GP,3
	TDNE	2,0(1)		;AND CHECK IT
	AOS	0(GP)
	POPJ	GP,

;SWEEP ALL PAGES OF FIXED SIZE, NON-CONTIGUOUS DATA TYPES
;LIST AND COUNT FREE ELEMENTS

SWPFX:	MOVSI 2,-NTYPN
SWPFA:	HRRZ 1,TYPBLK(2)	;LOOK FOR NON-CONTIG. TYPES
	JUMPE 1,SWPFB		;IGNORE TYPES IF TYPBLK 0
	MOVE 3,TBITS(1)
	TRNE 3,BCONT
	JRST SWPFB		;CONTIGUOUS TYPE
	SETZM TFRE(1)		;FIXED TYPE - SET FREE PTR 0
	SETZM TNFR(1)		;SET FREE COUNT 0
SWPFB:	AOBJN 2,SWPFA
	MOVE 2,BGNPAG		;GO THRU ALL ASSIGNED PAGES
SWPF2:	MOVE 10,TYPTAB(2)
	TLNE 10,SYSBIT
	JRST SWPF1		;DONT SWEEP SHARED PAGES
	MOVEI 10,0(10)		;GET TYPE
	HRRZ 7,TYPBLK(10)
	JUMPE 7,SWPF1		;TYPBLK 0 - IGNORE
	MOVE 1,TBITS(7)
	TRNE 1,BCONT
	JRST SWPF1
	CAIN 10,LISTT
	SETZM TFRE(7)
	PUSHJ GP,SWPPG		;CALL PAGE SWEEP
	CAIN 10,LISTT		;EXTRA WORK FOR LISTS
	HRLM 1,BTT(2)		;SAVE FRE PTR FOR PAGE
SWPF1:	AOBJN 2,SWPF2
	CAIN 2,HIPG+1		;DONE VCELLS YET?
	JRST SWPF4		;YES
	MOVE 2,VCPGS		;NO - DO EM
	JRST SWPF2
SWPF4:	MOVE 1,GCSTPT		;EXTRA STUFF FOR PTR TO NEW STRING
	MOVE 2,1		;CHECK FOR SPECIAL CASE
	TLZ 2,777770		;...NEW STRING, LENGTH 0
	IDIVI 2,5		;...AT END OF STORAGE
	CAMN 2,ENDSTR		;...ADDR IS OUTSIDE RANGE
	JRST SWPSP1
	PUSHJ CP,CHGSTR
SWPSP2:	MOVEM 1,GCSTPT
	POPJ GP,

SWPSP1:	SUBI 1,1		;FUDGE
	PUSHJ GP,CHGSTR
	ADDI 1,1
	JRST SWPSP2




;GENERAL SWEEP OF PAGE WITH FIXED SIZE ENTRIES AND BIT TABLE
;ENTER PAGE IN 2, TYPE IN 10
;RETURN NEW FREE POINTER IN 1 , PAGE IN 2, FREE COUNT THIS PAGE IN 3

SWPPG:	MOVE 7,TYPBLK(10)
	MOVE 6,[JRST SL2]
	TLNE F,GCMF+GCCF
	MOVE 6,TUDE(7)		;IF POINTERS NEED CHANGING
	MOVEM 6,SWPPJ		;SET SWPPJ TO UPDATE ROUTINE FOR TYPE
	HLRZ 5,TSIZ(7)
	MOVNI 3,NPS
	IDIVI 3,0(5)
	HRLI 5,101
	MOVE 7,TFRE(7)		;GET FREE POINTER

	PUSH GP,2
	MOVEI 4,0(2)
	LSH 4,LPS		;ADDR OF PAGE BEGINNING
	LSH	3,6		;LEAVE ROOM FOR 0-32 COUNTER
	HRLI 4,0(3)		;-NUMBER ENTRIEQ PER PAGE
	HRRZ 2,BTT(2)		;ADDR OF BIT TABLE FOR PAGE
	PUSH GP,2
	SETZ 3,
	SETZ 6,
SL1:	EXCH 6,@0(GP)		;PICK UP BITS AND CLEAR
SL4:	JUMPL 6,SWPPM		;DATUM MARKED
	AOJ 3,			;FREE - COUNT IT
	MOVEM 7,0(4)
	MOVEI 1,0(4)
	TLNE F,GCMF
	PUSHJ GP,CHGPT1
	MOVEI 7,0(1)
SL2:	LSH 6,1			;NEXT BIT
	ADD 4,5			;NEXT ENTRY
	JUMPGE 4,SWPP5		;END?
	TLZN	4,40		;NEXT BIT WORD?
	JRST SL4
	AOS 0(GP)
	JRST SL1

SWPPM:	XCT SWPPJ
	JRST SL2

U SWPPJ

SWPP5:	SUB GP,BHC+1
	MOVEI 1,0(7)
	MOVE 7,TYPBLK(10)
	MOVEM 1,TFRE(7)		;NEW FREE POINTER
	ADDM 3,TNFR(7)		;UPDATE FREECOUNT
	POP GP,2
	POPJ GP,

;SWEEPS OF SHARED PAGES THAT HAVE BECOME PRIVATE

;SWEEP SHARED ARRAY PAGE

SWPSAR:	PUSHJ GP,SCNSAR
	 PUSHJ GP,UDLIST
	POPJ GP,

;SWEEP SHARED LIST PAGE

SWPSL:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS
	PUSHJ GP,UDLIST
	AOBJN 4,.-1
	POPJ GP,

;SWEEP SHARED ATOM PAGE

SWPSAT:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS/3
	PUSHJ GP,UDATM
	ADDI 4,2
	AOBJN 4,.-2
	POPJ GP,

;SWEEP SHARED VALUE CELL PAGE

SWPSVC:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS
	PUSHJ GP,UDRITE
	AOBJN 4,.-1
	POPJ GP,

;SWEEP SHARED STRING POINTER PAGE

SWPSSP:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS
	PUSHJ GP,UDSTPT
	AOBJN 4,.-1
	POPJ GP,

;SWEEP SHARED USER DATA TYPE PAGE

SWPSUS:	HRRZ	10,TYPTAB(7)	;GET TYPE NUBMER
	HRRZ	3,TYPBLK(10)
	HLRZ	3,TSIZ(3)	;GET SIZE OF ITEM
	PUSH	GP,3		;AND SAVE IT
	MOVEI	4,NPS
	IDIVI	4,0(3)		;COMPUTE NUMBER OF ITEMS/PAGE
	PUSH	GP,4		;AND SAVE IT
	MOVEI	4,0(7)
	LSH	4,LPS
SWUS2:	PUSH	GP,4
	PUSHJ	GP,UDUSER	;UPDATE ITEM
	POP	GP,4
	ADD	4,-1(GP)	;BUMP ADDRESS
	SOSLE	0(GP)		;DECREMENT COUNTER
	JRST	SWUS2		;AND LOOP
	SUB	GP,BHC+2	;POP OFF JUNK
	POPJ	GP,

;SWEEP STACK - JUST CLEARS MARK BITS IF NO PTRS NEED CHANGING

SWPSTK:	HRRZ 1,ICP
SWPST4:	ADDI 1,1
SWPSTN:	HLRZ 5,0(1)		;HOLE?
	CAIN 5,STKHOL
	JRST SWPST2		;YES
	CAIN 5,STKEND		;END OF STACK?
	JRST SWPST5
	HRRZ 2,CF
	CAIE 2,-1(1)		;IS IT WHERE WE'RE RUNNING?
	JRST SWPST3
	HLRE 1,CP		;NO - MUST BE CURRENT STACK
	MOVN 1,1
	ADDI 1,1(CP)
	JRST SWPSTN
SWPST3:	MOVSI 2,FGCBIT
	ANDCAM 2,FGCWD(1)	;CLEAR MARK
	TLNN F,GCPF+GCCF	;PTRS CHANGING?
	JRST SWPST1		;NO
	PUSH GP,1
	PUSHJ GP,SWPFRM
	 PUSHJ GP,UDLIST
	 PUSHJ GP,UDRITE
	POP GP,1
SWPST1:	GETCPO 1,1
	JRST SWPST4

SWPST2:	HRRZ 5,0(1)		;HOLE LENGTH
	ADDI 1,0(5)
	JRST SWPSTN

SWPST5:	HRRZ 1,0(1)		;NEXT SECTION
	JUMPN 1,SWPST4		;IF ANY
	POPJ GP,

;UPDATE PTR IN RIGHT HALF OF WORD PTD TO BY 4

UDRITE:	HRRZ 1,0(4)
	PUSHJ GP,CHGPTR
	HRRM 1,0(4)
	POPJ GP,



;CHANGE POINTER IF ITS PAGE IS MOVING OR ITS TYPE IS COMPACTING OR BOTH
;ENTER AT CHGPT1 IF ONLY CONCERNED ABOUT PAGES MOVING
;POINTER IN 1 ON ENTRY AND EXIT

CHGPTR:	ROT 1,-LPS	;GET PAGE NUMBER
	TLNE F,GCCF	;IS SOMETHING COMPACTING??
	JRST CHGP2
CHGP3:	LDB 2,CHGPTP
	JUMPE 2,.+2
	HRRI 1,0(2)
CHGP4:	ROT 1,LPS
	POPJ GP,

CHGP2:	MOVE 2,TYPTAB(1)
	TLNE 2,SYSBIT
	JRST CHGP4
	MOVEI 2,0(2)
	CAME 2,CMPTYP
	JRST CHGP3
	ROT 1,LPS	;GET FULL POINTER BACK
	XCT CMPFN
CHGPT1:	ROT 1,-LPS	;NOW SEE IF NEW PAGE MOVES
	JRST CHGP3

;CHANGE POINTERS IN BOTH HALVES OF WORD IN 1 ON ENTRY AND EXIT

CHG2P:	PUSH GP,1
	HLRZ 1,1
	PUSHJ GP,CHGPTR
	EXCH 1,0(GP)
	HRRZI 1,0(1)
	PUSHJ GP,CHGPTR
	POP GP,2
	HRLI 1,0(2)
	POPJ GP,

;ROUTINES TO UPDATE POINTERS WITHIN VARIOUS DATA TYPES
;ADDRESS OF ELEMENT IN 4

;ATOMS
UDATM:	MOVE 1,0(4)
	PUSHJ GP,CHG2P
	MOVEM 1,0(4)
	HRRZ 1,1(4)
	PUSHJ GP,CHGPTR		;RIGHT HALF FUNCTION CELL
	HRRM 1,1(4)
	TLNE F,GCMF
	JRST UDA1		;PAGES SHUFFLING
	MOVEI 2,PNAMT
	CAME 2,CMPTYP
	POPJ GP,
UDA1:	HLRZ 1,2(4)		;OR PNAMES COMPACTING
	PUSHJ GP,CHGPTR		;CHANGE PNAME POINTER
	HRLM 1,2(4)
	POPJ GP,

;LIST

UDLIST:	MOVE 1,0(4)
	PUSHJ GP,CHG2P
	MOVEM 1,0(4)
	POPJ GP,

;STRING POINTERS

UDSTPT:	MOVE 1,0(4)
	PUSHJ GP,CHGSTR
	MOVEM 1,0(4)
	POPJ GP,

;GENERAL USER DATA TYPES
;TYPE NUMBER IN 10

UDUSER:	PUSH	GP,3
	PUSH	GP,4
	HRRZ	3,TYPSIZ(10)	;GET NUMBER OF POINTER ITEMS
UDS2:	SOJL	3,UDS3		;DEC. COUNT, EXIT IF DONE
	CDRA	1,4		;UPDATE CDR
	PUSHJ	GP,CHGPTR
	HRLM	1,0(4)
	SOJL	3,UDS3		;DECREMENT COUNT AND EXIT IF DONE
	CARA	1,4		;UDPATE CAR
	PUSHJ	GP,CHGPTR
	HRRM	1,0(4)
	AOJA	4,UDS2		;BUMP ADDRESS AND LOOP
UDS3:	POP	GP,4
	POP	GP,3
	POPJ	GP,

;GO THRU ALL PNAMES,
;CONSTRUCT A LIST THRU THE HOLES, LEFT HALF
;NUM OF EMPTIES SO FAR, RIGHT HALF PTR TO NEXT HOLE
;ALSO PUT POINTER TO FIRST HOLE OF A PAGE IN BTT
;AND COUNT IN LEFT HALF TYPTAB


P==6
PLANPN:	MOVEI 7,PNAMT
PLNPN1:	HRRZ 7,TYPBLK(7)
	MOVE 3,TBGN(7)		;FIRST PNAME WORD
	CAML 3,TEND(7)
	POPJ GP,		;NO PNAMES EXIST
	MOVEI 2,0(3)
	LSH 2,-LPS		;FIRST PAGE
	SETZ P,			;PTR TO LAST HOLE - INIT. 0
	MOVEI 10,-1(2)		;FLAG  = PAGE IF HOLE FOUND ON PAGE
	HRRZI 4,1
	HRRZI 5,SP7
SP6:	HLLOS BTT(2)		;-1 TO RIGHT BTT
SP3:	TDNN 4,0(3)		;CHECK BOTTOM BIT OF WORD
	JRST 0(5)		;NOT SET, HOLE BEGINNING OR CONTINUING
	ANDCAM 4,0(3)		;CLEAR MARK BIT
	HRRZI 5,SP7		;LOOKING FOR NEW HOLE
	AOJ 3,
SP8:	TRNE 3,MPS		;CHECK FOR END PAGE
	JRST SP3
	CAIE 10,0(2)		;ANY HOLES STARTED ON THIS PAGE?
	HLLM 3,BTT(2)		;NO - PUT COUNT IN LEFT BTT
	HRRZ 1,TEND(7)
	CAILE 1,0(3)		;END OF SPACE?
	AOJA 2,SP6		;NO, DO NEXT PAGE
	SKIPE P			;ANY HOLES AT ALL?
	HLLOM 3,0(P)		;YES - TERMINATE LIST
	HLRZ 3,3		;TOTAL EMPTY COUNT
	MOVNI 3,0(3)
	ADD 3,TEND(7)
	SUB 3,TBGN(7)
	MOVEM 3,TNWD(7)		;WORDS IN USE
	POPJ GP,
SP7:	JUMPE P,SP10		;FOUND HOLE - FIRST?
	MOVEM 3,0(P)		;NO - PUT COUNT,,HOLE PTR IN LAST
	CAIN 10,0(2)		;FIRST THIS PAGE?
	JRST SP9		;NO -
	SKIPA
SP10:	HRRM 3,BTT+1(10)	;ADDR FIRST HOLE TO BTT OF FIRST PAGE
	MOVEM 3,BTT(2)		;COUNT,,HOLE PTR TO BTT THIS PAGE
	MOVEI 10,0(2)		;FLAG HOLE SEEN THIS PAGE
SP9:	MOVEI 5,SP2		;LOOKING FOR END OF HOLE NOW
	MOVEI P,0(3)		;ADDR TO STORE NEXT COUNT,,HOLE-PTR
SP2:	AOBJP 3,SP8		;ALWAYS JUMPS

;SAME BUSINESS FOR STRINGS

PLNSTR:	MOVEI 7,STRNGT
	JRST PLNPN1

;CHANGE A PNAME TO VALUE IT WILL HAVE
;AFTER PNAMES GET COMPACTED
;PTR IN 1 RETURN WITH NEW POINTER IN 1 
CHGPN:	MOVEI 2,0(1)
	LSH 2,-LPS
	MOVE 2,BTT(2)		;COUNT,,PTR TO NEXT HOLE
CP2:	CAIG 1,0(2)
	JRST CP1
	MOVE 2,0(2)
	JRST CP2
CP1:	HLRZ 2,2	;PTR < NEXT HOLE
	SUBI 1,0(2)	;SUBTRACT COUNT FROM POINTER
	POPJ GP,

;CHANGE A STRING POINTER
;POINTER IN 1 ON ENTRY AND EXIT

CHGSTR:	PUSH GP,1		;SAVE STRING LENGTH
	TLZ 1,777770
	IDIVI 1,5		;GET ADDRESS OF STRING
	HRRM 2,0(GP)		;SAVE CHAR POS
	PUSHJ GP,CHGPTR
	IMULI 1,5
	POP GP,2
	AND 2,[XWD 777770,7]
	ADD 1,2
	POPJ GP,

;SWEEP ATOM HASH TABLE - MARK DELETED ENTRIES AND UPDATE POINTERS

SWPATH:	HRRZ 5,NHP
SWA5:	HRRZ 3,ATOMHT(5)
	MOVEI 1,0(3)		;UPDATE PAGE ADDR
	PUSHJ GP,CHGPTR
	HRRZM 1,ATOMHT(5)
	MOVEI 4,MPS
	HRLI 3,4		;L-1(4)
SWA1:	HRRZ 1,@3
	JUMPE 1,SWA3		;UNUSED ENTRY
	MOVEI 1,-2(1)		;HASH ENTRY -2 IS ATOM POINTER
	MOVEI 2,0(1)
	LSH 2,-LPS
	MOVE 2,TYPTAB(2)
	TLNE 2,SYSBIT
	JRST SWA3		;ON SHARED PAGE - STAYS
	PUSHJ GP,CKATM		;CHECK IF MARKED
	TDNE 2,0(1)
	JRST SWA4
	MOVSI 2,-1		;NOT MARKED - NO LONGER USED
	ADDM 2,ATOMHT		;DECREMENT COUNT OF ATOMS IN USE
	MOVSI 2,1
	MOVEM 2,@3		;FLAG HASH ENTRY AS RECLAIMED
SWA3:	SOJGE 4,SWA1
	SOJG 5,SWA5
	POPJ GP,

SWA4:	HRRZ 1,@3		;USED - CHANGE POINTER
	PUSHJ GP,CHGPTR
	HRRM 1,@3
	JRST SWA3


;MOVE PNAMES, IF NOT MOVING JUST UPDATE BEG, END AND FREE POINTERS

P==1
LW==2
C==3
H==4
B==5

MOVSTR:	MOVEI 1,STRNGT
	JRST MOVPN1

MOVPN:	MOVEI 1,PNAMT
MOVPN1:	MOVE 7,TYPBLK(1)
	CAME 1,CMPTYP
	JRST UDSP
	HRRZ 1,TEND(7)		;COMPUTE # WORDS FREE
	SUB 1,TBGN(7)
	SUB 1,TNWD(7)
	JUMPE 1,UDSP1		;NONE JUST UPDATE POINTERS
	HRRZ P,TBGN(7)	;FIRST PNAME WORD
	LSH P,-LPS	;FIRST PAGE
	HRRZI C,0		;COUNT
	HRRZI H,BTT(P)		;ADDR OF PTR TO FIRST HOLE
	JRST MPN2
MPN1:	HLRZ C,0(H)	;TOTAL EMPTIES INCLUDING THIS HOLE
	HRRZI B,0(LW)	;OLD LAST WORD
	ADDI B,0(C)	;PLUS EMPTY COUNT
	HRLI B,0(B)	;IS NEW BEG FROM
	HRRI B,0(LW)	;OLD LAST WORD IS NEW BEG TO
MPN2:	HRRZ LW,0(H)	;NEXT HOLE
	CAIN LW,-1	;IF IT EXISTS
	JRST MPN3
	HRRZ H,0(H)
	JUMPE C,MPN1
	SUB LW,C	;- EMPTY COUNT, IS LAST WORD TO
	BLT B,-1(LW)
	JRST MPN1

MPN3:	HRRZ P,TEND(7)		;NO MORE HOLES
	SUB P,C		;MOVE LAST CHUNK
	CAIE P,0(B)	;IF ANYTHING TO MOVE
	BLT B,-1(P)
	HRLI P,0(P)		;CLEAR FROM END-COUNT
	ADDI P,1
	HRRZ LW,TEND(7)		;... THRU END -1
	CAILE LW,-1(P)
	SETZM -1(P)
	CAILE LW,0(P)
	BLT P,-1(LW)
UDSP1:	MOVE 1,TNWD(7)
	ADD 1,TBGN(7)
	HRRM 1,TFRE(7)		;UPDATE FREE TO ACCT FOR COMPACTING
UDSPE:	MOVE 2,NNP		;UPDATE END TO ACCT FOR EXPANSION
	LSH 2,LPS
	ADDM 2,TEND(7)
	ADDM 2,TNFR(7)
UDSP:	MOVE 1,TBGN(7)		;UPDATE BEG,END AND FREE POINTERS
	PUSHJ GP,CHGPT1		;... FOR ARRAYS AND PNAMES
	MOVEI 2,0(1)		;... ACCTS FOR PAGE SHUFFLING ONLY
	EXCH 1,TBGN(7)
	SUBI 2,0(1)
	ADDM 2,TFRE(7)
	ADDM 2,TEND(7)
	POPJ GP,


;MOVE ARRAYS (IF ARRAYS NOT MOVING, JUST CLEARS GC PTRS)

MOVARR:	MOVEI 7,ARRAYT
	MOVE 7,TYPBLK(7)
	MOVE 4,TBGN(7)
MOVAR2:	CAML 4,TFRE(7)
	JRST MOVAR4
	HLRZ 1,1(4)		;GET GC POINTER - NEW LOC
	HRRZS 1(4)		;CLEAR IT
	MOVE 2,CMPTYP
	CAIE 2,ARRAYT		;ARRAYS COMPACTING?
	JRST MOVAR6
	MOVEI 2,0(4)		;REMOVE ARRAY FROM BTT
	LSH 2,-LPS
	HRRZ 3,BTT(2)
	CAIN 3,0(4)
	HLLZS BTT(2)		;IF IT WAS THERE
	JUMPE 1,MOVAR3	;0 MEANS UNUSED
	MOVEI 2,0(1)		;PUT NEW LOC IN BTT
	LSH 2,-LPS
	HRRZ 3,BTT(2)
	CAIN 3,0
	HRRM 1,BTT(2)		;IF ENTRY IS 0
MOVAR6:	JUMPE 1,MOVAR3
	HLRE 5,0(4)		;RELOCATABLE?
	JUMPLE 5,MOVAR7
	TLNN F,GCMF+GCCF	;SHUFFLING OR COMPACTING?
	JRST MOVAR3		;NO - DONE
	PUSH GP,1
	PUSHJ GP,CHGPT1		;... GET FINAL NEW LOC
	MOVEI 2,0(1)
	MOVEI 1,0(4)
	SUBI 2,0(4)		;RELOC FACTOR
	JUMPE 2,MOVAR8
	PUSH GP,7
	PUSH GP,4
	CALL RELI		;RELOCATE
	POP GP,4
	POP GP,7
MOVAR8:	POP GP,1
MOVAR7:	CAIN 1,0(4)		;OLD LOC=COMPACTED LOC?
	JRST MOVAR3		;YES - DONE
	HRLI 1,0(4)
	MOVEI 3,-1(1)
	ADD 3,@4
	ADD 4,@4
	BLT 1,0(3)		;MOVE IT
	JRST MOVAR3+1
MOVAR3:	ADD 4,@4
	HRRZI 4,0(4)	;CLEAR LEFT
	JRST MOVAR2

MOVAR4:	MOVE 1,CMPTYP
	CAIE 1,ARRAYT
	JRST UDSP
	MOVE 1,TBGN(7)	;CLEAR EMPTY REGION
	ADD 1,TNWD(7)
	MOVEM 1,TFRE(7)		;UPDATE FREE TO ACCT FOR COMPACTING
	CAML 1,TEND(7)
	JRST UDSPE		;NOTHING TO CLEAR
	SETZM 0(1)
	HRLI 1,0(1)
	ADDI 1,1
	MOVE 2,TEND(7)
	CAILE 2,1(1)
	BLT 1,-1(2)
	JRST UDSPE
;RELOCATE COMPILED CODE
;1 ADDRESS OF CODE, 2 INCREMENT

REL:	MOVE 1,2		;USER ENTRY
	CALL IUNBOX
	MOVE 2,1
	HRRZ 1,1(VP)
RELI:	HLRZ 3,0(1)		;INTERNAL ENTRY
	ADDI 3,0(1)		;ADDR OF RELOC BITS
	HRRZ 4,1(1)
	ADDI 1,0(4)
	MOVNI 4,-2(4)		;-LEN+2
	HRLI 1,4		;BEG+LEN(4)
REL3:	MOVEI 5,44		;36. BITS PER WORD
	MOVE 6,0(3)		;THE BITS
REL1:	JUMPE 6,REL4		;NO MORE RELOCATIONS THIS WORD
	TLNE 6,400000
	ADDM 2,@1		;RELOCATE
REL2:	LSH 6,1
REL5:	AOJGE 4,R
	SOJG 5,REL1
	AOJA 3,REL3

REL4:	ADDI 4,-1(5)
	MOVEI 5,0
	JRST REL5
;DECIDE WHERE ARRAYS WILL MOVE TO

PLANAR:	MOVE 7,TYPBLK+ARRAYT
	MOVE 2,TBGN(7)
	MOVEI 3,0(2)	;DESTINATION
PLNAR2:	CAML 2,TFRE(7)
	POPJ GP,
	HRRZ 4,0(2)	;GET LENGTH
	JUMPLE 4,GCERR		;LENGTH INSANE
	HLRZ 1,1(2)	;GET GC POINTER
	JUMPE 1,PLNAR3	;UNUSED
	CAIE 1,0(2)
	JRST GCERR		;ARRAYS FOULED
	HRLM 3,1(2)
	ADDI 3,0(4)	;INCREASE DESTINATION
PLNAR3:	ADDI 2,0(4)
	JRST PLNAR2

;CHANGE ARRAY POINTER

CHGARR:	PUSH GP,1
	PUSHJ GP,FBA		;FIND BEGINNING
	HLRZ 2,1(1)		;NEW BEGINNING
	SUBI 2,0(1)
	POP GP,1
	ADD 1,2
	POPJ GP,


;CHANGE POINTERS IN ARRAYS IF NECESSARY

SWPARR:	TLNN F,GCPF
	POPJ GP,
	MOVEI 5,ARRAYT
	MOVE 5,TYPBLK(5)
	MOVE 4,TBGN(5)
SWPAR2:	CAML 4,TFRE(5)
	POPJ GP,
	MOVEI 1,0(4)	;ARRAY POINTER
	MOVE 2,1(1)	;GC PTR,,REL.LOC.POINTERS
	TLZN 2,-1
	JRST SWPAR3	;UNUSED
	PUSHJ GP,SWP1AR		;FIND PTR WORDS IN ARRAY
	 PUSHJ GP,UDLIST	;AND UPDATE
SWPAR3:	SKIPL 0(4)
	JRST SWPAR4
	PUSH GP,4		;HASH  ARRAY GOTTA BE REEHASHED
	PUSH GP,5
	MOVEI 1,0(4)
	CALL REHSHG
	POP GP,5
	POP GP,4
SWPAR4:	HRRZ 2,0(4)
	ADDI 4,0(2)
	JRST SWPAR2

;FIND POINTERS IN SINGLE ARRAY - ADDR OF ARRAY IN 1
;INSTR FOLLOWING CALL XCT'D FOR EACH PTR WORD - ADDR IN 4

SWP1AR:	PUSH GP,4		;PRESERVE 4
	MOVEI 4,0(1)
	HRRZ 1,1(4)
	HLRE 2,0(4)	;REL.LOC.RELOCATION BITS
	JUMPG 2,.+2	;IF GREATER ZERO
	HRRZ 2,0(4)	;ELSE LENGTH
	ADDI 4,0(1)	;BEG OF POINTERS
	SUBI 1,0(2)	;REL.LOC. POINTERS-LENGTH
	JUMPE 1,SWP1AX	;NO POINTERS
	HRLI 4,0(1)	;IS -# OF POINTERS
SWPAR1:	XCT @ -1(GP)
	AOBJN 4,SWPAR1
SWP1AX:	POP GP,4
	AOS 0(GP)
	RET


;FIND HANDLE PAGES - CALL ROUTINE WITHE TYPTAB IN 3, PAGE IN 4

HDLPG:	MOVE 4,BGNPAG
HDLPG1:	HRRZ 3,TYPTAB(4)
	CAIE 3,HANDLT
	JRST HDLPG2
	MOVE 3,TYPTAB(4)
	PUSH GP,4
	XCT @-1(GP)
	POP GP,4
HDLPG2:	AOBJN 4,HDLPG1
	AOS 0(GP)
	RET


;GIVEN PAGE OF HANDLES, CHASE ALL PTRS ON SYS/PVT PAGES

SHRSHC:	MOVEI 2,CHLIST	;CHASE PTRS IN SYS/PVT PAGES OF SHADOW
	JRST SYSHDA

;UPDATE PTRS IN SYS/PVT SHADOW ARRAYS GIVEN HANDLE PAGE

SWPHDA:	MOVEI 2,UDLIST
;GIVEN PAGE OF HANDLES, CALL C(2) FOR EACH PTR IN SYS/PVT SHADOW

SYSHDA:	MOVEM 2,SYSHDR
	TLNN 3,SYSBIT		;IS HANDLE PAGE SYSTEM?
	RET		;NO - ASSUME CANT REF. SYS ARRAYS
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
SYSHD1:	MOVE 1,0(5)		;GO THRU HANDLES
	TLNN 1,-1
	JRST SYSHD2		;NOT REASONABLE HANDLE
	PUSH GP,5
	HRLI BR,(5)		;RETRIEVE THE (BOXED) HANDLE.
	CALL SCNSSA
	 PUSHJ GP,@SYSHDR
	POP GP,5
SYSHD2:	AOBJN 5,SYSHD1
	RET
U SYSHDR



;FIND STACK PTR PAGES - CALL ROUTINE W/ PG IN 7
;AOBJN PTR FOR IT IN 3

STKPPG:	MOVE 7,BGNPAG
STKPP1:	HRRZ 6,TYPTAB(7)
	CAIE 6,STKPT
	JRST STKPP2
	MOVEI 3,0(7)
	LSH 3,LPS
	HRLI 3,-NPS
	XCT @0(GP)
STKPP2:	AOBJN 7,STKPP1
	AOS 0(GP)
	RET

;FIND UNMARKED STK PTRS AND FLUSH ASSOCIATED STACK

STKFLQ:	MOVE 2,TYPTAB(7)
	TLNE 2,SYSBIT
	RET			;ALL SYS ONES STAY
STKFL1:	HRRZ 1,0(3)
	JUMPE 1,STKFL2
	LDT 2,1
	CAIE 2,STACKT
	JRST STKFL2
	MOVEI 1,0(3)
IFDEF MAXC,<BTLU 1,0>	; Marked?
IFNDEF MAXC,<PUSHJ GP,BTLU
	TDNE 1,0(2)>
	JRST STKFL2		;YES
	HRRZ 2,0(3)		;GET PTR 
	CALL FLFR		;FLUSH THE FRAME
STKFL2:	AOBJN 3,STKFL1
	RET

;CALLED BY RESET TO EXPUNGET STACK POINTERS

FLSTKP:	HRRZ 1,0(3)
	JUMPE 1,FLSTK2
	LDT 2,1
	CAIN 2,STACKT
	SETZM 0(3)
FLSTK2:	AOBJN 3,FLSTKP
	RET

;SCAN SYSTEM SHADOW ARRAYS, GIVEN UNBOXED HANDLE OF ARRAY IN 1
;ALSO BOXED HANDLE IN LH OF BR TO GIVE TO SWAPIN.
;FIND ALL POINTERS ON PAGES MADE PRIVATE, XCT FOLLOWING INST.
;WITH ADDR OF PTR WORD IN 4

SCNSSA:	MOVE 4,1		;HANDLE
	LDB 3,[POINT 9,4,8]	;GET # PAGES SPANNED??
SCNSS1:	CALL GFRKB
	TRNN 2,FSYSBT
	JRST .+3		;SHOULDNT BE REFS TO NON SYS PGS.
	TRNE 2,FPVTBT
	JRST SCNSS2
	ADDI 1,NPS
	SOJG 3,SCNSS1
	JRST SCNSSX		;NO PVT PAGES IN ARRAY

SCNSS2:	PUSH GP,4		;HANDLE
	PUSH GP,1		;ADDR OF FIRST PVT FORK PAGE
	MOVE 1,4
	TLO F,HDLFLG		;PREVENT RECURSION IN HANDLE CHASE
	CALL SWAPIN
	HRRZI 1,(BR)		;ADDRESS IN BUFFER WHERE IT GOT PUT.
	HLRE 6,0(1)		;GET END PTRS
	JUMPG 6,.+2
	HRRZ 6,0(1)
	JUMPLE 6,SCNSS7		;NO GOOD ARRAY
	ADDI 6,0(1)		;ADDR END PTRS IN CORE
	HRRZ 4,1(1)
	ADDM 4,-1(GP)		;ADDR BEG PTRS IN FORK
	ADDI 4,0(1)		;ADDR BEG PTRS IN CORE
	POP GP,5
	TRZ 5,777
SCNSS6:	MOVE 1,0(GP)
	CAMLE 5,1
	JRST SCNSS3		;IGNORE INITIAL NONPVT PAGES
	CALL GFRKB
	TRNN 2,FPVTBT
	JRST SCNSS3		;@AGE NOT PVT
	MOVEI 7,NPS(4)		;IS PVT
	TRZ 7,777
	CAIL 7,0(6)		;END PG PAST END PTRS?
	MOVEI 7,0(6)		;YES - QUIT AT END PTRS
SCNSS4:	CAIL 4,0(7)
	JRST SCNSS5
	XCT @-1(GP)
	AOJA 4,SCNSS4

SCNSS3:	ADDI 4,NPS		;STEP TO NEXT PAGE
	TRZ 4,777
SCNSS5:	MOVEI 1,NPS
	ADDM 1,0(GP)
	CAIGE 4,0(6)
	JRST SCNSS6
	TLZ F,HDLFLG
	SUB GP,BHC+1
SCNSSX:	AOS 0(GP)
	RET

SCNSS7:	SUB GP,BHC+2
	JRST SCNSSX


;GIVEN HANDLE PAGE SWEEP NON-SYSS SHADOW ARRAYS

SWPUHD:	MOVE 1,[PUSHJ GP,HDCHP]
	MOVE 2,[PUSHJ GP,CHLIST]
	JRST SWPUSA

;UPDATE PTRS IN NON-SYS SHADOW ARRAYS

SWPHDB:	MOVSI 1,(SKIPA)
	MOVE 2,[PUSHJ GP,UDLIST]
	JRST SWPUSA

HDCHP:	TLOE 1,HDLCHS
	RET			;ALREDY CHASED - IGNORE
	MOVEM 1,0(5)		;MARK IT
	AOS 0(GP)
	RET

;SWEEP OF NON-SYSTEM SHADOW ARRAYS
;GIVEN HANDLE PAGE IN 4, TYPTAB FOR PG IN 4
;CALL FOR HANDLE CHECK IN 1, CALL FOR WHAT TO DO TO  PTRS IN 2

SWPUSA:	TLNE 3,SYSBIT
	RET			;IGNORE SYSTEM HANDLES
	PUSH GP,1
	MOVEM 2,SWPUSR
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
SWPUS3:	MOVEI 1,0(5)
	CALL CKBIT
	 JRST SWPUSN		;HANDLE NOT USED
	MOVE 1,0(5)
	TLNN 1,-1
	JRST SWPUSN		;HANDLE NONESENSE
	CALL GFRKB
	TRNE 2,FSYSBT
	JRST SWPUSN		;IGNORE SYSTEM ARRAYS - SHOULD BE NONE
	XCT 0(GP)		;SKIP IF HANDLE WANTED
	JRST SWPUSN
	PUSH GP,5
	PUSH GP,3
	TLO F,GCF+HDLFLG
	HRLI BR,(5)
	CALL SWAPIN
	HRRZI 1,(BR)
	PUSHJ GP,SWP1AR
	XCT SWPUSR
	TLZ F,HDLFLG
	POP GP,3
	POP GP,5
SWPUSN:	AOBJN 5,SWPUS3
	SUB GP,BHC+1
	RET

U SWPUSR

FSYSBT==1
FPVTBT==2		;BITS IN FORK SYSBIT TABLES

;GIVEN FORK#,,ADDR IN 1, GET BITS IN 2 (PRESERVE 1)
;NOTE THAT'S A FORK NUMBER, NOT A HANDLE BUT A SWFRKS TABLE INDEX

GFRKB:	PUSH GP,1
	HLRZ 2,1
	ANDI 2,MFRKS
	MOVEI 1,0(1)
	LSH 1,-LPS
	HRRZ 2,FORKT(2)
	ROT 1,-4
	ADDI 2,0(1)
	HRRI 1,0
	ROT 1,5
	MOVE 2,0(2)
	ROT 2,2(1)
	ANDI 2,3
	POP GP,1
	RET

;GIVEN FORK#,,PAGE IN 1 BITS IN LOW 2
;SET FORK BITS (PRESERVE 1)  ... THIS IS USED BY WTRP

SFRKB:	PUSH GP,1
	PUSH GP,3
	HLRZ 3,1
	MOVEI 1,0(1)
	HRRZ 3,FORKT(3)
	ROT 1,-4
	ADDI 3,0(1)
	HRRI 1,0
	ROT 1,5
	MOVNI 1,2(1)
	ROT 2,0(1)
	IORM 2,0(3)
	POP GP,3
	POP GP,1
	RET

U FORKT,NFRKS		;CONTAINS ADDR OF BITS FOR FORK PGS
			;REMEMBER TO SET THIS UP AND PUT BITS
			;ON WRITABLE PAGES!!!!!


;CLEAR CHASED BITS FROM HANDLES

HDLCLR:	TLNE 3,SYSBIT		;NON-SYS PAGES ONLY
	RET
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
	MOVSI 2,HDLCHS
	ANDCAM 2,0(5)
	AOBJN 5,.-1
	RET


;GRAB AN UNASSIGNED PAGE
;AND N WORDS OF BIT TABLE--N IN AC1
;RETURN PAGE NUMBER IN 4
;SKIP IF SUCCESSFUL IN FINDING A PAGE

U FREEBT	;NEXT FREE WORD OF BIT TABLE STORAGE
U ENDBT		;LAST FREE WORD OF BIT TABLES

MTPGB:	PUSH GP,1
	PUSHJ GP,MTPG
	 JRST MTPGR
MTPGB2:	MOVE 1,FREEBT
	ADD 1,0(GP)
	CAMLE 1,ENDBT
	JRST MTPGB1	;NEED A NEW BIT TABLE PAGE
	EXCH 1,FREEBT
	MOVEM 1,BTT(4)
	AOS -1(GP)	;RETURN SKIPPING
MTPGR:	SUB GP,BHC+1	;POP
	POPJ GP,

MTPGB1:	PUSH GP,4	;SAVE FIRST PAGE FOUND
	PUSHJ GP,MTPG
	 JRST MTPGB3
	MOVEI 1,BTABT
	MOVEM 1,TYPTAB(4)
	MOVEI 1,0(4)
	LSH 4,LPS
	MOVEM 4,FREEBT
	ADDI 4,NPS
	MOVEM 4,ENDBT
	PUSHJ GP,CLRPG
	POP GP,4
	JRST MTPGB2

MTPGB3:	POP GP,4	;NO PAGE FOR BITTABLE 
	SETZM TYPTAB(4)	;,RELEASE PAGE PREVIOUSLY CLAIMED
	JRST MTPGR


;GET A NEW PAGE WITH BIT TABLE AND INITIALIZE TO FREE LIST
;ENTER WITH OLD FREE POINTER IN 1 AND NEW C(TYPTAB(PAGE)) IN 2
;RETURN WITH NEW FREE POINTER IN 1,2 UNCHANGED
;AND SKIP IF SUCCESSFUL

NEWPG:	MOVEI 3,1		;ONE WORD ENTRIES
NEWPGG:	PUSH GP,1		;ENTRY SIZE IN 3
	PUSH GP,2
	PUSH GP,3
	CAIN 2,VCELLT
	JRST NEWPV
	MOVEI 1,NPS
	IDIVI 1,0(3)
	ADDI 1,37
	LSH 1,-5		;NUMBER BIT TABLE WORDS
	PUSHJ GP,MTPGB
NEWPG2:	 JRST NEWPF
	POP GP,3
	POP GP,2
	CAIE 2,VCELLT
	JRST NEWPG3
	MOVN 1,BHC+1
	ADDM 1,VCPGS
	HRLI 2,FIXBIT
NEWPG3:	MOVEM 2,TYPTAB(4)
	POP GP,1
	AOS 0(GP)	;SET TO SKIP
FREPG:	LSH 4,LPS	;MAKE FREELIST
	MOVEI 5,NPS(4)	;PAGE IN 4
	HRLI 4,3	;ENTRY SIZE IN 3
	MOVNI 3,0(3)
	JRST .+ 2
FRE1:	HRRZM 4,@4
	SUB 4,3
	CAILE 5,0(4)
	JRST FRE1
	CAIE 5,0(4)
	ADD 4,3
	MOVEM 1,@4	;FREE POINTER IN 1
	MOVEI 1,-NPS(5)	;NEW FREEPOINTER TO 1
	POPJ GP,

NEWPF:	SUB GP,BHC+3
	POPJ GP,

NEWPV:	HRRZ 4,VCPGS		;TRY TO GET PG BELOW LOWEST
	SUBI 4,1
	SKIPE TYPTAB(4)		;FREE?
	JRST NEWPF		;NO GIVE UP (THIS AINT RIGHT)
	MOVEI 1,77		;RESERVE THE PAE
	MOVEM 1,TYPTAB(4)
	PUSH GP,[NEWPG2]	;FAKE A CALL TO MTPGB
	PUSH GP,[NPS/40]	;# BIT TABLE WDS
	JRST MTPGB2


;INITIALIZE TABLES AND STUFF FOR GC

GCI:	SETZM TYPBLK		;CLEAR TYPBLK
	HRLI 1,TYPBLK
	HRRI 1,TYPBLK+1
	BLT 1,TYPBLK+MTYPN
	SETZM BTT
	HRLI 1,BTT
	HRRI 1,BTT+1	;CLEAR BITTABLE TABLE
	BLT 1,BTT+NPM-1
	SETZM FREEBT	;SET AVAIL BIT TABLE STORAGE TO EMPTY
	SETZM ENDBT
	SETZM	IBOXCN
	SETZM	FBOXCN
	SETZM CNSCNT
	SETZM SYSPGS
	SETZM FORKBT		;CLEAR FORK BIT TABLES
	HRLI 1,FORKBT
	HRRI 1,FORKBT+1
	BLT 1,FORKBT+NFRKBT-1
	MOVEI 1,FORKBT		;SET UP PTRS TO TABLES
	MOVSI 2,-NFRKS		;NOTE ARE HAVIN FORK 0 WHICH IS A CROCK
	HRRZM 1,FORKT(2)
	ADDI 1,40
	AOBJN 2,.-2
	MOVEI 1,XTRATB
	MOVEM 1,FREETB
	ADDI 1,NTB
	MOVEM 1,ENDTB
	CALL GETPG		;RESERVE A PAGE FOR GC SLOP
	 HALTF
	LSH 1,-LPS
	MOVEM 1,RESPG		;REMEMBER RESERVED PAGE
	MOVEI 2,2
	MOVEM 2,TYPTAB(1)
 	MOVE 1,BGNCOR
	LSH 1,-LPS
	HRRM 1,BGNPAG
	MOVE 2,ENDCOR
	LSH 2,-LPS
	SUB 1,2
	HRLM 1,BGNPAG
	MOVEI 1,HIPG+1
	MOVEM 1,VCPGS		;NO PAGES ALLOCATED YET
	TYPSET ATOM
	TYPSET LIST
	TYPSET FLOAT
	TYPSET FIX
	TYPSET STPT
	TYPSET STRNG
	TYPSET ARRAY
	TYPSET PNAM
	TYPSET HANDL
	TYPSET STKP
	TYPSET VCELL
GCIS:	SETZM NEWCNS
	SETZM FRELST
	SETZM LSTCNS
	HRRZ 4,BGNSTR
	HRLI 4,440700
	MOVEM 4,FREEST
	MOVE 4,ENDSTR
	SUB 4,BGNSTR
	IMULI 4,5
	MOVEM 4,NFRECH
	RET

	LIT		;GET THESE IN BEFORE BEGTMP!!!!!
GCIE:

NFRKBT==NFRKS*40		;FORK BIT TABLES - 2 BITS PER PAGE

U RESPG			;RESERVED PAGE - FOR XTRA ROOM WHEN STORAGE FULL
U FORKBT,NFRKBT

;LAST PAGE

U ENDTMP		;END OF TEMP STORAGE

	END LISP0


