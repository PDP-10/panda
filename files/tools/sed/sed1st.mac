TITLE	SED1ST - SED TOPS10/TOPS20 SCREEN EDITOR - STARTUP, MAIN LOOP, TYPE-IN
SUBTTL	A CHRISTOPHER HALL FECIT

	SEARCH	SEDSYM
	SALL

IF1,<
IFE TOPS10,<PRINTX TOPS10==0  Assembling SED for TOPS-20>
IFN TOPS10,<PRINTX TOPS10==1  Assembling SED for TOPS-10>
IFE FTIMD,<PRINTX FTIMD==0   Insert-mode words must not exist in TTY output tables>
IFN FTIMD,<PRINTX FTIMD==1   Insert-mode words must exist in TTY output tables>
IFE FTLSR,<PRINTX FTLSR==0   Limited-scroll words must not exist in TTY output tables>
IFN FTLSR,<PRINTX FTLSR==1   Limited-scroll words must exist in TTY output tables>
IFE FTJOUR,<PRINTX FTJOUR==0  Journaling code is NOT included>
IFN FTJOUR,<PRINTX FTJOUR==1  Journaling code is included>
IFE FTDDT,<PRINTX FTDDT==0   DDT switch is OFF>
IFN FTDDT,<PRINTX FTDDT==1   DDT switch is ON>
IFE NEWTAB,<PRINTX NEWTAB==0  Using old-style command arrangement>
IFN NEWTAB,<PRINTX NEWTAB==1  Using new-style command arrangement>

IFN TOPS10,<
IFE FTKA10,<PRINTX FTKA10==0  Generating code for a KI or KL processor>
IFN FTKA10,<PRINTX FTKA10==1  Generating code for a KA processor>
IFE FTTMPC,<PRINTX FTTMPC==0  Not generating code to use TMPCOR>
IFN FTTMPC,<PRINTX FTTMPC==1  Generating code to use TMPCOR>
IFE FTSFD,<PRINTX FTSFD==0   SFD support not included>
IFN FTSFD,<PRINTX FTSFD==1   SFD support included>
>
IFE TOPS10,<
IFE FTSTSN,<PRINTX FTSTSN==0  SED will not be added to the subsystem table>
IFN FTSTSN,<PRINTX FTSTSN==1  SED will be added to the subsystem table>
IFE FTECHO,<PRINTX FTECHO==0  SED will echo printing characters itself>
IFN FTECHO,<PRINTX FTECHO==1  SED will let the monitor echo printing characters>
;IFE FTLOKF,<PRINTX FTLOKF==0  Not including code to lock files against others>
;IFN FTLOKF,<PRINTX FTLOKF==1  Including code to lock files against others>
>
> ;END IF1

IFN TOPS10,<
	TWOSEG
	LOC	134
	INTERR
	LOC	137
	BYTE	(3)CUSTVR (9)HALVER (6)HALMVR (18)HALEVR
	RELOC	400000

	SEARCH	UUOSYM
>
IFE TOPS10,<
	SEARCH	MONSYM

ENTVEC::JRST	START		;START ADDR, REEENT ADDR, AND VERSION
	JRST	START
	BYTE	(3)CUSTVR (9)HALVER (6)HALMVR (18)HALEVR
ENTLEN==.-ENTVEC
>
	EXTERN	TERMNL
	EXTERN	.JBREL,.JBAPR,.JBTPC,.JBREN,.JBFF

START::	JFCL			;(TO ACCOUNT FOR CCL ENTRY)
	RESET			;MAKE SURE THE WORLD IS RIGHT
STARTR::MOVE	P,[IOWD STKSIZ,STACK]
	SETOM	STTFLG		;SAY SED IS INITIALIZING
IFE TOPS10,<
IFN FTECHO,<
	HRRZM	P,EKOFLG	;MAKE SURE THE ECHO
	HRRZM	P,BRKFLG	;  AND BREAK FLAGS ARE POSITIVE
>
	MOVEI	T1,PARBUF+37	;MAKE SURE THE BUFFER IS HIGH ENOUGH
	CAIGE	T1,BUFBLK_11	;IS IT?
	JRST	START0		;YES - PROCEED
	HRROI	T1,[ASCIZ /?FATAL GLITCH: Add 1 to BUFBLK (in SED1DT) and reassemble SED
/]
	PSOUT
	HALTF			;THE WORLD WON'T BE RIGHT UNTIL IT'S FIXED
START0:
IFN FTSTSN,<
	MOVE	T1,[SIXBIT /SED/] ;ENTER SED IN THE SUBSYSTEM TABLE
	MOVE	T2,T1
	SETSN
	  JFCL
>
	HRRZ	T1,.JBREL	;FIND BLOCK SIZE OF STARTING FILE BUFFER
	SUBI	T1,BUFFER-1000	;  PLUS SYMBOL TABLE, ETC.
	LSH	T1,-11		;(EXPRESS IT IN BLOCKS)
	MOVEM	T1,FILBSZ	;SAVE IT
>
	MOVE	TY,TYPPTR	;SET UP TYPE BUFFER POINTER
	PUSHJ	P,INITTY	;MAKE THE EDITOR RECEIVE WHAT'S REALLY TYPED
	MOVEI	T1,XBFNUM-1	;MAKE LAST (NULL) EXECUTE BUFFER ACTIVE
	MOVEM	T1,XCTACW
	MOVE	T1,[010700,,XCTFRE-1]
	MOVEM	T1,XCFPTR	;SAVE POINTER TO START OF FREE SPACE
	ADDI	T1,XCFSIZ	;AND END OF F.S. FOR OVERFLOW CHECKING
	MOVEM	T1,XCTOVF
	MOVEI	T1,1		;SET UP NOMINAL FOR EXECUTE COUNTER
	MOVEM	T1,XCTSNM
	MOVEM	T1,XCTITR	;SET UP NUMBER OF TIMES TO ITERATE AN EXECUTE
	SETZM	CLSBUF+400	;CLEAR COUNT OF /DC SETTINGS
	HRLOM	P,ISVNUM	;START THE INCREMENTAL SAVE COUNTERS
	HRLOM	P,SAVNUM	;WITH LARGE NUMBERS
	SETOM	SLDFLG
	SETOM	BAKFLG
	SETOM	GOPRCT
	SETZB	F,UPPFLG	;UPPER CASE FLAG IS INITIALLY OFF
	SETZB	TM,PREDP	;SAY THERE'S NO PRE-SET DISPLAY POINTER
	MOVE	EN,[350700,,BUFFEN] ;SET UP THAT "WELCOME TO SED" MESSAGE
	SETZ	SL,		;CLEAR SLIDE OFFSET
IFN TOPS10,<
IFN FTSFD,<
	MOVE	T1,[SFDLVL+4,,DEFPTH]
	PATH.	T1,		;READ STARTING PATH
	  JFCL
	MOVEI	T1,SFDLVL
START1:	MOVE	T2,DEFPTH+2(T1)	;SET UP AS DEFAULT FILE PATH
	MOVEM	T2,FILPTH+2(T1)	;AND AS CURRENT PATH
	MOVEM	T2,OLDPTH+2(T1)	;AND AS ALTERNATE PATH
	MOVEM	T2,SVAPTH+2(T1)	;AND AS SAVED PATH
	SOJGE	T1,START1
>
	SETZ	T4,
	GETPPN	T1,		;GET USER'S PPN
	  JFCL
	MOVEM	T1,USRPPN	;SAVE IT FOR FUTURE REFERENCE
	PJOB	T1,		;GET JOB NUMBER FOR .TMP FILES
	MOVE	PT,[POINT 6,T4,17]
	IDIVI	T1,^D100	;CONVERT NUMBER TO 3 SIXBIT DIGITS
	IDIVI	T2,^D10		;IN RH OF T4
	IDPB	T1,PT
	IDPB	T2,PT
	IDPB	T3,PT
	ADDI	T4,'000'
	HRLM	T4,PIKFIL	;SET UP AS PICK FILE NAME (nnnPIK)
	HRLM	T4,CLSFIL	;AND AS CLOSE FILE NAME   (nnnCLS)
	HRLM	T4,SEDFIL	;AND AS STAT FILE NAME	  (nnnSED)
>
IFE TOPS10,<
	GJINF			;GET T2/DIRECTORY NUMBER, T3/JOB NUMBER
	MOVE	T2,T1		;TRANSLATE DIRECTORY NUMBER INTO A STRING
	HRROI	T1,USRNAM	;  IN USRNAM
	DIRST
	  JFCL			;FAILED - NO PROBLEM
	SETZ	T4,
	MOVE	T1,T3		;MOVE JOB NUMBER TO T1
	MOVE	PT,[POINT 7,T4]
	IDIVI	T1,^D100	;CONVERT NUMBER TO 3 ASCII DIGITS
	IDIVI	T2,^D10		;IN LH OF T4
	IDPB	T1,PT
	IDPB	T2,PT
	IDPB	T3,PT
	ORM	T4,PIKFIL	;SET UP AS PICK FILE NAME (nnnPIK)
	ORM	T4,CLSFIL	;AND AS CLOSE FILE NAME   (nnnCLS)
	ORM	T4,SEDFIL	;AND AS STAT FILE NAME	  (nnnSED)
>
	HRRZM	P,SAVEAC+11	;SET SET-FILE'S R-W FLAG POSITIVE (IE, NONE)
	PUSHJ	P,TABINI	;INITIALIZE THE TAB TABLE
	MOVE	TM,TERMNL	;SET UP THE RIGHT TYPE OF TERMINAL
	PUSHJ	P,REDSWH	;READ SWITCH.INI, IF INI
	PUSHJ	P,REDTMP	;AND nnnSED.TMP, IF ANY
	PUSHJ	P,RSCANL	;IF USER ENTERED WITH FILESPECS SET THEM UP

;THE ERROR ROUTINE JUMPS TO INIERR WHEN THERE IS AN ERROR IN THE COMMAND
;LINE (LIKE A BAD SWITCH). IT GOES TO REDNO (BELOW) WHEN THE USER HAS ERRED
;WHILE EDITING THE CHEERY MESSAGE.

INIERR::PUSHJ	P,@RTE(TM)	;CALL TERMINAL'S ENTRY ROUTINE
	HRLZ	T1,TCH(TM)	;GET TERMINAL-SPECIFIC FLAGS
	OR	TM,T1		;SET THEM UP
	SKIPN	RUP(TM)		;CAN TERMINAL ROLL UP?
	TRO	F,NRC		;NO - DON'T AUTOMATICALLY ROLL FROM LAST LINE
IFN FTJOUR,<
	SETZM	JRNBIT		;MAKE SURE JOURNAL FLAG IS CLEAR
	SKIPN	JRNFLG		;WANT TO RESTORE A JOURNAL?
	JRST	JRSTNO		;NO - SKIP THIS
	TLO	TM,JRC		;YES - SAY JOURNAL RESTORE IS HAPPENING
	SKIPN	XSHFLG		;WANT TO DISPLAY THE EXECUTE?
	TROA	F,XCT		;NO - JUST DISPLAY WHEN DONE
	TRO	F,XBN		;YES - SET UP SHOW IT ALL
	SETZM	XSHFLG		;CLEAR EXECUTE DISPLAY FLAG
	TLZE	TM,JRW		;DON'T JOURNAL WHILE RECOVERING - WANT TO?
	SETOM	JRNBIT		;YES - REMEMBER FOR LATER
	PUSHJ	P,JRNGET	;SET UP AND READ THE JOURNAL
JRSTNO:
>
	PUSHJ	P,INITT1	;DO TTY INIT STUFF WHICH COMES AFTER ENTRY RTN
	MOVE	T1,LPP(TM)	;GET LINES PER ROLL
	MOVEM	T1,LPP.0	;SAVE IN CASE OF CHANGE
	PUSHJ	P,SETLPP
	MOVE	T1,CPL(TM)	;SET UP CHARACTERS PER LINE VARIABLES
	MOVEM	T1,CPL.0	;SAVE IN CASE OF CHANGE
	SOJ	T1,
	MOVEM	T1,CPL.1
	SKIPN	RMARGN		;HAS THE USER SET THE RIGHT MARGIN?
	MOVEM	T1,RMARGN	;NO - SET IT AT THE RIGHT OF THE SCREEN
	MOVEM	TM,SAVFLG	;SAVE TERMINAL FLAGS

	HRRE	T3,STTFLG	;HAS THE TERMINAL LENGTH CHANGED?
	CAIL	T3,0
	PUSHJ	P,SWHLPP	;YES - SET IT IN THE RIGHT TABLE
	HLRE	T3,STTFLG	;HAS THE TERMINAL WIDTH CHANGED?
	CAIL	T3,0
	PUSHJ	P,SWHWID	;YES - SET IT IN THE RIGHT TABLE
	SETZM	STTFLG		;SAY NO LONGER INITIALIZING
	PUSHJ	P,CMDSET	;SET UP CHANGES TO COMMAND TABLE, IF ANY
	PUSHJ	P,SETXCB	;LIKEWISE EXECUTE BUTTONS, IF ANY, IN NEW TABLE

IFE TOPS10,<
IFN FTECHO,<
	MOVE	T3,RMARGN	;GET THE REAL RIGHT MARGIN
	PUSHJ	P,SWHRM1	;SET UP THE FIELD WIDTH
>>
	PUSHJ	P,RSTNOM	;SET UP DEFAULT PARAMETERS
	SKIPE	RSCANF		;GOT A FILE FROM RESCAN?
	JRST	SETSCN		;YES - SET IT UP AND GO TO LOOP1
	SKIPN	FILSPC		;GOT A FILE FROM nnnSED.TMP?
	JRST	REDNO		;NO - START OUT WITH CHEERY MESSAGE
INDIRE::PUSH	P,TM		;YES - DISABLE ERROR MESSAGES
	SETZ	TM,
	PUSHJ	P,PARSEF	;PARSE THE FILESPECS
	POP	P,TM
	MOVE	DO,[400000,,$SETFI]
	JRST	SETFL1		;AND GO SET UP THAT FILE

REDNO::	PUSHJ	P,PNTSTT	;ELSE DISPLAY CHEERY MESSAGE
NEWFIL::TLZ	F,ENT!CHG	;FILE UNCHANGED; ENTER OFF
	TLO	F,XPB		;LAST-LINE POINTER IS INVALID
IFE TOPS10,<
	SKIPN	ITTFLG		;HAS CHARACTER TRAPPING BEEN TURNED OFF?
	PUSHJ	P,INITTF	;NO - DO IT NOW
>
	DMOVE	T1,ISVNUM	;SET UP # OF COMMANDS BETWEEN ISAVES
	DMOVEM	T1,ISVCNT	;AND # OF TYPEIN CHARS BETWEEN SAVES
	MOVEI	T1,SQZVAL	;SET UP # OF COMMANDS TO SKIP BETWEEN SQUEEZES
	MOVEM	T1,SQZCNT
	CAMN	EN,[010700,,BUFFER-1] ;ANYTHING IN THE BUFFER?
	JRST	LOOP		;NO - DON'T TRY TO DISPLAY IT
	SKIPL	T1,GOPRCT	;YES - WANT TO START SOME PERCENT IN?
	JRST	[MOVEM T1,GOPERC ;YES - SET UP THE RIGHT PERCENT
		 SETOM GOPRCT	 ;FORGET THAT IT WAS GIVEN
		 SETZ  DO,
		 JRST  PERNPM]	 ;AND LET THE PERCENT COMMAND DO THE DISPLAY
NEWFL0::SKIPN	DSPFLG		;WANT TO OMIT STARTING DISPLAY?
	PUSHJ	P,DISPLL	;NO - DISPLAY A SCREENFUL
	SETZM	DSPFLG		;CLEAR OMIT-DISPLAY FLAG
	TRNE	F,GFL		;EDITING A REAL FILE?
	JRST	TYPFNM		;YES - OUTPUT FILE INFORMATION (RETURN TO LOOP:)
	PUSHJ	P,POSCUR	;POSITION THE CURSOR IN THE FILE

;NOW ACCEPT CHARACTERS AND DO THINGS
;ALL COMMANDS EVENTUALLY LOOP BACK TO LOOP

LOOP::	SKIPE	CLAFLG		;REMEMBERING A DELETE-LINES?
	PUSHJ	P,DLLCHK	;YES - SEE IF IT'S TIME TO FORGET
IFE TOPS10,<
IFN FTECHO,<
	TLZE	TM,ANM		;WAS A CHARACTER JUST TYPED?
	JRST	LOOP0		;YES - DON'T SET THE FIELD WIDTH
	MOVEI	T1,.PRIOU	;NO - SET THE FIELD WIDTH TO BE
	MOVEI	T2,.MOSFW	;  THE REMAINDER OF THE LINE
	MOVE	T3,FLDWTH
	SUB	T3,CM
	CAMLE	T3,SAVCNT	;OR THE INCREMENTAL SAVE COUNT,
	MOVE	T3,SAVCNT	;WHICHEVER IS SMALLER
	MTOPR
LOOP0:
>>
	SKIPE	SAVCNT		;TIME TO DO AN INCREMENTAL SAVE?
	SKIPN	ISVCNT
	PUSHJ	P,INCSAV	;YES - DO IT
	SETZ	DO,		;SAY NO COMMAND IS BEING HANDLED
	TDNE	F,[CWT,,XCT!XBN] ;ANYTHING SPECIAL?
	JRST	LOPSPC		;YES - DO IT SPECIALLY
	GETCHR			;READ A CHARACTER FROM THE TERMINAL IN T1

LOOP1:	TLNE	F,CCH		;CANCEL ENTER-CONTROL-CHAR FLAG - ON?
	JRST	LOOPCC		;YES - CHECK FOR AN ESCAPE (FLOW OR ALPNUM)
LOOPC2:	CAIL	T1," "		;SOME CONTROL CHARACTER?
	JRST	ALPNUM		;NO - JUST PUT IT IN FILE OR BUFFER
LOOPC3::MOVE	PT,[POINT 7,COMAND]
	SETZM	COMAND
	IDPB	T1,PT		;SAVE START OF COMMAND
	TLZ	F,ERF!CCH	;CLEAR CONSECUTIVE ERROR FLAG
	ADD	T1,ITB(TM)	;GET OFFSET IN TERMINAL TABLE
	SKIPGE	T1,(T1)		;IS IT A NORMAL COMMAND?
	JRST	[PUSHJ P,SUBTAB	;NO - READ MORE CHARACTERS
		 JRST  ILCERR	;ILLEGAL COMMAND - ERROR
		 JRST  .+1]	;LEGAL - CONTINUE

LOOP2::	TRNE	T1,200000	;IS THIS COMMAND REALLY AN EXECUTE BUFFER?
	JRST	ILCERT		;YES - SET BUFFER UP
	TRNE	F,XSV		;SAVE COMMAND IN EXECUTE BUFFER?
	JRST	[MOVEI T2,"^"	 ;YES - DO SO
		 CAIGE T1," "	 ;GOT A HIGH-NUMBERED COMMAND,
		 CAIN  T1,0	 ;  OR RESET (==0)?
		 IDPB  T2,XCTPTW ;YES - SAVE UP-ARROW AS FLAG
		 IDPB  T1,XCTPTW ;SAVE COMMAND
		 MOVE  T2,XCTPTW ;SEE IF BUFFER WILL OVERFLOW
		 CAME  T2,XCTOVF
		 JRST  .+1	 ;NO OVERFLOW - CONTINUE
		 JRST  XCTERR]	 ;ELSE GIVE ERROR MESSAGE
	TLNN	F,ENT		;ENTERING A PARAMETER?
	SKIPA	T2,CMDTBL(T1)	;NO - GET PROPER DISPATCH ADDRESS
	HLRZ	T2,CMDTBL(T1)	;YES - GET PROPER DISPATCH ADDRESS
	MOVE	DO,T1		;SAVE COMMAND THAT WAS TYPED
IFN FTJOUR,<
	TLNE	TM,JRW		;SAVING A JOURNAL?
	PUSHJ	P,JRNSVC	;YES - SAVE THE COMMAND
>
IFN FTIMD,<
	TLZE	TM,TIM		;IS THE TERMINAL IN INSERT MODE?
	PUSHJ	P,IMDOFN	;NO - TURN INSERT MODE OFF NOW
>
	JUMPN	T2,(T2)		;IF THERE IS AN ADDRESS, GO TO IT AND DO IT
	JRST	ILCER1		;ELSE IT'S AN ILLEGAL COMMAND

LOOPCC:	CAIE	T1,33		;CCH IS ON - WAS AN ESCAPE TYPED?
	JRST	LOOPC1		;NO - CONTINUE
	MOVEI	T1,"["		;YES - HANDLE IT LIKE ECC "["
	JRST	ALPNUM
LOOPC1:
IFE TOPS10,<
IFN FTECHO,<
	MOVEM	T1,SAVEAC
	PUSHJ	P,EKONPT	;TURN ON ECHO AND BREAK ON NONPRINTING CHARS
	MOVE	T1,SAVEAC
>>
	JRST	LOOPC2		;BACK TO THE FLOW

;SUBROUTINE TO SEE IF CLOSE BUFFER SHOULD BE APPENDED TO OR NOT IF THE NEXT
;COMMAND IS DELETE-LINES. THIS ALLOWS "CONSECUTIVE" DELETE-LINES' TO ACT AS
;IF THEY WERE ALL TYPED AS ONE BIG DELETE (TO HELP RECOVERING).

DLLCHK:	TLNN	F,ENT!PCM	;ENTERING A PARAMETER OR GOT A MARK?
	CAIN	DO,$DELLN	;NO - GOT A DELETE-LINES COMMAND?
	POPJ	P,		;NO, OR PARAMETER OR MARK - DONE
	CAIE	DO,$RESET	;GOT A RESET COMMAND?
	SETZM	CLAFLG		;NO - CLEAR CONSECUTIVE-DELETE FLAG
	POPJ	P,		;DONE

;HERE IF COMMAND SEQUENCE IS NOT FOUND IN TERMINAL INPUT TABLE
;SCAN THE EXECUTE BUFFERS TO SEE IF IT IS ONE OF THEM

ILCERR:	MOVEI	T3,4		;CONVERT LOWER CASE TO UPPER IN COMAND STRING:
	MOVE	T2,[POINT 7,COMAND,6]
ILCCAP:	ILDB	T1,T2		;GET THE NEXT CHARACTER
	JUMPE	T1,ILCCP2	;DONE IF NULL
	CAIGE	T1,"a"		;LOWER CASE?
	JRST	ILCCP1		;NO - LOOP
	CAIG	T1,"z"		;IS IT REALLY LOWER?
	SUBI	T1,40		;YES - CONVERT TO UPPER
	DPB	T1,T2		;STORE THE CORRECTED CHARACTER
ILCCP1:	SOJG	T3,ILCCAP	;LOOP THROUGH THE COMMAND CHARACTERS

ILCCP2:	LDB	T2,[POINT 6,PT,5] ;ELSE SEE IF CMND MATCHES AN XCT SEQUENCE
	SUBI	T2,43		;GET CHARACTER MASK
	MOVSI	T4,400000
	ASH	T4,(T2)
	MOVEI	T2,XBFNUM-1	;LOOK AT ALL EXECUTE BUFFERS
ILCXLP:	MOVE	T1,XCTKEY(T2)	;GET A BUFFER NAME
	AND	T1,T4		;MASK OFF THE UNREAD CHARACTERS
	CAME	T1,COMAND	;IS THIS WHAT THE USER TYPED?
	SOJGE	T2,ILCXLP	;NO - TRY ANOTHER
	JUMPL	T2,ILCER1	;NO MATCH - COMMAND IS ILLEGAL
	CAMN	T1,XCTKEY(T2)	;GOT THE ENTIRE COMMAND SEQUENCE?
	JRST	ILCE00		;YES - EXECUTE THE BUFFER
IFE TOPS10,<
IFN FTECHO,<
	MOVEM	T2,SAVEAC	;SAVE T2
	PUSHJ	P,EKOALL	;NO - ECHO OFF; BREAK ON ALL CHARACTERS
	MOVE	T2,SAVEAC	;GET T2 BACK
>>
	GETCHR			;NO - READ A CHARACTER FROM THE TERMINAL IN T1
	CAIL	T1,"a"		;LOWER CASE?
	CAILE	T1,"z"
	CAIA			;NO - O.K.
	SUBI	T1,40		;YES - CONVERT TO UPPER
	IDPB	T1,PT		;SAVE CHARACTER IN COMAND
	ASH	T4,-7		;INCLUDE ANOTHER CHARACTER IN MASK
	JRST	ILCXLP		;GO FIND LONGER SEQUENCE

;HERE IF COMMAND IS AN EXECUTE BUFFER - GO DO IT

ILCE00:	MOVE	DO,T2		;STORE THE BUFFER INDEX
IFE TOPS10,<
IFN FTECHO,<
	PUSHJ	P,EKONPT	;ECHO ON; BREAK ON NON-PRINTING CHARACTERS
>>
	CAIA			;SKIP THE MOVE
ILCER0::MOVE	DO,T1		;SAVE EXECUTE INDEX FOR JOURNALING
IFE TOPS10,<
	MOVE	T2,COMAND	;GET THE COMMAND SEQUENCE
	CAMN	T2,[BYTE (7) 15] ;IS IT A CARRIAGE RETURN?
	PBIN			;YES - BURN THE FOLLOWING LINEFEED
>
	ANDI	DO,77		;KEEP ONLY GOOD INDEX BITS
	MOVE	T2,XCTADR(DO)	;GET POINTER TO THIS BUFFER
	MOVEM	T2,XCTPTR	;SAVE AS ACTIVE POINTER

;IF THERE'S ONLY ONE COMMAND IN THE BUFFER, TREAT IT LIKE A COMMAND, NOT
;AN EXECUTE, SO IT RUNS FAST. THIS PROVIDES A CHEAP POOR-MAN'S WAY OF
;REDEFINING THE KEYBOARD.

	ILDB	T1,T2		;GET FIRST CHARACTER FROM BUFFER
	CAIN	T1,"^"		;SPECIAL CHARACTER FLAG?
	JRST	ILCE0S		;YES - SEE IF IT'S THE ONLY COMMAND THERE
	ILDB	T0,T2		;NO - GET NEXT COMMAND
	JUMPE	T0,XCTGTE	;IF ONLY ONE COMMAND DISPATCH TO LOOP2 OR ALPNUM

;HERE IF THERE'S MORE THAN ONE COMMAND IN THE BUFFER

ILCE0A:
IFN FTJOUR,<
	TLNE	TM,JRW		;WRITING A JOURNAL?
	PUSHJ	P,JRNSVX	;YES - SAVE THE EXECUTE INDEX
>
	MOVEI	T1,1		;SET TO DO ONE ITERATION OF BUFFER
	MOVEM	T1,XCTNUM
	MOVE	T1,[PARAMS,,SAVPRM]
	BLT	T1,SAVPRM+SAVPML-1 ;SAVE SOME PARAMETERS AND FLAGS
	HRRM	F,SAVFGS	;ALSO SAVE RH OF F
	HLLM	TM,SAVFGS	;  AND LH OF TM
	TRZ	F,XCT		;CLEAR JOURNAL-RESTORE FLAGS
	TLZ	TM,JRC
	TRO	F,XBN		;SET TO EXECUTE AND DISPLAY
	TLNN	F,ENT		;GOT A PARAMETER?
	JRST	LOOP		;NO - GO TAKE COMMANDS FROM BUFFER
	PUSHJ	P,ERSPM0	;YES - CLEAN UP SCREEN; DON'T CLEAR FLAG
	PUSHJ	P,PUTTYP	;OUTPUT EVERYTHING NOW
	JRST	LOOP		;GO TAKE COMMANDS FROM BUFFER

;HERE IF THE FIRST COMMAND IN THE BUFFER HAS A CODE ABOVE 37

ILCE0S:	ILDB	T1,T2		;GET COMMAND FROM EXECUTE BUFFER
	CAIN	T1,77		;GOT A RESET COMMAND?
	TDZA	T1,T1		;YES - GET THE REAL CODE AND SKIP TO USE IT
	CAILE	T1,37		;IS IT A REAL COMMAND?
	CAIL	T1,CMDLEN
	JRST	ILCE0A		;NO (AN EXECUTE CONSTRUCT) - HANDLE NORMALLY
;	CAIN	T1,77		;GOT A RESET COMMAND?
;	SETZ	T1,		;YES - GET THE REAL CODE
	ILDB	T0,T2		;GET NEXT COMMAND FROM THE BUFFER
	JUMPE	T0,LOOP2	;IF THERE'S ONLY ONE COMMAND GO USE IT
	JRST	ILCE0A		;ELSE HANDLE NORMALLY

;HERE IF COMMAND REALLY IS ILLEGAL - GIVE ERROR

ILCER1:
IFE TOPS10,<
IFN FTECHO,<
	PUSHJ	P,EKONPT	;ECHO ON; BREAK ON NON-PRINTING CHARACTERS
>>
	TLNN	F,ENT		;IS THERE A PARAMETER TO CLEAN UP?
	JRST	ILCER2		;NO - JUST OUTPUT MESSAGE
	SETZ	T1,		;YES - GET A NULL
	IDPB	T1,PARPTR	;SAVE IT AT THE END OF THE PARAMETER
	PUSHJ	P,ERSPM2	;RESTORE SAVED POSITION
ILCER2::MOVEI	T1,[ASCIZ /#########Illegal command/]
	JRST	ERROR

ILCERT:	TRNE	T1,100000	;GOT ENOUGH TYPE-IN?
	JRST	ILCERR		;NO - GET MORE
	JRST	ILCER0		;YES - GO EXECUTE BUFFER

;HERE FOR SPECIAL HANDLING: RESTORE NOMINALS, READ FROM EXECUTE BUFFER,
;OR GET TYPED-AHEAD (OR JOURNALED) CHARACTER

LOPSPC:	TRNE	F,XCT!XBN	;EXECUTE BUFFER OR JOURNAL RESTORE?
	JRST	XCTGET		;YES - TAKE COMMANDS FROM AN EXECUTE BUFFER
	TLZ	F,CWT		;NO - SAY NO CHARACTER IS WAITING
	MOVE	T1,TYPCHR	;PICK UP TYPED CHARACTER
	JRST	LOOP1		;AND USE IT AS CURRENT TERMINAL INPUT

;SUBROUTINE TO SET UP STARTING NOMINAL PARAMETER VALUES

RSTNOM::MOVEI	T1,1
	SETZM	GOPERC		;GO TO 0 PERCENT
	MOVEM	T1,SUBCNT	;DO ONE SUBSTITUTE
	MOVEM	T1,ADDLNS	;INSERT LINES DOES ONE LINE
	SETZM	ADDLSP		;  AND 0 SPACES
	MOVEM	T1,ADDSPC	;INSERT SPACES DOES ONE SPACE
	MOVEM	T1,PICKLN	;PICK DOES ONE LINE
	SETZM	PICKSP		;  AND 0 SPACES
	MOVEM	T1,ROLPGS	;ROLL ONE PAGE
	MOVEM	T1,CASSPS	;CHANGE THE CASE OF ONE CHARACTER
	SETZM	CASLNS		;  AND 0 SPACES
	MOVEM	T1,JUSLNS	;JUSTIFY ONE LINE
	MOVE	T1,LINROL
	MOVEM	T1,ROLLIN	;SET THE NUMBER OF LINES TO ROLL
	SKIPG	T1,SLIDNM	;GOT A DISTANCE TO SLIDE?
	MOVEI	T1,10		;NO - DEFAULT TO 8 COLUMNS
	MOVEM	T1,SLIDNM	;SAVE AS DEFAULT NOMINAL
	MOVEM	T1,SLIDES	;  AND AS CURRENT SLIDE SETTING
	POPJ	P,

;SUBROUTINE TO REFERENCE A TERMINAL'S SUBTABLES
;SKIP RETURN IF SEQUENCE FOUND, ELSE ERROR RETURN

SUBTAB::MOVE	T4,T1		;SET UP ADDRESS OF SUBTABLE
SUBTB0:
IFE TOPS10,<
IFN FTECHO,<
	PUSHJ	P,EKOALL	;ECHO OFF; BREAK ON EVERYTHING
>>
	GETCHR			;READ A CHARACTER FROM THE TERMINAL IN T1
	IDPB	T1,PT		;SAVE CHARACTER
SUBTB2:	SKIPN	T2,(T4)		;GET A SUBTABLE ENTRY - END?
IFN TOPS10,<
	POPJ	P,		;YES - INPUT SEQUENCE NOT FOUND
>
IFE TOPS10,<
IFN FTECHO,<
	JRST	SUBTBR
>
IFE FTECHO,<
	POPJ	P,		;YES - INPUT SEQUENCE NOT FOUND
>>
	TRNN	T2,-1		;MATCH ON ANY CHARACTER?
	JRST	SUBTB3		;YES - SET UP REAL COMMAND NOW
	CAIE	T1,(T2)		;DO USER'S AND TABLE'S CHARS MATCH?
	AOBJN	T4,SUBTB2	;NO - LOOP ON THE TABLE
	JUMPG	T4,CPOPJ	;ERROR IF END OF TABLE AND NOT FOUND
SUBTB3:	CAMLE	T2,[137,,0]	;ELSE FOUND - WANT ANOTHER LEVEL?
	JRST	SUBTBS		;YES - SET IT UP
SUBTB4:	HLRZ	T1,T2		;NO - SET UP REAL COMMAND
	AOS	(P)		;GIVE SKIP RETURN
IFE TOPS10,<
IFN FTECHO,<
SUBTBR:	MOVEM	T1,SAVEAC
	PUSHJ	P,EKONPT	;ECHO ON; BREAK ON NON-PRINTING CHARACTERS
	MOVE	T1,SAVEAC
>>
	POPJ	P,		;RETURN

SUBTBS:	TLNE	T2,200000	;GOT AN EXECUTE COMMAND?
	JRST	SUBTB4		;YES - SET IT UP AFTER ALL
	HLRZ	T4,T2		;POINT TO NEW SUBTABLE
	HRLI	T4,-^D40
	JRST	SUBTB0		;READ ANOTHER CHARACTER FROM TERMINAL

;**********************************************************************
;HERE IF A NON-CONTROL CHARACTER WAS TYPED - PUT IT IN FILE OR
;PARAMETER BUFFER, AND ADJUST CURSOR POSITION ONE TO THE RIGHT

ALPNUM::CAIL	T1,173		;GOT A HIGH CHARACTER?
	JRST	ALPHGH		;YES - MAYBE IT'S A COMMAND
ALPNU0:
IFE TOPS10,<
IFN FTECHO,<
	TLO	TM,ANM		;NOTE THAT A CHARACTER WAS TYPED
>>
IFN FTJOUR,<
	TLNE	TM,JRW		;WRITING A JOURNAL?
	PUSHJ	P,JRNSVA	;YES - SAVE THE CHARACTER
>
	SETO	DO,		;NOTE THAT A COMMAND IS ACTIVE
	SKIPE	UPPFLG		;WANT UPPER CASE ALPHABETICS?
	JRST	[CAIGE T1,"a"	;YES - IS CHARACTER LOWER CASE?
		 JRST  .+1	;NO - O.K.
		 CAIG  T1,"z"
		 SUBI  T1,40	;YES - CONVERT TO LOWER
		 JRST  .+1]	;CONTINUE
	TRNE	F,XSV		;SAVE COMMAND IN EXECUTE BUFFER?
	JRST	[IDPB T1,XCTPTW	;YES - DO SO
		 CAIN T1,"^"	;IS CHARACTER A REAL UP-ARROW?
		 IDPB T1,XCTPTW	;YES - SAVE TWO OF THEM
		 MOVE T2,XCTPTW	;SEE IF BUFFER WILL OVERFLOW
		 CAME T2,XCTOVF
		 JRST .+1	;NO OVERFLOW - CONTINUE
		 JRST XCTERR]	;AND GIVE ERROR MESSAGE
	TLZE	F,CCH		;WANT A CONTROL CHARACTER?
IFN TOPS10,<
	ANDI	T1,37		;YES - MAKE IT ONE
>
IFE TOPS10,<
IFN FTECHO,<
	JRST	[MOVEM T1,SAVEAC ;YES - SAVE THE USER'S CHARACTER
		 PUSHJ P,EKONPT	 ;ECHO ON; BREAK ON NON-PRINTING CHARACTERS
		 MOVE  T1,SAVEAC ;GET THE CHARACTER BACK
		 ANDI  T1,37	 ;MAKE IT A CONTROL CHARACTER
		 JRST  .+1]	 ;BACK TO THE FLOW
>
IFE FTECHO,<
	ANDI	T1,37
>>
ALPNU1::TLNE	F,ENT		;ENTERING A PARAMETER?
	JRST	ALPENT		;YES - HANDLE SEPARATELY

	TRNE	F,RDO		;NO - IS FILE READ-ONLY?
	JRST	ALPERR		;YES - COMMAND IS ILLEGAL
	SOS	SAVCNT		;DEBUMP TYPEIN SAVE COUNTER
	TLO	F,CHG!INS	;LET LINE BE EXTENDED IF NECESSARY
	PUSHJ	P,MAKCPT	;RE-MAKE CURSOR POSITION
	TLZ	F,INS!PCM
	CAIE	T3,15		;AT END OF LINE?
	TRNN	F,IMD		;NO - IN INSERT MODE?
	TDZA	T4,T4		;NOT INSERT MODE OR AT END OF LINE - SKIP
	JRST	ALPIMD		;INSERT MODE, NOT AT EOL - HANDLE SEPARATELY

;HERE TO PUT CHARACTER IN FILE (NON-INSERT-MODE)

ALPNM2:	ILDB	T2,CHRPTR	;GET CHARACTER THAT WILL BE OVERWRITTEN
	JUMPE	T2,ALPNUL	;IF NULL, SAVE POINTER
	CAIN	T2,11		;TAB?
	JRST	ALPTAB		;YES - NEED TO BREAK THE TAB APART
	CAIN	T2,15		;CARRIAGE RETURN?
	PUSHJ	P,ALPEXT	;YES - MAY NEED TO EXTEND LINE
ALPNM3:	DPB	T1,CHRPTR	;SAVE CHARACTER IN BUFFER
	CAMN	EN,CHRPTR	;AT THE END OF FILE?
	IBP	EN		;YES - INCREASE FILE SIZE BY ONE CHARACTER

;HERE TO DISPLAY CHARACTER, FROM REPLACE MODE OR PARAMETER

ALPDIS:	MOVEM	T1,CHARAC	;SAVE USER'S CHARACTER
	TRNE	F,XCT		;EXECUTING?
	JRST	ALPDS1		;YES - POSITION, BUT NO ECHO
IFN TOPS10,<
	CAMN	RW,LPP.1	;AT LAST LINE?
	JRST	[TLZN  F,FNC	;YES - IS FENCE UP?
		 JRST  .+1	;NO - DRIVE ON
		 TLO   F,XPB	;YES - INVALIDATE BOTTOM LINE POINTER
		 PUSH  P,T1	;SAVE CHARACTER TYPED
		 PUSHJ P,CBOTOM ;TAKE FENCE DOWN
		 PUSHJ P,POSCUR ;RE-POSITION CURSOR
		 POP   P,T1	;GET CHARACTER BACK
		 JRST  .+1]	;CONTINUE
>
IFE TOPS10,<
IFN FTECHO,<
	CAMN	RW,LPP.1	;AT LAST LINE?
	JRST	[TLZE F,FNC	;YES - IS THE FENCE UP?
		 TLO  F,XPB	;YES - INVALIDATE BOTTOM LINE POINTER
		 JRST .+1]	;AND PROCEED
>
IFE FTECHO,<
	CAMN	RW,LPP.1	;AT LAST LINE?
	JRST	[TLZN  F,FNC	;YES - IS FENCE UP?
		 JRST  .+1	;NO - DRIVE ON
		 TLO   F,XPB	;YES - INVALIDATE BOTTOM LINE POINTER
		 PUSH  P,T1	;SAVE CHARACTER TYPED
		 PUSHJ P,CBOTOM ;TAKE FENCE DOWN
		 PUSHJ P,POSCUR ;RE-POSITION CURSOR
		 POP   P,T1	;GET CHARACTER BACK
		 JRST  .+1]	;CONTINUE
>>
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	JRST	ALPCCH		;YES - DISPLAY SPECIALLY
IFN TOPS10,<
	TYPCHA			;ECHO THE CHARACTER IN T1
>
IFE TOPS10,<
IFN FTECHO,<
	TRNE	F,IMD		;IN INSERT MODE?
	TYPCHA			;YES - ECHO THE CHARACTER
>
IFE FTECHO,<
	TYPCHA
>>
ALPDS1:	CAMGE	CM,RMARGN	;BEYOND THE RIGHT MARGIN?
	JRST	ALPPOS		;NO - GO FINISH UP
	SETZM	SAVEAC+2	;YES - CLEAR COUNT OF CHARACTERS BACKED OVER
IFE TOPS10,<
IFN FTECHO,<
	TLZ	TM,ANM		;MAKE THE FIELD WIDTH BE RESET IN THE NEXT LOOP
>>
	MOVE	PT,CHRPTR	;GET CURRENT CHARACTER POINTER
	LDB	T1,PT		;GET CURRENT CHARACTER
	CAIE	T1," "		;IS IT A SPACE,
	CAIN	T1,11		;  OR A TAB?
	JRST	ALPDS2		;YES - PUT NEW LINE HERE
	MOVEI	T2,1		;NO - SET NOT-SPACE FLAG
	PUSHJ	P,ALPBAK	;AND BACK UP OVER THE LAST WORD
	JUMPG	T2,.-1
	JUMPL	T2,ALPNSP	;IF NO SPACES IN LINE JUST WRAP LAST CHAR
	MOVE	T3,PT		;SAVE POINTER TO START OF WORD
	PUSHJ	P,ALPBKS	;SEE WHAT'S BEFORE THE SPACES
	JUMPE	T2,.-1
	JUMPL	T2,ALPNSP	;IF LINE STARTS WITH SPACES WRAP LAST CHAR
	MOVE	PT,T3		;ELSE GET BACK POINTER TO START OF WORD
	MOVEM	PT,CHRPTR	;SAVE POINTER TO START OF LAST WORD

ALPDS2:	MOVEI	T1,2		;SET TO INSERT TWO CHARACTERS:
	MOVEM	T1,NUMCHR	;  A RETURN AND A LINEFEED
	MOVEI	T1,12
	MOVEM	T1,CHARAC
	PUSHJ	P,MAKCHR	;INSERT TWO LINEFEEDS
	MOVEI	T1,15		;AND CHANGE ONE OF THEM TO A RETURN
	IDPB	T1,PT
	IBP	PT		;JUMP OVER THE LINEFEED, FOR RE-DISPLAY

	SKIPN	T1,LMARGN	;GET THE LEFT MARGIN OFFSET - ANY?
	JRST	ALPDS3		;NO - SKIP THIS
	MOVEM	T1,NUMCHR	;YES - ADD THAT MANY SPACES
	MOVEM	PT,CHRPTR	;  AT THE START OF THE NEW LINE
	PUSHJ	P,MAKSPC

ALPDS3:	SKIPN	T1,SAVEAC+2	;WAS ANYTHING MOVED?
	JRST	ALPDS4		;NO - DON'T ERASE
	SUB	CM,T1		;ELSE ERASE THE LAST WORD: POSITION TO IT
	PUSHJ	P,POSCUR
	PUSHJ	P,CLRLNR	;AND ERASE THE TO END OF THE LINE
ALPDS4:	AOS	T4,RW		;POSITION TO THE START OF THE NEXT LINE
	CAMN	RW,LPP.1	;MOVED TO THE LAST LINE?
	TLZ	F,FNC		;YES - FENCE WILL BE CLEARED, IF IT'S THERE
	MOVE	CM,SAVEAC+2	;AND SET CURSOR POS'N TO END OF THE NEW LINE
	ADD	CM,LMARGN	;  (ADD IN MARGIN OFFSET)
	TLO	F,XPC!XPB	;CHARACTER AND BOTTOM POINTERS ARE BAD
	MOVEM	PT,LINPTR	;SAVE POINTER TO THE START OF THE NEW LINE
	CAML	RW,LPP(TM)	;ABOUT TO MOVE OFF THE SCREEN?
	JRST	RETROL		;YES - DO A ROLL
	PUSHJ	P,POSLIN	;ELSE POSITION TO START OF THE NEW LINE

	MOVEI	T4,1		;SET TO INSERT ONE LINE
	SKIPN	T1,ILN(TM)	;CAN TERMINAL TO AN INSERT-LINES?
	JRST	DISDWN		;RE-DRAW THE SCREEN FROM THERE DOWN; DONE
	PUSH	P,CM		;YES - FUDGE THE COLUMN POSITION TO ZERO
	SETZ	CM,
	PUSHJ	P,PUTSEQ	;YES - INSERT THE LINE
	POP	P,CM		;GET THE COLUMN POSITION BACK AGAIN
	PUSHJ	P,DISPLY	;DISPLAY THE OVERFLOW
	PUSHJ	P,FIXBLW	;PUT BACK FENCE AND INSERT MODE MESSAGES
	JRST	DISCUR		;POSITION TO THE END AND LOOP (WHEW)

ALPNSP:	SETZM	SAVEAC+2	;IF NO SPACES IN LINE JUST WRAP LAST CHAR
	MOVE	PT,CHRPTR
	JRST	ALPDS2

;SUBROUTINE TO READ THE CHARACTER PREVIOUS TO PT.
;RETURNS CHARACTER IN T1; T2/0 IF CHARACTER IS SPACE, TAB; -1 IF LF
;ALSO KEEPS A COUNT OF CHARACTERS BACKED OVER IN SAVEAC+2

ALPBKS:	MOVEI	T2,1		;SET FOUND-A-CHARACTER FLAG
ALPBAK:	ADD	PT,[70000,,0]	;BACK UP A NOTCH
	CAIGE	PT,0
	SUB	PT,[430000,,1]
	LDB	T1,PT		;GET THE PREVIOUS CHARACTER
	JUMPE	T1,ALPBAK	;SKIP IT IF NULL
	CAIE	T1," "		;SPACE,
	CAIN	T1,11		;  OR TAB?
	SETZ	T2,		;YES - MARK AS SUCH
	CAIN	T1,12		;HOW ABOUT A LINEFEED?
	SETO	T2,		;YES - MARK IT SPECIALLY
	JUMPLE	T2,CPOPJ	;GOT A REAL CHARACTER?
	AOS	SAVEAC+2	;YES - COUNT IT
	POPJ	P,		;DONE

;HERE TO SEE IF A HIGH CHARACTER IS REALLY A COMMAND

ALPHGH:	TLNN	TM,HTB		;GOT A HIGH TABLE TO USE?
	JRST	ALPHGR		;NO - JUST CHECK FOR RUBOUT
	MOVE	T2,T1		;SAVE CHARACTER
	ADD	T1,ITB(TM)	;GET TABLE ENTRY
	SKIPL	T1,-200(T1)	;IS THERE ONE?
	JRST	LOOPC3		;YES - HANDLE AS A COMMAND
	MOVE	T1,T2		;NO GET CHARACTER BACK
	JRST	ALPNU0		;AND GO PUT IT IN FILE

ALPHGR:	CAIE	T1,177		;GOT A RUBOUT?
	JRST	ALPNU0		;NO - TREAT LIKE A CHARACTER
	SETO	T1,		;YES - CHANGE INDEX TO -1
	JRST	LOOPC3		;AND PROCESS IT

;HERE TO OUTPUT A PROTECTED CONTROL CHARACTER

ALPCCH:	MOVE	T2,T1		;GET CHARACTER
	ADDI	T2,100		;  AS A REAL CHARACTER
	CAIN	T1,11		;GOT A TAB?
	JRST	ALPDTB		;YES - HANDLE SPECIALLY
	PUSH	P,T1		;SAVE KNOCKED CHARACTER
	PUSHJ	P,PROTON	;OUTPUT THE CHARACTER PROTECTED
	MOVE	T1,T2
	IDPB	T1,TY
	PUSHJ	P,PROTOF
	PUSHJ	P,PUTTYP	;OUTPUT IT NOW
	POP	P,T1		;GET CONTROL CHAR BACK AGAIN
	JRST	RIGHT+1

	MOVEI	DO,$CURHM	;CAUSE POSITIONING TO OCCUR
ALPDTB:	MOVSI	T1,70000	;MOVE POINTER BEHIND THE LATEST CHARACTER
	ADD	T1,CHRPTR
	CAIGE	T1,0
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR	;SAVE CHARACTER POINTER
IFN FTIMD,<
	TLZE	TM,TIM		;TURN OFF INSERT MODE FLAG - ON?
	PUSHJ	P,IMODOF	;YES - TURN OFF INSERT MODE
>
	PUSHJ	P,DISLIN	;REWRITE REMAINDER OF LINE
	IBP	CHRPTR		;MAKE CHARACTER POINTER RIGHT
	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
ALPPOS:	CAIE	T1,11		;TAB?
	JRST	RIGHT+1		;NO - MOVE TO THE RIGHT AND LOOP
	TRZ	CM,7		;YES - POINT TO CHARACTER AFTER TAB
	ADDI	CM,10
	JRST	DISCUR		;RE-POSITION AND LOOP

;HERE IF NULL FOUND WHERE CHARACTER POINTER POINTS

ALPNUL:	CAIN	T4,0		;IF NOT FIRST NULL, DON'T SAVE POINTER
	MOVE	T4,CHRPTR	;ELSE SAVE POINTER TO FIRST NULL
	CAME	EN,CHRPTR	;AT END OF FILE?
	JRST	ALPNM2		;NO - LOOP
	MOVEM	T4,CHRPTR	;YES - POINT BACK TO FIRST NULL
	JUMPN	T4,ALPNM3	;O.K. IF A NULL WAS FOUND
	MOVEI	T1,[ASCIZ /########BUG - No null found/]
	JRST	ERROR		;ELSE IT'S AN ERROR (SHOULD NEVER HAPPEN)

;HERE IF CHARACTER TO OVERWRITE IS A TAB - PRECEDE IT WITH SPACES AND CHAR
;IF CHARACTER IS GOING INTO THE 7TH POSITION OF THE TAB, TAKE THE TAB OUT

ALPTAB:	PUSH	P,T1		;SAVE CHARACTER USER TYPED
	MOVE	T2,[70000,,0]	;ELSE BACK POINTER UP BEFORE THE TAB
	ADDB	T2,CHRPTR
	JUMPGE	T2,ALPTB0
	MOVN	T2,[430000,,1]
	ADDM	T2,CHRPTR
ALPTB0:	AOS	T2,TABSPC	;GET SPACES (+ CHAR) TO ADD BEFORE TAB
	MOVEM	T2,NUMCHR	;ADD THAT MANY SPACES TO THE FILE
	PUSHJ	P,MAKSPC	;NOTE: T4 HAS PTR TO LAST THING ADDED

;MAKCHR POINTS TO START OF ADDED SPACES
;MAKPTR   "    "  LAST SPACE ADDED
;T4	  "    "  POINTS TO THE TAB

	SETZ	T1,		;NULL OUT THE FORMER TAB
	IDPB	T1,T4
	POP	P,T1		;GET USER'S CHARACTER BACK AGAIN
	MOVE	T4,MAKPTR
	DPB	T1,T4		;SAVE IT OVER THE LAST THING TYPED
	MOVEM	T4,CHRPTR	;SAVE AS CURRENT POSITION
	MOVN	T2,TABSPC
	ADDB	T2,TABSIZ	;SEE IF ENTIRE TAB HAS BEEN USED UP
	SETZM	TABSPC		;NO LONGER ANY SPACES TO LEFT OF TAB
	CAIG	T2,0		;IS TAB NOW EXPRESSED ENTIRELY IN CHARS?
	TDZA	T2,T2		;YES - NULL OUT THE TAB
	MOVEI	T2,11		;NO - MOVE TAB OVER
	IDPB	T2,T4
	JRST	ALPDIS		;DONE - GO DISPLAY

;HERE IF IN INSERT MODE, AND INSERTING A CHARACTER IN THE MIDDLE OF A TAB

ALPTBI:	PUSH	P,T1		;SAVE CHARACTER USER TYPED
;IFE TOPS10,<
;IFN FTECHO,<
;	TYPCHA			;ECHO THE CHARACTER
;>>
	JRST	ALPTB0		;JUMP INTO THE BREAK-UP-TAB ROUTINE

;SUBROUTINE FOR IF GOING TO OVERWRITE A <CR>. IF IT'S <CRLF> EXTEND LINE
;HOWEVER, IF A NULL WAS PASSED OVER, SAVE CHARACTER THERE; LEAVE <CR> ALONE

ALPEXT:	JUMPN	T4,ALPEX1	;IF FOUND A NULL, SAVE CHARACTER THERE
	MOVE	T3,CHRPTR
	ILDB	T2,T3
	CAIE	T2,12		;IS IT A LINEFEED?
	POPJ	P,		;NO - JUST OVERWRITE THE LONE <CR>
	PUSH	P,T1		;YES - SAVE CHARACTER USER TYPED

	MOVSI	T1,70000	;MOVE POINTER BEHIND THE <CR>
	ADD	T1,CHRPTR
	CAIGE	T1,0
	SUB	T1,[430000,,1]
	MOVEM	T1,CHRPTR	;SAVE IT AGAIN

	MOVEI	T1,12		;GO ADD 12 SPACES TO THE FILE
	MOVEM	T1,NUMCHR
;IFE FTNIH,<
;	PUSHJ	P,MAKSPC	;PUT IN THOSE SPACES
;>
;IFN FTNIH,<
	PUSHJ	P,MAKNUL	;PUT IN THOSE NULLS
;>
	POP	P,T1		;GET CHARACTER BACK
	IBP	CHRPTR		;POINT BACK TO REAL CHARACTER POSITION
	POPJ	P,		;AND GO PUT IT INTO BUFFER

ALPEX1:	MOVEM	T4,CHRPTR	;GO SAVE CHARACTER OVER THAT NULL
	POPJ	P,		;..

;HERE IF EDITOR IS IN INSERT MODE - ADD CHARACTER AT CURSOR; DON'T REPLACE

ALPIMD::CAML	CM,CPL.1	;AT 80TH COLUMN?
	JRST	ALPIBP		;YES - INSERT NOT ALLOWED
	MOVE	PT,CHRPTR	;GET CHARACTER POINTER
	MOVEM	T1,CHARAC	;SAVE USER'S CHARACTER
	ILDB	T2,PT		;GET CHARACTER AT POINTER
	JUMPE	T2,ALPIM4	;IF NULL, SAVE NEW CHAR THERE
	CAIN	T2,11		;IS IT A TAB?
	JRST	ALPTBI		;YES - BREAK THE TAB APART
	LDB	T2,CHRPTR	;ELSE GET CHARACTER BEFORE POINTER
	JUMPE	T2,ALPIM5	;IF NULL, SAVE NEW CHAR THERE
				;ELSE NEED TO INSERT SOME SPACE:
	MOVEI	T1,1		;TELL MAKCHR TO INSERT ONE CHARACTER
	MOVEM	T1,NUMCHR
	PUSHJ	P,MAKCHR	;INSERT THAT CHARACTER
	IBP	CHRPTR		;POINT TO CHARACTER AFTER THIS ONE
ALPIM1:	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	CAIN	T1,11		;IS IT A TAB?
	JRST	ALPDTB		;YES - REWRITE REST OF LINE
IFN FTIMD,<
	SKIPN	T3,IMO(TM)	;CAN THE TERMINAL SET INSERT MODE?
	JRST	ALPIM2		;NO - INSERT THE CHARACTER SOME OTHER WAY
	PUSHJ	P,FNDEOL	;YES - SEE IF THERE ARE TABS FROM HERE TO EOL
	  JRST	ALPDTB-1	;YES - RE-DISPLAY ENTIRE REMAINDER OF LINE
	TLON	TM,TIM		;ELSE IS THE TERMINAL ALREADY IN INSERT MODE?
	PUSHJ	P,IMODON	;NO - TURN ON INSERT MODE
	JRST	ALPIM3		;OUTPUT THE CHARACTER, ADJUST POSITION, & LOOP
>
ALPIM2:	MOVEI	T4,1		;SET TO OPEN LINE ONE CHARACTER
	SKIPE	T3,ISP(TM)	;CAN TERMINAL OPEN SPACES ON ITS OWN?
	PUSHJ	P,OPNSPI	;YES - OPEN UP THE LINE (SKIP RETURN)
	JRST	ALPDTB-1	;NO - REWRITE THE LINE CURSOR IS ON
	PUSHJ	P,POSCUR	;GET BACK TO START OF NEWLY-OPENED SPACE
ALPIM3:	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	JRST	ALPCCH		;YES - DISPLAY SPECIALLY
	IDPB	T1,TY		;DISPLAY IT
	AOJA	CM,DISCUR	;RE-DISPLAY THE CURSOR; DONE

ALPIBP:	TYPCHI	207		;IF AT 80TH COLUMN JUST BEEP
	JRST	LOOP

;HERE IF NULL FOUND AT (ALPIM4) OR BEFORE (ALPIM5) CURSOR POSITION
;SAVE NEW CHARACTER THERE; NO INSERT NECESSARY

ALPIM4:	IBP	CHRPTR		;SKIP OVER THIS NEW CHARACTER
ALPIM5:	MOVE	T1,CHARAC	;GET LATEST-TYPED CHARACTER
	DPB	T1,CHRPTR	;SAVE NEW CHARACTER JUST BEFORE POINTER
	JRST	ALPIM1		;GO DISPLAY WHAT HAPPENED

;HERE FOR A CHARACTER TYPED AS PART OF A PARAMETER

ALPENT:	TRZE	F,CMV		;DOING CURSOR MOVEMENT?
	JRST	CMXERR		;YES - CAN'T MIX CURSOR AND OTHERWISE
	HRRZ	PT,PARPTR	;GET POINTER INTO PARAMETER BUFFER
	CAIL	PT,PARBUF+PARBLN ;IS BUFFER ABOUT TO OVERFLOW?
	JRST	ALPIBP		;YES - BEEP AND DON'T SAVE THE CHARACTER
	IDPB	T1,PARPTR	;SAVE THIS CHARACTER IN PARAMETER BUFFER
	TRNE	F,XCT!XBN	;EXECUTING?
	JRST	LOOP		;YES - NO OUTPUT
	CAIGE	T1," "		;GOT A CONTROL CHARACTER?
	JRST	ALPENC		;YES - OUTPUT IT PROTECTED
IFN TOPS10,<
	TYPCHA			;ECHO THE CHARACTER IN T1
>
IFE TOPS10,<
IFN FTECHO,<
	TRNE	F,IMD		;IN INSERT MODE?
	TYPCHA			;YES - ECHO THE CHARACTER IN T1
>
IFE FTECHO,<
	TYPCHA			;ECHO THE CHARACTER IN T1
>>
	JRST	LOOP		;DONE

ALPENC:	MOVE	T4,T1		;SAVE CHARACTER
	PUSHJ	P,PROTON	;PROTECT CHARACTER
	MOVEI	T1,100(T4)	;GET REAL CHARACTER BACK
	IDPB	T1,TY		;SAVE IT
	PUSHJ	P,PROTOF
	PUSHJ	P,PUTTYP
	JRST	LOOP		;GET ANOTHER COMMAND

;************************************************************************
;HERE TO REENTER SED AFTER AN ABORT. RESTORES SAVED ACS AND FLIES

REEERR::MOVS	T1,[5,,SAVEAC]	;RESTORE ACS
	BLT	T1,P
IFE TOPS10,<
	TRNN	F,GFL		;IS THE FILE LEFT TO EDIT?
	JRST	STARTR		;NO - JUST DO A NORMAL STARTUP (WITHOUT RESET)
>
	PUSHJ	P,INITTY	;SET UP THE TTY AGAIN
	PUSHJ	P,@RTE(TM)	;CALL USER'S ENTRY ROUTINE
	PUSHJ	P,INITT1	;DO MORE TTY INITTING
IFE TOPS10,<
	PUSHJ	P,INITTF	;DISABLE TOPS-20 INTERRUPTS, TOO
>
	TLNE	TM,SLW		;PUTTING ERRORS ON THE BOTTOM LINE?
	PUSHJ	P,DISPLL	;YES - DISPLAY NOW, THEN
	MOVEI	T1,[ASCIZ /#########Re-entering SED/]
	JRST	ERROR		;(THIS IS IF USER TYPES ^C, REE)

;************************************************************************
;SUBROUTINE TO INITIALIZE THE TTY FOR INPUT AND OUTPUT

IFN TOPS10,<
INITTY::SETO	T1,		;FIND TERMINAL NUMBER
	TRMNO.	T1,
	  HALT
	MOVEM	T1,BRKADR+1	;SET IT UP IN VARIOUS LOCATIONS
	MOVEM	T1,PAGADR+1
	MOVEM	T1,XOFADR+1
	MOVEM	T1,CRRADR+1
	MOVEM	T1,CRWADR+1
	MOVEM	T1,CHRIN+1
	MOVEM	T1,TSTIN+1
	OPEN	1,TTYBLK	;OPEN TERMINAL IN PIM MODE
	  HALT
	MOVE	T1,[XWD 3,BRKADR]
	TRMOP.	T1,		;SET UP TO BREAK ON ALL CHARACTERS
	  HALT
	MOVE	T1,[XWD 2,CRRADR]
	TRMOP.	T1,		;READ SETTING OF TTY CRLF
	  HALT
	JUMPN	T1,CPOPJ	;DONE IF TTY NO CRLF SET
	MOVE	T1,[XWD 3,CRWADR]
	TRMOP.	T1,		;ELSE SET TTY NO CRLF
	  HALT
	SETZM	CRWADR+2	;AND MAKE SURE IT'LL BE RESET ON EXIT
	POPJ	P,
>
IFE TOPS10,<
INITTY::MOVEI	T1,-1		;READ THE STARTING CCOC WORD
	RFCOC
	DMOVEM	T2,SAVCOC	;SAVE IT
IFN FTECHO,<
	SETZB	T2,T3		;MAKE ALL CONTROL CHARACTERS NOT ECHO
>
IFE FTECHO,<
	MOVE	T2,[525252,,525252]
	MOVE	T3,T2		;MAKE ALL CONTROL CHARACTERS GIVE THEIR CODE
>
	SFCOC

;	MOVEI	T2,.MOXOF	;CLEAR PAUSE-ON-END-OF-PAGE BIT
;	SETZ	T3,		;this is off because it can't be sensed,
;	MTOPR			;so it can't be restored on exit

	MOVEI	T1,.FHSLF	;READ USER'S CAPABILITIES
	RPCAP
	MOVEM	T3,SAVCAP	;SAVE THE ENABLED ONES FOR LATER
IFN FTECHO,<
	MOVEI	T1,4
	MOVEM	T1,SAVWKU
	MOVEI	T3,SAVWKU	;READ THE STARTING WAKE-UP SET FOR EXITING
	MOVEI	T1,.PRIOU
	MOVEI	T2,.MORBM
	MTOPR

	MOVE	T1,[GJ%SHT]	;OPEN UP THE TERMINAL FOR OUTPUT
	HRROI	T2,[ASCIZ /TTY:/] ;SO OUTPUT WON'T BE TRANSLATED
	GTJFN
	  HALTF
	HRRZ	T1,T1
	MOVEM	T1,TTYJFN
	MOVE	T2,[10B5+OF%RD+OF%WR]
	OPENF
	  HALTF
	JRST	BRKNPT		;SET TO BREAK ONLY ON CTRL CHARACTERS; RETURN
>
	POPJ	P,

INITTF::MOVEI	T1,-5		;DISABLE INTERRUPTS ON ALL CHARACTERS
	SETZ	T2,		;  SO MONITOR WON'T TRAP ANYTHING
	STIW
	MOVEI	T1,.PRIIN	;READ MODE WORD
	RFMOD
	MOVEM	T2,FMDSAV	;SAVE IT FOR EXIT
IFN FTECHO,<
	TDZ	T2,[37777,,0020] ;ZERO PAGE LENGTH, WIDTH
	TDO	T2,[200000,,300] ;TURN ON FORMF, NO-TRANS-OUTPUT BITS
	MOVEM	T2,SMDSAV	;SAVE SED'S NORMAL MODE WORD
>
IFE FTECHO,<
	TDZ	T2,[37777,,4020] ;ZERO PAGE LENGTH, WIDTH; MAKE NOTHING ECHO
	TDO	T2,[200000,,300] ;TURN ON FORMF, NO-TRANS-OUTPUT BITS
>
	SFMOD
	STPAR
	SETOM	ITTFLG		;MARK INTERRUPTS AS DISABLED
	POPJ	P,
>
;SUBROUTINE TO DO MORE TTY INITIALIZATION, AFTER USER'S ENTRY ROUTINE IS RUN

IFN TOPS10,<
INITT1::MOVEI	T1,GETAK	;SET UP SO AN ILL MEM REF
	HRRM	T1,.JBAPR	;  EXPANDS CORE AUTOMATICALLY
	MOVEI	T1,420000
	APRENB	T1,
	TLNE	TM,NPG		;LEAVE XON AND XOFF ALONE?
	POPJ	P,		;YES - DONE
	JRST	INIT1B		;NO - SKIP THE SLEEP THE FIRST TIME

INIT1A:	MOVEI	T1,1		;SLEEP A BIT
	SLEEP	T1,
INIT1B:	MOVE	T1,[XWD 3,XOFADR]
	TRMOP.	T1,		;SEE IF XOFF IS CURRENTLY IN EFFECT
	  HALT
	JUMPN	T1,INIT1A	;IF SO, WAIT FOR USER TO CLEAR IT
	SETZM	PAGADR+2	;O.K. - RESET PAGE WORD IN CASE OF AN ABORT
	MOVE	T1,[XWD 3,PAGADR]
	TRMOP.	T1,		;NOW IT'S SAFE TO SET UP TTY NO PAGE
	  HALT
	POPJ	P,		;DONE
>
IFE TOPS10,<
INITT1::MOVEI	T1,.PRIIN
	RFMOD			;READ MODE WORD (AGAIN)
	TLNN	TM,NPG		;ENABLE CTRL-S AND CTRL-Q AS COMMANDS?
	TRZA	T2,2		;YES - CLEAR ECHO
	TRO	T2,2		;NO - SET THE BIT
	TLNE	TM,TBS		;DOES THE TERMINAL HAVE HARDWARE TABS?
	TLO	T2,(TT%TAB)	;YES - SET THE "DON'T SIMULATE" BIT
	STPAR
IFN FTECHO,<
	MOVEM	T2,SMDSAV	;SAVE IT AS SED'S NORMAL MODE WORD
>
	POPJ	P,		;DONE
>
;SUBROUTINE TO OUTPUT THE CURRENT AND ALTERNATE FILESPECS ON THE BOTTOM
;LINE, WHEN THE USER CHANGES FILES.

TYPFNM:	TLO	F,FBL		;SAY BOTTOM LINE IS FRAGGED
	PUSHJ	P,SWHBOT	;SET UP THE BOTTOM LINE
	MOVEI	T1,[ASCIZ /FILE: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,FILSPC	;OUTPUT THE CURRENT FILESPEC
	PUSHJ	P,PUTSTF
	SKIPN	OLDSPC		;GOT AN ALTERNATE FILE?
	JRST	SWHNPE		;NO - DON'T TALK ABOUT IT
	MOVEI	T1,[ASCIZ /  ALT: /]
	PUSHJ	P,PUTSTG
	MOVEI	T1,OLDSPC	;OUTPUT THE ALTERNATE FILESPEC
	PUSHJ	P,PUTSTF
	JRST	SWHNPE		;FINISH OFF THE LINE AND OUTPUT IT

IFN TOPS10,<END	START>
IFE TOPS10,<END	<ENTLEN,,ENTVEC>>

   