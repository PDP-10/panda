


              SED: A CRT EDITOR FOR TOPS-10 AND TOPS-20
            WRITTEN AND DOCUMENTED BY A Christopher Hall
                             August 1983

                    (Operating system:  TOPS-10)
                     (Terminal described: VT52)


                   HISTORICAL NOTE AND COMMERCIAL

     The first successful full-screen text editor was  developed  in
1967  at  the  Institute for Defense Analyses by Edgar T.  Irons and
Franz M.  Djorup for use on the CDC-6600 computer.  It was the first
editor to use function keys as editor commands.

     The Yale editor "E" was designed in 1970  by  Irons  and  Peter
Weiner  to  be  an  improvement  on  the  IDA editor, running on the
PDP-10.  It demonstrated  the  practicality  of  screen  editors  on
terminals of speeds as low as 2400 baud.

     The Rand editor "re" was conceived in  1974  by  Peter  Weiner,
based  on the Yale editor.  It was initially designed and written by
Walter Bilofsky, and modified by both  Weiner  and  Bilofsky  as  it
evolved.   The  Rand  editor is used on PDP-11 computers running the
UNIX operating system.  It is extremely powerful,  although  limited
to a small number of terminals.

     The author has worked with the Yale editor and the Rand  editor
for  the  past several years, and has made a number of modifications
and improvements to a version of the former.  The  editor  described
in this document was initially developed by the author in 1978 to be
a more tightly-written and better documented program than  the  Yale
editor,  but  it  has  evolved  into an entity in its own right.  It
incorporates useful features from both the Rand editor and the  Yale
editor  plus  several new ideas.  It runs on the PDP-10 under either
the TOPS-10 or TOPS-20 monitor (in native mode).

     This editor, SED, has a number of features which distinguish it
from  its predecessors.  It is the first full-screen editor which is
easily adaptable to a wide range of terminals.   Also,  it  exploits
more  fully the capabilities of the terminal by letting the terminal
do the work whenever possible (and  it  knows  whether  or  not  the
terminal  is  equipped to do the job).  The editor has the usual set
of commands:  cursor movers,  display  window  movers,  inserts  and
deletes,  searches,  and line copiers;  all of which cause immediate
changes on the CRT screen when they are invoked.  In addition, there
are  a  number of shortcuts by which the sophisticated user can save
time and typing.

     SED is documented with  a  tutorial,  this  user's  manual,  an
installation   guide,  copious  comments  within  the  program,  and
software history files and suchlike for the serious hacker.



                         INTRODUCTION TO SED

     This document contains complete descriptions  of  all  the  SED
commands.   It  is  a  reference  manual,  good  for finding out the
details about things, but confusing as a learning tool.  If you  are
a  new  SED  user, the tutorial guide, DOC:SED.MAN would be a better
introduction to the editor.  But the  tutorial  will  only  get  you
started;   use  this reference manual when you feel comfortable with
the basic SED commands.

     Commands to SED are given  by  holding  down  the  key  labeled
'CNTR'  or  'CTRL'  and  typing a letter.  Also, some terminals have
special keys which are SED commands.  In this manual editor commands
are  notated  in  capital  letters  and  brackets.  For example, the
command used to advance 1 page (one screenful) in a file is given by
holding  the 'CONTROL' key and typing the letter 'Y';  it is notated
<ROLL-FORWARD-PAGES> or ^Y.  Think of the 'CONTROL' key as  a  shift
key.



                             RUNNING SED

     There are three ways of running the editor.  At  monitor  level
type

        .R SED                  or
        .R SED;FILE.EXT         or
        .R SED;FILE.EXT=


     The first way will set up for editing the file  (and  alternate
file*) which were edited last time.  SED will return you to the same
position in the file that you were last.  If you are running SED for
the  first  time a cheery welcome message will appear.  You can then
use the <SET-FILE> command (described below) to get a file to edit.

     If you type the second form SED will put you at  the  beginning
of  FILE.EXT  (or whatever file you give).  The file you edited last
time will be the alternate file.  If  the  file  given  in  the  run
command does not exist SED will tell you so and give you last time's
file or the cheery message.

     If you use the third form SED will do as above, except that  if
the file does not exist the editor will create it.



--------------------

* SED allows you to toggle between any  two  files.   The  alternate
file  is  the  one  which  is  not  currently being edited.  See the
<SET-FILE> command.

                               - 1 -



                             THE CURSOR

     Run the editor and get the cheery message (don't  give  a  file
name).   There will be a blinking dash in the upper left-hand corner
of the screen;  that dash is called the cursor,  and  it  represents
your position in the file.

     You cannot do much with the cheery message, so why not create a
new file and play around with the editor?  Type the following:

             PAD-BLUE A B C D = ^B

one key after another (with no spaces in between).  The editor  will
create a file named ABCD containing the obvious message

        ; This file is ABCD.

Note that the cursor is still at the upper left of the screen.

     If you type a character it will appear where the cursor is  and
the cursor will move one space to the right.  The character you type
will replace the one at the cursor position.  If INSERT MODE  is  in
effect  (see  the  <INSERT-MODE>  command) the new character will be
inserted in the line, and the rest of the line moved one position to
the right.

     A carriage return will put the cursor at the start of the  next
line  on  the  screen, but will not affect the contents of the file.
There are other keys that simply move the cursor  around:   the  key
off to the right labeled HOME and the four arrow keys near it (which
move the  cursor  in  the  indicated  directions),  <TAB>  (^I)  and
<BACKTAB>  (^U).   There's  also  a  command (<LINE>) to move to the
beginning or the end of a line.  Linefeed is  NOT  merely  a  cursor
mover, however (see the section on <CLEAR-LINE> or <ERASE-LINE>).

     Type something.  If you make a mistake  use  the  <CURSOR-LEFT>
key  to  back up over the bad character, and type the correct one on
top of it.  If you put in  one  character  too  many,  position  the
cursor  to  it  and  type  <DELETE-SPACES>  (^L).   There is a whole
spectrum of commands for inserting and deleting characters and lines
of  text,  moving  around  within the file, and other useful things.
Read on.












                               - 2 -



                      FORMAT OF EDITOR COMMANDS

     SED does not exist by cursor movements alone.  There is a whole
raft of commands, which have the following form:

           <COMMAND>
     or    <ENTER><parameter><COMMAND>
     or    <ENTER><cursor movement><COMMAND>
     or    <ENTER><COMMAND>                (TOKEN FORMAT)


     The <ENTER> key  is  PAD-BLUE.   A  parameter  is  a  piece  of
information that is used by a command.  For instance, if you want to
insert blank lines in a file the parameter is the  number  of  lines
you  want  to  insert.  Most commands have default parameters;  that
is, if you simply issue the command without  specifying  parameters,
SED  will  use  a  pre-set value for each parameter.  <INSERT-LINES>
(^D) will insert 1 line until you tell it otherwise, which you do by
using the second form of command.  If you say

        <ENTER>5<INSERT-LINES>

SED will insert 5 lines.  From that point on whenever you say

        <INSERT-LINES>

SED will insert 5 lines, until you change it again.

     Certain pairs of commands share parameters.  If you say

        <ENTER>5<INSERT-LINES>

and later say

        <DELETE-LINES>

SED will delete  5  lines  because  it  shares  its  parameter  with
<INSERT-LINES> (<DELETE-LINES> = ^F).

     If the /RESET switch is set  (see  the  section  on  <SWITCH>),
parameters will be reset to their initial values after each command.

     There are two  other  command  formats:   cursor  movement  and
tokens.   Both  are  shortcuts  for the advanced user, so if you are
just starting out don't worry about them for now.

CURSOR MOVEMENT

     To define a parameter by cursor movement,  type  <ENTER>,  move
the  cursor  around using any of the cursor movement commands to get
to a different row and/or column on the terminal screen,  then  type
the  desired  command.   The command will take as its parameters the
difference in rows or columns (or both).   Often  both  changes  are

                               - 3 -



useful;   you  can  delete three lines and the first 8 spaces of the
next line by typing

        <ENTER><RETURN><RETURN><RETURN><TAB><DELETE-LINES>

Cursor movement is  often  easier  to  do  than  counting  lines  or
characters.   It  is  not  meaningful  with every command;  an error
message will result from using it at the wrong time.  But usually it
is  used  for  what  you  think it ought to be, and illegal when you
can't see any reason for doing it.

TOKENS

     When you give a  token  parameter  you  ask  SED  to  read  the
parameter  from  the  file itself, at the cursor position.  However,
for some commands token format means that special action  should  be
taken,  the  nature  of  which  is  dependent  on  the command.  For
example, <ENTER><PERCENT> will move to the end of the file;  it's  a
shorthand  way  of  saying  <ENTER>100<PERCENT>.  Also, <ENTER><PUT>
will insert text which has previously been deleted  into  the  file;
it  is  the  only  way  of recovering that information.  The special
functions of this command format are described in detail  with  each
command.

     A token can be thought of as "the word at the cursor position."
Actually  the  formal  definition  is:   the  string  of  characters
starting  at  the  cursor  location  and  extending  to  the   first
nonalphabetic,  nonnumeric  character.   Thus  the  location  of the
cursor is important, and it need not be at the start  of  an  actual
word.  Sometimes SED is interested in the token itself, for instance
for the search command;  sometimes it  is  only  interested  in  the
length of the token, like for <DELETE-SPACES>.

     The token for the <SET-FILE> (^B) command  is  different.   The
parameter  for  <SET-FILE>  (set  up  a  new file for editing), is a
filespec.  Since filespecs usually consist of at least a name and an
extension,  the  usual  token will not work, since it will recognize
only the file name (and stop on the ".").   So  for  the  <SET-FILE>
command  a token is defined as extending from the cursor position to
the next  space,  tab,  comma,  or  control  character.   All  other
characters will be legal token characters.

     Tokens, of course, don't  give  you  anything  you  don't  have
already;  they just save some typing.

EDITING A PARAMETER

     Parameters can be edited:  an entire parameter can be  canceled
by  typing  <RESET>  (which  is  invoked  by  DELETE).   The  latest
character of the parameter can be deleted by typing <CURSOR-LEFT> or
<DELETE-CHARACTER>  (BKSP).  The latest word of the parameter can be
erased by <BACKTAB> (^U) or  <ERASE-WORD>  (PAD-.),  and  the  whole
parameter erased by <ERASE-LINE> (^J).

                               - 4 -



                       COMMANDS TO THE EDITOR

     This section describes all the commands to  SED,  telling  what
they  are, how they are (normally) invoked, what types of parameters
they accept, and any special attributes they have.

     Each entry in this section describes one  command,  or  two  if
they  are  related  and  share a parameter value.  The format of the
entries in this sections is:

COMMAND NAME(S)                 CONTROL CHAR(S) WHICH INVOKE

        STARTING NOMINAL
        TYPE OF PARAMETER EXPECTED
        CURSOR MOVEMENT DEFINED (NONE, CHANGE OF ROW, COLUMN, BOTH)
        TOKEN (NONE, TOKEN, OR SPECIAL)


DESCRIPTION OF THE ACTION TAKEN BY THE COMMAND

EXAMPLE: A LINE OR TWO BEFORE AND AFTER EDITING

































                               - 5 -



***************************************************************************
The  commands  on  this  page  and the next (through <LINE>) are the
cursor movement commands.   They  move  the  cursor  around  on  the
terminal screen.  but have no effect on the file.        These
commands can be used in a  parameter  to  define  a  region  of  the
screen, between where the cursor was when you typed <ENTER> to where
it was when you typed a non-cursor movement command.

***************************************************************************
<CURSOR-RIGHT>
<CURSOR-LEFT>
<CURSOR-UP>
<CURSOR-DOWN>

     Moves the cursor in the indicated  direction.   If  the  cursor
goes  off  the  edge of the screen it will wrap around and appear at
the other side.

     If /SCROLL is set, <CURSOR-UP> at the  top  of  the  screen  or
<CURSOR-DOWN>  at the bottom will roll the screen one line.  See the
<SWITCH> command.


***************************************************************************
<CURSOR-HOME>                                   PAD-BLK

     Moves the cursor to the upper left-hand corner of the screen.


***************************************************************************
<UP-TAB>                                        PAD-8
<DOWN-TAB>                                      PAD-2

     Moves the cursor up or down six lines.   Exactly  the  same  as
typing six <CURSOR-UP> or <CURSOR-DOWN>s.


***************************************************************************
<CARRIAGE-RETURN>                               ^M

     Moves the cursor to the start of the  next  line  (ie,  does  a
CARRIAGE  RETURN,  LINEFEED).   If  the cursor started on the bottom
line of the screen the screen will roll up one line, a new line will
appear  at  the  bottom  of  the  screen,  and  the  cursor  will be
positioned at the start of it.

     In   INSERT    mode    (see    the    <INSERT-MODE>    command)
<CARRIAGE-RETURN>  will  actually  insert  a  <CRLF>  at  the cursor
location.

     Switches relevant to <CARRIAGE-RETURN>:  /ROLL and  /ICR.   See
the <SWITCH> command.


                               - 6 -



***************************************************************************
<TAB>                                           ^I
<BACKTAB>                                       ^U

     Moves  to  the  next  tab  stop  in  the  forward  or  backward
direction.  Tab stops are normally 8 spaces apart.

     Tabs can be set to be any constant distance  apart,  using  the
<SWITCH> command.  For example, to set tabs every 6 columns, type

        <ENTER>T:6<SWITCH>

Also, you can use the <TAB-SET> command to set  additional  tabs  or
clear tabs you don't want.  See the <TAB-SET> section.

     There are also wordwise tabs, which you ask for by  typing  the
/T:W  or /NOTABS switch.  Then <TAB> and <BACKTAB> function in terms
of words of text rather  than  screen  position.   The  table  below
explains what happens:

CURSOR AT:          TAB MOVES TO:         BACKTAB MOVES TO:
  within the line     start of next word    start of previous word
  start of line       start of next word    end of previous line
  last word of line   end of line           start of previous word
  beyond end of line  next normal tab stop  start of last word of line

     The /DELIM:  switch will make  wordwise  tabs  stop  after  the
given characters, in addition to stopping at the starts of words.

     If you want a TAB command which actually inserts a TAB into the
file you are editing, see <REAL-TAB>.

***************************************************************************
<BEGIN-LINE>                                    PAD-4
<END-LINE>                                      PAD-6

     <BEGIN-LINE> moves the cursor to the beginning of the  line  it
is on.  <END-LINE> moves the cursor to the end of the line it is on.

***************************************************************************
<LINE>                                          (none)

     <LINE> does the functions of <BEGIN-LINE> and  <END-LINE>:   it
moves the cursor to the beginning of the line, unless it was already
there, in which case it moves to the end of the line.   Thus  <LINE>
will  usually  move  to the beginning, and <LINE><LINE> will usually
move to the end.  It's not as hard to do as it is to describe.

     If <LINE> is  typed  within  a  parameter  it  acts  as  cursor
movement, moving to the beginning or the end of the line as above.




                               - 7 -



***************************************************************************
<ROLL-BACK-PAGES>                               ^A
<ROLL-FORWARD-PAGES>                            ^Y

        Starting nominal: 1 page
        Parameter: number (pages to roll)
        Cursor move: illegal
        Token: length of token is number of pages to roll

     Advances or backs up the given number of  pages  (screens-full)
of the file.

     <ROLL-BACK-PAGES> won't move before the start of the file,  and
<ROLL-FORWARD-PAGES>  won't  move  beyond  the end of the file.  Use
<INSERT-LINES> to extend the file, not one of the  rolls.   Or  just
type on the last line on the screen.

     Another  way  to  get  back  to  where  you  were  before   the
<ROLL-PAGES> command is to type <ENTER>P<MARKER>.






***************************************************************************
<ROLL-BACK-LINES>                               ^W
<ROLL-FORWARD-LINES>                            ^T

        Starting nominal: 1/3 page
        Parameter: number (lines to roll)
        Cursor move: lines only; spaces ignored
        Token: causes scanning to begin

     Same as above, but movement is in terms of lines.

     Scanning is when the editor does  a  roll  (using  the  current
nominal),  delays for a short time, then rolls again.  It is started
by typing <ENTER><ROLL-BACK-LINES> (or <ENTER><ROLL-FORWARD-LINES>).
Scanning continues until the start or end of the file is reached, or
until you type any character.  When scanning  stops  the  cursor  is
left in the middle of the screen to indicate that scanning is over.












                               - 8 -



***************************************************************************
<PERCENT-GOTO>                                  ^P

        Starting nominal: 0 percent
        Parameter: number between 0 and 100 (percent distance into file)
        Cursor move: illegal
        Token: acts same as 100 percent

     Displays the file starting the given percent into  it.   Typing
<ENTER>50<PERCENT-GOTO>  will  display  the  file  starting  mid-way
through.  <ENTER>100<PERCENT-GOTO> (or  just  <ENTER><PERCENT-GOTO>)
will  display the last several lines of the file, with the cursor at
the end of the last line.

     <PERCENT-GOTO> is very much faster than a <ROLL> command, since
it  does  not  count lines of text.  It can also be used to speed up
searching, by <GOTO>ing a place near where you expect  a  match  and
then doing the search.

     To get  back  to  where  you  were  before  the  <PERCENT-GOTO>
command, type <ENTER>P<MARKER>.

***************************************************************************
<SLIDE-LEFT>                                    ESC-L
<SLIDE-RIGHT>                                   ESC-T

        Starting nominal: 8 spaces
        Parameter: number (spaces to slide)
        Cursor move: spaces only; lines ignored
        Token: takes length of token

     Moves screen  window  left  or  right  within  the  file.   For
example,  after  a  nominal <SLIDE-RIGHT>, the first 8 characters of
each line will not appear on the screen (they will be off  the  left
of  the  window),  and  each  line  displayed  will  show  character
positions 9 through 88.

     The window can be slid right an unlimited amount, but it cannot
be  slid  left past the left margin.  The cursor will always stay on
the line it is on at the start of the slide;  if  the  character  it
pointed  to  is out of the window the cursor will point to the first
character on that line that is on the screen.

     /SLIDE:n sets the nominal distance to slide to be n.   /NOSLIDE
disables <SLIDE-LEFT> and <SLIDE-RIGHT>.  See the <SWITCH> command.









                               - 9 -



***************************************************************************
<INSERT-LINES>                                ^D
<DELETE-LINES>                                ^F

        Starting nominal: 1 line
        Parameter: number (lines to insert/delete)
        Cursor move: lines; spaces counted from left margin
        Token: takes size of token, plus 1

     <INSERT-LINES> adds the given number of  lines  at  the  CURSOR
POSITION  (the  given  number  of spaces are also added, if they are
asked for by a cursor move.  Thus if the cursor is on line 5  column
8,  and  you type <ENTER><CURSOR-DOWN><INSERT-LINES>;  then one line
and 8 spaces will be added to the file.  The result will be to split
line  5,  moving  everything after the cursor one line down.  If, in
the same position, you type  <ENTER><CARRIAGE-RETURN><INSERT-LINES>;
then  one line (and no spaces) will be added, and the result will be
to split the line and put the stuff after the  cursor  on  the  next
line,  starting at the left margin.  That last command could also be
made by typing <ENTER>1<INSERT-LINES>.

     <DELETE-LINES>  removes  lines  (and   spaces,   using   cursor
movement) analogously.  The deleted material is not thrown away, but
is stored in the DELETE BUFFER.  It can  be  replaced  in  the  file
using  the  <PUT>  command.   So if you <DELETE-LINES> accidentally,
type <ENTER><PUT> to get the lines back.

     Deletes of any size are permitted.  However, if more than about
50 lines are deleted, the delete buffer will overflow and it will be
written out  on  disk.   Everything  will  work  normally,  although
perhaps  a  little  more slowly.  However, there will be a new file,
nnnCLS.TMP (where nnn is your job number)  sitting  around  in  your
area.

     Overflowing the delete buffer has its  advantages.   nnnCLS.TMP
is  just another file, and can be edited the same as any other file.
It will stay around until it is overwritten by another large delete.
Thus  suppose  you  do  a 100-line delete, then a 1-line delete, and
then realize that part of those  100  lines  should  not  have  been
deleted.  You cannot type <ENTER><PUT> to restore those lines, since
what you will get is the single latestly-deleted line.  But you  can
get  into the nnnCLS.TMP file (using the <SET-FILE> command), <PICK>
up the desired lines, return to your original file,  and  <PUT>  the
lines back in.

     Another use of the delete buffer is to split a  file  into  two
pieces  (as long as one piece is large enough to overflow the delete
buffer).  To create two files, one containing the  first  100  lines
and  the  other  the  remainder, go to the beginning of the file and
type <ENTER>100<DELETE-LINES>.  Then  exit  the  editor  and  rename
nnnCLS.TMP to whatever you want;  it contains the first 100 lines.



                              - 10 -



EXAMPLE: The cursor is on the word "and"; you type <ENTER>2<INSERT-LINES>

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is the thing of the gig


        and the gig is where it's at

If you then do a <DELETE-LINES> the two blank lines will be removed.
Now say the cursor is on the "f" and you type <INSERT-LINES>:

BEFORE: Pack my box with five dozen liquor jugs.

AFTER:  Pack my box with

        five dozen liquor jugs.

Two blank lines have been inserted at the cursor position.

***************************************************************************
<DELETE-CHARACTER>                              BKSP

        No parameters

     Deletes the character to the  left  of  the  cursor.   If  that
character  is  a tab, <DELETE-CHARACTER> deletes the entire tab.  At
the beginning of a line <DELETE-CHARACTER> has no effect.

     If typed in a parameter, <DELETE-CHARACTER> will  still  delete
the   character   before   the   cursor.    Thus,  in  a  parameter,
<DELETE-CHARACTER> and <CURSOR-LEFT> have the same effect.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.

***************************************************************************
<ERASE-WORD>                                    PAD-.

        No parameters

     Deletes the word to the left of the  cursor.   <ERASE-WORD>  at
the beginning of a line deletes the last word on the previous line.

     A  word  is  a   string   of   alphanumerics,   or   a   single
non-alphanumeric, followed by zero or more spaces or tabs.

     <ERASE-WORD> deletes words in  parameters,  too.   Thus,  in  a
parameter, <ERASE-WORD> and <BACKTAB> have the same effect.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.



                              - 11 -



***************************************************************************
<ERASE-LINE>                                    ^J

        No Parameters
        If typed in a parameter, erases entire parameter

     The <ERASE-LINE> command deletes all characters from the cursor
position to the end of the line.  It is also used to erase an entire
parameter.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.

EXAMPLES: The cursor is on the "h" of "the" and you type <ERASE-LINE>:

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is t
        and the gig is where it's at

You type <ENTER>THING and wanted to  type  <ENTER>12.   <ERASE-LINE>
will erase the parameter "THING" and let you start again:

BEFORE: >THING
AFTER:  >


***************************************************************************
<CLEAR-LINE>                                    (none)

        No Parameters

     Clears out the entire line which the cursor  moves  onto.   The
contents  of  the line is not saved.  <CLEAR-LINE> won't work if the
cursor starts on the last line of the screen.  This is  a  dangerous
command,  but  useful  for cleaning out a lot of garbage and leaving
blank lines behind.

     Note:  <CLEAR-LINE> is almost the same as <ERASE-LINE> but  not
as useful.  It is included for compatibility, but is obsolete.

EXAMPLE: The cursor is on the word "thing"; you type <CLEAR-LINE>

BEFORE: This is the thing of the gig
        and the gig is where its at
        This is another thing of the gig

AFTER:  This is the thing of the gig

        This is another thing of the gig

Now the cursor is where the "is" used to be on the second line.


                              - 12 -



***************************************************************************
<INSERT-SPACES>                                 ^K
<DELETE-SPACES>                                 ^L

        Starting nominal: 1 space
        Parameter: number (spaces to insert/delete)
        Cursor move: spaces;
                     change in line causes rectangular insert/delete
        Token: uses size of token, plus 1

     Adds spaces (to add a string, see <PUT>) or deletes  characters
starting  at  the  cursor position.  The deleted stuff can be gotten
back by typing <ENTER><HELP>.

     EXAMPLE:  The cursor is at "t" of the word "thing";   you  type
<ENTER>4<INSERT-SPACES>:

BEFORE: This is the thing of the gig

AFTER:  This is the     thing of the gig

Then you move to the "o" of "of" and type <DELETE-SPACES>:

AFTER:  This is the     thing he gig

     A rectangular <INSERT-SPACES> works as follows:  say  you  type
<ENTER><DOWN><DOWN><RIGHT><RIGHT><INSERT-SPACES>.     Your    cursor
movement has defined a rectangle  whose  opposite  corners  are  the
starting  and  ending  cursor positions (in this case, three rows by
two columns).  That rectangle  will  be  filled  with  spaces.   For
example,  say  the  cursor  starts  at  the "o" of "of" and you type
<ENTER><DOWN><DOWN><RIGHT><RIGHT><INSERT-SPACES>.  The  cursor  ends
after the "f" of "five".

BEFORE: This is the thing of the gig,
        and the gig is where it's at.
        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

AFTER:  This is the thing   of the gig,
        and the gig is whe  re it's at.
        Pack my box with f  ive dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.


     Rectangular <DELETE-SPACES> works in a similar  manner,  except
that  all  the  characters within the rectangle are removed from the
file.

     If you just move the cursor up  or  down,  with  no  change  in
column  position,  you will work with a rectangle whose width is the
same as last time (which is useful if you  can  remember  what  last
time's parameter was).

                              - 13 -



***************************************************************************
<SEARCH-FORWARD>                                ^R
<SEARCH-BACK>                                   ^E

        Starting nominal: none
        Parameter: string (search key)
        Cursor move: spaces (change of lines is illegal)
        Token: uses token

     Searches for the given string, from the cursor position to  the
end of the file, or from the cursor position to the beginning of the
file.  When the key is found, a page from the file is displayed with
the  line containing the match one-third of the way down the screen.
If the match is on the page displayed at the start of the search the
cursor simply moves to the first character of the match.

     A search can be aborted at any time by typing RUBOUT.  This  is
useful,  for  example,  when your key was erroneously typed in lower
case and the file is  entirely  upper  case.   The  screen  will  be
restored to its pre-search status.

     CONTROL-?  and CONTROL-LEFT-ARROW are wild  search  characters;
they  will  match  any single character in their position.  Thus the
command

        <ENTER>THE^O?E<SEARCH-FORWARD>

(see the section on <ENTER-CONTROL-CHARACTER> to find out why  ^O  ?
sets  up  a  CONTROL-?)  will  match  on THESE, THERE, THEME, or THE
ERROR, among other things.

     A useful feature:  <ENTER>^OJGIG<SEARCH-FORWARD>  searches  for
the next line that begins with GIG.

HINT:  Searches will go faster if the first character of the key  is
uncommon.  Thus searching for "XECUTE" will be faster than searching
for "EXECUTE", and will accomplish the same thing.

     If the /CASE switch is set  searches  are  case-dependent;   if
/NOCASE they are case-independent (ie, "t" will match "t" or "T").

     You can use the <RECALL> command to get back  your  current  or
previous search key.  See the section on <RECALL>.

     To get back to where you were before a <SEARCH>  command,  type
<ENTER>P<MARKER>.








                              - 14 -



***************************************************************************
<SUBSTITUTE>                                    ^~

        Starting nominals: none
        Parameters: Sstring, Rstring, or number
        Cursor move: illegal
        Token: illegal

     <SUBSTITUTE> searches forward from the cursor  position  for  a
string  (the  key)  and  substitutes  another string (the substitute
string) for it.  You can tell <SUBSTITUTE> how many times to  repeat
the process.

     There are three types of parameters to <SUBSTITUTE>:

        <ENTER>Sstring1
        <ENTER>Rstring2
        <ENTER>number

     The first sets up string1 as the search key.  The  string  must
be  preceded  by  the letter "S" (or "s").  The search key is shared
with the <SEARCH-FORWARD> and <SEARCH-BACKWARD> commands.

     The second parameter sets up string2 as the entity  to  replace
occurrences  of  string1.  The string must be preceded by the letter
"R" (or "r").  String2 may be null, meaning  that  string1  will  be
deleted wherever it is found.

     The third parameter tells how many times to perform the  search
and substitute.

     Searching is done the same as for  the  <SEARCH>  commands,  so
wild  characters,  case  independence, and aborting the command with
RUBOUT all work.

     One, two, or all three of these  parameters  may  be  given  at
once, in any order.  The command

        <ENTER>SFOO<ENTER>Rfoo<ENTER>1000<SUBSTITUTE>

will change all occurrences of "FOO" to "foo" from the cursor to the
end of the file (well, 1000 times, anyway).

     Following the above command with

        <ENTER>SFUBAR<ENTER>1000<SUBSTITUTE>

will change all occurrences of "FUBAR"  to  "foo".   Note  that  the
substitute key was not given, so it defaulted to its latest setting.

     Sometimes it is useful to set up the  parameters,  think  about
them,  and  perform  the substitute when everything looks right.  If
the numeric parameter is omitted, them <SUBSTITUTE> will set up  the

                              - 15 -



key and substitute string, but will not execute.  Thus the commands

1)      <ENTER>SGIG<ENTER>RTHING<SUBSTITUTE>
2)      <ENTER>1<SUBSTITUTE>
3)      <SUBSTITUTE>
4)      <ENTER>10<ENTER>STHIS<SUBSTITUTE>
5)      <SUBSTITUTE>

work as follows:

1) Only sets up the parameters; makes no substitutions.
2) Does one <SUBSTITUTE> since there was a numeric parameter.
3) Also does one <SUBSTITUTE>.
4) Changes the search key to "THIS" and does 10 iterations.
   (the replace key is still the same).
5) Also does 10 iterations.

Note:  <SUBSTITUTE> is the only command for which multiple  <ENTER>s
are  meaningful.   For other commands, all <ENTER>s except the first
one are ignored.


































                              - 16 -



***************************************************************************
<PICK>                                          ^V

        Starting nominal: 1 line
        Parameter: number of lines
        Cursor move: lines; spaces counted from left margin
        Token: uses token

     Copies lines and/or partial lines from the file into  the  pick
buffer.   The  file is not changed.  Words (instead of lines) can be
<PICK>ed using cursor movement or token picks.

     If a pick of more than 100 lines is done, the pick buffer  will
overflow and be written out on disk.  Everything will work normally,
though.  Picks of any size are permitted.  However, there will be  a
new file, nnnPIK.TMP, sitting around on disk.

     The same discussion about overflow of the delete buffer applies
to overflow of the pick buffer.

EXAMPLES:  Say the cursor is at the start of the first line of:

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.
        Now is the time for all good people to
        come to the aid of their party.

If you type <ENTER>2<PICK> you will load the pick buffer with

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

There's a carriage return at the end of each line.   You  can  avoid
picking  the  last carriage return by using cursor movement:  typing
<ENTER><END-LINE><PICK> will load

        Pack my box with five dozen liquor jugs.

into the pick buffer, without the trailing carriage return.

     If  you  type <ENTER><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT>
<PICK> (6 RIGHTs) you will load

        Pack m

And if you type  <ENTER><DOWN><RIGHT><RIGHT><RIGHT><PICK>  you  will
pick up

        Pack my box with five dozen liquor jugs.
        Qui




                              - 17 -



     Normally, <PICK>  clears  the  pick  buffer  each  time  before
writing it.  However, there is a switch, /APPND, which causes <PICK>
to  append  to   the   buffer.    It   works   as   follows:    Type
<ENTER>/APPND<SWITCH>  to  tell  SED  to  append to the pick buffer.
When you do your first <PICK> after setting the  /APPND  switch  the
pick  buffer  will  be cleared and the text put into it.  The second
<PICK> will be added at the end of the first, and so  on.   You  can
<PUT>  the buffer and then continue appending to it if you want.  To
stop appending type the /NOAPPND switch.  To clear  the  buffer  and
keep appending type the /APPND switch again.

EXAMPLE:  Suppose the text is (again):

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.
        Now is the time for all good people to
        come to the aid of their party.

If you type <ENTER>/AP<SWITCH> and then <PICK> the  4th  line,  then
the 3rd, 1st, and 2nd lines, then <PUT>, you get:

        come to the aid of their party.
        Now is the time for all good people to
        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

inserted into the file.  The lines are sorted, for reason unknown.

     Typing more <PICKS> will continue to append.  If you then  type
<ENTER>/AP<SWITCH> and do two <PICK>s, just the text from those last
two <PICK>s will be in the buffer.

     You can append any kind of <PICK> to the buffer;   full  lines,
partial  lines,  single  words,  or a <PICK> using a <MARK> will all
work.

     The /APPND and /NOAPPND switches do not affect the contents  of
the pick buffer directly;  they just tell the following <PICK>s what
to do.















                              - 18 -



***************************************************************************
<PUT>                                           ^G

        Starting nominal: none
        Parameter: string (read into pick buffer)
        Cursor move: spaces (change of lines is illegal)
        Token: causes DELETE buffer to be PUT

     <PUT> writes text from either the pick  buffer  or  the  delete
buffer  into  the file, at the cursor location.  The contents of the
buffer is not changed.  The normal use of this command is to  <PICK>
something,  move  to  a  new location, and <PUT> it by simply typing
<PUT>.  Or <DELETE-LINES> something, move, and insert it  by  typing
<ENTER><PUT>.

     PUT is also used to insert a  string  directly  at  the  cursor
position.  The string is given as the parameter.  If you type

        <ENTER><string><PUT>

then <string> will be inserted at the cursor location.   The  string
will  also  be  stored  in  the  pick  buffer, so it can be inserted
somewhere else by simply typing <PUT>.

     EXAMPLE:  The cursor is at the "t" of the  word  "thing";   you
type  <ENTER><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><PICK>,  thus
loading "thing " into the pick buffer using  cursor  movement.   The
cursor is still at "thing".  Now type <PUT>:

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is the thing thing of the gig
        and the gig is where it's at

Now do a <BEGIN-LINE> to get to the beginning of that line and  type
<DELETE-LINES> (with the starting nominal of 1 already set up):

AFTER:  and the gig is where it's at

The deleted line has been loaded into  the  delete  buffer.   Typing
<DOWN><ENTER><PUT> restores that line beneath the other one:

AFTER:  and the gig is where it's at
        This is the thing thing of the gig

Now  position  the  cursor  to  the  "w"   of   "where"   and   type
<ENTER>NOT<PUT>:

AFTER:  and the gig is NOT where it's at
        This is the thing thing of the gig



                              - 19 -



***************************************************************************
<MARK>                                          PAD-7

        No Parameters
        Token: cancels mark

     This command extends the  <PICK>  and  <DELETE-LINES>  commands
using  cursor  movement  to  work with arbitrarily large sections of
text (ie, not restricted to within the limits of the screen).   When
MARK  is typed SED stores the current cursor position.  You can then
move  to  any  other  part  of  the  file  and   type   <PICK>   (or
<DELETE-LINES>),  and  all  the text between the mark and the ending
cursor position will be picked up (or deleted).  It  doesn't  matter
whether the ending cursor position is before or after the mark.

     Thus the <MARK> command temporarily changes  the  effect  of  a
<PICK>  or  <DELETE-LINES>  without a parameter.  When the <PICK> or
<DELETE> has been done, the mark is  forgotten  and  those  commands
perform normally again.

     Typing <ENTER><MARK> will  cancel  the  mark  and  restore  the
screen to the way it was when you typed <MARK>.

     The mark is also forgotten if you type any command which alters
the  file  (including  typing  a  character).   Every  other command
retains the mark.  You can get to the ending position  any  way  you
want:  <ROLLS>, <PERCENT-GOTO>, and <SEARCHES> are probably the most
useful ways.

     Say the nominal number of lines to pick is 1.  If you type:

        <MARK>
        <ENTER>10<ROLL-FORWARD-PAGES>
        <PICK>

then 10  screens-full  (say  around  240  lines)  of  text  will  be
<PICK>ed.   Those  lines  can  be PUT in the normal way.  If you now
type another <PICK> you will pick up 1 line.

     To  move  back  to  the  end  of  the   marked   region,   type
<ENTER>P<MARKER>.













                              - 20 -



***************************************************************************
<MARKER>                                        ^?

        Starting nominal: none
        Parameters: none, Sname, Gname, Kname, N, P, F
        Cursor move: illegal
        Token: Goes to default marker

     <MARKER> sets markers (placeholders) in the file, goes  to  the
named  marker,  kills  a  marker  name, and outputs the names of the
currently-defined markers.  <MARKER> also is used to pop the  marker
stack (described below).

     Note:  <MARKER> is different from the <MARK>, described above.

     There are 11 markers.  All except one  (the  "default"  marker)
must  be  named.   The  default  marker  is easy to work with but it
doesn't have a name.

Type:                 To:
  <MARKER>              Set the default marker at current position
  <ENTER><MARKER>       Go to the default marker
  <ENTER>Sname<MARKER>  Set marker named "name" at current position
  <ENTER>Gname<MARKER>  Go to marker "name"
  <ENTER>G<MARKER>      Go to the latest-set marker
  <ENTER>Kname<MARKER>  Kill (delete) marker "name"
  <ENTER>K*<MARKER>     Kill all markers
  <ENTER>N<MARKER>      List the currently-defined marker names
  <ENTER>P<MARKER>      Pop the marker stack; go to popped location
  <ENTER>F<MARKER>      Pop the Marker Stack forward

     When you set a marker, the position of the  upper-left  of  the
screen  is saved.  When you go to a marker, SED displays the file at
the saved position, with the cursor home.

     If you add or delete text in the file the marker may move some;
if so, it will usually be earlier in the file than you expect.

     The marker stack is a list of the 8 most  recent  "interesting"
positions  in  the  file.   Positions are pushed on it automatically
when certain commands are typed (see below).  Positions  are  popped
and moved to by typing <ENTER>P<MARKER> or <ENTER>F<MARKER>.

     The screen position is pushed on the marker stack  before  each
of   these  commands  is  executed:   <ROLL-PAGES>,  <PERCENT-GOTO>,
<SEARCHES> (when the screen position changes).   Also,  if  you  use
<MARK>  with  <PICK>  or  <DELETE-LINES>,  the  end of the region is
stacked.

     Thus <ENTER>P<MARKER> will get  you  back  to  where  you  were
before a search, or to the end of a <MARK>ed region.  if you pop too
far and want  to  get  back  to  a  previously-popped  marker,  type
<ENTER>F<MARKER>.

                              - 21 -



***************************************************************************
<INSERT-MODE>                                   PAD-ENT

        No Parameters

     This command toggles SED between REPLACE mode and INSERT  mode.
In REPLACE mode when you type a character it replaces the one at the
cursor position.  In INSERT mode the new character is placed  before
the one at the cursor and the rest of the line is moved one position
to the right.

     If SED is in REPLACE mode, typing <INSERT-MODE> will put it  in
INSERT  mode.  Then typing <INSERT-MODE> will put the editor back in
REPLACE mode.

     If you type the wrong character you can  delete  it  using  the
<DELETE-CHARACTER> command (see above).

     Character strings can also be inserted in the  file  using  the
PUT command, by typing <ENTER>string<PUT>.

     Switches relevant to <INSERT-MODE>:  /BEEP, /ICR,  and  /IMODE.
See the <SWITCH> command.




***************************************************************************
<SAVE-FILE>                                     (none)

        No parameters

     Saves the current file without exiting.

     BEWARE:  <SAVE-FILE> is designed to work quickly,  so  it  does
not   eliminate   nulls   or   trailing   spaces   from   the  file.
<SAVE-FILE><ABORT> is NOT the same as <EXIT>.  If you  have  changed
the file be sure to end the session with an <EXIT>.
















                              - 22 -



***************************************************************************
<SET-FILE>                                      ^B

        Starting nominal: none
        Parameter: string (filespecs)
        Cursor move: spaces (change of lines is illegal)
        Token: uses filespec token

     Looks up and displays the given file.  Saves previous  file  on
disk.   Saves  position in previous file.  If new file is not found,
returns to the previous file.  A backup file is made  if  /BACKU  is
set, else not.

     The   filespec   parameter    is    in    the    usual    form:
DEV:FILE.EXT[P,PN].  DEV:  defaults to DSK:, [P,PN] defaults to your
own.  If EXT is missing SED  will  try  some  extensions  until  one
succeeds:   none,  device  (if you typed HLP:FILE, SED will look for
HLP:FILE.HLP), the extension of the previous file,  MAC,  TXT,  RNO,
FOR,  CBL,  DAT (You can change this list of extensions by using the
/EXT:  switch).

     All of the switches described for the <SWITCH> command  can  be
given  along with the file specs (for example, DSKD:FOO.BAR/NOTABS).
Particularly relevant are the following:

/AGAIN   Set to the current file again. (or /AGAIN:n to set n percent
         into the file). <ENTER>/AG<SET-FILE> is the same as typing
         <ENTER>current-filespec<SET-FILE>.
/BACKU   Create a backup file on exit or save.
/CREATE  Create the file if it cannot be found.
/EXT:e,e Define the list of default extensions.
/GOTO:n  Set to n percent into the new file.
/GREAD   Set all files looked at to be read-only.
/ID:s,s  Put an I.D. line at the beginning of the file when saving.
/OUT:fs  Output the new file under the filespec "fs".
/QUICK   Causes the file not to display after the <SET-FILE>.
/RCUR    Causes the alternate file to remain and the current file to be
         replaced by the new one.
/READ    Declare the file read-only.
/STRIP   Strip other editors' line numbers from the file.
/WRITE   Declare that the file can be modified.

     <SET-FILE> with no parameter will return to the previous  file,
to  the  same  page  and  cursor  position  as was last set up.  The
current file will then become the new previous file.  Thus  you  can
toggle  back  and  forth  between  two files, after setting them up,
simply by typing <SET-FILE>s.

     If /CREATE is set the file will be created if it is not  found.
If /NOCREATE is set (which is the default), a "FILE NOT FOUND" error
will result.  To force the file to  be  created,  end  the  filespec
parameter with an "=".  Then if the file exists it will be looked up
as usual, but if it does not exist a file with a clever message will

                              - 23 -



be  materialized  and set up for editing.  SED will not overwrite an
existing file.

     Exception:  if you <SET-FILE> to your current file (so you  can
look  at  two  different places in the same file), SED will not save
the file.  This is so the change of file pointers can take place  as
quickly  as possible.  The file will be saved when you <SET-FILE> to
a different file or <EXIT> SED.

     The file is only saved on a <SET-FILE> or an  <EXIT>;   editing
is  only done to the in-core image of the file.  During the save all
nulls are removed from the file (they are added in abundance  during
editing),  and  trailing  spaces and tabs are removed from each line
(unless /TRAIL is set) (NOTE:  the file  can  also  be  saved  using
<SAVE-FILE>  or  with  the  incremental  save switches.  However, in
order to save the file quickly those commands to  not  remove  nulls
and  trailing  spaces  and  tabs.   Therefore  you  should end every
editing session with a <SET-FILE> or <EXIT>).

     To exit SED and forget all changes, use  the  <ABORT>  command.
The file will be the way it was before you edited it.

     Appendix A tells how filespecs default.  Appendix B  tells  how
to move back and forth through a list of files.






























                              - 24 -



***************************************************************************
<EXIT>                                          ^Z
<ABORT>                                         ^C

        Parameters or token causes Exit and Go (EXIT only)

     Saves the current file and exits to the monitor.

     The editor writes the file nnnSED.TMP (where nnn  is  your  job
number)  containing  the  names  and  status  of  the last two files
edited.  The next time you run the editor the latest of these  files
will  be  automatically set up, with display and cursor position the
same as they were upon exit.

     If any parameter is typed (or a token, ie, just  <ENTER><EXIT>)
the  editor  will exit as above and run COMPIL.  COMPIL will execute
the last compile-class command.  Other programs can be run on  exit;
see the /PROG:  switch.

     Unless told otherwise (see the  <SWITCH>  command)  the  editor
creates  a backup file, with extension .BAK, containing the file the
way it was before editing.

     <ABORT> does not save the file - the file ends  up  as  it  was
before the editing session.

     The editor can be re-entered after a mistaken <EXIT> or <ABORT>
by typing REENTER.

***************************************************************************
<RESET>                                         DELETE

        Starting nominal: none
        Parameter: ^ (up arrow) is the only meaningful parameter
        Cursor move: undefined
        Token: causes rewrite of single line

     <RESET> can cancel  an  entered  parameter,  reset  the  cursor
position,  rewrite a single line, or re-do the entire screen.  It is
useful if you  don't  trust  what  you  see.   If  you  ever  get  a
"Timesharing  ends"  message while you're editing, you'll appreciate
being able to <RESET>.

     <RESET> also repairs the bottom line of the screen  if  it  has
been overwritten with status information.

To:                                    Type:
  Cancel a parameter                     <RESET>
  Position the cursor properly           <RESET>
  Repair the bottom line                 <RESET>
  Rewrite the line the cursor is on      <ENTER><RESET>
  Re-do the entire screen                <ENTER>^<RESET>


                              - 25 -



***************************************************************************
<TAB-SET>                                       ESC-S

        Starting nominal: none
        Parameter: C or D
        Cursor move: illegal
        Token: clear tab at cursor position

     Sets, clears, and displays tab settings.  To set a tab move the
cursor  to  the desired column and type <TAB-SET>.  To clear the tab
at the cursor,  type  <ENTER><TAB-SET>.   To  clear  all  tabs  type
<ENTER>C<TAB-SET>.

     <ENTER>D<TAB-SET> displays a ruler on the bottom  line  of  the
screen,  with  the  tab  settings  marked by dashes, the left margin
(/LMARGN) by a slash, and the right margin (/RMARGN) by a backslash.
The ruler can be erased by typing <RESET>.

     Tabs can also be set using the /TSET:n switch:  /TSET:12 sets a
tab  at  column  12;  /NOTSET:12 clears that tab.  /TSET:14,52,36,76
sets tabs at the four given  columns;   /NOTSET:12,15  clears  tabs.
/TSET is useful in SWITCH.INI or SED.INI and execute (.XCT) files.

     See also the <TAB> and <SWITCH> commands.






























                              - 26 -



***************************************************************************
<REWRITE>                                       PAD-5

        No parameters

     Rewrites the entire terminal screen without changing  anything.
<REWRITE>  does the same thing as <ENTER>^<RESET>, above.  <REWRITE>
is commonly used to repair a screen which has been messed  up  by  a
system message or something.



***************************************************************************
<ENTER-CONTROL-CHARACTER>                       ^O

        No parameters

     Causes the next character typed to be a  control  character  (a
character, now, not a command).  Has no effect on commands.  Thus if
you type in your file

                ABC<ENTER-C-C>D

the characters A, B, C, and CONTROL-D will be placed in the file.

     <ENTER-C-C> also works within parameters, so

        <ENTER>ABC<ENTER-C-C>D<PUT>

will put A, B, C, CONTROL-D into the file.

     Note:  this command is the way to get a TAB or a FORMFEED (page
mark)  into a file.  For a TAB type <ENTER-C-C>I, and for a formfeed
type <ENTER-C-C>L.



***************************************************************************
<REAL-TAB>                                      PAD-0

        No Parameters

     The    <REAL-TAB>    command    is    identical    to    typing
<ENTER-CONTROL-CHARACTER>I.  It replaces the character at the cursor
with a tab character (or inserts it, if  the  editor  is  in  insert
mode).  <REAL-TAB> also can be used to put a tab in a parameter.

     See also the <TAB> command, which just moves the cursor  around
but does not change the file you are editing.





                              - 27 -



***************************************************************************
<SWITCH>                                        ^N

        Starting nominal: none
        Parameter: string (switch name or names)
        Cursor move: undefined
        Token: query of nominal parameter settings
        No Parameter: query of position and file status

     <SWITCH> is used to tailor the operation of SED to the user and
to  get  status  information.  The default setting of each switch is
denoted as on (+) or off (-) where it  is  meaningful.   To  turn  a
switch   off  type  "NONAME"  ("NOCASE",  "NOUPPER",  etc.)  as  the
parameter.  You only have to type enough of the switch name to  make
it unique (and "T" is good enough for TABS, "G" for GOTO).

     You can set more than one switch in one command  by  separating
them with slashes, for example <ENTER>TABS:6/CASE/BACK<SWITCH>.

     To give a slash as an argument to a  switch,  type  "^/".   Use
"^^" for up-arrow.

     All of the switches below are mentioned along with the commands
they  control,  or  in the appendices, except /HELP, /FENCE, /ITABS,
/MESSAG, /UPPER, and /ALT.  They are described only here.

-APPND  causes <PICK>s to append to the PICK buffer,  not  overwrite
        it,  until  /NOAPPND  or  another  /APPND is typed.  See the
        <PICK> command.

+BACKUP causes a backup file to be made  on  <SET-FILE>  or  <EXIT>.
        The file has the extension .BAK.  /NOBACKUP causes no backup
        file to be made.

-BEEP   causes the terminal to beep once when entering  INSERT  mode
        and  twice when entering REPLACE mode, instead of displaying
        a message on the screen.

+CASE   make searches case-dependent, ie, the key "THE" is different
        from  the  key "the".  /NOCASE causes the key "THE" to match
        the first occurrence of "THE", "the", "tHe", &c.

-CREATE if <SET-FILE> cannot find a  file,  always  create  it.   if
        /NOCREATE  is  set  the file will be created if the filespec
        ends with an "=", otherwise SED will give an error.

-DELIM:CHARACTER-LIST specifies a set of delimiters used by wordwise
        tabs.   Example:   With  /DELIM:.,- a wordwise tab will stop
        after a period, comma, or dash, as well as at the starts  of
        words.   /NODELIM  clears  the  list of characters.  See the
        section on <TAB> and <BACKTAB>.



                              - 28 -



-DTABS  causes tabs to identify themselves.  With /DTABS  set,  each
        tab displays as highlighted "."s.  The columns on the screen
        are still aligned properly.

-EXT:EXTENSION-LIST sets up the  list  of  default  extensions  (see
        <SET-FILE>).   Up  to  10 extensions can be given.  Example:
        /EXT:MAC,CTL,CMD.

+FENCE  causes the normal fence to be displayed after the end of the
        file.   /NOFENCE  causes  a  short,  discreet  fence  to  be
        displayed.

-FILL   causes <JUSTIFY> to align the text against the right margin.
        /NOFILL gives a ragged right margin.

-GREAD  causes all files to be set read-only until /NOGREAD is  set.
        Can be overridden for the current file by /WRITE or /NOREAD.

+HELP   enables on-line help when <ENTER><ENTER> is typed.

+ICR    causes a carriage return typed in INSERT mode  to  insert  a
        carriage  return.   /NOICR  causes the cursor to move to the
        start of the next line.

-ID     when the file is saved, /ID causes a new first  line  to  be
        added to the file.  The line contains the filespec, the date
        and time, and the name of the user who edited the file.  The
        line  starts  with  a  ";".  /ID:s1 will make the line start
        with "s1" (5 characters or fewer).  /ID:s1,s2 will also make
        the line end with "s2".  Use "^/" to get a "/".

+INVRT  tells the <CASE> command to  invert  case.   /NOINVRT  tells
        <CASE> to use the setting of the /RAISE switch.

-ISAVE:n causes an incremental save of the file  every  n  commands.
        Default is n=0 (ie, no incremental saves) (#).

+ITABS  if you type something beyond the end  of  a  line  SED  will
        insert  spaces  so the character is properly positioned.  If
        /ITABS is set SED will try to use as many tabs  as  possible
        instead of spaces.  /NOITABS causes SED to use only spaces.

-JOURN  starts  a  journal.   See  Appendix D  for  information   on
        journaling.

 JPRE:STRING causes <JUSTIFY> to delete STRING  from  the  start  of
        each  line,  if  it's present, and to begin each line of the
        justified text with STRING.

 LENG:n causes SED to think your terminal is n lines long.  Good for
        limiting  the  amount  of  information  written  on  a  slow
        terminal.  See Appendix C.


                              - 29 -



 LMAR:n sets the left margin to be column n.  The default is 1.  See
        Appendix C to find out about margins.

+MESSAG enables the cheery message on startup and the "this file is"
        message  in a new file.  /NOMESSAG causes those messages not
        to be given.

 OUT:FILESPEC changes the name of the file being  edited  (or  being
        set  to,  if  the switch is given in a <SET-FILE> or the run
        command) to be FILESPEC.

-PAGE   causes <SWITCH> to output your position as PAGE-LINE, rather
        than  LINES  from  start  of  file.   Pages are delimited by
        formfeeds (^L).

-PIND:n sets the paragraph indentation for the <JUSTIFY> command  to
        be n spaces.

 PROG:FILE sets up the name of the system program to be run when you
        type  <ENTER><EXIT>.   The  default  is  COMPIL.  The switch
        /PROG:RUNOFF will cause RUNOFF to be run instead.

+RAISE  used by the <CASE> command if /NOINVRT is set.  /RAISE tells
        <CASE> to change lower case to upper.  /NORAISE tells <CASE>
        to change upper case to lower.

-READ   makes the file read-only.  /READ is the opposite of /WRITE.

-RESET  causes the starting nominal parameters  to  be  reset  after
        each  command.  When set, <ENTER>5<INSERT-LINE><INSERT-LINE>
        will insert 6 lines.  Under  /NORESET  those  commands  will
        insert 10 lines.

 RMAR:n sets the right margin to be column n.  Default is the  width
        of the screen.  See Appendix C to find out about margins.

+ROLL   causes <CARRIAGE-RETURN> when the cursor is at the bottom of
        the  screen  to  roll  forward one line.  If /NOROLL is set,
        <RETURN> causes the cursor to wrap around to the top line of
        the screen (see also /SCROLL).

-SAVE:n causes an incremental save of the file every n characters of
        typein.  Default is n=0 (ie, no incremental saves) (#).

-SCROLL causes a  <CURSOR-UP>  at  the  top  of  the  screen,  or  a
        <CURSOR-DOWN>  at  the  bottom,  to  roll one line (see also
        /ROLL).  Note:  to get to the bottom line  when  /SCROLL  is
        set, type <HOME><CURSOR-LEFT>.

-SHOW   causes <EXECUTE> to  display  as  it  is  working.   /NOSHOW
        updates the screen only when the <EXECUTE> is done.



                              - 30 -



+SLIDE:n sets the nominal parameter for the <SLIDE> commands  to  n.
        /NOSLIDE disables the <SLIDE>s (no action is taken when they
        are typed).

-STRIP  causes SOS line numbers to be stripped from the file when it
        is read in.  /NOSTRIP just marks the file read-only.

+TABS   makes <TAB> and  <BACKTAB>  use  the  usual  tab  positions.
        /NOTABS  sets up wordwise TABS.  See the TAB/BACKTAB section
        (*).

-TRAIL  causes trailing spaces and tabs to be preserved in the  file
        when  it  is  saved.   /NOTRAIL causes trailing things to be
        stripped.  Warning:  SED adds trailing spaces sometimes,  so
        set /NOTRAIL only on special occasions.

 TSET:n sets a tab at column n.  /NOTSET:n clears that  tab.   Also,
        /TSET:n1,n2,n3  will set tabs at the given columns.  See the
        <TAB-SET> command.

-UPPER  causes all alphabetic characters to be  converted  to  upper
        case.   Useful  for  a  terminal whose shift lock shifts all
        characters.

 WIDTH:n causes SED to think the  terminal  is  n  characters  wide.
        Good  for  terminals which can change their widths, like the
        VT100.  See Appendix C.

+WRITE  allows the current file  to  be  altered.   /NOWRITE  causes
        commands  which  change the file become illegal, so the file
        cannot be modified accidentally.

(#) /ISAVE and /SAVE should be used together.  When  either  becomes
zero  the  file  is  saved  and  both  counters are reset.  See also
Appendix D.

(*) You can also type /TABS:n to set up tab stops every n positions.
Default  is  TABS:8.   Also,  /TABS:W  sets  wordwise  tabs (same as
/NOTABS) and /TABS:R sets regular tabs (same as /TABS).

    There are four other places you can use these switches:  as part
of the monitor-level RUN command, in the <SET-FILE> command, in your
SWITCH.INI or SED.INI file, and  in  an  execute  (.XCT  -  see  the
<EXECUTE> command) file.  You can do things like

        .R SED;FILE.EXT/NOCASE/TABS:5
or
        <ENTER>FILE.EXT/GOTO:50<SET-FILE>

and if your SWITCH.INI or SED.INI contains the line

        SED/NOCASE/UPPER


                              - 31 -



SED will set switches for searching independently of  case  and  for
upper case characters each time it is run.

    There are several switches  which  are  not  meaningful  in  the
<SWITCH> command but can be used with the other four methods:

 AGAIN  used in a <SET-FILE> command.  If you are editing  FILE.FOO,
        typing   <ENTER>/AG<SET-FILE>   acts  the  same  as  if  the
        parameter were "FILE.FOO".  Also, /AG:nn acts  the  same  as
        /AG/GO:nn  - the numeric argument is a percentage of the way
        into the file.  Do not use explicit filespecs with /AGAIN.

 ALT    used when running SED.   Swaps  the  current  and  alternate
        files  you  were  editing last time.  Also, /ALT:nn acts the
        same as /ALT/GO:nn.

 GOTO:PERC used when running SED or doing a  <SET-FILE>.   The  file
        will  be displayed starting PERC percent of the way through.
        If /GOTO, no argument, is used  SED  will  use  the  current
        percent value.

-IMODE  puts SED in insert mode.  /NOIMODE puts it in replace  mode.
        This switch can also be used in execute buffers ($IM^SW).

-QUICK  causes the file not to display after the  <SET-FILE>.   This
        is  useful on a slow terminal when you are not interested in
        what is on the first page of display.

 RCUR   used with <SET-FILE>;  causes the current filespecs,  rather
        than  the alternate specs, to be replaced by the given ones.
        Useful for "keeping your finger" in one file (the alternate)
        while looking at several others.

 RECOV  typing SED/REC at monitor level tells  SED  to  recover  the
        previous  session  using  the  journal.   See Appendix D for
        information on journaling.

 X:NAME:txt used in SWITCH.INI or  SED.INI  to  set  up  an  execute
        buffer  named  NAME  with  contents  txt.  See the <EXECUTE>
        command for details.


     The  <SWITCH>  command  has  two  other  functions:    to   get
information  about  the  file  you  are  editing and to find out the
current parameter settings.  You  get  the  former  by  typing  just
<SWITCH>,  the latter by typing <ENTER><SWITCH>.  The information is
written on the bottom line of the screen.  The bottom  line  can  be
cleaned up by typing <RESET>.

     The file information consists of the  current  file  name,  the
line  and position the cursor is on (that's the line and position in
the file, not the row and column on the screen), the percent through
the file, and the name of the alternate file (if any).  For example,

                              - 32 -



FILE: *SED.RNO[401,127]  LINE: 534(67%) POS: 1 ALT: FOO.BAR[10,15]

says that the current  file  is  SED.RNO  (the  "*"  indicates  that
SED.RNO  has been modified), the cursor is at the start of the 534th
line, which is 67% through the  file,  and  the  alternate  file  is
FOO.BAR  (The "LINE" field can be made a "PAGE-LINE" field.  See the
/PAGE switch).

     To find out how many lines lie between a  given  line  and  the
beginning  of  the file, position the cursor to the desired line and
type <SWITCH>.  This function may not occur immediately,  since  SED
has to go back to the beginning of the file and count every line.

     Typing <ENTER><SWITCH> will  give  you  the  current  parameter
settings.  The bottom line of the screen will look something like:

RL:8 RP:1 PC:2 SL:8 IL:1 IS:8 PK:3,8 CS:1 SU:5 TB:8; KEY:th SUB:FOO

     This message tells you that the following values are set:

        LINES TO ROLL:         8
        PAGES TO ROLL:         1
        PERCENT-GOTO:          2
        SLIDE:                 8
        INSERT/DELETE LINES:   1 LINE AND 0 SPACES
        INSERT/DELETE SPACES:  8
        PICK:                  3 LINES AND 8 SPACES
        CHANGE-CASE PARAMETER: 1
        NUMBER OF SUBSTITUTES: 5
        TAB SIZE:              8
        SEARCH KEY:            th
        SUBSTITUTE STRING:     FOO

     So if you type a <PERCENT-GOTO> command with no  parameter  you
will  go  to  the 2% point, a <DELETE-LINES> will delete 1 line (and
<INSERT-LINES> will insert 1 line), and a PICK will pick up 3 lines.

     Remember that you can use cursor movement to  tell  <PICK>  and
<INSERT/DELETE-LINES>  to  work  with  both  a number of lines and a
number of spaces;  thus their parameters are expressed as two values
above.

     Tab size is controlled by the /TABS switch.  If  wordwise  tabs
are  in  effect  the  tab size is "W".  Similarly, settable tabs are
indicated by "S".









                              - 33 -



***************************************************************************
<RECALL>                                        PAD-RED

        Starting nominal: none
        Parameter: type of thing to recall
        Cursor move: ignored
        Token: ignored

     Simulates an <ENTER> with the  latest  parameter  typed.   When
<RECALL>  is typed the latest parameter appears at the bottom of the
screen and the editor is placed in <ENTER> mode.  You can add to  or
delete  from the parameter and then pass that parameter to a command
by typing that command.

     The <RECALL> command is useful in three  instances:   when  you
have  typed  the wrong parameter to a command and want to correct it
with a minimum of typing, when you have given the right parameter to
the   wrong   command   (in   which   case   you   can   just   type
<RECALL><RIGHT-COMMAND>), and when you just want  to  see  what  the
latest parameter was.

     <RECALL> uses the first character of its  parameter  to  recall
some  specific  information.   Type <ENTER><char><RECALL> to get the
following:

     char    THING RECALLED
         F      Current Filespecs
         A      Alternate Filespecs
         S      Current Search Key
         O      Previous (Old) Search Key
         R      Substitute String

After you recall one of these things you can use it as if you  typed
it  in:   For  example,  <ENTER>F<RECALL><PUT>  will put the current
filespecs into the file.

***************************************************************************
<HELP>                                          PAD-3

        No explicit parameters
        Token: Recovers from a delete command

     Asks for on-line help.  When <HELP> is typed SED asks  for  the
command to give help for and waits for you to type any command.  SED
then tells you something about the command  and  asks  for  another.
Typing  "G" or "g" instead of a command will return you to the file.
Try it.

     <HELP><HELP> gives a layout of the commands on the terminal.

     Typing <ENTER><HELP> will put back  the  text  deleted  by  the
latest    <DELETE-CHARACTER>,   <ERASE-WORD>,   <DELETE-SPACES>   or
<ERASE-LINE> command.

                              - 34 -



***************************************************************************
<CASE>                                          PAD-9

        Starting nominal: 1 character
        Parameter: number of characters
        Cursor move: characters and/or lines
        Token: uses token

     The <CASE> command changes the case  of  the  letters  starting
where the cursor is.  Two switches control way <CASE> works:  /INVRT
and /RAISE.  If /INVRT is set (default) then the  case  of  all  the
letters is inverted:  upper is changed to lower and lower to upper.

     If /NOINVRT is set then the setting of /RAISE is  used.   Lower
case  letters  will be changed to upper case if the /RAISE switch is
set;  if /NORAISE, upper case letters will be changed to lower case.

     Cursor movement can be used to make  <CASE>  work  across  more
than one line.

EXAMPLE: The cursor is at the start of "BOX" and you type
         <ENTER><RIGHT><RIGHT><RIGHT><CASE>:

BEFORE: PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.

AFTER:  PACK MY box WITH FIVE DOZEN LIQUOR JUGS.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.

You then type <ENTER><RETURN><CASE>:

AFTER:  PACK MY box with five dozen liquor jugs.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.


***************************************************************************
<WINDOW>                                        PAD-1

        No Parameters

     The <WINDOW> command allows two files to appear on the terminal
screen  at the same time.  The files each occupy half of the screen,
one on top of the other.

     Type <WINDOW> to divide the screen.  The file you are currently
editing  will  be  displayed  in  the  top window.  If you then do a
<SET-FILE>, the new file will appear in the bottom window.   Another
<SET-FILE> will get you back to the top window, and so on.

     To get back to normal, non-windowing operations, type  <WINDOW>
again.  The split screen will go away and the file you are currently
editing will occupy the entire screen.


                              - 35 -



***************************************************************************
<JUSTIFY>                                       ESC-J

        Starting nominal: 1 line
        Parameter: number of lines, or "C" to center line
        Cursor move: lines (change in spaces is ignored)
        Token: justify to end of paragraph

     Justifies or centers text within the left  and  right  margins.
The  number of spaces to indent a new paragraph (positive, negative,
or zero) may also be given, as well as a string to be  removed  from
the  start  of  each raw line and added to each justified line.  The
text can be made flush against the right margin ("filled")  or  left
ragged.

     <JUSTIFY> works from the start of the line the cursor is on for
the  number  of lines given explicitly or using cursor movement.  If
<ENTER><JUSTIFY> is typed the command works from the line the cursor
is  on  to  the  end  of  the  paragraph  (The end of a paragraph is
signaled by a blank line or a line which begins with spaces or tabs.
The  line  the cursor is on is always the start of a paragraph;  the
last line of the range is always the end of a paragraph).

     A new paragraph in the justified text begins with a blank  line
and the indentation given by /PIND:.

Switches used by <JUSTIFY>:

    /JPRE:s     delete string s from each input line;
                begin each output line with string s.
    /LMAR:n     set the left margin to be column n.
    /RMAR:n     set the right margin to be column n.
    /PIND:n     set the paragraph indentation to be n columns.
    /FILL       make a straight right margin (/NOFILL == ragged).

     To center the line the cursor is  on,  type  <ENTER>C<JUSTIFY>.
The line will be centered between the left and right margins.

EXAMPLE:  The  cursor  is  somewhere  in  the  first line. You type
<ENTER>JPRE:;/RMAR:55/PIND:3<SWITCH> and then <ENTER>5<JUSTIFY>.

BEFORE:
;When in the course of human events it becomes necessary for one
;people to dissolve the political bands which have connected them.

Pack my box with five dozen liquor jugs.

AFTER:
;   When in the course of human events it becomes
;necessary for one people to dissolve the political
;bands which have connected them.

;   Pack my box with five dozen liquor jugs.

                              - 36 -




EXAMPLE:   The   cursor   is   somewhere  in  the  line.  You  type
<ENTER>/RMAR:68<SWITCH> and then <ENTER>c<JUSTIFY>.

BEFORE:
TABLE OF CONTENTS

AFTER:
                         TABLE OF CONTENTS

EXAMPLES:  The  cursor  is  somewhere  in  the first line. You type
<ENTER>RMAR:55/PIND:3<SWITCH> and then <ENTER><JUSTIFY>.

BEFORE:
When in the course of human events it becomes necessary for one
people to dissolve the political bands which have connected them.

Pack my box with five dozen liquor jugs.

AFTER:
   When in the course of human events it becomes
necessary for one people to dissolve the political
bands which have connected them.

Pack my box with five dozen liquor jugs.


Now you type <ENTER>FILL<SWITCH> and <ENTER><JUSTIFY>.

AFTER:
   When  in  the  course  of  human  events it becomes
necessary for one people  to  dissolve  the  political
bands which have connected them.

Pack my box with five dozen liquor jugs.


Now you type <ENTER>LM:10/RM:68/PI:-5<SWITCH> and <ENTER>5<JUSTIFY>.

AFTER:
    When in the course of human events it becomes necessary for one
         people   to   dissolve  the  political  bands  which  have
         connected them.

    Pack my box with five dozen liquor jugs.

Beware:  The lines above all begin with spaces, therefore if you try
to  justify  them  again  SED  will  treat  them  as  four  separate
paragraphs.  Delete the leading spaces from the lines which are  not
the beginning of a paragraph before justifying it a second time.




                              - 37 -



***************************************************************************
<EXECUTE>                                       ^X

        Starting nominal: 0
        Parameter: number (iterations)
        No Parameter: closes execute buffer, if open
                      does nominal iterations, if buffer closed
        Cursor move: spaces (change of lines is illegal)
        Token: opens execute buffer

     This command allows you to store a sequence of  commands  in  a
command  buffer,  and  later  execute that sequence as many times as
desired.  A command buffer can  be  made  to  look  like  an  editor
command  (where  pressing  a  button  on the terminal will cause the
buffer to execute once).  It is easy to do things like removing  the
first  16  spaces  from  every  line  of  the  file, or causing each
occurrence of JU&$ to be at the start of a new line.

     <EXECUTE> is a complicated command.  This section explains  the
basics  of  how  to use one <EXECUTE> buffer.  The next two sections
deal with advanced <EXECUTE> features.

     The procedure for using the <EXECUTE> command  is  as  follows:
first  open the execute buffer by typing <ENTER><EXECUTE>.  From now
until the buffer is closed everything that you type  will  have  its
effect  on the file and the screen, and also be saved in the execute
buffer.  Do one iteration of the sequence.  Close the execute buffer
by typing only <EXECUTE>.

     When you want to execute that command sequence, figure out  how
many times you want to do it (a large number, if you want as many as
possible;  it will stop on an error like "Search failure").  For  10
iterations type

        <ENTER>10<EXECUTE>

The command sequence in the execute buffer will be issued 10  times,
just  as  if  you  had  typed the commands yourself.  Except for one
thing:  the display screen will not  change  until  the  execute  is
done.   This  saves  time.  However, every 8 times the entire buffer
has been executed, the terminal will beep so  you  can  tell  it  is
still working.  So there should be 2 beeps from the command above.

     When the execute is done the screen  will  be  re-displayed  to
show what it looks like after the last iteration.

     An <EXECUTE> can  be  aborted  early  by  typing  RUBOUT.   The
command  will  stop immediately and return control to you.  The file
will have been changed by the commands which have been issued before
you aborted the <EXECUTE>.




                              - 38 -



     Some helpful suggestions:  set up your nominals before you open
the command buffer.  For example, you might type

        <ENTER><EXECUTE>
        <ENTER>XYZ<SEARCH-FORWARD>
        ABC
        <EXECUTE>

which will set up to change XYZ's to ABC's.  Instead type

        <ENTER>XYZ<SEARCH-FORWARD>
        <CURSOR-UP>
        <ENTER><EXECUTE>
        <SEARCH-FORWARD>
        ABC
        <EXECUTE>

This does the same thing, although it requires more typing.  But the
benefit  is  that  the work of setting up the search key is not done
every time the command is iterated.   The  time  savings  from  this
gambit  can  be  enormous  for  a  complicated  sequence or a lot of
iterations (and you'll be just twiddling your thumbs  and  listening
to  beeps while all this happens).  There is another advantage:  the
nominals can be  changed,  resulting  in  a  similar  but  different
command  sequence  at  minimum setup cost.  For example, suppose the
lower sequence above had been typed.  Now change all XYZ's to ABC's:

        <ENTER>0<PERCENT>
        <ENTER>10000<EXECUTE>

Fine.  But it so happens that all xyz's want to be changed to ABC's,
too.  Just type:

        <PERCENT>
        <ENTER>xyz<SEARCH-FORWARD>
        <CURSOR-UP>
        <EXECUTE>

     This will search for  all  occurrences  (or  the  first  10000,
whichever  comes  first) of xyz and change them to ABC.  It iterates
10000 times because that is the  nominal  set  up  by  the  previous
<EXECUTE>.   The  <CURSOR-UP> is so the first match will be found by
the first iteration;  if the cursor were pointing at it, it would be
skipped.

     Note:  if xyz were wanted to be  changed  to  abc  (instead  of
ABC),  you would need to reload the execute buffer, since the ABC is
not a command nominal.  For  the  record,  an  absolutely  arbitrary
"change  all  occurrences of ??  to ??" command can be set up by the
following:




                              - 39 -



        <ENTER><STRING><SEARCH-FORWARD>
        <ENTER><length of above string><DELETE-SPACES>
        <ENTER><STRING1><PUT>

        <ENTER><EXECUTE>
        <SEARCH-FORWARD>
        <DELETE-SPACES>
        <PUT>
        <EXECUTE>

     This sets up <EXECUTE> to change all occurrences of  STRING  to
STRING1 (except the first two, which you have done yourself by hand.
The first sets up the command parameters and the  second  saves  the
commands  in  the  execute  buffer).   To  change  all  STRING2's to
STRING3's, type

        <ENTER><STRING2><SEARCH-FORWARD>
        <ENTER><length of above string><DELETE-SPACES>
        <ENTER><STRING3><PUT>

and then execute;  the rest has already been set up.

     Another use of the <EXECUTE> command is to do something to  the
same part of every line in the file.  For example, suppose you had a
batch output file and you wanted to pretty it up by removing all the
time  tags  -  the  first  16 characters of every line.  Move to the
start of the first line of the file and type

        <ENTER>16<DELETE-SPACES>
        <ENTER>1<ROLL-FORWARD-LINES>

That sets up the nominal parameter values.   Now  load  the  execute
buffer:

        <ENTER><EXECUTE>
        <DELETE-SPACES>
        <CURSOR-DOWN>
        <ROLL-FORWARD-LINES>
        <EXECUTE>

Then execute the sequence  by  typing  <ENTER>10000<EXECUTE>.   Note
that  the  <ROLL>  is necessary because without it, when the execute
got to last line on the screen the <DOWN> would position the  cursor
back  at the first line on the screen.  Note also that the <DOWN> is
not really needed for this particular sequence since the <ROLL> will
kick  the  cursor down a line (since the cursor is at the top of the
screen).  But if you were working with lines in the  middle  of  the
screen,  or deleting characters from the middle of a line, you would
want the <CURSOR-DOWN>.

     Use the /SHOW switch to tell SED whether to  display  execution
as  it  happens  (/SHOW)  or  just to re-display the screen when the
entire execute is complete (/NOSHOW, the default).

                              - 40 -



                  MORE INFORMATION ABOUT <EXECUTE>

Sections:
        SETTING UP A BUFFER
        WRITING A BUFFER
        TWO WAYS OF READING THE CONTENTS OF A BUFFER
        FINDING OUT WHAT THE NAMES OF THE BUFFERS ARE
        KILLING A BUFFER
        SETTING UP EXECUTE BUFFERS IN SWITCH.INI OR SED.INI
        EXAMPLES OF EXECUTE SEQUENCES

     There are a number of  execute  buffers  (normally  32),  so  a
variety  of  different command sequences can be set up and iterated.
Each buffer can be given a name up to five characters  long.   Names
can be defined or deleted as desired.  Buffers can be written either
by opening them and allowing commands to be stored, as described  in
the  previous  section,  or  directly  using the WRITE-BUFFER format
described below.  One buffer has a default  name:   null  (it's  the
buffer that was described in the basic <EXECUTE> section above).

     There are also conditional execute commands (such as IF and  DO
WHILE),  and  a way to connect an execute buffer to a command key or
sequence, so that pressing the key  will  execute  the  buffer  once
(thus   creating  your  own  meta-command).   Also,  execute  buffer
definitions can be stored in a disk file and read  in  when  needed.
All these things will be taken up in the next section.

     The <EXECUTE> command can be in one of the following formats:

        <ENTER>S<name><EXECUTE>     set up buffer with given name
        <ENTER>K<name><EXECUTE>     kill buffer with given name
        <ENTER>N<EXECUTE>           get list of buffer names

        <ENTER>W<sequence><EXECUTE> write sequence into active buffer
        <ENTER>R<name><EXECUTE>     read name & contents of buffer
        <ENTER>R<EXECUTE>           read active buffer
        <ENTER>L<name><EXECUTE>     list contents of buffer
        <ENTER>L<EXECUTE>           list active buffer

        <ENTER><EXECUTE>            open active buffer
        <EXECUTE>                   close or execute active buffer
        <ENTER><number><EXECUTE>    execute active buffer n times

     Note that the WRITE format, and READ and LIST with no argument,
work  with  the active execute buffer, meaning the one that was most
recently set up (using the S format).  Originally the active  buffer
is the null buffer.

     All characters typed in these formats are meaningful.  So don't
put in any spaces unless you really want them.




                              - 41 -



***************************************************************************
SETTING UP A BUFFER

     The general procedure for working with an execute buffer is  to
set it up, write it, then execute it.

     To define and write a new buffer:  choose a  name,  say  "FOO",
and set up the buffer by typing

        <ENTER>SFOO<EXECUTE>

     Names can be up to five characters long and can consist of  any
printing characters.

     The S format is also used to set to a buffer which has  already
been  created.   A  buffer  must  be set before it is written (the W
format), read (R), listed (L), or executed.  The S format will  look
for  a  buffer of the given name and make it and its contents active
if it exists;  if no buffer by that name exists, it will create  one
(which is empty).  To set to the null buffer type <ENTER>S<EXECUTE>.

***************************************************************************
WRITING A BUFFER

     After creating the buffer named FOO you  can  write  a  command
sequence  into  it  in  the usual way, by typing <ENTER><EXECUTE> to
open the buffer, the desired sequence of commands, and <EXECUTE>  to
close  it.   Note  that setting up the buffer name with the S format
does NOT open the buffer.

     The execute buffer can also be written directly, without having
the  commands  take effect on the screen (using the W WRITE format).
The WRITE  format  works  with  the  active  buffer.   For  example,
following the above set command with

        <ENTER>W$THING^SF$5^DS$HACK^PT<EXECUTE>

will load the buffer names FOO with a  sequence  of  commands  which
searches  for  an  occurrence  of  "THING",  deletes it, and inserts
"HACK".  The buffer is loaded with the following command sequence:

        <ENTER>THING<SEARCH-FORWARD>
        <ENTER>5<DELETE-SPACES>
        <ENTER>HACK<PUT>

     Writing into the execute buffer requires a language to describe
the  editor  commands, since typing them directly will cause them to
take effect.  Appendix E is a list of the editor  commands  and  the
sequences that <EXECUTE> uses to describe them.  In general they are
"^" followed by two or three letters  which  describe  the  command.
<ENTER-PARAMETER> is a dollar sign.



                              - 42 -



     For another example, to load the active buffer with a  sequence
to  put  an  "X"  at  the  cursor  position,  move  to  the position
underneath, and roll the screen one line, type

        <ENTER>WX^CL^CD$1^RFL<EXECUTE>

This sets up the buffer with the following command sequences:

        X
        <CURSOR-LEFT>
        <CURSOR-DOWN>
        <ENTER>1<ROLL-FORWARD-LINES>

     Of course, the execute will run faster if  the  parameters  are
set up in advance, not in the sequence itself.

     The execute buffer does not have to be opened in order to write
it  using  the  W  format,  nor does it have to be closed afterward.
Those two formats apply only when you want to save commands as  they
are issued, as described in the previous section.

     After the buffer has been written it can  be  executed  in  the
normal fashion, by typing <ENTER><number><EXECUTE>.

     If you want to do the same series of commands several times  in
a  row,  you  can  give a repeat count.  For example, ^4(^CR) is the
same as ^CR^CR^CR^CR.  Any series of commands can be repeated up  to
4000 times.

     To put a real up-arrow in a buffer type "^^"  (two  up-arrows).
To  put  in  a  real dollar sign type "^$".  Within a repeat, a real
close parenthesis must  be  given  as  "^)".   When  using  the  /X:
switch,  use  "^/"  to mean a real slash (to distinguish it from the
start of the next switch).

     You can use cursor movement to read a  buffer  definition  from
the  file  you  are  editing,  so a useful way of experimenting with
execute buffers is to  put  the  buffer  definition  in  your  file,
preceded by the "W" for the WRITE format.  Position to the "W", move
the cursor to the end of the  line,  and  type  <EXECUTE>.   If  the
command  sequence  is not quite right, change it in the file and use
cursor movement to pick it up again.

***************************************************************************
TWO WAYS OF READING THE CONTENTS OF A BUFFER

     There are two ways you can see what is in  an  execute  buffer:
LISTing   and  READing.   LIST  presents  the  buffer  in  a  manner
compatible with the WRITE format;  READ presents it in a style  that
can be <PUT> into execute files or SWITCH.INI or SED.INI.




                              - 43 -



     To see what is in a buffer, type <ENTER>L<name><EXECUTE>.   The
active  buffer  can  be  read by typing <ENTER>L<EXECUTE>.  The null
buffer must be made active before it is read (using the  S  format).
Typing <ENTER>L<EXECUTE> will cause a line like

        W$THING^SF$5^DS$HACK^PT

to be put into the parameter buffer and  displayed  on  the  screen.
This  line can be treated just like a parameter that you have typed:
you can edit it and type <EXECUTE> again to load the edited  version
into  the  buffer, or use <PUT> to insert it into the file (where it
can be copied or modified at will,  and  later  reloaded  by  typing
<ENTER><END-LINE>(EXECUTE>.

     Similarly,   you   can   type    <ENTER>R<name><EXECUTE>    (or
<ENTER>R<EXECUTE> to read the active buffer).  This format gives you
a little more data:  READing the FOO buffer will cause the line

        /X:FOO:$THING^SF$5^DS$HACK^PT

to be put into the parameter buffer and  displayed  on  the  screen.
Again, you can treat this line like a parameter that you have typed,
for example to store the command string in SWITCH.INI or SED.INI  or
some  other  file by doing a READ and a <PUT>.  For more about these
switch files, see the section on reading execute files from disk.

Note:  The output of the L or R formats may be too long  to  fit  in
the  parameter buffer.  In that case the output will be truncated to
fit in the parameter buffer and SED will beep to tell you it's taken
liberties with your buffer.

***************************************************************************
FINDING OUT WHAT THE NAMES OF THE BUFFERS ARE

     Typing <ENTER>N<EXECUTE> will  fill  the  bottom  line  of  the
screen with the names of the buffers.

***************************************************************************
KILLING A BUFFER

     If all the execute buffers are  set  up  and  you  try  to  SET
another one, SED will inform you that all the buffers are in use and
suggest you kill one of them.  You do that using the K  format:   to
kill the buffer FOO type

        <ENTER>KFOO<EXECUTE>

That name will go away and the buffer will be cleared, and  it  will
be available to be set to something new.

     The null buffer can be killed by typing <ENTER>K<EXECUTE>.



                              - 44 -



***************************************************************************
SETTING UP EXECUTE BUFFERS IN SWITCH.INI OR SED.INI

     Frequently-used command sequences can be put in  SWITCH.INI  or
SED.INI  so  they  will be set up automatically when SED is run.  An
example of an execute switch is:

        /X:NAME:$gig^PT^RT

which sets up execute buffer "NAME" with the command sequence to  do
a <PUT> and a carriage return.

     You can copy an execute buffer into SWITCH.INI or  SED.INI  (or
any file) by typing <ENTER>R<name><EXECUTE> and then <PUT>.

***************************************************************************
EXAMPLES OF EXECUTE SEQUENCES

        ^8($5^DS^CD)^RFL

(where the <ROLL-LINES> parameter is set  to  8).   This  deletes  5
characters  from  the same column of each of 8 lines, then rolls the
screen 8 lines.

        $^ECJ^EC?^EC?^EC?^ECM^SF^DL

This will delete all lines which are exactly three characters  long.
It  looks  for  lines  which have exactly three characters between a
linefeed (the end of the previous line) and a carriage return.

        ^SF^LN^PK^RT^FL^PT^RT^FL

(where some search key has been set up, the <PICK> parameter  is  1,
and the alternate file is the end of the current file).  This copies
all lines which contain a match of the search key to the end of  the
file.   It  searches  for  a  match,  gets to the start of the line,
<PICK>s the line, sets to the alternate file (which is  the  end  of
the current file), <PUT>s the line, and <SET-FILE>s back.  Note that
there will never be a search failure.  The alternate file could be a
separate  file,  but  then  the  two  files will have to be read and
written on disk for each <SET-FILE>, which will  slow  the  sequence
down  considerably.   The  set  of  matching  lines  can  easily  be
transferred from the end of the file to  any  other  file  when  the
execute has completed.










                              - 45 -



                  ADVANCED EXECUTE BUFFER FEATURES

Sections:
        WRITING AND EXECUTING IN ONE COMMAND
        SETTING INITIAL PARAMETERS FOR AN EXECUTE
        CONNECTING EXECUTE BUFFERS TO TERMINAL KEYS
        READING EXECUTE BUFFERS FROM DISK
        CONDITIONAL EXECUTE CONSTRUCTS
        THE EXECUTE COUNTER

     The story of <EXECUTE> is not over yet.


                WRITING AND EXECUTING IN ONE COMMAND

     You can write a sequence of commands into the active buffer and
immediately  execute the buffer a given number of times by using the
X format:

        <ENTER>Xn:<sequence><EXECUTE> write buffer & execute n times

The X format is useful for doing a one-shot series of commands.

***************************************************************************
              SETTING INITIAL PARAMETERS FOR AN EXECUTE

     The START-UP construct allows  you  to  define  parameters  and
switches at the beginning of an execute.  The format of START-UP is:

START-UP  . . . . . . . . . . . ^ST( ... )

     The contents of the START-UP block is executed  only  once,  at
the  start  of  the  execute.   The  parameters  of  commands in the
START-UP block are set  up  but  the  commands  themselves  are  not
executed.   Thus  the  START-UP  block is used to initialize command
parameters.  Switches can  also  be  set  in  the  block  using  the
<SWITCH> command.

     For  example  the  construct  ^ST($1^IS$gig^SF)  will  set  the
<INSERT-SPACES>  parameter  and the search key, but will not perform
either command.

     Initializing can speed up an execute buffer a lot.  For example

        ^ST($THING^SF$2^DS)^SFGIG^DS

acts the same as

        $THING^SFGIG$2^DS

but is much more efficient since the parameters are set up  once  in
the  first case and once per iteration in the second.  Parsing those
parameters takes time.

                              - 46 -



     The START-UP block can also be used to set switches which  will
be in effect during the execute:

        ^ST($NC/T:8/NIM^SW)     or
        ^ST($NC+T:8+NIM^SW)

initializes for case-independent searches, tab length of 8,  and  no
INSERT  mode during the execute.  The second form above must be used
in SWITCH.INI or SED.INI or an indirect (.XCT) execute file, since a
"/" marks the start of a new buffer definition or switch.

***************************************************************************
             CONNECTING EXECUTE BUFFERS TO TERMINAL KEYS

     You can set up any command sequence to call one iteration of an
execute  buffer.  A command sequence is a string of characters which
begins with a control character.  The action of the commands in  the
buffer  will  be displayed on the screen as it happens.  You can use
this capability, in effect, to define new commands to SED.

     There is one more EXECUTE format:

        <ENTER>B<EXECUTE>          connect active buffer to button

After you type this format  SED  will  ask  you  to  press  any  key
followed  by  the  letter  "G" (or "g").  SED will take the sequence
output by that key as the invocation of the currently active buffer.
Making  some other buffer active has no effect on this relationship.
Changing the contents of the buffer also has no effect, but remember
that  if  you  change  the buffer something new will happen when you
press the key.

     After you have typed <ENTER>B<EXECUTE> you can type any command
sequence  you  want.   The  sequence  can  be a control character, a
special key, or any string of characters which begins with a control
character.  If you type

        <ENTER>B<EXECUTE>
        <ESCAPE>XG

then the buffer would be executed  once  when  you  typed  <ESCAPE>X
(there  is  a  way  to make <ENTER>n<ESCAPE>X cause the buffer to be
executed n times;   see  the  section  about  the  execute  counter,
below).

     The sequence of  characters  can  even  be  one  which  already
invokes an editor command, so you can replace commands you don't use
with new ones of your own design.

     You can undefine a key by making its buffer active  and  typing
<ENTER>B<EXECUTE>G (ie, re-defining its key to nothing).



                              - 47 -



     The key definition can be set up with the buffer in  SWITCH.INI
or SED.INI.  The expanded format of the SWITCH.INI line is:

        /X:NAME,^[X:$gig^PT^RT

which sets up a buffer named NAME with <ENTER>gig<PUT><RETURN>,  and
assigns  it  to  the  sequence  <ESCAPE>X.   ("^["  ==  CONTROL-[ ==
<ESCAPE>.  All the stuff between the comma and the colon is taken as
the key definition.  The key definition can be omitted.

     Note:  RUBOUT (or DELETE) can be part of the command  sequence.
If you read the execute buffer the RUBOUT will appear as "^?".

***************************************************************************
                  READING EXECUTE BUFFERS FROM DISK

     There is yet another <EXECUTE> format:

        <ENTER>@FILE.EXT<EXECUTE>  read from the given file

This causes the buffer definitions and switches in  FILE.EXT  to  be
set  up.   The  previous definitions are erased.  Thus the disk file
can contain the definition of an entire special user environment.

     The disk file looks like a list of  switches.   SED  will  skip
characters  until  it finds a "/", so the first several lines can be
used for comments.  But be sure there's not a "/" in the comments.

     The default extension of this file is "XCT".

     You can set up and write execute buffers, and  then  when  they
are  working  properly you can put them in this file by Setting each
one up, doing a READ, and then a <PUT>.

     Here is an example of an execute file.  It sets up four special
keys  on  the  VT52  terminal  to  do  useful things for an assembly
language programmer:

        MACRO PROGRAMMER'S EXECUTES:
        BUTTON 4: TAB TO 4TH STOP AND ";"
        BUTTON 5: <CR> AND TAB
        BUTTON 6: ":" AND TAB
        BUTTON 8: PUSHJ<TAB>P,
        BUTTON 9: POPJ<TAB>P,

        /X:B4CM,^[?t:^3(^FCL32(^TA));
        /X:B5RT,^[?u:^RT^TA
        /X:B6RC,^[?v::^TA
        /X:B8PU,^[?x:PUSHJ^TAP,
        /X:B9PO,^[?y:POPJ^TAP,




                              - 48 -



***************************************************************************
                   CONDITIONAL EXECUTE CONSTRUCTS

     In addition to the editor commands,  the  following  constructs
are defined:

ITERATED-DO . . . . . . . . . . ^n ( ... )
DO-WHILE  . . . . . . . . . . . ^DW condition ( ... )
DO-ON-SEARCH-FAILURE  . . . . . ^DF ( ... )

IF-CHARACTER  . . . . . . . . . ^IF condition ( ... )
IF-ROW  . . . . . . . . . . . . ^FR comparison ( ... )
IF-COLUMN . . . . . . . . . . . ^FC comparison ( ... )
IF-COUNTER  . . . . . . . . . . ^F. comparison ( ... )

EXIT-BLOCK  . . . . . . . . . . ^XB
CONTINUE-BLOCK. . . . . . . . . ^CB
EXIT-BUFFER . . . . . . . . . . ^XX

     The ITERATED-DO construct has already been described:   it  was
called  a "repeat block" in a previous section.  It causes the stuff
following in ()'s to be repeated the given number of  times  (up  to
4000).

     DO-WHILE and IF-CHARACTER perform or skip  the  stuff  in  ()'s
depending  on  the  nature  of the character at the cursor position.
DO-ON-SEARCH-FAILURE  performs  the  stuff  in  ()'s  only  if   the
preceding search fails.

     IF-ROW  and  IF-COLUMN  perform  or  skip  the  stuff  in  ()'s
depending on the row or column position of the cursor on the screen.
IF-COUNTER does likewise depending  on  the  value  of  the  Execute
counter (use of the counter is described below).

     EXIT-BLOCK  causes  control  to  leave  the   interior   of   a
conditional.   CONTINUE-BLOCK  causes the rest of the conditional to
be skipped.  These two behave the same inside an IF block;  in a  DO
block  EXIT stops iterating and CONTINUE ends the current iteration.
EXIT-BUFFER ends the current iteration of the execute buffer.

     Now  for  details.   The  DO-ON-SEARCH-FAILURE  construct  must
immediately  follow an <SEARCH-FORWARD> or <SEARCH-BACKWARD> (^SF or
^SB).  The commands in ()'s will be skipped over unless  the  search
fails.   On  search  failure  SED will execute the commands in ()'s,
then continue execution with the next command after the  ^DF  block.
Use  the ^XX, ^CB, or ^XB constructs in the ^DF block to control how
execution proceeds (SED  can  be  told  to  continue,  to  stop  the
execute,  or  to  stop the current iteration, depending on how those
constructs are used).

     If a ^SF or ^SB is not followed by a ^DF and the search  fails,
an   "search-failure"  error  will  result  and  execution  will  be
terminated.

                              - 49 -



EXAMPLES:
        ^20(^SF^DF(^GO^PT^XX)^LB^PK^RT)END

<PICK>s up to 20 lines which contain the search key.  If fewer  than
20 matches are found, SED moves to the beginning of the file, does a
<PUT>, and terminates the execute.  If  20  matches  are  found  SED
types "END" wherever the cursor is.

        ^20(^SF^DF(^GO^PT^XB)^LB^PK^RT)END

The ^XX is changed to an ^XB.  The action  is  the  same  as  above,
except  when  the  search fails, after the <PUT>, SED terminates the
iterate block (the ^20).  "END" is typed out and execution ends.

        ^20(^SF^DF(^GO^PT^CB)^LB^PK^RT)END

Now it's ^CB.  When the search fails, after the <PUT>, SED skips the
rest  of  the  current  iteration  and starts the next one.  It does
another search, which fails;  these searches continue until  all  20
iterations  are  done.   This is probably not what the writer of the
buffer had in mind.  But it illustrates the difference  between  ^XB
and ^CB.

     DO-WHILE and IF-CHARACTER can check to see if the character  at
the cursor is

            Some given character
        ^L  ALPHABETIC (A-Z, a-z)
        ^U  UPPER CASE (A-Z)
        ^N  NUMERIC (0-9)
        ^A  ALPHA-NUMERIC
        ^C  ANY CHARACTER
        ^S  SPACE OR TAB
        ^E  END OF LINE OR BEYOND

or .NOT.  any of those things (by preceding  them  by  "^X").   "Any
character" is anything but space or TAB (same as "^X^S").

     You can say "if character is a space,  move  cursor  right"  by
"^IF^S(^CR)".   "Do  while  character  is not the letter 'A', cursor
right" is "^DW^XA(^CR)".

     IF-ROW, IF-COLUMN and IF-COUNTER check if the  current  row  or
column or the Execute counter is:

        En  EQUAL TO n
        Gn  GREATER THAN n
        Ln  LESS THAN n
        Nn  NOT EQUAL TO n

For example, you can say "If column is less than 64,  cursor  right"
by  "^FCL64(^CR)",  and  "If  it's  not  row  12,  cursor  down"  by
"^FRN12(^CD)".

                              - 50 -



     These constructs can be nested to a  depth  of  about  10,  and
intermingled as much as desired.

Examples:

    ^DW (^CR)       while character at cursor is " ", cursor right
    ^DW^X5(^CR)     while character is not a "5" move right
                    a.k.a. DO-UNTIL character is "5" ...
    ^DW^X^N(^CR)    until character is numeric move right
    ^FCE64(^RT)     if at column 64 do a RETURN
    ^FRG10(^CH)     if beyond row 10 go HOME
    ^IF^E(^RT)      if at or beyond end of line do a RETURN
    ^IF^X^E(^CR)    if not end of line move right
    ^1000(^PT)      PUT 1000 times

     EXIT- and CONTINUE-BLOCK are usually used inside a conditional,
along with an IF statement.  For example

        ^DW^X^E(^CR^FCG40(^XB))

will stop DOing when the end of the line  is  reached  or  when  the
column is greater than 40.

        ^1(^IF^S(^DS^PT^XB)^TB)

is an IF-THEN-ELSE statement.  If the character is a  space  or  TAB
SED deletes it, does a <PUT>, and skips the rest of the conditional;
else it TABs over.


























                              - 51 -



***************************************************************************
                         THE EXECUTE COUNTER

     You can keep a count of something  and  use  that  count  as  a
command  parameter or the number of iterations of a DO.  The counter
constructs are:

CLEAR-COUNTER . . . . . . . . . ^C=
INCREMENT-COUNTER . . . . . . . ^C+
DECREMENT-COUNTER . . . . . . . ^C-
USE-COUNTER . . . . . . . . . . ^CT
ITERATE-COUNTER . . . . . . . . ^C.( ... )
IF-COUNTER  . . . . . . . . . . ^F.( ... )
SET-COUNTER . . . . . . . . . . ^SC

     The  counter  can  be  cleared,  incremented,  and  decremented
anywhere in the execute buffer.

     You can use  the  counter  as  a  parameter:   if  the  counter
contains  12,  then  "$^CT^DS"  will delete 12 spaces.  Or "$^CT^PT"
will <PUT> the characters "12" into  the  file.   You  can  use  the
counter  with  characters  in  the  parameter;   "$123^CT45^PT"  and
"$AB^CTCD^CTEF^PT" are both legal.

     To  loop  <counter>  times  on  a   set   of   commands,   type
"^C.( ... )".   For  example  if  the counter contains 5, "^C.(^PT)"
will do 5 <PUT>s.

     The value of the counter can be used for conditional branching:
"^F.E10(^PT)" will do a <PUT> only if the counter contains 10.

     SET-COUNTER (^SC) is used to set  the  counter  to  a  specific
value.  "$12SC" sets the counter to 12.

     SET-COUNTER can also be used to set the execute counter to  the
(numeric)  parameter  the  user  typed.   It is intended for execute
buffers which are assigned to keys on the terminal.  If ^SC  appears
at  the  beginning  of the buffer and the user types <ENTER>17<KEY>,
then 17 will be stored in the counter.  If the user does not type  a
parameter,  the same value as last time will be used (the default is
1).  Non-numeric parameters cause an error.
For example the buffer

        ^SC^C-^ND$^ECL^C.(^SF)^RT

sets up a command to put the user at the start of some page  of  the
file  (where  pages are marked by formfeeds - CONTROL-L's).  Suppose
the user  types  <ENTER>4<KEY>.   The  counter  is  set  to  3,  and
CONTROL-L  is  searched  for 3 times [the construct $^ECL^C.(^SF) is
used rather than ^C.($^ECL^SF) because it is faster - the  parameter
is only processed once).  After the last search a carriage return is
done.  NO-DISPLAY (^ND - see next section) is set, so the action  is
displayed  only after the buffer is done executing.  Without ^ND all

                              - 52 -



the search targets would appear on the screen one by one.



***************************************************************************
    DEFERRING THE DISPLAY OF A BUFFER ATTACHED TO A TERMINAL KEY

NO-DISPLAY  . . . . . . . . . . ^ND

     Normally, the action  taken  by  an  execute  buffer  which  is
connected  to a terminal key is displayed step by step as the buffer
is processed.  If the NO-DISPLAY construct appears in a buffer,  the
screen will not be updated until the buffer has completed.  Then the
entire screen will be re-written.  This feature  is  useful  if  the
buffer  will  display  a  lot of parts of the file but you only care
about where it ends up.

     A buffer with ^ND in it acts the same as a  buffer  invoked  by
<ENTER>n<EXECUTE> with /NOSHOW set.



***************************************************************************
                     OUTPUTTING IMAGE CHARACTERS

OUTPUT  . . . . . . . . . . . . ^OU( ... )

     The OUTPUT construct is used  to  output  an  image  string  of
characters.   SED  will  send  to the terminal the ASCII argument to
^OU.  This construct can be used to cause things to  happen  to  the
terminal  that SED does not know about (for example, changing colors
on a graphics terminal).

     NOTE:  The text is output to the terminal screen.   It  is  not
put in the file.

     Control characters are  denoted  by  "^K".   <ESCAPE>  is  "$".
"^$", "^^", and "^)" denote "$", "^", and ")".

EXAMPLE:  ^OU($H$J(Running^)) outputs "<ESCAPE>H<ESCAPE>J(Running)".














                              - 53 -



As an overall example, here is an  execute  buffer  which  lines  up
every comment line at the 4th tab position, or if the comment starts
after the 4th tab, it puts one space between the instruction and the
comment.  Also, comments which start before column 16 are assumed to
be subroutine headers, and are left alone.

     Note that if the search key were "'" the buffer would work with
BASIC programs;  if it were "!" it would work with FORTRAN, etc.

     One comment is handled by every iteration of this buffer.

        ^ST($;^SF$1^IS$IM^SW)
        ^SF
        ^FCG16(
                ^CL^C=
                ^DW^S(^CL^C+)
                ^CR
                $^CT^DS
                ^4(^FCL32(^TA))
                ^CL
                ^IF^X^S(^CR )
                )
        ^RT

The buffer first sets the search key to be ";",  the  parameter  for
<DELETE-SPACES> to be 1, and INSERT MODE to be in effect.

     SED finds a match.  If the match is not beyond the 16th column,
SED  does  a  carriage  return (one comment per line!) and stops the
iteration.  Else SED moves to the left of the  comment  symbol.   It
counts  up  all  spaces to the left of the comment, and then deletes
them.  Then SED puts in tabs until the comment starts at column 32.

     Then SED looks at the character to  the  left  of  the  comment
symbol.   If  it  is  not  a  space or tab (meaning that the comment
started beyond column 32, thus no tabs were  inserted  in  the  loop
above)  SED separates the comment from the instruction with a space.
SED then does a <RETURN> to end the iteration.

     Other sample execute buffers can be found in SED.XCT and  other
.XCT files.

     Incidentally, the  multi-line  format  above  can  be  used  in
SWITCH.INI  or  SED.INI  or  .XCT files.  The indentation characters
must be TABs.  When SED is reading a buffer definition  all  control
characters are ignored, so CARRIAGE RETURNs, LINEFEEDs, and TABs can
be put in wherever you want.







                              - 54 -



                             APPENDICES

               Appendix A. DEFAULT FILESPECS AND SFDS

     When SFD's are in  effect  SED's  default  filespecs  behave  a
little differently than when they are not.  Without SFD's, if you do
not give a PPN the default is the number you logged in under.   Thus
if you are [100,150],

        <ENTER>FILE.EXT[200,25]<SET-FILE>
        <ENTER>NEWFIL.MAC<SET-FILE>

will find NEWFIL.MAC on [100,150].

     However, with SFD's in effect the default is the path which SED
is   following  at  the  moment.   The  above  commands  would  find
NEWFIL.MAC on [200,25].  Here's how the defaults work when you  have
SFD's:

<ENTER>FILE.EXT[200,25]<SET-FILE>       gets things started
<ENTER>FOO.MAC[,,THING]<SET-FILE>       looks on [200,25,THING]
<ENTER>FOO.FOR<SET-FILE>                on [200,25,THING]
<ENTER>FOO.BAR[,]<SET-FILE>             on [200,25]
<ENTER>NEWFIL.MAC[100,150]<SET-FILE>    only way to get [100,150]






























                              - 55 -



             Appendix B. LOOKING THROUGH A LIST OF FILES

     You can create a file containing a list of files and then  look
at  them  one  by one, moving one file forward or backward along the
list.  The easiest way to create this list of  files  is  using  the
DIRECT program (or command).  For example, type

        .DIR/F LIST=*.MAC

This creates LIST.DIR with a list of the MACRO files in  your  area.
Any method which sets up a list of files, one to a line, will do.

     If you then run SED and say <ENTER>@LIST.DIR<SET-FILE> (or  run
with  ".R SED;@LIST.DIR")  (the default extension is "DIR") you will
be looking at the first file on the list.  Then  a  lone  <SET-FILE>
command  will  get  the next file on the list, and <ENTER><SET-FILE>
will get the previous one.  When you reach the beginning or  end  of
the list SED will toggle between the last two files it found.

     You can return to normal by typing <ENTER>filespecs<SET-FILE>.

NOTE:  The indirect file must  reside  in  the  top  level  of  your
logged-in  directory.   If  the  indirect  file  is  somewhere else,
include the device and/or directory in the filespec.

     The indirect file (such as LIST.DIR above) can contain comments
(which start with "!" or ";").  Spaces and tabs are ignored, so they
can be put in anywhere.  Entirely blank lines can appear before  the
first filespec, but not between specs (use a lone comment symbol).

     Here is an example of an indirect <SET-FILE> file:

        ;LIST OF EXPERIMENTAL FILES

        EXP1.MAC        !FILE TO CHANGE ALL THE WORLD
        EXP2.MAC        ;FILE TO CHANGE ALL THE REST
        EXP3A.MAC
        !
        ;THE FOLLOWING ARE NOT VERY USEFUL:
        EXP8.MAC
        EXP15.MAC













                              - 56 -



             Appendix C. USING MARGINS AND SCREEN LIMITS

     This appendix discusses the action of four switches:  /LENGTH:,
/WIDTH:, /LMAR:, and /RMAR:.

     /LENGTH:  and /WIDTH:  set up the dimensions  of  the  terminal
display.   You  can  use  them  to  limit the amount of output.  For
example, for a lot of searching on a slow terminal,  set  /LENGTH:10
and  only  a  few  lines  around the search match will be displayed.
Also, SED can be adjusted for terminals which  change  widths,  like
the VT100, using the /WIDTH:  switch.

     /LMAR:  and /RMAR:  control how typed-in characters are entered
on  the  screen  and  in the file.  If you set, say, /LMAR:8, then a
<CARRIAGE-RETURN> or <BEGIN-LINE> command will move the  cursor,  on
the  screen  and in the file, to the eighth column.  The line in the
file will begin with eight spaces.  /LMAR:  is initially 1.

     You can move into that indented region using  <CURSOR-LEFT>  or
<DELETE-CHARACTER>.

     /RMAR:  sets up the right margin.  If you are  typing  in  text
and  exceed  the  right  margin then the word you are typing will be
moved to the next line.  SED will put in the  carriage  returns  for
you.  /RMAR:  starts as the width of the entire screen.

     /RMAR:  can be disabled by setting it larger  than  the  screen
width (like /RMAR:1000).


























                              - 57 -



          Appendix D. INCREMENTAL FILE SAVES AND JOURNALING

     There are a number of ways to recover editing sessions in  SED.
You  can  save the file you are editing automatically by setting the
/ISAVE:  and /SAVE:   switches.   Say  you  set  /ISAVE:30/SAVE:150.
Then after 30 commands or 150 characters of type-in, whichever comes
first, the file will be saved.  Then both counters are reset.

     /ISAVE:  and  /SAVE:   both  start  off  at  zero,  meaning  no
incremental  saves  (which is what these saves are called).  You can
tune SED's saving characteristics to your editing style.

     Of course, you can also save the file by simply exiting SED and
rerunning  it,  since  SED  will  put you back where you were in the
file.  This scheme is good if you want  to  save  only  at  specific
times (and can remember that it needs to be done).  There's also the
<SAVE-FILE> command, which saves the file without exiting SED.

     One thing to beware:  incremental  saves  and  the  <SAVE-FILE>
command  do  not  clean  up  the  file.  SED puts a lot of nulls and
trailing spaces into the file;  they are eliminated when the file is
saved  by  an <EXIT> or <SET-FILE> command.  But the other saves are
designed to take as little time as possible, so the nulls and spaces
are  left  in.  However, some programs will break if there are nulls
in the file.  So end your editing sessions  by  typing  <EXIT>,  not
<SAVE-FILE><ABORT>.

     Incremental saves can take a long time  for  large  files.   So
there  is  another  recovery mechanism:  journaling.  The journal is
the file SEDJRN.TMP, which holds the stream of  commands  which  you
typed  during your editing session.  If the computer crashes you can
recover your session by telling SED to read its  commands  from  the
journal  and  apply  them  to  the  unchanged  file (it is unchanged
because the system crashed before you exited).  A  few  commands  at
the  end  of the session will be lost, but you will get most of your
work back.

     ALERT:  Command  parameters  settings  are  not  saved  in  the
     journal.   Suppose  you  edit a file, do a search (say), set to
     another file, and type <SEARCH-FORWARD>.  When you set  to  the
     other  file  a new journal was started, and it does not contain
     the search key.  If you try to recover using that  journal  SED
     will  give  a  "No  search key" error.  The same applies to any
     parameters which were  changed  before  the  current  file  was
     edited.   This  problem  does not occur very often, but it is a
     known deficiency of journaling.

          However, the journal is an ASCII file and can  be  edited,
     so  if you can remember what the missing parameters are you can
     insert them in the journal and make it work.




                              - 58 -



     Start journaling by typing the /JOURN switch (in  the  <SWITCH>
command,  in  the  monitor-level  RUN  command,  or  as  part  of  a
<SET-FILE>.  The journal will be started immediately, and  SED  will
remember  what  file  you  are editing and where you are in it.  The
journal is restarted every time the file is saved (on  a  <SET-FILE>
or incremental save).

     You don't have to worry about the journal unless  the  computer
crashes.   When the system comes up, type ".R SED;/RECOV" at monitor
level.  SED will take its commands  from  the  journal,  update  the
file, and tell you when it's done.

     If you want  to  see  your  own  commands  being  performed  at
super-speed,   type   ".R SED;/RECOV/SHOW"  Watching  your  two-hour
session whiz by in a couple of minutes is very humbling, and has the
same  entertainment  value as watching two shirts fight in a clothes
dryer.

     To abort a journal recovery, type  RUBOUT  anytime  during  the
recovery.

     If   you   recover   by    typing    ".R SED;/REC/JOURN"    (or
".R SED;/REC/SHOW/JOURN") then the journal will be appended to after
the recovery is  finished.   This  also  happens  if  /JOURN  is  in
SWITCH.INI   or  SED.INI.   Note:   if,  after  recovery,  you  type
<ENTER>JOURN<SWITCH> then the journal  file  will  be  STARTED,  not
appended to.  When in doubt save the file (by exiting, for example),
and start with a fresh journal.

     If you put the /JOURN switch in your SWITCH.INI or SED.INI file
then journaling will be done automatically.  You can turn it off for
an editing session by typing <ENTER>NOJOURN<SWITCH>  (as  you  might
expect).





















                              - 59 -



             Appendix F. TABLE OF EXECUTE COMMAND NAMES

        COMMAND             NAME    OTHER COMMANDS          NAME
        -------             ----    ----- ----------        ----
        ENTER-PARAMETER . . $       REWRITE . . . . . . . . ^RW
                                    SAVE-FILE . . . . . . . ^SV
CURSOR  CURSOR-UP . . . . . ^CU     SET-FILE  . . . . . . . ^FL
        CURSOR-DOWN . . . . ^CD     SWITCH  . . . . . . . . ^SW
        CURSOR-LEFT   . . . ^CL     TAB-SET . . . . . . . . ^TS
        CURSOR-RIGHT  . . . ^CR     WINDOW  . . . . . . . . ^WI
        CURSOR-HOME   . . . ^CH
        CARRIAGE-RETURN . . ^RT
        TAB . . . . . . . . ^TB     OTHER CONSTRUCTS        FORMAT
        BACKTAB . . . . . . ^BT     ----- ----------        ------
        UP-TAB  . . . . . . ^UT     START-UP  . . . . . . . ^ST( ... )
        DOWN-TAB  . . . . . ^DT     IMAGE-OUTPUT  . . . . . ^OU( ... )
        BEGIN-LINE  . . . . ^LB     NO-DISPLAY  . . . . . . ^ND
        END-LINE  . . . . . ^LE
        LINE  . . . . . . . ^LN     ITERATED-DO . . . . . . ^n( ... )
                                    DO-WHILE  . . . . . . . ^DWc( ... )
ROLLS   ROLL-BACK-PAGES . . ^RBP    DO-ON-SEARCH-FAILURE  . ^DF( ... )
        ROLL-FORWARD-PAGES. ^RFP    IF-CHARACTER  . . . . . ^IFc( ... )
        ROLL-BACK-LINES . . ^RBL    IF-ROW  . . . . . . . . ^FRc( ... )
        ROLL-FORWARD-LINES. ^RFL    IF-COLUMN . . . . . . . ^FCc( ... )
        PERCENT-GOTO  . . . ^GO     EXIT-BLOCK  . . . . . . ^XB
        SLIDE-LEFT. . . . . ^SL     CONTINUE-BLOCK. . . . . ^CB
        SLIDE-RIGHT . . . . ^SR     EXIT-BUFFER . . . . . . ^XX

SEARCH  SEARCH-FORWARD  . . ^SF     CLEAR-COUNTER . . . . . ^C=
        SEARCH-BACKWARD . . ^SB     INCREMENT-COUNTER . . . ^C+
        SUBSTITUTE  . . . . ^SU     DECREMENT-COUNTER . . . ^C-
                                    SET-COUNTER . . . . . . ^SC
TEXT    INSERT-SPACES . . . ^IS     USE-COUNTER . . . . . . ^CT
        DELETE-SPACES . . . ^DS     ITERATE-COUNTER . . . . ^C.( ... )
        INSERT-LINES  . . . ^IL     IF-COUNTER  . . . . . . ^F.c( ... )
        DELETE-LINES  . . . ^DL
        PICK  . . . . . . . ^PK     For DO-WHILE or IF-CHARACTER:
        PUT   . . . . . . . ^PT
        INSERT-MODE . . . . ^IN           SOME GIVEN CHARACTER
        DELETE-CHARACTER. . ^DC       ^L  ALPHABETIC (A-Z, a-z)
        CLEAR-LINE  . . . . ^LF       ^U  UPPER CASE (A-Z)
        ERASE-LINE  . . . . ^EL       ^N  NUMERIC (0-9)
        ERASE-WORD  . . . . ^EW       ^A  ALPHA-NUMERIC
                                      ^S  SPACE OR TAB
OTHERS  ABORT . . . . . . . ^AB       ^E  END OF LINE OR BEYOND
        CASE  . . . . . . . ^CS
        ENTER-CTRL-CHAR . . ^EC       ^X  .NOT. ONE OF THE ABOVE
        EXECUTE . . . . . . ^EX
        EXIT  . . . . . . . ^XT     For IF-ROW, -COLUMN, -COUNTER:
        HELP  . . . . . . . ^HL
        JUSTIFY . . . . . . ^JU        En  EQUAL TO n
        MARK  . . . . . . . ^MK        Gn  GREATER THAN n
        REAL-TAB  . . . . . ^TA        Ln  LESS THAN n
        RECALL  . . . . . . ^RC        Nn  NOT EQUAL TO n
                              - 60 -



                              EXAMPLE I
                    VT52 TERMINAL KEYBOARD LAYOUT

     The VT52 has a numeric  keypad  to  the  right  of  the  normal
keyboard.  Four cursor movement keys are at the right of that keypad
and there are three colored buttons above  the  pad.   The  leftmost
(blue)  button  is the <ENTER> command, the rightmost one (BLACK) is
<HOME>, and the center one (RED) is <RECALL>.  The  number  keys  in
the  pad  invoke  SED commands.  Do not use the red ESC (SEL) key at
the upper left of the keyboard.


VT52 EDITOR KEYBOARD

.____.____.____.____.____.____.____.____.____.____.____.____.____.____.
!    !    !    !    !    !    !    !    !    !    !    !    !    !ERAS!
! !  ! @  ! #  ! $  ! %  ! ^  ! &  ! *  ! (  ! )  ! _  ! +  !SUBS!CHAR!
! 1  ! 2  ! 3  ! 4  ! 5  ! 6  ! 7  ! 8  ! 9  ! 0  ! -  ! =  ! ~` !back!
!____!____!____!____!____!____!____!____!____!____!____!____!____!____!_.
  !xon !ROLL!SRCH!SRCH!ROLL!ROLL!BACK!    !ENTR!PERC!    !    !ERAS!RE- !
  !    !BK L!BACK!FWD !FW L!FW P!TAB !TAB !CCH !GOTO! ]  ! |  !LINE!SET !
  ! q  ! w  ! e  ! r  ! t  ! y  ! u  ! i  ! o  ! p  ! [  ! \  !lnfd! del!
  !____!____!____!____!____!____!____!____!____!____!____!____!____!____!_.
    !ROLL!xoff!INS !DEL !    !CUR !ERAS!INS !DEL !    !    !    !         !
    !BK P!    !LINE!LINE!PUT !LEFT!LINE!SPAC!SPAC! :  ! "  ! }  ! RETURN  !
    ! a  ! s  ! d  ! f  ! g  ! h  ! j  ! k  ! l  ! ;  ! ,  ! {  !         !
.___!____!____!____!____!____!____!____!____!____!____!____!____!_________!
!     !    !    !    !    !SET !    !RE- !    !    !    !       !    !    !
!shift!EXIT!EXCT!ABRT!PICK!FILE!SWCH!TURN! <  ! >  ! ?  ! shift !rept!copy!
!     ! z  ! x  ! c  ! v  ! b  ! n  ! m  ! ,  ! .  ! /  !       !    !    !
!_____!____!____!____!____!____!____!____!____!____!____!_______!____!____!

        NUMERIC PAD AT RIGHT     .____.____.____.____.
        OF NORMAL KEYBOARD:      !    !RE- !    !CUR !
                                 !ENTR!CALL!HOME! UP !
                                 !blue!red !blck! /\ !
                                 !____!____!____!____!
                                 !    !UP- !    !CUR !
                                 !MARK!TAB !CASE!DOWN!
                                 !  7 ! 8  ! 9  ! \/ !
                                 !____!____!____!____!
                                 !BEG-!RE- !END-!CUR !
                                 !LINE!WRIT!LINE!RGHT!
                                 ! 4  ! 5  ! 6  ! -> !
                                 !____!____!____!____!
                                 !WIN-!DOWN!    !CUR !
                                 !DOW !TAB !HELP!LEFT!
In addition:                     ! 1  ! 2  ! 3  ! <- !
                                 !____!____!____!____!
  ESCAPE-L is <SLIDE-LEFT>       !   REAL  !ERAS!INS !
  ESCAPE-T is <SLIDE-RIGHT>      !   TAB   !WORD!MODE!
  ESCAPE-S is <TAB-SET>          !    0    ! .  !entr!
  ESCAPE-J is <JUSTIFY>          !_________!____!____!

                              - 61 -



                             EXAMPLE II
                   VT100 TERMINAL KEYBOARD LAYOUT


VT100 KEYBOARD LAYOUT

._____.                                               .____.____.____.____.
!set- !                                               !    !    !    !    !
! up  !                                               ! /\ ! \/ ! <- ! -> !
!     !                                               ! UP !DOWN!LEFT!RGHT!
!___._!__.____.____.____.____.____.____.____.____.____!____!____!____!____!
!   !    !    !    !    !    !    !    !    !    !    !    !    !    !ERAS!
!esc! !  ! @  ! #  ! $  ! %  ! ^  ! &  ! *  ! (  ! )  ! _  ! +  !SUBS!CHAR!
!   ! 1  ! 2  ! 3  ! 4  ! 5  ! 6  ! 7  ! 8  ! 9  ! 0  ! -  ! =  ! ~` !back!
!___!____!____!____!____!____!____!____!____!____!____!____!____!____!____!_.
!     !xon !ROLL!SRCH!SRCH!ROLL!ROLL!BACK!    !ENTR!PERC!    !    !    !RE- !
! TAB !    !BK L!BACK!FWRD!FW L!FW P! TAB!TAB !CCH !GOTO! {  ! }  !    !SET !
!     ! q  ! w  ! e  ! r  ! t  ! y  ! u  ! i  ! o  ! p  ! [  ! ]  !    ! del!
!_____!____!____!____!____!____!____!____!____!____!____!____!____!    !____!
!       !ROLL!xoff!INS !DEL !    !CUR !ERAS!INS !DEL !    !    !       !    !
! caps  !FW P!    !LINE!LINE!PUT !LEFT!LINE!SPAC!SPAC! :  ! "  ! RETURN! |  !
! lock  ! a  ! s  ! d  ! f  ! g  ! h  ! j  ! k  ! l  ! ;  ! ,  !       ! \  !
!_______!____!____!____!____!____!____!____!____!____!____!____!_______!____!
!         !    !    !    !    !SET-!    !RE- !    !    !    !         !ERAS!
! shift   !EXIT!EXCT!ABRT!PICK!FILE!SWCH!TURN! <  ! >  ! ?  !  shift  !LINE!
!         ! z  ! x  ! c  ! v  ! b  ! n  ! m  ! ,  ! .  ! /  !         ! lf !
!_________!____!____!____!____!____!____!____!____!____!____!_________!____!

        NUMERIC PAD AT RIGHT     .____.____.____.____.
        OF NORMAL KEYBOARD:      !    !RE- !    !SAVE!
                                 !ENTR!CALL!HOME!FILE!
                                 ! pf1! pf2! pf3! pf4!
                                 !____!____!____!____!
                                 !    !UP- !    !SLID!
                                 !MARK!TAB !CASE!LEFT!
                                 ! 7  ! 8  ! 9  ! -  !
                                 !____!____!____!____!
                                 !BEG-!RE- !END-!SLID!
                                 !LINE!WRIT!LINE!RGHT!
                                 ! 4  ! 5  ! 6  ! ,  !
                                 !____!____!____!____!
                                 !WIN-!DOWN!    !INS !
                                 !DOW !TAB !HELP!MODE!
                                 ! 1  ! 2  ! 3  ! e  !
                                 !____!____!____! n  !
                                 !         !ERAS! t  !
                                 !REAL-TAB !WORD! e  !
                                 !    0    ! .  ! r  !
                                 !_________!____!____!

In addition: ESCAPE-S is <TAB-SET>
             ESCAPE-J is <JUSTIFY>


                              - 62 -



                INDEX OF EDITOR COMMANDS, BY COMMAND

PAGE  COMMAND    NAME                 EXPLANATION

 13     ^K       INSERT-SPACES        INSERT SPACES TO FILE
 23     ^B       SET-FILE             SET UP A FILE FOR EDITING
 25     ^C       ABORT                EXIT AND FORGET CHANGES
 10     ^D       INSERT-LINES         INSERT BLANK LINES IN FILE
 14     ^E       SEARCH-BACKWARD      SEARCH FROM CURSOR TO START OF FILE
 10     ^F       DELETE-LINES         DELETE LINES FROM FILE
 19     ^G       PUT                  PUT TEXT INTO FILE
  6     LEFT     CURSOR-LEFT          MOVE CURSOR LEFT
  7     ^I       TAB                  MOVE TO NEXT TAB STOP
 12     (none)   CLEAR-LINE           CLEAR LINE BELOW CURSOR
 12     ^J       ERASE-LINE           ERASE FROM CURSOR TO END OF LINE
  9     ESC-L    SLIDE-LEFT           SLIDE VIEWING WINDOW LEFT
  9     ESC-T    SLIDE-RIGHT          SLIDE VIEWING WINDOW RIGHT
  6     ^M       CARRIAGE-RETURN      GOOD OL' ASCII CARRIAGE RETURN
 28     ^N       SWITCH               SET SWITCHES OR QUERY STATUS
 27     ^O       ENTER-CTRL-CHAR      MAKE NEXT CHARACTER A CONTROL CHAR.
  9     ^P       PERCENT-GOTO         GO TO SOME PERCENT THROUGH THE FILE
  8     ^A       ROLL-BACK-PAGES      MOVE VIEWING WINDOW BACK PAGES
 14     ^R       SEARCH-FORWARD       SEARCH FROM CURSOR TO END
 13     ^L       DELETE-SPACES        DELETE CHARACTERS FROM FILE
  8     ^T       ROLL-FORWARD-LINES   MOVE VIEWING WINDOW FORWARD LINES
  7     ^U       BACKTAB              MOVE TO PREVIOUS TAB STOP
 17     ^V       PICK                 PICK TEXT FROM FILE
  8     ^W       ROLL-BACKWARD-LINES  MOVE VIEWING WINDOW BACK LINES
 38     ^X       EXECUTE              PERFORM SEQUENCE OF EDITOR COMMANDS
  8     ^Y       ROLL-FORWARD-PAGES   MOVE VIEWING WINDOW FORWARD PAGES
 25     ^Z       EXIT                 EXIT AND SAVE CHANGES
  3     PAD-BLUE ENTER                PASS A PARAMETER TO A COMMAND
 25     DELETE   RESET                RESET SCREEN OR PARAMETER
 34     PAD-RED  RECALL               RECALL PREVIOUS PARAMETER
 22     PAD-ENT  INSERT-MODE          CHARACTER INSERT/REPLACE TOGGLE
 11     BKSP     DELETE-CHARACTER     ERASE CHARACTER TO LEFT OF CURSOR
 27     PAD-0    REAL-TAB             TYPE A REAL TAB IN THE FILE
 20     PAD-7    MARK                 MARK POSITION FOR PICK OR DELETE
 35     PAD-9    CASE                 CHANGE CASE OF LETTER AT CURSOR
 35     PAD-1    WINDOW               SET OR CLEAR SPLIT-SCREEN WINDOWING
  6     PAD-8    UP-TAB               MOVE THE CURSOR UP 6 LINES
  6     PAD-2    DOWN-TAB             MOVE THE CURSOR DOWN 6 LINES
 27     PAD-5    RE-WRITE             REWRITE THE SCREEN
 22     (none)   SAVE-FILE            SAVE THE CURRENT FILE
 34     PAD-3    HELP                 GIVE ON-LINE HELP
  7     PAD-4    BEGIN-LINE           MOVE THE THE BEGINNING OF THE LINE
  7     PAD-6    END-LINE             MOVE THE THE END OF THE LINE
 11     PAD-.    ERASE-WORD           ERASE THE WORD AT THE CURSOR
 15     ^~       SUBSTITUTE           SEARCH AND SUBSTITUTE
 26     ESC-S    TAB-SET              SET AND CLEAR TABS
 36     ESC-J    JUSTIFY              JUSTIFY TEXT
 21     ^?       MARKER               MANIPULATE MARKER IN FILE


                              - 63 -



                ARTICULATED INDEX OF EDITOR COMMANDS

     The COMMAND  column  refers  to  the  control  character  which
invokes  the  desired  command.  UP, DOWN, LEFT, RIGHT, and HOME are
the five cursor movement keys, usually denoted by arrows on the  key
caps  RUB  is the RUBOUT key, sometimes yclept DEL, for DELETE.  ESC
is the ESCAPE or ALTMODE key.  "PAD" means that  the  key  is  on  a
keypad which is separate from the normal typewriter keyboard.

KEY         EXPLANATION                     COMMAND       PAGE

ABORT       EXIT AND FORGET CHANGES           ^C	   25
APPEND      APPENDING LINES TO PICK BUFFER    ^V	   17

BACKWARD    ROLL SCREEN BACKWARD LINES        ^W	   8
BACKWARD    ROLL SCREEN BACKWARD PAGES        ^A	   8
BACKWARD    SEARCH BACKWARD                   ^E	   14
BEGINNING   MOVE TO BEGINNING OR END OF LINE  (none)	   7
BEGINNING   MOVE TO THE BEGINNING OF A LINE   PAD-4	   7

CASE        CHANGE CASE OF LETTERS            PAD-9	   35
CHANGES     EXIT AND FORGET CHANGES           ^C	   25
CHANGES     EXIT AND SAVE CHANGES             ^Z	   25
CHARACTER   DELETE THE PREVIOUS CHARACTER     BKSP	   11
CHARACTER   ENTER CONTROL CHARACTER           ^O	   27
CHARACTERS  DELETE CHARACTERS FROM FILE       ^L	   13
CLEAR TAB   SET OR CLEAR TABS                 ESC-S	   26
CLEAR       CLEAR LINE BELOW CURSOR           (none)	   12
COMMAND     EXECUTE COMMAND SEQUENCE          ^X	   38
CONTROL     ENTER CONTROL CHARACTER           ^O	   27
CURSOR      CLEAR LINE BELOW CURSOR           (none)	   12
CURSOR      MOVE CURSOR DOWN                  DOWN	   6
CURSOR      MOVE CURSOR HOME                  PAD-BLK	   6
CURSOR      MOVE CURSOR LEFT                  LEFT	   6
CURSOR      MOVE CURSOR RIGHT                 RIGHT	   6
CURSOR      MOVE CURSOR UP                    UP	   6

DELETE      DELETE CHARACTERS FROM FILE       ^L	   13
DELETE      DELETE LINES FROM FILE            ^F	   10
DELETE      DELETE THE PREVIOUS CHARACTER     BKSP	   11
DELETE      DELETE THE PREVIOUS WORD          PAD-.	   11
DELETE      MARK POSITION FOR PICK OR DELETE  PAD-7	   20
DELETED     RESTORE DELETED LINES             ^G	   19
DISPLAY     RESET PARAMETER OR DISPLAY        DELETE	   25
DOWN        MOVE CURSOR DOWN                  DOWN	   6
DOWN        MOVE CURSOR DOWN 6 LINES          PAD-2	   6

EDIT        EDIT A NEW FILE                   ^B	   23
END         MOVE TO BEGINNING OR END OF LINE  (none)	   7
END         MOVE TO THE END OF A LINE         PAD-6	   7
ENTER       ENTER CONTROL CHARACTER           ^O	   27
ENTER       ENTER PARAMETER                   PAD-BLUE	   3
ERASE       ERASE FROM CURSOR TO END OF LINE  ^J	   12

                              - 64 -
KEY         EXPLANATION                     COMMAND       PAGE


EXECUTE     EXECUTE COMMAND SEQUENCE          ^X	   38
EXECUTE     EXECUTE: BUFFERS IN SWITCH.INI    ^X	   45
EXECUTE     EXECUTE: CONDITIONAL CONSTRUCTS   ^X	   49
EXECUTE     EXECUTE: CONNECTING TO KEYS       ^X	   47
EXECUTE     EXECUTE: DEFERRING THE DISPLAY    ^X	   53
EXECUTE     EXECUTE: FINDING THE BUFFER NAMES ^X	   44
EXECUTE     EXECUTE: KILLING A BUFFER         ^X	   44
EXECUTE     EXECUTE: OUTPUTTING IMAGE CHARS.  ^X	   53
EXECUTE     EXECUTE: READING A BUFFER         ^X	   43
EXECUTE     EXECUTE: READING FROM DISK        ^X	   48
EXECUTE     EXECUTE: SETTING INITIAL PARMS    ^X	   46
EXECUTE     EXECUTE: SETTING UP A BUFFER      ^X	   42
EXECUTE     EXECUTE: THE EXECUTE COUNTER      ^X	   52
EXECUTE     EXECUTE: WRITING A BUFFER         ^X	   42
EXECUTE     EXECUTE: X (WRITE/EXECUTE) FORMAT ^X	   46
EXECUTE     TABLE OF EXECUTE COMMAND NAMES    Appendix	   60
EXIT        EXIT AND FORGET CHANGES           ^C	   25
EXIT        EXIT AND SAVE CHANGES             ^Z	   25

FILE        EDIT A NEW FILE                   ^B	   23
FILE        SAVE THE CURRENT FILE             (none)	   22
FILESPECS   DEFAULT FILESPECS AND SFDS        Appendix	   55
FILESPECS   RECALL CURRENT FILESPECS          PAD-RED	   34
FORGET      EXIT AND FORGET CHANGES           ^C	   25
FORWARD     ROLL SCREEN FORWARD LINES         ^T	   8
FORWARD     ROLL SCREEN FORWARD PAGES         ^Y	   8
FORWARD     SEARCH FORWARD                    ^R	   14

GO TO       GO TO PERCENT IN FILE             ^P	   9

HELP        GIVE ON-LINE HELP                 PAD-3	   34
HOME        MOVE CURSOR HOME                  PAD-BLK	   6

INDIRECT    LOOKING THROUGH A LIST OF FILES   Appendix	   56
INSERT      INSERT LINES IN FILE              ^D	   10
INSERT      INSERT SPACES IN FILE             ^K	   13
INSERT      INSERT TEXT IN FILE               ^G	   19
INSERT      INSERT/REPLACE TOGGLE             PAD-ENT	   22

JOURNAL     INCREMENTAL SAVES AND JOURNALING  Appendix	   58
JUSTIFY     JUSTIFY TEXT                      ESC-J	   36

KEYBOARD    VT100 TERMINAL KEYBOARD LAYOUT    Example	   62
KEYBOARD    VT52 TERMINAL KEYBOARD LAYOUT     Example	   61

LEFT        MOVE CURSOR LEFT                  LEFT	   6
LEFT        SLIDE WINDOW LEFT                 ESC-L	   9
LINE        CLEAR LINE BELOW CURSOR           (none)	   12
LINE        ERASE FROM CURSOR TO END OF LINE  ^J	   12
LINE        MOVE TO BEGINNING OR END OF LINE  (none)	   7
LINE        MOVE TO THE BEGINNING OF A LINE   PAD-4	   7
LINE        MOVE TO THE END OF A LINE         PAD-6	   7
LINES       DELETE LINES FROM FILE            ^F	   10

                              - 65 -
KEY         EXPLANATION                     COMMAND       PAGE


LINES       INSERT LINES IN FILE              ^D	   10
LINES       PICK UP LINES OF FILE             ^V	   17
LINES       RESTORE DELETED LINES             ^G	   19
LINES       ROLL SCREEN BACKWARD LINES        ^W	   8
LINES       ROLL SCREEN FORWARD LINES         ^T	   8
LIST        LOOKING THROUGH A LIST OF FILES   Appendix	   56

MARGINS     USING MARGINS AND SCREEN LIMITS   Appendix	   57
MARK        MARK POSITION FOR PICK OR DELETE  PAD-7	   20
MARKER      MANIPULATE MARKER IN FILE         ^?	   21
MARKER      POP MARKER STACK                  ^?	   21
MOVE        MOVE CURSOR DOWN                  DOWN	   6
MOVE        MOVE CURSOR HOME                  PAD-BLK	   6
MOVE        MOVE CURSOR LEFT                  LEFT	   6
MOVE        MOVE CURSOR RIGHT                 RIGHT	   6
MOVE        MOVE CURSOR UP                    UP	   6
MOVE        MOVE TO NEXT TAB STOP             TAB	   7
MOVE        MOVE TO NEXT TAB STOP             ^I	   7
MOVE        MOVE TO PREVIOUS TAB STOP         ^U	   7

NAMES       TABLE OF EXECUTE COMMAND NAMES    Appendix	   60
NEW         EDIT A NEW FILE                   ^B	   23
NEXT        MOVE TO NEXT TAB STOP             TAB	   7
NEXT        MOVE TO NEXT TAB STOP             ^I	   7

PAGES       ROLL SCREEN BACKWARD PAGES        ^A	   8
PAGES       ROLL SCREEN FORWARD PAGES         ^Y	   8
PARAMETER   ENTER PARAMETER                   PAD-BLUE	   3
PARAMETER   RECALL PARAMETER                  PAD-RED	   34
PARAMETER   RESET PARAMETER OR DISPLAY        DELETE	   25
PERCENT     GO TO PERCENT IN FILE             ^P	   9
PICK        MARK POSITION FOR PICK OR DELETE  PAD-7	   20
PICK        PICK UP LINES OF FILE             ^V	   17
POSITION    MARK POSITION FOR PICK OR DELETE  PAD-7	   20
PREVIOUS    MOVE TO PREVIOUS TAB STOP         ^U	   7

QUERY       SET SWITCHES OR QUERY STATUS      ^N	   28

RECALL      RECALL PARAMETER                  PAD-RED	   34
REPLACE     INSERT/REPLACE TOGGLE             PAD-ENT	   22
RESET       RESET PARAMETER OR DISPLAY        DELETE	   25
RESTORE     RESTORE DELETED LINES             ^G	   19
RETURN      CARRIAGE RETURN                   ^M	   6
REWRITE     REWRITE THE SCREEN                PAD-5	   27
RIGHT       MOVE CURSOR RIGHT                 RIGHT	   6
RIGHT       SLIDE WINDOW RIGHT                ESC-T	   9
ROLL        ROLL SCREEN BACKWARD LINES        ^W	   8
ROLL        ROLL SCREEN BACKWARD PAGES        ^A	   8
ROLL        ROLL SCREEN FORWARD LINES         ^T	   8
ROLL        ROLL SCREEN FORWARD PAGES         ^Y	   8

SAVE        EXIT AND SAVE CHANGES             ^Z	   25
SAVE        SAVE THE CURRENT FILE             (none)	   22

                              - 66 -
KEY         EXPLANATION                     COMMAND       PAGE


SAVES       INCREMENTAL SAVES AND JOURNALING  Appendix	   58
SCAN        SCAN THE FILE BACKWARD            ^W	   8
SCAN        SCAN THE FILE FORWARD             ^T	   8
SEARCH      RECALL CURRENT/FORMER SEARCH KEY  PAD-RED	   34
SEARCH      SEARCH AND SUBSTITUTE STRINGS     ^~	   15
SEARCH      SEARCH BACKWARD                   ^E	   14
SEARCH      SEARCH FORWARD                    ^R	   14
SET TAB     SET OR CLEAR TABS                 ESC-S	   26
SFDS        DEFAULT FILESPECS AND SFDS        Appendix	   55
SLIDE       SLIDE WINDOW LEFT                 ESC-L	   9
SLIDE       SLIDE WINDOW RIGHT                ESC-T	   9
SPACES      INSERT SPACES IN FILE             ^K	   13
SPLIT       SET OR CLEAR SPLIT-SCREEN WINDOW  PAD-1	   35
STACK       POP MARKER STACK                  ^?	   21
STATUS      SET SWITCHES OR QUERY STATUS      ^N	   28
STRINGS     SEARCH AND SUBSTITUTE STRINGS     ^~	   15
SUBSTITUTE  SEARCH AND SUBSTITUTE STRINGS     ^~	   15
SWITCHES    SET SWITCHES OR QUERY STATUS      ^N	   28

TAB         MOVE CURSOR DOWN 6 LINES          PAD-2	   6
TAB         MOVE CURSOR UP 6 LINES            PAD-8	   6
TAB         MOVE TO NEXT TAB STOP             TAB	   7
TAB         MOVE TO NEXT TAB STOP             ^I	   7
TAB         MOVE TO PREVIOUS TAB STOP         ^U	   7
TAB         PUT A REAL TAB IN THE FILE        PAD-0	   27
TAB         SET OR CLEAR TABS                 ESC-S	   26
TERMINAL    VT100 TERMINAL KEYBOARD LAYOUT    Example	   62
TERMINAL    VT52 TERMINAL KEYBOARD LAYOUT     Example	   61
TEXT        INSERT TEXT IN FILE               ^G	   19

UP          MOVE CURSOR UP                    UP	   6
UP          MOVE CURSOR UP 6 LINES            PAD-8	   6

VT100       VT100 TERMINAL KEYBOARD LAYOUT    Example	   62
VT52        VT52 TERMINAL KEYBOARD LAYOUT     Example	   61

WINDOW      SET OR CLEAR SPLIT-SCREEN WINDOW  PAD-1	   35
WINDOW      SLIDE WINDOW LEFT                 ESC-L	   9
WINDOW      SLIDE WINDOW RIGHT                ESC-T	   9
WORD        DELETE THE PREVIOUS WORD          PAD-.	   11














                              - 67 -
    