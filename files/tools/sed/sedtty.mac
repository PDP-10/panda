TITLE	SEDTTY - COMBINED TERMINAL DEFINITION FILE FOR SED
SUBTTL	A CHRISTOPHER HALL FECIT

	SEARCH	SEDSYM
IFN TOPS10,<SEARCH UUOSYM>
IFE TOPS10,<SEARCH MONSYM>

;NOTE:  SEDTTY  combines  all  the terminal tables (which were formerly
;distributed separately) into one file. The tables  for  each  terminal
;can  be  enabled  individually by setting a flag below. If two or more
;terminals are enabled, code will also be set up which asks the monitor
;what type of terminal it is and/or processes  the  /Z:  terminal  name
;switch  (if  there's  only  one terminal type, no decisions have to be
;made, so that decision code does not assemble).

;CAVAET:  Most  of  the  tables  here  are  not up to date, some are of
;questionable reliability, and some define  different  arrangements  of
;SED commands on the keyboard. That is because many tables were sent to
;me  by  sites  who  had  those  terminals,  and I distribute them as I
;receive them. New tables or updates or  corrections  to  these  tables
;will be gratefully accepted and incorporated into this file. so PLEASE
;look  over the tables you want to enable to make sure they do what you
;want them to. The terminal tables,  not  the  documentation,  are  the
;final authority on which keystrokes invoke which commands.

;The only tables I can guarantee to be up-to-date are those for the DEC
;VT52 and VT100 family of terminals. I use those terminals every day.


;To add a new terminal:
;(see SED.MEM for a complete description of each table)

;1) Invent names for the terminal:
;     NAME5 (VT100) - 5-character (or less) name used to build labels
;     NAM4  (V100)  - 4-character name ditto
;     NM3   (V10)   - 3-character name ditto
;     TNAME (VT100) - Name to call the terminal. Used with the /Z: switch.
;		      This is the name returned by TRMOP. on TOPS-20,
;		      or set up in the T20NAM table [see below] on TOPS-20.

;2) Add a switch to the list below (format must be F'NAME5).

;3) Add "GOTERM('NAME5)" to the list at termnl (alphabetical is nice
;   but unnecessary).

;4) Add to CRTTAB: the SIXBIT terminal name (TNAME), under the switch
;   (F'NAME5).

;5) Add the terminal tables under feature test switch F'NAME5.

;6) If TOPS20, add TNAME to T20NAM: at the position of the index returned
;   from GTTYP (NOTE: The name in T20NAM must match name in CRTTAB in the
;   monitor).
;   NOTE: Every terminal must have an entry routine. The routine must begin
;   with the line "IFN ..IDX-1,<JRST DECIDE>" and end with "POPJ P,".

;NAMING CONVENTIONS:
;A number of labels or flags can be found in every terminal table. To avoid
;duplication, they should be named as described below. Similar labels not
;listed here should follow the same conventions. The intention is that if
;sedtty is assembled with all terminals on (all the F'NAME5==1), there will
;be no duplicate labels.

;O'NAME5	Address of terminal output table
;I'NAME5	Address of terminal input table
;C'NAME5	Address of routine to position cursor to given ROW, COLUMN
;L'NAME5	Address of routine to position to start of line
;E'NAME5	Address of entry routine
;X'NAME5	Address of exit routine
;S'NM3'.T	Address of terminal subtable (Example: SV52.T)
;S'NM3'.S	Length of terminal subtable (Example: SV52.S)
;F'NAM4'F	Fast-terminal flag (set if terminal sends XOFF-XON)
;F'NAM4'X	Some other terminal-dependent flag


;FLAGS TO ENABLE EACH TERMINAL TABLE.
;SET VALUE TO 1 IF YOU WANT SED TO RUN ON THAT TERMINAL

FAD100==0	;ADDS REGENT 100
FADM2==0	;ADM2
FADM31==0	;ADM-31
FADM3A==0	;ADM-3A
FANARB==0	;ANN ARBOR
FBEHIV==0	;BEEHIVE B100
FDM3K==0	;DATAMEDIA 3000
FDM152==0	;DATAMEDIA 1520/1521
FDMELT==0	;DATAMEDIA ELITE
FDDISK==0	;DATA DISK
FGIGI==1	;GIGI (VK100)
FH1500==0	;HAZELTINE 1500
FZEH19==1	;ZENITH H19
FMEM2A==0	;MIME 2A
FONTEL==0	;ONTEL SUGARMAN
FIQ120==0	;SOROC IQ 120
FT4041==0	;TELRAY 4041
FVT52==1	;DIGITAL VT52
FVT61==1	;DIGITAL VT61
FVT100==1	;DIGITAL VT100
FVT102==1	;DIGITAL VT102
FVT125==1	;DIGITAL VT125
FVI200==0	;VISUAL 200
FVIEWP==0	;ADDS VIEWPOINT

;IF A FLAG ABOVE IS ON THIS MACRO PUTS THE ADDRESS OF THAT TERMINAL'S OUTPUT
;TABLE AT THE END OF THE LIST AT TERMNL AND ASSIGNS THE INDEX IN TERMNL TO
;X'NAME. FOR EXAMPLE, IF THE TERMINAL IS THE VT52, ITS NAME IS VT52, AND ITS
;TABLE ADDRESS IS OVT52.
;TERMINAL NAMES MUST BE NO LONGER THAN 5 CHARACTERS.

DEFINE GOTERM(NAME),<
	IFN F'NAME,<
	  IF2,<PRINTX [SED will include support for 'NAME terminals]>
	  ..IDX=..IDX+1
	  O'NAME>
	>
	..IDX==0

TERMNL::GOTERM AD100	;ADDRESSES OF THE TERMINAL TABLES TO USE
	GOTERM ADM2
	GOTERM ADM31
	GOTERM ADM3A
	GOTERM ANARB
	GOTERM BEHIV
	GOTERM DM3K
	GOTERM DM152
	GOTERM DDISK
	GOTERM DMELT
	GOTERM GIGI
	GOTERM H1500
	GOTERM ZEH19
	GOTERM MEM2A
	GOTERM ONTEL
	GOTERM IQ120
	GOTERM T4041
	GOTERM VT52
	GOTERM VT61
	GOTERM VT100
	GOTERM VT102
	GOTERM VT125
	GOTERM VI200
	GOTERM VIEWP

IFE ..IDX,<PRINTX ?No terminals are turned on for SED>

;IF THERE'S ONLY ONE TERMINAL TYPE, NO DECISIONS HAVE TO BE MADE.
;SO IF ..IDX IS 1 DON'T GENERATE THESE TABLES AND THE DECISION CODE.

IFN ..IDX-1,<

;SED-INTERNAL NAMES OF TERMINALS. USED BY THE /Z: SWITCH
;AND TO MATCH THE TERMINAL NAME RETURNED FROM THE MONITOR

CRTTAB:
IFN FAD100,<SIXBIT /AD100/>
IFN FADM2, <SIXBIT /ADM2/>
IFN FADM31,<SIXBIT /ADM31/>
IFN FADM3A,<SIXBIT /ADM3A/>
IFN FANARB,<SIXBIT /ANNARB/>
IFN FBEHIV,<SIXBIT /BEEHIV/>
IFN FDM3K, <SIXBIT /DM3000/>
IFN FDM152,<SIXBIT /DM1520/>
IFN FDDISK,<SIXBIT /DDISK/>
IFN FDMELT,<SIXBIT /DMELT/>
IFN FGIGI, <SIXBIT /GIGI/>
IFN FH1500,<SIXBIT /H1500/>
IFN FZEH19,<SIXBIT /ZENH19/>
IFN FMEM2A,<SIXBIT /MIME2A/>
IFN FONTEL,<SIXBIT /ONTEL/>
IFN FIQ120,<SIXBIT /IQ120/>
IFN FT4041,<SIXBIT /TE4041/>
IFN FVT52, <SIXBIT /VT52/>
IFN FVT61, <SIXBIT /VT61/>
IFN FVT100,<SIXBIT /VT100/>
IFN FVT102,<SIXBIT /VT102/>
IFN FVT125,<SIXBIT /VT125/>
IFN FVI200,<SIXBIT /VI200/>
IFN FVIEWP,<SIXBIT /VIEWP/>
CRTLEN==.-CRTTAB

IFE TOPS10,<
;TABLE OF TERMINAL NAMES RECOGNIZED BY TOPS-20.
;CONTAINS SIXBIT SED-INTERNAL TERMINAL NAME; INDEXED BY VALUE RETURNED BY GTTYP
;(STILL UNDER IFN ..IDX)

.NOCRT==0	;NOT A CRT TERMINAL

T20NAM:
	.NOCRT			; 0  ( 0) - MOD 33
	.NOCRT			; 1  ( 1) - MOD 35
	.NOCRT			; 2  ( 2) - MOD 37
	.NOCRT			; 3  ( 3) - TI
	0			; 4  ( 4) - RESERVED FOR CUSTOMER
	0			; 5  ( 5) -     "     "     "
	0			; 6  ( 6) -     "     "     "
	0			; 7  ( 7) -     "     "     "
	.NOCRT			; 8  (10) - DEFAULT: MAX PADDING, ETC.
	.NOCRT		        ; 9  (11) - 'IDEAL' TERMINAL, NO FILL INF SIZ
	0		        ; 10 (12) - VT05
	0		        ; 11 (13) - VT50
	.NOCRT		        ; 12 (14) - LA30
	.NOCRT		        ; 13 (15) - (OBSOLETE)
	.NOCRT		        ; 14 (16) - LA36
	SIXBIT /VT52/		; 15 (17) - VT52
	SIXBIT /VT100/	        ; 16 (20) - VT100
	.NOCRT		        ; 17 (21) - LA38
	.NOCRT		        ; 18 (22) - LA120
	0			; 19 (23) - RESERVED FOR CUSTOMER
	0			; 20 (24) -     "     "     "
	0			; 21 (25) -     "     "     "
	0			; 22 (26) -     "     "     "
	0			; 23 (27) -     "     "     "
	0			; 24 (30) -     "     "     "
	0			; 25 (31) -     "     "     "
	0			; 26 (32) -     "     "     "
	0			; 27 (33) -     "     "     "
	0			; 28 (34) -     "     "     "
	0			; 29 (35) -     "     "     "
	0			; 30 (36) -     "     "     "
	0			; 31 (37) -     "     "     "
	0			; 32 (40) -     "     "     "
	0			; 33 (40) -     "     "     "
	0			; 34 (41) -     "     "     "
	SIXBIT /VT125/	        ; 35 (42) - VT125
	SIXBIT /GIGI/	        ; 36 (43) - VK100
	SIXBIT /VT102/	        ; 37 (45) - VT102
T20NLN==.-T20NAM
>

;SUBROUTINE TO DECIDE WHICH TERMINAL TABLE TO USE
;JUMPS INTO TERMINAL'S ENTRY ROUTINE + 1 (ASSUMES +0/ JRST DECIDE)
;SETS UP T4/ SIXBIT TERMINAL NAME, TM/ ADDRESS OF TERMINAL TABLE

;(STILL UNDER IFN ..IDX)

DECIDE:	SKIPE	T3,TRMNAM	;DID USER GIVE A NAME WITH THE /Z SWITCH?
	JRST	DECID1		;YES - ASSUME HE KNOWS WHAT HE'S DOING; USE IT
IFN TOPS10,<
	MOVE	T3,[2,,T1]	;GET THE TERMINAL TYPE NAME FROM TOPS-10
	MOVEI	T1,.TOTRM	;IN AC T3
	SETO	T2,
	TRMOP.	T3,
	  JRST	DECDN1		;TERMINAL IS UNKNOWN TO TOPS-10
>
IFE TOPS10,<
	MOVEI	T1,.PRIIN	;GET THE TERMINAL TYPE NUMBER FROM TOPS-20
	GTTYP
	  ERJMP	DECDN1		;ERROR (SHOULD NEVER HAPPEN)
	SKIPN	T3,T20NAM(T2)	;MAKE THE NUMBER A SIXBIT NAME IN T3 - VALID?
	JRST	DECDN1		;NO - NON-CRT OR UNDEFINED - ERROR
>
DECID1:	PUSHJ	P,MATCH		;FIND THE GIVEN TERMINAL NAME IN THE TABLE
	JUMPGE	T1,DECIDN	;JUMP IF NO MATCH OR AMBIGUOUS
	HRR	TM,TERMNL(T1)	;ELSE SET UP ADDRESS OF TERMINAL'S TABLES
	MOVE	T4,CRTTAB(T1)	;AND SIXBIT NAME OF TERMINAL
	MOVE	T1,RTE(TM)	;GET ADDRESS OF TERMINAL'S ENTRY ROUTINE
	JRST	1(T1)		;CONTINUE FROM THERE, SKIPPING THE JRST DECIDE

;HERE IF TERMINAL TYPE IS UNKNOWN. COMPLAIN AND EXIT.

DECIDN:	HRROI	T1,[ASCIZ /? Terminal name is ambiguous
/]
	CAIN	T1,0		;SET UP NO MATCH OR AMBIGUOUS MESSAGE
DECDN1:	HRROI	T1,[ASCIZ /? Your terminal type is unknown to SED
/]
IFN TOPS10,<
	OUTSTR	(T1)
	EXIT
>
IFE TOPS10,<
	PSOUT
	HALTF
>
;THIS ROUTINE MATCHES THE GIVEN (SIXBIT) STRING WITH THE TABLE CRTTAB.
;NON-AMBIGUOUS ABBREVIATIONS ARE ALLOWED
;CALL WITH T3/ KEYWORD
;RETURNS T1/ IOWD INDEX (<0) IF MATCH; 0 IF NO MATCH; >0 IF AMBIGUOUS

MATCH:	SETO	T2,		;GET THE MASK OF THE RIGHT LENGTH
	LSH	T2,-6
	TDNE	T3,T2
	JRST	.-2
	SETZ	T4,		;CLEAR IOWD OF FIRST ABBREVIATION FOUND
	MOVSI	T1,-CRTLEN	;GET IOWD INTO TERMINAL NAME TABLE
MATCH1:	MOVE	T0,CRTTAB(T1)	;GET NEXT TABLE ENTRY
	XOR	T0,T3		;SEE IF IT'S AN EXACT MATCH
	JUMPE	T0,CPOPJ	;IF SO, RETURN WITH IOWD INDEX IN T1
	ANDCM	T0,T2		;ELSE MASK ENTRY TO THE LENGTH OF THE KEY
	JUMPN	T0,MATCH3	;JUMP IF NO MATCH
	CAIN	T4,0		;ALREADY FOUND AN ABBREVIATED MATCH?
	SKIPA	T4,T1		;NO - SAVE INDEX OF THIS ONE
	TLZ	T4,-1		;YES - ABBREVIATION IS AMBIGUOUS
MATCH3:	AOBJN	T1,MATCH1	;NO EXACT MATCH YET - LOOP THROUGH TABLE
	MOVE	T1,T4		;DONE - RETURN IOWD INDEX IN T1
	POPJ	P,		;(0=NOT FOUND, -1=AMBIGUOUS)

> ;END IFN ..IDX

IFN FAD100,<
;ADDS REGEANT 100 TERMINAL DEFINITIONS

OAD100:	BYTE (7) 32		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 6		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 33,"Y"," "," "	; HOME
	BYTE (7) 33,"k" 	;CLEAR PAGE
	BYTE (7) 33,"K" 	;CLEAR LINE
	BYTE (7) 1,12		;ROLL UP AND CLEAR LINE
	CPOPJ			;ROLL DOWN AND CLEAR LINE
	CPOPJ			;PROTECT ON
;	BYTE(7) 33,"0","Q"	;PROTECT ON
	CPOPJ			;PROTECT OFF
;	BYTE (7) 33,"0","@"	;PROTECT OFF
	0			;INSERT A BLANK LINE
	0			;INSERT A SPACE
	0			;DELETE LINE
	0			;DELETE SPACE
	BYTE (7) 33,"Y","7"," "	;MOVE TO BOTTOM
	BYTE (7) 14		;HOME AND CLEAR PAGE
	CAD100			;ROUTINE TO POSITION TO CHARACTER
	LAD100			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
	WRP!NLP!SLW!MRK		;FLAGS (WRAPAROUND, REWRITE LAST LINE)
	EAD100			;ROUTINE TO CALL ON ENTRY
	XAD100			;ROUTINE TO CALL ON EXIT
	1,,0			;SEND NULLS AFTER CURSOR POSITIONING
	IAD100			;ADDRESS OF TERMINAL INPUT TABLE
IFN FTIMD,<
	0			;START INSERT MODE
	0			;END INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"*"			;MARK CHARACTER

		0			;COMMAND FOR RUBOUT (RESET)
IAD100:		4
	EXP	37
	-SA10.S,,SA10.T			;^B REQUIRES A SUBTABLE (FUNCTION KEYS)
	EXP	       3,12, 5,35,40	; C - G
	EXP	10,11,34,1,23,15,7,25	; H - O
	EXP	20,27,22,0,24,10,26,21	; P - W
	EXP	30,31,36,33,14,35,13,6	; X - Z, [,\,],^,_
SA10.S=.-SA10.T

SA10.T:	IASUB1,,"1"	;f1 = set file
	IASUB2,,"2"	;f2 = insert control character
	IASUB3,,"3"	;f3 = insert real tab
	IASUB4,,"4"	;f4 = switch
	IASUB5,,"5"	;f5 = insert/replace toggle
	IASUB6,,"6"	;f6 = recall
	IASUB7,,"7"	;f7 = mark
	IASUB8,,"8"	;f8 = exit

IASUB1:	2,,0
IASUB2:	17,,0
IASUB3:	43,,0
IASUB4:	16,,0
IASUB5:	41,,0
IASUB6:	40,,0
IASUB7:	44,,0
IASUB8:	32,,0

;POSITIONING ALGORITHMS
;OUTPUT ROW+37, COLUMN+37; STARTING ROW, COLUMN ARE [1,1]

;MOVE TO ROW (RW), COLUMN (CM)

CAD100:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

;MOVE TO START OF LINE (T4)

LAD100:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,

;ENTRY ROUTINE TO SET TT FORM AND NO CRLF BITS

;NOTE: THE ENTRY AND EXIT ROUTINES HAVE BEEN WRITTEN FOR TOPS-10 ONLY

EAD100:
IFN ..IDX-1,<JRST DECIDE>
IFN TOPS10,<
	PJOB	T1,		;GET JOB NUMBER IN T1
	TRMNO.	T1,		;GET UNIVERSAL DEVICE INDEX IN T1
	  POPJ	P,		;ERROR RETURN
	MOVEM	T1,TTFORM+1	;SET UDI IN ARG BLOCKS
	MOVEM	T1,TTCRLF+1
	MOVEM	T1,TTSET+1
	MOVE	T1,[XWD 2,TTFORM]
	TRMOP.	T1,
	  POPJ	P,		;ERROR RETURN
	MOVEM	T1,TTSTAT	;SAVE FORM STATUS BIT
	MOVE	T1,[XWD 2,TTCRLF]
	TRMOP.	T1,
	  POPJ	P,
	MOVEM	T1,TTSTAT+1	;SAVE CRLF STATUS BIT
	SETOM	TTSET+2		;RESET WORD IF ROUTINE IS USED AGAIN
	MOVE	T1,[XWD 3,TTSET]
	TRMOP.	T1,		;SET TT FORM
	  POPJ	P,
	MOVEI	T1,2010
	MOVEM	T1,TTSET
        MOVE	T1,[XWD 3,TTSET]
        TRMOP.	T1,		;SET TT NO CRLF
          POPJ	P,		;ERROR RETURN
>
	POPJ	P,		;NORMAL RETURN

;EXIT ROUTINE TO RESTORE FORM AND CRLF STATUS

XAD100:
IFN TOPS10,<
	MOVE	T1,TTSTAT+1
        MOVEM	T1,TTSET+2
        MOVE	T1,[XWD 3,TTSET]
        TRMOP.	T1,		;RESTORE CRLF STATUS
          POPJ	P,		;ERROR RETURN
        MOVEI	T1,2006
        MOVEM	T1,TTSET
        MOVE	T1,TTSTAT
        MOVEM	T1,TTSET+2
        MOVE	T1,[XWD 3,TTSET]
        TRMOP.	T1,		;RESTORE FORM STATUS
          POPJ	P,		;ERROR RETURN
>
        POPJ	P,		;NORMAL RETURN

IFN TOPS10,<
;DATA BLOCKS FOR INITIALIZATION TRMOPS (FORM, NO CRLF)

TTFORM: 1006
        0
TTCRLF: 1010
        0
TTSET:  2006
        0
        -1
TTSTAT: 0		;WORD TO SAVE TTY LINE CHARACTERISTICS
        0
>
>

IFN FADM2,<
;ADM2 TERMINAL DEFINITIONS

OADM2:	BYTE (7) 13		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 14		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 36		; HOME
	BYTE (7) 33,"Y" 	;CLEAR PAGE
	BYTE (7) 33,"T" 	;CLEAR LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"E" 	;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,")"		;PROTECT ON
	BYTE (7) 33,"("		;PROTECT OFF
	BYTE (7) 33,"E" 	;INSERT A BLANK LINE
	BYTE (7) 33,"Q" 	;INSERT A SPACE
	BYTE (7) 33,"R" 	;DELETE LINE
	BYTE (7) 33,"W" 	;DELETE SPACE
	BYTE (7) 36,13		;MOVE TO BOTTOM
	BYTE (7) 36,33,"Y"	;HOME AND CLEAR PAGE
	CADM2			;ROUTINE TO POSITION TO CHARACTER
	LADM2			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
	WRP			;FLAGS (WRAPAROUND)
	EADM2			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0			;NO NULLS NEEDED
	IADM2			;ADDRESS OF TERMINAL INPUT TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

		 0			;COMMAND FOR RUBOUT (RESET)
IADM2:		40
	-SAD2.S,,SAD2.T			;^A NEEDS A SUBTABLE
	EXP	       2, 3, 4, 5, 6, 7
	EXP	10,11,34,36,35,15,16,17 ;^K AND ^L ALTERED
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32,33,34,35,37,43 ;36==HOME; 37==REAL-TAB

SAD2.T:	IADF16,,"O"	;^A O CR == 16 == ENTER
	IADF01,,"@"	;^A @ CR ==  1 == INSERT-SPACES
	IADF02,,"A"	;^A A CR ==  2 == DELETE-SPACES
	IADF03,,"B"	;^A B CR ==  3 == SLIDE-LEFT
	IADF04,,"C"	;^A C CR ==  4 == SLIDE-RIGHT
	IADF13,,"L"	;^A L CR == 13 == ERASE-CHARACTER
	IADF14,,"M"	;^A M CR == 14 == INSERT MODE
	IADF15,,"N"	;^A N CR == 15 == RECALL
	IADF08,,"G"	;^A G CR ==  8 == REAL TAB
	IADF12,,"K"	;^A K CR == 12 == MARK
	IADF11,,"J"	;^A J CR == 11 == ERASE-LINE
	IADF10,,"I"	;^A I CR == 10 == WINDOW
SAD2.S==.-SAD2.T

IADF01:	"A"-100,,0
IADF02:	"S"-100,,0
IADF03:	"K"-100,,0
IADF04:	"L"-100,,0
IADF08:	43,,0
IADF12:	44,,0
IADF13:	42,,0
IADF14:	41,,0
IADF15:	40,,0
IADF16:	33,,0
IADF11:	50,,0
IADF10:	47,,0

;ROUTINE TO CALL ON ENTRY

EADM2:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;POSITIONING ALGORITHMS

CADM2:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LADM2:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FADM31,<
;NOTE: THIS MODULE IS AS YET UNTESTED, AND MAY NOT BE QUITE RIGHT

FAD31F==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OADM31:	BYTE (7) 13		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 14		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 36		; HOME
	BYTE (7) 33,"Y"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"T"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"E"		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"G","4"	;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 33,"G","0"	;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 33,"E"		;INSERT LINE (0 IF NONE)
	BYTE (7) 33,"Q"		;INSERT SPACE (0 IF NONE)
	BYTE (7) 33,"R"		;DELETE LINE (0 IF NONE)
	BYTE (7) 33,"W"		;DELETE SPACE (0 IF NONE)
	BYTE (7) 36,13		;MOVE TO BOTTOM
	BYTE (7) 36,33,"Y"	;HOME AND CLEAR ENTIRE PAGE
	CADM31			;ROUTINE TO POSITION TO CHARACTER
	LADM31			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FAD31F,<
	WRP			;TERMINAL-DEPENDENT FLAGS (WRAP)
>
IFN FAD31F,<
	WRP!NPG		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EADM31			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
        0,,0                    ;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IADM31			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FAD31F,<
                0                       ;CODE FOR RUBOUT (0==RESET)
IADM31:	EXP	33, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,36,35,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SA31.S,,SA31.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,37,37
>
IFN FAD31F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO B AND N, B TO ESCAPE-F, AND M TO ESCAPE-S.

                 0                      ;COMMAND FOR RUBOUT (RESET)
IADM31:	EXP	33,21, 1, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,36,35,15,23,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SA31.S,,SA31.T
	EXP		 34,35,37,37
>
;SUBTABLE FOR ESCAPE

SA31.T:	33,,33		;ESCAPE ESCAPE == ENTER
	37,,"H" 	;ESCAPE H == HOME
	42,,"D" 	;ESCAPE D == DELETE-CHARACTER
	41,,"I" 	;ESCAPE I == INSERT-MODE
	43,,"T" 	;ESCAPE T == REAL-TAB
	44,,"M" 	;ESCAPE M == MARK
	40,,"E" 	;ESCAPE E == RECALL
	13,,"L" 	;ESCAPE L == SLIDE-LEFT
	14,,"R" 	;ESCAPE R == SLIDE-RIGHT
	47,,"W" 	;ESCAPE W == WINDOW
IFN FAD31F,<
	02,,"F"		;ESCAPE F == SET-FILE
	16,,"S"		;ESCAPE S == SWITCH
>
SA31.S=.-SA31.T

;ROUTINE TO CALL ON ENTRY

EADM31:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;POSITIONING ALGORITHMS

CADM31:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LADM31:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FADM3A,<
;TABLES FOR THE ADM3A

FAD3AF==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S
FAD3AA==0	;SET THIS IF TERMINAL HAS THE AUTONL SWITCH SET ON

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OADM3A:	BYTE (7) 13		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 14		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 36		; HOME
	0			;CLEAR TO END OF PAGE
	0			;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	0			;ROLL DOWN AND CLEAR LINE
	0			;PROTECT ON  (NONE)
	0			;PROTECT OFF (NONE)
	0			;INSERT LINE (NONE)
	0			;INSERT SPACE (NONE)
	0			;DELETE LINE (NONE)
	0			;DELETE SPACE (NONE)
	BYTE (7) 33,"=","7"," "	;MOVE TO BOTTOM
	BYTE (7) 36,32		;HOME AND CLEAR ENTIRE PAGE
	CADM3A			;ROUTINE TO POSITION TO CHARACTER
	LADM3A			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FAD3AF,<
IFE FAD3AA,<
	MRK!SLW			;TERMINAL-DEPENDENT FLAGS (MARK)
>
IFN FAD3AA,<
	WRP!MRK!SLW		;TERMINAL-DEPENDENT FLAGS (WRAP, MARK)
>>
IFN FAD3AF,<
IFE FAD3AA,<
	MRK!NPG!SLW		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
IFN FAD3AA,<
	WRP!MRK!NPG!SLW		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>>
	EADM3A			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
        0,,0                    ;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IADM3A			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"~"			;MARK TO INSERT ON ENTER

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FAD3AF,<
                0                       ;CODE FOR RUBOUT (0==RESET)
IADM3A:	EXP	33, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,36,35,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SA3A.S,,SA3A.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,37,37
>
IFN FAD3AF,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO B AND N, B TO ESCAPE-F, AND N TO ESCAPE-S.

                 0                      ;COMMAND FOR RUBOUT (RESET)
IADM3A:	EXP	33,21, 1, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,36,35,15,23,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SA3A.S,,SA3A.T
	EXP		 34,35,37,37
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SA3A.T:	$ENTER,,33	;ESCAPE ESCAPE == ENTER
	$CURHM,,"H"	;ESCAPE H == HOME
	$CURHM,,"h"	;ESCAPE h == HOME
	$DELCH,,"D"	;ESCAPE D == DELETE-CHARACTER
	$DELCH,,"d"	;ESCAPE d == DELETE-CHARACTER
	$INMOD,,"I"	;ESCAPE I == INSERT-MODE
	$INMOD,,"i"	;ESCAPE i == INSERT-MODE
	$RLTAB,,"T"	;ESCAPE T == REAL-TAB
	$RLTAB,,"t"	;ESCAPE t == REAL-TAB
	$MARK,,"M"	;ESCAPE M == MARK
	$MARK,,"m"	;ESCAPE m == MARK
	$RECAL,,"E"	;ESCAPE E == RECALL
	$RECAL,,"e"	;ESCAPE e == RECALL
	$CASE,,"C"	;ESCAPE C == CASE
	$CASE,,"c"	;ESCAPE c == CASE
	$SLDLF,,"L"	;ESCAPE L == SLIDE-LEFT
	$SLDLF,,"l"	;ESCAPE l == SLIDE-LEFT
	$SLDRT,,"R"	;ESCAPE R == SLIDE-RIGHT
	$SLDRT,,"r"	;ESCAPE r == SLIDE-RIGHT
	$WINDW,,"W"	;ESCAPE W == WINDOW
	$WINDW,,"w"	;ESCAPE w == WINDOW
	$SUBST,,"X"	;ESCAPE X == SUBSTITUTE
	$SUBST,,"x"	;ESCAPE x == SUBSTITUTE

	$BLINE,,"<"	;ESCAPE < == GO TO START OF LINE
	$ELINE,,">"	;ESCAPE > == GO TO END OF LINE
	$ERSLN,,"F"	;ESCAPE F == ERASE TO EOL
	$ERSLN,,"f"	;ESCAPE f == ERASE TO EOL
	$UPTAB,,"K"	;ESCAPE K == UP TAB
	$UPTAB,,"k"	;ESCAPE k == UP TAB
	$DNTAB,,"J"	;ESCAPE J == DOWN TAB
	$DNTAB,,"j"	;ESCAPE j == DOWN TAB
	$REWRT,,"Q"	;ESCAPE Q == REDRAW SCREEN
	$REWRT,,"q"	;ESCAPE q == REDRAW SCREEN
	$SAVE,,"Z"	;ESCAPE Z == SAVE FILE
	$SAVE,,"z"	;ESCAPE z == SAVE FILE
	$HELP,,"?"	;ESCAPE ? == HELP
	$ERSWD,,"U"	;ESCAPE U == ERASE PREVIOUS WORD
	$ERSWD,,"u"	;ESCAPE u == ERASE PREVIOUS WORD

IFN FAD3AF,<
	$SETFI,,"F"	;ESCAPE F == SET-FILE
	$SETFI,,"f"	;ESCAPE f == SET-FILE
	$SWTCH,,"S"	;ESCAPE S == SWITCH
	$SWTCH,,"s"	;ESCAPE s == SWITCH
>
SA3A.S=.-SA3A.T

;ROUTINE TO CALL ON ENTRY

EADM3A:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;POSITIONING ALGORITHMS

CADM3A:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LADM3A:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FANARB,<

;OUTPUT TABLE FOR THE ANN-ARBOR TERMINAL

OANARB:	BYTE (7) 16		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 37		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 13		; HOME
	0			;CLEAR TO END OF PAGE
	0			;CLEAR TO END OF LINE
	0			;ROLL UP AND CLEAR LINE
	BYTE (7) 12		;ROLL DOWN AND CLEAR LINE
	CPOPJ			;PROTECT ON (CPOPJ IF NONE)
	CPOPJ			;PROTECT OFF (CPOPJ IF NONE)
	0			;INSERT LINE (0 IF NONE)
	0			;INSERT SPACE (0 IF NONE)
	0			;DELETE LINE (0 IF NONE)
	0			;DELETE SPACE (0 IF NONE)
	BYTE (7) 13,16		;MOVE TO BOTTOM
	BYTE (7) 13,14		;HOME AND CLEAR PAGE
	CPOPJ			;SEQUENCE FOR ABSOLUTE POSITIONING
	CPOPJ			;ALGORITHM FOR CURSOR POSITIONING
	^D40			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
	MRK			;FLAGS (MARK ON ENTER, NO ROLL DOWN)
	EANARB			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0			;NO NULLS NEEDED
	IANNAB			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;INSERT MODE ON (NONE)
	0			;INSERT MODE OFF (NONE)
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"$"			;MARK TO DISPLAY ON ENTER (OMIT IF MRK NOT SET)

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

		 0			;COMMAND FOR RUBOUT (RESET)
IANNAB:	EXP	40, 1, 2, 3, 4, 5, 6, 7
	EXP	10,11,34,37,14,15,34,17 ;13==HOME, 16==UP
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-7,,ISUBTB			;ESCAPE NEEDS A SUBTABLE (FOR EXAMPLE)
	EXP		 34,35,36,35    ;37==RIGHT

	EXP	$RESET				;RUBOUT
		0
IVT52:	EXP		$RECAL, $INSSP, $SETFI	;   0, A, B
;			40	1	2
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
;		3	4	5	6
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
; DELCH		7	XX 	11	50
	EXP	$SLDLF, $SLDRT, $RETRN, $SWTCH	;K, L, M, N
;		13	14	15	16
	EXP	$ENTCC, $GOTO,  $RLBKP, $SRCFW	;O, P, Q, R
;		17	20	21	22
	EXP	$DELSP, $RLFWL, $BKTAB, $PICK	;S, T, U, V
;		23	24	25	26
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
;		27	30	31	32
	EXP	-SIZ.IS,,I.VT52			;ESCAPE
;		33
	EXP	$PUSH,  $CURRT, $SUBST, $SAVE 	;\, ], ^, _

ISUBTB: $CURUP,,"A" 	;ESCAPE A == UP
	$CURDN,,"B" 	;ESCAPE B == DOWN
	$CURRT,,"C" 	;ESCAPE C == RIGHT
	$CURLF,,"D" 	;ESCAPE D == LEFT
	$ENTER,,"P" 	;ESCAPE P == ENTER
	$CURHM,,"R" 	;ESCAPE R == HOME
	$RECAL,,"Q" 	;ESCAPE Q == RECALL

;ANN-ARBOR ENTRY ROUTINE. NONE NEEDED; JUST INTERFACE TO DECIDE:

EANARB:
IFN ..IDX-1,<JRST DECIDE>	;DECIDE WHICH TERMINAL, IF MORE THAN ONE
	POPJ	P,		;NOTHING ELSE TO DO
>

IFN FBEHIV,<
;BEEHIVE B100 TERMINAL DEFINITIONS FOR THE EDITOR

FBE10F==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OBEHIV:	BYTE (7) 33,"A"		;CURSOR UP
	BYTE (7) 33,"B"		; DOWN
	BYTE (7) 33,"C"		; RIGHT
	BYTE (7) 33,"D"		; LEFT
	BYTE (7) 33,"H"		; HOME
	BYTE (7) 33,"J"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"K"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"]"		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 33,"["		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 33,"P"		;DELETE SPACE (0 IF NONE)
	BYTE (7) 33,"F","7"," "	;MOVE TO BOTTOM
	BCLRSC			;HOME AND CLEAR ENTIRE PAGE
	CBEHIV			;ROUTINE TO POSITION TO CHARACTER
	LBEHIV			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FBE10F,<
	WRP!NLP			;TERMINAL-DEPENDENT FLAGS
>
IFN FBE10F,<
	WRP!NLP!NPG		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EBEHIV			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	6,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IBEHIV			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FBE10F,<
		0			;CODE FOR RUBOUT (0==RESET)
IBEHIV:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,13,14,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SB10.S,,SB10.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,36,37
>
IFN FBE10F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T.

		 0			;COMMAND FOR RUBOUT (RESET)
IBEHIV:	EXP	40,21, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34, 1,23,15,16,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SB10.S,,SB10.T
	EXP		 34,35,36,37
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SB10.T:	33,,"E" 	;ESCAPE E == ENTER
	33,,"e"
	43,,"T" 	;ESCAPE T == REAL-TAB
	43,,"t"
	40,,"Q" 	;ESCAPE Q == RECALL
	40,,"q"
	41,,"I" 	;ESCAPE I == INSERT-MODE
	41,,"i"
	44,,"M" 	;ESCAPE M == MARK
	44,,"m"
	50,,"K" 	;ESCAPE K == ERASE-LINE
	50,,"k"
	47,,"W" 	;ESCAPE W == WINDOW
	47,,"w"
IFN FBE10F,<
	13,,"L"		;ESCAPE L == SLIDE-LEFT
	14,,"R"		;ESCAPE T == SLIDE-RIGHT
	13,,"l"		;ESCAPE l == SLIDE-LEFT
	14,,"r"		;ESCAPE t == SLIDE-RIGHT
>
SB10.S=.-SB10.T

;ROUTINE TO CALL ON ENTRY

EBEHIV:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;SUBROUTINE TO MOVE TO ROW (RW), COLUMN (CM)

CBEHIV:	MOVE	T1,[BYTE (7) 33,"F"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

;SUBROUTINE TO MOVE TO START OF LINE (T4)

LBEHIV:	MOVE	T1,[BYTE (7) 33,"F"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,

;SUBROUTINE TO MOVE TO START OF LINE (T4)

BCLRSC:	MOVE	T1,[BYTE (7) 33,"E"]
	PUSHJ	P,PUTSQ1
	PUSHJ	P,PUTTYP	;OUTPUT IT NOW
	MOVEI	T1,^D100	;LET IT TAKE EFFECT
IFN TOPS10,<
	HIBER	T1,
	  JFCL
>
IFE TOPS10,<
	DISMS
>
	POPJ	P,
>

IFN FDM3K,<
;DATAMEDIA 3000 TERMINAL DEFINITIONS

FDM3KF==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

ODM3K:	BYTE (7) 33,"A"		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 33,"C"		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 33,"H"		; HOME
	BYTE (7) 33,"J"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"K"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"O"		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 33,"N"		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 33,"R"		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) 33,"Y"," ","7"	;MOVE TO BOTTOM
	BYTE (7) 33,"H",33,"J"	;HOME AND CLEAR ENTIRE PAGE
	CDM3K			;ROUTINE TO POSITION TO CHARACTER
	LDM3K			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FDM3KF,<
	WRP			;TERMINAL-DEPENDENT FLAGS
>
IFN FDM3KF,<
	WRP!NPG			;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EDM3K			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IDM3K			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

;NOTE: D3000 KEYS NOT USED: PF10=$y<CR> XMIT=$L XMIT-LINE=$T MR=$M
;      PRINT=$] ROLL=$V INS-CHAR=$P

IFE FDM3KF,<
		0			;CODE FOR RUBOUT (0==RESET)
IDM3K:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,13,14,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SDM3.S,,SDM3.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 35,33,37,36	;ENTER==CONTROL-]
>
IFN FDM3KF,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T.

		 0			;COMMAND FOR RUBOUT (RESET)
IDM3K:	EXP	40,21, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34, 1,23,15,16,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SDM3.S,,SDM3.T
	EXP		 35,33,37,36	;ENTER==CONTROL-]
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SDM3.T:	D3PF1,,"p"	;PF1 == ENTER
	35,,"C" 	;ESCAPE C == CURSOR-RIGHT
	36,,"A"		;ESCAPE A == CURSOR-UP
	D3PF2,,"q"	;PF2 == RECALL
	D3PF3,,"r"	;PF3 == INSERT-MODE
	D3PF4,,"s"	;PF4 == MARK
	D3PF5,,"t"	;PF5 == TAB
	D3PF6,,"u"	;PF6 == LINE
	D3PF7,,"v"	;PF7 == CASE
	D3PF8,,"w"	;PF8 == ERASE-CHAR
	D3PF9,,"x"	;PF9 == HOME
	33,,"E" 	;ESCAPE E == ENTER
	33,,"e"
	41,,"I" 	;ESCAPE I == INSERT-MODE
	41,,"i"
	44,,"M" 	;ESCAPE M == MARK
	44,,"m"
	50,,"K" 	;ESCAPE K == ERASE-LINE
	50,,"k"
	47,,"W" 	;ESCAPE W == WINDOW
	47,,"w"
IFN FDM3KF,<
	13,,"L"		;ESCAPE L == SLIDE-LEFT
	14,,"R"		;ESCAPE R == SLIDE-RIGHT
	13,,"l"		;ESCAPE l == SLIDE-LEFT
	14,,"r"		;ESCAPE r == SLIDE-RIGHT
>
SDM3.S=.-SDM3.T

D3PF1:	33,,0
D3PF2:	40,,0
D3PF3:	41,,0
D3PF4:	44,,0
D3PF5:	43,,0
D3PF6:	45,,0
D3PF7:	46,,0
D3PF8:	42,,0
D3PF9:	37,,0

;ROUTINE TO CALL ON ENTRY

EDM3K:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;SUBROUTINE TO MOVE TO ROW (RW), COLUMN (CM)

CDM3K:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

;SUBROUTINE TO MOVE TO START OF LINE (T4)

LDM3K:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	POPJ	P,
>

IFN FDM152,<
;DATAMEDIA 1520/1521 TERMINAL DEFINITIONS

FDM52F==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

ODM152:	BYTE (7) 37		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 34		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) "Y"-100	; HOME
	BYTE (7) 13		;CLEAR TO END OF PAGE
	BYTE (7) 35		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 0		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 0		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) 36," ","7"	;MOVE TO BOTTOM
	BYTE (7) 14		;HOME AND CLEAR ENTIRE PAGE
	CDM152			;ROUTINE TO POSITION TO CHARACTER
	LDM152			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FDM52F,<
	WRP!MRK			;TERMINAL-DEPENDENT FLAGS
>
IFN FDM52F,<
	WRP!MRK!NPG		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EDM152			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IDM152			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"~"			;MARK TO DISPLAY ON ENTER (OMIT IF MRK NOT SET)

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FDM52F,<
		0			;CODE FOR RUBOUT (0==RESET)
IDM152:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,13,14,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SDM5.S,,SDM5.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 35,33,37,36	;ENTER==CONTROL-]
>
IFN FDM52F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T.

		 0			;COMMAND FOR RUBOUT (RESET)
IDM152:	EXP	40,21, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34, 1,23,15,16,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SDM5.S,,SDM5.T
	EXP		 35,33,37,36	;ENTER==CONTROL-]
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SDM5.T:	45,,"L" 	;ESCAPE L == LINE
	45,,"l"
	42,,"D" 	;ESCAPE D == DELETE-CHARACTER
	42,,"d"
	43,,"T" 	;ESCAPE T == REAL-TAB
	43,,"t"
	40,,"Q" 	;ESCAPE Q == RECALL
	40,,"q"
	41,,"I" 	;ESCAPE I == INSERT-MODE
	41,,"i"
	44,,"M" 	;ESCAPE M == MARK
	44,,"m"
	46,,"C" 	;ESCAPE C == CASE
	46,,"c"
	50,,"K" 	;ESCAPE K == ERASE-LINE
	50,,"k"
	47,,"W" 	;ESCAPE W == WINDOW
	47,,"w"
IFN FDM52F,<
	13,,"L"		;ESCAPE L == SLIDE-LEFT
	14,,"R"		;ESCAPE R == SLIDE-RIGHT
	13,,"l"		;ESCAPE l == SLIDE-LEFT
	14,,"r"		;ESCAPE r == SLIDE-RIGHT
>
SDM5.S=.-SDM5.T

;ROUTINE TO CALL ON ENTRY

EDM152:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;SUBROUTINE TO MOVE TO ROW (RW), COLUMN (CM)

CDM152:	MOVEI	T1,36
	IDPB	T1,TY		;START IT OFF
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

;SUBROUTINE TO MOVE TO START OF LINE (T4)

LDM152:	MOVEI	T1,36
	IDPB	T1,TY		;START IT OFF
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE
>

IFN FDDISK,<

ODDISK:	XDDISK
>

IFN FDMELT,<
;DEFINITIONS FOR THE DATAMEDIA ELITE

FDMELF==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

ODMELT:	BYTE (7) 37		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 34		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 31		; HOME
	BYTE (7) 13		;CLEAR TO END OF PAGE
	BYTE (7) 35		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 0		;PROTECT ON (0 IF NONE)
	BYTE (7) 0		;PROTECT OFF (0 IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) 36," ","7"	;MOVE TO BOTTOM
	BYTE (7) 14		;HOME AND CLEAR ENTIRE PAGE
	CDMELT			;ROUTINE TO POSITION TO CHARACTER
	LDMELT			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FDMELF,<
	SLW!WRP!MRK		;TERMINAL-DEPENDENT FLAGS
>
IFN FDMELF,<
	SLW!WRP!MRK!NPG		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EDMELT			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IDMELT			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"*"			;MARK TO DISPLAY ON ENTER (OMIT IF MRK NOT SET)

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FDMELF,<
	EXP	$RESET				;RUBOUT
IDMELT:	EXP		$RECAL, $RLBKP, $SETFI	;   0, A, B
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
	EXP	$PUT,   $CURLF, $TAB,   $CURDN	;G, H, I, J
	EXP	$SLDLF, $SLDRT, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  $RLBKP, $SRCFW	;O, P, Q, R
	EXP	$DELSP, $RLFWL, $BKTAB, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $CURHM, $EXIT	;W, X, Y, Z
	EXP	-SDME.S,,SDME.T			;ESCAPE
	EXP	$CURRT, $ENTER, $CURHM, $DELCH	;\, ], ^, _
>
IFN FDMELF,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T

;NOTE: this table has not been altered for the Datamedia.

	EXP	$RESET				;RUBOUT
IDMELT:	EXP		$RECAL, $RLBKP, $SETFI	;   0, A, B
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
	EXP	$INSSP, $DELSP, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  0,	$SRCFW	;O, P, Q, R
	EXP	0,	$RLFWL, $BKTAB, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		-SDME.S,,SDME.T			;ESCAPE
	EXP	$CURDN, $CURRT, $CURUP, $CURHM	;\, ], ^, _
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SDME.T:	$SETFI,,"F" 	;ESCAPE F == SET-FILE
	$SAVE ,,"S" 	;ESCAPE S == SAVE-FILE
	$EXIT ,,"E" 	;ESCAPE E == EXIT
	$WINDW,,"W" 	;ESCAPE W == WINDOW
	$REWRT,,"X" 	;ESCAPE X == REWRITE
	$CASE ,,"C" 	;ESCAPE C == CASE
	$HELP ,,"H" 	;ESCAPE H == HELP
	$INSSP,,"I" 	;ESCAPE I == INSERT-SPACES
	$INMOD,,"M" 	;ESCAPE M == INSERT-MODE
	$SLDLF,,"L" 	;ESCAPE L == SLIDE-LEFT
	$SLDRT,,"R" 	;ESCAPE R == SLIDE-RIGHT
	$RLFWP,,"P" 	;ESCAPE P == ROLL-FORWARD-PAGES
	$RLTAB,,"T" 	;ESCAPE T == REAL-TAB
	$RECAL,,"?" 	;ESCAPE ? == RECALL
	$ENTER,,33 	;ESCAPE ESCAPE == ENTER
	$PUSH ,,"^" 	;ESCAPE ^ == PUSH
	$MARK ,,"\" 	;ESCAPE \ == MARK

	$SETFI,,"f" 	;ESCAPE f == SET-FILE
	$SAVE ,,"s" 	;ESCAPE s == SAVE-FILE
	$EXIT ,,"e" 	;ESCAPE e == EXIT
	$WINDW,,"w" 	;ESCAPE w == WINDOW
	$REWRT,,"x" 	;ESCAPE x == REWRITE
	$CASE ,,"c" 	;ESCAPE c == CASE
	$HELP ,,"h" 	;ESCAPE h == HELP
	$INSSP,,"i" 	;ESCAPE i == INSERT-SPACES
	$INMOD,,"m" 	;ESCAPE m == INSERT-MODE
	$SLDLF,,"l" 	;ESCAPE l == SLIDE-LEFT
	$SLDRT,,"r" 	;ESCAPE r == SLIDE-RIGHT
	$RLFWP,,"p" 	;ESCAPE p == ROLL-FORWARD-PAGES
	$RLTAB,,"t" 	;ESCAPE t == REAL-TAB
IFN FDMELF,<
			;IF TTY PAGE IS IN EFFECT,
			;DEFINE SEQUENCES FOR
			;<SLIDE-LEFT> AND <SLIDE-RIGHT> HERE
>
SDME.S=.-SDME.T

;ROUTINE TO CALL ON ENTRY

EDMELT:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;DATAMEDIA SUBROUTINE TO MOVE TO ROW, COLUMN [RW, CM]

CDMELT:	MOVEI	T1,36
	IDPB	T1,TY
	MOVEI	T1," "(CM)
	IDPB	T1,TY
	MOVEI	T1," "(RW)
	IDPB	T1,TY
	POPJ	P,

;DATAMEDIA SUBROUTINE TO MOVE TO THE START OF ROW (T4)

LDMELT:	MOVEI	T1,36
	IDPB	T1,TY
	MOVEI	T1," "
	IDPB	T1,TY
	MOVEI	T1," "(T4)
	IDPB	T1,TY
	POPJ	P,
>

IFN FH1500,<
;EDITOR TERMINAL DEFINITIONS FOR THE HAZELTINE 1500

;EVERYTHING IS USUAL, EXCEPT:
;  ENTER        - ESCAPE ESCAPE
;  CURSOR-UP    - ESCAPE U (OR u)
;  CURSOR-DOWN  - ESCAPE D (OR d)
;  CURSOR-RIGHT - CONTROL-P
;  CURSOR-LEFT  - CONTROL-H
;  CURSOR-HOME  - ESCAPE H (OR h)
;  PERCENT-GOTO - ESCAPE P

FH150F==0	;SET THIS IS TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OH1500:	BYTE (7) "~",14		;CURSOR UP
	BYTE (7) "~",13		; DOWN
	BYTE (7) 20		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) "~",22		; HOME
	BYTE (7) "~",30		;CLEAR TO END OF PAGE
	BYTE (7) "~",17		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) "~",32		;ROLL DOWN AND CLEAR LINE
	BYTE (7) "~",37		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) "~",31		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) "~",32		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) "~",23		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) "~",21,140,27	;MOVE TO BOTTOM
	BYTE (7) "~",34		;HOME AND CLEAR PAGE
	CH1500			;ROUTINE TO POSITION TO CHARACTER
	LH1500			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FH150F,<
	WRP			;TERMINAL-DEPENDENT FLAGS (WRAPAROUND)
>
IFN FH150F,<
	NPG!WRP			;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EH1500			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
        0,,0                    ;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IH1500			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FH150F,<
                0                       ;COMMAND FOR RUBOUT (0==RESET)
IH1500:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,12,13,14,15,16,17
	EXP	35,21,22,23,24,25,26,27
	EXP	30,31,32
	-SH15.S,,SH15.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,36,37
>
IFN FH150F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO B AND N, B TO ESCAPE-F, AND N TO ESCAPE-S.

                 0                      ;COMMAND FOR RUBOUT (RESET)
IH1500:	EXP	40,21, 1, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,12,13,14,15,23,17
	EXP	35, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SH15.S,,SH15.T
	EXP		 34,35,36,37
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SH15.T:	33,,33		;ESC ESC  == ENTER
	37,,"H"		;ESCAPE H == HOME
	37,,"h"		;ESCAPE h == HOME
	36,,"U"		;ESCAPE U == UP
	36,,"u"		;ESCAPE u == UP
	34,,"D"	 	;ESCAPE D == DOWN
	34,,"d"	 	;ESCAPE d == DOWN
	35,,"P" 	;ESCAPE P == PERCENT-GOTO
IFN FH150F,<
	02,,"F"		;ESCAPE F == SET-FILE
	16,,"S"		;ESCAPE S == SWITCH
>
SH15.S=.-SH15.T

;ROUTINE TO CALL ON ENTRY

EH1500:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;CURSOR POSITIONING ROUTINES
;MOVE TO ROW (RW), COLUMN (CM)

CH1500:	MOVE	T1,[BYTE (7) 176,21]
	PUSHJ	P,PUTSQ1	;START IT OFF
	SKIPN	T1,CM		;GET COLUMN POSITION - ZERO?
	ADDI	T1,^D96		;YES - SEND ALTERNATE CODE
	IDPB	T1,TY
	SKIPN	T1,RW		;GET ROW POSITION - ZERO?
	ADDI	T1,^D96		;YES - USE ALTERNATE CODE
	IDPB	T1,TY
	POPJ	P,		;DONE

;MOVE TO START OF LINE (T4)

LH1500:	MOVE	T1,[BYTE (7) 176,21]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,^D96		;SET TO COLUMN ZERO
	IDPB	T1,TY
	SKIPN	T1,T4		;GET ROW POSITION - ZERO?
	ADDI	T1,^D96		;YES - USE ALTERNATE CODE
	IDPB	T1,TY
	POPJ	P,		;DONE
>

IFN FZEH19,<
;TERMINAL DEFINITIONS FOR THE ZENITH H19

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OZEH19:	BYTE (7) 33,"A"		;CURSOR UP
	BYTE (7) 33,"B"		; DOWN
	BYTE (7) 33,"C"		; RIGHT
	BYTE (7) 33,"D"		; LEFT
	BYTE (7) 33,"H"		; HOME
	BYTE (7) 33,"J"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"K"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"I"		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"p"		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 33,"q"		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 33,"L"		;INSERT LINE (0 IF NONE)
	BYTE (7) 33,"@"," ",33,"O"	;INSERT SPACE (0 IF NONE)
	BYTE (7) 33,"M"		;DELETE LINE (0 IF NONE)
	BYTE (7) 33,"N"		;DELETE SPACE (0 IF NONE)
	BYTE (7) 33,"Y","7"," "	;MOVE TO BOTTOM
	BYTE (7) 33,"E"		;HOME AND CLEAR ENTIRE PAGE
	CZEH19			;ROUTINE TO POSITION TO CHARACTER
	LZEH19			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
	NPG!TBS			;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
	EZEH19			;ROUTINE TO CALL ON ENTRY
	XZEH19			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IZEH19			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

		 0			;COMMAND FOR RUBOUT (RESET)
IZEH19:	EXP	40, 0, 2, 3, 0, 0,55, 0 ;^F IS SAVE-FILE
	EXP	42,11, 0, 0,13,15,25,17	;^U IS CASE
	EXP	20, 0,14, 0, 0,46,16,47	;^W IS WINDOW
	EXP	30, 0,32
	-SZ19.S,,SZ19.T
	EXP		 34,35,36,37

;SUBTABLES FOR ESCAPE

SZ19.T:	41,,"P" 	;ESC P == INSERT-MODE (BLUE)
	37,,"H" 	;ESC H == HOME
	36,,"A" 	;ESC A == UP
	34,,"B" 	;ESC B == DOWN
	35,,"C" 	;ESC C == RIGHT
	10,,"D" 	;ESC D == LEFT
	07,,"Q" 	;ESC Q == PUT (RED)
	01,,"@" 	;ESC @ == OPEN SPACES
	04,,"L" 	;ESC L == INSERT LINES
	06,,"M" 	;ESC M == DELETE LINES
	12,,"J" 	;ESC J == ERASE LINE
	26,,"R" 	;ESC R == PICK (WHITE)
	23,,"N" 	;ESC N == CLOSE SPACES
	SCHSUB,,"S" 	;ESC S == LOOK FURTHER (F1)
	LNESUB,,"T" 	;ESC T == LOOK FURTHER (F2)
	PGESUB,,"U" 	;ESC U == LOOK FURTHER (F3)
	BAKSUB,,"V" 	;ESC V == LOOK FURTHER (F4)
	FRWSUB,,"W" 	;ESC W == LOOK FURTHER (F5)
	IAZE19,,"?" 	;ESC ? == LOOK FURTHER
SZ19.S==.-SZ19.T

IAZE19:	33,,"M" 	;ESC ? M == ENTER (ENT)
	40,,"n" 	;ESC ? N == RECALL (.)
	42,,"y" 	;ESC ? Y == DEL-CHAR (SDC)
	43,,"p" 	;ESC ? P == REAL-TAB (0)
	44,,"u" 	;ESC ? U == MARK (S5)
	45,,"q" 	;ESC ? Q == LINE (S1)
	53,,"r"		;ESC ? r == DOWN TAB (S2)
	52,,"x"		;ESC ? x == UP TAB   (S8)
	57,,"t"		;ESC ? t == BEGIN LINE (S4)
	60,,"v"		;ESC ? v == END LINE (S6)
	61,,"s"		;ESC ? s == ERASE WORD (S3)
	45,,"q" 	;ESC ? Q == LINE (S1)
	54,,"w"		;ESC ? w == REPAINT SCREEN (S7)
	0

SCHSUB:	SCHTBL,,33	;ESC S ESC == LOOK FURTHER
	0
SCHTBL:	05,,"V" 	;ESC S ESC V == SEARCH-BACK
	22,,"W" 	;ESC S ESC W == SEARCH-FORWARD
	0

LNESUB:	LNETBL,,33	;ESC T ESC == LOOK FURTHER
	0
LNETBL:	24,,"W" 	;ESC T ESC W == ROLL-FORW-LINES (F2,F5)
	27,,"V" 	;ESC T ESC V == ROLL-BACK-LINES (F2,F4)
	0

PGESUB:	PGETBL,,33	;ESC U ESC == LOOK FURTHER
	0
PGETBL:	21,,"V" 	;ESC U ESC V == ROLL-BACK-PAGES (F3,F4)
	31,,"W" 	;ESC U ESC W == ROLL-FORW-PAGES (F3,F5)
	0

BAKSUB:	BAKTBL,,33	;ESC V ESC == LOOK FURTHER
	0
BAKTBL:	21,,"U" 	;ESC V ESC U == ROLL-BACK-PAGES (F4,F3)
	27,,"T" 	;ESC V ESC T == ROLL-BACK-LINES (F4,F2)
	05,,"S" 	;ESC V ESC S == SEARCH-BACK     (F4,F1)
	0

FRWSUB:	FRWTBL,,33	;ESC W ESC == LOOK FURTHER
	0
FRWTBL:	22,,"S" 	;ESC W ESC S == SEARCH-FORWARD  (F5,F1)
	24,,"T" 	;ESC W ESC T == ROLL-FORW-LINES (F5,F2)
	31,,"U" 	;ESC W ESC U == ROLL-FORW-PAGES (F5,F3)
	0

;ROUTINE CALLED ON ENTRY: SET UP KEYPAD IN APPLICATION MODE

EZEH19:
IFN ..IDX-1,<JRST DECIDE>
IFE TOPS10,<
	MOVEI	T1,.PRIIN
	RFMOD
	TLO	T2,100000	; TERMINAL HAS TABS
	STPAR
>
	HRROI	T1,[BYTE (7) 33,"x","1",33,"Y",70,40,33,"p",0]
IFN TOPS10,<
	OUTSTR	(T1)
>
IFE TOPS10,<
	PSOUT
>
	HRROI	T1,[ASCIZ /    SEARCH    LINE    PAGE   BACK  FORWARD CLEAR  INSERT PUT  PICK  /]
IFN TOPS10,<
	OUTSTR	(T1)
>
IFE TOPS10,<
	PSOUT
>
	MOVE	T1,[BYTE (7) 33,"=",33,"t",33,"q",33,"H",0]
	PUSHJ	P,PUTSQ1
	JRST	PUTTYP

;SUBROUTINE CALLED ON EXIT: RESTORE KEYPAD TO NON-APPLICATION MODE

XZEH19:	MOVE	T1,[BYTE (7) 33,"Z"]
	PUSHJ	P,PUTSQ1
	JRST	PUTTYP

;POSITIONING ALGORITHMS

CZEH19:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LZEH19:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN 0
	IDPB	T1,TY
	POPJ	P,		;DONE
>

IFN FMEM2A,<
;MIME2A TERMINAL DEFINITIONS FOR THE EDITOR

FMM2AF==1	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

OMEM2A:	BYTE (7) 33,"A" 	;CURSOR UP
	BYTE (7) 33,"B" 	; DOWN
	BYTE (7) 33,"C" 	; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 33,"H" 	; HOME
	BYTE (7) 33,"J" 	;CLEAR PAGE
	BYTE (7) 33,"K" 	;CLEAR LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"I" 	;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"S","J"	;PROTECT ON (START REVERSE VIDEO)
	BYTE (7) 33,"S","@"	;PROTECT OFF (END REVERSE VIDEO)
	BYTE (7) "A"-100	;INSERT LINE
	BYTE (7) "O"-100," ",7	;INSERT SPACE
	BYTE (7) "W"-100	;DELETE LINE
	BYTE (7) "N"-100	;DELETE SPACE
	BYTE (7) 33,"Y","7"," " ;MOVE TO BOTTOM
	BYTE (7) 33,"H",33,"J"	;HOME AND CLEAR PAGE
	CMEM2A			;ROUTINE TO POSITION TO CHARACTER
	LMEM2A			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FMM2AF,<
	SLW!TBS			;FLAGS (SHORT MESSAGES,HARD TABS)
>
IFN FMM2AF,<
	SLW!TBS!NPG		;FLAGS (SHORT MSG, HARD TABS, KEEP TTY PAGE)
>
	EMEM2A 			;ROUTINE TO CALL ON ENTRY
	XMEM2A			;ROUTINE TO CALL ON EXIT
        0                       ;NO NULLS NEEDED
	IMEM2A			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"~"			;MARK TO DISPLAY ON ENTER

IFE FMM2AF,<
                 0                      ;COMMAND FOR RUBOUT (RESET)
IMEM2A	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,50,13,14,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SM2A.S,,SM2A.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,36,37
>
IFN FMM2AF,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO B AND N, B TO ESCAPE-1k, AND N TO ESCAPE-2k.

                 0                      ;COMMAND FOR RUBOUT (RESET)
IMEM2A:	EXP	40,21, 1, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,50,13,14,15,23,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SM2A.S,,SM2A.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,36,37
>
SM2A.T:	36,,"A" 	;ESCAPE A == UP
	34,,"B" 	;ESCAPE B == DOWN
	35,,"C" 	;ESCAPE C == RIGHT
	10,,"D" 	;ESCAPE D == LEFT
	33,,"P" 	;ESCAPE P == ENTER
	40,,"Q" 	;ESCAPE Q == RECALL
	37,,"R" 	;ESCAPE R == HOME
	M2A.TT,,"?"	;ESCAPE ? == CHECK SOME MORE
SM2A.S==.-SM2A.T

M2A.TT: 41,,"M"		;ESCAPE ? M == INSERT-MODE
	42,,"n"		;ESCAPE ? n == DELETE-CHARACTER
	43,,"p"		;ESCAPE ? p == REAL TAB
	44,,"w"		;ESCAPE ? w == MARK
	45,,"x"		;ESCAPE ? x == LINE
	46,,"y"		;ESCAPE ? y == CASE
IFN FMM2AF,<
	02,,"q"		;ESCAPE ? q == SET-FILE
	16,,"r"		;ESCAPE ? r == SWITCH
>
	47,,"s"		;ESCAPE ? s == WINDOW
	0

;ROUTINE CALLED ON ENTRY: SET UP KEYPAD IN APPLICATION MODE

EMEM2A:
IFN ..IDX-1,<JRST DECIDE>
	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1
	MOVE	T1,[BYTE (7) 33,"S","@"]
	PUSHJ	P,PUTSQ1		; SET UP DEFAULT VIDEO ATTRIBUTES
	MOVE	T1,[BYTE (7) 33,";"]
	PUSHJ	P,PUTSQ1		; SET UP MIME2A IN JUMP SCROLL MODE
	JRST	PUTTYP

;ROUTINE CALLED ON EXIT: RESTORE KEYPAD TO NON-APPLICATION MODE

XMEM2A:	MOVE	T1,[BYTE (7) 33,76,33,":"]
	PUSHJ	P,PUTSQ1		; RESET MIME2A TO SMOOTH SCROLL MODE
	JRST	PUTTYP

;POSITIONING ALGORITHMS

CMEM2A:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LMEM2A:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FONTEL,<

OONTEL:	XONTEL
>

IFN FIQ120,<
;SOROC IQ 120 TERMINAL DEFINITIONS

FIQ12F==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OIQ120:	BYTE (7) 13		;CURSOR UP
	BYTE (7) 12		; DOWN
	BYTE (7) 14		; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) "^"-100	; HOME
	BYTE (7) 33,"Y"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"T"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,")"		;PROTECT ON (CPOPJ IF NONE)
	BYTE (7) 33,"("		;PROTECT OFF (CPOPJ IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) 33,"=","7"," "	;MOVE TO BOTTOM
	BYTE (7) 33,"*"		;HOME AND CLEAR ENTIRE PAGE
	CIQ120			;ROUTINE TO POSITION TO CHARACTER
	LIQ120			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FIQ12F,<
	WRP!NEL!SLW		;TERMINAL-DEPENDENT FLAGS
>
IFN FIQ12F,<
	WRP!NEL!SLW!NPG	;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EIQ120			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IIQ120			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FIQ12F,<
		0			;CODE FOR RUBOUT (0==RESET)
IIQ120:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34,36,35,15,16,17
	EXP	20,21,22,23,24,25,26,27
	EXP	30,31,32
	-SSIQ.S,,SSIQ.T			;ESCAPE NEEDS A SUBTABLE
	EXP		 34,35,37,37
>
IFN FIQ12F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T.
;this needs work since K and L are cursor movement commands now

		 0			;COMMAND FOR RUBOUT (RESET)
IIQ120:	EXP	40,21, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
	EXP	10,11,34, 1,23,15,16,17
	EXP	20, 0,22, 0,24,25,26,27
	EXP	30,31,32
	-SSIQ.S,,SSIQ.T
	EXP		 34,35,37,37
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SSIQ.T:	33,,"E" 	;ESCAPE E == ENTER
	33,,"e"
	50,,"K" 	;ESCAPE K == ERASE-LINE
	50,,"k"
	43,,"T" 	;ESCAPE T == REAL-TAB
	43,,"t"
	40,,"Q" 	;ESCAPE Q == RECALL
	40,,"q"
	41,,"I" 	;ESCAPE I == INSERT-MODE
	41,,"i"
	44,,"M" 	;ESCAPE M == MARK
	44,,"m"
	44,,"D" 	;ESCAPE D == INSERT-LINES
	44,,"d"		;  (VECTOR 1 MONITOR TRAPS CONTROL-D)
	13,,"L"		;ESCAPE L == SLIDE-LEFT
	13,,"l"
	14,,"R"		;ESCAPE T == SLIDE-RIGHT
	14,,"r"
	47,,"W"		;ESCAPE W == WINDOW
	47,,"w"
SSIQ.S=.-SSIQ.T

;ROUTINE TO CALL ON ENTRY

EIQ120:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;SUBROUTINE TO MOVE TO ROW (RW), COLUMN (CM)

CIQ120:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

;SUBROUTINE TO MOVE TO START OF LINE (T4)

LIQ120:	MOVE	T1,[BYTE (7) 33,"="]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FT4041,<
;TELRAY 4041 TERMINAL DEFINITIONS

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OT4041:	BYTE (7) 33,"A" 	;CURSOR UP
	BYTE (7) 33,"B" 	; DOWN
	BYTE (7) 33,"C" 	; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 33,"H" 	; HOME
	BYTE (7) 33,"J" 	;CLEAR PAGE
	BYTE (7) 33,"K" 	;CLEAR EOL
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	RD4041			;ROLL DOWN AND CLEAR LINE
	BYTE (7) 37		;PROTECT ON (NONE)
	0			;PROTECT OFF
	BYTE (7) 33,"L"		;INSERT LINE
	BYTE (7) 33,"P"		;INSERT SPACE
	BYTE (7) 33,"M"		;DELETE LINE
	BYTE (7) 33,"Q"		;DELETE SPACE
	BYTE (7) 33,"Y","7 "	;MOVE TO BOTTOM
	BYTE (7) 33,"H",33,"J"	;HOME AND CLEAR PAGE
	CT4041			;ROUTINE TO POSITION TO CHARACTER
	LT4041			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
	MRK!NPG			;FLAGS (no protect and leave page alone)
	ET4041			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NO NULLS NEEDED
	IT4041			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"*"			;MARK TO DISPLAY ON ENTER

;ROLL DOWN AND CLEAR LINE

RD4041:	MOVE	T1,[BYTE (7) 33,"H",33,"L"]
	PUSHJ	P,PUTSQ1
	PUSHJ	P,PUTTYP
	MOVEI	T1,^D050	;SLEEP .25 SECONDS
IFN TOPS10,<
	HIBER	T1,
	  JFCL
>
IFE TOPS10,<
	DISMS
>
	POPJ	P,

IT4041:	EXP	40,1,24,3,23,32,13,7 ;NOTHING SPECIAL
	EXP	10,11,50,4,6,15,31,25
	EXP	20,0,5,0,27,16,22,14
	EXP	30,21,0,33
	EXP	35,34,36
		-ST41.S,,ST41.T

ST41.T:	37,,"H" 	;ESCAPE H == HOME
	02,,"F"		;ESCAPE F == SWITCH/SET FILE
	26,,"S"		;ESCAPE S == SWITCH PARAMETERS
	17,,"^"		;ESCAPE C == ENTER CONTROL CHAR
	36,,"A"		;UP
	34,,"B"		;DOWN
	35,,"C"		;RIGHT
	10,,"D"		;LEFT
	33,,"P"		;ENTER
	13,,"R"		;PICK
	07,,"Q"		;PUT
ST41.S==.-ST41.T

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

;		0			;CODE FOR RUBOUT (0==RESET)
;IT4041:	EXP	40, 1, 2, 3, 4, 5, 6, 7 ;NOTHING SPECIAL
;	EXP	10,11,50,13,14,15,16,17
;	EXP	20,21,22,23,24,25,26,27
;	EXP	30,31,32
;	-ST41.S,,ST41.T			;ESCAPE NEEDS A SUBTABLE
;	EXP		 34,35,36,37

;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

;ST41.T:	33,,"P" 	;ESCAPE P == ENTER
;        37,,"R" 	;ESCAPE R == HOME
;        36,,"A" 	;ESCAPE A == UP
;        34,,"B" 	;ESCAPE B == DOWN
;        35,,"C" 	;ESCAPE C == RIGHT
;        10,,"D" 	;ESCAPE D == LEFT
;        40,,"Q" 	;ESCAPE Q == RECALL
;ST41.S==.-ST41.T

;ROUTINE TO CALL ON ENTRY

ET4041:
IFN ..IDX-1,<JRST DECIDE>
	POPJ	P,

;POSITIONING ALGORITHMS

CT4041:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LT4041:	MOVE	T1,[BYTE (7) 33,"Y"]
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,
>

IFN FVT52!FVT61,<
;TABLES TO SUPPORT THE DIGITAL VT52 TERMINAL

FVT52F==1		;FLAG: TURN ON IF TERMINAL SENDS XON-XOFF'S

OVT61:
OVT52:	BYTE (7) 33,"A" 	;CURSOR UP
	BYTE (7) 33,"B" 	; DOWN
	BYTE (7) 33,"C" 	; RIGHT
	BYTE (7) 10		; LEFT
	BYTE (7) 33,"H" 	; HOME
	BYTE (7) 33,"J" 	;CLEAR PAGE
	BYTE (7) 33,"K" 	;CLEAR LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"I" 	;ROLL DOWN AND CLEAR LINE
	CPOPJ			;PROTECT ON (NONE FOR A VT52)
	CPOPJ			;PROTECT OFF
	0			;INSERT LINE (NONE)
	0			;INSERT SPACE (NONE)
	0			;DELETE LINE (NONE)
	0			;DELETE SPACE (NONE)
	BYTE (7) 33,"Y","7"," "	;MOVE TO BOTTOM
	BYTE (7) 33,"H",33,"J"	;HOME AND CLEAR PAGE
	CVT52			;ROUTINE TO POSITION TO CHARACTER
	LVT52			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FVT52F,<
	MRK!TBS!SLW		;FLAGS (NO PROTECT, HARD TABS)
>
IFN FVT52F,<
	MRK!TBS!NPG!SLW		;FLAGS (NO PROTECT, HARD TABS, KEEP TTY PAGE)
>
	EVT52 			;ROUTINE TO CALL ON ENTRY
	XVT52			;ROUTINE TO CALL ON EXIT
	0			;NO NULLS NEEDED
	IVT52			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>
	"~"			;MARK TO DISPLAY ON ENTER

IFE FVT52F,<
	EXP	$RESET				;RUBOUT
IVT52:	EXP		$RECAL, $INSSP, $SETFI	;   0, A, B
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
	EXP	$SLDLF, $SLDRT, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  $RLBKP, $SRCFW	;O, P, Q, R
	EXP	$DELSP, $RLFWL, $BKTAB, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		-SV52.S,,SV52.T		;ESCAPE
	EXP	$PUSH,  $JUSTI, $SUBST, $SAVE	;\, ], ^, _
>
IFN FVT52F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T

	EXP	$RESET				;RUBOUT
IVT52:	EXP		$RECAL, $RLBKP, $SETFI	;   0, A, B
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
	EXP	$INSSP, $DELSP, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  0,	$SRCFW	;O, P, Q, R
	EXP	0,	$RLFWL, $BKTAB, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		-SV52.S,,SV52.T			;ESCAPE
	EXP	$PUSH,  $JUSTI, $SUBST, $SAVE	;\, ], ^, _
>
SV52.T:	$ENTER,,"P" 	;ESCAPE P == ENTER
	$CURHM,,"R" 	;ESCAPE R == HOME
	$CURUP,,"A" 	;ESCAPE A == UP
	$CURDN,,"B" 	;ESCAPE B == DOWN
	$CURRT,,"C" 	;ESCAPE C == RIGHT
	$CURLF,,"D" 	;ESCAPE D == LEFT
	$RECAL,,"Q" 	;ESCAPE Q == RECALL
	IAVT52,,"?"	;ESCAPE ? == CHECK SOME MORE
	$TBSET,,"S" 	;ESCAPE S == SET-TABS
	$TBSET,,"s" 	;ESCAPE s == SET-TABS
	$JUSTI,,"J" 	;ESCAPE J == JUSTIFY
	$JUSTI,,"j" 	;ESCAPE j == JUSTIFY
	$MARKR,,"M" 	;ESCAPE M == MARKER
	$MARKR,,"m" 	;ESCAPE m == MARKER
IFN FVT52F,<
	$SLDLF,,"L" 	;ESCAPE L == SLIDE-LEFT
	$SLDRT,,"T" 	;ESCAPE T == SLIDE-RIGHT
	$SLDLF,,"l" 	;ESCAPE l == SLIDE-LEFT
	$SLDRT,,"t" 	;ESCAPE t == SLIDE-RIGHT
>
SV52.S=.-SV52.T

IAVT52:	$BLINE,,"t"	;ESCAPE ? t == START-OF-LINE
	$ELINE,,"v"	;ESCAPE ? v == END-OF-LINE
	$DNTAB,,"r"	;ESCAPE ? r == DOWN-TAB
	$UPTAB,,"x"	;ESCAPE ? x == UP-TAB
	$CASE ,,"y"	;ESCAPE ? y == CASE
	$ERSWD,,"n"	;ESCAPE ? n == ERASE-WORD
	$RLTAB,,"p"	;ESCAPE ? p == REAL-TAB
	$MARK ,,"w"	;ESCAPE ? w == MARK
	$INMOD,,"M"	;ESCAPE ? M == INSERT-MODE
	$REWRT,,"u"	;ESCAPE ? u == REWRITE SCREEN
	$WINDW,,"q"	;ESCAPE ? q == WINDOW
	$HELP ,,"s"	;ESCAPE ? s == HELP
	0

;POSITIONING ALGORITHMS

CVT52:	MOVSI	T1,(BYTE (7) 33,"Y")
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(RW)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40(CM)	;GET COLUMN POSITION
	IDPB	T1,TY
	POPJ	P,		;DONE

LVT52:	MOVSI	T1,(BYTE (7) 33,"Y")
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,40(T4)	;GET ROW POSITION
	IDPB	T1,TY
	MOVEI	T1,40		;MOVE TO COLUMN ZERO
	IDPB	T1,TY
	POPJ	P,

;ROUTINE CALLED ON ENTRY: DECIDE WHETHER IT'S A VT52 OR VT100
;IF VT52, SET UP KEYPAD IN APPLICATION MODE; DONE

EVT52:
IFN ..IDX-1,<JRST DECIDE>	;IF MORE THAN ONE TERMINAL TYPE, FIND WHICH
	MOVSI	T1,(BYTE (7) 33,"=")
	PUSHJ	P,PUTSQ1	;ENABLE THE ALTERNATE KEYBOARD
IFN FVT61,<
	CAMN	T4,[SIXBIT /VT61/] ;REALLY WANT A VT61?
	JRST	EVT61		;YES - MODIFY THE TERMINAL TABLE FOR IT
>
	JRST	PUTTYP		;OUTPUT EVERYTHING AND RETURN
>
IFN FVT52!FVT61!FVT100!FVT102!FVT125!FGIGI,<
;ROUTINE CALLED ON EXIT: RESTORE KEYPAD TO NON-APPLICATION MODE

XVT52:	MOVSI	T1,(BYTE (7) 33,76)	;OUTPUT ESCAPE CLOSE-ANGLE-BRACKET
	PUSHJ	P,PUTSQ1
	JRST	PUTTYP
>

IFN FVT61,<
;TERMINAL TABLES FOR THE VT61
;(USES THE SAME INPUT, OUTPUT TABLES AND POSITIONING ROUTINES AS THE VT52)

IFN FVT61,<
EVT61:	MOVE	T1,[BYTE (7) 33,"P","F"]
	MOVEM	T1,ILN(TM)	;INSERT LINE SEQUENCE
	MOVE	T1,[BYTE (7) 33,"P","D"]
	MOVEM	T1,DLN(TM)	;DELETE LINE SEQUENCE
	MOVE	T1,[BYTE (7) 33,"O","J"]
	MOVEM	T1,PON(TM)	;PROTECT ON SEQUENCE
	MOVE	T1,[BYTE (7) 33,"O","j"]
	MOVEM	T1,POF(TM)	;PROTECT OFF SEQUENCE
	MOVEI	T1,NVT61
	MOVEM	T1,ISP(TM)	;INSERT SPACE ROUTINE
	MOVE	T1,[BYTE (7) 33,"P","S"]
	MOVEM	T1,DSP(TM)	;DELETE SPACE SEQUENCE
	MOVEI	T1,MRK		;CLEAR THE USE-MARK FLAG
	ANDCAM	T1,TCH(TM)	;  SO THE CURSOR POSITION WILL BE HIGHLIGHTED
IFN FTIMD,<
	MOVE	T1,[BYTE (7) 33,"P","I"]
	MOVEM	T1,IMO(TM)	;SEQUENCE TO TURN INSERT MODE ON
	MOVE	T1,[BYTE (7) 33,"P","i"]
	MOVEM	T1,IMF(TM)	;AND TO TURN INSERT MODE OFF
>
	JRST	PUTTYP		;COMPLETE OUTPUT AND RETURN

;SUBROUTINE TO INSERT (T4) SPACES AT THE CURSOR
;need to start by clearing to end of line if line will wrap

NVT61:	MOVE	T1,[BYTE (7) 33,"P","I"]
	PUSHJ	P,PUTSQ1	;GET INTO INSERT MODE
	MOVEI	T1," "		;GET A SPACE
	IDPB	T1,TY		;OPEN ONE SPACE
	SOJG	T4,.-1		;LOOP THROUGH ALL SPACES
	MOVE	T1,[BYTE (7) 33,"P","i"]
	JRST	PUTSQ1		;EXIT INSERT MODE AND RETURN
>

IFN FVT100!FVT102!FVT125!FGIGI,<
;TERMINAL TABLES FOR THE DIGITAL VT100
;(ALSO USED FOR OTHER DIGITAL VT100-LIKE TERMINALS)
;NOTE: THE WRP FLAG SHOULD NOT BE SET WHETHER OR NOT THE VT100 HAS WRAPAROUND

FV100F==1		;FLAG: TURN ON IF TERMINAL SENDS XON-XOFF'S

OGIGI:
OVT102:
OVT125:
OVT100:	BYTE (7) 33,"[","A"	;CURSOR UP
	BYTE (7) 33,"[","B"	; DOWN
	BYTE (7) 33,"[","C"	; RIGHT
	BYTE (7) 33,"[","D"	; LEFT
	BYTE (7) 33,"[","H"	; HOME
	BYTE (7) 33,"[","J"	;CLEAR PAGE
	BYTE (7) 33,"[","K"	;CLEAR LINE
	BYTE (7) 33,"D"		;ROLL UP AND CLEAR LINE
	BYTE (7) 33,"M"		;ROLL DOWN AND CLEAR LINE
	BYTE (7) 33,"[","7","m"	;PROTECT ON
	BYTE (7) 33,"[","0","m"	;PROTECT OFF
	ILVT10			;INSERT LINE
	0			;INSERT SPACE (NONE)
	DLVT10			;DELETE LINE
	0			;DELETE SPACE (NONE)
	3777,,[BYTE (7) 33,"[","2","4",";","1","H"] ;MOVE TO BOTTOM
	HVT100			;HOME AND CLEAR PAGE
	CVT100			;ROUTINE TO POSITION TO CHARACTER
	LVT100			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FV100F,<
	SLW!TBS			;FLAGS (SLOW TTY,TTY WRAPS,HARDWARE TABS)
>
IFN FV100F,<
	NPG!SLW!TBS		;FLAGS (KEEP TTY PAGE AND ONES ABOVE)
>
	EVT100			;ROUTINE TO CALL ON ENTRY
	XVT52			;ROUTINE TO CALL ON EXIT
	0,,0			;NO NULLS NEEDED
	IVT100			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	GVT100			;LIMIT SCROLLING REGION
	3777,,[BYTE (7) 33,"[","0",";","2","4","r"] ;UN-LIMIT SCROLLING REGION
>>
IFN FTLSR,<
;SUBROUTINE TO LIMIT THE SCROLLING REGION TO T2,T3

GVT100:	PUSH	P,T3		;SAVE ENDING ROW
	PUSH	P,T2		;AND STARTING ROW
	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1	;START OFF THE SEQUENCE
	POP	P,T1		;GET STARTING ROW
	PUSHJ	P,PUTNUM	;OUTPUT IT
	MOVEI	T1,";"		;DELIMIT STARTING, ENDING ROWS
	IDPB	T1,TY
	POP	P,T1		;GET ENDING ROW
	PUSHJ	P,PUTNUM	;OUTPUT IT
	MOVEI	T1,"r"		;COMPLETE THE SEQUENCE
	IDPB	T1,TY
	POPJ	P,		;DONE
>
HVT100:	MOVEI	T1,[BYTE (7) 33,"[","H",33,"[" ;HOME AND CLEAR PAGE
		    BYTE (7) "J"]
	PUSHJ	P,PUTSTG
	PUSHJ	P,PUTTYP	;OUTPUT IT NOW
	MOVEI	T1,^D0100	;DELAY JUST A LITTLE
IFN TOPS10,<
	HIBER	T1,
	  JFCL
>
IFE TOPS10,<
	DISMS
>
	POPJ	P,		;THEN RETURN
>
IFN FVT100!FVT125!FGIGI,<
;INSERT (T4) LINES (USES LIMITED SCROLLING REGION)

ILVT10:	PUSHJ	P,SVT100	;SET UP THE SCROLLING REGION
	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1
	PUSHJ	P,GETROW	;GET THE CURRENT ROW IN T1
	PUSHJ	P,PUTNUM	;AND OUTPUT DECIMAL IN ASCII
	MOVE	T1,[BYTE (7) ";","0","H"]
	PUSHJ	P,PUTSQ1	;AND MAKE SURE WE ARE THERE
	PUSH	P,T4
ILVT1A:	MOVE	T1,[BYTE (7) 33,"M"]
	PUSHJ	P,PUTSQ1	;INSERT A LINE
	SOJG	T4,ILVT1A	;LOOP TO INSERT ALL THE LINES

	POP	P,T1		;GET NUMBER OF LINES INSERTED
	JUMPE	CM,RVT100	;DONE IF AT START OF LINE
	SOSG	T4,T1		;  OR IF ONLY ONE LINE
	JRST	RVT100
	PUSHJ	P,RVT100	;NOW RESTORE THE INITIAL STATE
ILVT1B:	MOVE	T1,[BYTE (7) 33,"[","B"]
	PUSHJ	P,PUTSQ1	;ELSE MOVE DOWN ONE LESS TIME THAN LINES
	SOJG	T4,ILVT1B	;LOOP TO INSERT ALL THE LINES
	POPJ	P,

;DELETE ONE LINE (USES LIMITED SCROLLING REGION)

DLVT10:	MOVE	T1,LPP(TM)	;ON ONE OF THE THE BOTTOM TWO LINES?
	CAIG	T1,2(RW)
;	CAIG	T1,1(RW)
	JRST	DLVT1S		;YES - HANDLE SPECIALLY
DLVT1A:	PUSHJ	P,SVT100	;ELSE SET UP THE SCROLLING REGION
;	MOVEI	T1,[BYTE (7) 33,"[","2","4",";"
;		    BYTE (7) "0","H",33,"D"]
;	PUSHJ	P,PUTSTG
;	PUSHJ	P,RVT100
;	JRST	PUTTYP		;OUTPUT AND RETURN

	MOVEI	T1,[BYTE (7) 33,"[","2","4",";"
		    BYTE (7) "0","H"]
	PUSHJ	P,PUTSTG
DLVT1B:	MOVE	T1,[BYTE (7) 33,"D"]
	PUSHJ	P,PUTSQ1	;DELETE A LINE
	SOJG	T2,DLVT1B	;LOOP TO DELETE ALL THE LINES
				;FALL INTO RVT100 AND RETURN

RVT100:	MOVEI	T1,[BYTE (7) 33,"[","0",";","2"
		    BYTE (7) "4","r",33,"8"]
	JRST	PUTSTG		;OUTPUT AND RETURN

;HERE IF THE CURSOR IS ON ONE OF THE BOTTOM TWO LINES. DO AS TWO SPECIAL CASES.

DLVT1S:	CAIE	T1,2(RW)	;ON THE BOTTOM LINE?
	JRST	DLVTS1		;YES - HANDLE SPECIALLY
	JUMPE	CM,DLVT1A	;JUMP IF AT START OF NEXT-TO-BOTTOM LINE
	MOVE	T1,[BYTE (7) 12,33,"[","K"]
	PUSHJ	P,PUTSQ1	;ELSE JUST CLEAR THE BOTTOM LINE
	MOVE	T1,CUP(TM)	;MOVE UP AGAIN, AND RETURN
	JRST	PUTSEQ

DLVTS1:	MOVE	T1,[BYTE (7) 33,"[","K"]
	JRST	PUTSQ1		;JUST CLEAR LINE OUT AND RETURN

;SET UP SCROLLING REGION FOR INSERT OR DELETE LINES

SVT100:	MOVE	T1,[BYTE (7) 33,"7",33,"["]
	PUSHJ	P,PUTSQ1
	PUSHJ	P,GETROW	;GET THE CURRENT ROW IN T1
	PUSHJ	P,PUTNUM	;OUTPUT DECIMAL NUMBER IN ASCII
	MOVE	T1,[BYTE (7) ";","2","4","r"]
	JRST	PUTSQ1
;	PUSHJ	P,PUTSQ1
;	PUSHJ	P,PUTTYP	;OUTPUT ALL THIS NOW AND RETURN
;	SNOOZE	500
;	POPJ	P,

GETROW:	MOVEI	T1,1(RW)	;GET THE CURRENT ROW
	ADD	T1,HOMPOS	;ADD WINDOW OFFSET, IF ANY
	JUMPE	CM,CPOPJ	;IS THE CURSOR AT THE START OF THE ROW?
	AOJA	T1,CPOPJ	;NO - START ONE ROW FARTHER DOWN AND RETURN
>
IFN FVT100!FVT102!FVT125!FGIGI,<
;TERMINAL INPUT TABLE - TELLS WHICH CHARACTER SEQUENCES
;INVOKE WHICH COMMANDS

IFE FV100F,<
	EXP	$RESET				;RUBOUT
IVT100:	EXP		$RECAL,	$INSSP,	$SETFI	;   0, A, B
	EXP	$ABORT,	$INSLN,	$SRCBK,	$DELLN	;C, D, E, F
	EXP	$PUT,	$DELCH,	$TAB,	$ERSLN	;G, H, I, J
	EXP	$SLDLF,	$SLDRT,	$RETRN,	$SWTCH	;K, L, M, N
	EXP	$ENTCC,	$GOTO,	$RLBKP,	$SRCFW	;O, P, Q, R
	EXP	$DELSP,	$RLFWL,	$BKTAB,	$PICK	;S, T, U, V
	EXP	$RLBKL,	$EXEC,	$RLFWP,	$EXIT	;W, X, Y, Z
		-SV10.S,,SV10.T			;ESCAPE
	EXP	$PUSH,	$JUSTI,	$SUBST,	$MARKR	;\, ], ^, _
>
IFN FV100F,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T

	EXP	$RESET				;RUBOUT
IVT100:	EXP		$RECAL,	$RLBKP,	$SETFI	;   0, A, B
	EXP	$ABORT,	$INSLN,	$SRCBK,	$DELLN	;C, D, E, F
	EXP	$PUT,	$DELCH,	$TAB,	$ERSLN	;G, H, I, J
	EXP	$INSSP,	$DELSP,	$RETRN,	$SWTCH	;K, L, M, N
	EXP	$ENTCC,	$GOTO,	0,	$SRCFW	;O, P, Q, R
	EXP	0,	$RLFWL,	$BKTAB,	$PICK	;S, T, U, V
	EXP	$RLBKL,	$EXEC,	$RLFWP,	$EXIT	;W, X, Y, Z
		-SV10.S,,SV10.T			;ESCAPE
	EXP	$PUSH,	$JUSTI,	$SUBST,	$MARKR	;\, ], ^, _
>
;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SV10.T:	VT100X,,"["	;ESCAPE [ == READ NEXT CHAR
	VT100S,,"O"	;ESCAPE O == READ NEXT CHAR
	$JUSTI,,"J" 	;ESCAPE J == JUSTIFY
	$JUSTI,,"j" 	;ESCAPE j == JUSTIFY
	$TBSET,,"S" 	;ESCAPE S == SET-TABS
	$TBSET,,"s" 	;ESCAPE s == SET-TABS
	$MARKR,,"M" 	;ESCAPE M == MARKER
	$MARKR,,"m" 	;ESCAPE m == MARKER
SV10.S==.-SV10.T

VT100X:	$CURUP,,"A"	;ESCAPE [ A == UP
	$CURDN,,"B"	;ESCAPE [ B == DOWN
	$CURRT,,"C"	;ESCAPE [ C == RIGHT
	$CURLF,,"D"	;ESCAPE [ D == LEFT
	0

VT100S:	$ENTER,,"P"	;ESCAPE O P == ENTER
	$CURHM,,"R"	;ESCAPE O R == HOME
	$RECAL,,"Q"	;ESCAPE O Q == RECALL
	$INMOD,,"M"	;ESCAPE O M == INSERT-MODE
	$SAVE,,"S"	;ESCAPE O S == SAVE-FILE

	$CURUP,,"A"	;ESCAPE O A == UP
	$CURDN,,"B"	;ESCAPE O B == DOWN
	$CURRT,,"C"	;ESCAPE O C == RIGHT
	$CURLF,,"D"	;ESCAPE O D == LEFT

	$BLINE,,"t"	;ESCAPE O t == START-OF-LINE
	$ELINE,,"v"	;ESCAPE O v == END-OF-LINE
	$DNTAB,,"r"	;ESCAPE O r == DOWN-TAB
	$UPTAB,,"x"	;ESCAPE O x == UP-TAB
	$ERSWD,,"n"	;ESCAPE O n == ERASE-WORD
	$RLTAB,,"p"	;ESCAPE O p == REAL-TAB
	$MARK,,"w"	;ESCAPE O w == MARK
	$CASE,,"y"	;ESCAPE O y == CASE
	$REWRT,,"u"	;ESCAPE O u == REWRITE SCREEN
	$WINDW,,"q"	;ESCAPE O q == WINDOW
	$SLDLF,,"m"	;ESCAPE O m == SLIDE-LEFT
	$SLDRT,,"l"	;ESCAPE O l == SLIDE-RIGHT
	$HELP,,"s"	;ESCAPE O s == HELP
	0

;MOVE TO ROW (RW), COLUMN (CM)

CVT100:	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,1(RW)	;GET ROW POSITION
	PUSHJ	P,PUTNUM
	MOVEI	T1,";"		;THEN A SEMICOLON
	IDPB	T1,TY
	MOVEI	T1,1(CM)	;GET COLUMN POSITION
	PUSHJ	P,PUTNUM
	MOVEI	T1,"H"		;THEN AN H
	IDPB	T1,TY
	POPJ	P,		;DONE

;MOVE TO START OF LINE (T4)

LVT100:	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1	;START IT OFF
	MOVEI	T1,1(T4)	;GET ROW POSITION
	PUSHJ	P,PUTNUM
	MOVE	T1,[ASCII /;0H/]
	JRST	PUTSQ1		;MOVE TO FIRST COLUMN; DONE

;ROUTINE CALLED ON VT100 ENTRY: SET UP KEYPAD IN APPLICATION MODE
;(NOTE: EXIT ROUTINE IS WITH VT52 CODE)

EVT100:
IFN ..IDX-1,<JRST DECIDE>	;IF MORE THAN ONE TERMINAL TYPE, FIND WHICH
	MOVE	T1,[BYTE (7) 33,"=",33,74]
	PUSHJ	P,PUTSQ1	;ASSUME VT52, SET VT100 (+ ALTERNATE KEYPAD)
IFN FVT102,<
	CAMN	T4,[SIXBIT /VT102/] ;REALLY WANT A VT102?
	JRST	EVT102		;YES - MODIFY THE TERMINAL TABLE FOR IT
>
IFN FGIGI,<
	CAMN	T4,[SIXBIT /GIGI/] ;REALLY WANT A GIGI?
	JRST	EGIGI		;YES - MODIFY THE TERMINAL TABLE FOR IT
>
	JRST	PUTTYP		;NO - LEAVE IT A VT100

IFN FGIGI,<
EGIGI:	SETZM	OVT100+ILN	;GIGI - CAN'T INSERT AND DELETE LINES
	SETZM	OVT100+DLN	;  SO SAY IT CAN'T BE DONE
	MOVE	T1,[3777,,[BYTE (7) 33,"[","3","1",";","4","4","m"]]
	MOVEM	T1,OVT100+PON	;CHANGE DISPLAY OF PROTECT-ON
	JRST	PUTTYP		;OUTPUT EVERYTHING AND RETURN
>>

IFN FVT102,<
;TERMINAL TABLES FOR THE VT102
;(USES THE SAME INPUT, OUTPUT TABLES AND POSITIONING ROUTINES AS THE VT100)

FV102F==1		;FLAG: TURN ON IF TERMINAL SENDS XON-XOFF'S

EVT102:
IFN FVT100!FVT125!FGIGI,<
	MOVEI	T1,LVT102
	MOVEM	T1,ILN(TM)	;INSERT LINE ROUTINE
	MOVEI	T1,DVT102
	MOVEM	T1,DLN(TM)	;DELETE LINE ROUTINE
>
	MOVEI	T1,NVT102
	MOVEM	T1,ISP(TM)	;INSERT SPACE ROUTINE
	MOVEI	T1,SVT102
	MOVEM	T1,DSP(TM)	;DELETE SPACE ROUTINE
IFN FTIMD,<
	MOVE	T1,[BYTE (7) 33,"[","4","h"]
	MOVEM	T1,IMO(TM)	;SEQUENCE TO TURN INSERT MODE ON
	MOVE	T1,[BYTE (7) 33,"[","4","l"]
	MOVEM	T1,IMF(TM)	;AND TO TURN INSERT MODE OFF
>
	JRST	PUTTYP		;COMPLETE OUTPUT AND RETURN

;SUBROUTINE TO INSERT A LINE AT THE CURSOR
;INSERTS (T4) LINES. ALSO MOVES THE CURSOR DOWN (T4)-1 LINES

IFE FVT100!FVT125!FGIGI,<
ILVT10:
>
LVT102:	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1	;INSERT ALL THE LINES AT ONCE
	MOVE	T1,T4
	PUSHJ	P,PUTNUM
	SOJLE	T4,LVT12A	;DONE IF ONLY ONE LINE
	MOVE	T1,[BYTE (7) "L",33,"["]
	PUSHJ	P,PUTSQ1	;ELSE MOVE THE CURSOR DOWN THAT MANY, TOO
	MOVE	T1,T4
	PUSHJ	P,PUTNUM
	MOVEI	T1,"B"
	TDZA	T4,T4		;CLEAR CALLER'S LOOP COUNT
LVT12A:	MOVEI	T1,"L"
	IDPB	T1,TY
	POPJ	P,

;SUBROUTINE TO DELETE (T2) LINES AT THE CURSOR

IFE FVT100!FVT125!FGIGI,<
DLVT10:
>
DVT102:	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1
	MOVE	T1,T2
	PUSHJ	P,PUTNUM
	MOVEI	T1,"M"
	IDPB	T1,TY
	SETZ	T2,		;CLEAR CALLER'S LOOP COUNT
	POPJ	P,

;SUBROUTINE TO INSERT (T4) SPACES AT THE CURSOR

NVT102:	MOVE	T1,[BYTE (7) 33,"[","4","h"]
	PUSHJ	P,PUTSQ1	;GET INTO INSERT MODE
	MOVEI	T1," "		;GET A SPACE
	IDPB	T1,TY		;OPEN ONE SPACE
	SOJG	T4,.-1		;LOOP THROUGH ALL SPACES
	MOVE	T1,[BYTE (7) 33,"[","4","l"]
	JRST	PUTSQ1		;EXIT INSERT MODE AND RETURN

;SUBROUTINE TO DELETE (T4) SPACES AT THE CURSOR

SVT102:	MOVSI	T1,(BYTE (7) 33,"[")
	PUSHJ	P,PUTSQ1
	MOVE	T1,T4
	PUSHJ	P,PUTNUM
	MOVEI	T1,"P"
	IDPB	T1,TY
	SETZ	T4,		;CLEAR CALLER'S LOOP COUNT
	POPJ	P,
>

IFN FVI200,<

OVI200:	XVI200

>

IFN FVIEWP,<
;DEFINITIONS FOR THE ADDS VIEWPOINT TERMINAL

FVIEWF==0	;SET THIS IF TERMINAL SENDS OUT XON-XOFF'S

;TERMINAL OUTPUT TABLE - SEQUENCES TO MAKE THE TERMINAL DO SPECIAL THINGS

OVIEWP:	BYTE (7) "Z"-100	;CURSOR UP
	BYTE (7) "J"-100	; DOWN
	BYTE (7) "F"-100	; RIGHT
	BYTE (7) "U"-100	; LEFT
	BYTE (7) 33,"Y"," "," "	; HOME
	BYTE (7) 33,"k"		;CLEAR TO END OF PAGE
	BYTE (7) 33,"K"		;CLEAR TO END OF LINE
	BYTE (7) 12		;ROLL UP AND CLEAR LINE
	BYTE (7) 0		;ROLL DOWN AND CLEAR LINE
	BYTE (7) "N"-100	;PROTECT ON (0 IF NONE)
	BYTE (7) "O"-100	;PROTECT OFF (0 IF NONE)
	BYTE (7) 0		;INSERT LINE (0 IF NONE)
	BYTE (7) 0		;INSERT SPACE (0 IF NONE)
	BYTE (7) 0		;DELETE LINE (0 IF NONE)
	BYTE (7) 0		;DELETE SPACE (0 IF NONE)
	BYTE (7) 1		;MOVE TO BOTTOM
	BYTE (7) 1,14		;HOME AND CLEAR ENTIRE PAGE
	CVIEWP			;ROUTINE TO POSITION TO CHARACTER
	LVIEWP			;ROUTINE TO POSITION TO START OF LINE
	^D24			;LINES PER PAGE
	^D80			;CHARACTERS PER LINE
IFE FVIEWF,<
	SLW!WRP			;TERMINAL-DEPENDENT FLAGS
>
IFN FVIEWF,<
	SLW!WRP!NPG		;TERMINAL-DEPENDENT FLAGS (KEEP TTY PAGE)
>
	EVIEWP			;ROUTINE TO CALL ON ENTRY
	CPOPJ			;ROUTINE TO CALL ON EXIT
	0,,0			;NUMBER OF NULLS TO OUTPUT,,NULL CHARACTER
	IVIEWP			;ADDRESS OF INPUT CHARACTER TABLE
IFN FTIMD,<
	0			;ENTER INSERT MODE
	0			;EXIT INSERT MODE
IFN FTLSR,<
	CPOPJ			;LIMIT SCROLLING REGION
	CPOPJ			;UNLIMIT SCROLLING REGION
>>

;TERMINAL INPUT TABLE - TELLS WHAT CONTROL CHARACTERS OR SEQUENCES
;INVOKE WHICH COMMANDS

IFE FVIEWF,<
	EXP	$RESET				;RUBOUT
IVIEWP:	EXP		$RECAL, $CURHM		;   0, A
	EXP	-SIZ.CB,,SUBCB			;B (NEEDS A SUBTABLE)
	EXP	$ABORT, $INSLN, $SRCBK, $CURRT	;C, D, E, F
	EXP	$PUT,   $DELCH, $TAB,   $CURDN	;G, H, I, J
	EXP	$TAB,   $BKTAB, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  $RLBKP, $SRCFW	;O, P, Q, R
	EXP	$DELSP, $RLFWL, $CURLF, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $RLFWP, $CURUP	;W, X, Y, Z
	EXP	-SVEW.S,,SVEW.T			;ESCAPE
	EXP	$MARK,  $CURRT, $PUSH,  $CURHM	;\, ], ^, _
>
IFN FVIEWF,<
;THIS TABLE SETS UP THE KEYBOARD ARRANGEMENT FOR WHEN YOU NEED TO KEEP
;TTY PAGE IN EFFECT BECAUSE THE TERMINAL SENDS OUT ITS OWN CONTROL S AND Q'S
;THOSE TWO CHARACTERS CANNOT BE COMMANDS SINCE SED DOES NOT KNOW WHETHER THE
;USER HAS TYPED THEM OR THEY WERE SENT BY THE TERMINAL.

;SO Q GOES TO A, A AND S GO TO K AND L, K TO ESCAPE-L, AND L TO ESCAPE-T

;NOTE: this table has not been altered for the Viewpoint.

	EXP	$RESET				;RUBOUT
IVIEWP:	EXP		$RECAL, $RLBKP, $SETFI	;   0, A, B
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
	EXP	$INSSP, $DELSP, $RETRN, $SWTCH	;K, L, M, N
	EXP	$ENTCC, $GOTO,  0,	$SRCFW	;O, P, Q, R
	EXP	0,	$RLFWL, $BKTAB, $PICK	;S, T, U, V
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		-SVEW.S,,SVEW.T			;ESCAPE
	EXP	$CURDN, $CURRT, $CURUP, $CURHM	;\, ], ^, _
>
;SUBTABLE FOR CONTROL-B (NORMAL AND SHIFTED F1, F2, F3)

SUBCB:	$ENTER,,"1"	;CONTROL-B 1 == ENTER
	$DELLN,,"2"	;CONTROL-B 2 == DELETE-LINES
	$BLINE,,"3"	;CONTROL-B 1 == BEGIN-LINE
	$RECAL,,"!"	;CONTROL-B ! == RECALL
	$ERSLN,,""""	;CONTROL-B " == ERASE-LINE
	$ELINE,,"#"	;CONTROL-B 1 == END-LINE
SIZ.CB==.-SUBCB

;SUBTABLE. PUT THE MOST FREQUENTLY-USED SEQUENCES FIRST
;ENTER IS PROBABLY THE MOST COMMON OF ALL

SVEW.T:	$SETFI,,"F" 	;ESCAPE F == SET-FILE
	$SAVE ,,"S" 	;ESCAPE S == SAVE-FILE
	$EXIT ,,"E" 	;ESCAPE E == EXIT
	$WINDW,,"W" 	;ESCAPE W == WINDOW
	$REWRT,,"X" 	;ESCAPE X == REWRITE
	$CASE ,,"C" 	;ESCAPE C == CASE
	$HELP ,,"H" 	;ESCAPE H == HELP
	$INSSP,,"I" 	;ESCAPE I == INSERT-SPACES
	$INMOD,,"M" 	;ESCAPE M == INSERT-MODE
	$SLDLF,,"L" 	;ESCAPE L == SLIDE-LEFT
	$SLDRT,,"R" 	;ESCAPE R == SLIDE-RIGHT
	$RLFWP,,"P" 	;ESCAPE P == ROLL-FORWARD-PAGES
	$RLTAB,,"T" 	;ESCAPE T == REAL-TAB
	$ENTER,,33 	;ESCAPE ESCAPE == ENTER

	$SETFI,,"f" 	;ESCAPE f == SET-FILE
	$SAVE ,,"s" 	;ESCAPE s == SAVE-FILE
	$EXIT ,,"e" 	;ESCAPE e == EXIT
	$WINDW,,"w" 	;ESCAPE w == WINDOW
	$REWRT,,"x" 	;ESCAPE x == REWRITE
	$CASE ,,"c" 	;ESCAPE c == CASE
	$HELP ,,"h" 	;ESCAPE h == HELP
	$INSSP,,"i" 	;ESCAPE i == INSERT-SPACES
	$INMOD,,"m" 	;ESCAPE m == INSERT-MODE
	$SLDLF,,"l" 	;ESCAPE l == SLIDE-LEFT
	$SLDRT,,"r" 	;ESCAPE r == SLIDE-RIGHT
	$RLFWP,,"p" 	;ESCAPE p == ROLL-FORWARD-PAGES
	$RLTAB,,"t" 	;ESCAPE t == REAL-TAB
IFN FVIEWF,<
			;IF TTY PAGE IS IN EFFECT,
			;DEFINE SEQUENCES FOR
			;<SLIDE-LEFT> AND <SLIDE-RIGHT> HERE
>
SVEW.S=.-SVEW.T

;VIEWPOINT SUBROUTINE TO EXECUTE ON ENTRY

EVIEWP:
IFN ..IDX-1,<JRST DECIDE>
	MOVE	T1,[BYTE (7) 33,"0","P",0]
	PUSHJ	P,PUTSQ1
	JRST	PUTTYP		;OUTPUT IT AND RETURN

;VIEWPOINT SUBROUTINE TO MOVE TO ROW, COLUMN [RW, CM]

CVIEWP:	MOVE	T1,[BYTE (7) 33,"Y",0]
	PUSHJ	P,PUTSQ1
	MOVEI	T1," "(RW)
	IDPB	T1,TY
	MOVEI	T1," "(CM)
	IDPB	T1,TY
	POPJ	P,

;VIEWPOINT SUBROUTINE TO MOVE TO THE START OF ROW (T4)

LVIEWP:	MOVE	T1,[BYTE (7) 33,"Y",0]
	PUSHJ	P,PUTSQ1
	MOVEI	T1," "(T4)
	IDPB	T1,TY
	MOVEI	T1," "
	IDPB	T1,TY
	POPJ	P,
>

	END

REPEAT 0,<
	EXP	$RESET				;RUBOUT
		0
IVT52:	EXP		$RECAL, $INSSP, $SETFI	;   0, A, B
			40	1	2
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
		3	4	5	6
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
		7	XX 	11	XX
	EXP	$SLDLF, $SLDRT, $RETRN, $SWTCH	;K, L, M, N
		13	14	15	16
	EXP	$ENTCC, $GOTO,  $RLBKP, $SRCFW	;O, P, Q, R
		17	20	21	22
	EXP	$DELSP, $RLFWL, $BKTAB, $PICK	;S, T, U, V
		23	24	25	26
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		27	30	31	32
	EXP	-SIZ.IS,,I.VT52			;ESCAPE
		33
	EXP	$PUSH,  $CURRT, $SUBST, $SAVE 	;\, ], ^, _


	EXP	$RESET				;RUBOUT
		0
IVT52:	EXP		$RECAL, $RLBKP, $SETFI	;   0, A, B
			40	21	2
	EXP	$ABORT, $INSLN, $SRCBK, $DELLN	;C, D, E, F
		3	4	5	6
	EXP	$PUT,   $DELCH, $TAB,   $ERSLN	;G, H, I, J
		7	XX	11	XX
	EXP	$INSSP, $DELSP, $RETRN, $SWTCH	;K, L, M, N
		1	23	15	16
	EXP	$ENTCC, $GOTO,  0,	$SRCFW	;O, P, Q, R
		17	20		22
	EXP	0,	$RLFWL, $BKTAB, $PICK	;S, T, U, V
		 	24	25	26
	EXP	$RLBKL, $EXEC,  $RLFWP, $EXIT	;W, X, Y, Z
		27	30	31	32
		-SIZ.IS,,I.VT52			;ESCAPE
		33
	EXP	$PUSH,  $CURRT, $SUBST, $SAVE 	;\, ], ^, _

>
 