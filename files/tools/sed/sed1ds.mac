TITLE	SED1DS - SCREEN DISPLAY, CONTROL, AND UPDATE ROUTINES
SUBTTL	A CHRISTOPHER HALL FECIT

	SEARCH	SEDSYM
	SALL

IFN TOPS10,<
	SEARCH	UUOSYM
	TWOSEG
	RELOC	400000
>
IFE TOPS10,<
	SEARCH	MONSYM
>

;THE ROUTINES BELOW DEAL WITH DISPLAYING PART OF THE BUFFER ON THE SCREEN
;JRST    DISDWN - FROM CURSOR POSITION TO END OF SCREEN
;JRST    DISALL - ENTIRE SCREEN
;PUSHJ P,DISPLL - ENTIRE SCREEN
;JRST    DISCUR - REPOSITION CURSOR
;PUSHJ P,DISLIN - POSITION, REMAINDER OF LINE
;PUSHJ P,DISONL - POSITION, ENTIRE LINE
;PUSHJ P,DISONE - ENTIRE LINE

;HERE TO DISPLAY FROM THE LINE THE CURSOR IS ON TO THE BOTTOM,
;POSITION THE CURSOR WHERE IT BELONGS, AND GO GET A NEW COMMAND

DISDWN::TRNE	F,XCT		;DOING AN EXECUTE?
	JRST	DISCUR		;YES - NO DISPLAY
	SKIPN	CPG(TM)		;IS THERE A SEQUENCE FOR CLEAR-TO-EOP?
	JRST	DISDWC		;NO - SEE IF CLEAR-TO-EOL'S WILL WORK
	MOVE	T4,RW		;YES - MOVE CURSOR TO START OF LINE
	PUSHJ	P,POSLIN
	PUSHJ	P,CLEARP	;CLEAR TO END OF PAGE
DISDW1:	MOVE	PT,LINPTR
	MOVE	T4,LPP(TM)	;FIND NUMBER OF LINES TO DISPLAY
	SUB	T4,RW
	TLNE	TM,WDW		;WINDOWING?
	PUSHJ	P,DISWDW	;YES - (MAYBE) ADJUST COUNT
	TLZ	F,FNC!FBL	;FENCE WILL BE RE-DRAWN; BOTTOM LINE O.K.
	PUSHJ	P,DISPLY	;RE-DISPLAY ALL LINES AFTER CURSOR POSITION
	TRNE	F,IMD		;IN INSERT MODE?
	PUSHJ	P,INSMSG	;YES - PUT UP INSERT MESSAGE
	JRST	DISCUR		;POSITION CURSOR AND LOOP

;HERE IF THERE'S NO CLEAR-TO-END-OF-SCREEN - USE C-EOL'S IF POSSIBLE

DISDWC:	SKIPN	CLN(TM)		;CAN THE TERMINAL CLEAR A LINE?
	JRST	DISALL		;NO - GO DISPLAY THE ENTIRE PAGE
	MOVE	T4,LPP(TM)	;YES - CLEAR EACH LINE SEPARATELY
	SUB	T4,RW		;FIND NUMBER OF LINES TO DISPLAY
	TLNE	TM,WDW		;WINDOWING?
	PUSHJ	P,DISWDW	;YES - (MAYBE) ADJUST COUNT
	MOVE	T3,T4
	MOVE	T4,RW
DISDCL:	PUSHJ	P,POSLIN	;MOVE TO THE START OF ANOTHER LINE
	PUSHJ	P,CLRLNA	;CLEAR IT OUT
	AOJ	T4,		;MOVE TO NEXT LINE
	SOJG	T3,DISDCL	;LOOP THROUGH ALL LINES
	MOVE	T4,RW		;MOVE CURSOR TO START OF THE FIRST LINE
	PUSHJ	P,POSLIN
	JRST	DISDW1		;RE-JOIN THE FLOW

;DISRES: ENTRY POINT FOR THE RE-DISPLAY SCREEN OPTION OF THE RESET COMMAND

DISRES::PUSHJ	P,RESTPM	;RESET ENTER MODE
	MOVEI	T1,77		;GET EXECUTE CODE FOR RESET
	TRNE	F,XSV		;SAVING IN AN EXECUTE BUFFER?
	DPB	T1,XCTPTW	;YES - OVERWRITE REAL CODE WITH EXECUTE CODE
DISALL::PUSHJ	P,DISPLL	;(ENTER HERE TO DISPLAY ALL AND LOOP)
DISCUR::PUSHJ	P,POSCUR	;RE-POSITION THE CURSOR AND RETURN
	JRST	LOOP		;AND GET ANOTHER COMMAND

;SUBROUTINE TO DISPLAY A SCREENFUL OF DATA, STARTING FROM DISPTR
;T1-T4 AND PT ARE FRAGGED

DISPLL::TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	PUSHJ	P,CLRALL	;GO HOME AND CLEAR THE SCREEN
	MOVE	PT,DISPTR	;GET POINTER TO START OF DISPLAY
	MOVE	T4,LPP(TM)	;SET TO DISPLAY THE ENTIRE SCREEN
	TLNE	TM,WDW		;WINDOWING?
	PUSHJ	P,DISWDW	;YES - (MAYBE) ADJUST COUNT
	PUSHJ	P,DISPS0	;DO THE DISPLAY
	MOVE	T1,DISPPT	;GET POINTER TO LAST LINE
	MOVEM	T1,BOTPTR	;SAVE AS BOTTOM POINTER
	TLNN	F,FNC		;IS THE FENCE ON THE SCREEN?
	TLZA	F,XPB		;NO - MARK BOTTOM POINTER AS GOOD
	TLO	F,XPB		;YES - BOTTOM POINTER IS BAD
	TLZ	F,FBL		;BUT BOTTOM LINE ITSELF IS O.K.
	TRNE	F,IMD		;IN INSERT MODE?
	JRST	INSMSG		;YES - PUT INSERT MESSAGE UP
	POPJ	P,		;NO - DONE

;SUBROUTINE IF WINDOWING - IF TOP WINDOW DISPLAY ONE FEWER LINE

DISWDW:	SKIPN	HOMPOS		;IN THE TOP WINDOW?
	SOJ	T4,		;YES - DISPLAY ONE FEWER LINE
	POPJ	P,

;SUBROUTINE TO DISPLAY ONE LINE, FROM CURSOR POSITION TO END
;CURSOR DOES NOT HAVE TO BE POSITIONED; CHRPTR MUST BE RIGHT

DISLIN::TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	PUSHJ	P,POSCUR	;MOVE CURSOR TO ITS RIGHTFUL POSITION
	SKIPN	CLN(TM)		;CAN TERMINAL CLEAR TO END OF LINE?
	JRST	[MOVEM TM,SAVEAC+4
		 TLZ   TM,TBS	;NO - MAKE TABS COME OUT AS SPACES
		 JRST  DISLN1]	;AND CLEAR LINE LATER
	PUSHJ	P,CLRLNR	;YES - LET IT DO SO
DISLN1:	MOVE	PT,CHRPTR	;SET TO WRITE ONE LINE WHERE CURSOR IS
	MOVEI	T4,1		;SAY ONE LINE WILL BE DISPLAYED

	MOVN	T2,CPL(TM)	;GET IOWD FOR CHARACTER COUNT:
	ADD	T2,CM		;  COUNT: CHARS REMAINING IN LINE
        TLNN	TM,WRP		;  WILL LINES WRAP AROUND?
	JRST	DISLN2		;  NO - NO EXTRA CHARACTER
	CAMGE	RW,LPP.1	;  YES - ON LAST LINE?
	SOJ	T2,		;  NO - DO ONE MORE CHARACTER
DISLN2:	HRLI	T2,-1(T2)
	HRR	T2,SL		;  OFFSET: SLIDE + CHARS NOT REMAINING
	ADD	T2,CM
	PUSHJ	P,DISPL0	;DISPLAY FROM CURSOR TO END OF LINE

DISCLR:	SKIPE	CLN(TM)		;COULD TERMINAL CLEAR TO END OF LINE?
	POPJ	P,		;YES - DONE
	MOVE	TM,SAVEAC+4	;NO - RESTORE CORRECT TBS FLAG
	HLRE	T0,T2		;GET ENDING POSITION IN LINE
	JUMPE	T0,CPOPJ	;NOTHING TO CLEAR IF LINE IS FULL
	ADD	T0,CPL(TM)
	SUBI	T0,2
	JRST	CLRLN0		;CLEAR REMAINDER OF LINE AND RETURN

;HERE TO DISPLAY ONE ENTIRE LINE POINTED TO BY (PT)
;IF CURSOR IS ALREADY POSITIONED ENTER AT DISONE

DISONL::TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	MOVE	T4,RW
	PUSHJ	P,POSLIN	;MOVE CURSOR TO START OF LINE
	MOVE	PT,LINPTR

DISONE::SKIPN	CLN(TM)		;CAN TERMINAL CLEAR TO END OF LINE?
	JRST	[MOVEM TM,SAVEAC+4
		 TLZ   TM,TBS	;NO - MAKE TABS COME OUT AS SPACES
		 JRST  DISON1]	;AND CLEAR LINE LATER
	PUSHJ	P,CLRLNA	;YES - LET IT CLEAR THE WHOLE LINE
DISON1:	MOVEI	T4,1		;DISPLAY ONE ENTIRE LINE
	PUSHJ	P,DISPLY	;DISPLAY THE LINE
	JRST	DISCLR		;CLEAR REST OF LINE AND RETURN

;SUBROUTINE TO DISPLAY (T4) LINES STARTING AT WHERE PT POINTS IN BUFFER
;CURSOR IS ASSUMED TO BE AT THE RIGHT POSITION
;T1-T4 AND PT ARE FRAGGED

DISPLY::TRNE	F,XCT		;DOING AN EXECUTE?
	POPJ	P,		;YES - NO DISPLAY
	TLZA	F,LFF
DISPS0::TLZ	F,FNC!LFF
	PUSHJ	P,DISSLD	;SKIP OVER, IF THERE'S A SLIDE
DISPL0:	MOVEI	T3,TYPBUF+TYPSIZ+1 ;SET UP END-OF-TYPE-BUFFER ADDRESS

;NOW COPY LINE INTO DISPLAY BUFFER

DISPL1:	CAMN	PT,EN		;AT END OF BUFFER?
	JRST	DISPEN		;YES - DISPLAY THE REST, THEN DONE
	ILDB	T1,PT		;GET A CHARACTER FROM THE FILE BUFFER
	JUMPE	T1,DISPL1	;IGNORE A NULL
	AOBJP	T2,DISSKP	;JUMP IF LINE HAS FILLED SCREEN
	TLZE	F,LFF		;LOOKING FOR A LINEFEED?
	JRST	DISPLF		;YES - SEE IF THIS IS ONE
DISPL2:	CAIN	T1,177		;GOT A RUBOUT CHARACTER?
	JRST	DISRUB		;YES - DISPLAY AS HIGHLIGHTED "?"
	CAIGE	T1," "		;SOME KIND OF CONTROL CHARACTER?
	JRST	DISCTL		;YES - HANDLE IT SEPARATELY
DISPL3:	IDPB	T1,TY		;STORE CHARACTER IN TYPE BUFFER

DISPL4:	CAIL	T3,(TY)		;IS BUFFER FILLED?
	JRST	DISPL1		;NO - LOOP
	PUSHJ	P,PUTTYP	;FINISH BUFFER AND OUTPUT IT
	JRST	DISPL1		;AND GET MORE OUTPUT

;HERE IF A FULL LINE OF CHARACTERS HAS BEEN FOUND; IGNORE REST OF LINE

DISSKP:	TLZE	F,LFF		;LOOKING FOR A LINEFEED?
	CAIE	T1,12		;YES - IS LAST CHARACTER A <LF>?
	CAIA			;NO - SKIP THIS
	JRST	DISPLF		;YES - END THE LINE NOW
	CAIE	T1,15		;USE THIS CHAR IF IT'S A <CR>
DISKP1:	ILDB	T1,PT		;IGNORE REST OF LINE
DISKP2:	CAIE	T1,15		;END OF LINE?
	JRST	DISKP1		;NO - IGNORE ANOTHER CHARACTER
	ILDB	T1,PT		;FOUND <CR> - GET <LF>
	CAIE	T1,12		;IS IT REALLY?
	JRST	DISKP2		;OF COURSE NOT - KEEP IGNORING
	TLNN	TM,WRP		;NEED A CARRIAGE RETURN AT END OF LONG LINE?
	JRST	DISPF1		;YES - FINISH LINE WITH CR
	SOJG	T4,DISPF2	;NO - WORKING ON LAST LINE?

;need to know if this is last line on screen or just last of display

	SETZ	T1,		;YES - OVERWRITE LAST CHAR WITH A NULL
	DPB	T1,TY
	JRST	PUTTYP		;FINISH THE DISPLAY AND RETURN

;HERE IF CHARACTER IS A RUBOUT - DISPLAY AS PROTECTED "?"

DISRUB:	MOVEI	T1,"?"-100	;GET THE QUESTION MARK
	PUSHJ	P,DISREV	;OUTPUT IT PROTECTED
	JRST	DISPL4		;AND CONTINUE

;HERE IF CHARACTER IS A CONTROL CHARACTER
;IF NOT <CR>, <LF>, OR <TB>, DISPLAY AS REVERSED-ASCII CHARACTER

DISCTL:	CAIN	T1,15		;JUST A <CR>?
	JRST	[TLO  F,LFF	;MAYBE - SET FLAG TO LOOK FOR <LF>
		 JRST DISPL4]	;AND CHECK NO FURTHER
	CAIN	T1,11		;TAB?
	JRST	DISTAB		;YES - TREAT SPECIALLY
	PUSHJ	P,DISREV	;ELSE OUTPUT REVERSED CHARACTER
	JRST	DISPL4

;HERE TO HANDLE A TAB - DE-BUMP POSITION BY SIZE OF TAB
;IF SLIDE IS A MULTIPLE OF 8, WORK WITH TAB; ELSE CONVERT TO SPACES

DISTAB:	TRNN	SL,7		;IS SLIDE A MULTIPLE OF 8?
	TLNN	TM,TBS		;  AND GOT HARDWARE TABS?
	JRST	DISTBX		;NEITHER - SIMULATE WITH SPACES
	TRNE	F,DTB		;BOTH - WANT TO DISPLAY TABS?
	JRST	DISTBA		;YES - GO DO IT
DISTB0:	TRNE	T2,7		;MOVE OVER TO TAB BOUNDARY
	AOBJN	T2,.-1
	JUMPL	T2,DISPL3	;GO SAVE TAB IF THERE'S ENOUGH ROOM
	JRST	DISSKP		;ELSE SKIP IT

DISTBA:
DISTBB:	PUSHJ	P,PROTON	;TURN PROTECTION ON
	MOVEI	T1,"T"		;MAKE FIRST CHAR OF TAB BE A "T"
	IDPB	T1,TY
	SKIPA	T1,["."]	;THEN USE PROTECTED DOTS FOR THE REST OF TAB
DSTBA1:	IDPB	T1,TY		;OUTPUT PROTECTED "."S
	TRNE	T2,7		;AT TAB BOUNDARY?
	AOBJN	T2,DSTBA1	;NO - KEEP GOING
	PUSHJ	P,PROTOF	;YES - TURN PROTECTION OFF
	JUMPGE	T2,DISSKP	;JUMP IF AT END OF LINE
	JRST	DISPL4		;ELSE CONTINUE

DISTBX:	TRNE	F,DTB		;WANT TO DISPLAY TABS?
	JRST	DISTBB		;YES - GO DO SO
DISTX1:	MOVEI	T1," "		;NO - SIMULATE TAB: GET A SPACE
	IDPB	T1,TY
	TRNE	T2,7		;SAVE UNTIL AT TAB BOUNDARY
	AOBJN	T2,.-2
	JRST	DISPL4

;SUBROUTINE TO OUTPUT THE CHARACTER IN T1 AS HIGHLIGHTED ASCII

DISREV:	PUSH	P,T1		;OUTPUT REVERSED CHARACTER
	PUSHJ	P,PROTON
	POP	P,T1		;RESTORE REVERSABLE CHARACTER
	ADDI	T1,"A"-1	;MAKE IT A CHARACTER
	IDPB	T1,TY
	PUSHJ	P,PROTOF
	CAIGE	T3,(TY)		;IS BUFFER FILLED?
	JRST	PUTTYP		;YES - FINISH BUFFER AND OUTPUT IT
	POPJ	P,		;NO - JUST RETURN

;HERE IF EOF REACHED BEFORE E.O. SCREEN. OUTPUT FENCE; DONE

	POP	P,		;(HERE FROM DISSLD)
DISPEN:	PUSHJ	P,PUTTYP	;FINISH BUFFER AND OUTPUT IT
	JRST	FIXBLW		;DISPLAY FENCE AND RETURN

;HERE IF EXPECTING A <LF> AFTER A <CR>. IF GOT ONE, COUNT AN END OF LINE

DISPLF:	CAIE	T1,12		;IS THIS CHARACTER A <LF>?
	JRST	DISPCR		;NO - REVERSE THE <CR> AND CONTINUE
DISPF1:	SOJLE	T4,[TLNE F,SCN	 ;COUNT ONE MORE LINE - SCANNING?
		    JRST DISTST	 ;YES - SEE IF USER WANTS TO STOP
		    JRST PUTTYP] ;NO - OUTPUT THE LAST BUFFER AND RETURN
IFN FTNIH,<
	MOVEI	T1," "		;END THE LINE WITH A SPACE
	TLNE	TM,WRP		;UNLESS DOING A SLIDE
	IDPB	T1,TY
>
	MOVEI	T1,15		;SAVE THE OLD <CR>
	IDPB	T1,TY
	PUSHJ	P,CDOWN		;MOVE TO NEXT LINE DOWN

DISPF2:	PUSHJ	P,DISTST	;SEE IF THE USER WANTS TO INTERRUPT
	CAMN	PT,EN		;AT END OF BUFFER?
	JRST	DISPEN		;YES - FINISH THE DISPLAY
	MOVEM	PT,DISPPT	;SAVE POINTER TO THE START OF THIS LINE
	PUSHJ	P,DISSLD	;SKIP OVER, IF THERE'S A SLIDE
	JRST	DISPL4		;AND CONTINUE

;HERE IF CHARACTER FOLLOWING <CR> IS NOT <LF> - MAKE <CR> REVERSED CTRL-M

DISPCR:	PUSH	P,T1		;SAVE CURRENT CHARACTER
	MOVEI	T1,15		;SET TO OUTPUT A REVERSED <CR>
	PUSHJ	P,DISREV
	POP	P,T1		;RESTORE CURRENT CHARACTER
	JRST	DISPL2

;HERE IF USER TYPED A CHARACTER DURING THE DISPLAY - STOP IT IF
;ENTER OR COMMAND, ELSE DRIVE ON
;TOPS20 NOTE: SIBE (GOTINP) FRAGS T2

DISTST:	TLNE	TM,TIM		;IS THE TERMINAL IN INSERT MODE?
	POPJ	P,		;YES - DON'T ALLOW IT TO BE INTERRUPTED
IFN TOPS10,<
	SNOOZE	30		;SLEEP FOR AN INSTANT
	MOVE	T1,[XWD 2,[EXP 2,-1]]
	TRMOP.	T1,		;SKIP IF OUTPUT IS COMPLETE - IS IT?
	  CAIA
	JRST	DISTST		;NO - KEEP WAITING
>
	GOTINP			;SKIP IF USER TYPED SOMETHING
	  POPJ	P,		;NO - CONTINUE
	TLOE	F,CWT		;SAY CHARACTER HAS BEEN READ - HAS ONE?
	POPJ	P,		;YES - JUST HAVE TO FORGET THIS ONE, THEN
	GETCHR			;READ A CHARACTER FROM THE TERMINAL IN T1
	TLZE	F,SCN		;SCANNING?
	JRST	[TLZ   F,CWT	;YES - NO WAITING COMMAND
		 MOVEI RW,^D12	;PUT CURSOR NEAR CENTER OF SCREEN
		 MOVEI CM,^D40
		 TLO   F,XPL!XPC ;LINE AND CHARACTER POINTERS ARE NO GOOD
		 POPJ  P,]	;AND QUIT
	MOVEM	T1,TYPCHR	;SAVE CHARACTER FOR LATER
	CAIL	T1,40		;CONTROL CHARACTER?
	POPJ	P,		;NO - JUST CONTINUE WITH THE DISPLAY
	MOVE	TY,TYPPTR	;YES - PURGE ANY UNSENT OUTPUT
	MOVE	P,[IOWD STKSIZ,STACK] ;CLEAN UP THE STACK
IFE TOPS10,<
IFN FTECHO,<
	MOVE	T1,TTYJFN	;CLEAR THE OUTPUT BUFFER
>
IFE FTECHO,<
	MOVEI	T1,.PRIOU
>
	CFOBF
>
	JRST	LOOP		;GET ANOTHER COMMAND

;SUBROUTINE TO SKIP OVER A SLIDE'S WORTH OF SPACES

DISSLD:	JUMPE	SL,DISSLE	;IF NO SLIDE, JUST SET UP SIZE
	MOVN	T2,SL		;ELSE SKIP THAT MANY REAL CHARACTERS
	HRLZ	T2,T2		;  GET AN IOWD FOR SLIDE SKIPPING
DISSL1:	ILDB	T1,PT		;GET A CHARACTER FROM THE FILE BUFFER
	CAMN	PT,EN		;AT END OF BUFFER?
	JRST	DISPEN-1	;YES - DISPLAY THE REST, THEN DONE
	JUMPE	T1,DISSL1	;IGNORE A NULL
	CAIN	T1,15		;IF <CR>, SEE IF END OF LINE
	JRST	[MOVE  T1,PT	;GET FRAGGABLE POINTER
		 ILDB  T1,T1	;GET LINEFEED
		 CAIE  T1,12	;IS IT REALLY?
		 JRST  DISSL2	;NO - SKIP THE <CR>
		 IBP   PT	;YES - SKIP <CRLF>
		 POP   P,	;KILL CALL TO DISSLD
		 MOVEI T3,TYPBUF+TYPSIZ+1 ;SET UP END-OF-TYPE-BUFFER ADDRESS
		 JRST  DISPLF]	;AND END THE LINE
	CAIN	T1,11		;TAB?
	JRST	DISSLT		;YES - COUNT IT
DISSL2:	AOBJN	T2,DISSL1	;GO UNTIL SKIPPED OUT
DISSLE:	MOVN	T2,CPL(TM)	;GET IOWD FOR CHARACTER COUNT
	HRLI	T2,-1(T2)
	HRR	T2,SL
	POPJ	P,		;THEN RETURN

DISSLT:	HRRZ	T1,T2		;HERE IF TAB - FIND ITS SIZE
	ANDI	T1,7
	SUBI	T1,10
	AOBJP	T2,DISLFP	;COUNT A SPACE; JUMP IF END OF SLIDE
	AOJL	T1,.-1		;LOOP THROUGH TAB
	JRST	DISSL1		;GET ANOTHER CHARACTER

DISLFP:	AOJE	T1,DISSLE	;IF EXACTLY COUNTED OUT, PUT NOTHING IN
	HRLZ	T1,T1		;GET IOWD FOR SPACES ADDED
	MOVEI	T2," "		;SLIDE ENDS IN MIDDLE OF TAB - PUT IN SPACES
	IDPB	T2,TY		;STORE CHARACTER IN TYPE BUFFER
	AOBJN	T1,.-1		;PUT IN ALL EXTRA SPACES
	HRLZ	T2,T1		;SET UP LENGTH OF REMAINDER OF LINE
	HRLZ	T0,CPL(TM)
	ADD	T0,[1,,0]
	SUB	T2,T0
	POPJ	P,		;THEN DONE

;************************************************************************
;ROUTINES TO UNDO THE DAMAGE CAUSED BY ENTER MODE, WHICH CAN BE:
;  1. REVERSED-SPACE AT CURSOR POSITION (COVER WITH CHARACTER FROM BUFFER)
;  2. ENTER LINE AT BOTTOM OF SCREEN (RE-WRITE WITH LINE FROM BUFFER)
;  3. ENTER FLAG (RESET IT)
;  4. CURSOR IS ILL-POSITIONED (RE-POSITION IT)

;THE ENTER FLAG MUST ALWAYS BE CLEARED. THE OTHER THINGS MAY NOT NEED TO
;BE UNDONE, DEPENDING ON HOW MUCH OF THE SCREEN HAS BEEN OVERWRITTEN.
;THUS THE ABOVE ARE HANDLED BY DIFFERENT SUBROUTINES, SO NO MORE WORK NEEDS
;TO BE DONE THAN NECESSARY.

;THE LINE AT THE BOTTOM MUST BE RE-DONE QUICKLY IF IT NEEDS TO BE DONE AT ALL
;THE TEXT MARK SHOULD ALSO BE DONE QUICKLY, SO CHRPTR MAY NOT NEED RE-MAKING
;CURSOR POSITIONING SHOULD BE THE LAST THING DONE BY THE COMMAND ROUTINE

;SUBROUTINE TO RESET ENTER MODE (NOTE: CAN'T FRAG T4)

RESTPM::TLZN	F,ENT		;WAS ENTER TYPED?
	POPJ	P,		;NO - NOTHING TO DO
	TRNE	F,XCT!XBN	;EXECUTING?
	JRST	ERSPM2		;YES - DON'T OUTPUT ANYTHING
	PUSH	P,T4		;ELSE SAVE OLD T4
	JRST	ERSPM1		;AND DE-BLIP THE BLIP

;SUBROUTINE TO WRITE LAST LINE OF SCREEN OVER ENTERED PARAMETER

ERASPM::TLZN	F,ENT		;WAS ENTER TYPED?
	POPJ	P,		;NO - NOTHING TO DO
	TRNE	F,XCT!XBN	;EXECUTING?
	JRST	ERSPM2		;YES - DON'T OUTPUT ANYTHING
ERSPM0::PUSH	P,T4		;SAVE OLD T4
	PUSHJ	P,FIXBLN	;RE-DO THE BOTTOM LINE
ERSPM1:	SKIPN	T1,CHRCUR	;GOT A BLIP TO DE-BLIP?
	JRST	ERSPM2-1	;NO - DON'T DE-BLIP IT, ALREADY
	CAIGE	T1," "		;IS CHARACTER A CONTROL CHARACTER?
	JRST	[TLNN  TM,MRK	;YES - GOT A MARK THERE?
		 JRST  ERSPM2-1	;NO - DON'T DE-BLIP IT
		 ADDI  T1,100	;YES - MAKE CHARACTER A REAL CHARACTER
		 MOVEM T1,CHRCUR
		 JRST  .+1]	;AND DRIVE ON
	PUSHJ	P,POSCUR	;ELSE POSITION THE CURSOR
IFN FTNIH,<
	PUSHJ	P,PROTOF	;UNPROTECT THE CHARACTER
>
IFE FTNIH,<
	MOVE	T1,CHRCUR
	IDPB	T1,TY		;PUT THE PROPER CHARACTER BACK THERE
	PUSHJ	P,CLEFT		;AND POSITION OVER THE CHARACTER
>
	POP	P,T4		;RESTORE THE T4 THAT WAS ENTERED WITH
ERSPM2::TRZN	F,CMV		;CLEAR CURSOR MOVEMENT FLAG - ON?
	POPJ	P,		;NO - RETURN
	CAME	RW,SAVPOS	;YES - WAS ROW CHANGED?
	TLO	F,XPL!XPC	;YES - POINTERS ARE NO GOOD
	MOVE	RW,SAVPOS	;RESTORE SAVED ROW POSITION
	CAMN	CM,SAVPOS+1	;WAS COLUMN CHANGED?
	JRST	PUTTYP		;NO - OUTPUT THE POSITIONING AND RETURN
	TLO	F,XPC		;YES - CURSOR POINTER IS NO GOOD
	MOVE	T1,SAVPOS+1	;SAVE CHANGE IN COLUMNS IN SAVEAC
	EXCH	T1,CM		;AND RESTORE SAVED COLUMN POSITION
	SUB	T1,CM
	MOVMM	T1,SAVEAC
	JRST	PUTTYP		;OUTPUT THE POSITIONING AND RETURN

;**********************************************************************
;SUBROUTINES TO FIX UP THE BOTTOM LINE OF THE SCREEN
;FIXBLC: CLEAR TO END OF SCREEN, THEN FIXBLN
;FIXBLN: IF NO SPECIAL MESSAGE, REWRITE BOTTOM LINE ONLY IF NEL IS NOT ON
;FIXBLF: DITTO, REWRITE BOTTOM LINE ALWAYS
;FIXBLW: WRITE SPECIAL MESSAGE, ELSE LEAVE BOTTOM LINE ALONE

FIXBLC::PUSHJ	P,CLEARP	;CLEAR TO END OF SCREEN

FIXBLN::TLNE	TM,NEL		;YES - CAN THE BOTTOM LINE REMAIN FRAGGED?
	TDZA	T1,T1		;YES - SET FLAG FOR LATER
FIXBLF::MOVEI	T1,1		;NO - SET TO REPAIR BOTTOM LINE ALWAYS
	TRNE	F,IMD		;IN INSERT MODE?
	TLNE	TM,BEP		;YES - BUT BEEPING?
	TLZA	F,FBL		;NOT INSERT, OR BEEPING - REPAIR BOTTOM LINE
	JRST	INSMSG		;INSERT, NOT BEEP - PUT UP INSERT MODE MESSAGE
	TLZE	F,XPB		;IS POINTER TO LAST LINE VALID?
	PUSHJ	P,MAKBPT	;NO - MAKE IT
	SKIPN	PT,BOTPTR	;IS THERE REALLY A BOTTOM LINE?
	JRST	FNCPUT		;NO - PUT UP THE FENCE AND RETURN
	JUMPE	T1,CBOTOM	;IF BOTTOM LINE CAN STAY FRAGGED JUST ERASE IT
	PUSHJ	P,CBOTOM	;NO - MOVE TO BOTTOM OF SCREEN
	JRST	DISONE		;RE-DO THE BOTTOM LINE AND RETURN

;SUBROUTINE TO PUT UP THE FENCE OR INSERT MODE MESSAGE,
;BUT NOT REPAIR THE BOTTOM LINE IF NO MESSAGE SHOULD BE DISPLAYED

FIXBLW::TRNE	F,IMD		;IN INSERT MODE?
	TLNE	TM,BEP		;YES - BUT BEEPING?
	TLZA	F,FBL		;NOT INSERT, OR BEEPING - REPAIR BOTTOM LINE
	JRST	INSMSG		;INSERT, NOT BEEP - PUT UP INSERT MODE MESSAGE
	TLZE	F,XPB		;IS POINTER TO LAST LINE VALID?
	PUSHJ	P,MAKBPT	;NO - MAKE IT
	SKIPE	PT,BOTPTR	;IS THERE REALLY A BOTTOM LINE?
	POPJ	P,		;YES - DO NOTHING
				;NO - FALL THROUGH TO DISPLAY THE FENCE

;SUBROUTINE TO OUTPUT THE FENCE

FNCPUT::MOVEI	T1,3(RW)	;GET ROW+3
	CAML	T1,LPP.1	;CLOSE TO THE BOTTOM OF THE SCREEN?
	JRST	CBOTOM		;YES - JUST CLEAR THE BOTTOM LINE
	MOVEI	T1,FENCE	;OUTPUT THE FENCE ON THE BOTTOM LINE
	PUSHJ	P,PUTBTM
	PUSHJ	P,PROTOF
	TLO	F,FNC		;SET FLAG TO SAY FENCE IS UP
	JRST	POSCUR		;RE-POSITION THE CURSOR; DONE

;SUBROUTINE TO OUTPUT INSERT MODE MESSAGE

INSMSG::TLNE	TM,BEP		;BEEPING?
	POPJ	P,		;YES - NO MESSAGE
	TLZE	F,XPB		;IS POINTER TO LAST LINE VALID?
	PUSHJ	P,MAKBPT	;NO - MAKE IT
	SKIPN	PT,BOTPTR	;IS THERE REALLY A BOTTOM LINE?
	SKIPA	T1,[[ASCIZ / *INSERT MODE ** FENCE* /]]
	SKIPA	T1,[[ASCIZ / *INSERT MODE* /]]
	TLOA	F,FNC		;NO - OUTPUT INSERT MODE AND FENCE
	TLZ	F,FNC		;YES - OUTPUT JUST INSERT MODE
	PUSHJ	P,PUTBTM
	PUSHJ	P,PROTOF
	TLO	F,FBL		;MARK BOTTOM LINE AS FRAGGED
	JRST	POSCUR		;REPOSITION THE CURSOR AND RETURN

;**********************************************************************
;SUBROUTINES TO POSITION THE CURSOR
;THESE JUST CALL THE ACTUAL POSITIONING ROUTINES IN THE TERMINAL-DEPENDENT
;CODE, OUTPUT IDLES AS DESIRED, AND TYPE OUT THE TYPE BUFFER

POSLIN::ADD	T4,HOMPOS	;MAKE POSITION RELATIVE TO HOME
	PUSHJ	P,@PSL(TM)	;POSITION TO THE RIGHT LINE
	SUB	T4,HOMPOS	;RESTORE PROPER POSITION
	JRST	POSEND		;GO FINISH OFF

POSCUR::ADD	RW,HOMPOS	;MAKE POSITION RELATIVE TO HOME
	PUSHJ	P,@PSC(TM)	;POSITION TO THE RIGHT CHARACTER
	SUB	RW,HOMPOS	;RESTORE PROPER POSITION
POSEND::TLNN	TM,NLP		;FOLLOW WITH SOME NULLS?
	JRST	PUTTYP		;NO - OUTPUT THE POSITIONING AND QUIT
	MOVE	T1,NUL(TM)	;YES - GET NULL CHARACTER
	HLRZ	T2,T1		;AND NUMBER OF NULLS TO OUTPUT
	IDPB	T1,TY		;OUTPUT A NULL
	SOJG	T2,.-1		;OUTPUT ALL THE NULLS, IN FACT
	JRST	PUTTYP		;THEN SEND IT ALL AND RETURN

;****************************************************************
;TERMINAL DEPENDENT OUTPUT SECTION
;STORE VARIOUS CHARACTER SEQUENCES IN THE TYPE BUFFER

CBOTOM::PUSHJ	P,CMVBTM	;MOVE TO BOTTOM LINE
				;AND FALL INTO CLEAR-IT CODE
CLRLNA::TDOA	T0,[-1]		;SET TO CLEAR ENTIRE LINE
CLRLNR::MOVE	T0,CM		;SET TO CLEAR TO END OF LINE
CLRLN0:	SKIPE	T1,CLN(TM)	;CAN TERMINAL CLEAR TO END OF LINE?
	JRST	PUTSEQ		;YES - GO DO IT
	PUSH	P,T2		;NO - DO IT IN SOFTWARE
	PUSH	P,T0		;SAVE SOME ACS
	CAIGE	T0,0		;IS T0/-1?
	SETZ	T0,		;YES - MAKE IT ZERO
	SUB	T0,CPL(TM)	;FIND NUMBER OF SPACES TO OUTPUT
	MOVNS	T0
	MOVEI	T1," "		;GET A SPACE
	MOVEI	T2,TYPBUF+TYPSIZ+1 ;SET UP END-OF-TYPE-BUFFER ADDRESS
	PUSHJ	P,CLRLN1	;SPACE OVER
	EXCH	CM,(P)
	JUMPL	CM,[MOVEI T1,15	;IF WANT A CR, GET ONE
		    IDPB  T1,TY	;OUTPUT IT AND OUTPUT THE BUFFER
		    PUSHJ P,PUTTYP
		    JRST  CLRLR1] ;SKIP THE REPOSITION AND CONTINUE
	PUSHJ	P,POSCUR	;RE-POSITION CURSOR
CLRLR1:	POP	P,CM		;GET REAL COLUMN BACK
	POP	P,T2		;RESTORE T2, TOO
	POPJ	P,

CLRLN1:	SUBI	T0,2
CLRLN2:	IDPB	T1,TY		;SPACE OVER
	CAMG	T2,(TY)		;IS TYPE BUFFER FULL?
	JRST	[PUSHJ P,PUTTYP	;YES - OUTPUT IT
		 MOVEI T1," "	;GET THE SPACE AGAIN
		 JRST  .+1]	;CONTINUE
	SOJG	T0,CLRLN2	;DO ALL THE SPACES
	POPJ	P,		;DONE

CHOME::	SKIPN	HOMPOS		;IS HOME REALLY HOME?
	SKIPA	T1,CHM(TM)	;YES - GET SEQUENCE FOR CURSOR HOME
	TDZA	T4,T4		;NO - POSITION TO THE FAKE HOME
	JRST	PUTSEQ
	JRST	POSLIN

CLRALL::TLNN	TM,WDW		;IN A WINDOW?
	SKIPA	T1,HCP(TM)	;NO - GO HOME AND CLEAR PAGE
	TDZA	T4,T4		;YES - POSITION TO THE FAKE HOME
	JRST	PUTSEQ
	PUSHJ	P,POSLIN	;POSITION HOME
	SKIPE	HOMPOS		;IN LOWER WINDOW?
	JRST	[SKIPE T1,CPG(TM) ;YES - CAN TERMINAL CLEAR TO EOP?
		 JRST  PUTSEQ	  ;YES - DO IT
		 JRST  CLRLL1]	  ;NO - CONTINUE
	MOVE	T4,LPP(TM)	;IN UPPER WINDOW - CLEAR ONE LINE FEWER
	SOJA	T4,CLRLL3

CLRLL1:	SKIPA	T4,LPP(TM)	;OUTPUT A BUNCH OF CLEAR-LINES
CLRLL2:	PUSHJ	P,CDOWN
CLRLL3:	PUSHJ	P,CLRLNA
	SOJG	T4,CLRLL2
	JRST	CHOME		;GO HOME, OUTPUT, AND RETURN

CLEARP::MOVE	T1,CPG(TM)	;CLEAR TO END OF PAGE
	JRST	PUTSEQ
IFN FTIMD,<
IMODON::MOVE	T1,IMO(TM)	;TURN INSERT MODE ON
	TLO	TM,TIM		;AND FLAG IT AS ON
	JRST	PUTSEQ

IMODOF::MOVE	T1,IMF(TM)	;TURN INSERT MODE OFF
	TLZ	TM,TIM		;AND FLAG IT AS OFF
	JRST	PUTSEQ

IMDOFN::MOVE	T1,IMF(TM)	;TURN INSERT MODE OFF NOW
	TLZ	TM,TIM		;AND FLAG IT AS OFF
	PUSHJ	P,PUTSEQ
	JRST	PUTTYP
>
IFN FTLSR,<
LIMSCR::SKIPA	T1,LSR(TM)	;SET TO LIMIT SCROLLING REGION TO (T2,T3)
ULMSCR::MOVE	T1,USR(TM)	;SET TO UNLIMIT SCROLLING REGION
	JRST	PUTSEQ
>
PROTON::SKIPN	T1,PON(TM)	;CAN PROTECTION BE TURNED ON?
	POPJ	P,		;NO - NOTHING TO DO
	JRST	PUTSEQ		;YES - DO IT
PROTOF::SKIPN	T1,POF(TM)	;CAN PROTECTION BE TURNED OFF?
	POPJ	P,		;NO - NOTHING TO DO
	JRST	PUTSEQ		;YES - DO IT
CMVBTM::MOVE	T1,MVB(TM)	;CURSOR TO BOTTOM
	JRST	PUTSEQ
CRIGHT::SKIPA	T1,CRG(TM)	;CURSOR RIGHT
CLEFT::	MOVE	T1,CLF(TM)	;CURSOR LEFT
	JRST	PUTSEQ
CURUP::	SKIPA	T1,CUP(TM)	;CURSOR UP
CDOWN::	MOVE	T1,CDN(TM)	;CURSOR DOWN
	JRST	PUTSEQ
ROLLUP::SKIPA	T1,RUP(TM)	;ROLL UP AND CLEAR LINE
ROLLDN::MOVE	T1,RLD(TM)	;ROLL DOWN AND CLEAR LINE

;SUBROUTINE TO OUTPUT UP TO 5 CHARACTERS IN T1 (PUTSQ1)

PUTSEQ::TLNN	T1,777777	;GOT A ROUTINE ADDRESS?
	JRST	@T1		;YES - DISPATCH TO THAT ROUTINE
	TLNN	T1,774000	;GOT THE ADDRESS OF A LONG ASCII STRING?
	JRST	PUTSTG		;YES - GO OUTPUT THE STRING
PUTSQ1::
IFE TOPS10,<
IFN FTECHO,<
	SETZ	T0,
>>
	LSHC	T0,7		;SHIFT IN A CHARACTER
	IDPB	T0,TY		;SAVE IT IN TYPE BUFFER
	JUMPN	T1,PUTSQ1	;LOOP THROUGH ALL CHARACTERS
	POPJ	P,		;THEN DONE

;SUBROUTINE TO MOVE TO BOTTOM, CLEAR, PROTECT, AND OUTPUT (T1)

PUTBTM::MOVEM	T1,SAVEAC+12	;SAVE MESSAGE ADDRESS
	PUSHJ	P,CBOTOM	;PUT MESSAGE ON BOTTOM LINE
	PUSHJ	P,PROTON	;PROTECT
	MOVE	T1,SAVEAC+12	;GET ADDRESS BACK AND FALL INTO PUTSTG

;SUBROUTINE TO OUTPUT A STRING. ADDRESS IN T1 (FRAGGED)

PUTSTG::HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PUTSG1:	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	IDPB	T0,TY		;ELSE SAVE IN TYPE BUFFER
	JRST	PUTSG1		;AND LOOP

;SUBROUTINE TO OUTPUT A STRING. ADDRESS IN T1 (FRAGGED). USES T0, T2
;SAME AS PUTSTG, BUT CONTROL CHARACTERS ARE SIMULATED BY BEING PROTECTED
;IF STRING BEING OUTPUT IS ALREADY PROTECTED ENTER PUTSTC; ELSE PUTSTS

PUTSTS::TDZA	T2,T2		;CLEAR FLAG TO GET SIMULATION
PUTSTC::SETO	T2,		;SET FLAG SO NO SIMULATION
	HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PUTSC1:	ILDB	T0,T1		;GET A CHARACTER
	CAIN	T0,177		;GOT A DELIMITER?
	JRST	PUTSCD		;YES - SIMULATE IT
	CAIGE	T0,40		;GOT A CONTROL CHARACTER?
	JRST	PUTSC2		;YES - SIMULATE IT
	IDPB	T0,TY		;SAVE CHARACTER IN TYPE BUFFER
	JRST	PUTSC1		;AND LOOP

PUTSCD:	MOVEI	T0,76-100	;MAKE 177 COME OUT AS PROTECTED WEDGE
PUTSC2:	JUMPE	T0,CPOPJ	;DONE, IF NULL
	PUSH	P,T1		;ELSE SAVE CHARACTER
	PUSH	P,T0
	CAIN	T2,0		;WANT TO PROTECT?
	PUSHJ	P,PROTON	;YES - DO SO
	POP	P,T0
	ADDI	T0,100		;OUTPUT PRINTING CHARACTER
	IDPB	T0,TY
	CAIN	T2,0		;WANT TO PROTECT?
	PUSHJ	P,PROTOF	;YES - DO SO
	POP	P,T1
	JRST	PUTSC1		;CONTINUE

;SUBROUTINE TO OUTPUT AN ERROR MESSAGE (ADDRESS IN T1, FRAGGED)
;SAME AS PUTSTG, BUT #'S ARE CONVERTED TO SPACES

PUTSTX::HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PTSTX1:	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	CAIN	T0,"#"		;ELSE GOT AN ARTIFICIAL SPACE?
	MOVEI	T0," "		;YES - MAKE IT A REAL ONE
	IDPB	T0,TY		;SAVE IN TYPE BUFFER
	JRST	PTSTX1		;AND LOOP

;SUBROUTINE TO OUTPUT FILESPECS (FOR THE SWITCH COMMAND)
;SAME AS PUTSTG, BUT OUTPUTS ONLY UNTIL FIRST "/"

PUTSTF::HRLI	T1,440700	;MAKE ADDRESS A BYTE POINTER
PTSTF1:	ILDB	T0,T1		;GET A CHARACTER
	JUMPE	T0,CPOPJ	;DONE IF NULL
	CAIN	T0,"/"		;ELSE GOT START OF SWITCHES?
	POPJ	P,		;YES - DONE
	IDPB	T0,TY		;SAVE IN TYPE BUFFER
	JRST	PTSTF1		;AND LOOP

;SUBROUTINE TO OUTPUT THE TYPE BUFFER

IFN FTNIHO,<
PUTTYH::PUSH	P,T0
	PUSH	P,T2
	JRST	PUTTY0

PUTONE::IDPB	T1,TY
>
PUTTYP::TRNE	F,XCT		;EXECUTING?
	JRST	PUTTY2		;YES - THROW BUFFER AWAY
	CAMN	TY,TYPPTR
	POPJ	P,		;DO NOTHING IF NOTHING TO OUTPUT
PUTTYF::SETZ	T1,		;ELSE OUTPUT TYPE BUFFER:
	IDPB	T1,TY		;  END IT WITH A NULL
IFN FTNIHO,<
        PUSH    P,T0
        PUSH    P,T2
	MOVE	T0,[POINT 7,TYPBUF]
PUTTY0:	ILDB	T1,T0
	JUMPE	T1,PUTTY1
	MOVE	T2,T1
	ANDI	T2,3
	ASH	T1,-2
	LDB	T1,PARPTX(T2)
	IONEOU	T1		;GAWDAWFUL, AIN'T IT?
	JRST	PUTTY0
>
IFN TOPS10,<
	OUTSTR	TYPBUF		;OUTPUT THE BUFFER
>
IFE TOPS10,<
IFN FTECHO,<
	PUSH	P,T2
	PUSH	P,T3
	MOVE	T1,TTYJFN
	MOVE	T2,TYPPTR
	SETZ	T3,
	SOUT
	POP	P,T3
	POP	P,T2
>
IFE FTECHO,<
	HRROI	T1,TYPBUF
	PSOUT			;OUTPUT THE BUFFER
>>
PUTTY1:
IFN FTNIHO,<
	POP     P,T2
        POP     P,T0
>
PUTTY2:	MOVE	TY,TYPPTR
	POPJ	P,		;RESTORE TYPE POINTER AND RETURN

;TABLE OF CHARACTERS WITH PARITY ATTACHED. PICKS UP PARTBL[T2,T1]

IFN FTNIHO,<
PARPTX:	POINT	9,PARTBL(T1),8
	POINT	9,PARTBL(T1),17
	POINT	9,PARTBL(T1),26
	POINT	9,PARTBL(T1),35

PARTBL:	BYTE (9) 000,201,202,003
	BYTE (9) 204,005,006,207
	BYTE (9) 210,011,012,213
	BYTE (9) 014,215,216,017
	BYTE (9) 220,021,022,223
	BYTE (9) 024,225,226,027
	BYTE (9) 030,231,232,033
	BYTE (9) 234,035,036,237
	BYTE (9) 240,041,042,243
	BYTE (9) 044,245,246,047
	BYTE (9) 050,251,252,053
	BYTE (9) 254,055,056,257
	BYTE (9) 060,261,262,063
	BYTE (9) 264,065,066,267
	BYTE (9) 270,071,072,273
	BYTE (9) 074,275,276,077
	BYTE (9) 300,101,102,303
	BYTE (9) 104,305,306,107
	BYTE (9) 110,311,312,113
	BYTE (9) 314,115,116,317
	BYTE (9) 120,321,322,123
	BYTE (9) 324,125,126,327
	BYTE (9) 330,131,132,333
	BYTE (9) 134,335,336,137
	BYTE (9) 140,341,342,143
	BYTE (9) 344,145,146,347
	BYTE (9) 350,151,152,353
	BYTE (9) 154,355,356,157
	BYTE (9) 360,161,162,363
	BYTE (9) 164,365,366,167
	BYTE (9) 170,371,372,173
	BYTE (9) 374,175,176,377
>
;SUBROUTINE TO OUTPUT A DECIMAL NUMBER
;ENTER WITH NUMBER IN T1; USES T0, T1

PUTNPO::AOJ	T1,		;OUTPUT (T1) + 1
PUTNUM::MOVE	T0,T1		;SET TO USE T0 AND T1
PTNUM1:	IDIVI	T0,^D10		;GET A DIGIT IN T2
	HRLM	T1,(P)		;SAVE IT ON THE STACK
	CAIE	T0,0		;IF ZERO, START POPPING
	PUSHJ	P,PTNUM1	;ELSE CALL RECURSIVELY
	HLRZ	T1,(P)		;GET A DIGIT OFF THE STACK
	ADDI	T1,"0"		;CONVERT TO ASCII
	IDPB	T1,TY		;PUT IT IN THE TYPE BUFFER
	POPJ	P,		;RETURN RECURSIVELY AND FINALLY

	END
   