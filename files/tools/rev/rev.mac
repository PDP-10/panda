; UPD ID= 23, SNARK:<6.TOOLS-TAPE>REV.MAC.2,  18-Jul-83 14:11:12 by JCAMPBELL
	TITLE	REV	FILE REVIEWER
	SUBTTL	DEFINITIONS



;THIS PROGRAM ALLOWS THE USER TO SCAN SELECTED FILES ONE BY ONE,
;AND INDIVIDUALLY PROCESS COMMANDS FOR EACH.  EXAMPLES OF THINGS
;THAT CAN BE DONE ARE DELETE, RENAME, COPY, PRINT, TYPE, READ
;PARAMETERS, AND SET PARAMETERS OF A FILE.  THIS IS MUCH EASIER
;THAN DOING THINGS LIKE TYPE, DIRECT, DELETE, OVER AND OVER.



	SEARCH	MACSYM,MONSYM	;NEEDED DEFINITIONS
	SALL




;VERSION INFORMATION:

	VMAJOR==4	;MAJOR VERSION
	VMINOR==0	;MINOR VERSION
	VEDIT==175	;EDIT NUMBER
	VWHO==1		;WHO EDITED LAST




;ACCUMULATORS:


	F=0		;FLAGS
	T1=1		;TEMP AC'S
	T2=2
	T3=3
	T4=4
	T5=5
	I=6		;INDEX FOR TYPEOUT LOOP
	ZZ=7		;CONTAINS ZERO
	P=17		;STACK

;MACROS:


	DEFINE	ND(SYM,VAL),<
	IFNDEF	SYM,<SYM==VAL>
>




	DEFINE	TEXT(STRING),<
	XLIST
	ASCIZ	@STRING@
	LIST
>




	DEFINE	AA(SWITCH,ADDR,BITS),<
IFB	<BITS>,<
	XWD	[ASCIZ/SWITCH/],ADDR
>
IFNB	<BITS>,<
	XWD	[EXP	CM%FW!<BITS>
		 ASCIZ/SWITCH/],ADDR
>
>




	DEFINE	ILLARG(TEXT),<
	JRST	[HRROI	T1,[ASCIZ/
? TEXT

/]
		 JRST	ERRPRT]
>

;FLAGS ARE DIVIDED INTO TWO KINDS.  IN THE LEFT HALF OF AC F ARE
;PAIRS OF FLAGS DETERMINING WHICH KINDS OF FILES ARE TO BE REVIEWED.
;EACH PAIR DIVIDES ALL FILES INTO TWO DISJOINT SETS.
;THE RIGHT HALF FLAGS ARE NORMAL PROGRAM FLAGS.


	FR.ADV==1	;WE HAVE ADVANCED GJFN EARLY
	FR.OPN==2	;FILE CURRENTLY WORKING ON IS OPENED
	FR.MAP==4	;FILE CURRENTLY WORKING ON IS MAPPED IN CORE
	FR.QIT==10	;THE QUIT COMMAND HAS BEEN GIVEN
	FR.AGN==20	;CURRENT FILE IS TO BE PROCESSED AGAIN
	FR.NXD==40	;USER WANTS TO GO TO NEXT DIRECTORY
	FR.NXS==100	;USER WANTS TO GO TO NEXT STRUCTURE
	FR.NXT==200	;USER WANTS TO GO TO NEXT FILE TYPE
	FR.NXF==400	;USER WANTS TO GO TO NEXT FILE NAME
	FR.OP2==1000	;OUTPUT FILE HAS BEEN OPENED
	FR.FBA==2000	;ALL OF THE FDB IS TO BE TYPED
	FR.HDR==4000	;HEADER LINE IS NEEDED FOR NEXT SPEC
	FR.FOL==10000	;WANT TO FOLLOW PROGRESS OF A FILE
	FR.TMP==20000	;TEMPORARY USE


	FL.DUD==1B0	;DISALLOW UNDELETED FILES
	FL.DDL==1B1	;DISALLOW DELETED FILES

	FL.DVS==1B2	;DISALLOW VISIBLE FILES
	FL.DIV==1B3	;DISALLOW INVISIBLE FILES

	FL.DON==1B4	;DISALLOW ONLINE FILES
	FL.DOF==1B5	;DISALLOW OFFLINE FILES


	FL.DAL==FL.DUD+FL.DDL+FL.DVS+FL.DIV+FL.DON+FL.DOF	;ALL KINDS
	FL.DIN==FL.DDL+FL.DIV	;DEFAULT KINDS OF FILES TO DISALLOW




;DEFAULT PARAMETERS:


	ND	PDLLEN,100	;SIZE OF PUSH-DOWN STACK
	ND	PAGSIZ,1000	;SIZE OF A PAGE
	ND	TXTLEN,^D200	;SIZE OF TEXT BUFFERS FOR COMMANDS
	ND	INTCHN,0	;CHANNEL TO USE FOR ^E INTERRUPT
	ND	MAXUP,^D101	;NUMBER OF FILES WE CAN BACK UP
	ND	SPECSZ,^D50	;WORDS NEEDED TO HOLD A FILE SPEC
	ND	ERRSIZ,^D10	;SIZE OF ERROR STAKING AREA
	ND	FOLSLP,^D5000	;SLEEP TIME WHEN FOLLOWING A FILE




;OPDEFS:


	OPDEF	CALL	[PUSHJ P,]	;SUBROUTINE CALL
	OPDEF	RET	[POPJ P,]	;RETURN
	OPDEF	RETSKP	[JRST CPOPJ1]	;SKIP RETURN

	SUBTTL	INITIALIZATION



ENTRY:	JRST	REV		;ENTRY VECTOR
	JRST	REV		;REENTER ADDRESS
	BYTE	(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT	;VERSION



REV:	RESET			;RESET EVERYTHING
	MOVE	P,[IOWD	PDLLEN,PDL]	;INITIALIZE STACK
	SETZB	ZZ,GJFN		;AND AC AND MAIN JFN
	SETZM	JFN		;CLEAR ANOTHER JFN
	SETZM	JFNOUT		;CLEAR OUTPUT JFN
	SETZM	INIJFN		;CLEAR INITIAL SPEC JFN
	MOVX	F,FL.DIN	;GET INITIAL FILES TO IGNORE
	MOVEI	T1,ERRBUF	;GET ADDRESS OF SAVING AREA
	MOVEM	T1,ERRPTR	;INITIALIZE POINTER INTO AREA
	MOVEI	T1,MONRET	;GET ADDRESS TO GO TO ON BIG ERROR
	CALL	ERRSET		;SET IT UP IN CASE IT HAPPENS
	MOVEI	T1,.FHSLF	;GET READY
	RPCAP			;READ MY CAPABILITIES
	TXO	T3,SC%CTC	;SET MY CAPABILITY FOR CONTROL-C'S
 	EPCAP			;ENABLE IT
	 ERJMP	.+1		;IGNORE ERROR
	MOVEI	T1,.FHSLF	;GET MY PROCESS
	MOVE	T2,[LEVTAB,,CHNTAB]	;POINT TO INTERRUPT TABLES
	SIR			;TELL MONITOR WHERE THEY ARE
	 ERJMP	ERRSTR		;SHOULDN'T FAIL
	MOVEI	T1,.FHSLF	;GET READY
	MOVX	T2,1B<INTCHN>	;GET BIT FOR CHANNEL
	AIC			;ACTIVATE THE CHANNEL
	 ERJMP	ERRSTR		;LOSE
	MOVEI	T1,.FHSLF	;ONE MORE TIME
	EIR			;ENABLE INTERRUPTS
	 ERJMP	ERRSTR		;CAN'T
	MOVEI	T1,LAST+PAGSIZ-1	;GET LAST ADDRESS NEEDED FOR PMAP
	IDIVI	T1,PAGSIZ	;PUT FIRST ADDRESS IN PAGE BOUNDARY
	MOVEM	T1,PAGNUM	;SAVE PAGE NUMBER WE WILL USE
	IMULI	T1,PAGSIZ	;TURN INTO ADDRESS
	MOVEM	T1,PAGADR	;SAVE ADDRESS OF PAGE ALSO
	ADDI	T1,PAGSIZ	;INCREMENT TO NEXT PAGE
	MOVEM	T1,PAGAD2	;SAVE AS ADDRESS OF SECOND PAGE
	IDIVI	T1,PAGSIZ	;GET PAGE NUMBER OF SECOND PAGE
	MOVEM	T1,PAGNU2	;SAVE IT TOO
	SETZ	T1,		;GET READY
	RSCAN			;SEE IF THERE IS ANY INPUT FOR US
	 ERJMP	ERRSTR		;FAILURE, COMPLAIN
	JUMPE	T1,NEWCMD	;NO, JUST GO GET A COMMAND

;HERE IF THERE IS SOMETHING TO BE RESCANNED IN THE RESCAN BUFFER.
;IT MIGHT HAVE A FILE SPEC FOLLOWING OUR PROGRAM NAME.  IF SO,
;WE WANT TO DEFAULT TO THE "REVIEW" COMMAND.  ANY ERROR HERE IS NOT
;FATAL, SINCE WE DON'T KNOW IF THE TYPE-IN IS REASONABLE OR NOT.



	MOVEI	T1,CMDBLK	;POINT TO COMMAND BLOCK
	HRROI	T2,ZZ		;GET A POINTER TO A NULL STRING
	MOVEM	T2,CMDBLK+.CMRTY	;SAVE AS CONTROL-R POINTER
	MOVEI	T2,JFNBLK	;GET ADDRESS OF JFN BLOCK
	MOVEM	T2,CMDBLK+.CMGJB	;AND SET IN COMMAND BLOCK
	MOVX	T2,GJ%OFG	;GET FLAGS
	MOVEM	T2,JFNBLK	;SET UP GTJFN BLOCK
	MOVEI	T2,[FLDDB. (.CMINI)]	;GET SET
	CALL	COMMND		;INITIALIZE COMMAND
	MOVEI	T2,[FLDDB. (.CMFIL)]	;WANT TO READ A FILE SPEC
	COMND			;DO IT
	 ERJMP	EATLIN		;FAILED, JUST GO EAT LINE
	TXNE	T1,CM%NOP	;DIDN'T PARSE?
	JRST	EATLIN		;YES, GO EAT LINE
	HRROI	T1,SPECS	;POINT TO STORAGE
	MOVX	T3,FLD (.JSAOF,JS%NAM)	;SET UP TO STORE ONLY NAME
	JFNS			;DO IT
	 ERJMP	EATLIN		;FAILED
	IDPB	ZZ,T1		;MAKE IT ASCIZ
	MOVE	T1,T2		;GET JFN
	RLJFN			;RELEASE IT
	 ERJMP	EATLIN		;FAILED
	GETNM			;NOW GET OUR USER NAME
	 ERJMP	EATLIN		;FAILED
	MOVE	T3,[POINT 7,SPECS]	;POINT TO STRING

CMPLOP:	ILDB	T4,T3		;GET NEXT CHAR OF FILE NAME
	JUMPE	T4,CMPFIN	;DONE IF GET A NULL
	SETZ	T2,		;CLEAR AC
	ROTC	T1,6		;SHIFT IN NEXT CHAR OF OUR NAME
	CAIE	T4," "(T2)	;CHARACTERS MATCH EACH OTHER?
	JRST	EATLIN		;NO, THEN CAN'T BE WANTED COMMAND LINE
	JRST	CMPLOP		;LOOP

CMPFIN:	JUMPE	T1,GETSPC	;JUMP IF GOT MATCH WITH OUR NAME
				;OTHERWISE EAT LINE

;HERE WHEN WE HAVE FOUND SOMETHING IN THE RESCAN BUFFER, BUT IT
;DID NOT LOOK LIKE OUR PROGRAM NAME.  WE HAVE TO EAT UP THE REST
;OF THE LINE, AND THEN GET A NORMAL COMMAND.


EATLIN:	MOVEI	T1,CMDBLK	;SET UP TO THE COMMAND BLOCK
	MOVEI	T2,[FLDDB. (.CMCFM)]	;CONFIRM FUNCTION
	COMND			;READ TO THE END OF LINE
	 ERJMP	NEWCMD		;IGNORE ANY ERROR
	JRST	NEWCMD		;OK, GO GET A NORMAL COMMAND





;HERE WHEN WE KNOW HE TYPED OUR NAME AS THE COMMAND.  WE NOW WANT
;TO LOOK FOR ANY SPECIFICATION FOLLOWING SO WE CAN USE IT IN THE
;IMPLICIT "REVIEW" COMMAND.  ERRORS HERE NOW CAN BE TOLD ABOUT.


GETSPC:	MOVEI	T1,CMDBLK	;POINT TO COMMAND BLOCK AGAIN
	MOVX	T2,GJ%OLD+GJ%IFG+GJ%FLG+GJ%ACC+.GJDEF	;GET FLAGS
	MOVEM	T2,JFNBLK	;STORE IN GTJFN BLOCK
	MOVEI	T2,[FLDDB. (.CMCFM,,,,,<[FLDDB. (.CMFIL)]>)]
	CALL	COMMND		;PARSE IT LOOKING FOR CRLF OR SPEC
	TSC	T3,T3		;COMPARE FIRST AND LAST FUNCTION BLOCK
	JUMPE	T3,NEWCMD	;NO SPEC WAS TYPED, GO GET A COMMAND
	MOVEM	T2,GJFN		;HAVE THE SPEC, SAVE THE JFN
	CALL	CONFRM		;CONFIRM THE SPEC
	CALL	ACTRVD		;GO REVIEW THE GIVEN FILES NOW
	CALL	CLOSE		;ALL DONE, CLOSE THE FILES
	CALL	CRLF		;TYPE A FINAL CRLF
	JRST	MONRET		;THEN EXIT

	SUBTTL	MAIN COMMAND SCANNER



;HERE TO INPUT A COMMAND FOR THE PROGRAM.  GOTTEN TO IF THE RESCANNED
;TEXT LOOKED INCORRECT OR HAD NO FILE SPECIFICATION GIVEN.



NEWCMD:	MOVEI	T1,NEWCMD	;GET ADDRESS TO GO TO IF ANY ERRORS
	CALL	ERRSET		;REMEMBER IT

NEWCMA:	HRROI	T1,[ASCIZ/REV>/]	;GET THE PROMPT
	MOVEM	T1,CMDBLK+.CMRTY	;AND SET UP CONTROL-R BUFFER
	MOVX	T1,GJ%OLD+GJ%IFG+GJ%FLG+GJ%ACC+.GJDEF	;GET FLAGS
	MOVEM	T1,JFNBLK	;AND STORE IN BLOCK
	MOVEI	T1,CMDBLK	;GET ADDRESS OF BLOCK
	MOVEI	T2,[FLDDB. (.CMINI)]	;AND INITIALIZE FUNCTION
	CALL	COMMND		;PARSE THE COMMAND
	MOVEM	P,SAVEP		;REMEMBER STACK FOR REPARSING


NEWPAR:	MOVE	P,SAVEP		;RESTORE STACK
	ANDCMI	F,FR.NXD!FR.NXS!FR.NXT!FR.NXF	;CLEAR FLAGS
	MOVEI	T1,CMDBLK	;POINT TO BLOCK
	MOVEI	T2,[FLDDB. (.CMKEY,,ACTTAB)]	;POINT TO TABLE
	CALL	COMMND		;PARSE THE COMMAND
	MOVE	T2,(T2)		;GET ADDRESS OF ROUTINE
	CALL	(T2)		;CALL IT FOR THIS COMMAND
	JRST	NEWCMA		;DONE, GO GET ANOTHER COMMAND

	SUBTTL	THE SIMPLE COMMANDS



;HERE TO DO ALL THE TRIVIAL COMMANDS: EXIT, HELP, ALLOW, ETC.



ACTHLP:	CALL	CONFRM		;CONFIRM THE EOL
	HRROI	T1,TXTHLP	;POINT TO STRING
	PSOUT			;TYPE IT
	HRROI	T1,HLPTXT	;POINT TO OTHER TEXT
	PSOUT			;AND OUTPUT IT TOO
	RET			;THEN RETURN


TXTHLP:	TEXT	<
REV is a program which lists files one by one and gives you the
option of typing, changing, or deleting each file separately.
The commands are:

  ALLOW  args		Allow the reviewing of the specified types of
			files.  The args can be any of DELETED, UNDELETED,
			ONLINE, OFFLINE, VISIBLE, INVISIBLE, or ALL.

  HELP			Type this text.

  EXIT			Exit from the program.

  REVIEW  file1  file2	Go over the files specified by file1, starting
			at the file specification given by file2.

  WHAT			Tell which kind of files we are set to review.

>






ACTXIT:	CALL	CONFRM		;LOOK FOR END OF LINE
	CALL	CRLF		;TYPE ANOTHER CRLF
MONRET:	RESET			;RESET EVERYTHING
	HALTF			;STOP
	JRST	.-1		;STAY DEAD

	SUBTTL	ROUTINE TO SET WHICH FILES ARE TO BE REVIEWED



;COMMAND TO SET THE PROPER FLAG BITS TO INDICATE WHICH FILES
;ARE TO BE REVIEWED.  THE "ALLOW" COMMAND.



ACTALW:	MOVEI	T2,[ASCIZ/REVIEWING OF/]	;NOISE
	CALL	NOISE		;PARSE IT
	SETZ	T5,		;CLEAR WHICH FILES WE ARE ALLOWING

ACTALP:	MOVEI	T2,[FLDDB. (.CMCFM,,,,,<[FLDDB. (.CMKEY,,ALWTAB)]>)]
	CALL	COMMND		;READ A KEYWORD OR A CRLF
	TSC	T3,T3		;SEE WHAT INPUT WE GOT
	JUMPE	T3,ACTADN	;A CRLF, GO FINISH UP
	TSO	T5,(T2)		;SET FLAGS TO ALLOW THIS TYPE
	JRST	ACTALP		;LOOP FOR ANOTHER KEYWORD


ACTADN:	MOVX	T1,3B1		;INITIALIZE A PAIR OF BITS
ACTADL:	TDNN	T5,T1		;DIDN'T MENTION EITHER DISJOINT SET?
	TDO	T5,T1		;YES, THEN ALLOW WHOLE SET
	LSH	T1,-2		;MOVE TEST BITS OVER
	TXNE	T1,FL.DAL	;LOOKED AT ALL KINDS OF FILES?
	JRST	ACTADL		;NO, CHECK NEXT PAIR
	SETCA	T5,T5		;COMPLEMENT RESULT
	HLL	F,T5		;SET THE NEW FLAGS
	RET			;AND RETURN





ALWTAB:	XWD	ALWLEN,ALWLEN		;HEADER FOR TABLE
ALWALL:	AA	ALL,(FL.DAL)		;ALL FILES
	AA	DELETED,(FL.DDL)	;DELETED FILES
	AA	INVISIBLE,(FL.DIV)	;INVISIBLE FILES
	AA	OFFLINE,(FL.DOF)	;OFFLINE FILES
	AA	ONLINE,(FL.DON)		;ONLINE FILES
	AA	UNDELETED,(FL.DUD)	;UNDELETED FILES
	AA	VISIBLE,(FL.DVS)	;VISIBLE FILES

	ALWLEN==.-ALWTAB-1	;NUMBER OF TYPES OF FILES

	SUBTTL	ROUTINE TO TELL ABOUT WHAT WE CAN REVIEW




;THIS ROUTINE TELLS THE USER WHAT KIND OF FILES HE IS SET TO
;REVIEW.  IS THE "WHAT" COMMAND.




ACTWHT:	MOVEI	T2,[ASCIZ/FILES ARE TO BE REVIEWED/]	;GET TEXT
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;AND CONFIRM IT
	HRROI	T1,[ASCIZ/
Set to review /]		;GET STRING
	PSOUT			;TYPE INTRODUCTION
	ANDCMI	F,FR.TMP	;INITIALIZE TEMPORARY FLAG
	HLRO	T1,ALWALL	;GET THE STRING FOR ALL FILES
	SETO	T5,		;AND A COUNT OF JUST ONE
	TXNN	F,FL.DAL	;ALL FILES BEING REVIEWED?
	JRST	WHTALL		;YES, GO DO SPECIAL
	MOVE	T5,[-ALWLEN,,ALWTAB+1]	;NO, GET READY FOR NORMAL LOOP


WHTLOP:	HRRZ	T1,T5		;GET THIS TYPE OF FILE
	CAIN	T1,ALWALL	;IS THIS THE ENTRY FOR ALL FILES?
	JRST	WHTLNX		;YES, SKIP IT
	HRLZ	T1,(T5)		;GET THE BITS FOR THIS TYPE
	TDNE	F,T1		;IS THIS KIND OF FILE DISALLOWED?
	JRST	WHTLNX		;YES, SKIP IT
	JFFO	T1,.+1		;SEE WHICH BIT THIS IS
	TRNN	T2,1		;IS THE BIT POSITION EVEN OR ODD?
	LSH	T1,-1		;EVEN, OTHER BIT OF PAIR IS TO THE RIGHT
	TRNE	T2,1		;WELL?
	LSH	T1,1		;ODD, OTHER BIT IS TO THE LEFT
	TDNN	F,T1		;IS THE OPPOSITE KIND BEING ALLOWED TOO?
	JRST	WHTLNX		;YES, NO NEED TO MENTION THIS TYPE
	HRROI	T1,[ASCIZ/,
/]				;GET SOME TEXT
	TROE	F,FR.TMP	;ALREADY TYPED A WORD?
	PSOUT			;YES, THEN SEPARATE WITH COMMAS
	HLRO	T1,(T5)		;GET THE TYPE OF FILE
WHTALL:	PSOUT			;OUTPUT IT
WHTLNX:	AOBJN	T5,WHTLOP	;LOOP OVER ALL TYPES OF FILE
	HRROI	T1,[ASCIZ/ files.

/]				;GET FINAL TEXT
	PSOUT			;TYPE IT
	RET			;DONE

	SUBTTL	ROUTINE TO DO THE REVIEW COMMAND



;HERE TO DO MAIN COMMAND OF PROGRAM.  READ IN A FILE SPEC, AND 
;LOOP OVER ALL FILES ASKING WHAT TO DO WITH EACH ONE.
;CALLED AT ACTRVD WHEN DOING A SPEC WHICH WE RESCANNED.



ACTREV:	MOVEI	T2,[ASCIZ/FILES/]	;GET NOISE WORD
	CALL	NOISE		;PARSE IT
	TXNN	F,FL.DDL	;ARE DELETED FILES ALLOWED?
	SKIPA	T2,[GJ%OLD+GJ%IFG+GJ%FLG+GJ%ACC+GJ%XTN+GJ%DEL+.GJALL]	;YES
	MOVE	T2,[GJ%OLD+GJ%IFG+GJ%FLG+GJ%ACC+GJ%XTN+.GJALL]	;NO
	MOVEM	T2,JFNBLK	;SET UP PROPER BITS
	TXNE	F,FL.DIV	;INVISIBLE FILES ALLOWED?
	TDZA	T2,T2		;NO, GET NO BITS
	MOVX	T2,G1%IIN	;YES, GET THE ALLOW INVISIBLE FILES BIT
	MOVEM	T2,JFNBLK+.GJF2	;AND STORE IN BLOCK
	MOVEI	T2,JFNBLK	;GET ADDRESS OF NORMAL JFN BLOCK
	MOVEM	T2,CMDBLK+.CMGJB	;AND SET INTO COMAND BLOCK
	MOVEI	T2,[FLDDB. (.CMFIL,CM%HPP+CM%SDH,,<files to review>)]
	CALL	COMMND		;READ THE FILE SPEC
	MOVEM	T2,GJFN		;REMEMBER JFN
	MOVEI	T2,[ASCIZ/STARTING AT FILE/]	;GET MORE NOISE
	CALL	NOISE		;PARSE IT
	MOVEI	T2,INIBLK	;GET ADDRESS OF SPECIAL JFN BLOCK
	MOVEM	T2,CMDBLK+.CMGJB	;AND SET UP TO USE IT
	MOVE	T2,[GJ%OLD+GJ%DEL+GJ%IFG+GJ%OFG+GJ%FLG+.GJALL]	;GET BITS
	MOVEM	T2,JFNBLK	;SET THEM
	MOVEI	T2,[FLDDB. (.CMFIL,CM%HPP+CM%SDH,,<file to begin at>)]
	CALL	COMMND		;READ THE FILE SPEC
	MOVEM	T2,INIJFN	;SAVE IT
	CALL	CONFRM		;LOOK FOR THE END OF THE COMMAND


ACTRVD:	HRRZ	T1,GJFN		;GET JFN
	DVCHR			;FIND OUT ABOUT DEVICE
	 ERJMP	ERRSTR		;SHOULDN'T FAIL
	LDB	T1,[POINT 9,T1,17]	;GET DEVICE TYPE
	CAIE	T1,.DVDSK	;IS IT A REAL DISK?
	 ILLARG	Device must be a disk
	ANDCMI	F,FR.AGN+FR.QIT	;CLEAR FLAGS
	IORI	F,FR.HDR	;AND SET THIS ONE

ACTRVS:	SETZM	SPCPTR		;INITIALIZE STRING POINTER
	SETZM	BACNUM		;AND NUMBER OF FILES BACKED UP
	CALL	CHKNXD		;SEE IF THIS FILE IS WANTED
	SKIPA			;NO
	JRST	LOOP		;YES, GO BEGIN MAIN LOOP
	CALL	NEXT		;ADVANCE TO THE NEXT FILE
	 ILLARG	No files found
	JRST	ACTRVS		;THEN SEE IF IT IS OK

;HERE TO HANDLE NEXT FILE:


LOOP:	CALL	CPYJFN		;CREATE A JFN AND STORE FILE SPEC
	SOSGE	BACNUM		;DECREMENT FILES WE ARE BACKED UP BY
	AOS	BACNUM		;BUT DON'T GO NEGATIVE
	ANDCMI	F,FR.NXD+FR.NXS+FR.NXT+FR.NXF	;CLEAR FLAGS
	CALL	DOFILE		;GO TYPE OUT FILE AND GET RESPONSE
	CALL	CLOSE		;MAKE SURE ALL FILES ARE RELEASED
	TRZE	F,FR.QIT	;USER WANTS TO QUIT?
	JRST	DONE		;YES, GO ABORT THIS
	CALL	NEXT		;ADVANCE TO NEXT FILE
	 JRST	CRLF		;NO MORE FILES, ALL DONE
	JRST	LOOP		;THEN GO WORK ON NEW FILE




;HERE WHEN USER WANTS TO ABORT EVERYTHING:


DONE:	HRRZ	T1,GJFN		;GET JFN
	RLJFN			;RELEASE IT
	 ERJMP	ERRSTR		;SHOULDN'T FAIL
	JRST	CRLF		;GIVE CRLF AND RETURN

	SUBTTL	SUBROUTINE CALLED FOR EACH FILE




;THIS ROUTINE ACTUALLY DOES THE WORK FOR EACH FILE.  WE TYPE OUT
;THE FILE SPECIFICATION, AND ASK THE USER WHAT HE WANTS TO DO
;WITH THIS FILE.  WE RETURN WHEN THIS FILE IS PROCESSED.




DOFILE:	MOVEI	T1,BADKEY	;GET ADDRESS OF ERROR ROUTINE
	CALL	ERRSET		;REMEMBER IT

DOFILA:	ANDCMI	F,FR.AGN	;CLEAR FLAG
	TRZE	F,FR.HDR	;CHECK AND CLEAR HEADER FLAG
	CALL	TYPHDR		;WANTED IT TYPED, DO IT
	HRRZ	T1,JFN		;GET JFN
	MOVSI	T2,.FBLEN	;GET LENGTH OF FDB
	MOVEI	T3,FDB		;AND PLACE TO STORE INFO
	GTFDB			;READ THE INFORMATION
	 ERJMP	ERRSTR		;LOSE
	MOVE	T1,[POINT 7,FILTXT]	;SET UP POINTER TO BUFFER
	MOVE	T2,FDB+.FBCTL	;GET STATUS BITS
	MOVEI	T3," "		;GET A SPACE
	TXNE	T2,FB%DEL	;IS FILE DELETED?
	MOVEI	T3,"D"		;YES, CHANGE TO A D
	IDPB	T3,T1		;STORE RESULT
	MOVEI	T3," "		;GET A SPACE
	TXNE	T2,FB%INV	;IS FILE INVISIBLE?
	MOVEI	T3,"I"		;YES, CHANGE LETTER
	IDPB	T3,T1		;STORE RESULT
	MOVEI	T3," "		;GET ANOTHER SPACE
	TXNE	T2,FB%OFF	;IS THE FILE OFFLINE?
	MOVEI	T3,"O"		;YES, REPLACE CHAR
	IDPB	T3,T1		;STORE RESULT
	MOVEI	T3," "		;AND SET UP A SPACE
	TXNE	T2,FB%BAT	;SOME PAGES IN FILE BAD MAYBE?
	MOVEI	T3,"*"		;YES, REPLACE SPACE
	IDPB	T3,T1		;STORE RESULT AGAIN
	HRRZ	T2,JFN		;GET JFN
	MOVE	T3,[1B8+1B11+1B14+1B17+JS%PAF]	;AND FLAGS
	JFNS			;STORE STRING FILE.TYPE.GEN

	MOVEI	T2,^D25		;GET COLUMN TO JUSTIFY TO
	CALL	JUSTFY		;DO THE JUSTIFICATION
	HRRZ	T2,FDB+.FBBYV	;GET PAGE COUNT IF ON-LINE
	MOVE	T3,FDB+.FBCTL	;AND FLAGS
	TXNE	T3,FB%OFF	;IS THE FILE OFF-LINE?
	HRRZ	T2,FDB+.FBBBT	;YES, GET SIZE FROM OTHER WORD
	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,^D29		;GET COLUMN TO JUSTIFY TO
	CALL	JUSTFY		;DO IT
	CALL	EOFOUT		;TYPE OUT THE EOF POINTER
	MOVEI	T2,^D40		;GET COLUMN TO JUSTIFY TO
	CALL	JUSTFY		;DO IT
	MOVE	T2,FDB+.FBWRT	;GET LAST DATE FILE WAS WRITTEN
	MOVX	T3,OT%NTM	;SET TO OUTPUT DATE ONLY, STANDARD FORMAT
	CALL	DATOUT		;GO TYPE THE DATE
	MOVEI	T2,[ASCIZ/ : /]	;GET STRING TO PROMPT USER
	CALL	STROUT		;STORE IT IN BUFFER
	IDPB	ZZ,T1		;STORE NULL ALSO TO MAKE ASCIZ

;HERE TO READ THE COMMAND FOR THIS FILE:


KEYCMD:	MOVEI	T1,KEYBLK	;POINT TO KEYWORD BLOCK
	MOVEI	T2,[FLDDB. (.CMINI)]	;INITIALIZATION
	CALL	COMMND		;DO IT
	MOVEM	P,SAVEP		;SAVE STACK FOR REPARSING

KEYPAR:	MOVE	P,SAVEP		;RESTORE STACK
	MOVEI	T1,KEYBLK	;SET UP FOR COMND JSYS
	MOVEI	T2,[FLDDB. (.CMCFM,CM%HPP+CM%SDH,,CRLF for next file,,<[FLDDB. (.CMKEY,,KEYTAB)]>)]
	CALL	COMMND		;READ THE COMMAND
	TSC	T3,T3		;COMPARE FUNCTION BLOCKS
	JUMPE	T3,CPOPJ	;IF THE SAME, JUST CRLF WAS TYPED
	MOVE	T2,(T2)		;GET TABLE ENTRY OF MATCH
	CALL	(T2)		;CALL ROUTINE FOR THIS SWITCH
	TRNE	F,FR.AGN	;HAVE TO PROCESS FILE AGAIN?
	JRST	DOFILA		;YES, GO DO IT
	RET			;ALL DONE, RETURN




BADKEY:	IORI	F,FR.AGN	;SET FLAG SO JFN IS NOT RELEASED
	CALL	CLOSE		;UNMAP AND CLOSE THE FILE IF NEEDED
	JRST	DOFILE		;AND REDO THIS FILE

	SUBTTL	 SIMPLE ROUTINES CALLED TO DO THINGS TO A FILE




;COMMAND TO QUIT THIS WHOLE BUSINESS, AND RETURN TO COMMAND LEVEL
;IMMEDIATELY.  THE "ABORT" COMMAND.


CMDABT:	MOVEI	T2,[ASCIZ/THIS COMMAND/]	;GET STRING
	CALL	NOISE		;PARSE THE NOISE
	CALL	CONFRM		;CONFIRM THE COMMAND
	IORI	F,FR.QIT	;SET FLAG TO QUIT
	RET			;RETURN






;COMMAND TO DELETE THE FILE WITHOUT EXPUNGING IT.
;THE "DELETE" COMMAND.


CMDDEL:	CALL	CONFRM		;CONFIRM THE COMMAND FIRST
	HRRZ	T1,JFN		;GET JFN OF FILE
	TLO	T1,(DF%NRJ)	;SET NOT TO RELEASE JFN
	DELF			;DELETE THE FILE
	 ERJMP	ERRSTR		;ERROR, NON-SKIP RETURN
	RET			;OK, RETURN



;ROUTINE TO TYPE HELP MESSAGE GIVING WHAT EACH COMMAND DOES.
;THE "HELP" COMMAND.


CMDHLP:	CALL	CONFRM		;CONFIRM THE COMMAND
	HRROI	T1,HLPTXT	;POINT TO TEXT
	PSOUT			;TYPE MESSAGE
	IORI	F,FR.AGN	;SAY TO DO FILE AGAIN
	RET			;THEN RETURN

;COMMAND TO UNDELETE FILES WHICH ARE DELETED.  THE "UNDELETE" COMMAND.


CMDUND:	CALL	CONFRM		;CONFIRM IT
	MOVSI	T1,.FBCTL	;GET WORD IN FDB TO CHANGE
	HRR	T1,JFN		;AND THE JFN
	MOVX	T2,FB%DEL	;AND MASK FOR THE DELETED BIT
	SETZ	T3,		;WANT TO TURN IT OFF
	CHFDB			;UNDELETE THE FILE
	 ERJMP	ERRSTR		;FAILED
	RET			;RETURN






;COMMAND TO EXIT TO MONITOR LEVEL.  ON A CONTINUE, WE RETYPE THE
;FILE SPEC AND GO BACK TO WHERE WE WAS.  IS THE "EXIT" COMMAND.


CMDXIT:	CALL	CONFRM		;CONFIRM THE END OF LINE
	CALL	CRLF		;TYPE A CRLF TO LOOK NICE
	HALTF			;EXIT WITHOUT RESETTING
	IORI	F,FR.AGN+FR.HDR	;SAY TO REDO THE FILE
	RET			;AND RETURN

	SUBTTL	ROUTINE TO DO A PUSH COMMAND



;COMMAND TO GET AN EXEC AS AN INFERIOR PROCESS.  WHEN THE EXEC
;TERMINATES, WE REPROCESS THE CURRENT FILE SPEC AGAIN.  THE
;"PUSH" COMMAND.




CMDPSH:	MOVEI	T2,[ASCIZ/COMMAND LEVEL/]	;GET NOISE
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;CONFIRM COMMAND
	MOVX	T1,GJ%OLD+GJ%PHY+GJ%SHT	;GET BITS READY
	HRROI	T2,[ASCIZ/SYSTEM:EXEC.EXE/]	;AND SPEC
	CALL	GETFRK		;GET IT IN INFERIOR FORK
	CALL	RUNFRK		;THEN RUN IT
	IORI	F,FR.AGN+FR.HDR	;REMEMBER TO DO THIS FILE AGAIN
	RET			;AND RETURN

	SUBTTL	ROUTINE TO RUN THE CURRENT FILE




;COMMAND TO PUT THE CURRENT FILE INTO AN INFERIOR FORK, AND START IT
;RUNNING.  WHEN IT EXITS OR BLOWS UP, WE REPROCESS THE CURRENT SPEC
;AGAIN.  THE "RUN" COMMAND.



CMDRUN:	MOVEI	T2,[ASCIZ/THIS PROGRAM/]	;GET NOISE
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;CONFIRM THE COMMAND
	MOVE	T1,SPCPTR	;GET POINTER TO CURRENT SPEC
	IDIVI	T1,MAXUP	;MAKE MODULO TABLE SIZE
	IMULI	T2,SPECSZ	;MAKE OFFSET FOR THIS STRING
	HRROI	T2,SPECS(T2)	;POINT TO THE STRING
	MOVX	T1,GJ%OLD+GJ%DEL+GJ%PHY+GJ%SHT+GJ%ACC	;GET BITS
	CALL	GETFRK		;READ THIS INTO INFERIOR


DORUN:	MOVEI	T1,RUNABT	;GET ROUTINE TO GO TO ON CONTROL-C
	MOVEM	T1,INTCOD	;SET IT
	MOVEM	P,INTPDL	;SAVE STACK POINTER TOO
	MOVE	T1,[.TICCC,,INTCHN]	;GET READY
	ATI			;TRY TO INTERCEPT CONTROL-C'S
	 ERJMP	[HRROI	T1,[ASCIZ/
% REV - Unable to Control-C trap
/]				;FAILED, GET STRING
		PSOUT		;SAY WE CAN'T DO IT
		JRST	.+1]	;PROCEED
	CALL	RUNFRK		;THEN GO RUN IT
	SKIPA			;SKIP SINCE ALREADY KILLED FORK


RUNABT:	CALL	RUNFIN		;KILL OFF THE FORK
	MOVEI	T1,.TICCC	;GET CHARACTER CODE
	DTI			;DEASSIGN IT
	IORI	F,FR.AGN+FR.HDR	;DO FILE AGAIN
	RET			;RETURN

	SUBTTL	ROUTINE TO CALL AN EDITOR FOR THIS FILE




;THE "EDIT" COMMAND.  WE READ IN THE FILE SPEC FROM THE LOGICAL
;NAME OF "EDITOR:", AND START IT.  THE RSCAN BUFFER IS FILLED
;WITH THE NAME OF THE FILE.




CMDEDT:	MOVEI	T2,[ASCIZ/THIS FILE/]	;GET READY
	CALL	NOISE		;TYPE SOME NOISE
	CALL	CONFRM		;CONFIRM THE LINE FIRST
	MOVX	T1,GJ%OLD+GJ%SHT	;GET FLAGS
	HRROI	T2,[ASCIZ/EDITOR:/]	;GET LOGICAL NAME READY
	CALL	GETFRK		;READ IT INTO AN INFERIOR FORK
	CALL	CRLF		;TYPE A PRELIMARY CRLF
	MOVE	T1,[POINT 7,TEMP]	;POINT TO STORAGE AREA
	MOVEI	T2,[ASCIZ/EDIT /]	;GET STARTING STRING
	CALL	STROUT		;OUTPUT IT
	MOVE	T2,SPCPTR	;GET POINTER TO CURRENT STRING
	IDIVI	T2,MAXUP	;GET INDEX INTO TABLES
	IMULI	T3,SPECSZ	;MULTIPLY BY SIZE OF A SPEC
	MOVEI	T2,SPECS(T3)	;GET ADDRESS OF STRING
	CALL	STROUT		;OUTPUT THE FILE SPEC
	MOVEI	T2,[ASCIZ/
/]				;GET A CRLF
	CALL	STROUT		;OUTPUT IT
	SETZ	T2,		;GET A NULL
	IDPB	T2,T1		;MAKE THE STRING ASCIZ
	HRROI	T1,TEMP		;POINT TO THE STRING
	RSCAN			;MAKE THE STRING AVAILABLE
	 ERJMP	ERRSTR		;FAILED
	JRST	DORUN		;GO DO THE RUN NOW

	SUBTTL	ROUTINE TO CALL FILDDT FOR THIS FILE



;THE "FILDDT" COMMAND.  WE GET FILDDT ON AN INFERIOR FORK, AND
;START IT UP.  WE GIVE IT THE FILE SPECIFICATION OF OUR FILE
;BY TYPING IT TO OUR INPUT BUFFER.


	DD.NOS==1		;DON'T TELL FILDDT THE FILE SPEC
	DD.PAT==2		;ENABLE PATCHING OF FILE
	DD.DAT==4		;ENABLE DATA ONLY MODE


CMDDDT:	SETZ	T5,		;CLEAR FLAGS
CMDDDL:	MOVEI	T2,[FLDDB. (.CMCFM,,,<
>,,<[FLDDB. (.CMKEY,,DDTTAB)]>)]	;GET READY
	CALL	COMMND		;READ KEYWORD OR A CRLF
	TSC	T3,T3		;COMPARE LAST DESCRIPTOR BLOCK USED
	JUMPE	T3,DDTDO	;WAS CRLF, GO DO IT NOW
	MOVE	T2,(T2)		;GET BITS FOR THIS KEYWORD
	IORI	T5,(T2)		;REMEMBER THEM
	JRST	CMDDDL		;LOOP FOR MORE


DDTDO:	CALL	CRLF		;TYPE A CRLF FIRST
	MOVX	T1,GJ%OLD+GJ%SHT	;GET FLAGS
	HRROI	T2,[ASCIZ/SYS:FILDDT.EXE/]	;AND THE SPEC
	CALL	GETFRK		;READ IT INTO INFERIOR FORK
	MOVEI	T1,.PRIIN	;GET READY
	CFIBF			;CLEAR INPUT BUFFER
	MOVEI	T3,[ASCIZ/Enable patching
/]	;GET STRING
	TRNE	T5,DD.PAT	;WANT TO PATCH?
	CALL	STISTR		;YES, PUT STRING IN BUFFER
	MOVEI	T3,[ASCIZ/Enable data-file
/]		;GET STRING
	TRNE	T5,DD.DAT	;WANT DATA MODE?
	CALL	STISTR		;YES, STORE STRING
	TRNE	T5,DD.NOS	;DOESN'T WANT THE SPEC TYPED?
	JRST	DORUN		;YES, JUST GO RUN IT
	MOVEI	T3,[ASCIZ/Get /]	;GET TEXT
	CALL	STISTR		;TYPE STRING INTO INPUT BUFFER
	MOVE	T2,SPCPTR	;GET POINTER TO CURRENT STRING
	IDIVI	T2,MAXUP	;GET INDEX INTO TABLES
	IMULI	T3,SPECSZ	;MULTIPLY BY SIZE OF A SPEC
	MOVEI	T3,SPECS(T3)	;POINT TO SPEC
	CALL	STISTR		;TYPE IT TO INPUT
	MOVEI	T3,[BYTE (7)15]	;GET JUST A CRLF
	CALL	STISTR		;TYPE IT TO END LINE
	JRST	DORUN		;THEN GO RUN IT

;TABLE OF POSSIBLE KEYWORDS:



DDTTAB:	DDTLEN,,DDTLEN			;LENGTH OF TABLE
	AA	DATA-FILE,DD.DAT	;ENABLE DATA MODE ONLY
	AA	NO-FILE,DD.NOS		;DON'T TYPE SPEC
	AA	PATCHING,DD.PAT		;ENABLE PATCHING

	DDTLEN==.-DDTTAB-1	;LENGTH





;SUBROUTINE TO STORE A STRING INTO OUR INPUT BUFFER.


STISTR:	HRLI	T3,(POINT 7,)	;MAKE BYTE POINTER
STISTL:	ILDB	T2,T3		;GET CHAR
	JUMPE	T2,CPOPJ	;DONE, RETURN
	MOVEI	T1,.CTTRM	;GET MY TERMINAL DESIGNATOR
	STI			;PUT CHAR INTO INPUT BUFFER
	 ERJMP	ERRSTR		;FAILED
	JRST	STISTL		;LOOP OVER WHOLE STRING

	SUBTTL	ROUTINE TO SKIP OVER FILES




;COMMAND TO SKIP TO THE NEXT DIRECTORY OR THE NEXT STRUCTURE.
;THE "NEXT" COMMAND.


CMDNXT:	MOVEI	T2,[FLDDB. (.CMKEY,,NXTTAB,<
>,<DIRECTORY>)]			;SET UP MORE
	CALL	COMMND		;GET ARGUMENT
	HRRZ	T4,(T2)		;GET BITS FROM TABLE
	CALL	CONFRM		;CONFIRM THE COMMAND
	IORI	F,(T4)		;SET PROPER BITS
	RET			;AND RETURN





NXTTAB:	NXTLEN,,NXTLEN			;HEADER FOR TABLE
	AA	DIRECTORY,FR.NXD	;NEXT DIRECTORY
	AA	FILE,FR.NXF		;NEXT FILE
	AA	STRUCTURE,FR.NXS	;NEXT STRUCTURE
	AA	TYPE,FR.NXT		;NEXT FILE TYPE

	NXTLEN==.-NXTTAB-1	;NUMBER OF COMMANDS

	SUBTTL	ROUTINE TO STORE FILE SPEC IN A FILE




;COMMAND TO STORE THE CURRENT FILE SPEC INTO A FILE.  IF THE FILE IS
;NONEMPTY, THE SPEC IS APPENDED WITH A PRECEEDING COMMA, TO CREATE
;A LIST OF FILES.



CMDSTO:	MOVEI	T2,[ASCIZ/FILENAME INTO FILE/]	;GET NOISE TEXT
	CALL	NOISE		;PARSE IT
	MOVX	T2,GJ%MSG	;GET FLAGS FOR FILE
	MOVEM	T2,KEYJFB	;SET THEM INTO JFN BLOCK
	SETZM	KEYJFB+.GJDEV	;NO DEFAULT DEVICE
	SETZM	KEYJFB+.GJDIR	;OR DEFAULT DIRECTORY
	MOVE	T2,[ASCII/REV/]	;GET DEFAULT NAME
	MOVEM	T2,DFTNAM	;SET IT
	MOVE	T2,[ASCII/LST/]	;GET DEFAULT EXTENSION
	MOVEM	T2,DFTTYP	;SET IT ALSO
	MOVEI	T2,[FLDDB. (.CMFIL)]	;GET READY
	CALL	COMMND		;READ FILE SPEC
	HRRZM	T2,JFNOUT	;SAVE OUTPUT JFN
	CALL	CONFRM		;THEN CONFIRM THE LINE
	MOVE	T1,JFNOUT	;GET JFN
	MOVX	T2,<FLD(7,OF%BSZ)!OF%APP>	;GET READY
	OPENF			;OPEN FILE FOR APPENDING
	 ERJMP	ERRSTR		;FAILED
	IORI	F,FR.OP2	;REMEMBER FILE IS OPEN NOW
	RFPTR			;READ CURRENT FILE POINTER
	 ERJMP	ERRSTR		;FAILED
	JUMPE	T2,STOFIL	;SKIP ON IF FILE IS EMPTY
	HRROI	T2,[ASCIZ/,
/]				;NONEMPTY, GET TEXT TO APPEND
	SETZ	T3,		;WANT IT ALL
	SOUT			;STORE SEPARATOR TEXT FIRST
	 ERJMP	ERRSTR		;FAILED
STOFIL:	HRRZ	T2,JFN		;GET CURRENT FILE'S JFN
	MOVX	T3,1B2+1B5+1B8+1B11+1B14+JS%PAF	;FLAGS
	JFNS			;STORE THIS FILE SPEC
	 ERJMP	ERRSTR		;FAILED
	CLOSF			;NOW CLOSE THE FILE
	 ERJMP	ERRSTR		;FAILED
	ANDCMI	F,FR.OP2	;FILE NO LONGER OPEN
	SETZM	JFNOUT		;CLEAR THE JFN
	IORI	F,FR.AGN	;REMEMBER TO DO THE FILE AGAIN
	RET			;DONE

	SUBTTL	ROUTINE TO TYPE OUT A FILE


;COMMAND TO TYPE THE FILE TO THE TERMINAL.  THE "TYPE" COMMAND.
;USER CAN ABORT THE TYPEOUT WITH A ^E.


CMDFOL:	TXOA	F,FR.FOL	;REMEMBER TO FOLLOW THE FILE
CMDTYP:	TXZ	F,FR.FOL	;OR REMEMBER TO JUST TYPE IT
	MOVEI	T2,[ASCIZ/FROM PAGE/]	;GET NOISE TEXT
	TXNE	F,FR.FOL	;FOLLOWING?
	MOVEI	T2,[ASCIZ/WRITING OF FILE FROM PAGE/]	;YES, OTHER TEXT
	CALL	NOISE		;GOBBLE THE NOISE
	MOVEI	T2,[FLDDB. (.CMNUM,,^D10,,<0>)]	;NUMBER FUNCTION
	CALL	COMMND		;READ IT
	TLNE	T2,-1		;ILLEGAL PAGE NUMBER GIVEN?
	 ILLARG	Illegal page number specified
	TXNN	F,FR.FOL	;FOLLOWING?
	SUBI	T2,1		;NO, CHANGE TO PREVIOUS PAGE
	MOVEM	T2,PAGE		;SAVE AS PAGE TO START FROM
	CALL	CONFRM		;CONFIRM THE END OF LINE IS OK
	CALL	OPEN		;OPEN THE FILE FOR READING
	CALL	CRLF		;START WITH A CRLF
	MOVEI	T1,TYPABT	;GET ROUTINE TO GO TO ON CONTROL-E
	MOVEM	T1,INTCOD	;SET IT
	MOVEM	P,INTPDL	;SAVE STACK POINTER TOO
	MOVE	T1,[.TICCE,,INTCHN]	;GET CODE AND CHANNEL
	ATI			;ASSIGN ^E TO CHANNEL
	 ERJMP	ERRSTR		;ERROR
	TXNE	F,FR.FOL	;WANT TO FOLLOW PROGRESS?
	JRST	FOLLOW		;YES, GO TO SPECIAL CODE NOW


TYPLOP:	CALL	PAGMAP		;MAP IN THE NEXT PAGE OF FILE
	 JRST	TYPDON		;NO MORE PAGES
	MOVEI	T1,.PRIOU	;OUTPUT DESIGNATOR
	HRRO	T2,PAGADR	;TEXT TO BE TYPED
	MOVNI	T3,PAGSIZ*5	;WHOLE PAGE OF TEXT
	SOUT			;TYPE IT
	 ERJMP	ERRSTR		;FAILED
	JRST	TYPLOP		;AND LOOP FOR NEXT PAGE

;HERE TO FOLLOW THE PROGRESS OF A FILE BEING WRITTEN:


FOLLOW:	MOVE	T1,JFN		;GET JFN
	MOVE	T2,PAGE		;GET PAGE NUMBER
	IMULI	T2,PAGSIZ*5	;MULTIPLY BY BYTES TO A PAGE
	SFPTR			;TELL MONITOR WHERE TO START
	 ERJMP	ERRSTR		;FAILED

FOLLOP:	MOVE	T1,JFN		;GET BACK JFN
	BIN			;READ NEXT BYTE OF FILE
	 ERJMP	FOLFAI		;FAILED, GO SEE WHY
	JUMPE	T2,FOLLOP	;IGNORE NULLS
	MOVE	T3,T2		;SAVE CHARACTER
	RFPTR			;READ CURRENT FILE POSITION
	 ERJMP	ERRSTR		;FAILED
	MOVEM	T2,FILBYT	;REMEMBER FOR LATER
	MOVE	T1,T3		;GET BACK CHARACTER
	PBOUT			;TYPE TO TERMINAL
	JRST	FOLLOP		;CONTINUE LOOPING


FOLFAI:	GTSTS			;GET DEVICE STATUS
	TXNN	T2,GS%EOF	;END OF FILE?
	JRST	ERRSTR		;NO, GO SAY WHAT WENT WRONG
	MOVEI	T1,FOLSLP	;GET SLEEP TIME
	DISMS			;WAIT A LITTLE WHILE
	MOVE	T1,JFN		;GET JFN
	TXO	T1,CO%NRJ	;SAY TO NOT RELEASE THE JFN
	CLOSF			;CLOSE THE FILE
	 ERJMP	ERRSTR		;FAILED
	CALL	OPEN		;OPEN FILE AGAIN
	MOVE	T1,JFN		;GET BACK JFN
	MOVE	T2,FILBYT	;RESTORE BYTE COUNT
	SFPTR			;SET POINTER BACK TO OLD LOCATION
	 ERJMP	ERRSTR		;FAILED
	JRST	FOLLOP		;AND TRY SOME MORE

;HERE ON A CONTROL-E CHARACTER


TYPABT:	MOVEI	T1,.PRIOU	;GET OUTPUT DESIGNATOR
	CFOBF			;CLEAR OUTPUT BUFFER
	TXNN	F,FR.FOL	;FOLLOWING A FILE?
	JRST	ABTNTF		;NO, GO ON
	MOVE	T2,FILBYT	;GET BYTE NUMBER WE STOPPED AT
	IDIVI	T2,PAGSIZ*5	;COMPUTE PAGE NUMBER
	MOVEM	T2,PAGE		;STORE IT

ABTNTF:	SKIPN	T2,PAGE		;GET PAGE WE STOPPED ON
	JRST	TYPAB2		;IF FIRST PAGE, SKIP OUTPUT
	HRROI	T1,[ASCIZ/

Stopped on page /]	;GET STRING
	PSOUT			;TYPE IT OUT
	MOVEI	T1,.PRIOU	;GET READY
	MOVEI	T3,^D10		;DECIMAL NUMBER
	NOUT			;TYPE IT
	 ERJMP	ERRSTR		;FAILED
TYPAB2:	CALL	CRLF		;FINISH WITH A CRLF




;HERE WHEN ALL DONE WITH TYPING THE FILE:



TYPDON:	MOVEI	T1,.TICCE	;GET CHARACTER CODE TO RELEASE
	DTI			;REMOVE CONTROL-E INTERRUPT
	IORI	F,FR.AGN	;SAY WE WILL REPROCESS THE FILE
	CALL	CLOSE		;UNMAP AND CLOSE THE FILE
	JRST	CRLF		;GIVE A CRLF AND RETURN

	SUBTTL	COMMAND TO PRINT INFORMATION ABOUT A FILE




;THIS ROUTINE HANDLES THE "INFO" COMMAND.  IT WILL TYPE
;OUT EITHER INFORMATION ABOUT THE FDB OF A FILE, OR ABOUT ITS
;USE OF PAGES.  DEFAULT IS TO TYPE OUT ABOUT THE FDB.




CMDINF:	MOVEI	T2,[ASCIZ/ABOUT/]	;GET NOISE
	CALL	NOISE		;PARSE IT
	MOVEI	T2,[FLDDB. (.CMKEY,,INFTAB,<
>,<FDB>)]			;GET READY
	CALL	COMMND		;READ A KEYWORD
	MOVE	T4,(T2)		;GET DISPATCH ADDRESS
	CALL	CONFRM		;CONFIRM THE COMMAND
	JRST	(T4)		;GO HANDLE THE COMMAND




INFTAB:	INFLEN,,INFLEN			;HEADER WORD
	AA	ALL-OF-FDB,INFFDA	;TYPE OUT ALL FDB INFO
	AA	FDB,INFFDB		;TYPE OUT INTERESTING FDB INFO
	AA	PAGES,INFMAP		;TYPE OUT PAGE MAP INFO

	INFLEN==.-INFTAB-1		;NUMBER OF ENTRIES

	SUBTTL	ROUTINE TO MAP OUT THE USED PAGES OF A FILE



;ROUTINE TO TYPE OUT WHICH PAGES OF A FILE ARE IN USE.  USEFUL
;TO EXAMINE FILES WHICH HAVE HOLES IN THEM.  THE "INFO PAGES"
;COMMAND.




INFMAP:	CALL	OPEN		;OPEN THE FILE FOR READING
	MOVE	T1,[POINT 7,LINBUF]	;GET POINTER
	MOVEI	T2,[ASCIZ/
Used pages: /]			;GET TEXT
	CALL	STROUT		;START OFF OUTPUT WITH THAT
	SETOM	PAGE		;INITIALIZE PAGE NUMBER
	SETZB	T5,PAGTOT	;INITIALIZE FLAG AND TOTAL PAGES



MAPLOP:	MOVEM	T1,LINPTR	;SAVE CURRENT BYTE POINTER
	AOS	T1,PAGE		;GET PAGE TO START AT
	TLNE	T1,-1		;OVERFLOWED MAXIMUM PAGE?
	JRST	MAPDON		;YES, ALL DONE
	HRL	T1,JFN		;INSERT THE JFN
	FFUFP			;FIND THE NEXT USED PAGE
	 ERJMP	MAPEND		;FAILED, GO SEE WHY
	HRRZM	T1,PAGBEG	;SAVE PAGE NUMBER
	MOVE	T1,JFN		;NOW GET READY
	HRL	T1,PAGBEG	;TO FIND NEXT FREE PAGE
	FFFFP			;DO IT
	 ERJMP	ERRSTR		;FAILED
	CAME	T1,[-1]		;MORE PAGES?
	TLZA	T1,-1		;YES, ISOLATE NUMBER
	MOVSI	T1,1		;NO, GET MAX PAGE PLUS 1
	MOVEM	T1,PAGE		;SAVE NEXT STARTING PLACE
	SUB	T1,PAGBEG	;SUBTRACT FIRST PAGE OF GROUP
	ADDM	T1,PAGTOT	;UPDATE TOTAL PAGES IN FILE
	MOVE	T1,PAGE		;GET NEXT FREE PAGE
	SUBI	T1,1		;DECREMENT TO GET LAST USED PAGE
	MOVEM	T1,PAGEND	;SAVE
	MOVE	T1,LINPTR	;RESTORE BYTE POINTER
	CALL	MAPTYP		;TYPE OUT THE RANGE WE FOUND
	JRST	MAPLOP		;AND LOOP

;HERE WHEN ALL DONE, TO TYPE OUT FINAL STUFF:


MAPEND:	CAIE	T1,FFUFX3	;NO MORE PAGES TO DO?
	JRST	ERRSTR		;OTHER ERROR, GO COMPLAIN
MAPDON:	MOVE	T1,LINPTR	;GET BYTE POINTER BACK
	SKIPN	T2,PAGTOT	;GET TOTAL NUMBER OF PAGES
	JRST	[MOVEI	T2,[ASCIZ/ None

/]				;WAS NONE, GET TEXT
		JRST	MAPFIN]	;AND GO FINISH
	MOVEI	T2,[ASCIZ/
Total pages: /]			;GET TEXT
	CALL	STROUT		;OUTPUT THAT
	MOVE	T2,PAGTOT	;GET COUNT
	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,[ASCIZ/

/]				;GET A COUPLE OF CRLFS


MAPFIN:	CALL	STROUT		;STORE IT
	IDPB	ZZ,T1		;CREATE ASCIZ STRING
	HRROI	T1,LINBUF	;POINT TO STRING
	PSOUT			;OUTPUT IT
	IORI	F,FR.AGN	;WANT TO DO FILE AGAIN
	JRST	CLOSE		;CLOSE FILE AND REDO IT

;SUBROUTINE USED FOR THE INFMAP ROUTINE.  OUTPUTS A RANGE OF NUMBERS
;WHICH ARE IN LOCATIONS PAGBEG AND PAGEND.  IF THEY ARE THE SAME,
;WE ONLY OUTPUT ONE NUMBER.  BYTE POINTER FOR OUTPUT IS IN AC T1.
;AC T5 IS A FLAG ON WHETHER OR NOT WE HAVE BEEN CALLED BEFORE.




MAPTYP:	MOVEI	T2,","		;GET A COMMA
	TROE	T5,-1		;FIRST TIME THIS WAS CALLED?
	IDPB	T2,T1		;NO, OUTPUT THE COMMA
	MOVEI	T2,(T1)		;GET CURRENT ADDRESS POINTER IS AT
	CAIGE	T2,LINBUF+^D11	;GETTING NEAR THE END OF THE LINE?
	JRST	MAPTYC		;NO, SKIP THE CRLF NOW
	MOVEI	T2,[ASCIZ/
/]				;YES, GET A CRLF
	CALL	STROUT		;OUTPUT IT
	IDPB	ZZ,T1		;MAKE STRING ASCIZ
	HRROI	T1,LINBUF	;POINT TO IT
	PSOUT			;AND OUTPUT IT
	MOVE	T1,[POINT 7,LINBUF]	;REINITIALIZE BYTE POINTER


MAPTYC:	MOVEI	T2," "		;GET A SPACE
	IDPB	T2,T1		;SPACE OVER FROM LAST OUTPUT
	MOVE	T2,PAGBEG	;GET FIRST PAGE OF THE RANGE
	CALL	OCTOUT		;OUTPUT IT
	MOVE	T2,PAGEND	;GET SECOND PAGE OF THE RANGE
	CAMN	T2,PAGBEG	;SAME AS FIRST PAGE?
	RET			;YES, DON'T TYPE IT
	MOVEI	T3,"-"		;GET A DASH
	IDPB	T3,T1		;STORE IT
	JRST	OCTOUT		;OUTPUT SECOND NUMBER AND RETURN

	SUBTTL	ROUTINE TO TYPE INFO ABOUT A FILE



;THIS ROUTINE TYPES OUT THE VARIOUS PARAMETERS OF A FILE.  IS THE
;ROUTINE TO PROCESS THE "INFO FDB" COMMAND.


INFFDA:	TROA	F,FR.FBA	;REMEMBER TO SHOW ALL
INFFDB:	ANDCMI	F,FR.FBA	;REMEMBER DON'T WANT TO SEE ALL
	HRROI	T1,[ASCIZ/
FDB for file /]			;GET TEXT
	PSOUT			;TYPE IT
	MOVE	T1,SPCPTR	;GET SPEC POINTER
	IDIVI	T1,MAXUP	;GET MODULO NUMBER OF SPECS
	IMULI	T2,SPECSZ	;MULTIPLY BY SIZE OF EACH SPEC
	HRROI	T1,SPECS(T2)	;POINT TO SPEC
	PSOUT			;TYPE IT
	CALL	CRLF		;AND A CRLF
	CALL	CRLF		;AND ANOTHER
	LDB	T1,[POINTR FDB+.FBHDR,FB%LEN]	;GET LENGTH OF THIS FDB
	ADDI	T1,FDB-1	;COMPUTE LAST ADDRESS WHICH IS VALID
	MOVEM	T1,FDBMAX	;REMEMBER FOR CHECKS LATER
	MOVSI	I,-TABNUM	;GET READY TO LOOP OVER ALL FIELDS


VERLOP:	HRRZ	T1,TABPTR(I)	;GET THE OFFSET FOR THIS FIELD
	CAMLE	T1,FDBMAX	;IS THE OFFSET VALID FOR THIS FDB?
	JRST	VERLPN		;NO, SKIP IT
	TRNN	F,FR.FBA	;EITHER WANT THE WHOLE FDB?
	SKIPGE	TABTXT(I)	;OR FIELD ALWAYS TO BE OUTPUT EVEN IF ZERO?
	JRST	VERLP0		;YES, GO DO IT
	LDB	T1,TABPTR(I)	;NO, GET FIELD VALUE
	JUMPE	T1,VERLPN	;IF ZERO, SKIP THE OUTPUT

VERLP0:	MOVE	T1,[POINT 7,LINBUF]	;GET POINTER TO BUFFER
	MOVE	T2,TABMSK(I)	;GET MASK FOR FIELD
	AOJE	T2,VERLP1	;JUMP IF WAS FOR WHOLE WORD
	MOVEI	T2,[ASCIZ/       /]	;PARTIAL WORD, GET SOME SPACES
	CALL	STROUT		;INDENT THIS LINE
	MOVE	T2,TABSYM(I)	;GET SYMBOL FOR THIS FIELD
	CALL	SIXOUT		;OUTPUT IT
	MOVEI	T2,[ASCIZ/  (/]	;GET TEXT
	CALL	STROUT		;TYPE IT
	MOVE	T3,TABPTR(I)	;GET BYTE POINTER FOR FIELD
	HRRI	T3,[-1]		;POINT TO ALL ONES
	LDB	T2,T3		;GET BYTE
	CALL	OCTOUT		;TYPE THE FIELD
	MOVEI	T2,"B"		;GET CHARACTER
	IDPB	T2,T1		;STORE IT
	MOVEI	T2,^D35		;GET BIT COUNT READY
	LDB	T3,[POINT 6,TABPTR(I),5]	;GET BYTE POSITION
	SUBI	T2,(T3)		;SUBTRACT TO GET POSITION
	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,")"		;GET TRAILING PARANTHESIS
	IDPB	T2,T1		;STORE IT
	JRST	VERLP2		;AND GO FINISH UP

VERLP1:	MOVE	T2,TABWRD(I)	;FULL WORD VALUE, GET OFFSET
	MOVEI	T3," "		;GET A SPACE READY
	CAIGE	T2,^O10		;NEED TWO DIGITS?
	IDPB	T3,T1		;NO, THEN SPACE OVER
	CALL	OCTOUT		;TYPE OFFSET
	MOVEI	T2,[ASCIZ/  /]	;GET A FEW MORE SPACES
	CALL	STROUT		;OUTPUT THEM
	MOVE	T2,TABSYM(I)	;GET SYMBOL FOR WORD
	CALL	SIXOUT		;OUTPUT IT

VERLP2:	MOVEI	T2,[ASCIZ/  -  /]	;MORE TEXT
	CALL	STROUT		;TYPE IT
	MOVE	T2,TABTXT(I)	;GET TEXT STRING FOR FIELD
	CALL	STROUT		;OUTPUT THAT TOO
	MOVEI	T2,[ASCIZ/: /]	;GET FINAL TEXT
	CALL	STROUT		;TYPE THAT
	LDB	T2,TABPTR(I)	;GET DATA TO BE TYPED
	CALL	@TABADR(I)	;GO TYPE VALUE
	MOVEI	T2,[ASCIZ/
/]				;GET A CRLF
	CALL	STROUT		;OUTPUT IT ALSO
	IDPB	ZZ,T1		;MAKE WHOLE STRING ASCIZ
	HRROI	T1,LINBUF	;POINT TO BUFFER
	PSOUT			;TYPE THE LINE

VERLPN:	AOBJN	I,VERLOP	;LOOP OVER ALL FIELDS TO TYPE
	IORI	F,FR.AGN	;SAY TO DO FILE AGAIN
	JRST	CRLF		;GIVE A CRLF AND RETURN

	SUBTTL	ROUTINES USED IN TYPEOUT OF FIELDS



;ALL ROUTINES HERE SEND THEIR OUTPUT TO A STRING USING THE BYTE
;POINTER IN AC T1.  ARGUMENTS FOR TYPEOUT ALWAYS GO INTO AC T2.



TYPDEC:	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,"."		;GET A PERIOD
	IDPB	T2,T1		;OUTPUT IT TO INDICATE DECIMAL NUMBER
	RET			;RETURN



TYPHLF:	TLNN	T2,-1		;LARGER THAN A HALFWORD?
	JRST	OCTOUT		;NO, JUST OUTPUT IT
	MOVE	T5,T2		;SAVE FOR AWHILE
	HLRZ	T2,T2		;GET LEFT HALF
	CALL	OCTOUT		;OUTPUT IT
	MOVEI	T2,[ASCIZ/,,/]	;GET SOME COMMAS
	CALL	STROUT		;OUTPUT IT
	HRRZ	T2,T5		;GET RIGHT HALF
	JRST	OCTOUT		;OUTPUT IT AND RETURN



TYPHLD:	MOVE	T5,T2		;SAVE FOR LATER
	HLRZ	T2,T5		;GET LEFT HALF
	CALL	TYPDEC		;OUTPUT IT IN DECIMAL
	MOVEI	T2,[ASCIZ/,,/]	;GET COMMAS
	CALL	STROUT		;OUTPUT THEM
	HRRZ	T2,T5		;GET OTHER HALF
	JRST	TYPDEC		;OUTPUT IN DECIMAL AND RETURN



TYPBIT:	ADDI	T2,[ASCII/No/
		    ASCII/Yes/]	;POINT TO PROPER STRING
	JRST	STROUT		;THEN OUTPUT IT

TYPEXD:	JUMPE	T2,EXDNON	;SPECIAL MESSAGE IF NO TIME
	TLNE	T2,-1		;IS THIS AN INTERVAL OR A DATE?
	JRST	TYPDAT		;A DATE, GO TYPE IT
	CALL	TYPDEC	;OUTPUT THE NUMBER OF DAYS
	MOVEI	T2,[ASCIZ/ days/]	;GET MORE TEXT
	JRST	STROUT		;SAY IT IS IN DAYS

EXDNON:	MOVEI	T2,[ASCIZ/None/]	;GET STRING
	JRST	STROUT		;OUTPUT AND RETURN




TYPDAT:	SETZ	T3,		;FULL OUTPUT
DATOUT:	JUMPE	T2,DATNON	;ZERO, GO TYPE NONE
	ODTIM			;OUTPUT IT
	 ERJMP	ERRSTR		;FAILED
	RET			;AND RETURN

DATNON:	MOVEI	T2,[ASCIZ/  Never/]	;GET TEXT
	JRST	STROUT		;OUTPUT IT AND RETURN




TYPAUT:	SKIPA	T3,[Z	(.GFAUT)]	;GET FUNCTION FOR AUTHOR
TYPLWR:	MOVSI	T3,.GFLWR	;GET FUNCTION FOR LAST WRITER
	PUSH	P,T3		;SAVE FUNCTION
	CALL	TYPHLF		;TYPE IT
	MOVEI	T2,[ASCIZ/ ==> /]	;GET TEXT
	CALL	STROUT		;TYPE IT
	MOVE	T2,T1		;MOVE BYTE POINTER
	POP	P,T1		;RESTORE FUNCTION CODE
	HRR	T1,JFN		;AND PUT IN JFN
	GFUST			;STORE THE DATA
	 ERJMP	ERRSTR		;CAN'T
	MOVE	T1,T2		;MOVE BYTE POINTER BACK
	RET			;DONE

TYPOFR:	CALL	OCTOUT		;OUTPUT REASON CODE
	MOVEI	T2,[ASCIZ/ - /]	;MORE TEXT
	CALL	STROUT		;OUTPUT IT
	LDB	T2,TABPTR(I)	;GET REASON AGAIN
	CAILE	T2,OFFMAX	;IS IT REASONABLE?
	SKIPA	T2,[ASCIZ/Unknown/]	;NO, GET STRING SAYING SO
	MOVE	T2,OFFTAB(T2)	;YES, GET GOOD STRING
	JRST	STROUT		;OUTPUT REASON


OFFTAB:	EXP	[ASCIZ/None/]				;(0) NOT OFFLINE
	EXP	[ASCIZ/File expired/]			;(1) IT EXPIRED
	EXP	[ASCIZ/Archive was requested/]		;(2) ARCHIVED
	EXP	[ASCIZ/Migration was requested/]	;(3) MIGRATED

	OFFMAX==.-OFFTAB		;HIGHEST KNOWN REASON FOR OFFLINE



TYPACT:	CALL	TYPHLF		;TYPE DATA
	MOVEI	T2,[ASCIZ/ ==> /]	;GET TEXT
	CALL	STROUT		;OUTPUT IT
	MOVE	T2,JFN		;GET JFN OF FILE
	MOVX	T3,FLD (.JSAOF,JS%ACT)	;GET BITS FOR ACCOUNT TYPEOUT
	JFNS			;STORE THE ACCOUNT STRING
	 ERJMP	ERRSTR		;FAILED
	RET			;DONE




TYPSIX:	JUMPN	T2,SIXOUT	;OUTPUT NAME IF THERE
	MOVEI	T2,[ASCIZ/None/]	;OTHERWISE GET THIS
	JRST	STROUT		;AND TYPE IT

	SUBTTL	ROUTINE TO SET PARAMETERS OF FILE



;THIS IS THE COMPLEMENTARY COMMAND TO VERBOSE.  WE ASK HIM WHAT HE
;WANTS TO CHANGE AND THEN WE DO IT WITH A CHFDB.  THE "SET" COMMAND.



CMDSET:	MOVEI	T2,[FLDDB. (.CMKEY,,SETTAB,<
>)]				;SET UP
	CALL	COMMND		;READ A KEYWORD
	MOVE	T2,(T2)		;GET DISPATCH ADDRESS
	CALL	(T2)		;CALL ROUTINE FOR THIS ARG
	IORI	F,FR.AGN	;SAY TO DO FILE AGAIN
	RET			;RETURN

SETTAB:	SETLEN,,SETLEN			;HEADER FOR TABLE
	AA	1ST-BACKUP-WORD,SET1BW	;FIRST BACKUP WORD
	AA	2ND-BACKUP-WORD,SET2BW	;SECOND BACKUP WORD
	AA	3RD-BACKUP-WORD,SET3BW	;THIRD BACKUP WORD
	AA	ACCOUNT,SETACT		;ACCOUNT
	AA	ARCHIVE-DESIRED,SETARC	;SET ARCHIVE STATUS
	AA	AUTHOR,SETAUT		;AUTHOR OF FILE
	AA	BYTE-COUNT,SETBYC	;SET COUNT OF BYTES
	AA	COUNT-OF-REFERENCES,SETRFC	;NUMBER OF REFERENCES
	AA	CREATION-DATE,SETCRV	;DATE FILE WAS CREATED
	AA	DATE-LAST-WRITTEN,SETWRT	;DATE FILE WAS WRITTEN
	AA	FILE-CLASS-FIELD,SETCLS	;SET FILE CLASS FIELD
	AA	FORTRAN-CARRIAGE-CONTROL,SETFOR	;SET FORTRAN CARRIAGE CONTROL
	AA	GENERATION-RETENTION-COUNT,SETRET	;RETENTION COUNT
	AA	INVISIBLE,SETINV	;SET FILE INVISIBLE
	AA	LAST-WRITER,SETLWR	;LAST WRITER
	AA	MODE-LAST-WRITTEN,SETMOD	;DATA MODE
	AA	NOT,SETNOT		;SET NOT ARGUMENT
	AA	P,PROTCM,CM%ABR+CM%INV	;ABBREVIATION OF PROTECTION
	AA	PAGE-COUNT,SETPAG	;SET PAGE COUNT
	AA	PERMANENT,SETPER	;SET FILE AS PERMANENT
PROTCM:	AA	PROTECTION,SETPRT	;SET FILE PROTECTION
	AA	REFERENCED-LAST-DATE,SETREF	;DATE WAS LAST REFERENCED
	AA	SAVED-BY-BACKUP-SYSTEM,SETSAV	;SAVED BY DUMPER
	AA	SIZE-OF-BYTES,SETBYS	;SET BYTE SIZE
	AA	SYSTEM-DATE-WRITTEN,SETCRE	;DATE WAS WRITTEN (SYSTEM)
	AA	TEMPORARY,SETTMP	;SET FILE AS TEMPORARY
	AA	USER-SETTABLE-WORD,SETUSW	;USER SETTABLE WORD
	AA	VISIBLE,SETVIS		;SET FILE VISIBLE
	AA	WRITE-COUNT,SETWRC	;NUMBER OF WRITES

	SETLEN==.-SETTAB-1		;NUMBER OF ENTRIES IN TABLE





SETNTB:	SETNLN,,SETNLN			;HEADER FOR NOT TABLE
	AA	ARCHIVE-DESIRED,SETNAR	;SET NOT ARCHIVED
	AA	FORTRAN-CARRIAGE-CONTROL,SETNFR ;SET NOT FORTRAN CARRIAGE CONTROL
	AA	PERMANENT,SETNPR	;SET NOT PERMANENT
	AA	SAVED-BY-BACKUP-SYSTEM,SETNSV	;SET NOT TO BE SAVED
	AA	TEMPORARY,SETNTE	;SET NOT TEMPORARY

	SETNLN==.-SETNTB-1		;NUMBER OF ENTRIES

;ROUTINES TO SET VARIOUS PARAMETERS OF THE FILE.  IF ANY ERROR
;ENCOUNTERED, THEY DO NOT RETURN, BUT INSTEAD TRAP TO ERRSTR.




SETPRT:	MOVEI	T2,[FLDDB. (.CMNUM,,^D8)]	;SET FOR OCTAL INPUT
	CALL	COMMND		;READ IT
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;END THE LINE
	TLNE	T4,-1		;GIVE ILLEGAL VALUE?
	 ILLARG	Illegal protection specified
	MOVSI	T1,.FBPRT	;SET UP FDB INDEX
	MOVEI	T2,-1		;AND MASK
	MOVE	T3,T4		;MOVE PROTECTION TO RIGHT AC

CHGFDB:	HRR	T1,JFN		;PUT IN JFN OF FILE TO CHANGE
	CHFDB			;CHANGE THE PARAMETER
	 ERJMP	ERRSTR		;FAILED
	RET			;DID IT, RETURN



SETBYC:	MOVEI	T2,[FLDDB. (.CMNUM,,^D10)]	;SET UP
	CALL	COMMND		;READ VALUE
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;CONFIRM THE COMMAND
	MOVE	T3,T4		;PUT VALUE IN RIGHT AC
	SETO	T2,		;MASK IS ALL ONES
	MOVSI	T1,.FBSIZ	;OFFSET INTO THE FDB
	JRST	CHGFDB		;GO CHANGE IT AND RETURN



SETBYS:	MOVEI	T2,[FLDDB. (.CMNUM,,^D10)]	;SET UP
	CALL	COMMND		;READ THE NUMBER
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;CONFIRM THE COMMAND
	MOVX	T2,FB%BSZ	;GET MASK
	MOVSI	T1,.FBBYV	;AND INDEX INTO FDB
	MOVE	T3,T4		;PUT VALUE IN RIGHT AC
	ROT	T3,^D24		;POSITION THE NUMBER
	TDNE	T3,[-1-FB%BSZ]	;TYPED ILLEGAL VALUE?
	 ILLARG	Illegal byte size specified
	JRST	CHGFDB		;IS OK, GO CHANGE IT

SETRET:	MOVEI	T2,[FLDDB. (.CMNUM,,^D10)]	;GET READY
	CALL	COMMND		;READ VALUE
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;CONFIRM THE VALUE
	MOVSI	T1,.FBBYV	;SET UP INDEX
	MOVX	T2,FB%RET	;GET MASK
	MOVE	T3,T4		;PUT VALUE IN RIGHT AC
	ROT	T3,-6		;POSITION IT
	TDNE	T3,[-1-FB%RET]	;EXTRA JUNK?
	 ILLARG	Illegal generation retention count specified
	JRST	CHGFDB		;IS OK, GO CHANGE IT



SETNOT:	MOVEI	T2,[FLDDB. (.CMKEY,,SETNTB,<
>)]				;SET UP
	CALL	COMMND		;READ KEYWORD
	MOVE	T4,(T2)		;GET ADDRESS TO GO TO
	CALL	CONFRM		;END THE COMMAND
	JRST	(T4)		;GO DO THE FUNCTION



SETPER:	CALL	CONFRM		;END THE COMMAND
	MOVSI	T1,.FBCTL	;GET ADDRESS TO SET
	MOVX	T2,FB%PRM	;GET MASK
	MOVE	T3,T2		;AND VALUE
	JRST	CHGFDB		;GO CHANGE VALUE



SETTMP:	CALL	CONFRM		;CONFIRM THE COMMAND
	MOVSI	T1,.FBCTL	;ADDRESS TO CHANGE
	MOVX	T2,FB%TMP	;AND BIT TO CHANGE
	MOVE	T3,T2		;COPY IT
	JRST	CHGFDB		;GO DO IT



SETNPR:	SKIPA	T2,[EXP	FB%PRM]	;GET BIT TO CLEAR
SETNTE:	MOVX	T2,FB%TMP	;OR OTHER BIT
	MOVSI	T1,.FBCTL	;ADDRESS TO CHANGE
	SETZ	T3,		;CLEAR THE BIT
	JRST	CHGFDB		;DO DO IT

SETUSW:	MOVEI	T2,[FLDDB. (.CMNUM,,^D8)]	;FUNCTION FOR OCTAL
	CALL	COMMND		;READ IT
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;END LINE
	MOVSI	T1,.FBUSW	;WORD TO SET
	SETO	T2,		;WHOLE WORD
	MOVE	T3,T4		;GET VALUE
	JRST	CHGFDB		;GO DO IT



SETWRT:	SKIPA	T5,[.RSWRT]	;GET CODE FOR DATE LAST WRITTEN
SETCRV:	MOVEI	T5,.RSCRV	;GET CODE FOR CREATION DATE
	JRST	SETDAT		;GO SET THE DATE

SETREF:	SKIPA	T5,[.RSREF]	;GET CODE FOR DATE LAST REFERENCED
SETCRE:	MOVEI	T5,.RSCRE	;GET CODE FOR SYSTEM DATE OF WRITE
SETDAT:	MOVEI	T2,[FLDDB. (.CMTAD,,CM%IDA+CM%ITM)]	;GET SET
	CALL	COMMND		;READ DATE AND TIME
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;CONFIRM THE COMMAND
	HRRZ	T1,JFN		;GET JFN OF FILE
	MOVEI	T2,DATBLK	;POINT TO BLOCK OF DATES
	MOVE	T3,[DATBLK,,DATBLK+1]	;GET READY
	SETOM	DATBLK		;CLEAR FIRST WORD OF BLOCK
	BLT	T3,DATBLK+3	;CLEAR REST ALSO
	MOVEI	T3,4		;GET NUMBER OF ARGUMENTS
	MOVEM	T4,DATBLK(T5)	;STORE PROPER DATE AWAY
	SFTAD			;SET IT
	 ERJMP	ERRSTR		;FAILED
	RET			;OK, RETURN




SETAUT:	SKIPA	T4,[.SFAUT]	;GET CODE FOR AUTHOR
SETLWR:	MOVEI	T4,.SFLWR	;OR FOR LAST WRITER
	MOVEI	T2,[FLDDB. (.CMUSR)]	;FUNCTION TO READ USER NAME
	CALL	COMMND		;READ IT
	MOVE	T2,[ATMBUF,,TMPBUF]	;GET READY
	BLT	T2,TMPBUF+TXTLEN/5	;COPY ATOM BUFFER
	CALL	CONFRM		;CONFIRM THE COMMAND
	MOVSI	T1,(T4)		;SET UP CODE
	HRR	T1,JFN		;AND JFN OF FILE
	HRROI	T2,TMPBUF	;POINT TO USER NAME
	SFUST			;SET AUTHOR OR LAST WRITER
	 ERJMP	ERRSTR		;FAILED
	RET			;OK, RETURN

SETPAG:	MOVEI	T2,[FLDDB. (.CMNUM,,^D10)]	;SET UP
	CALL	COMMND		;READ IT
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;EAT REST OF LINE
	MOVSI	T1,.FBBYV	;GET OFFSET IN FDB
	MOVX	T2,FB%PGC	;AND MASK
	MOVE	T3,T4		;GET ARG
	TLNE	T3,-1		;ILLEGAL?
	 ILLARG	Illegal page count specified
	JRST	CHGFDB		;NO, GO SET IT



SET1BW:	JSP	T4,SETBAC	;FIRST BACKUP WORD
SET2BW:	JSP	T4,SETBAC	;SECOND WORD
SET3BW:	JSP	T4,SETBAC	;AND THIRD
SETBAC:	SUBI	T4,SET2BW	;COMPUTE OFFSET OF WORD TO SET
	MOVEI	T2,[FLDDB. (.CMNUM,,^D8)]	;GET READY
	CALL	COMMND		;READ IT
	MOVE	T5,T2		;SAVE IT
	CALL	CONFRM		;THEN EAT END OF LINE
	MOVSI	T1,.FBBK0(T4)	;GET WORD TO BE CHANGED
	SETO	T2,		;THE WHOLE WORD
	MOVE	T3,T5		;GET THE VALUE
	JRST	CHGFDB		;GO SET IT



SETACT:	MOVEI	T2,[FLDDB. (.CMFLD,,,<account string>)]	;SET UP
	CALL	COMMND		;DO IT
	MOVE	T2,[ATMBUF,,TMPBUF]	;GET SET
	BLT	T2,TMPBUF+TXTLEN/5	;COPY TEXT TO GOOD PLACE
	CALL	CONFRM		;THEN LOOK FOR END OF LINE
	HRRZ	T1,JFN		;GET JFN OF FILE
	HRROI	T2,TMPBUF	;POINT TO TEXT
	SACTF			;SET THE ACCOUNT STRING
	 ERJMP	ERRSTR		;FAILED
	RET			;OK, RETURN

SETARC:	CALL	CONFRM		;CONFIRM THE LINE
	SKIPA	T3,[EXP .ARSET]	;GET VALUE TO SAY DO ARCHIVE
SETNAR:	MOVX	T3,.ARCLR	;OR VALUE TO SAY DON'T ARCHIVE
	HRRZ	T1,JFN		;GET THE JFN
	MOVEI	T2,.ARRAR	;AND FUNCTION TO REQUEST ARCHIVING
	ARCF%			;DO THE WORK
	 ERJMP	ERRSTR		;FAILED
	RET			;OK



SETMOD:	MOVEI	T2,[FLDDB. (.CMNUM,,^D8)]	;SET TO READ OCTAL
	CALL	COMMND		;DO IT
	MOVE	T4,T2		;SAVE NUMBER
	CALL	CONFRM		;THEN EAT LINE
	MOVSI	T1,.FBBYV	;GET WORD
	MOVX	T2,FB%MOD	;AND MASK
	MOVE	T3,T4		;PUT ARG IN RIGHT AC
	ROT	T3,^D18		;POSITION IT CORRECTLY
	TDNE	T3,[-1-FB%MOD]	;ILLEGAL ARGUMENT?
	 ILLARG	Illegal data mode specified
	JRST	CHGFDB		;OK, GO SET IT




SETVIS:	TDZA	T4,T4		;CLEAR THE FLAG
SETINV:	MOVX	T4,FB%INV	;OR GET THE FLAG
	CALL	CONFRM		;CONFIRM THE LINE
	MOVSI	T1,.FBCTL	;WANT TO CHANGE FLAG WORD
	MOVX	T2,FB%INV	;MASK IS FOR THE BIT
	MOVE	T3,T4		;GET THE FLAG
	JRST	CHGFDB		;DO THE WORK

SETRFC:	SKIPA	T5,[777777]	;GET MASK FOR REFERENCE COUNT
SETWRC:	MOVSI	T5,-1		;OR FOR WRITE COUNT
	MOVEI	T2,[FLDDB. (.CMNUM,,^D10)]	;GET READY
	CALL	COMMND		;READ NUMBER
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;CONFIRM COMMAND
	MOVSI	T1,.FBCNT	;GET WORD TO CHANGE
	MOVE	T2,T5		;GET HALFWORD WE ARE SETTING
	MOVE	T3,T4		;GET VALUE
	TLNE	T3,-1		;ILLEGAL?
	 ILLARG	Illegal count specified
	TRNN	T2,-1		;VALUE GOES IN LEFT HALF?
	MOVSI	T3,(T3)		;YES, PUT IT THERE
	JRST	CHGFDB		;AND GO SET IN FDB




SETSAV:	CALL	CONFRM		;CONFIRM THE LINE
	MOVSI	T1,.FBCTL	;GET WORD BIT IS IN
	MOVX	T2,FB%NOD	;AND MASK
	SETZ	T3,		;SET TO CLEAR BIT
	JRST	CHGFDB		;GO DO IT



SETNSV:	MOVSI	T1,.FBCTL	;GET WORD TO CHANGE
	MOVX	T2,FB%NOD	;AND BIT
	SETO	T3,		;SAY TO TURN IT ON
	JRST	CHGFDB		;GO DO IT




SETCLS:	MOVEI	T2,[FLDDB. (.CMNUM,,^D8)]	;SET UP
	CALL	COMMND		;PARSE IT
	MOVE	T4,T2		;SAVE IT
	CALL	CONFRM		;END THE LINE
	MOVSI	T1,.FBCTL	;GET OFFSET IN FDB
	MOVX	T2,FB%FCF	;AND MASK
	MOVS	T3,T4		;AND VALUE
	TDNE	T3,[-1-FB%FCF]	;ILLEGAL VALUE?
	 ILLARG	Illegal class field specified
	JRST	CHGFDB		;OK, GO SET IT



SETFOR:	CALL	CONFRM		;CONFIRM THE LINE
	SKIPA	T3,[FB%FOR]	;SAY TO TURN ON THE BIT
SETNFR:	SETZ	T3,		;SAY TO TURN IT OFF
	MOVSI	T1,.FBCTL	;GET WORD TO CHANGE
	MOVX	T2,FB%FOR	;AND MASK
	JRST	CHGFDB		;GO DO IT

	SUBTTL	ROUTINE TO PRINT FILE ON LINE PRINTER



;THIS ROUTINE COPIES THE FILE TO DEVICE LPT:.  THE "LIST" COMMAND.
;IS ESSENTIALLY THE SAME AS THE COMMAND "COPY (TO) LPT:"




CMDLST:	MOVEI	T2,[ASCIZ/TO LPT/]	;GET NOISE TEXT
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;CONFIRM IT
	MOVE	T1,[POINT 7,TMPBUF]	;POINT TO A BUFFER
	MOVEI	T2,[ASCIZ/LPT:/]	;GET DEVICE
	CALL	STROUT		;COPY STRING TO BUFFER
	HRRZ	T2,JFN		;GET JFN OF FILE
	MOVE	T3,[1B8+1B11+JS%PAF]	;GET FLAGS
	JFNS			;STORE FILENAME AND EXTENSION
	 ERJMP	ERRSTR		;FAILED
	IDPB	ZZ,T1		;MAKE ASCIZ STRING
	MOVX	T1,GJ%SHT+GJ%NEW+GJ%PHY	;GET BITS
	HRROI	T2,TMPBUF	;POINT TO BUFFER
	GTJFN			;GET A JFN
	 ERJMP	ERRSTR		;FAILED
	HRRZM	T1,JFNOUT	;AND SAVE IT
	JRST	DOCOPY		;AND JOIN COPY CODE

	SUBTTL	ROUTINE TO COPY A FILE


;THIS ROUTINE IS USED TO COPY THE FILE WE ARE CURRENTLY WORKING
;ON TO ANOTHER FILE.  THE DEFAULT DEVICE AND DIRECTORY IS THE
;CONNECTED DIRECTORY, WHILE THE DEFAULT FILE NAME IS THE SAME
;AS THE INPUT.  CAN ONLY COPY TO ANOTHER DISK FILE.  THE "COPY"
;COMMAND.



CMDCPY:	MOVEI	T2,[ASCIZ/TO/]	;GET NOISE
	CALL	NOISE		;PROCESS IT
	CALL	DEFALN		;DEFAULT JUST THE FILE NAME
	MOVEI	T1,KEYBLK	;RESET POINTER TO COMND BLOCK
	MOVEI	T2,[FLDDB. (.CMFIL)]	;FILE SPEC FUNCTION
	CALL	COMMND		;READ IT
	HRRZM	T2,JFNOUT	;SAVE OUTPUT JFN
	CALL	CONFRM		;CONFIRM THE COMMAND



DOCOPY:	CALL	OPEN		;OPEN THE FILE FOR READING
	HRRZ	T1,JFN		;GET JFN AGAIN
	MOVSI	T2,.FBLWR+1	;GET READY TO READ FDB AGAIN
	MOVEI	T3,FDB		;SINCE RACE CONDITION COULD HAPPEN
	GTFDB			;DO IT
	 ERJMP	ERRSTR		;CAN'T
	MOVE	T1,JFNOUT	;GET OUTPUT FILE
	MOVX	T2,OF%WR+OF%NWT	;AND FLAGS
	OPENF			;OPEN IT FOR WRITING
	 ERJMP	ERRSTR		;CAN'T
	IORI	F,FR.OP2	;REMEMBER HAVE IT OPEN
	SETOM	PAGE		;INITIALIZE PAGE COUNTER

;HERE TO LOOP OVER ALL PAGES, DOING THE COPY:


CPYLOP:	CALL	PAGMAP		;MAP IN THE NEXT PAGE
	 JRST	CPYDON		;NO MORE, GO FINISH UP
	MOVS	T1,PAGADR	;GET ADDRESS TO COPY FROM
	HRR	T1,PAGAD2	;AND ADDRESS TO COPY TO
	MOVE	T2,PAGAD2	;GET ADDRESS OF OUTPUT PAGE
	BLT	T1,PAGSIZ-1(T2)	;COPY IT ALL
	MOVE	T1,PAGNU2	;GET PAGE NUMBER
	HRLI	T1,.FHSLF	;AND MY OWN PROCESS HANDLE
	MOVE	T2,PAGE		;GET PAGE OF FILE WE ARE WRITING
	HRL	T2,JFNOUT	;AND JFN OF FILE
	MOVX	T3,PM%WR	;WANT TO WRITE THE PAGE
	PMAP			;OUTPUT THE PAGE
	 ERJMP	ERRSTR		;ERROR
	JRST	CPYLOP		;THEN LOOP FOR NEXT PAGE




;HERE WHEN ALL DONE, TO CLOSE FILES AND UPDATE FDBS:


CPYDON:	MOVE	T1,JFNOUT	;GET JFN AGAIN
	HRLI	T1,.FBSIZ(CF%NUD)	;SET BIT AND OFFSET
	SETO	T2,		;WANT WHOLE WORD CHANGED
	MOVE	T3,FDB+.FBSIZ	;GET INFORMATION FROM FILE
	CHFDB			;SET IT
	 ERJMP	ERRSTR		;FAILED
	HRLI	T1,.FBCTL(CF%NUD)	;FLAG WORD, DON'T WRITE TO DISK YET
	MOVX	T2,FB%FOR	;COPY ONLY THE FORTRAN BIT
	MOVE	T3,FDB+.FBCTL	;GET FLAGS FROM OLD FILE
	CHFDB			;SET IN THE NEW FILE
	 ERJMP	.+1		;COULDN'T, MUST BE OLD MONITOR
	HRLI	T1,.FBBYV	;GET OFFSET TO CHANGE NOW
	MOVX	T2,FB%BSZ	;WANT TO CHANGE BYTE SIZE ONLY
	MOVE	T3,FDB+.FBBYV	;GET DATA FROM INPUT FILE
	CHFDB			;SET THAT TOO
	 ERJMP	ERRSTR		;CAN'T
	HRRZ	T1,JFNOUT	;GET JFN
	CLOSF			;CLOSE THE FILE
	 ERJMP	ERRSTR		;ERROR
	ANDCMI	F,FR.OP2	;FILE NO LONGER OPENED
	SETZM	JFNOUT		;AND JFN NO LONGER ASSIGNED
	RET			;RETURN

	SUBTTL	ROUTINE TO RENAME A FILE


;COMMAND TO RENAME A FILE TO ANOTHER NAME.  NOTICE THAT ALL DEFAULTS
;WILL BE THAT OF THE INPUT FILE, EVEN THE DEVICE AND DIRECTORY, FOR
;THAT IS WAS IS GENERALLY WANTED.  THE "RENAME" COMMAND.



CMDREN:	MOVEI	T2,[ASCIZ/TO/]	;GET NOISE WORD
	CALL	NOISE		;PARSE IT
	CALL	DEFALT		;SET UP FULL DEFAULT
	MOVEI	T1,KEYBLK	;POINT TO COMND BLOCK TO USE
	MOVEI	T2,[FLDDB. (.CMFIL)]	;FUNCTION FOR OUTPUT FILE
	CALL	COMMND		;READ IT
	HRRZM	T2,JFNOUT	;SAVE OUTPUT JFN
	CALL	CONFRM		;LOOK FOR THE END OF LINE
	MOVE	T5,SPCPTR	;SAVE CURRENT SPEC POINTER
	CALL	NEXT		;ADVANCE TO NEXT SPEC SO CAN DO RENAME
	 JFCL			;DON'T CARE IF NO MORE FILES
	IORI	F,FR.ADV	;REMEMBER WE ADVANCED ALREADY
	MOVE	T1,JFN		;GET JFN OF FILE TO RENAME
	MOVE	T2,JFNOUT	;AND JFN OF FILE TO RENAME TO
	RNAMF			;RENAME THE FILE
	 ERJMP	ERRSTR		;FAILED, RETURN
	SETZM	JFN		;RENAME CLEARS THE JFN
	MOVE	T1,T5		;GET POINTER FOR SPEC WE RENAMED
	IDIVI	T1,MAXUP	;GET INDEX INTO FLAG TABLE
	HLLZS	FLAGS(T2)	;CLEAR RIGHT HALF OF FLAG WORD
	RET			;RETURN

	SUBTTL	ROUTINE TO BACK UP TO A PREVIOUS FILE



;CALLED TO GO BACK AND REDO THE PREVIOUS FILE SPECIFICATION BEFORE
;THE PRESENT ONE.  THE "BACKUP" COMMAND.  USED IF THE USER TYPED
;A CRLF FOR A FILE, AND REGRETTED IT.  CAN ONLY BACK UP A CERTAIN
;NUMBER OF FILES TOTAL, SINCE WE HAVE TO STORE ALL THE FILE SPECS.



CMDBAC:	MOVEI	T2,[ASCIZ/BY/]	;GET NOISE
	CALL	NOISE		;EAT IT UP
	MOVEI	T2,[FLDDB. (.CMNUM,,^D10,,<1>)]	;SET UP TO GET NUMBER
	CALL	COMMND		;READ ARGUMENT
	MOVEM	T2,BACTRY	;SAVE NUMBER OF SPECS TO BACK UP BY
	MOVEI	T2,[ASCIZ/FILES/]	;MORE NOISE
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;LOOK FOR A GOOD END OF LINE
	MOVEI	T1,-1		;GET A LARGE VALUE
	SKIPGE	BACTRY		;DID HE SPECIFY A NEGATIVE NUMBER?
	MOVEM	T1,BACTRY	;YES, REPLACE VALUE
	SETZ	T1,		;CLEAR NUMBER OF FILES BACKED UP SO FAR



BACLOP:	SKIPG	BACTRY		;BACKED UP ALL FILES WE ASKED FOR?
	JRST	BACDON		;YES, GO SET THINGS NOW
	MOVE	T2,BACNUM	;GET NUMBER OF FILES ALREADY BACKED UP
	ADD	T2,T1		;ADD NUMBER WE ARE ALSO BACKING UP BY
	CAIGE	T2,MAXUP-1	;MAKE SURE AREN'T EXCEEDING OUR STORAGE
	CAML	T1,SPCPTR	;AND THAT WE AREN'T GOING OFF THE TOP
	JRST	BACDON		;TOO FAR BACK, STOP NOW
	MOVE	T2,SPCPTR	;GET CURRENT SPEC POINTER
	SUB	T2,T1		;COMPUTE POINTER TO SPEC BACKING UP TO
	IDIVI	T2,MAXUP	;GET INDEX INTO FLAG TABLE
	MOVE	T2,FLAGS(T3)	;GET FLAGS FOR THIS SPEC
	TLNE	T2,(GN%STR+GN%DIR)	;CHANGING DIRECTORIES?
	IORI	F,FR.HDR	;YES, REMEMBER TO TYPE A HEADER
	SOSGE	T3		;BACK UP TO PREVIOUS FLAG WORD
	MOVEI	T3,MAXUP-1	;WRAPPED AROUND, RESET TO END
	MOVE	T2,FLAGS(T3)	;GET FLAGS FOR SPEC BACKING UP TO
	TRNE	T2,-1		;WAS THAT SPEC EXPUNGED OR RENAMED?
	SOS	BACTRY		;NO, THEN DECREMENT COUNT OF FILES TO DO
	AOJA	T1,BACLOP	;COUNT BACKUP AND LOOK AT NEXT FILE

;HERE WHEN WE HAVE BACKED UP ALL THE AMOUNT WE WERE SUPPOSED TO.
;FIX THINGS UP SO WE WILL START AT THE RIGHT PLACE.



BACDON:	ADDM	T1,BACNUM	;ADD TO NUMBER OF SPECS ALREADY BACKED UP
	MOVN	T1,T1		;GET NEGATIVE
	ADDM	T1,SPCPTR	;DECREMENT SPEC POINTER BY AMOUNT ALSO
	CALL	CLOSE		;RELEASE THE PRESENT JFN
	CALL	CPYJFN		;GET A NEW ONE FOR WHERE WE ARE
	IORI	F,FR.AGN	;SAY WE WANT TO DO FILE "AGAIN"
	RET			;AND RETURN





	SUBTTL	ROUTINE TO DELETE AND EXPUNGE A FILE




;ROUTINE TO EXPUNGE A FILE TOTALLY.  THE "EXPUNGE" COMMAND.
;NO WAY TO GET THE FILE BACK WITH THIS COMMAND, SO USUALLY
;PEOPLE SHOULD USE THE DELETE COMMAND INSTEAD.



CMDEXP:	MOVEI	T2,[ASCIZ/!!/]	;GET NOISE WORD TO WARN HIM
	CALL	NOISE		;PARSE IT
	CALL	CONFRM		;MAKE SURE CRLF WAS TYPED
	MOVE	T5,SPCPTR	;GET POINTER FOR PRESENT SPEC
	CALL	NEXT		;ADVANCE TO NEXT FILE NOW SO CAN EXPUNGE
	 JFCL			;DON'T CARE IF NO MORE FILES
	IORI	F,FR.ADV	;SAY WE ADVANCED ALREADY
	MOVE	T1,JFN		;GET JFN OF FILE
	HRLI	T1,(DF%EXP)	;SET THE EXPUNGE BIT
	DELF			;DELETE AND EXPUNGE THE FILE
	 ERJMP	ERRSTR		;FAILED, RETURN
	SETZM	JFN		;JFN WAS RELEASED BY THE EXPUNGE
	MOVE	T1,T5		;GET POINTER TO SPEC WE DELETED
	IDIVI	T1,MAXUP	;COMPUTE OFFSET INTO FLAG WORD
	HLLZS	FLAGS(T2)	;CLEAR RIGHT HALF
	RET			;AND RETURN

	SUBTTL	ROUTINE TO COPY A JFN AND SAVE SPECIFICATION



;CALLED TO STORE THE FULL FILE SPECIFICATION FOR A FILE
;CURRENTLY POINTED TO MY THE MAIN JFN, AND TO GET ANOTHER JFN
;ON THE FILE WHICH WE WILL ACTUALLY USE.



CPYJFN:	MOVE	T3,SPCPTR	;GET STORAGE POINTER
	IDIVI	T3,MAXUP	;DIVIDE BY NUMBER OF SPECS
	IMULI	T4,SPECSZ	;MULTIPLY BY SIZE OF A SPEC
	SKIPLE	BACNUM		;BACKED UP ANY FILES?
	JRST	NEWJFN		;YES, JUST GO REGET A JFN
	HRROI	T1,SPECS(T4)	;POINT TO STORAGE FOR SPEC
	HRRZ	T2,GJFN		;GET JFN
	MOVE	T3,[1B2+1B5+1B8+1B11+1B14+JS%PAF]	;GET BITS
	JFNS			;STORE THE SPECIFICATION
	 ERJMP	ERRSTR		;FAILED
	IDPB	ZZ,T1		;STORE NULL TO MAKE ASCIZ

NEWJFN:	MOVEI	T1,NEWBLK	;POINT TO GTJFN BLOCK
	HRROI	T2,SPECS(T4)	;POINT TO STRING
	GTJFN			;GET ANOTHER JFN FOR FILE
	 ERJMP	ERRSTR		;CAN'T
	MOVEM	T1,JFN		;SAVE JFN FOR USE LATER
	RET			;OK, RETURN

	SUBTTL	ROUTINES TO DEFAULT OUTPUT SPECIFICATIONS



;CALLED TO SET UP COMND BLOCK SO THAT THE DEFAULT SPEC IS
;THE SAME AS THE INPUT FILE.  CALLING DEFALT SETS UP DEFAULTS
;ON EVERYTHING, CALLING DEFALN ONLY SETS UP DEFAULT FOR
;FILE NAME AND EXTENSION.




DEFALN:	SETZM	KEYJFB+.GJDEV	;CLEAR DEFAULT DEVICE
	SETZM	KEYJFB+.GJDIR	;AND DEFAULT DIRECTORY
	HRRZ	T2,JFN		;GET JFN OF INPUT FILE
	JRST	DEFAL1		;AND GO STORE OTHER DEFAULTS


DEFALT:	HRROI	T1,DFTDEV	;POINT TO DEVICE STORAGE
	MOVEM	T1,KEYJFB+.GJDEV	;SAVE IN COMND BLOCK
	HRRZ	T2,JFN		;GET JFN OF INPUT FILE
	MOVX	T3,FLD (.JSAOF,JS%DEV)	;SET UP
	JFNS			;STORE DEVICE DEFAULT
	 ERJMP	ERRSTR		;FAILED
	IDPB	ZZ,T1		;MAKE SURE NULL FOLLOWS
	HRROI	T1,DFTDIR	;POINT TO DIRECTORY STORAGE
	MOVEM	T1,KEYJFB+.GJDIR	;SAVE IN COMND BLOCK
	MOVX	T3,FLD (.JSAOF,JS%DIR)	;SET UP
	JFNS			;STORE DIRECTORY DEFAULT
	 ERJMP	ERRSTR		;FAILED
	IDPB	ZZ,T1		;APPEND A NULL

DEFAL1:	HRROI	T1,DFTNAM	;POINT TO NAME STORAGE
	MOVX	T3,FLD (.JSAOF,JS%NAM)	;SET UP
	JFNS			;STORE FILE NAME DEFAULT
	 ERJMP	ERRSTR		;LOSE
	IDPB	ZZ,T1		;APPEND A NULL
	HRROI	T1,DFTTYP	;POINT TO FILE "TYPE" STORAGE
	MOVX	T3,FLD (.JSAOF,JS%TYP)	;SET UP
	JFNS			;STORE IT
	 ERJMP	ERRSTR		;LOSE
	IDPB	ZZ,T1		;AND APPEND A NULL
	RET			;THEN RETURN

	SUBTTL	ROUTINE TO ADVANCE TO NEXT FILE


;ROUTINE TO ADVANCE TO THE NEXT FILE.  THIS ROUTINE WILL
;DO THE GNJFN ON THE MAIN JFN, AND SAVE AWAY THE FLAG BITS
;IN THE STORAGE BLOCK.  SKIP RETURN IF HAVE A NEW FILE, NON-SKIP
;IF HAVE LOOKED AT ALL FILES.




NEXT:	TRZN	F,FR.ADV	;ALREADY ADVANCED TO NEXT SPEC?
	JRST	NEXTDO		;NO, GO DO IT NOW
	SKIPG	BACNUM		;BACKED UP ANY FILES?
	SKIPE	GJFN		;OR MORE FILES TO DO?
CPOPJ1:	AOS	(P)		;YES, SKIP RETURN
CPOPJ:	RET			;RETURN

NEXTDO:	AOS	T2,SPCPTR	;INCREMENT TO NEXT SPEC
	IDIVI	T2,MAXUP	;GET MODULO NUMBER OF SPECS
	SKIPLE	BACNUM		;BACKED UP ANY FILES?
	JRST	NXTBAC		;YES, GO DO THAT
	SETZM	FLAGS(T3)	;CLEAR THE FLAG WORD FOR THE SPEC

NEXTGT:	MOVE	T1,GJFN		;GET JFN AND FLAG BITS
	GNJFN			;ADVANCE TO NEXT FILE
	 ERJMP	NEXTDN		;ERROR, GO SEE IF FINISHED
	IORM	T1,FLAGS(T3)	;STORE THE FLAGS FOR THIS SPEC
	TLNE	T1,(GN%STR+GN%DIR)	;NEED A NEW HEADER?
	IORI	F,FR.HDR	;YES, REMEMBER TO TYPE IT
	CALL	CHKNXD		;SEE IF WE HAVE SKIPPED TO WANTED FILE
	JRST	NEXTGT		;NO, KEEP LOOKING THEN
	RETSKP			;YES, RETURN WITH IT

NEXTDN:	HRRZ	T4,GJFN		;GET THE JFN
	SETZM	GJFN		;AND CLEAR IT
	CAIE	T1,GNJFX1	;DID WE REALLY RUN OUT OF FILES?
	JRST	ERRSTR		;NOPE, GO DIE
	RET			;YES, RETURN

NXTBAC:	MOVE	T1,FLAGS(T3)	;GET FLAGS FOR THIS FILE
	TLNE	T1,(GN%STR+GN%DIR)	;NEED A NEW HEADER?
	IORI	F,FR.HDR	;YES, REMEMBER THAT
	TRNE	T1,-1		;CHECK FOR FILE NO LONGER AVAILABLE
	CALL	CHKNXT		;SEE IF WENT TO DESIRED FILE YET?
	SOSA	T1,BACNUM	;NO, DECREMENT COUNT OF BACKED UP FILES
	RETSKP			;YES, SKIP RETURN
	JRST	NEXT		;SEE IF DONE YET

	SUBTTL	ROUTINE TO SEE IF A FILE IS WANTED



;ROUTINE TO SEE IF WE ARE SATISFIED WITH A FILE FOUND BY GNJFN.
;CALLED WITH BITS IN AC T1 DESCRIBING WHICH PARTS OF A SPECIFICATION
;HAVE CHANGED.  SKIP RETURN IF CONDITION IS SATISFIED.



CHKNXD:	SKIPN	T2,INIJFN	;STILL SEARCHING FOR INITIAL SPEC?
	JRST	CHKNXI		;NO, SKIP THIS THEN
	MOVEM	T1,GNBITS	;SAVE THE BITS
	MOVEI	T1,.WLJFN	;WANT TO COMPARE THE JFNS
	HRRZ	T3,GJFN		;JFN OF CURRENT FILE
	WILD%			;ASK MONITOR IF THEY MATCH
	 ERJMP	ERRSTR		;FAILED
	TXNE	T1,WL%DEV!WL%DIR!WL%NAM!WL%EXT!WL%GEN	;FOUND INITIAL SPEC?
	RET			;NOT YET, GO TO NEXT FILE
	HRRZ	T1,INIJFN	;FOUND STARTING POINT, GET JFN
	SETZM	INIJFN		;THEN CLEAR IT
	RLJFN			;AND RELEASE IT
	 ERJMP	ERRSTR		;FAILED
	MOVE	T1,GNBITS	;RESTORE BITS


CHKNXI:	CALL	CHKNXT		;SEE IF HAVE TO SKIP SOME FILES
	 RET			;YES, RETURN
	TXNN	F,FL.DAL-FL.DDL-FL.DIV	;NEED TO LOOK AT THE FDB?
	RETSKP			;NO, SHOW THE FILE
	HRRZ	T1,GJFN		;GET JFN OF FILE
	MOVE	T2,[1,,.FBCTL]	;ONE WORD TO BE READ
	MOVEI	T3,T3		;READ INTO AC T3
	GTFDB			;GET STATUS BITS FOR THE FILE
	 ERJMP	ERRSTR		;FAILED
	TXNE	F,FL.DON	;ALLOWING ONLINE FILES?
	TXNE	T3,FB%OFF	;NO, IS THIS FILE OFFLINE?
	SKIPA			;YES, OK
	RET			;NO, DON'T WANT THIS ONE
	TXNE	F,FL.DOF	;ALLOWING OFFLINE FILES?
	TXNN	T3,FB%OFF	;NO, IS THIS FILE ONLINE?
	SKIPA			;YES, OK
	RET			;NO, DON'T WANT THIS ONE
	TXNE	F,FL.DUD	;ALLOWING UNDELETED FILES?
	TXNE	T3,FB%DEL	;NO, IS THIS FILE DELETED?
	SKIPA			;YES, OK
	RET			;NO, DON'T WANT THIS ONE
	TXNE	F,FL.DVS	;ALLOWING VISIBLE FILES?
	TXNE	T3,FB%INV	;NO, IS THIS FILE INVISIBLE?
	AOS	(P)		;YES, WE WANT IT
	RET			;NO WE DON'T

;SUBROUTINE TO SEE IF WE HAVE SKIPPED THE FILE TYPE, NAME, DIRECTORY,
;OR STRUCTURE YET.  SKIP RETURN IF SO.


CHKNXT:	TRNN	F,FR.NXT	;WANTS TO SKIP TO NEXT FILE TYPE?
	JRST	NEXT1		;NO, GO ON
	TXNN	T1,GN%STR+GN%DIR+GN%NAM+GN%EXT	;DID IT CHANGE?
	RET			;NO, LOOK AT NEXT FILE


NEXT1:	TRNN	F,FR.NXF	;WANTS TO SKIP TO NEXT FILENAME?
	JRST	NEXT2		;NO, GO ON
	TXNN	T1,GN%STR+GN%DIR+GN%NAM	;YES, DID IT CHANGE?
	RET			;NO, WANT NEXT FILE


NEXT2:	TRNN	F,FR.NXD	;WANTS TO SKIP TO NEXT DIRECTORY?
	JRST	NEXT3		;NO, SKIP ON
	TXNN	T1,GN%STR+GN%DIR	;YES, DID IT CHANGE?
	RET			;NOPE, KEEP WANTING NEW FILE


NEXT3:	TRNN	F,FR.NXS	;WANTS TO SKIP TO NEXT STRUCTURE?
	JRST	NEXT4		;NO, SKIP ON
	TXNN	T1,GN%STR	;YES, DID STRUCTURE CHANGE?
	RET			;NO, RETURN


NEXT4:	TXZ	F,FR.NXS+FR.NXD+FR.NXF+FR.NXT	;ALL DONE SKIPPING
	RETSKP			;GOOD RETURN

	SUBTTL	ROUTINE TO OPEN THE FILE FOR READING




;THIS ROUTINE GETS THE FILE OPENED FOR READING ONLY.  WE TRY TO
;OPEN THE FILE FIRST WITH EXCLUSIVE ACCESS, IF THAT FAILS THEN
;WE TRY SIMULTANEOUS ACCESS.  NO RETURN IF FAIL TO GET FILE.





OPEN:	HRRZ	T1,JFN		;GET JFN OF FILE
	MOVX	T2,7B5+OF%RD+OF%PDT+OF%NWT	;READ ONLY, NO UPDATING OF DATES
	OPENF			;TRY TO OPEN FILE
	 ERJMP	OPENTW		;FAILED, GO TRY OPENING IT THAWED
	IORI	F,FR.OPN	;OK, REMEMBER IT IS OPEN
	RET			;AND RETURN



OPENTW:	CAIE	T1,OPNX9	;IS FAILURE DUE TO INVALID SIMULTAN. ACCESS?
	CAIN	T1,OPNX13	;OR DUE TO INVALID ACCESS REQUESTED?
	SKIPA			;YES, PROCEED
	JRST	ERRSTR		;NO, GO LOSE
	HRRZ	T1,JFN		;GET BACK JFN
	MOVX	T2,OF%RD+OF%PDT+OF%NWT+OF%THW	;INCLUDE THAWED BIT
	OPENF			;NOW TRY TO OPEN IT
	 ERJMP	ERRSTR		;STILL FAILED, GO COMPLAIN
	IORI	F,FR.OPN	;OK, REMEMBER IT IS OPEN
	RET			;AND RETURN

	SUBTTL	ROUTINE TO MAP IN NEXT PAGE OF CURRENT FILE



;CALLED TO FIND THE NEXT USED PAGE OF THE INPUT FILE, AND TO MAP
;IT INTO THE USUAL PAGE.  THE LAST PAGE MAPPED WAS IN LOCATION PAGE.
;SKIP RETURN IF NEW PAGE MAPPED IN, PAGE NUMBER IS IN LOCATION PAGE.
;NON-SKIP IF NO MORE PAGES REMAIN IN THE FILE.




PAGMAP:	AOS	T1,PAGE		;INCREMENT TO NEXT PAGE NUMBER
	TLNE	T1,-1		;OVERFLOWED THE HALFWORD?
	RET			;YES, ALL DONE
	HRL	T1,JFN		;GET JFN OF INPUT FILE
	FFUFP			;FIND THE NEXT USED PAGE
	 ERJMP	PAGDON		;ERROR, GO CHECK IT OUT
	HRRZM	T1,PAGE		;SAVE PAGE NUMBER
	HRL	T1,JFN		;GET JFN AGAIN
	MOVE	T2,PAGNUM	;GET PAGE NUMBER USED FOR MAPPING
	HRLI	T2,.FHSLF	;AND MY PROCESS
	MOVX	T3,PM%RD	;WANT TO ONLY READ THE PAGE
	IORI	F,FR.MAP	;REMEMBER WE HAVE PAGE MAPPED
	PMAP			;MAP THE PAGE
	 ERJMP	ERRSTR		;FAILED
	SKIPA	@PAGADR		;TOUCH THE PAGE TO MAKE SURE ITS OK
	 ERJMP	ERRSTR		;IT ISN'T, LOSE
	RETSKP			;ALL DONE, SKIP RETURN



PAGDON:	CAIE	T1,FFUFX3	;FAILED BECAUSE NO MORE PAGES EXIST?
	JRST	ERRSTR		;NO, GO LOSE
	RET			;YES, RETURN

	SUBTTL	ROUTINE TO CLEAN UP ALL FILES



;ROUTINE TO CLOSE OFF AND RELEASE ALL FILES WHICH MAY BE OPEN.
;THIS ROUTINE WILL ALSO RELEASE ALL JFNS EXCEPT FOR THE MAIN JFN.
;FILES WILL BE UNMAPPED IF THAT IS NECESSARY.  THE INFERIOR FORK
;WILL BE KILLED IF NEEDED.



CLOSE:	SKIPE	T1,HANDLE	;GET HANDLE OF INFERIOR
	KFORK			;KILL IT OFF
	 ERJMP	.+1		;IGNORE ERRORS
	SETZM	HANDLE		;CLEAR HANDLE
	TRZN	F,FR.MAP	;WAS FILE MAPPED?
	JRST	CLOSE1		;NO, SKIP UNMAP THEN
	SETO	T1,		;-1 MEANS TO UNMAP PAGE
	MOVE	T2,PAGNUM	;GET PAGE WE WERE MAPPED IN AT
	HRLI	T2,.FHSLF	;IN MY OWN PROCESS
	SETZ	T3,		;ONLY THE ONE PAGE
	PMAP			;RELEASE THE PAGE
	 ERJMP	ERRSTR		;IF CAN'T, FATAL ERROR


CLOSE1:	TRZN	F,FR.OPN	;WAS THE FILE OPENED AT ALL?
	JRST	CLOSE2		;NO, GO ON
	HRRZ	T1,JFN		;YES, GET JFN OF FILE
	TLO	T1,(CO%NRJ)	;SET BIT NOT TO RELEASE JFN
	CLOSF			;CLOSE THE FILE
	 ERJMP	ERRSTR		;SHOULD WORK, IF NOT FATAL


CLOSE2:	SKIPE	T1,JFN		;WAS JFN NOT OPEN?
	TRNE	F,FR.AGN	;OR WE GOING TO DO FILE AGAIN?
	JRST	CLOSE3		;YES, GO LOOK AT OUTPUT FILE NOW
	SETZM	JFN		;NO, CLEAR IT
	RLJFN			;AND RELEASE JFN
	 ERJMP	ERRSTR		;ERROR

CLOSE3:	TRZN	F,FR.OP2	;OUTPUT FILE OPEN?
	JRST	CLOSE4		;NO, GO CHECK MORE
	HRRZ	T1,JFNOUT	;YES, GET JFN
	CLOSF			;CLOSE IT
	 ERJMP	ERRSTR		;ERROR
	SETZM	JFNOUT		;CLEAR WORD
	RET			;AND RETURN


CLOSE4:	SKIPN	T1,JFNOUT	;HAVE A JFN FOR OUTPUT FILE?
	JRST	CLOSE5		;NO, GO ON
	SETZM	JFNOUT		;YES, CLEAR IT
	RLJFN			;AND RELEASE IT
	 ERJMP	ERRSTR		;SHOULDN'T FAIL


CLOSE5:	HRRZ	T1,INIJFN	;GET JFN FOR INITIAL FILE SPEC
	JUMPE	T1,CPOPJ	;DONE IF NONE THERE
	SETZM	INIJFN		;CLEAR FROM MEMORY
	RLJFN			;THEN RELEASE IT
	 ERJMP	ERRSTR		;FAILED
	RET			;DONE

	SUBTTL	ROUTINE TO READ IN A FILE INTO INFERIOR FORK




;ROUTINE TO LOAD A PROGRAM INTO AN INFERIOR FORK.  CALL:
;
;	MOVE	T1,BITS		;GET GTJFN BITS
;	HRROI	T2,[ASCIZ/SPEC/] ;AND FILE TO BE READ IN
;	CALL	GETFRK		;GO READ IT IN
;
;ON RETURN, FORK IS READY TO BE STARTED, AND FORK HANDLE IS IN HANDLE.




GETFRK:	GTJFN			;GET A JFN ON THE FILE
	 ERJMP	ERRSTR		;FAILED
	MOVEM	T1,JFNOUT	;SAVE FOR LATER
	MOVX	T1,CR%CAP	;SET UP BITS TO KEEP CAPABILITIES
	CFORK			;CREATE AN INFERIOR
	 ERJMP	ERRSTR		;CAN'T
	MOVEM	T1,HANDLE	;SAVE THE HANDLE
	MOVS	T1,T1		;PUT IN LEFT HALF
	HRR	T1,JFNOUT	;GET JFN OF THE FILE
	GET			;READ IN THE PROG INTO THE FORK
	 ERJMP	ERRSTR		;LOSE
	SETZM	JFNOUT		;CLEAR JFN SINCE NO LONGER OURS
	RET			;RETURN

	SUBTTL	ROUTINE TO RUN A PROGRAM IN OUR INFERIOR FORK





;THIS ROUTINE STARTS THE INFERIOR, AND WAITS FOR IT TO FINISH.  WHEN
;IT IS DONE, WE TYPE OUT ANY ERROR WHICH MAY HAVE STOPPED IT.
;HANDLE OF INFERIOR IS IN LOCATION HANDLE.




RUNFRK:	MOVE	T1,HANDLE	;GET READY
	SETZ	T2,		;START AT NORMAL ADDRESS
	SFRKV			;DO IT
	 ERJMP	ERRSTR		;CAN'T
	WFORK			;WAIT FOR IT TO RETURN
	 ERJMP	ERRSTR		;LOSE
	RFSTS			;GET STATUS AND PC OF FORK
	LDB	T1,[POINTR (T1,RF%STS)]	;GET STATUS CODE
	CAIE	T1,.RFFPT	;FORCED TERMINATION?
	JRST	RUNFIN		;NO, ALL IS OK
	HRROI	T1,[ASCIZ/
? Error at PC /]		;GET STRING
	PSOUT			;TYPE THE STRING
	MOVEI	T1,.PRIOU	;OUTPUT TO TTY
	ANDI	T2,-1		;KEEP ONLY THE PC
	MOVX	T3,NO%LFL+NO%ZRO+<6,,10>	;GET FORMAT READY
	NOUT			;TYPE THE PC
	 ERJMP	ERRSTR		;FAILED
	HRROI	T1,[ASCIZ/: /]	;GET MORE STRING
	PSOUT			;OUTPUT IT
	MOVEI	T1,.PRIOU	;GIVE TO TTY
	HRLO	T2,HANDLE	;GET FORK HANDLE AND LAST ERROR
	SETZ	T3,		;NO LIMIT
	ERSTR			;OUTPUT THE FORK'S ERROR
	 JFCL			;LOSE
	 JFCL
	CALL	CRLF		;TYPE A CRLF


RUNFIN:	MOVE	T1,HANDLE	;GET HANDLE ON FORK
	KFORK			;THEN KILL IT OFF
	 ERJMP	.+1		;OH WELL
	SETZM	HANDLE		;NO LONGER HAVE A HANDLE ON IT
	RET			;RETURN


	SUBTTL	ROUTINES TO OUTPUT DATA INTO CORE STORAGE




;THE FOLLOWING ROUTINES OUTPUT USING A BYTE POINTER WHICH IS
;SUPPLIED IN AC T1.  ALL ROUTINES EXCEPT FOR EOFOUT TAKE THEIR DATA
;FROM AC T2.




STROUT:	HRLI	T2,(POINT 7,)	;CREATE FULL BYTE POINTER
STROUL:	ILDB	T3,T2		;GET NEXT CHAR OF STRING
	JUMPE	T3,CPOPJ	;RETURN WHEN GET A NULL
	IDPB	T3,T1		;STORE CHAR
	JRST	STROUL		;AND LOOP FOR ALL CHARS





DECOUT:	SKIPA	T4,[^D10]	;GET RADIX
OCTOUT:	MOVEI	T4,^D8		;OR OCTAL
NUMOUT:	LSHC	T2,-^D35	;TURN NUMBER INTO DOUBLE-WORD
	LSH	T3,-1		;  THAT IS UNSIGNED
	DIVI	T2,(T4)		;GET A DIGIT
	JUMPE	T2,NUMFIN	;IF ZERO, ALL DONE
	HRLM	T3,(P)		;MORE TO GET, SAVE THIS ONE
	CALL	NUMOUT		;AND GET ANOTHER
	HLRZ	T3,(P)		;GET BACK A DIGIT
NUMFIN:	ADDI	T3,"0"		;CONVERT TO ASCII CHARACTER
	IDPB	T3,T1		;STORE IT AWAY
	RET			;AND RETURN

SIXOUT:	MOVEI	T4,6		;SET UP TO DO SIX TIMES
SIXOUL:	SETZ	T3,		;CLEAR NEXT AC
	ROTC	T2,6		;GET NEXT CHAR TO TYPE
	ADDI	T3," "		;CONVERT TO ASCII
	IDPB	T3,T1		;STORE IT IN STRING
	SOJG	T4,SIXOUL	;LOOP FOR ALL CHARS
	RET			;RETURN




EOFOUT:	MOVE	T2,FDB+.FBSIZ	;GET NUMBER OF BYTES IN FILE
	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,"("		;GET A LEFT PARENTHESIS
	IDPB	T2,T1		;STORE IT
	LDB	T2,[POINT 6,FDB+.FBBYV,11]	;GET BYTE SIZE
	CALL	DECOUT		;OUTPUT IT
	MOVEI	T2,")"		;GET CLOSING PARENTHESIS
	IDPB	T2,T1		;STORE IT ALSO
	RET			;AND RETURN

	SUBTTL	ROUTINES TO HANDLE COMND JSYSES




;SIMPLE ROUTINES TO DO THE COMND JSYS, WHILE CHECKING FOR ERRORS.
;NO RETURN IF ERROR DETECTED, NORMAL RETURN IF PARSED OK.  AC T1
;CONTAINS THE ADDRESS OF THE COMND BLOCK TO USE.




CONFRM:	MOVEI	T2,[FLDDB. (.CMCFM)]	;GET CONFIRMATION FUNCTION
COMMND:	COMND			;PARSE THE END OF LINE
	 ERJMP	ERRSTR		;ERROR IN COMMAND, GO COMPLAIN
	TXNE	T1,CM%NOP	;DID IT PARSE CORRECTLY?
	JRST	ERRSTR		;NO, GO COMPLAIN
	RET			;YES, RETURN






NOISE:	HRROM	T2,NOIBLK+.CMDAT	;SAVE POINTER AS DATA
	MOVEI	T2,NOIBLK	;POINT TO DATA BLOCK
	JRST	COMMND		;GO READ IT AND RETURN

	SUBTTL	SUBROUTINE TO JUSTIFY OUTPUT OF A LINE



;CALLED WHEN STORING THE PARTS OF A LINE DESCRIBING A FILE, TO
;JUSTIFY IT ON NICE BOUNDARIES BY OUTPUTTING THE REQUIRED NUMBER
;OF SPACES.  CALL IS:
;
;	MOVE	T1,POINTER	;GET BYTE POINTER WHICH STARTED AT FILTXT
;	MOVEI	T2,BYTE NUMBER	;GET BYTE TO JUSTIFY TO
;	CALL	JUSTFY		;DO THE JUSTIFICATION
;	(RETURN)		;ALL DONE
;
;USES AC'S T2, T3, AND T4.



JUSTFY:	LDB	T3,[POINT 6,T1,5]	;GET POSITION FROM POINTER
	MOVEI	T4,^D36		;GET BITS TO A WORD
	SUBM	T4,T3		;SUBTRACT TO GET BIT POSITION
	IDIVI	T3,7		;DIVIDE BY BITS TO A BYTE
	MOVEI	T4,(T1)		;GET CURRENT WORD POINTER IS AT
	SUBI	T4,FILTXT	;SUBTRACT ADDRESS OF START OF BUFFER
	IMULI	T4,5		;MULTIPLY BY BYTES TO A WORD
	ADDI	T4,(T3)		;ADD IN BYTES IN PARTIAL WORD
	SUBI	T2,(T4)		;SUBTRACT BYTES ALREADY USED
	MOVEI	T3," "		;GET A SPACE TO DO JUSTIFYING WITH
	IDPB	T3,T1		;ALWAYS OUTPUT AT LEAST ONE
	SOJG	T2,.-1		;LOOP UNTIL JUSTIFIED
	RET			;THEN RETURN

	SUBTTL	ROUTINES TO TYPE SIMPLE THINGS TO TTY




;HERE WHEN THE STRUCTURE OR DIRECTORY HAS CHANGED, TO TYPE THEM
;OUT SO THE USER KNOWS WHERE THE FILES ARE COMING FROM.



TYPHDR:	HRROI	T1,[ASCIZ/
	/]			;GET A CRLF, TAB
	PSOUT			;OUTPUT IT TO START OFF
	MOVEI	T1,.PRIOU	;SET PRIMARY OUTPUT
	HRRZ	T2,JFN		;JFN OF FILE
	MOVE	T3,[1B2+1B5+JS%PAF]	;SET TO OUTPUT DEV:<USER>
	JFNS			;TYPE IT OUT
	 ERJMP	ERRSTR		;FAILED
				;THEN FALL INTO CRLF CODE



;HERE TO TYPE A CRLF TO THE TTY.


CRLF:	HRROI	T1,[ASCIZ/
/]				;GET A CRLF
	PSOUT			;OUTPUT IT
	RET			;AND RETURN

	SUBTTL	CHARACTER INTERRUPT HANDLING ROUTINE




;HERE WHEN WE ARE TRAPPING SOME CONTROL CHARACTER, TO GO TO THE
;PROPER ROUTINE FOR THAT TRAP.  OUR ACTION HERE IS SIMPLY TO ABORT
;THE CURRENT ACTION AND GO TO WHERE WE WERE TOLD TO GO.




TYPINT:	MOVE	P,INTPDL	;GET BACK GOOD STACK POINTER
	PUSH	P,T1		;SAVE AN AC
	MOVEI	T1,.TICCC	;GET CODE FOR CONTROL-C
	DTI			;DEASSIGN IT
	MOVEI	T1,.TICCE	;GET CODE FOR CONTROL-E
	DTI			;DEASSIGN IT TOO
	MOVE	T1,INTCOD	;GET ROUTINE TO GO TO
	TLO	T1,(1B5)	;SET USER MODE FOR SURE
	MOVEM	T1,CHNPC1	;SET WHERE WE RETURN TO
	POP	P,T1		;RESTORE AC
	DEBRK			;RETURN
	 ERJMP	ERRSTR		;SHOULD NOT CONTINUE
	JRST	ERRSTR		;EITHER WAY

	SUBTTL	ERROR HANDLING ROUTINES



;THE FOLLOWING SUBROUTINES ARE USED TO HANDLE HORRIBLE ERRORS WHICH
;OCCUR INSIDE ROUTINES WHICH HAVE NO ERROR RETURN.  WE ESSENTIALLY
;HAVE A STACK OF PUSH-DOWN STACKS AND ERROR HANDLING ROUTINES.
;TO SET UP ERROR HANDLING FOR A SUBROUTINE, IT DOES:
;
;	MOVEI	T1,ADDRESS	;GET ADDRESS OF ROUTINE TO HANDLE ERROR
;	CALL	ERRSET		;GO SET UP FOR ANY ERRORS
;	(RETURN)		;DID IT
;
;USES ONLY AC T1.  IF ANY ERROR THEN OCCURS IN THE CALLING ROUTINE
;OR LOWER, CONTROL WILL BE PASSED TO THE GIVEN ADDRESS.  THESE CALLS
;CAN BE NESTED.


ERRSET:	HRRZM	T1,@ERRPTR	;SAVE ROUTINE TO CALL IN CASE OF ERROR
	AOS	T1,ERRPTR	;INCREMENT POINTER INTO SAVE AREA
	CAIGE	T1,ERRBUF+ERRSIZ	;TOO MUCH DEPTH?
	JRST	ERRSE1		;NO, GO ON
	HRROI	T1,[ASCIZ/
? Error handling depth exceeded

/]				;GET STRING
	PSOUT			;TYPE IT
	JRST	MONRET		;AND EXIT

ERRSE1:	MOVEM	P,@ERRPTR	;SAVE STACK AT THIS POINT IN TIME TOO
	AOS	ERRPTR		;AND INCREMENT STACK AGAIN
	MOVEI	T1,ERRBAC	;GET ROUTINE TO CALL WHEN HE POPJ'S
	EXCH	T1,(P)		;SWITCH OUR RETURN ADDRESS
	JRST	(T1)		;RETURN TO CALLER




;HERE WHEN THE CALLER FINALLY DOES A POPJ, WE RETURN HERE TO FIX
;UP THE ERROR STACK, AND ALSO TO GIVE A SKIP RETURN IF NECESSARY.


ERRBAC:	JRST	.+2		;NORMAL RETURN
	AOS	(P)		;SKIP RETURN, PASS IT ON
	SOS	ERRPTR		;BUMP ERROR POINTER
	SOS	ERRPTR		;TO RESTORE LEVEL OF ERROR HANDLING
	RET			;RETURN TO CALLER OF ROUTINE

;HERE IF AN ERROR OCCURRED IN THE SUBROUTINE.  THE ROUTINE WITH THE
;ERROR HAS JUMPED TO US TO FIX THINGS UP.  COME TO ERRMSG IF THE
;ERROR WAS A STANDARD JSYS ERROR WHICH WE CAN ERRSTR TO THE TERMINAL.
;COME TO ERRPRT IF WE HAVE OUR OWN ERROR MESSAGE READY TO TYPE.
;WE RETURN TO THE ADDRESS ORIGINALLY GIVEN TO US IN THE CALL
;TO ERRSET, WITH THE STACK RESTORED PROPERLY.




ERRSTR:	MOVEI	T1,.TICCE	;GET READY
	DTI			;DEASSIGN CONTROL-E
	MOVEI	T1,.TICCC	;GET READY
	DTI			;DEASSIGN CONTROL-C TOO
	HRROI	T1,[ASCIZ/
? /]				;GET PRILIMARY TEXT
	PSOUT			;TYPE IT
	MOVEI	T1,.PRIOU	;SET UP
	HRLOI	T2,.FHSLF	;WANT LAST ERROR IN MY PROCESS
	SETZ	T3,		;NO LIMIT ON ERROR TEXT
	ERSTR			;TYPE THE ERROR
	 JFCL			;CAN'T DO MUCH ELSE
	 JFCL
	HRROI	T1,[ASCIZ/

/]				;GET A COUPLE OF CRLFS


ERRPRT:	PSOUT			;TYPE THE TEXT
	MOVEI	T1,.PRIIN	;GET READY
	CFIBF			;CLEAR INPUT BUFFER
	SOS	ERRPTR		;DECREMENT ERROR POINTER
	MOVE	P,@ERRPTR	;RESTORE STACK POINTER
	POP	P,T1		;REMOVE CALL TO ERRSET FROM BEFORE
	SOS	ERRPTR		;DECREMENT AGAIN
	ANDCMI	F,FR.HDR	;PREVENT OUTPUT OF HEADER NOW
	MOVE	T1,@ERRPTR	;GET ADDRESS TO GO TO ON THE ERROR
	JRST	(T1)		;AND GO TO IT
HLPTXT:	TEXT	<
For each file indicated, type either just a carriage return or
one of the commands listed below.  Carriage return just moves
down to the next file.

  ABORT		Return to command level now.

  BACKUP n	Go backwards "n" files to reprocess them again.
		The default number is 1, and the maximum is 100.

  COPY file	Copy the file to the desired specification.  The
		default device and directory are the ones you are
		connected to.

  DELETE	Deletes the file.

  EDIT		Edit the file using the editor associated with the
		logical name of EDITOR:.  When the editor is finished,
		the current file is reprocessed.

  EXIT		Returns to the EXEC.  A "CONTINUE" command will
		reprocess the current file.

  EXPUNGE	Deletes and expunges a file.  A file can not be
		undeleted if this command is used, since the disk
		space is freed immediately.

  FILDDT args	Get FILDDT in an inferior fork so that you can use
		it on the file.  When FILDDT exits, the current
		file is reprocessed.  The args are any of NO-FILE,
		DATA-FILE, or PATCHING.

  FOLLOW page	Type out a file starting at the given page number,
		waiting as data is appended to the end of the file.
		This is useful for typing BATCH log files.

  INFO arg	Type out information about the file.  The arg can be
		one of FDB, ALL-OF-FDB, or PAGES.  Default is FDB.

  LIST		Print the file on the line printer.

  NEXT arg	Skip over files until a new "arg" is found.  The arg
		can be one of STRUCTURE, DIRECTORY, FILE, or TYPE.
		DIRECTORY is the default argument.

  PUSH		PUSH to an inferior EXEC.  When a POP is done, the
		current file will be reprocessed.

  RENAME file	Rename the file to the given file specification.  The
		defaults for the output file are the same as the input.

  RUN		Execute the file in an inferior fork.  When the fork
		exits or gets a fatal error, the current file will
		be reprocessed.  Control-C will return to REV.

  SET arg	Set the specified parameter of the file.  Type a
		question mark to list the fields that can be changed.

  STORE file	Store the filespec of the current file into the named
		file.  If the file is nonempty, the name is appended
		following a comma.  The default file is REV.LST.

  TYPE page	Type out the file starting at the given page number.
		Default page number is 0 (I.E., start of the file).
		Typing ^E will abort the typeout.

  UNDELETE	Undelete the file.

>

	SUBTTL	TABLES FOR THE DESCRIPTION AND SETTING OF FDB INFO



;THE FOLLOWING MACRO IS USED TO GENERATE THE TABLES WHICH ARE USED
;TO DESCRIBE OR SET THE VARIOUS FIELDS IN A FILE'S FDB.  THE
;IMBEDDED XX MACRO HAS THE FOLLOWING ARGUMENTS:
;
;	XX	SYMBOL-NAME,WORD,MASK,TYPE-ADDR,DESCRIPTION,FLAG
;
;WHERE SYMBOL-NAME IS THE NAME AS DOCUMENTED IN THE REFERENCE MANUAL,
;WORD IS THE OFFSET IN THE FDB OF THIS FIELD, MASK IS THE PART OF THE
;WORD THE FIELD IS IN, TYPE-ADDR IS THE ROUTINE TO TYPE THE FIELD,
;SET-ADDR IS THE ROUTINE TO SET THE FIELD, DESCRIPTION IS THE TEXT
;EXPLAINING THE FIELD, AND FLAG IS 1 IF THIS FIELD IS ALWAYS OUTPUT.



	XALL		;SHOW EXPANSIONS OF MACROS


	DEFINE	FDBDAT,<

XX	.FBHDR,.FBHDR,-1,TYPHLF,Header word,1
  XX	FB%LEN,.FBHDR,FB%LEN,TYPHLF,Length of FDB,1
XX	.FBCTL,.FBCTL,-1,TYPHLF,Status bits
  XX	FB%TMP,.FBCTL,FB%TMP,TYPBIT,File is temporary
  XX	FB%PRM,.FBCTL,FB%PRM,TYPBIT,File is permanent
  XX	FB%NEX,.FBCTL,FB%NEX,TYPBIT,File does not have a file type
  XX	FB%DEL,.FBCTL,FB%DEL,TYPBIT,File is deleted
  XX	FB%NXF,.FBCTL,FB%NXF,TYPBIT,First write is not complete
  XX	FB%LNG,.FBCTL,FB%LNG,TYPBIT,File is longer than 512 pages
  XX	FB%SHT,.FBCTL,FB%SHT,TYPBIT,File has compressed page table
  XX	FB%DIR,.FBCTL,FB%DIR,TYPBIT,File is a directory
  XX	FB%NOD,.FBCTL,FB%NOD,TYPBIT,File is not to be saved
  XX	FB%BAT,.FBCTL,FB%BAT,TYPBIT,File has bad pages
  XX	FB%SDR,.FBCTL,FB%SDR,TYPBIT,Directory has subdirectories
  XX	FB%ARC,.FBCTL,FB%ARC,TYPBIT,File has archive status
  XX	FB%INV,.FBCTL,FB%INV,TYPBIT,File is invisible
  XX	FB%OFF,.FBCTL,FB%OFF,TYPBIT,File is offline
  XX	FB%FCF,.FBCTL,FB%FCF,TYPHLF,File class field
  XX	FB%NDL,.FBCTL,FB%NDL,TYPBIT,File cannot be deleted
  XX	FB%WNC,.FBCTL,FB%WNC,TYPBIT,Last write not closed
  XX	FB%FOR,.FBCTL,FB%FOR,TYPBIT,File has Fortran carriage control
XX	.FBEXL,.FBEXL,-1,TYPHLF,Link to FDB of next file type
XX	.FBADR,.FBADR,-1,TYPHLF,Disk address of index block,1
XX	.FBPRT,.FBPRT,-1,TYPHLF,File access bits,1
XX	.FBCRE,.FBCRE,-1,TYPDAT,Time of last write,1
XX	.FBAUT,.FBAUT,-1,TYPAUT,Author of file,1
XX	.FBGEN,.FBGEN,-1,TYPHLF,Generation and directory numbers,1
  XX	FB%GEN,.FBGEN,FB%GEN,TYPDEC,Generation number,1
  XX	FB%DRN,.FBGEN,FB%DRN,TYPHLF,Directory number
XX	.FBACT,.FBACT,-1,TYPACT,Account designator,1
XX	.FBBYV,.FBBYV,-1,TYPHLF,File I/O information,1
  XX	FB%RET,.FBBYV,FB%RET,TYPDEC,Retention count,1
  XX	FB%BSZ,.FBBYV,FB%BSZ,TYPDEC,File byte size,1
  XX	XXX1,.FBBYV,3B13,TYPHLF,Unused
  XX	FB%MOD,.FBBYV,FB%MOD,TYPHLF,Data mode written in,1
  XX	FB%PGC,.FBBYV,FB%PGC,TYPDEC,Page count of file,1
XX	.FBSIZ,.FBSIZ,-1,TYPDEC,Number of bytes in file,1
XX	.FBCRV,.FBCRV,-1,TYPDAT,Creation time of file,1
XX	.FBWRT,.FBWRT,-1,TYPDAT,Time of last user write,1
XX	.FBREF,.FBREF,-1,TYPDAT,Time of last nonwrite access,1
XX	.FBCNT,.FBCNT,-1,TYPHLD,<Count of writes,,references>,1
XX	.FBBK0,.FBBK0,-1,TYPHLF,Backup word 1
XX	.FBBK1,.FBBK1,-1,TYPHLF,Backup word 2
XX	.FBBK2,.FBBK2,-1,TYPHLF,Backup word 3
XX	.FBBBT,.FBBBT,-1,TYPHLF,Archive status bits
  XX	XXX2,.FBBBT,1B0,TYPHLF,Unused
  XX	AR%RAR,.FBBBT,AR%RAR,TYPBIT,Archive requested by user
  XX	AR%RIV,.FBBBT,AR%RIV,TYPBIT,System requested invol migration
  XX	AR%NDL,.FBBBT,AR%NDL,TYPBIT,Don't delete contents when archiving
  XX	AR%NAR,.FBBBT,AR%NAR,TYPBIT,Resist migration
  XX	AR%EXM,.FBBBT,AR%EXM,TYPBIT,File is exempt from migration
  XX	AR%1ST,.FBBBT,AR%1ST,TYPBIT,First pass of archive run complete
  XX	AR%RFL,.FBBBT,AR%RFL,TYPBIT,Retrieve failed
  XX	AR%WRN,.FBBBT,AR%WRN,TYPBIT,User warned of approaching expiration
  XX	XXX3,.FBBBT,77B14,TYPHLF,Unused
  XX	AR%RSN,.FBBBT,AR%RSN,TYPOFR,Offline reason
  XX	AR%PSZ,.FBBBT,AR%PSZ,TYPDEC,Page count when file went offline
XX	.FBNET,.FBNET,-1,TYPEXD,On-line expiration date
XX	.FBUSW,.FBUSW,-1,TYPHLF,User settable word
XX	.FBGNL,.FBGNL,-1,TYPHLF,Address of FDB of next generation
XX	.FBNAM,.FBNAM,-1,TYPHLF,Pointer to filename block,1
XX	.FBEXT,.FBEXT,-1,TYPHLF,Pointer to file type block,1
XX	.FBLWR,.FBLWR,-1,TYPLWR,Last writer to file,1
XX	.FBTDT,.FBTDT,-1,TYPEXD,Date archived
XX	.FBFET,.FBFET,-1,TYPEXD,Offline expiration date
XX	.FBTP1,.FBTP1,-1,TYPSIX,Tape ID for run 1
XX	.FBSS1,.FBSS1,-1,TYPHLD,<Run 1 saveset number,,Tape file number>
XX	.FBTP2,.FBTP2,-1,TYPSIX,Tape ID for run 2
XX	.FBSS2,.FBSS2,-1,TYPHLD,<Run 2 saveset number,,Tape file number>
>

;EXPAND MACRO AS REQUIRED.  FIRST SYMBOL NAMES:

	DEFINE	XX(S,W,M,T,D,F),<
	EXP	SIXBIT/S/	;Symbol for D
>

TABSYM:	FDBDAT

	TABNUM==.-TABSYM	;NUMBER OF FIELDS

;THEN OFFSETS IN THE FDBS:

	DEFINE	XX(S,W,M,T,D,F),<
	EXP	W		;Offset in FDB for D
>

TABWRD:	FDBDAT

;THEN MASK BITS IN THE WORD:

	DEFINE	XX(S,W,M,T,D,F),<
	EXP	M		;Mask for D
>

TABMSK:	FDBDAT

;THEN BYTE POINTERS TO THE FIELD:

	DEFINE	XX(S,W,M,T,D,F),<
	PTR==POINTR(<FDB+W>,^O<M>)	;GET BYTE POINTER
	EXP	PTR		;Byte pointer to D
>

TABPTR:	FDBDAT

;THEN DISPATCH ADDRESS FOR TYPEOUT OF FIELDS:

	DEFINE	XX(S,W,M,T,D,F),<
	EXP	T		;Routines for D
>

TABADR:	FDBDAT

;FINALLY FLAG BITS AND THE ASCII STRINGS THEMSELVES:

	DEFINE	XX(S,W,M,T,D,F<0>),<
	XWD	F'B18,[ASCIZ	"D"]
>

TABTXT:	FDBDAT

	SUBTTL	DATA AREA

	SALL		;RETURN TO GOOD LISTING FORMAT


;COMMAND BLOCK FOR FILE SPEC.


CMDBLK:	0,,NEWPAR		;FLAGS,,REPARSE ADDRESS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	-1,,[ASCIZ/REV>/]	;CONTROL-R BUFFER
	-1,,TXTBUF		;POINTER TO TEXT BUFFER
	-1,,TXTBUF		;POINTER TO CURRENT POSITION
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	0			;NUMBER OF UNPARSED CHARS
	-1,,ATMBUF		;POINTER TO THE ATOM BUFFER
	TXTLEN			;LENGTH OF ATOM BUFFER
	0			;POINTER TO GTJFN BLOCK FILLED IN AT RUNTIME



;GTJFN BLOCK FOR TOP LEVEL COMMAND PARSING:


JFNBLK:	0			;FLAGS,,GENERATION FILLED IN AT RUNTIME
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	0			;DEFAULT DEVICE, NONE
	0			;DEFAULT DIRECTORY, NONE
	-1,,[ASCIZ/*/]		;DEFAULT FILENAME, WILD
	-1,,[ASCIZ/*/]		;DEFAULT FILETYPE, WILD
	0			;DEFAULT PROTECTION, NONE
	0			;DEFAULT ACCOUNT, NONE
	0			;JFN TO ASSIGN, NONE
	0			;FLAGS IN FIRST WORD OF EXTENDED BLOCK
	BLOCK	10		;REMAINING ARGUMENTS NOT USED

;GTJFN BLOCK FOR COPYING THE MAIN JFN:


NEWBLK:	EXP	GJ%OLD+GJ%DEL+GJ%PHY+GJ%SHT+GJ%ACC+GJ%XTN	;FLAGS
	XWD	.NULIO,.NULIO	;NO OTHER INPUT
	0			;NO DEFAULT DEVICE
	0			;OR DEFAULT DIRECTORY
	0			;OR DEFAULT FILE
	0			;OR DEFAULT EXTENSION
	0			;OR PROTECTION
	0			;NO BYTE POINTER
	0			;OR JFN TO ASSIGN
	EXP	G1%IIN		;EXTENDED FLAGS, ALLOW INVISIBLE FLAGS



;GTJFN BLOCK FOR READING STARTING FILE SPEC (ALL WILD):


INIBLK:	GJ%OLD+GJ%OFG+GJ%FLG+.GJALL	;FLAGS,,GENERATION
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	-1,,[ASCIZ/DSK*/]	;DEFAULT DEVICE
	-1,,[ASCIZ/*/]		;DEFAULT DIRECTORY
	-1,,[ASCIZ/*/]		;DEFAULT FILENAME
	-1,,[ASCIZ/*/]		;DEFAULT FILETYPE
	BLOCK	14		;NO OTHER QUANTITIES OF IMPORTANCE

;COMMAND BLOCK FOR PARSING COMMANDS TO HANDLE EACH FILE.


KEYBLK:	0,,KEYPAR		;FLAGS,,REPARSE ADDRESS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	-1,,FILTXT		;CONTROL-R BUFFER
	-1,,TXTBUF		;POINTER TO TEXT BUFFER
	-1,,TXTBUF		;POINTER TO CURRENT POSITION
	TXTLEN			;NUMBER OF CHARS IN BUFFER
	0			;NUMBER OF UNPARSED CHARS
	-1,,ATMBUF		;POINTER TO ATOM BUFFER
	TXTLEN			;LENGTH
	EXP	KEYJFB		;POINTER TO GTJFN BLOCK




;GTJFN BLOCK FOR OUTPUT SPECIFICATIONS.


KEYJFB:	GJ%DEL+GJ%ACC+GJ%FOU	;FLAG BITS,,GENERATION NUMBER
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	0			;DEFAULT DEVICE, FILLED IN LATER
	0			;DEFAULT DIRECTORY, FILLED IN TOO
	-1,,DFTNAM		;DEFAULT NAME, SAME AS INPUT
	-1,,DFTTYP		;DEFAULT TYPE, SAME AS INPUT
	0			;DEFAULT PROTECTION, NONE
	0			;DEFAULT ACCOUNT, NONE
	0			;JFN TO ASSIGN, NONE
	0			;NO EXTENDED BLOCK
	BLOCK	10		;OTHER ARGS NOT USED

;TABLE OF COMMANDS FOR PROGRAM.



ACTTAB:	ACTLEN,,ACTLEN		;NUMBER OF ENTRIES
	AA	ALLOW,ACTALW	;ALLOW KINDS OF FILES
	AA	EXIT,ACTXIT	;LEAVE PROGRAM
	AA	HELP,ACTHLP	;TYPE OUT HELP TEXT
	AA	REVIEW,ACTREV	;REVIEW SOME FILES
	AA	WHAT,ACTWHT	;TELL WHICH KIND OF FILES WE REVIEW

	ACTLEN==.-ACTTAB-1	;NUMBER OF COMMANDS





;TABLE OF COMMANDS FOR EACH FILE.


KEYTAB:	KEYLEN,,KEYLEN		;NUMBER OF ENTRIES
	AA	ABORT,CMDABT	;RETURN TO COMMAND LEVEL
	AA	BACKUP,CMDBAC	;BACKUP TO A PREVIOUS FILE
	AA	COPY,CMDCPY	;COPY FILE
	AA	DELETE,CMDDEL	;DELETE THE FILE
	AA	E,EXITCM,CM%ABR+CM%INV	;EXIT ABBREVIATION
	AA	EDIT,CMDEDT	;EDIT A FILE
	AA	EX,EXITCM,CM%ABR+CM%INV	;ANOTHER ONE
EXITCM:	AA	EXIT,CMDXIT	;EXIT FROM PROGRAM NOW
	AA	EXPUNGE,CMDEXP	;DELETE AND EXPUNGE A FILE
	AA	FILDDT,CMDDDT	;CALL FILDDT FOR FILE
	AA	FOLLOW,CMDFOL	;FOLLOW WRITING OF FILE
	AA	HELP,CMDHLP	;TYPE SHORT DESCRIPTION OF OPTIONS
	AA	INFO,CMDINF	;INFORMATION ABOUT FILE
	AA	LIST,CMDLST	;PRINT FILE ON LPT
	AA	NEXT,CMDNXT	;GO ON TO NEXT DIRECTORY
	AA	PUSH,CMDPSH	;PUSH TO AN INFERIOR EXEC
	AA	RENAME,CMDREN	;CHANGE NAME OF FILE
	AA	RUN,CMDRUN	;RUN THIS FILE IN AN INFERIOR FORK
	AA	SET,CMDSET	;SET PARAMETERS OF FILE
	AA	STORE,CMDSTO	;STORE FILE SPEC INTO A FILE
	AA	TYPE,CMDTYP	;TYPE FILE TO TERMINAL
	AA	UNDELETE,CMDUND	;UNDELETE THE FILE

	KEYLEN==.-KEYTAB-1	;NUMBER OF KEYWORDS

;INTERRUPT BLOCKS FOR CHANNEL AND LEVEL.


LEVTAB:	EXP	CHNPC1		;PLACE TO STORE PC
	BLOCK	2		;OTHER LEVELS UNUSED

CHNTAB:	XWD	1,TYPINT	;LEVEL 1, INTERRUPT ROUTINE
	BLOCK	^D35		;OTHER CHANNELS UNUSED




;DATA BLOCK FOR PARSING NOISE WORDS.


NOIBLK:	FLDDB.	(.CMNOI)	;NOISE STRING FILLED IN LATER

	SUBTTL	PURE DATA STORAGE


	XLIST			;LITERALS
	LIT
	LIST


PDL:	BLOCK	PDLLEN		;STACK ROOM
INTCOD:	BLOCK	1		;LOCATION GO TO ON CONTROL-CHAR INTERRUPT
INTPDL:	BLOCK	1		;STACK POINTER TO RESTORE
CHNPC1:	BLOCK	1		;INTERRUPT PC FOR LEVEL 1
SAVEP:	BLOCK	1		;PLACE TO SAVE STACK POINTER
ERRPTR:	BLOCK	1		;POINTER INTO ERRBUF ADDRESSES
ERRBUF:	BLOCK	ERRSIZ+1	;STORAGE FOR ERROR HANDLER ROUTINES
HANDLE:	BLOCK	1		;HANDLE ON INFERIOR FORK
GJFN:	BLOCK	1		;MAIN JFN USED IN GTJFN LOOP
JFN:	BLOCK	1		;JFN FOR GRUNGING ON A FILE
INIJFN:	BLOCK	1		;JFN OF INITIAL FILE SPEC
GNBITS:	BLOCK	1		;BITS RETURNED FROM GNJFN
FILBYT:	BLOCK	1		;FILE BYTE POINTER FOR FOLLOW ROUTINE
JFNOUT:	BLOCK	1		;OUTPUT JFN
PAGADR:	BLOCK	1		;ADDRESS WHERE FILE IS MAPPED IN
PAGNUM:	BLOCK	1		;PAGE NUMBER WHERE FILE IS MAPPED
PAGAD2:	BLOCK	1		;ADDRESS OF SECOND PAGE
PAGNU2:	BLOCK	1		;PAGE NUMBER OF SECOND PAGE
PAGE:	BLOCK	1		;PAGE NUMBER OF FILE WHICH IS MAPPED
PAGBEG:	BLOCK	1		;FIRST PAGE IN A RANGE TO TYPE
PAGEND:	BLOCK	1		;LAST PAGE IN A RANGE TO TYPE
PAGTOT:	BLOCK	1		;TOTAL PAGES TYPED OUT
DATBLK:	BLOCK	4		;WORDS USED FOR SFTAD JSYS
FDBMAX:	BLOCK	1		;HIGHEST OFFSET VALID FOR THIS FDB
FDB:	BLOCK	.FBLEN		;AREA TO READ FILE FDB INTO
DFTDEV:	BLOCK	^D8		;DEFAULT DEVICE FOR OUTPUT
DFTDIR:	BLOCK	^D8		;DEFAULT DIRECTORY FOR OUTPUT
DFTNAM:	BLOCK	^D8		;DEFAULT FILE NAME FOR OUTPUT
SPCPTR:	BLOCK	1		;POINTER TO SPECIFICATIONS
BACNUM:	BLOCK	1		;NUMBER OF FILES WE HAVE BACKED UP
BACTRY:	BLOCK	1		;NUMBER OF FILES TO BE BACKED UP BY
DFTTYP:	BLOCK	^D8		;DEFAULT FILE TYPE FOR OUTPUT
SPECS:	BLOCK	MAXUP*SPECSZ	;STORAGE OF FILE SPECIFICATIONS
FLAGS:	BLOCK	MAXUP		;FLAGS FOR EACH SPECIFICATION
LINPTR:	BLOCK	1		;SAVED BYTE POINTER INTO LINBUF
LINBUF:	BLOCK	^D20		;STORAGE FOR A LINE OF OUTPUT
TXTBUF:	BLOCK	TXTLEN/5+1	;STORAGE FOR COMND
ATMBUF:	BLOCK	TXTLEN/5+1	;MORE STORAGE FOR COMND
TMPBUF:	BLOCK	TXTLEN/5+1	;COPY OF ATOM BUFFER
FILTXT:	BLOCK	TXTLEN/5+1	;STORAGE OF FILE SPEC
TEMP:	BLOCK	^D100		;TEMPORARY USE AREA
LAST:	BLOCK	3000		;CORE TO DO PMAP INTO.



	END	3,,ENTRY	;ENTRY VECTOR
