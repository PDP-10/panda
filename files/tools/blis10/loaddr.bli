!THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
!  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
!
!COPYRIGHT (C) 1972,1973,1974,1977,1978 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 01754
!FILENAME:	LOADDR.BLI
!DATE:		1 MAR 73	MGM

%3.2%	GLOBAL BIND LOADV=1;	!MODULE VERSION NUMBER




%3.1%	GLOBAL ROUTINE TVMP(X)=
!  (TEMPORARY VALUE IN MEMORY PREDICATE)
!  X MUST BE A LEXEME.   TVMP IS A PREDICATE WITH VALUE 1
!  (OTHERWISE 0) IF THE LEXEME IS OF THE FORM @R (POSSIBLY
!  WITH A UNARY - OR NOT) WHERE R IS A HAS-BEEN TEMPORARY
!  REGISTER NOW DUMPED INTO CORE TO LOOK LIKE A LOCAL
!  VARIABLE.   THE IDEA OF TVMP IS TO DECIDE WHETHER THAT
!  CORE LOCATION CAN PROFITABLY BE USED TO FURTHER EVALUATE
!  AN EXPRESSION.   FOR INSTANCE @R+@D, WHERE D IS A DECLARED
!  REGISTER, COULD BE CODED AS  ADDM D,R.
  BEGIN REGISTER E;
    IF ((E_.X AND (NOT NGNTM AND NOT RTEM);.E) EQL ZERO
           OR .E EQL 0) AND .X<DTF> THEN
      .RT[.RT<RTEF>]<RSF> AND (.RT[.RT<RTEF>]<USEF> EQL 1)
  END;




%3.1%	GLOBAL ROUTINE LITV(X)=
!  (LITERAL VALUE)
!  X MUST BE THE LEXEME FOR A LITERAL.   LITV RETURNS
!  THE 36 BIT VALUE OF THAT LITERAL.
  IF .X<VEF> THEN GETLITVAL(.X<LTEF>) ELSE .X<LTEF>;




%3.1%	GLOBAL ROUTINE LITA(X)=
!  (LITERAL ADDRESS)
!  X MUST BE THE LEXEME FOR A LITERAL.   LITA RETURNS
!  A VALUE WITH TWO FIELDS COMPATIBLE WITH CODE-3 FORMAT.
!  THE RIGHT HALF HOLDS THE ENTRY OF THAT LITERAL IN THE
!  LT.   THIS WILL CAUSE A SMALL LITERAL TO BE ENTERED IF
!  IT IS NOT ALREADY IN THE TABLE - NECESSARY SINCE THE
!  PDP-10 DOES NOT HAVE IMMEDIATE INSTRUCTIONS FOR ALL
!  OPERATIONS, E.G. PUSH.   THE RELOCF HOLDS LTRELOC.
  BEGIN
  X_IF .X<VEF> THEN .X<LTEF>
     ELSE LTINSERT(.X<LTEF>);
  X<RELOCF>_7;
  .X
  END;




%3.1%	GLOBAL ROUTINE RAGLAR(X)=
!  (REGISTER ADDRESS - GENERATE LOAD ARBITRARY REGISTER)
!  X MUST BE A LEXEME.   RAGLAR GENERATES CODE TO FORCE
!  THE EXPRESSION INTO AN ARBITRARY REGISTER WHOSE ADDRESS
!  IT RETURNS IN CODE-3 FORMAT.
  BEGIN LOCAL D;
    D_X_GLAR(.X);
    X_.RT[.X<RTEF>]<ARTEF>;
    RMA(IF .D<DTF> THEN .X,0,.X)
  END;




%3.1%	GLOBAL ROUTINE RMA(R,M,Y)=
!  (RELEASE - MODIFY - ADDRESS)
!  Y MUST BE AN ADDRESS, POSSIBLY WITH THE RELOCF SET.
!  R AND M MUST BE ACTUAL REGISTER ADDRESSES.   RMA PUTS
!  R AND M IN THE RELRF AND INDXF OF Y AND RETURNS THE
!  RESULT (CODE-3 FORMAT).   MEANTIME IT SANCTIFIES M.
  BEGIN
    IF .ART[.R]<DTF> THEN Y<RELRF>_.R;
    Y<INDXF>_.M;
    IF (M_.ART[.M]<RTEF>) NEQ 0 THEN RT[.M]<HOLYF>_1;
    .Y
  END;





%3.1%	GLOBAL ROUTINE LEXRA(X)=
  ! RETURNS LEXEME OF A REGISTER WHOSE ADDRESS IS X.  IF X DOES NOT HAVE
  ! A NAME, LEXRA GETS ONE

  IF .ART[.X]<RTEF> EQL 0 THEN
    IF (1^.X AND .MODREGM) EQL 0 THEN
      BEGIN
        RMFRLST(.X);
        LEXRN(GETRN(.X,0,0))
      END
    ELSE LEXRN(GETRN(.X,1,0))
  ELSE LEXRN(.ART[.X]<RTEF>);



%3.1%	GLOBAL ROUTINE REGAR(X)=
!  (REGISTER ADDRESS - RELEASE)
!  X SHOULD BE A LEXEME OF THE FORM @R.   REGAR PROVIDES
!   THE ACTUAL REGISTER ADDRESS OF R AS WITH REGAK, BUT 
!  WITH THE RELRF ALSO SET TO THIS ADDRESS (TO SIGNAL TO
!  CODEN TO RELEASE THE REGISTER) UNLESS R IS DECLARED.
  BEGIN LOCAL A,T;
    T_TVMP(.X);
    A_REGAK(.X);
    IF .X<DTF> AND NOT .T THEN RMA(.A,0,.A) ELSE .A
  END;




%3.1%	GLOBAL ROUTINE REGAK(X)=
!  (REGISTER ADDRESS - KEEP)
!  X SHOULD BE A LEXEME OF THE FORM @R.   REGAK PROVIDES
!  THE ACTUAL REGISTER ADDRESS OF R SETTING HOLINESS TO
!  PREVENT SWAPPING.   THE VALUE IS COMPATIBLE WITH CODE-2
!  AND CODE-3 FORMATS.
  BEGIN LOCAL T;
    (T_RT[.X<RTEF>])<HOLYF>_1;
    IF NOT(.(.T)<RSF> AND .X<DTF>) THEN .(.T)<ARTEF>
    ELSE GMA(.X)
  END;




%3.1%	GLOBAL ROUTINE TVRP(X)=
!  (TEMPORARY VALUE IN REGISTER PREDICATE)
  %1 IF THE LEXEME X REPRESENTS AN EXPRESSION PROVIDING AN UNIQUE
   TEMPORARY REGISTER(UNLESS THE EXPRESSION IS READY) WHICH MAY BE
   USED WITHOUT POSSIBLE LOSS IN THE A FIELD OF A MEMORY TO REGISTER
   INSTRUCTION. 0 OTHERWISE%
  BEGIN REGISTER N;
    IF (IF REGP(.X) THEN
	 ITRP(.X) OR (.RT[N_.X<RTEF>]<ARTEF> EQL .OPTTOREGADDR)
	ELSE 0) THEN
      RT[.N]<HOLYF>_1
    ELSE 0
  END;




%3.1%	GLOBAL ROUTINE ITRP(X)=
!  (INVOLVES TEMPORARY REGISTER PREDICATE)
!  X MUST BE A LEXEME.   ITRP IS A PREDICATE WITH VALUE 1
!  (OTHERWISE 0) IF THE LEXEME INCLUDES @R WHERE R IS AN 
!  UNDUMPED TEMPORARY REGISTER.
  BEGIN REGISTER N;
    IF (N_.X<RTEF>) GEQ 16 THEN
      NOT .RT[.N]<RSF> AND .RT[.N]<USEF> EQL 1
    ELSE 0
  END;



%3.1%	GLOBAL ROUTINE DCRP(X)=
!  (DECLARED REGISTER PREDICATE)
  %1 IF THE LEXEME REPRESENTS AN EXPRESSION OF THE FORM @D, WHERE D
   IS EITHER A DECLARED REGISTER OR A NON-UNIQUE TEMPORARY REGISTER.
   NON-UNIQUENESS RESULTS FROM A SUCCESSFUL MATCH IN THE
   TRCT BEFORE THE REGISTER HAS BEEN RELEASED.
   E.G. IN  (T_EXPR)+.T  AND IN THIS CASE HOLINESS IS SET
   TO PREVENT SWAPPING.
   IN EITHER CASE THE REGISTER CONTENTS MAY NOT BE CHANGED.
   0 OTHERWISE%
  BEGIN REGISTER E;
    IF REGP(.X) THEN E_.X<RTEF> ELSE RETURN(0);
    IF .E LSS 16 THEN RETURN 1;
    IF NOT .RT[.E]<RSF> THEN IF .RT[.E]<USEF> GTR 1 THEN
        RETURN RT[.E]<HOLYF>_1;
    0
  END;




GLOBAL ROUTINE REGP(X)=
  ! PREDICATE: X IS A LEXEME REPRESENTING A REGISTER

  BEGIN
    IF .X EQL 0 THEN RETURN 0;
    (.X AND NOT RTEM) EQL 0
  END;


GLOBAL ROUTINE SMPOSLITVP(X)=
  ! (SMALL-POSITIVE-LITERAL-VALUE-PREDICATE)  X IS AN 18-BIT LITERAL VALUE

  BEGIN
    IF .X LSS 0 THEN RETURN 0;
    .X LEQ RIGHTM
  END;


GLOBAL ROUTINE SMNEGLITVP(X)=
  ! (SMALL-NEGATIVE-LITERAL-VALUE-PREDICATE) -X IS AN 18-BIT LITERAL VALUE

  BEGIN
    IF .X GEQ 0 THEN RETURN 0;
    .X GEQ -RIGHTM
  END;

!END OF LOADDR.BLI

