!THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
!  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
!
!COPYRIGHT (C) 1972,1973,1974,1977,1978 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 01754
!FILENAME:	H3LDIN.BLI
!DATE:		4 MAY 74	MGM/FLD/KR/GJB

%3.43%	GLOBAL BIND H3LDV=12;	!MODULE VERSION NUMBER

!
! REVISION HISTORY:
!
!   6-9-77      ROUTINE WRITE1 IS MODIFIED SO THAT EXTERNAL SYMBOL
!               REFERENCE IN PLITS,OWN AND GLOBAL INITIALIZATION
!               WORK PROPERLY.THE CHAIN IS REFERENCED BACKWARDS.
!               RELOCATE LOWSEG ADDRESS WITH HIGH OR LOWSEG
!               ONLY.
!
!    5-9-77     ROUTINES OUTPLITS,LDINIT ARE MODIFIED TO OUTPUT
!  	        PLITS IN HI-SEG AND OWN GLOBAL VARIABLES INTO
!	        LISTING AS WELL AS REL FILES.NOW PLITS ARE
!	        ALWAYS IN HI-SEG.
!
!    1/26/77	ADDED ROUTINE WRIT11 WHICH OUTPUTS TO THE OBJECT
!		FILE A LOAD REQUEST FOR ANOTHER MODULE EITHER
!		ABSOLUTLY OR CONDITIONALY (LIBRARY).
!




    STRUCTURE FIELDVECTOR[I]=.FIELDVECTOR+.I;
    STRUCTURE STSTR[IND,WD] = (.STSTR+.IND+.WD)<0,36>;
    STRUCTURE GNAMESSTR[I] = (.GNAMESSTR-3+.I)<0,36>;

    EXTERNAL PTREFNO,LTREFNO,VECTOR LTTRANST:PTTRANST,
             PTLNK,NREG,
             LOC2,LOCC,GNAMESSTR GNAMES,ETP,ETL,ETPNXT,MNAME,
             BUF1,BUFPT1,BUF2,BUFPT2,
             GETSPACE,RELEASESPACE,OUTREL,LTINSERT,
             NEXTOWN,GTP,NEXTGLOBAL,VECTOR LT,MNAM,FCNSTATE,TABLE,
             NOSAVREG,FLAGS,
             HIORG,ORG2,
             FNSTAT;

    MACRO CTCDE=CT<30,6,CTEP>$,
          STCD(X)=ST[X,0]<16,6>$,
          HDSTE=CT[0,2]<,15,CTEP>$,
          STSY(X)=ST[X,2]$,
          HDLOCE=CT[0,3]<,18,CTEP>$,
          HDLLE=CT[0,3]<,,CTEP>$,
          CTFPE=CT<,15,CTEP>$,
          CTBPE=CT<15,15,CTEP>$,
          CTOCE=CT[0,1]<,,CTEP>$,
          STAD(X)=ST[X,1]<,18>$,
          HDCPE=CT[0,1]<0,15,CTEP>$,
          PTOCE=1<,,CTEP>$,
          PTCDE=0<30,6,CTEP>$,
          XWD(LH,RH)=((LH)^18+(RH))$;

    BIND RHDCD=62,
         STGRCD=#12,
         LH=#777777^18,
         CTCDP=30,CTCDS=6;
ROUTINE WOB(BUF,BUFPT)=
  BEGIN
    BIND VECTOR BUFFER = .BUF,BUFL=BUFFER<,18>;
    IF
      .BUFL NEQ 0
     THEN(
      INCR I TO .BUFL+1 DO
       OUTREL(@BUFFER[.I]);
      BUFL _ 0;
      .BUFPT _ BUFFER<,2>)
   END;




  ROUTINE WOB1=(
    WOB(BUF1,BUFPT1));





  ROUTINE WOB2=(
    WOB1();
    WOB(BUF2,BUFPT2));
ROUTINE INBUF(WD,CD,BUF,BUFPT,WOB)=
  BEGIN
    BIND VECTOR BUFFER=.BUF, BUFL=BUFFER<,18>;
    REPLACEI(.BUFPT,.CD);
    BUFFER[.BUFL+2] _ .WD;
    IF
      (BUFL_.BUFL+1) EQL 18
     THEN
      (.WOB)()
   END;




  ROUTINE INBUF1(WD,CD)=(
    INBUF(.WD,.CD,BUF1,BUFPT1,WOB1));





  ROUTINE INBUF2(WD,CD)=(
    INBUF(.WD,.CD,BUF2,BUFPT2,WOB2));
  ROUTINE WRITE1(WD,CD)=(    !CODE
    IF
      .BUF1<,18> EQL 0
     THEN
      INBUF1(.LOCC,1);
 ! 6-9-77 IF THERE ARE EXTERNAL SYMBOL USE IN OWN OR GLOBAL
 ! INITIALIZATION , RELOCATE TO LOWSEG ONLY WHEN TWOSEGMENTS.
 ! INBUF1(.CD^17 AND .HIORG OR .WD, .CD);
   INBUF1(IF .TWOSEGFLG AND .CD AND (.LOCC LSS #400000)
              THEN .WD
              ELSE (.CD^17 AND .HIORG OR .WD)
             , .CD);
    LOCC_.LOCC+1);





  ROUTINE WRITE2(WD1,WD2,CD)=(    !SYMBOL TABLE
    INBUF2(.WD1,0);
    INBUF2(.CD^17 AND .ORG2 OR .WD2, .CD));





  ROUTINE WRITE3=(    !HISEG BLOCK
    OUTREL(XWD(3,1));
    OUTREL(1^34);
    OUTREL(.HIORG^18 OR .HIORG));





  ROUTINE WRITE5=(    !END
    WOB2();
    OUTREL(XWD(5,2));
    OUTREL(IF .TWOSEGFLG THEN 5^32 ELSE 1^34);
    OUTREL(.LOC2);
%3.36% OUTREL(IF .TWOSEGFLG
%3.36%	THEN .NEXTGLOBAL+.NEXTOWN
%3.36%	+(IF .LSTART OR .PROFLG THEN 1 ELSE 0)
%3.36%	ELSE 0));





  ROUTINE WRITE8(PTR,VAL)=(    !INTERNAL REQUEST
    WOB2();
    OUTREL(8^18+1);
    OUTREL(3^34);
    OUTREL(.PTR^18 OR .VAL OR .HIORG^18 OR .HIORG));





ROUTINE WRITE6(NAM) =(    !NAME
%3.3%	!MAKE 2 WD NAME BLOCK WITH COMPILER NUMBER FOR LINK.
%3.3%  OUTREL(XWD(6,2));
  OUTREL(0);
%3.3%  OUTREL(.NAM);
%3.3%	OUTREL(XWD(6,0)));





ROUTINE WRITE7(SA) =(    !STARTING ADDRESS
  OUTREL(XWD(7,1));
  OUTREL(1^34);
  OUTREL(.SA));




%3.21%	GLOBAL ROUTINE WRITE9(LOC, VALUE)=
%3.21%
%3.21%		(OUTREL(XWD(1,2));	! WRITE 'LOC' CODE
%3.21%		 OUTREL(0);
%3.21%		 OUTREL(.LOC);
%3.21%		 OUTREL(.VALUE));




GLOBAL ROUTINE WRIT10(LOC, SYM)=	! GLOBAL REQUEST

	(OUTREL(XWD(2,2));
	 OUTREL(0);
	 OUTREL(.SYM OR #60^30);
	 OUTREL(.LOC));

GLOBAL ROUTINE WRIT11(COND,DEV,FLNM,PPN)=	! REL FILE REQUEST
BEGIN
    IF .COND
	THEN OUTREL(XWD(#17,3))
	ELSE OUTREL(XWD(#16,3));
    OUTREL(0);
    OUTREL(.FLNM);
    OUTREL(.PPN);
    OUTREL(.DEV);
    .VREG
    END;


FORWARD GETNAM,RMVENT;

%3.1%	GLOBAL ROUTINE DEFLOW(IND)=    !DEFINE GLOBAL OR OWN
%2.25%	BEGIN
  BIND LGLOT=.STCD(.IND) EQL GLOBALT,NAME=GETNAM(STSY(.IND),6);
  WRITE2((IF LGLOT THEN (RMVENT(.IND); #24^30) ELSE #10^30) OR NAME,.STAD(.IND),0);
%2.25%  WRITE2(#60^30 OR .GNAMES[3+LGLOT],(#12+LGLOT)^32 OR NAME,0);
%2.25%	!WRITE THE MACRO DECLARATION INTO THE LISTING FILE
%2.25%	IF .MLFLG THEN	!DETAILS FOR MACRO-10
%2.25%	IF LGLOT
%2.25%	  THEN  !THIS IS A GLOBAL
%2.25%	    MDCLOUT(.IND,3,.ST[.IND,1]<RIGHTHALF>)
%2.25%	  ELSE
%2.25%	    (OCHAR(";"); MDCLOUT(.IND,4,.ST[.IND,1]<RIGHTHALF>));
%2.25%	END;	!OF ROUTINE DEFLOW
GLOBAL ROUTINE DEFGLLEX(IND)=

  !MAKE A GLOBAL SYMBOL ENTRY IN THE LOADER ST FOR THE GPLITT
  !TYPE STE REFERENCED BY STINDEX.

  BEGIN
    LOCAL R50NAME;
    WRITE2(#24^30 OR (R50NAME_GETNAM(STSY(.IND),6)),.ST[.IND,1],0);
    !ADD THREE TO GNAMES OFFSET TO COMPENSATE FOR MAPPING TO GNAMESSTR IN H3LDIN ABOVE
%2.25%    WRITE2(#60^30 OR .GNAMES[9], #54^30 OR .R50NAME,0);
%2.25%	!WRITE THE DECLARATION FOR MACRO INTO THE LISTING FILE
%2.25%	IF .MLFLG THEN !OUTPUT DETAILS FOR MACRO-10
%2.25%	MDCLOUT(.IND,7,.ST[.IND,1]<RIGHTHALF>);
  END;


GLOBAL ROUTINE DEFGBC (IND,		!INDEX OF STE
		      VALUE) =		!VALUE OF GLOBAL SYMBOL

  !INSERT THE GLOBAL SYMBOL NAME WITH CORRESPONDING VALUE INTO
  !THE LOADER SYMBOL TABLE

%2.25%	BEGIN
  WRITE2 (#04^30 OR GETNAM(STSY(.IND),6),.VALUE,0);
%2.25%	IF .MLFLG THEN	!OUTPUT DETAILS FOR MACRO-10
%2.25,4.07%	MDCLOUT(.IND,1,.VALUE);
%2.25%	END;

GLOBAL ROUTINE DEFGBG (IND,		! INDEX OF STE
			VALUE,		! VALUE TO BE BOUND
			EXTEL)=	! EXTERNAL ELEMENT
! THIS ROUTINE DEFINES A GLOBAL AS A 36 BIT OFFSET FROM
! AN EXTERNAL.
BEGIN
    LOCAL R50NAME;
    WRITE2((#24^30) OR (R50NAME_GETNAM(STSY(.IND),6)),
	.VALUE,0);
    WRITE2((#60^30) OR .EXTEL,
	(#54^30) OR .R50NAME,0);
    ! AT THIS POINT WE SHOULD EMIT THE BIND IN MACRO TO
    ! THE LISTING BUT THIS IS VERY HARD
	.VREG
END;

GLOBAL ROUTINE DEFGBR(IND,		! STE INDEX
		RTNSTE,			! ROUTINE (FUNCTION) STE INDEX
		POSNSIZE)=		! POSITION AND SIZE
    !  GLOBAL BIND TO A ROUTINE
    BEGIN
    WRITE2((#4^30) OR GETNAM(STSY(.IND),6),
	.POSNSIZE OR .ST[.ST[.RTNSTE,1]<RIGHTHALF>,3]<RIGHTHALF>,1);
    ! AT THIS POINT WE SHOULD EMIT THE BIND IN MACRO TO
    ! THE LISTING BUT THIS IS VERY HARD
    END;

GLOBAL ROUTINE PUTGBP(BNDIND,FWRDIND,VAL)=
! THIS ROUTINE PUTS A REQUEST IN THE GLOBAL BIND
! PENDING (GBP) LIST TO MAKE A GLOBAL BIND OF BNDIND
! TO FWRDIND+VAL WHEN FWRDIND IS RESOLVED
BEGIN
    REGISTER GBPE;

    GBPE=GETSPACE(2);
    (.GBPE+1)=.BNDIND;
    (.GBPE+2)=.FWRDIND;
    (.GBPE+3)=.VAL;
    (.GBPE)=.GBPHDR;
    GBPHDR=.GBPE;
    .VREG
END;

GLOBAL ROUTINE CHKGBP(IND)=
! CHECK THROUGH THE GBP LIST.  IF THE ROUTINE INDEX
! ENTRY MATCHES .IND FOR ANY OF THEM MAKE THE GLOBAL BIND.
BEGIN
   REGISTER GBPENT,GBPOENT;
   GBPOENT=GBPHDR;
   GBPENT=.GBPHDR;
   WHILE .GBPENT NEQ 0 DO
	IF .IND EQL .(.GBPENT+2) THEN
	    BEGIN
	    DEFGBR(.(.GBPENT+1),.(.GBPENT+2),.(.GBPENT+3));
	    (.GBPOENT)=..GBPENT;
	    GBPENT=..GBPENT;
	    RELEASESPACE(.GBPENT,2);
	    END
	ELSE
	    BEGIN
	    GBPOENT=.GBPENT;
	    GBPENT=..GBPENT;
	    END;
    .VREG
END;
GLOBAL ROUTINE GETNAM(SYM,NC) =
  BEGIN
    REGISTER C,R;
    SYM<24,12> _ 36^6+7;
    R _ 0;
    WHILE
      (C_SCANI(SYM)) NEQ #177 AND (NC_.NC-1) GEQ 0
     DO
      R _ 40*.R + (IF .C GEQ "A" THEN .C-#66 ELSE IF .C GEQ "0" THEN .C-#57 ELSE
        IF .C EQL "." THEN #45 ELSE .C+2);
    .R
  END;    !GETNAM





%3.1%	GLOBAL ROUTINE OFFST(OC)=(OC<,18>_.OC-.FNSTAT; .OC);





ROUTINE TTRANS(IND,TAB,REFNOP)=
  BEGIN
    BIND FIELDVECTOR OFFT=(.TAB)<,18>,FIELDVECTOR REFT=(.TAB)<18,18>,REFP=REFT[.IND],REFNO=.REFNOP;
    IF
      .REFP NEQ #777777
     THEN
      .REFP
     ELSE(
      REFNO _ @REFNO+1;
      OFFT[@REFNO] _ .IND;
      REFT[.IND] _ @REFNO)
   END;    !TTRANS
%2.25%	GLOBAL ROUTINE RPTTRANS(IND)=TTRANS(.IND,PTTRANST,PTREFNO);



%2.25%	GLOBAL ROUTINE RLTTRANS(IND)=
%2.9%	  !LITERALS ARE CURRENTLY IN LT IN HASHED ORDER.
%2.9%	  !EACH TIME WE WRITE OUT A LINE OF CODE WHICH REFERENCES
%2.9%	  !A LITERAL, WE MUST SPECIFY AN ADDRESS.  SO EACH TIME WE
%2.9%	  !NEED TO REFERENCE A NEW LITERAL, WE PUT ITS LT INDEX INTO
%2.9%	  !THE NEXT AVAILABLE SLOT IN THE LTTRANST.  WE WILL LATER OUTPUT
%2.9%	  !THE LITERALS TO THE RELOCATABLE BINARY FILE IN THE ORDER IN WHICH
%2.9%	  !THEY APPEAR IN THE LTTRANST.
%2.9%	  !IND IS THE LT INDEX OF THE LITERAL WE DESIRE TO TRANSLATE.
%2.9%	  !RLTTRANS RETURNS AS ITS VALUE, THE OFFSET OF THE LT INDEX
%2.9%	  !ENTRY IN LTTRANS WHICH CORRESPONDS TO THE OFFSET THE LITERAL
%2.9%	  !WILL HAVE FROM THE BEGINNING OF THE LITERAL AREA OUTPUT TO THE
%2.9%	  !RELOCATABLE BINARY FILE.

%2.9%	  BEGIN
%2.9%	    REGISTER RBASE,	!BASE OF CURRENT LTTRANST MODULE
%2.9%			J;	!INDEX OF CURRENT LTTRANST ENTRY

%2.9%	    !LOOP THROUGH ALL LTTRANST MODULES IN ORDER
%2.27%	    INCR I FROM 0 TO LTNUM - 1 DO
%2.9%	      BEGIN
%2.9%		!IF THIS BASE POINTER IS EMPTY, GET A NEW MODULE AND INIT IT TO -1.
%2.9%		IF .LTTBASE[.I] EQL 0
%2.9%		  THEN
%2.9%		    BEGIN
%2.9%		      LTTBASE[.I]<RIGHTHALF>_CT[GETSPACE(LTSIZE^(-1)),0];
%2.9%		      INCR J FROM .LTTBASE[.I]<RIGHTHALF> TO .LTTBASE[.I]<RIGHTHALF> + LTSIZE-1 DO
%2.9%			(.J)<0,36>_-1
%2.9%		    END;
%2.9%		RBASE_.LTTBASE[.I]<RIGHTHALF>;	!POINT TO BASE OF THIS MODULE
%2.9%		!NOW LOOK THROUGH THE MODULE FOR THE INDEX
%2.9%		J_.RBASE-1;
%2.9%		WHILE ((J_.J+1) LSS .RBASE + .LTTBASE[.I]<LEFTHALF>) DO
%2.9%%3.35%	  IF @@J EQL .IND THEN RETURN (.I*LTSIZE+.J-.RBASE);
%2.9%		!IF THERE IS MORE ROOM IN THIS MODULE, UP COUNT & INSERT ENTRY.
%2.9%		IF .LTTBASE[.I]<LEFTHALF> LSS LTSIZE
%2.9%		  THEN
%2.9%		    BEGIN
%2.9%		      LTTBASE[.I]_.LTTBASE[.I]+1^18;
%2.9%		      (.J)<0,36>_.IND;
%2.9%%3.35%	      RETURN (.I*LTSIZE+.J-.RBASE);
%2.9%		    END;
%2.9%	      END;
%2.9%	  END;
ROUTINE TRANS(OC,TYPE)=
  BEGIN
    BIND OCRH=OC<,18>;
    OCRH_IF .TYPE EQL 6 THEN RPTTRANS(.OCRH) ELSE IF .TYPE EQL 7 THEN RLTTRANS(.OCRH) ELSE .OCRH;
    .OC
   END;    !TRANS





ROUTINE RMVENT(STIND) =     !REMOVE ENTRY FROM ENTRY TABLE
    IF
        .ENTHED NEQ 0
     THEN     !ENTRIES EXIST
      BEGIN
        LOCAL CURS,ENTIND;
        CURS _ .CTNEXT1[.ENTHED];
        WHILE
            .CURS NEQ .ENTHED
         DO     !SEARCH FOR ENTRY
          BEGIN
            ENTIND _ .CTNEXT1[.CURS];
            IF
                .ST[.ENTIND,2] EQL .ST[.STIND,2] AND .ST[.ENTIND,3] EQL .ST[.STIND,3]
             THEN     !FOUND
                EXITLOOP;
            CURS _ .CTNEXT[.CURS]
          END;
        IF
            .CURS NEQ .ENTHED
         THEN     !FOUND
          BEGIN
            ERASECELL(.CURS);
            IF
                .CTNEXT1[.ENTHED] EQL .ENTHED
             THEN     !NOW EMPTY
              BEGIN
                DELCELL(.ENTHED);
                ENTHED _ 0
              END
          END
      END;     !RMVENT
ROUTINE OCOUT(OC,TYPE)=
  BEGIN

    REGISTER PTT, T;
    LOCAL PTTYP,TCD,TSTADP,TSTAD;

    MACRO ETEP=PTT$,CTEP=PTT$,
          ET=CT$,
          TL=T$,TOCAD=T$,TLNK=T$,TETL=T$;

    IF .TYPE EQL MODRELOC
	THEN(    !MODULE RELOCATION
	WRITE1(.OC,1);
	RETURN);

    IF .TYPE EQL EXPRELOC
	THEN(    !EXTERNAL OFFSET
	WRITE1(.OC AND #777777^18 OR .STOFFSET[.OC<OPADF>],0);
	WRITE2(#60^30 OR GETNAM(STSY(.STPARSTE[.OC<OPADF>]),6),1^35 OR .LOCC-1,1);
	RETURN);


    IF .TYPE EQL 0 OR (TL_.TYPE GTR 2)

     THEN(    !OBJECT CODE OUTPUT IS ABSOLUTE OR LOCAL
      IF .TYPE NEQ 6
       THEN     !SPECIAL ACTION REQUIRED OTHERWISE
        WRITE1(IF .TYPE NEQ 8 THEN TRANS(.OC,.TYPE) ELSE (TL_0; OFFST(.OC)),0);


      IF  .TL
       THEN(    !DISPLACEMENT FROM A GLOBAL REGION
        IF .TYPE EQL 6
         THEN     !CONSTANT POINTER (MAY POINT TO LOCAL)
          BEGIN
            IF
              (PTTYP_.(PTT_PT[.OC<,18>,0]<0,0>)<CTCDP,CTCDS-1>) EQL 8
             THEN(    !REFERS TO LOCAL.  CHANGE TO LITERAL.
              TYPE _ 7;
              OC<,18> _ LTINSERT(OFFST(.1<,,PTT>)))
             ELSE
              IF .PTTYP EQL 2
               THEN     !REFERS TO CT
                IF
                  .CT[.1<,18,PTT>] GEQ 0
                     THEN(    !REFERS TO CODE CELL. CHANGE TO MODULE RELOC.
                      0<30,5,PTT> _ MODRELOC;
                      1<,18,PTT> _ .CT[.1<,18,PTT>,0]<15,15>);
            WRITE1(TRANS(.OC,.TYPE),0)
          END;
        WRITE2(6^33 OR .GNAMES[.TYPE],1^35 OR .LOCC-1,1)))
     ELSE     !EXTERNAL OR CT REF
      BEGIN
	TCD_1;
	TOCAD_.OC<,18>;
	WRITE1((
	  IF .TYPE EQL 1
	   THEN     !EXTERNAL REF
	    BEGIN
              MACRO ETSTPE=ET<15,15,ETEP>$,
                    ETLKE=ET[0,1]<,,ETEP>$,
                    ETFPE=ET<,15,ETEP>$,
                    ETLK(LK)=((LK)+1)$;

	      IF (TSTAD_.(TSTADP_STAD(.TOCAD))) EQL #777777
		THEN(    !1ST REF.  CREATE ET ENTRY
		   .TSTADP _ TABLE + (ETEP_GETSPACE(1));
		   ETSTPE _ .TOCAD;
		   ETLKE _ .LOCC;
		   ETFPE _ .ETP;
		   ETP _ .ETEP;
		   TCD _ 0)
		ELSE(    !CONTINUE LINKAGE
		   TETL_@(ETEP_ETLK(.TSTAD));
		   (.ETEP)<>_.LOCC;
		   .TETL)
	     END   !EXTERNAL REF

	   ELSE    !CT REF
	    BEGIN
	      CTEP_.TOCAD;
	      IF .TABLE<,,CTEP> LSS 0
	       THEN     !POINTER TO HEADER
		IF .HDLLE LSS 0
		 THEN(    !LOCATION UNRESOLVED.  MUST LINK
		  IF (TLNK_.HDLOCE) EQL #777777
		   THEN(    !1ST REF
		    TCD_0;
		    TLNK_0);
		    HDLOCE_.LOCC;
		    .TLNK)
		 ELSE .HDLOCE     !LOCATION RESOLVED
	       ELSE .CTBPE     !POINTER TO CODE STRING (RESOLVED)
 	     END)  !CT REF
	   OR .OC AND LH,
	   .TCD)
       END   !EXTERNAL OR CT REF
   END;  !OCOUT
ROUTINE OUTPLITS(H) =     !OUTPUT PLITS BELOW REPEAT HEADER H
  BEGIN
    LOCAL CURS,TEMP;
    INCR I FROM 1 TO .CTRPTCNT[.H] DO
      BEGIN
        CURS _ .CTNEXT1[.H];
        WHILE
            .CURS NEQ .H
         DO
          BEGIN
            IF
                HEADERP(.CURS)
             THEN
                OUTPLITS(.CURS)
             ELSE
              BEGIN
                IF ((.OWNBLK LSS 0 OR .GLOBLK LSS 0) AND
                 (.CT[.CURS,0]<PRIORITYF> EQL OWNT OR .CT[.CURS,0]<PRIORITYF>
                   EQL GLOBALT) AND .CT[.CURS,1]<LEFTHALF> EQL
                      #377777)
                 THEN BEGIN
                    TEMP_IF .CT[.CURS,1]<17,1> EQL 1 THEN
                            .CT[.CURS,1]+1^35
                           ELSE .CT[.CURS,1]<RIGHTHALF>;
                       IF .TEMP GTR 0 THEN  WOB1();
                       LOCC_.TEMP+.LOCC
                     END
                 ELSE
                OCOUT(.CTOP[.CURS],.CTREL[.CURS]);
               END;
            CURS _ .CTNEXT[.CURS]
          END
      END
  END;
GLOBAL ROUTINE LIINIT =     !INITIALLIZE
  BEGIN
%3.36% EXTERNAL NOSVR,RBREG,RENTLEX,RXITLEX;
    LOCAL CURS;
%2.25%    BIND GNAMESSTR GNAMESI=PLIT(#2741,#2731,#2730,#2725,#2736,#2755,#2742);
%2.25%	!				.O    .G    .F    .C    .L    ..    .P
    ACCUM[1] _ -2;
%3.36% ACCUM[0] _ '.BREG';
%3.36% RBREG _ DOTM+ZERO36+LSM+STINSERT(EXTRNT^TYPEFP+LSM,#777777);
    INCR I FROM 0 TO .NOSVR DO
      BEGIN
        MACRO SETLEX(CHAR,VECTOR)=
            ACCUM[0]_'.E'+(CHAR^(2*7)+"T.")^1;
            VECTOR[.I]_DOTM+ZERO36+LSM+STINSERT(EXTRNT^TYPEFP+LSM,#777777)$;
        ACCUM[1]<4*7+1,7> _ .I + "0";
        SETLEX("N",RENTLEX);
        SETLEX("X",RXITLEX)
      END;
    ETP _ #77777;
    MNAME_GETNAM(MNAM,4)*1600;
    INCR I TO PTMASK DO
        PTTRANST[.I]_-1;
%2.9%    PTREFNO_-1;
    INCR I FROM 3 TO 9 DO
        GNAMES[.I]_.GNAMESI[.I]+.MNAME;
%2.25%	!FIRST GET ALL SYMBOL NAMES AS ASCIZ LOCALS
%2.25%	R50TOASCIZ(ONAME,.GNAMES[3]);
%2.25%	R50TOASCIZ(GNAME,.GNAMES[4]);
%2.25%	R50TOASCIZ(FNAME,.GNAMES[5]);
%2.25%	R50TOASCIZ(CNAME,.GNAMES[6]);
%2.25%	R50TOASCIZ(LNAME,.GNAMES[7]);
%2.25%	R50TOASCIZ(TNAME,.GNAMES[8]);
%2.25%	R50TOASCIZ(PNAME,.GNAMES[9]);
%2.25%	IF .MLFLG THEN MMHDOUT();	!OUTPUT TITLE AND RELOC PSEUDO-OPS
    IF
        .NUMENT GTR 0 AND NOT .BINFLG
     THEN     !OUTPUT ENTRY BLOCK
      BEGIN
        OUTREL(XWD(4,.NUMENT));
        NUMENT _ .NUMENT - 1;
        CURS _ .CT[.ENTHED,1]<NEXTF>;
        INCR I TO .NUMENT/18 DO
          BEGIN
            OUTREL(0);
            INCR J TO IF .NUMENT-18*.I GEQ 17 THEN 17 ELSE .NUMENT-18*.I DO
              BEGIN
                OUTREL(GETNAM(ST[.CTNEXT1[.CURS],2],6));
                CURS _ .CTNEXT[.CURS]
              END
          END
      END;
    LOC2_ORG2_HIORG_IF .TWOSEGFLG THEN (HGHFLG_1;1^17) ELSE 0;
    WRITE6(.MNAME + RADIX50"..");
    IF
        .HGHFLG
     THEN     !MAKE HIGH SEGMENT
        WRITE3();
    WRITE2(1^32 OR .MNAME+#2711,0,1);
%3.11%   IF .LSTART OR .PROFLG
%3.11%  THEN		! PUT PROLOGS AND EPILOGS ON LISTING
      BEGIN
        LOCAL DREGA[11];
        REGISTER SVREG,F;
        MACRO OMC(F,A,X,Y)=OCOUT((F)^27 OR (A)^23 OR (X)^18 OR (Y),0)$;
        STRUCTURE STEFSTR[I]=(.STEFSTR+.I)<STEF>;
        EXTERNAL STEFSTR RENTLEX:RXITLEX;
        LOCC _ .LOC2;
        SVREG _ .SVREGM^20;
        DREGA _ 15;
        INCR I FROM 1 TO .NOSVR DO
          BEGIN
            F _ FIRSTONE(.SVREG);
            SVREG _ .SVREG^(.F) AND (-1)^(-1);
            DREGA[.I] _ .DREGA[.I-1] - .F
          END;
        INCR I FROM 0 TO .NOSVR DO
          BEGIN
            WRITE2(4^30 OR GETNAM(STSY(.RENTLEX[.I]),6),.LOCC,1);
            OMC(PUSH,.SREG,0,.FREG);
            OMC(HRRZ,.FREG,0,.SREG);
            INCR J FROM 1 TO .I DO
                OMC(PUSH,.SREG,0,.DREGA[.J]);
            OMC(JRST,0,.JSPREG,0)
          END;
        DREGA _ .FREG;
        DECR I FROM .NOSVR TO 0 DO
          BEGIN
            WRITE2(4^30 OR GETNAM(STSY(.RXITLEX[.I]),6),.LOCC,1);
            OMC(POP,.SREG,0,.DREGA[.I])
          END;
        OMC(POPJ,.SREG,0,0);
        LOC2 _ .LOCC;
	IF .DEBFLG THEN ! DEFINE DEBUGUUO FOR DDT
	    WRITE2(1^32+RADIX50"DEBUG",DEBUGUUO^27,0);

%2.25%	IF .MLFLG THEN !OUTPUT EXTRA FOR MACRO-10
%2.25%	BEGIN
%2.25%	!OUTPUT CODE FOR PROLOGS AND EPILOGS TO THE LISTING
%2.25%	NEWLINE();	NEWLINE();
%2.25%	OUTPSTRING(PLIT(ASCIZ ';ROUTINE PROLOGS AND EPILOGS'));  NEWLINE();  NEWLINE();

%2.25%	INCR I FROM 0 TO .NOSVR
%2.25%	  DO !OUTPUT THE PROLOGS
%2.25%	    BEGIN
%2.25%	      OUTPSTRING(PLIT(ASCIZ '.ENT.')); OCHAR("0"+.I);  OUTSTR("::",2);	!LABEL
%2.25%	      NEWLINE();
%2.25%	      MCODEOUT(PLIT(ASCIZ 'PUSH'), .SREG,0,.FREG);
%2.25%	      MCODEOUT(PLIT(ASCIZ 'HRRZ'),.FREG,0,.SREG);
%2.25%	      INCR J FROM 1 TO .I DO
%2.25%		MCODEOUT(PLIT(ASCIZ 'PUSH'),.SREG,0,.DREGA[.J]);
%2.25%	      MCODEOUT(PLIT(ASCIZ 'JRST'),0,.JSPREG,0);
%2.25%	      NEWLINE();
%2.25%	    END;

%2.25%	  DECR I FROM .NOSVR TO 0 DO !OUTPUT THE EPILOGS
%2.25%	    BEGIN
%2.25%	      OUTPSTRING(PLIT(ASCIZ '.EXT.')); OCHAR("0"+.I); OUTSTR("::",2);	!LABEL
%2.25%	      NEWLINE();
%2.25%	      MCODEOUT(PLIT(ASCIZ 'POP'),.SREG,0,.DREGA[.I]);
%2.25%	    END;

%2.25%	  MCODEOUT(PLIT(ASCIZ 'POPJ'),.SREG,0,0);
%2.25%	  NEWLINE();  NEWLINE();
%2.25%	END;	!OF EXTRA FOR MACRO-10

      END
  END;     !LIINIT
GLOBAL ROUTINE LDINT(HDP) =     !LOADER INTERFACE
  BEGIN
%2.9%    BIND FIELDVECTOR PTOFF=PTTRANST<,18>;
    REGISTER CTEP;
    LOCAL LRH,CTEPS,LOC1,IND,NXTIND;
    IF
%3.15%  .BINFLG AND NOT .MLFLG
     THEN(    !NO CODE OUTPUT.  JUST ERASE.
      NXTIND _ .CT[.HDP,1]<,15>;
      UNTIL
        (IND_.NXTIND) EQL .HDP
       DO(
        NXTIND _ .CT[.IND]<,15>;
        RELEASESPACE(.IND,1));
      RETURN);
    NREG_.NOSAVREG - 8;
    LOC1_.LOC2;
    CTEP_.HDP;
    IF
      LRH_.CTCDE EQL RHDCD
     THEN(    !ROUTINE HEADER
      WRITE2((IF .STCD(.HDSTE) EQL STGRCD OR .GRFLG THEN (RMVENT(.HDSTE);4^30) ELSE #10^30)
        OR GETNAM(STSY(.HDSTE),6),.LOC1+.LUNDEFLG,1);
      IF
	.HDLOCE NEQ #777777
       THEN     !LINK
	WRITE8(.HDLOCE,.LOC1+.LUNDEFLG);
      CHKGBP(.HDSTE);
      HDLLE_.LOC1+.LUNDEFLG)
     ELSE(     !MAIN BLOCK
%3.22%  IF .STARTBLOCK THEN (WRITE7(.LOC1);	! PUT START BLOCK ONLY IF
%3.22%						! STACK OR START DECLARATION
%3.22%  WRITE2(1^32 OR .MNAME+#2730,.LOC1,1)));
%3.38% IF NOT .LRH THEN (	! THE FOLLOWING CODE WAS MOVED HERE FROM H3DRIV
%2.25%	IF .MLFLG THEN MREGSOUT();	!OUTPUT SPECIAL REGISTER DECLARATIONS
%2.25%	MCPOUT();	!OUTPUT THE CONSTANT POINER AREA
%2.25%	MLITOUT();	!OUTPUT LITERALS AREA
%2.25%	    MPLITOUT();	! OUTPUT THE PLIT AREA
%2.25%	!NOW WE SWITCH TO LOSEG VIA RELOC PSEUDO-OP IN THE CASE WHERE WE
%2.25%	!ARE GENERATING A TWOSEG PROGRAM.  OTHERWISE WE LEAVE THE LOC
%2.25%	!COUNTER AS IS.
%2.25%	IF .MLFLG THEN
%2.25%	BEGIN
%2.25%	IF .TWOSEGFLG THEN
%2.25%	  (OUTPSTRING(PLIT (ASCIZ 'RELOC		;To low segment')); NEWLINE(););
%2.25%	NEWLINE();
%2.25%	OUTPSTRING(PLIT(ASCIZ ';GLOBAL area'));  NEWLINE();
       IF .GLOBLK GTR 0 THEN
        BEGIN  LOCAL DIFFER,DIFFER1;
          DIFFER_.NEXTGLOBAL-.GLOBLK;
          DIFFER1_.GLOBLK;
          MBLKOUT(GNAME<0,0>,0);GLOBLK_XWDOFFSET_-1;
          NEWLINE();
           MPLOUT(.GLOHEAD);
           IF .DIFFER GTR 0 THEN (OUTPSTRING(PLIT(ASCIZ 'BLOCK   '));
                 OUTMOC(.DIFFER));
                 GLOBLK_.DIFFER1
          END
        ELSE
%2.25%	MBLKOUT(GNAME<0,0>,.NEXTGLOBAL);	!OUTPUT GLOBAL AREA
%2.25%	NEWLINE();
%2.25%	OUTPSTRING(PLIT(ASCIZ ';OWN area'));  NEWLINE();
        IF .OWNBLK GTR 0 THEN
         BEGIN LOCAL DIFFER,DIFFER1;
           DIFFER_.NEXTOWN-.OWNBLK;
           DIFFER1_.OWNBLK;
           MBLKOUT(ONAME<0,0>,0);OWNBLK_XWDOFFSET_-1;
           NEWLINE();
           MPLOUT(.OWNHEAD);
          IF .DIFFER GTR 0 THEN (OUTPSTRING(PLIT(ASCIZ 'BLOCK   '));
                   OUTMOC(.DIFFER));
                OWNBLK_.DIFFER1
          END
        ELSE
%2.25%	MBLKOUT(ONAME<0,0>,.NEXTOWN);	!OUTPUT OWN AREA
%2.25%	NEWLINE();
%2.25%	END;
%3.38% );	! THE PRECEDING CODE WAS MOVED HERE FROM H3DRIV
    CTEP_.HDP+1;
    LOCC_.LOC1;
    WHILE
      (CTEP_.CTFPE) NEQ .HDP
     DO(    !REPLACE BACK LINKS BY LOCATION
      CTBPE_.LOCC;
      LOCC_.LOCC+1);
    LOC2_.LOCC;
    CTEP_.HDP+1;
    LOCC_.LOC1;
    PTLNK_#777777;
    WHILE
      (CTEP_.CTFPE) NEQ .HDP
     DO     !OUTPUT CODE
      OCOUT(.CTOCE,.CTCDE);
    CTEP_.PTLNK;
    IF
      .LOC1 NEQ .LOC2
     THEN(    !RELEASE CODE SPACE
      CTEP_.HDP;
      CTEP_.HDCPE;
      INCR I FROM 1 TO .LOC2-.LOC1 DO(
	CTEPS_.CTFPE;
	RELEASESPACE(.CTEP,1);
	CTEP_.CTEPS));
    IF
      NOT .LRH
     THEN(    !BLOCK HEADER.  OUTPUT NON-CODE SEGS.
      LOCC_.LOC2;
      WRITE2(#44^30 OR .MNAME+#2712,.LOC2,1);
      IF
        .PTREFNO GEQ 0
       THEN(    !CONSTANT POINTERS
        WRITE2(1^32 OR .GNAMES[6],.LOC2,1);
        INCR I TO .PTREFNO DO
          OCOUT(.PT[CTEP_.PTOFF[.I],1],.PT[.CTEP]<30,6>);
        LOC2_.LOCC);
      IF
%2.27%	.LTTBASE[0] NEQ 0		!IMPLIES THERE IS AT LEAST ONE LITERAL
       THEN(    !LITERAL TABLE
	WRITE2(1^32 OR .GNAMES[7],.LOC2,1);
%2.27%	INCR I FROM 0 TO LTNUM -1 DO
%2.9%	  INCR J FROM .LTTBASE[.I]<RIGHTHALF> TO .LTTBASE[.I]<LEFTHALF> +.LTTBASE[.I]<RIGHTHALF>-1 DO
%2.9%	    WRITE1(GETLITVAL(@@J),0);
	LOC2_.LOCC);
     !PLITS ARE LOADED INTO HISEG ONLY  5-9-77
      IF .PLNEXT GTR 0 THEN
          BEGIN
              WRITE2(1^32 OR .GNAMES[9],.LOCC,1);
              OUTPLITS(.PLHEAD);
               LOC2_.LOCC
          END;
      ORG2 _ 0;
      IF
	.NEXTGLOBAL GTR 0
  %
       THEN(    !GLOBAL DEFS
        WRITE2(#44^30 OR .GNAMES[4],IF .TWOSEGFLG THEN 0 ELSE REPLACEVAL(LOC2,.LOC2+.NEXTGLOBAL),1));
  %
       THEN BEGIN
        LOCC_IF .TWOSEGFLG THEN 0 ELSE REPLACEVAL(LOC2,.LOC2+.NEXTGLOBAL);
        WRITE2(#44^30 OR .GNAMES[4],.LOCC,1);
        IF .GLOBLK GTR 0 THEN
          (WOB1();GLOBLK_-1;OUTPLITS(.GLOHEAD);GLOBLK_0)
         END;
      IF
	.NEXTOWN GTR 0
    %
       THEN(    !OWN REGION
	WRITE2(1^32 OR .GNAMES[3],IF .TWOSEGFLG THEN .NEXTGLOBAL ELSE REPLACEVAL(LOC2,.LOC2+.NEXTOWN),1));
    %
       THEN BEGIN
          LOCC_IF .TWOSEGFLG THEN .NEXTGLOBAL ELSE
                   REPLACEVAL(LOC2,.LOC2+.NEXTOWN);
          WRITE2(1^32 OR .GNAMES[3],.LOCC,1);
          IF .OWNBLK GTR 0 THEN 
            (WOB1();OWNBLK_-1;OUTPLITS(.OWNHEAD);OWNBLK_0)
        END;
%3.36% IF .LSTART OR .PROFLG THEN
%3.36%	BEGIN
%3.36%	  STRUCTURE STEFSTR[I]=(.STEFSTR+.I)<STEF>;
%3.36%	  EXTERNAL STEFSTR RBREG;
%3.36%	  WRITE2(4^30 OR GETNAM(STSY(.RBREG[0]),5),
%3.36%		IF .TWOSEGFLG
%3.36%			THEN .NEXTGLOBAL+.NEXTOWN
%3.36%			ELSE REPLACEVAL(LOC2,.LOC2+1) ,1);
%3.36%	  IF .MLFLG THEN
%3.36%	    BEGIN
%3.36%	      OUTPSTRING(PLIT(ASCIZ '.BREG::	BLOCK	1	;CO-ROUTINE PSEUDO-REGISTER'));
%3.36%	      NEWLINE()
%3.36%	    END
%3.36%	END;
    ! DELETE THE FOLLOWING LINES BECAUSE PLITS ARE IN HISEG NOW
    %       DELETED ON  5-9-77
	IF .PLNEXT GTR 0 THEN
	    BEGIN		! PLITS
	    LOCAL PLOW;
	    LOCC=(IF
		(PLOW_(IF .TWOSEGFLG THEN .B20FLG ELSE 0))
		THEN .NEXTGLOBAL+.NEXTOWN+
		    (IF .LSTART OR .PROFLG THEN 1 ELSE 0)
		ELSE .LOC2);
	    WRITE2(1^32 OR .GNAMES[9],.LOCC,1);
	    WOB1();		! IN CASE  WE SWITCHED SEGMENTS
	    OUTPLITS(.PLHEAD);
	    IF NOT .PLOW THEN
		LOC2=.LOCC;
	    END;
      %
      CTEP_.ETP;
      WHILE
        .CTEP NEQ #77777
       DO(    !LINK EXTERNAL REQUESTS
        WRITE2(6^33 OR GETNAM(STSY(.CTBPE),6),.CTOCE,1);
        CTEP_.CTFPE);
%3.38%	IF .MLFLG THEN MEXTOUT();	!OUTPUT EXTERNAL DECLARATIONS
%3.38%	MENDOUT();	!OUTPUT END PSEUDO-OP LINE
      WRITE5())
   END;    !LDINT



!END OF H3LDIN.BLI
  