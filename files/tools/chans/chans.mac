;<TOOLS.CHANS>CHANS.MAC.3, 28-Dec-2001 03:01:55, Edit by MRC
;PANDA changes
; [1] RM05 support
; UPD ID= 20, SNARK:<6.1.TOOLS-TAPE>CHANS.MAC.2,   9-May-85 14:44:30 by PAETZOLD
;Add NI Channel type
;<GRANT>CHANS.MAC.13, 22-Dec-84 07:21:46, EDIT BY GRANT
;Add drive serial number to units display
;<V-SOURCES>CHANS.MAC.11, 27-Jun-84 23:11:27, Edit by MCLEAN
;MAKE UDB CHANGES
;<V-SOURCES>CHANS.MAC.9, 27-Jun-84 12:54:58, Edit by PURRETTA
;Output channel,controller and unit numbers in decimal
;<V-SOURCES>CHANS.MAC.7, 14-May-84 21:27:05, Edit by MCLEAN
;ADD TA78'S
;<MCCOLLUM>CHANS.MAC.2 18-Jan-84 13:45:48, Edit by MCCOLLUM
;Fix values of CDB, KDB, and UDB symbols for 6.0
;<V-SOURCES>CHANS.MAC.5, 23-Sep-83 07:09:55, EDIT BY GRANT
;Add CI to channel type table
;<PURRETTA>CHANS.MAC.9,  8-Jul-83 12:17:03, Edit by PURRETTA
;Change UDBDDP to UDBDDD (this changed during release 5)
;<PURRETTA>CHANS.MAC.8,  7-Jul-83 17:25:10, Edit by PURRETTA
;Show if disk is dual-ported in status display.
;<SWSKIT>CHANS.MAC.6, 10-Jan-82 15:08:46, EDIT BY ZIMA
;[106] Require SYS:DPY so build works.

	TITLE	CHANS	PROGRAM TO DUMP CHANNEL INFORMATION
	SUBTTL	DAVID I. BELL/DIB/JGZ



	SEARCH	MONSYM,MACSYM	;GET DEFINITIONS
	SEARCH	DPYDEF		;GET DEFINITIONS FOR DPY TOO
	.REQUIRE SYS:DPY	;GET DPY CODE
	SALL			;NICE MACROS


	VERSION==4		;VERSION
	EDIT==110		;EDIT NUMBER


;ACCUMULATORS:


	F=0			;FLAGS
	T1=1			;USUAL USE
	T2=2
	T3=3
	T4=4
	C=5			;AOBJN POINTER OVER CHANNELS
	CN=6			;CHANNEL NUMBER
	K=7			;AOBJN POINTER OVER CONTROLLERS
	KN=10			;CONTROLLER NUMBER
	U=11			;AOBJN POINTER OVER UNITS
	UN=12			;UNIT NUMBER
	I=13			;INDEX FOR COLUMN OUTPUT
	X=14			;OUTPUT AC
	P=17			;STACK


;FLAG BITS:


	FR.CDB==1		;SHOW CDBS
	FR.KDB==2		;SHOW KDBS
	FR.UDB==4		;SHOW UDBS
	FR.TAP==10		;SHOW MAGTAPE UDBS
	FR.DSK==20		;SHOW DISK UDBS
	FR.DPY==40		;USE DPY
	FR.XIT==100		;LEAVE PROGRAM
	FR.COL==200		;A COLUMN HAS BEEN OUTPUT
	FR.TWO==400		;TWO OR MORE OF CDB, KDB, UDB IS SHOWN
	FR.END==1000		;WE SAW END OF SCREEN LAST UPDATE
	FR.REF==2000		;REFRESH THE SCREEN

;USEFUL RANDOM DEFINITIONS:


	PDLSIZ==30		;STACK SIZE
	TABMAX==^D80		;MAXIMUM COLUMN FOR TAB STOPS
	COLGAP==1		;SPACES BETWEEN COLUMNS
	BLKSIZ==^D100		;MAXIMUM SIZE OF A BLOCK
	MTAMAX==^D32		;MAXIMUM NUMBER OF MAGTAPES
	SLPTIM==^D100		;SLEEP TIME




;PHYPAR DEFINITIONS:


	CHNNUM==^D8		;NUMBER OF CHANNELS
	BLKTYP==POINT 2,0,30	;BYTE POSITION OF BLOCK TYPE FIELD
	DEVTYP==POINT 5,0,35	;BYTE POSITION OF DEVICE TYPE FIELD
	.BTKDB==2		;BLOCK TYPE FOR KDB
	CS.OFL==1B0		;CDB IS OFFLINE
	CS.AC1==1B1		;PRIMARY ACTIVE
	CS.AC2==1B2		;SECONDARY ACTIVE
	KS.ACT==1B1		;KDB IS ACTIVE
	KS.HLT==1B2		;MICROCODE IS HALTED
	US.OFS==1B0		;UDB IS OFFLINE
	US.POS==1B2		;POSITIONING IN PROGRESS
	US.ACT==1B3		;ACTIVE
	US.PGM==1B6		;DUAL PORTED
	US.REW==1B10		;UNIT IS REWINDING
	US.WLK==1B11		;UNIT IS WRITE-LOCKED
	US.OIR==1B13		;OPERATOR INTERVENTION REQUIRED
	US.TAP==1B16		;THIS IS A TAPE DEVICE
	UDBDSN==16		;OFFSET FOR DRIVE SERIAL NUMBER

	SUBTTL	DISPATCH MACROS




;THE FOLLOWING MACRO DEFINES THE COLUMNS WHICH EXIST.
;ARGUMENTS TO THE IMBEDDED XX MACRO ARE:
;
;	XX	HEADER,CDB-DISPATCH,KDB-DISPATCH,UDB-DISPATCH,BITS
;
;WHERE:
;
;HEADER/	THE NAME OF THIS COLUMN (NUMBER OF CHARS GIVES WIDTH)
;CDB-DISPATCH/	ROUTINE TO TYPE THE COLUMN FOR CHANNELS
;KDB-DISPATCH/	ROUTINE TO TYPE THE COLUMN FOR CONTROLLERS
;UDB-DISPATCH/	ROUTINE TO TYPE THE COLUMN FOR UNITS
;BITS/		FLAGS TO BE IN COLBIT IF DEFAULT NOT WANTED
;
;IF A COLUMN MAKES NO SENSE FOR ONE OF THE CDB, KDB, OR UDB TYPEOUTS,
;THEN LEAVE IT NULL.



	DEFINE	TABLE,<

XX	Block,TYPCBK,TYPKBK,TYPUBK,FR.TWO	;;BLOCK TYPE
XX	< Addr >,TYPADR,TYPADR,TYPADR		;;MONITOR ADDRESS OF BLOCK
XX	Chan,TYPCNM,TYPCNM,TYPCNM		;;CHANNEL NUMBER
XX	Ctrl,,TYPKNM,TYPKNM			;;CONTROLLER NUMBER
XX	Unit,,,TYPUNM				;;UNIT NUMBER
XX	Device,,,TYPDEV				;;DEVICE NAME
XX	<Type >,TYPCTP,TYPKTP,TYPUTP		;;TYPE OF DEVICE
XX	<Cyl/File>,,,TYPCYL			;;CURRENT CYLINDER/FILE
XX	<Sec/Rec >,,,TYPSEC			;;CURRENT SECTOR/RECORD
XX	<DSN  >,,,TYPDSN			;;DRIVE SERIAL NUMBER
XX	Status,TYPCST,TYPKST,TYPUST		;;STATUS FLAGS
>

	SUBTTL	MAIN PROGRAM



ENTRY:	JRST	CHANS		;START ADDRESS
	JRST	CHANS		;REENTRY ADDRESS
	BYTE	(3)0(9)VERSION(6)0(18)EDIT	;VERSION


CHANS:	RESET			;RESET EVERYTHING
	MOVE	P,[IOWD	PDLSIZ,PDL]	;SET UP STACK
	MOVE	T1,[CALL DPYUUO]	;GET READY
	MOVEM	T1,.JB41##	;SET UP LUUO
	SETZM	PAGE		;ON THE FIRST PAGE
	CALL	GETSYM		;READ IN SYMBOLS WE NEED
	MOVE	T1,CHNTAB	;GET ADDRESS WHERE TO READ FROM
	MOVEI	T2,TABCDB	;AND WHERE TO COPY TO
	MOVEI	T3,CHNNUM	;NUMBER OF WORDS
	CALL	READ		;READ THE DATA
	MOVE	T1,MTCUTB	;GET ADDRESS WHERE TO READ FROM
	MOVEI	T2,TABMTC	;AND ADDRESS TO COPY TO
	MOVE	T3,MTAN		;NUMBER OF WORDS
	CALL	READ		;COPY THE DATA

ASK:	SETZ	F,		;CLEAR FLAGS
	HRROI	T1,[ASCIZ/
Options (any of C=CDB, K=KDB, U=UDB, T=tapes, D=disks, V=video): /]
	PSOUT			;ASK

GETIN:	PBIN			;GET INPUT
	CAIE	T1,177		;RUBOUT?
	CAIN	T1,"U"-100	;OR ^U?
	JRST	ASK		;YES, RESTART
	CAIL	T1,"A"+40	;LOWER CASE?
	CAILE	T1,"Z"+40	;WELL?
	SKIPA			;NO
	SUBI	T1,40		;YES, CONVERT
	CAIN	T1,"V"		;WANTS VIDEO DISPLAY?
	TXO	F,FR.DPY	;YES
	CAIN	T1,"E"		;EXIT PROGRAM?
	TXO	F,FR.XIT	;YES
	CAIN	T1,"C"		;SHOW CDBS?
	TXO	F,FR.CDB	;YES
	CAIN	T1,"K"		;SHOW KDBS?
	TXO	F,FR.KDB	;YES
	CAIN	T1,"U"		;SHOW UDBS?
	TXO	F,FR.UDB	;YES
	CAIN	T1,"T"		;SEE ONLY TAPES?
	TXO	F,FR.TAP!FR.UDB	;YES
	CAIN	T1,"D"		;SEE ONLY DISKS?
	TXO	F,FR.DSK!FR.UDB	;YES
	CAIE	T1,12		;LINE FEED?
	JRST	GETIN		;NO, EAT

	TXNE	F,FR.XIT	;WANTS TO LEAVE?
	JRST [	HALTF		;YES, QUIT
		JRST ASK]	;AND ASK AGAIN IF CONTINUED
	TXNN	F,FR.CDB!FR.KDB!FR.UDB	;ANY BLOCK TYPE SELECTED?
	TXO	F,FR.CDB!FR.KDB!FR.UDB	;NO, USE ALL
	TXNN	F,FR.TAP!FR.DSK	;ANY TYPE OF DEVICE SELECTED?
	TXO	F,FR.TAP!FR.DSK	;NO, USE ALL
	MOVX	T1,FR.CDB!FR.KDB!FR.UDB	;GET ALL TYPES OF BLOCKS
	AND	T1,F		;KEEP ONLY WHAT WAS SELECTED
	MOVN	T2,T1		;NEGATE
	AND	T2,T1		;SELECT RIGHTMOST NONZERO BIT
	CAME	T1,T2		;THE ONLY BIT THAT'S SET?
	TXO	F,FR.TWO	;NO, THEN HAVE MULTIPLE BITS
	TXNE	F,FR.DPY	;WANTS DPY?
	CALL	NOECHO		;YES, TURN OFF ECHOING
	TXNE	F,FR.DPY	;WELL?
	INI$			;YES, INITIALIZE
	TXO	F,FR.END	;ACT LIKE SAW THE END OF THE DISPLAY


LOOP:	SETZM	COLUMN		;AT FIRST COLUMN
	TXNN	F,FR.DPY	;USING DPY?
	CALL	CRLF		;NO, START WITH CRLF
	CALL	HEADER		;TYPE PROPER HEADER AND SET TAB STOPS
	MOVE	C,[-CHNNUM,,TABCDB]	;POINT TO CDB TABLE
	SETZ	CN,		;START WITH CHANNEL 0

LOPCDB:	CALL	DOCHAN		;SHOW DATA FOR THIS CHANNEL
	ADDI	CN,1		;INCREMENT CHANNEL NUMBER
	AOBJN	C,LOPCDB	;LOOP OVER THEM ALL
	TXNE	F,FR.DPY	;NOT USING DPY?
	CALL	DODPY		;OR TIME TO QUIT?
	 JRST	ASK		;YES, GET A NEW COMMAND
	MOVEI	T1,SLPTIM	;NO, GET SLEEP TIME
	DISMS			;WAIT A BIT
	JRST	LOOP		;THEN LOOP

	SUBTTL	ROUTINES TO HANDLE STUFF WHEN DOING VIDEO OUTPUT




;CALLED AFTER A SCREEN HAS BEEN OUTPUT TO DPY, TO SHOW IT AND CHECK FOR
;COMMANDS.  ONLY COMMANDS ARE:  "E" FOR EXIT, " " FOR SHOW NEXT SCREEN,
;"R" FOR REFRESH, AND CRLF FOR RETURN TO COMMAND LEVEL.



DODPY:	LOC$	T1		;GET LAST LOCATION TYPED TO DPY
	SKIPL	T1		;DID SCREEN FILL UP?
	TXOA	F,FR.END	;NO, SAY END OF SCREEN WAS SEEN
	TXZ	F,FR.END	;YES, SAY MORE TO GO ON NEXT SCREEN
	SET$	[$SEEAT,,0]	;RESET TO NO EATING
	HRROI	T1,[ASCIZ/---
/]				;GET FINAL TEXT
	CALL	STROUT		;OUTPUT IT



CHKCMD:	MOVEI	T1,.PRIIN	;PRIMARY INPUT
	SIBE			;ANYTHING THERE?
	 JRST	HAVCMD		;YES, GO HANDLE IT
	TXNN	F,FR.REF	;WANT A REFRESH OF SCREEN?
	DPY$	DP$NOH		;NO, DO NORMAL UPDATE
	TXZE	F,FR.REF	;WELL?
	REF$	RE$NOH!RE$CLR	;YES, REFRESH SCREEN
	AOS	(P)		;SKIP RETURN
	RET			;TO SAY CONTINUE LOOPING

;HERE WHEN WE HAVE A COMMAND CHARACTER IN T1:


HAVCMD:	PBIN			;READ THE COMMAND
	CAIL	T1,"A"+40	;LOWER CASE?
	CAILE	T1,"Z"+40	;WELL?
	SKIPA			;NO
	SUBI	T1,40		;YES, TURN INTO UPPER CASE
	CAIE	T1,"R"		;WANT TO REFRESH?
	CAIN	T1,"E"		;OR EXIT?
	TXO	F,FR.REF	;YES, REMEMBER TO REFRESH SCREEN
	CAIE	T1,12		;WANT TO GO BACK TO COMMAND LEVEL?
	CAIN	T1,"E"		;OR EXIT?
	TTY$	$TTCLR		;YES, CLEAR THE SCREEN
	CAIN	T1,12		;WANT TO RETURN NOW?
	JRST	ECHO		;YES, ECHO TERMINAL AND RETURN
	CAIN	T1,"E"		;WANT TO EXIT?
	HALTF			;YES, DO THAT
	CAIE	T1," "		;A SPACE?
	JRST	CHKCMD		;NO, LOOK FOR MORE COMMANDS
	TXNN	F,FR.END	;YES, SAW END OF SCREEN THIS TIME?
	AOSA	PAGE		;NO, MOVE TO NEXT PAGE
	SETZM	PAGE		;YES, RESET BACK TO FIRST ONE
	JRST	CHKCMD		;LOOK FOR MORE COMMANDS




;ROUTINES TO ECHO AND NOECHO THE TERMINAL:


ECHO:	SKIPA	T3,[TXO	T2,TT%ECO]	;SET INSTRUCTION
NOECHO:	MOVE	T3,[TXZ	T2,TT%ECO]	;OR OTHER ONE
	MOVEI	T1,.PRIIN	;INPUT
	RFMOD			;READ CURRENT TERMINAL STATUS
	XCT	T3		;CHANGE AS DESIRED
	SFMOD			;TELL MONITOR ABOUT IT
	RET			;DONE

	SUBTTL	ROUTINE TO SHOW CHANNEL STATUS




;CALLED TO TYPE THE STATUS OF A SINGLE CHANNEL, AND ALL OF THE
;KDBS AND UDBS UNDER IT.  CALL:
;	C/	POINTER TO CDB ADDRESS
;	CN/	CHANNEL NUMBER
;	TABCDB	FILLED IN




DOCHAN:	SKIPN	T1,(C)		;GET ADDRESS OF THIS CHANNEL
	RET			;DOESN'T EXIST
	MOVEM	T1,ADDR		;REMEMBER FOR TYPEOUT
	MOVEI	T2,DATCDB	;GET ADDRESS OF WHERE TO PUT DATA
	MOVE	T3,CDBDDP	;ALSO SIZE OF BLOCK
	CALL	READ		;READ CDB INTO CORE
	MOVEI	T1,DSPCDB	;POINT TO DISPATCH TABLE
	TXNE	F,FR.CDB	;WANTS TO SHOW CDBS?
	CALL	INFO		;YES, TYPE INFORMATION
	MOVE	K,CDBIUN	;GET OFFSET FOR UBD/KDB POINTER
	MOVE	K,DATCDB(K)	;GET THE POINTER
	SUB	K,(C)		;REMOVE OFFSET
	ADDI	K,DATCDB	;AND ADD OUR OWN
	SETZ	KN,		;CLEAR CONTROLLER NUMBER

LOPKDB:	CALL	DOCONT		;SHOW DATA ON THIS CONTROLLER
	ADDI	KN,1		;MOVE TO NEXT ONE
	AOBJN	K,LOPKDB	;LOOP OVER THEM ALL
	RET			;DONE

;ROUTINES TO TYPE THINGS ABOUT A CHANNEL:



TYPCNM:	MOVEI	X," "		;GET SPACE
	CALL	CHROUT		;OUTPUT IT
	MOVE	T1,CN		;GET CHANNEL NUMBER
	JRST	DECOUT		;GO OUTPUT IT IN DECIMAL



TYPCBK:	MOVEI	T1,[ASCIZ/CDB/]	;THIS IS A CDB
	JRST	STROUT		;OUTPUT THAT



TYPADR:	MOVE	T1,ADDR		;GET ADDRESS
	JRST	OCTOUT		;OUTPUT IT



TYPCTP:	LDB	T1,[DATCDB+DEVTYP]	;GET TYPE OF DEVICE
	MOVEI	T2,TYPCDB	;POINT TO CDB TABLE
	JRST	GIVTYP		;OUTPUT TYPE OF CHANNEL



TYPCST:	MOVE	T2,DATCDB	;GET WORD OF BITS
	MOVEI	T1,[ASCIZ/Offline /]
	TXNE	T2,CS.OFL	;OFFLINE?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Active /]
	TXNE	T2,CS.AC1	;ACTIVE?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Secondary-active /]
	TXNE	T2,CS.AC2	;SECONDARY ACTIVE?
	CALL	STROUT		;YES
	RET			;DONE

	SUBTTL	ROUTINE TO SHOW STATUS OF A CONTROLLER




;CALLED TO SHOW THE STATUS OF A CONTROLLER, IF IT EXISTS.  THIS
;ROUTINE SHOWS THE STATUS OF ALL UNITS UNDER THE CONTROLLER TOO.




DOCONT:	SKIPN	T1,(K)		;IS THIS CONTROLLER IN EXISTANCE?
	RET			;NO, RETURN
	MOVEM	T1,ADDR		;YES, REMEMBER ADDRESS
	MOVEI	T2,DATKDB	;POINT TO STORAGE
	MOVE	T3,KDBDDP	;NUMBER OF WORDS TO READ
	CALL	READ		;READ THEM
	LDB	T1,[DATKDB+BLKTYP]	;GET BLOCK TYPE
	CAIE	T1,.BTKDB	;IS THIS REALLY A KDB?
	JRST	NOCONT		;NOPE, THEN WE HAVE NO CONTROLLER
	MOVEI	T1,DSPKDB	;POINT TO DISPATCH TABLE
	TXNE	F,FR.KDB	;WANTS TO SEE INFO?
	CALL	INFO		;YES, TYPE INFORMATION ABOUT IT
	MOVE	U,KDBIUN	;GET OFFSET FOR UDB POINTER
	MOVE	U,DATKDB(U)	;GET THE POINTER
	SUB	U,(K)		;REMOVE OFFSET
	ADDI	U,DATKDB	;AND ADD OUR OWN
	SETZ	UN,		;CLEAR UNIT NUMBER

LOPUDB:	CALL	DOUNIT		;SHOW DATA ABOUT THIS UNIT
	ADDI	UN,1		;MOVE TO NEXT ONE
	AOBJN	U,LOPUDB	;LOOP OVER THEM ALL
	RET			;DONE




;HERE IF THERE IS NO CONTROLLER:


NOCONT:	PUSH	P,KN		;SAVE CONTROLLER NUMBER
	MOVE	U,K		;POINT TO RIGHT DATA
	MOVE	UN,KN		;SET UNIT NUMBER
	SETO	KN,		;INDICATE NO CONTROLLER EXISTS
	CALL	DOUNIT		;TYPE INFORMATION ABOUT THE UNIT
	POP	P,KN		;RESTORE CONTROLLER NUMBER
	RET			;DONE

;ROUTINES TO TYPE INFORMATION ABOUT A CONTROLLER:



TYPKNM:	MOVEI	X," "		;GET SPACE
	CALL	CHROUT		;OUTPUT IT
	MOVE	T1,KN		;GET CONTROLLER NUMBER
	JRST	DECOUT		;OUTPUT IT IN DECIMAL



TYPKBK:	MOVEI	T1,[ASCIZ/ KDB/]	;GET STRING
	JRST	STROUT		;OUTPUT IT



TYPKTP:	LDB	T1,[DATKDB+DEVTYP]	;GET DEVICE TYPE
	MOVEI	T2,TYPKDB	;AND ADDRESS OF TABLE
	JRST	GIVTYP		;GO OUTPUT IT



TYPKST:	MOVE	T2,DATKDB	;GET WORD OF BITS
	MOVEI	T1,[ASCIZ/Active /]	;GET READY
	TXNE	T2,KS.ACT	;ACTIVE?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Halted /]	;GET READY
	TXNE	T2,KS.HLT	;IS MICROCODE CROAKED?
	CALL	STROUT		;YES
	RET			;DONE

	SUBTTL	ROUTINE TO SHOW DATA ABOUT A UNIT




;CALLED TO SHOW DATA ABOUT A UNIT.




DOUNIT:	SKIPN	T1,(U)		;ANYTHING THERE?
	RET			;NOPE, RETURN
	MOVEM	T1,ADDR		;REMEMBER ADDRESS
	MOVEI	T2,DATUDB	;POINT TO STORAGE
	MOVE	T3,UDBDDD	;GET NUMBER OF WORDS
	CALL	READ		;READ IN THE WORDS
	MOVE	T1,F		;COPY FLAGS
	ANDX	T1,FR.DSK!FR.TAP	;PRESERVE ONLY DEVICE TYPE FLAGS
	MOVE	T2,DATUDB	;GET UDB STATUS
	TXNN	T2,US.TAP	;TAPE?
	TXZA	T1,FR.TAP	;NOPE, CLEAR ONE FLAG
	TXZ	T1,FR.DSK	;YES, CLEAR OTHER FLAG
	JUMPE	T1,CPOPJ	;IF NO FLAG LEFT, DON'T SHOW IT
	MOVEI	T1,DSPUDB	;POINT TO DISPATCH TABLE
	TXNE	F,FR.UDB	;WANTS INFORMATION ON IT?
	CALL	INFO		;YES, OUTPUT INFORMATION
	RET			;DONE

;ROUTINES TO TYPE STUFF ABOUT A UNIT:



TYPUNM:	MOVEI	X," "		;GET SPACE
	CALL	CHROUT		;OUTPUT IT
	MOVE	T1,UN		;GET SUPPOSED UNIT NUMBER
	JUMPL	KN,DECOUT	;CORRECT IF NO CONTROLLER
	MOVE	T1,UDBSLV	;GET OFFSET
	HRRZ	T1,DATUDB(T1)	;THEN GET SLAVE NUMBER
	JRST	DECOUT		;OUTPUT IT IN DECIMAL



TYPUBK:	MOVEI	T1,[ASCIZ/  UDB/]	;GET STRING
	JRST	STROUT		;TYPE IT



TYPUTP:	LDB	T1,[DATUDB+DEVTYP]	;GET DEVICE TYPE
	MOVEI	T2,TYPUDB	;POINT TO TABLES
	JRST	GIVTYP		;OUTPUT TYPE



TYPUST:	MOVE	T2,DATUDB	;GET WORD OF BITS
	MOVEI	T1,[ASCIZ/Offline /]
	TXNE	T2,US.OFS	;OFFLINE?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Positioning /]
	TXNE	T2,US.POS	;POSITIONING?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Active /]
	TXNE	T2,US.ACT	;ACTIVE?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Dual-ported /]
	TXNE	T2,US.PGM	;DUAL-PORTED?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Rewinding /]
	TXNE	T2,US.REW	;REWINDING?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/OPR-action /]
	TXNE	T2,US.OIR	;OPERATOR INTERVENTION?
	CALL	STROUT		;YES
	MOVEI	T1,[ASCIZ/Write-locked /]
	TXNE	T2,US.WLK	;WRITE-LOCKED?
	CALL	STROUT		;YES
	RET			;DONE



TYPCYL:	SKIPA	T1,UDBPS1	;GET OFFSET FOR FIRST POSITION WORD
TYPSEC:	MOVE	T1,UDBPS2	;OR OFFSET FOR OTHER POSITION WORD
	MOVE	T1,DATUDB(T1)	;GET CYLINDER/FILE OR SECTOR/RECORD
	JRST	OCTOUT		;OUTPUT IT

TYPDEV:	MOVE	T1,DATUDB	;GET STATUS WORD
	TXNN	T1,US.TAP	;IS THIS A TAPE DEVICE?
	JRST	ISSTR		;NO, GO SHOW STRUCTURE
	HRLZ	T4,MTAN		;GET NUMBER OF MAGTAPES
	JUMPE	T4,CPOPJ	;FAIL IF NONE
	MOVN	T4,T4		;MAKE INTO AOBJN POINTER
	HRRZ	T1,TABMTC(T4)	;GET NEXT MAGTAPE UDB
	CAME	T1,ADDR		;FOUND IT?
	AOBJN	T4,.-2		;NO, KEEP LOOKING
	JUMPGE	T4,CPOPJ	;FAIL IF NOT FOUND
	MOVEI	T1,[ASCIZ/MTA/]	;GET STRING
	CALL	STROUT		;OUTPUT IT
	HRRZ	T1,T4		;GET UNIT NUMBER
	JRST	DECOUT		;OUTPUT IT IN DECIMAL


ISSTR:	MOVE	T1,UDBSTR	;GET OFFSET
	SKIPGE	T1,DATUDB(T1)	;GRAB THE STRUCTURE INDEX
	RET			;NOT PART OF STRUCTURE, RETURN
	ADD	T1,STRTAB	;ADD ADDRESS OF STRTAB IN
	MOVEI	T2,T4		;POINT TO AC
	CALL	READ1		;READ SDB ADDRESS
	SKIPN	T1,T4		;GET ADDRESS
	RET			;ISN'T ONE
	MOVEI	T2,T4		;AGAIN
	CALL	READ1		;READ STRUCTURE NAME
	MOVE	T1,T4		;MOVE TO RIGHT AC
	JRST	SIXOUT		;OUTPUT STRUCTURE NAME


TYPDSN:	MOVE T1,DATUDB+UDBDSN	;GET UDB
	JRST DECOUT		;OUTPUT IT IN DECIMAL

	SUBTTL	UTILITY ROUTINES




;ROUTINE TO READ IN MONITOR DATA USING PEEK JSYS.  CALL:
;	T1/	MONITOR ADDRESS
;	T2/	LOCATION TO READ INTO
;	T3/	NUMBER OF WORDS
;THERE IS A MAXIMUM NUMBER OF WORDS WE CAN READ WHICH IS BLKSIZ.
;CALL AT READ1 TO READ JUST ONE WORD.


READ1:	MOVEI	T3,1		;SET FOR JUST ONE WORD
READ:	SKIPLE	T3		;VERIFY HAVE GOOD NUMBER
	CAILE	T3,BLKSIZ	;AND NOT TOO MANY
	JRST	BADRED		;WRONG
	HRL	T1,T3		;PUT WORD COUNT IN RIGHT AC
	PEEK			;TRY THE READ
	 ERJMP	LOSE		;FAILED
	RET			;OK, IT WORKED

BADRED:	HRROI	T1,[ASCIZ/
? Bad number of words being PEEKed
/]
	PSOUT			;SAY WHAT IS WRONG
	HALTF			;QUIT
	JRST	.-1		;STAY THAT WAY

;ROUTINE TO SNOOP ALL THE SYMBOLS WE NEED.



GETSYM:	MOVEI	T1,.SNPSY	;WANT TO READ A SYMBOL
	MOVE	T2,[RADIX50 0,CHNTAB]	;GET SYMBOL
	MOVE	T3,[RADIX50 0,STG]	;AND MODULE
	SNOOP			;READ IT
	 ERJMP	LOSE		;FAILED
	MOVEM	T2,CHNTAB	;REMEMBER VALUE
	MOVEI	T1,.SNPSY	;AGAIN
	MOVE	T2,[RADIX50 0,STRTAB]	;SYMBOL
	SNOOP			;READ IT
	 ERJMP	LOSE		;FAILED
	MOVEM	T2,STRTAB	;REMEMBER VALUE
	MOVEI	T1,.SNPSY	;AGAIN
	MOVE	T2,[RADIX50 0,MTCUTB]	;SYMBOL
	SNOOP			;READ IT
	 ERJMP	LOSE		;FAILED
	MOVEM	T2,MTCUTB	;REMEMBER IT
	MOVEI	T1,.SNPSY	;AGAIN
	MOVE	T2,[RADIX50 0,MTAN]	;SYMBOL
	SNOOP			;READ IT
	 ERJMP	LOSE		;FAILED
	MOVEM	T2,MTAN		;REMEMBER IT
	RET			;DONE

;ROUTINE TO TYPE JSYS FAILURES:



LOSE:	HRROI	T1,[ASCIZ/
? /]				;START IT
	PSOUT			;TYPE
	MOVEI	T1,.PRIOU	;TO TERMINAL
	HRLOI	T2,.FHSLF	;LAST ERROR IN THIS FORK
	SETZ	T3,		;INFINITE OUTPUT
	ERSTR			;TYPE IT
	 JFCL			;FAILED
	 JFCL			;ALSO FAILED
	HRROI	T1,[ASCIZ/
/]				;GET A CRLF
	PSOUT			;FINISH IT
	HALTF			;QUIT
	JRST	.-1		;STAY THAT WAY

	SUBTTL	ROUTINE TO TYPE HEADER AND SET UP TAB STOPS



;ROUTINE CALLED TO DETERMINE WHICH COLUMNS OF OUTPUT ARE NEEDED,
;SET UP TAB STOPS FOR THOSE COLUMNS, AND THEN TYPE THE HEADER OUT.




HEADER:	MOVE	T1,[TABSTP,,TABSTP+1]	;GET READY
	SETZM	TABSTP			;CLEAR FIRST WORD
	BLT	T1,TABSTP+TABMAX-1	;THEN THE REST
	MOVSI	I,-COLNUM	;GET READY FOR LOOPING
	SETZ	T4,		;START AT POSITION ZERO
	TXZ	F,FR.COL	;NO COLUMN YET DONE

HDRLOP:	TDNN	F,COLBIT(I)	;THIS COLUMN TO BE SHOWN?
	JRST	HDRNXT		;NO, SKIP IT
	TXOE	F,FR.COL	;NEED A TAB BETWEEN COLUMNS?
	CALL	TAB		;YES, TYPE ONE
	HRRZ	T1,COLNAM(I)	;THEN GET NAME OF COLUMN
	CALL	STROUT		;OUTPUT IT
	HLRZ	T1,COLNAM(I)	;GET SIZE OF COLUMN
	ADDI	T4,COLGAP(T1)	;ADD TO GET NEW TAP STOP
	CAIGE	T4,TABMAX	;OUT OF TABLE RANGE?
	SETOM	TABSTP(T4)	;NO, SET A TAB STOP
HDRNXT:	AOBJN	I,HDRLOP	;LOOP OVER ALL COLUMNS
	CALL	CRLF		;END IN A CRLF
	CALL	CRLF		;AND ANOTHER ONE
	TXNN	F,FR.DPY	;DISPLAY OUTPUT?
	RET			;NO, ALL DONE
	MOVE	T1,@DPYTAB+$DPLEN	;GET LENGTH OF SCREEN
	SUBI	T1,2		;REDUCE EFFECTIVE SIZE BY WHAT HEADER USES
	IMUL	T1,PAGE		;MULTIPLY BY PAGE NUMBER
	TLNE	T1,-1		;TOO LARGE?
	MOVEI	T1,-1		;YES, LOWER TO MAXIMUM VALUE
	HRLI	T1,$SEEAT	;INSERT FUNCTION
	SET$	T1		;TELL DPY TO IGNORE SOME OUTPUT
	RET			;DONE

	SUBTTL	OUTPUT SUBROUTINES




;ROUTINE TO LOOP OVER ALL COLUMNS FOR A CDB, KDB, OR UDB, AND CALL
;THE VARIOUS SUBROUTINES TO OUTPUT DATA ABOUT EACH ONE.  CALL:
;	T1/	ADDRESS OF DISPATCH TABLE



INFO:	MOVEM	T1,DISADR	;SAVE DISPATCH ADDRESS
	MOVSI	I,-COLNUM	;SET UP FOR AOBJN LOOP
	TXZ	F,FR.COL	;NO COLUMN OUTPUT YET

INFO1:	TDNN	F,COLBIT(I)	;THIS COLUMN USED AT ALL?
	JRST	INFO3		;NO, SKIP IT
	TXOE	F,FR.COL	;TYPED A COLUMN YET?
	CALL	TAB		;YES, MOVE TO NEXT TAB STOP FIRST
	MOVE	T1,DISADR	;GET DISPATCH TABLE BACK
	ADDI	T1,(I)		;ADD IN OFFSET
	SKIPE	T1,(T1)		;GET ROUTINE TO BE CALLED
	CALL	(T1)		;AND CALL IT IF IT EXISTS
INFO3:	AOBJN	I,INFO1		;LOOP OVER ALL COLUMNS
	CALL	CRLF		;END IN A CRLF
	RET			;DONE






;ROUTINE TO OUTPUT THE TYPE OF A DEVICE.  CALL:
;	T1/	DEVICE TYPE
;	T2/	POINTER TO TYPE TABLE



GIVTYP:	SKIPN	(T2)		;RAN OUT OF ENTRIES?
	JRST	UNKTYP		;YES
	HLRZ	T3,(T2)		;NOPE, GET TYPE
	CAME	T1,T3		;IS THIS THE ONE?
	AOJA	T2,GIVTYP	;NOPE, LOOK SOME MORE
	HRRZ	T1,(T2)		;GET ADDRESS OF STRING
	JRST	STROUT		;AND OUTPUT IT

UNKTYP:	MOVEI	X,"#"		;UNKNOWN, GET HASH MARK
	CALL	CHROUT		;OUTPUT IT
	JRST	OCTOUT		;THEN TYPE DEVICE TYPE

;OTHER OUTPUT ROUTINES:



CRLF:	MOVEI	T1,[BYTE (7)15,12]	;GET TEXT
STROUT:	HRLI	T1,(POINT 7,)	;MAKE A BYTE POINTER
STROUL:	ILDB	X,T1		;GET CHAR
	JUMPE	X,CPOPJ		;RETURN IF NULL
	CALL	CHROUT		;OUTPUT IT
	JRST	STROUL		;LOOP UNTIL DONE



DECOUT:	SKIPA	T3,[^D10]	;SET UP RADIX
OCTOUT:	MOVEI	T3,^D8		;OR OTHER ONE
NUMOUT:	JUMPGE	T1,NUMPOS	;SKIP IF NOT NEGATIVE
	MOVEI	X,"-"		;GET MINUS SIGN
	CALL	CHROUT		;OUTPUT IT
	MOVM	T1,T1		;MAKE NUMBER POSITIVE
NUMPOS:	IDIVI	T1,(T3)		;GET DIGIT
	JUMPE	T1,NUMFIN	;DONE IF ZERO
	HRLM	T2,(P)		;SAVE DIGIT
	CALL	NUMPOS		;LOOP
	HLRZ	T2,(P)		;GET BACK DIGIT
NUMFIN:	MOVEI	X,"0"(T2)	;GET DIGIT
	JRST	CHROUT		;OUTPUT IT



SIXOUT:	JUMPE	T1,CPOPJ	;RETURN IF NULL
	SETZ	T2,		;CLEAR NEXT AC
	ROTC	T1,6		;SHIFT NEXT CHAR OVER
	MOVEI	X," "(T2)	;MAKE ASCII
	CALL	CHROUT		;OUTPUT IT
	JRST	SIXOUT		;LOOP

;HERE TO OUTPUT A SINGLE CHARACTER.  THIS IS CALLED BY ALL THE OTHER
;OUTPUT ROUTINES.  CHARACTER TO OUTPUT IS IN AC X.



CHROUT:	CAIN	X,"	"	;IS THIS A TAB?
	JRST	TAB		;YES, HANDLE IT
	CAIE	X,12		;END OF LINE?
	AOSA	COLUMN		;NO, INCREMENT COLUMN POSITION
	SETZM	COLUMN		;YES, RESET COLUMN
	TXNE	F,FR.DPY	;OUTPUT TO DPY?
	JRST [	CHI$ (X)	;YES, OUTPUT IT
		RET]		;AND RETURN
	PUSH	P,T1		;NO, SAVE AN AC
	MOVE	T1,X		;COPY CHAR
	PBOUT			;OUTPUT IT
	POP	P,T1		;RESTORE AC
CPOPJ:	RET			;DONE




;HERE ON A TAB:


TAB:	MOVEI	X," "		;CONVERT TO SPACE
	CALL	CHROUT		;OUTPUT ONE
	MOVE	X,COLUMN	;GET COLUMN COUNTER
	CAIGE	X,TABMAX	;TOO FAR?
	SKIPE	TABSTP(X)	;OR REACHED TAB STOP?
	RET			;YES, DONE
	JRST	TAB		;NOPE, SPACE AGAIN

	SUBTTL	TABLES




	DEFINE	XX(CODE,NAME),<		;;MACRO TO DEFINE TYPE TABLES
	XWD	CODE,[ASCIZ/NAME/]
>




TYPCDB:	XX	1,RH10		;TABLE OF CHANNEL TYPES
	XX	2,RH20
	XX	3,RH11
	XX	4,CI
	XX 	5,NI
	EXP	0




TYPKDB:	XX	4,TM02		;TABLE OF CONTROLLER TYPES
	XX	12,TM03
	XX	14,TM78
	XX	16,DX20A
	XX	23,DX20B
	XX	25,NODE
	XX	26,HSC50
	EXP	0




TYPUDB:	XX	1,RP04		;TABLE OF UNIT TYPES
	XX	2,RS04
	XX	3,TU45
	XX	5,RP05
	XX	6,RP06
	XX	7,RP07
	XX	10,RP08
	XX	11,RM03
	XX	13,TU77
	XX	15,TU78
	XX	17,TU70
	XX	20,TU71
	XX	21,TU72
	XX	22,TU73
	XX	24,RP20
IFN PANDASW,<	;[1]
	XX	25,RM05
>;IFN PANDASW
	XX	27,RA80
	XX	30,RA81
	XX	31,RA60
	XX	32,RA82
	XX	33,RA62
	XX	34,TA78
	EXP	0

;NOW EXPAND THE TABLE MACRO TO PRODUCE ALL THE NEEDED TABLES FOR THE
;COLUMNS WE WILL NEED.



	XALL			;SHOW EXPANSIONS NOW



DEFINE	XX(NAME,DSPC,DSPK,DSPU,BITS<0>),<

	.XX.==0			;;INITIALIZE FLAG WORD

	IFNB	<DSPC>,<.XX.==.XX.!FR.CDB>	;;ADD IN CDB IF NECESSARY
	IFNB	<DSPK>,<.XX.==.XX.!FR.KDB>	;;AND KDB
	IFNB	<DSPU>,<.XX.==.XX.!FR.UDB>	;;AND UDB
	IFN	<BITS>,<.XX.==BITS>		;;USE BITS IF SPECIFIED

	EXP	.XX.		;BITS NEEDED FOR NAME
>



COLBIT:	TABLE			;EXPAND THE BITS

DEFINE	XX(NAME,DSPC,DSPK,DSPU,BITS),<

	.XX.==0				;;INITIALIZE
	IRPC	<NAME>,<.XX.==.XX.+1>	;;COUNT CHARACTERS

	XWD	.XX.,[ASCIZ@NAME@]
>



COLNAM:	TABLE			;EXPAND COLUMN NAMES AND SIZES

	COLNUM==.-COLNAM	;NUMBER OF COLUMNS

DEFINE	XX(NAME,DSPC,DSPK,DSPU,BITS),<
	EXP	DSPC		;ROUTINE FOR NAME
>



DSPCDB:	TABLE			;EXPAND CHANNEL DISPATCH

DEFINE	XX(NAME,DSPC,DSPK,DSPU,BITS),<
	EXP	DSPK		;ROUTINE FOR NAME
>



DSPKDB:	TABLE			;EXPAND CONTROLLER DISPATCH

DEFINE	XX(NAME,DSPC,DSPK,DSPU,BITS),<
	EXP	DSPU		;ROUTINE FOR NAME
>



DSPUDB:	TABLE			;EXPAND UNIT DISPATCH

	SUBTTL	DATA STORAGE




;NORMAL STORAGE:


PDL:	BLOCK	PDLSIZ		;STACK
DATCDB:	BLOCK	BLKSIZ		;READ IN CDB
DATKDB:	BLOCK	BLKSIZ		;READ IN KDB
DATUDB:	BLOCK	BLKSIZ		;READ IN UDB
TABCDB:	BLOCK	CHNNUM		;READ IN CHNTAB
TABMTC:	BLOCK	MTAMAX		;READ IN MTCUTB
ADDR:	BLOCK	1		;ADDRESS OF CURRENT BLOCK
COLUMN:	BLOCK	1		;POSITION ON LINE
TABSTP:	BLOCK	TABMAX		;TAB STOPS
DISADR:	BLOCK	1		;DISPATCH TABLE CURRENTLY IN USE
PAGE:	BLOCK	1		;CURRENT PAGE NUMBER IF DPYING





;MONITOR SYMBOL VALUES USED (SOME FILLED IN BY SNOOPING):


CHNTAB:	BLOCK	1		;ADDRESS OF CHNTAB
STRTAB:	BLOCK	1		;ADDRESS OF STRTAB
MTCUTB:	BLOCK	1		;ADDRESS OF MTCUTB
MTAN:	BLOCK	1		;NUMBER OF MAGTAPE UNITS
CDBIUN:	EXP	4
CDBDDP:	EXP	64
KDBIUN:	EXP	1
KDBDDP:	EXP	30		;*** THIS VALUE IS INCORRECT ON PURPOSE ***
UDBSTR:	EXP	13
UDBPS1:	EXP	31
UDBPS2:	EXP	32
UDBSLV:	EXP	47
UDBDDD:	EXP	111



	END	<3,,ENTRY>
