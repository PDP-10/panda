;EDIT 240
;Reformat to TOPS20 coding conventions.
;Add FREEZE, UNFREEZE commands.
;Add STATUS USER command.
;EDIT 237
;Change default "till when" from "soon" to "one hour".
;EDIT 236
;Remove old SEARCH ALUPRM statement.
;EDIT 235
;Changed version number to 11
;-------
;This version shipped on tools tape with TOPS20 Release 5, although
;edit number had not been updated and was shipped as 233.
;EDIT 234
;Assemble ALUPRM as part of ALU rather than as universal.
;Put back default extension for CANCEL.
;Use ALU: instead of SYS: for second try for help file
;Give extension .RED for REDIT changes file.
;Type REDIT info in neater format

	TITLE ALU - AUTOMATED LIBRARY UPDATING
	SUBTTL DAVID WRIGHT	JUL., 1979

;BASED ON ALU BY JACK KRUPANSKY
;USER-DEPENDENT THINGS ARE IN ALUPRM.MAC

	SEARCH MONSYM,MACSYM

	SALL
	.REQUIRE SYS:MACREL

;SET DEFAULT F.T. SWITCHES

DEFINE ND (NAME,VALUE),<
	IFNDEF NAME,<NAME==VALUE>>

ND FTFUID,0	;DEFAULT IS NO UID IN SOURCE FILE
ND FTFCOM,0	;DEFAULT IS NOT AUTOMATIC FILCOM AFTER REPLACE
ND FTCOPO,0	;DEFAULT IS NO AUTOMATIC COPYING OF OUTPUT FILES
ND FTRUID,1	;DEFAULT IS REPLACE UID (IF UID BEING USED)
ND FTBAKF,1	;DEFAULT IS MAKE BACKUP FILE WITH RENAME
ND FTANYU,0	;DEFAULT IS REGISTERED USERS ONLY
ND FTGCPY,1	;DEFAULT IS ASK USER IF HE WANTS A COPY OF FILE
		; EVEN THOUGH IT IS RESERVED BY SOMEONE ELSE.
ND FTREDT,1	;DEFAULT IS RUN REDIT BEFORE REPLACE
ND FTCGET,1	;DEFAULT IS TO COPY FILE WHEN IT'S RESERVED

;VERSION INFORMATION:

	ALUMJR==11		;MAJOR VERSION
	ALUMNR==0		;MINOR VERSION
	ALUEDT==241		;EDIT LEVEL
	ALUWHO==0		;WHO LAST EDITED


;EDIT HISTORY
;==================================
;EDIT#   DATE	  WHO	WHY       !
;==================================
;
;233	6-Jul-81 /DAW	  If file is RENAME'd to the library, set the
;			generation-retention-count to the default of the
;			library.
;232	6-Jul-81 /DAW	  Implement /COPY and /NOCOPY switches on "GET" and
;			"QGET" commands.
;			  FTCGET feature test switch: = 1 means the default
;			is /COPY on GET and QGET, = 0 means default is /NOCOPY.
;231	6-Jul-81 /DAW	  Add "INFORMATION (ABOUT) VERSION" command,
;			put out whole version number (including "minor"
;			and "who" field) to FILUPD.HST.
;			 Don't depend on user defining LIB: the same way
;			as is in ALU's table for REPLACE to work correctly.
;			 STATUS to print out "lib: = " before each library
;			directory.
;			 Allow user to be on a different structure and
;			REPLACE (until now this hasn't worked with all
;			flavors of ALU).
;			 When replacing generated output files, do the same
;			typeout as the EXEC when it does a COPY.
;
;*** VERSION 10    July 3,1981 ***
;
;230	2-Jul-81 /DAW	 Add another argument to LIB macro; to allow
;			different libraries to have different FILUPD.HST's
;			and places to put .DIF and .SCM files.
;			 Changed COMMENT command to ask which library's
;			FILUPD.HST you want to put a comment in.
;			 Also ALUPRM files are now incompatible, so ALU is
;			now version 10.
;227	2-Jul-81 /DAW	 Delete switch FTRCD (use connected directory
;			on replaces); this is reasonable for all ALU's
;			to do.
;			 Add DFLIB feature: If you define DFLIB in
;			ALUPRM.MAC, it is used as the default library.
;226	1-Jul-81 /DLM	 RSCAN line handled.
;			 Get why text from new file if possible.
;			 CANCEL not fail if copy of file gone.
;			 Better handling of GTJFN failure on STATUS, etc.
;			 Allow any user if FTANYU.
;			 See if file already in connected directory before
;			COPY'ing with GET.
;			 Handle busy on update of FILUPD.HST.
;			 Replace from connected directory.
;			 No default directory, code cleanup.
;225	8-Jun-81  /DAW	 Never set CM%RAI flag - it doesn't work well in
;			COMND% JSYS unless you do it all the time. Convert
;			the library field by hand to uppercase.
;224	4-JAN-80  /DAW	 Fix running of FILCOM to look nicer when it happens.
;223	3-DEC-79  /DAW	 Make DELETE work under TOPS20 V3A.
;222	30-NOV-79 /DAW	 Put user name in log entry.
;221	21-NOV-79 /DAW	 Fix problem in edit 220, where ALU no longer knew
;			if you were connected to a library. Note: This change
;			makes .MAZ files be incompatible (since the structure
;			name is now included in them).
;220	20-NOV-79 /DLM	 Features for the TOPS20 project:
;			function switches SWRUID and SWBAKF,
;			allow .MAZ files to be in a subdirectory of the library,
;			and fix ALU to be able to work across structures.
;217	30-OCT-79 /DAW	 In log file, say "Replaced LIB:file.ext" instead of
;			just file.ext.
;216	21-OCT-79 /DAW	 ADD and DELETE commands implemented
;215	19-OCT-79 /DAW	 Created ALUPRM.MAC. Got rid of feature-tested code,
;			and made them all run-time switches. Changed name
;			of command "INFORMATION (about) FEATURE-TEST-SWITCHES"
;			to "INFORMATION (about) FUNCTION-CONTROL-SWITCHES"
;214	18-OCT-79 /DAW	 Add option to STATUS command to just get the status
;			of a particular file.
;213	17-OCT-79 /DAW	 Add another set of parsing routines for secondary
;			command parsing. This improves the usefulness of "?"
;			and control-U in certain places.
;212	16-OCT-79 /DAW	 Do RENAMEs instead of COPYs when built with FTFUID=0.
;			Make ALU set date/times of files copied around
;			just like EXEC copy. ALU only changes file date/times
;			now when built with FTFUID=1.
;211	16-OCT-79 /DAW	 Improve error recovery when writing the MAZ file.
;			 Created a subroutine WRTMAZ to modularize the problem.
;
;*** VERSION 7     OCT 16,1979 ***
;
;210	16-OCT-79 /DAW	Make several changes to make ALU incompatible
;			with old versions. Therefore it is now version 7.
;207	15-OCT-79 /DAW	Implement "INFORMATION (ABOUT) EXTENSIONS"
;206	15-OCT-79 /DAW	Implement automatic copying of generated output
;			files to the library along with the reserved
;			file when it is replaced. This feature is controlled
;			by switch "SWCOPO".
;			Make "INFORMATION (ABOUT) FEA" tell about this.
;205	15-OCT-79 /DAW	Implement "INFORMATION" command
;			(about: USERS, LIBRARIES, FEATURE-TEST-SWITCHES)
;204	14-OCT-79 /DAW	Implement feature test FTFUID - if 0, supresses
;			changing the UID line in the updated file
;203	24-AUG-79 /DAW	Fix STATUS command to 1) Print Library name
;			when 1st reserved file on it found, and "no files
;			reserved" otherwise;  2) Print actual file name
;			that's reserved instead of "MAZ" name.
;202	23-AUG-79 /DAW	Get rid of logical names, move EXTS definition
;			up to top of file for easy editing.
;201	23-AUG-79 /DAW	CHECK FOR "No such generation number" when
;			doing a GTJFN for MAZ file.
;
;** VERSION 6 **   JUL 1, 1979
;
;200	1-JUL-79  /DAW	INITIAL VERSION TAKEN FROM KRUPANSKY'S
;


;ABSTRACT:
;	ALU is a program to aid developers of TOPS20 software products.
;It provides the following:
;
;1) An interlock mechanism on library files. Only one
;   person can be editing a particular file at one time.
;
;2) A record of all changes to the library.
;
;  The original version of this program was written in
;SNOBOL in 1978 by Jack Krupansky for the COBOL-79 project.
;  It became version 6 in July, 1979 when David Wright rewrote
;it in MACRO for performance and maintainability.
;  As more in-house developers started using it, feature-test
;switches were added and the formats of things changed, so in
;October, 1979 it became version 7.
;  Dan Murphy (who represented the TOPS-20 monitor group)
;made several enhancements after that, and his source was
;merged in July, 1981 with David Wright's latest source to
;become ALU version 10. ALU was also made to work with REDIT
;in July, 1981 to make its capabilities rival those of STEP.



;AC DEFINITIONS

	STDAC.			;STANDARD DEFINIIONS FROM MACSYM

;FLAGS

F.HUD==1B0			;RESERVED FILE HAS A UID LINE
F.NUD==1B1			;NEW FILE HAS A UID LINE
F.72C==1B2			;NEW FILE'S UID LINE IS 72 CHARS LONG
F.TLN==1B3			;TYPED A LIBRARY NAME IN "STATUS" COMMAND
F.FFL==1B4			;FOUND A FILE IN "STATUS (OF) filespec"
F.QCMD==1B5			;IN Q COMMAND (QGET)
F.EXIT==1B6			;EXIT AFTER CURRENT COMMAND
F.SPCR==1B7			;SPECIAL REPLACE FILESPEC
F.RCPY==1B8			;Did a COPY vs RENAME when source file was
				; REPLACE'd.
F.GCPY==1B9			;/COPY option on "GET" or "QGET".
F.SUSR==1B10			;DOING "STATUS USER" COMMAND


;DEFAULT PARAMETERS

PDLSIZ==100			;SIZE OF PUSHDOWN STACK
TXTLEN==^D100			;SIZE OF TEXT BUFFER
LOGLEN==^D2000			;SIZE OF LOG BUFFER
LINLEN==^D80			;SIZE OF A LINE OF .MAZ FILE
MAXLIN==^D140			;SIZE OF (FIRST) TEXT LINE IN FILE
WHYLEN==^D100			;LENGTH OF "WHY" TEXT
FILWDS==^D72			;Max # words needed to hold a TOPS-20 filespec
CD.LEN==.CDRET+1		;Number of words needed in a directory block

DEFINE AA(NAME,DATA,FLAGS),<	;MACRO FOR COMMAND TABLES
	XWD [IFNB <FLAGS>,<EXP CM%FW!<FLAGS>>
		ASCIZ/NAME/],DATA
>

;DECREMENT BYTE POINTER IN GIVEN LOCATION

DEFINE DBP. (LOC)<
	MOVNI CX,1
	IBP CX,LOC
	MOVEM CX,LOC>

DEFINE TEXT (STRING),<
	ASCIZ @STRING@
   >

DEFINE TYPE (ADDRESS),<
	HRROI T1,ADDRESS
	PSOUT%>

CRLF==[ASCIZ/
/]				;ADDRESS OF A CRLF

TOINDI==[ASCIZ/ => /]		;Like EXEC "COPY"


SUBTTL START-UP

AENTRY:	JRST ST			;FIRST TIME ENTRY
	JRST ST1		;REENTER
ALUVER:	BYTE (3)ALUWHO(9)ALUMJR(6)ALUMNR(18)ALUEDT

BENTRY:	JRST ST1		;NORMAL ENTRY
	JRST ST1		;REENTER
	BYTE (3)ALUWHO(9)ALUMJR(6)ALUMNR(18)ALUEDT

;HERE IS FIRST TIME ENTRY

ST:	RESET%
	TDZ F,F			;CLEAR ALL FLAGS
	MOVEM F,SAVEF		;SAVE THEM
	MOVE P,[IOWD PDLSIZ,PDL]
	CALL SETPMP		;SETUP PAGE MAP
	CALL WDFLIB		;Figure out which library is the
				; default (if any). If none of them
				; is, give error and abort.
	CALL SETAVR		;Get ASCIZ ALU version number string
	MOVEI T1,.FHSLF		;SET ALTERNATE ENTRY VECTOR
	MOVE T2,[3,,BENTRY]	;ENTRY VECTOR WORD
	SEVEC%			;SET IT

;Set up first-time defaults from assembly switches

	MOVEI T1,FTFCOM		;GET FILCOM SWITCH SETTING
	MOVEM T1,SWFCOM		;SET IT
	MOVEI T1,FTCOPO		;GET COPY REL FILES SWITCH SETTING
	MOVEM T1,SWCOPO		;SET IT
	MOVEI T1,FTFUID		;UID IN SOURCE FILE SWITCH SETTING
	MOVEM T1,SWFUID		;SAVE IT
	MOVEI T1,FTRUID		;1= REPLACE UID IN SOURCE ON REPLACE
	MOVEM T1,SWRUID
	MOVEI T1,FTBAKF
	MOVEM T1,SWBAKF
	MOVEI T1,FTANYU
	MOVEM T1,SWANYU
	MOVEI T1,FTGCPY		;1= ASK USER IF HE WANTS A COPY OF FILE
				; IF IT WAS RESERVED AND HE DID A "GET"
	MOVEM T1,SWGCPY
	MOVEI T1,FTREDT		;1= RUN REDIT before REPLACE
	MOVEM T1,SWREDT
	MOVEI T1,FTCGET		;1= /COPY is the default for GET
	MOVEM T1,SWCGET
	TYPE <[ASCIZ/[ALU: First-time Initialization complete]
[Type "EXIT" then save ALU to bypass the initialization from now on]
/]>
	JRST ST2

;SECONDARY ENTRY POINT AND REENTER ADDRESS
;( ASSUME PAGE MAP AND SWITCHES ARE ALL SET UP)

ST1:	MOVE P,[IOWD PDLSIZ,PDL]
	MOVE F,SAVEF		;GET SAVED FLAGS
	MOVEI T1,.RSINI
	RSCAN%			;Get rescan line if any
	 IFJER.
	  SETZ T1,
	 ENDIF.
	MOVEM T1,RSCANF		;Note RESCAN waiting

ST2:	MOVE T1,[ZROST,,ZROST+1]
	SETZM ZROST
	BLT T1,ZROEND		;CLEAR ZEROED AREA

	SETO T1,		;GET MY TERMINAL NUMBER
	MOVE T2,[-1,,T4]
	MOVEI T3,.JITNO		;JUST TERMINAL NUMBER
	GETJI%
	 ERJMP SYSERR		;BAD ERROR
	TRO T4,.TTDES		;MAKE A TTY DESIGNATOR
	MOVEM T4,MYTTY		;SAVE IT

;SEE IF WE HAVE "PRIVS" TO DO ^E COMMANDS

	CALL RGUCHK		;CHECK FOR REGISTERED USER
	 JRST DOSCAN		;NOT, THEN NO PRIVS
	MOVE T2,USRBIT		;Get user flags
	TXNE T2,E.BIT		;Is E.BIT on?
	 SETOM MEPRIV		;YES, HE HAS PRIVS TO DO ^E COMMANDS

	JRST DOSCAN		;OK TO GO


SUBTTL SYSTEM ERRORS

SYSERR:	TMSG <?JSYS ERROR: >
	HRRZI T1,.PRIOU		;PRIMARY OUTPUT
	HRLOI T2,400000
	SETZ T3,
	ERSTR%
	 JRST ERSTRE
	 JRST ERSTRE
	HALTF%
	JRST ST			;RESTART PROGRAM IF HE TYPES CONTINUE

ERSTRE:	TMSG < ?Can't get JSYS error code!!>
	HALTF%
	JRST ST

IMPERR:	TMSG <? "Impossible" JSYS error: >
	CALL LSTFER
	TMSG <
(Address of the ERCAL is in AC1)
>
	POP P,T1
	SUBI T1,1
	HALTF%
	JRST 1(T1)		;RETURN

SUBTTL COMMAND SCANNER

DOSCAN:

;HERE TO READ NEXT COMMAND

NEWCMD:	MOVEI T1,.PRIOU		;Get usual place for command output
	SKIPE RSCANF		;RESCAN waiting?
	 MOVEI T1,.NULIO	;Yes, no output from COMND
	HRRM T1,CMDBLK+.CMIOJ
	MOVEI T1,CMDBLK		;POINT TO COMMAND BLOCK
	MOVEI T2,[FLDDB. (.CMINI)] ;INITIALIZATION FUNCTION
	CALL COMMND		;GO DO IT
	MOVEM P,SAVEP		;SAVE STACK FOR REPARSING

NEWPAR:	MOVE P,SAVEP		;RESTORE THE STACK
	SKIPN T1,PRSJFN		;ANY JFN?
	 JRST NEWPR1		;NO
	RLJFN%			;RELEASE IT
	 JFCL
	SETZM PRSJFN		;CLEAR PARSED JFN

NEWPR1:	TXZ F,F.QCMD!F.EXIT!F.SUSR ;Not a Q cmd.
	MOVEI T1,CMDBLK		;POINT TO THE COMMAND BLOCK
	SKIPN RSCANF		;RESCAN line here?
	 JRST NEWPR3		;No
	SETZM RSCANF		;Yes, once only
	MOVEI T2,[FLDDB. (.CMKEY,,RSCNTB)] ;Yes, special table
	COMND%
	 ERJMP LOSE
	TXNE T1,CM%NOP		;Got our name?
	 JRST NEWCMD		;No, ignore the line quietly
	HRRZ P1,0(T2)		;Save dispatch address
	MOVEI T2,[FLDDB. (.CMCFM)]
	COMND%			;See if line ends here
	 ERJMP LOSE
	TXNN T1,CM%NOP
	 JRST NEWCMD		;It did, nothing to do
	TXO F,F.EXIT		;Remember exit after command
	JRST 0(P1)		;Dispatch to command

NEWPR3:	SKIPE MEPRIV		;AM I PRIVILEDGED TO DO ^E COMMANDS?
	 JRST NEWP1A		;YES
	MOVEI T2,[FLDDB. (.CMKEY,,CMDTAB)] ;POINT TO COMMAND TABLE
	CALL COMMND		;READ THE COMMAND
NEWP1B:	MOVE T2,(T2)		;GET ADDRESS OF ROUTINE
	CALL (T2)		;CALL IT
	TXNE F,F.EXIT		;EXIT after command?
	 HALTF%			;Yes, done
	JRST NEWCMD		;GO GET A NEW COMMAND

NEWP1A:	MOVEI T2,FLPR1		;COMMANDS, AND ^E
	CALL COMMND
	HRRZ T3,T3		;GET PARSE BLOCK USED
	CAIN T3,FLPR1		;NORMAL COMMAND?
	 JRST NEWP1B		;YES

;^E PARSED.. GO GET A ^E COMMAND
	MOVEI T2,[FLDDB. (.CMKEY,,CMETAB)]
	CALL COMMND
	HRRZ T2,(T2)
	CALL (T2)		;CALL A CONTROL-E COMMAND
	JRST NEWCMD		;AND GET A NEW COMMAND


;PARSING TABLES FOR MAJOR COMMANDS

FLPR1:	FLDDB. (.CMKEY,,CMDTAB,,,FLPR2)
FLPR2:	FLDDB. (.CMTOK,,<POINT 7,ASCCTE>)

ASCCTE:	BYTE (7)5,0		;CONTROL-E

;TABLE OF COMMANDS

CMDTAB:	CMDLEN,,CMDLEN		;HEADER
	AA ADD,CMDADD		;ADD A FILE
	AA CANCEL,CMDCAN	;CANCEL A GET
	AA COMMENT,CMDCOM	;PUT COMMENT INTO FILE
	AA DELETE,CMDDEL	;DELETE A FILE FROM A LIBRARY
	AA EXIT,CMDEXT		;EXIT
	AA FREEZE,CMDFRZ	;FREEZE
	AA GET,CMDGET		;GET A FILE
	AA HELP,CMDHLP		;HELP
	AA INFORMATION,CMDINF	;INFORMATION
	AA QGET,CMQGET		;Quick GET (no questions asked)
	AA REPLACE,CMDREP	;REPLACE A FILE
	AA STATUS,CMDSTT	;STATUS
	AA UNFREEZE,CMDUNF	;UNFREEZE
	CMDLEN==.-CMDTAB-1	;NUMBER OF COMMANDS

;CONTROL-E COMMANDS
CMETAB:	CMELEN,,CMELEN		;HEADER
	AA DDT,CMEDDT
	AA SET,CMESET
	CMELEN==.-CMETAB-1	;NUMBER OF ^E COMMANDS

;TABLE OF COMMANDS FOR RESCAN LINE

RSCNTB:	RSTLEN,,RSTLEN
	AA ALU,NEWPR3
	RSTLEN==.-RSCNTB-1

SUBTTL ADD COMMAND

;ADD A NEW SOURCE FILE TO THE LIBRARY

CMDADD:	MOVEI T2,[ASCIZ/file/]
	CALL NOISE
	SETZM JFNBLK		;NO DEFAULTS
	MOVE T2,[JFNBLK,,JFNBLK+1]
	BLT T2,JFNBLK+20
	MOVX T2,GJ%OLD		;GET AN EXISTING FILE
	MOVEM T2,JFNBLK+.GJGEN	;STORE FLAGS
	MOVEI T2,[FLDDB. (.CMFIL,CM%SDH,,<existing file to put on library>)]
	CALL COMMND
	HRRZM T2,PRSJFN		;SAVE PARSED JFN
	MOVEI T2,[ASCIZ/to/]
	CALL NOISE
	MOVE T3,[POINT 7,[ASCIZ/(Library to add file to)
/]]				;Get help text
	CALL PRSLIB		;Parse library name
	CALL BLDINM		;BUILD NAME IN IFINAM
	CALL PRSWHY		;GET "WHY" TEXT
	MOVX T1,GJ%SHT+GJ%OLD	;SEE IF FILE THERE ALREADY
	HRROI T2,IFINAM		;PTR TO NAME
	GTJFN%
	 ERJMP CMDAD1
	RLJFN%			;ALREADY THERE, COMPLAIN
	 JFCL
	TMSG <? File already exists on the library
>
	RET			;DONE, RETURN

CMDAD1:				;ONE MIGHT CHECK TO MAKE SURE WE ARE GETTING ONE OF THE
	;VALID ERROR CODES FROM GTJFN
	MOVX T1,GJ%SHT+GJ%NEW	;WRITE FILE TO LIBRARY NOW
	HRROI T2,IFINAM
	GTJFN%
	 ERJMP ADDER1		;ERROR-CAN'T WRITE
	MOVEM T1,OJFN		;SAVE THIS JFN
	MOVE T1,PRSJFN
	MOVEM T1,IJFN		;SET "IJFN", "OJFN"

	MOVE T1,IJFN		;READ DATE/TIME OF INPUT FILE
	MOVEI T2,RFTAD1
	MOVEI T3,2
	RFTAD%

	CALL OPENO		;GET READY TO WRITE NEW FILE
	 RET			;ERRORS, FORGET IT
	CALL IOPEN		;OPEN FILE FOR READING
	 JRST [CALL RLOJFN	;ERROR, RELEASE OJFN
		RET]		; AND RETURN

	SKIPN SWFUID		;PUT UID IN FILE?
	 JRST ADDCM2		;NO

;DO A "SLOW" COPY
	CALL BLDNUI		;BUILD NEW UID LINE
	 RET			;ERRORS, RETURN

	CALL OUT1ST		;OUTPUT 1ST LINE TO OUTPUT FILE
	CALL BYTWRT		;USE BYTE I/O TO COPY THE FILE NOW

	JRST ADDCM4		; DON'T RESET DATE/TIMES

;DO A "FAST" COPY
ADDCM2:	CALL PRELD0		;GET SOME PAGES IN CORE
	CALL PPCPY		;PAGE/PAGE COPY
	CALL ALUUID		;GET A UID

;MAKE LOG ENTRY
ADDCM4:	CALL ADDLOG		;DO A "ADD" LOG ENTRY

;RELEASE FILES
	HRRZ T1,OJFN
	RLJFN%
	 JFCL
	HRRZ T1,IJFN
	RLJFN%
	 JFCL
	RET			;DONE, RETURN

ADDER1:	TMSG <?GTJFN FAILED: >
	CALL LSTFER
	TYPE CRLF
	HALTF%
	RET

;Routine to parse a library name
; He can either type LIB: on this line or type CRLF here and
;is then prompted for a library name. It is required that he
;actually type the library name, and this routine returns when
;he has typed something.
;Input:
;	T3/ help text
;Output:
;	LIBNUM/ library number

PRSLIB:	MOVEM T3,HPTXTP		;Save help text ptr
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<library:>)]
	CALL COMMND		;PARSE THE TEXT
	LDB T1,[POINT 7,ATMBUF,6] ;ANYTHING TYPED?
	JUMPE T1,GTLNM		;NO, MAKE HIM TYPE SOMETHING

	MOVEI T1,ATMBUF		;Convert ATMBUF to uppercase
	CALL CNVUPP
	MOVE T1,[ATMBUF,,LIBHLD]
	BLT T1,LIBHLD+17	;COPY STRING TO HERE
	MOVEI T1,CMDBLK		;String must be followed by CRLF
	CALL CONFRM
	JRST GOTLNM		;GO CHECK IT

;HERE TO ASK FOR HIM TO TYPE LIBNAM
GTLNM:	MOVE T1,HPTXTP		;Get ptr to help text
	CALL PR2SET
	MOVEI T1,CM2BLK
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<library:>)]
	CALL COMMND
	LDB T2,[POINT 7,ATM2BF,6] ;ANYTHING TYPED?
	JUMPE T2,GTLNM		;NO, TRY AGAIN
	MOVEI T1,ATM2BF		;Convert ATM2BF to uppercase
	CALL CNVUPP
	MOVE T1,[ATM2BF,,LIBHLD] ;COPY IT
	BLT T1,LIBHLD+17
	MOVEI T1,CM2BLK
	CALL CONFRM		;String must end here

;HERE WHEN THERE WAS SOMETHING INPUT FOR LIBRARY NAME. SEE IF OK.

GOTLNM:	CALL FNDLIB		;FIND THE LIBARY HE TYPED
	 JRST GTLNM		;NOT A LIBRARY, GO ASK AGAIN
	RET			;Got it, return ok

;CALL:	LIBNUM/ # of library
;	PRSJFN/ TO GET FILE.EXT
;	CALL BLDINM
;	<RETURN HERE, WHOLE ASCIZ STRING IN IFINAM>

BLDINM:	MOVE T1,[POINT 7,IFINAM] ;OUTPUT TO HERE
	MOVE T2,LIBNUM
	HRRZ T2,LIBLST(T2)
	HRLI T2,(POINT 7,)	;<DIR>
	CALL CPYNUL		;COPY TO NUL
	HRRZ T2,PRSJFN		;GET JFN
	MOVX T3,1B8+1B11+JS%PAF	;FILE.EXT
	JFNS%

	RET			;RETURN, DONE

;ROUTINE TO CHECK INPUT LIBRARY NAME IN LIBHLD
; IF IT IS A LIBARY, RETURNS .+2, library index in LIBNUM
; IF NOT, TYPES ERROR MESSAGE

FNDLIB:	PUSH P,P4		;Save an ac
	MOVSI P4,-NMLIBS	;FIND THE LIBRARY HE TYPED
FNDLB1:	HRRZ T1,LB1LST(P4)	;POINT TO A LIBRARY
	HRLI T1,(POINT 7,)	;STRING
	MOVE T2,[POINT 7,LIBHLD] ;POINT TO INPUT STRING
FNDLB2:	ILDB T3,T1
	ILDB T4,T2
	JUMPE T3,[CALL FNBT4	;GET FIRST NON-BLANK
			JUMPE T4,FNDLB4 ;OK IF BOTH ENDED
			JRST FNDLB3] ;TO AOBJN
	CAIN T3,(T4)		;STILL THE SAME?
	 JRST FNDLB2		;YES, LOOP
FNDLB3:	AOBJN P4,FNDLB1		;LOOP FOR ALL
	TMSG <? >
	TYPE LIBHLD		;TYPE HIS TEXT
	TMSG < is not a library
>
	POP P,P4		;Restore ac
	RET			;ERROR MESSAGE, POPJ

;HERE IF LIBRARY MATCHES
FNDLB4:	HRRZM P4,LIBNUM		;SET INTERNAL LIBRARY NUMBER
	POP P,P4		;Restore ac
	JRST RSKP		;SKIP RETURN

;LITTLE ROUTINE TO IGNORE TRAILING BLANKS
FNBT4:	CAIE T4,.CHTAB
	CAIN T4," "
	 CAIA
	RET			;NON-BLANK, RETURN
	ILDB T4,T2
	JRST FNBT4

SUBTTL CANCEL COMMAND

CMDCAN:	MOVEI T2,[ASCIZ/file/]
	CALL NOISE
	MOVE T2,DFLIBW		;GET DEFAULT LIBRARY (OR 0)
	MOVEM T2,JFNBLK+.GJDEV
	HRRO T2,EXTLST		;DEFAULT EXT - FIRST ONE IN THE LIST.
	MOVEM T2,JFNBLK+.GJEXT
	MOVX T2,GJ%OLD
	MOVEM T2,JFNBLK		;STORE FLAGS
	MOVEI T2,[FLDDB. (.CMFIL,CM%SDH,,<file on library you don't want reserved any more>)]
	CALL COMMND
	HRRZM T2,PRSJFN		;SAVE PARSED JFN
	CALL CONFRM		;CONFIRM THE LINE
	MOVE T1,PRSJFN
	MOVEM T1,GTFJFN		;SAVE "GET" FILE JFN

	CALL RGUSR		;GET USER NUMBER FOR ME
	 RET			;? NOT A REGISTERED USER!

	CALL GTFINL		;GET LIBRARY
	 RET			;? NOT IN A LIBRARY

	CALL FNDEXT		;FIND EXTENSION
	 RET			;CAN'T.. OOPS

;LOOK FOR .MAZ FILE

	CALL GMAZNM		;GET MAZ FILENAME
	 RET			;ERRORS, RETURN

;TRY TO GTJFN IT
	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP CCANE2		;NOT THERE -- GO COMPLAIN
	MOVEM T1,MAZJFN		;YUP--SAVE JFN OF IT

	CALL CHKRME		;MAKE SURE RESERVED BY ME!
	 RET			;NOT.. RETURN AFTER TYPING ERROR MSG
;  FALL...

;DELETE THE RESERVED FILE FROM THE RESERVATION DIRECTORY IF IT IS THERE

	MOVE T2,[POINT 7,RDIR]
	MOVE T1,[POINT 7,RETJNM] ;MAKE JFN STRING FOR FILE IN AREA IT WAS
				;RESERVED IN
	CALL CPYNUL		;COPY TO NUL

;USE JFNS TO GET REST OF NAME

	MOVE T2,GTFJFN
	MOVX T3,1B8+1B11+JS%PAF	;FILENAME.EXT
	JFNS%
	SETZ T2,
	IDPB T2,T1		;;STORE NULL AT END OF STRING

	MOVX T1,GJ%SHT!GJ%OLD
	HRROI T2,RETJNM
	GTJFN%
	 ERJMP CCAN1		;Couldn't find it
	PUSH P,T1
	TMSG <(Delete >
	TYPE RETJNM
	TMSG < ?) >
	CALL YESNO
	 JRST [ POP P,T1	;Recover JFN
		RLJFN%
		  NOP
		JRST CCAN1]
	POP P,T1		;Recover JFN
	MOVEI T2,0		;Keep 0 generations
	DELNF%			;Delete all generations
	 ERJMP CCAN1		;OOPS.. CAN't
	RLJFN%			;Release JFN
	 ERJMP .+1		; Ah, well, tried

;THEN DELETE .MAZ FILE

CCAN1:	HRRZ T1,MAZJFN
	DELF%
	 ERJMP CCANE3		;OOPS.. CAN'T
	RET			;DONE, RETURN

; ERRORS DURING "CANCEL" COMMAND

;GTJFN FAILED FOR MAZ FILE -- PROBABLY NOT RESERVED

CCANE2:	CAIE T1,GJFX19		;NO SUCH FILE TYPE
	CAIN T1,GJFX24		;FILE NOT FOUND
	 JRST NOTRSV		;YEAH.. NOT RESERVED, YOU FOOL
	CAIN T1,GJFX20		;NO SUCH GENERATION NUMBER (TOPS20 FUNNY)
	 JRST NOTRSV
	TMSG <?GTJFN failed for MAZ file: >
	CALLRET LSTFRC		;Type JSYS error, CRLF, then return

NOTRSV:	TMSG <% File >
	MOVEI T1,.PRIOU		;PREPARE TO TYPE FILENAME
	HRRZ T2,GTFJFN
	MOVX T3,1B5+1B8+1B11+JS%PAF
	JFNS%

	TMSG < was not reserved
>
;	JRST RLMAZP		;Release MAZJFN and POPJ

;Routine to release MAZJFN
; It must not be opened.

RLMAZP:	MOVE T1,MAZJFN
	RLJFN%			;RELEASE MAZ FILE
	 ERJMPS .+1		;WHO CARES?
	RET			;RETURN FROM "CANCEL" COMMAND

CCANE3:	TMSG <?DELF failed for MAZ file: >
	CALLRET LSTFRC

SUBTTL COMMENT COMMAND

CMDCOM:	MOVEI T2,[ASCIZ/for library/]
	CALL NOISE
	MOVE T3,[POINT 7,[ASCIZ/(Library to comment about)
/]]				;Get help text
	CALL PRSLIB		;Parse library name and confirm
	CALL RGUSR		;GET USER NUMBER
	  RET			;HE'S NOT A REGISTERED USER
GETCMT:	TMSG <(Type a one-line comment)
>
	SETZ T1,		;NO CONTROL-R BUFFER
	CALL PR2SET		;SETUP FOR 2ND PARSE
	MOVEI T1,CM2BLK		;2ND PARSE BLOCK
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<One-line comment to put in FILUPD.HST>)]
	CALL COMMND		;READ THE COMMENT

	MOVE T3,[POINT 7,ATM2BF]
	ILDB T1,T3
	JUMPE T1,GETCMT		;MAKE HIM TYPE SOMETHING

	CALL ALUUID		;GET A UID

;DO LOG ENTRY
	CALL STLOG		;START THE LOG
	MOVE T2,[POINT 7,[ASCIZ/
[Comment by /]]
	CALL LOGSTR
	MOVE T2,[POINT 7,USRNAM]
	CALL LOGSTR
	MOVEI T2,"]"
	IDPB T2,P1
	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR
	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR

	MOVE T2,[POINT 7,ATM2BF]
	CALL LOGSTR		;OUTPUT COMMENT
	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR		;AND CRLF

	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR		;AND EXTRA CRLF

	MOVEI T1,0
	IDPB T1,P1		;NULL TO END IT
	CALL ALULOG		;OUTPUT TO LOG FILE
	RET			;DONE, RETURN


SUBTTL DELETE COMMAND

CMDDEL:	MOVEI T2,[ASCIZ/file/]
	CALL NOISE
	MOVE T2,DFLIBW		;GET DEFAULT LIBRARY (OR 0)
	MOVEM T2,JFNBLK+.GJDEV
	HRRO T2,EXTLST		;DEFAULT EXT - FIRST ONE IN THE LIST.
	MOVEM T2,JFNBLK+.GJEXT
	MOVX T2,GJ%OLD
	MOVEM T2,JFNBLK+.GJGEN	;STORE FLAGS
	MOVEI T2,[FLDDB. (.CMFIL,CM%SDH,,<existing file in a library>)]
	CALL COMMND
	HRRZM T2,PRSJFN		;SAVE PARSED JFN
	CALL CONFRM		;CONFIRM THE LINE
	MOVE T1,PRSJFN
	MOVEM T1,GTFJFN		;SAVE "GET" FILE JFN

	CALL GTFINL		;GET WHICH LIBRARY IT'S IN
	 RET			;ISN'T IN ANY, RETURN

	CALL RGUSR		;GET MY USER NUMBER
	 RET			;? NOT A REGISTERED USER

	CALL FNDEXT		;FIND EXTENSION
	 RET			;CAN'T.. RETURN

;MAKE SURE FILE ISN'T RESERVED BY SOMEONE

	CALL SKPFRF		;SKIP IF LIBRARY FROZEN
	IFSKP.
	  HRRZ P1,T1		;SAVE JFN
	  TMSG <?Library is frozen.
>
	  JRST CDELE8
	ENDIF.

	CALL GMAZNM		;GET .MAZ FILENAME
	 RET			;ERRORS.. RETURN

	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP CDELE2		;FAILED.. MIGHT BE OK

;FILE WAS THERE.. COMPLAIN TO HIM

CDELE7:	HRRZ P1,T1		;JFN IN P1
CDELE8:	TMSG <?>
	CALL TYPFIL		;TYPE THE .MAZ FILE OUT
	HRRZ T1,P1		;RELEASE .MAZ FILE
	RLJFN%
	 JFCL			;ERRORS ARE BAD.
	RET			;RETURN TO RELEASE PRSJFN (SOURCE FILE)

;GTJFN FAILED FOR .MAZ FILE.. HOPEFULLY FILE-NOT-FOUND

CDELE2:	CAIE T1,GJFX24		;FILE NOT FOUND
	CAIN T1,GJFX19		;NO SUCH FILE TYPE
	 JRST CDELT3		;OK TO DELETE THE FILE
	CAIN T1,GJFX20		;NO SUCH GENERATION NUMBER
	 JRST CDELT3		;IS OK TOO
	JRST EGTMAZ		;GO COMPLAIN THAT GTJFN FAILED

;HERE IF NO .MAZ FILE EXISTS.. OK TO DELETE IT

CDELT3:	CALL PRSWHY		;ASK HIM FOR ONE-LINE COMMENT
	SKIPN SWBAKF		;USING BACKUP FILES?
	JRST CDELT4		;NO

;DELETE BACKUP TOO IF THERE

	HRROI T1,RETJNM
	HRRZ T2,GTFJFN
	MOVX T3,1B2+1B5+1B8+JS%PAF ;<DIRECTORY>FILE
	JFNS%
	HRRZ T2,EXTNUM		;WHICH EXTENSION?
	HRRZ T2,EXBLST(T2)	;GET A BACKUP EXTENSION
	HRLI T2,(POINT 7,)	;POINT TO IT
	MOVEI T3,"."		;APPEND A DOT FIRST
	IDPB T3,T1
	CALL CPYNUL		;COPY STRING

	MOVX T1,GJ%SHT+GJ%OLD	;SEE IF WE CAN FIND BACKUP TOO
	HRROI T2,RETJNM
	GTJFN%
	 ERJMP CDELT4		;NO, FORGET IT

;DELETE FILE, THEN BACKUP

	MOVE P3,T1		;SAVE JFN OF BACKUP TO DELETE
	HRRZ T1,GTFJFN		;DELETE SOURCE
	MOVEI T2,0		;KEEP 0 GENERATIONS
	DELNF%			;Delete it, keep JFN
	 ERJMP CDELE4		;CAN'T

	HRRZ T1,P3		;DELETE BACKUP
	MOVEI T2,0		;KEEP 0 GENERATIONS
	DELNF%
	 ERJMP CDELE5
	RLJFN%			;Release backup JFN
	 ERJMP .+1		; Tried..

	TYPE <[ASCIZ/[Deleted /]>
	TYPE RETJNM
	TYPE <[ASCIZ/ also]
/]>

CDELT5:	CALL ALUUID		;GO ALLOCATE A UID
	CALL LOGDEL		;A DELETE LOG ENTRY
	RET			;RETURN--DONE

;NO BACKUP.. JUST DELETE SOURCE FILE

CDELT4:	HRRZ T1,GTFJFN
	MOVEI T2,0		;KEEP 0 GENERATIONS
	DELNF%			;DELETE ALL GENERATIONS
	 ERJMP CDELE3		;ERROR
	JRST CDELT5		;OK, FINISH


;DELETE ERRORS

CDELE3:	TMSG <?Can't delete file: >
	CALLRET LSTFRC		;Type why, CRLF and return to release PRSJFN

CDELE4:	TMSG <?Can't delete file: >
CDELE6:	CALL LSTFRC		;Type why
	HRRZ T1,P3		;RELEASE BACKUP JFN
	RLJFN%
	 JFCL			;CAN'T
	RET			;RETURN TO RELEASE PRSJFN

CDELE5:	TMSG <?Can't delete >
	TYPE RETJNM		;<DIR>FILE.EXT
	TMSG <: >
	JRST CDELE6		;GO FINISH ERROR RECOVERY

SUBTTL EXIT COMMAND

CMDEXT:	CALL CONFRM

;SEE IF ANY FUNCTION-SWITCHES HAVE BEEN CHANGED.. IF SO, TELL HIM TO
;  SAVE A COPY TO RETAIN THESE CHANGES.

	SKIPN CNFCOM
	SKIPE CNCOPO
	 JRST CMDEX1		;SAY "SAVE"
	SKIPN CNFUID
	SKIPE CNRUID
	 JRST CMDEX1
	SKIPN CNBAKF
	SKIPE CNANYU
	 JRST CMDEX1		;SAY "SAVE"
	SKIPN CNGCPY
	SKIPE CNREDT
	 JRST CMDEX1		;SAY "SAVE"
	SKIPE CNCGET
	 JRST CMDEX1		;SAY "SAVE"

CMDEX2:	HALTF%
	SETZM CNFCOM		;ASSUME HE DID SAVE
	SETZM CNCOPO
	SETZM CNFUID
	SETZM CNRUID
	SETZM CNBAKF
	SETZM CNANYU
	SETZM CNGCPY
	SETZM CNREDT
	SETZM CNCGET
	RET			;CONTINUE

CMDEX1:	TYPE <[ASCIZ/
[Type "SAVE ALU:ALU" to retain the function changes you made]
/]>
	JRST CMDEX2


	SUBTTL FREEZE COMMAND

CMDFRZ:	MOVEI T2,[ASCIZ /library/]
	CALL NOISE
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<library name:>)]
	CALL COMMND
	LDB T1,[POINT 7,ATMBUF,6]
	JUMPE T1,[TMSG <?"library:" expected.
>
		RET]
	MOVEI T1,ATMBUF
	CALL CNVUPP
	MOVE T1,[ATMBUF,,LIBHLD]
	BLT T1,LIBHLD+17
	CALL FNDLIB		;LOOKUP LIBRARY NAME
	 RET
	CALL SKPFRL		;SEE IF ALREADY FROZEN
	IFSKP.
	  HRRZ P1,T1		;SAVE JFN
	  TMSG <?Library is already frozen.
>
	  CALL TYPFIL		;TYPE MESSAGE
	  HRRZ T1,P1
	  RLJFN%
	   ERJMPS .+1
	  RET
	ENDIF.
	MOVX T1,GJ%SHT		;NOT ALREADY FROZEN, CREATE FREEZE FILE
	HRROI T2,MAZNAM
	GTJFN%
	 IFJER.
	  TMSG <?Can't create freeze file because:
>
	  CALL LSTFRC		;TYPE ERR MSG
	  RET
	ENDIF.
	HRRZM T1,MAZJFN
	MOVX T2,7B5+OF%WR
	OPENF%
	 IFJER.
	  TMSG <?Can't open freeze file because:
>
	  CALL LSTFRC
	  HRRZ T1,MAZJFN
	  RLJFN%
	   ERJMPS .+1
	  RET
	ENDIF.
	MOVEI T3,[ASCIZ /! Frozen by /]
	CALL MAZSTR
	 JRST FATAL
	MOVEI T3,USRNAM
	CALL MAZSTR
	 JRST FATAL
	MOVEI T3,[ASCIZ / on /]
	CALL MAZSTR
	 JRST FATAL
	CALL MAZTIM		;WRITE TIME TO FILE
	 JRST FATAL
	MOVEI T3,[ASCIZ /
/]
	CALL MAZSTR
	 JRST FATAL
	HRRZ T1,MAZJFN
	CLOSF%
	 ERJMPS .+1
	RET

SUBTTL GET COMMAND

CMQGET:	TXO F,F.QCMD		;Quick version
CMDGET:	SKIPN SWCGET		;COPY-ON-GET?
	 TXZA F,F.GCPY		;No, default is /NOCOPY
	TXO F,F.GCPY		;Yes, default is /COPY
	MOVEI T2,[ASCIZ/file/]
	CALL NOISE
	MOVE T2,DFLIBW		;GET DEFAULT LIBRARY (OR 0)
	MOVEM T2,JFNBLK+.GJDEV
	HRRO T2,EXTLST		;DEFAULT EXT - FIRST ONE IN THE LIST.
	MOVEM T2,JFNBLK+.GJEXT
	MOVX T2,GJ%OLD
	MOVEM T2,JFNBLK+.GJGEN	;STORE FLAGS
	MOVEI T2,[FLDDB. (.CMFIL,CM%SDH,,<existing file in a library>)]
	CALL COMMND
	HRRZM T2,PRSJFN		;SAVE PARSED JFN
	MOVEI T2,FLCPCF		;Switch or CRLF
	CALL COMMND
	HRRZ T3,T3		;Which parse block?
	CAIN T3,FLGCF		;CRLF?
	 JRST GTDPRS		;yes, done parse
	HRRZ T2,(T2)		;Get address of routine to call
	CALL (T2)		;Call it
	CALL CONFRM		;Confirm the command
	JRST GTDPRS		;OK, done parsing

FLCPCF:
FLGCF:	FLDDB. (.CMCFM,,,,,FLGTSW)
FLGTSW:	FLDDB. (.CMSWI,,GTSWTT)

GTSWTT:	NMGTSW,,NMGTSW		;Header
	AA COPY,GTSWCP
	AA NOCOPY,GTSWNC
NMGTSW==.-GTSWTT-1		;Number of "GET" switches

;/COPY
GTSWCP:	TXOA F,F.GCPY

;/NOCOPY
GTSWNC:	TXZ F,F.GCPY
	RET


;Here when done parse of "GET" command

GTDPRS:	MOVE T1,PRSJFN
	MOVEM T1,GTFJFN		;SAVE "GET" FILE JFN

	CALL GTFINL		;GET WHICH LIBRARY THE FILE IS IN
	 RET			;ISN'T IN ANY, RETURN

	CALL RGUSR		;GET MY USER NUMBER
	 RET			;? NOT A REGISTERED USER, RETURN

	CALL FNDEXT		;FIND EXTENSION
	 RET			;CAN'T.. RETURN

	CALL GETCD		;GET MY CONNECTED DIRECTORY
				;AND MAKE SURE IT'S NOT A LIBRARY
;SEE IF FILE IS RESERVABLE
; (LOOKUP ".MAZ" FILE.. IF IT'S THERE, WE CAN'T DO IT)

	CALL SKPFRF		;SEE IF LIBRARY FROZEN
	IFSKP.
	  HRRZM T1,P1		;SAVE JFN
	  TMSG <
%Library is frozen.
>
	  CALL TYPFIL		;TYPE OUT INFO
	  MOVE T1,P1
	  RLJFN%
	   ERJMPS .+1
	ENDIF.

	CALL GMAZNM		;GET .MAZ FILENAME
	 RET			;ERRORS.. RETURN

;NOW LOOK IT UP
	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP CMGET8		;ASSUME MERELY NOT THERE
				;ERJMP CGETE2		;FAILED.. MIGHT BE OK

;FILE WAS THERE.. COMPLAIN TO HIM
;OPEN IT

	HRRZM T1,MAZJFN
	MOVX T2,7B5+OF%RD
	OPENF%
	 ERJMP CGETE6		;CAN'T OPEN IT
	HRRZ T1,MAZJFN
	BIN%
	 ERJMP CMGT7B
	CAIN T2,"!"		;CHANGE FIRST BYTE
	MOVEI T2,"?"
	HRRZ T1,T2
	PBOUT%

;TYPE IT OUT
CMGT7A:	HRRZ T1,MAZJFN
	BIN%
	 ERJMP CMGT7B
	HRRZ T1,T2
	PBOUT%
	JRST CMGT7A


;HERE WHEN WE GOT TO EOF AFTER TYPING OUT THE .MAZ FILE FOR HIM
; CLOSE IT, AND GIVE HIM THE OPTION OF COPYING IT ANYWAY.

CMGT7B:	HRRZ T1,MAZJFN
	CLOSF%
	 ERJMP .+1		;IGNORE ERRORS CLOSING FILE
	SKIPN SWGCPY		;Skip if giving user the option
	 RET			;Assume no copy wanted

	TMSG < Do you want a copy anyway? (Answer YES or NO): >
	CALL YESNO
	 RET			;"NO"
	JRST GTCOPY		;GO GET A COPY

;HERE IF OK TO GET THE FILE - GET "TILL" TEXT

CMGET8:	TXNE F,F.QCMD		;QGET?
	 JRST [  MOVE T1,[POINT 7,TILTXT] ;Yes, default TILTXT
		   MOVE T2,[POINT 7,[ASCIZ/One hour/]]
		   CALL CPYNUL
		   MOVE T2,T1	;Dest byte ptr
		   JRST DONTT1]
	MOVE T1,[POINT 7,[ASCIZ/(Till when?) /]]
	CALL PR2SET		;SET UP FOR 2ND PARSE
	MOVEI T1,CM2BLK		;USE 2ND COMND BLOCK
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<One-line comment for STATUS information>)]
	CALL COMMND

; COPY ANSWER TO TILTXT - MAKE SURE THERE IS SOMETHING THERE, AND APPEND ".."

	MOVE T3,[POINT 7,ATM2BF] ;FROM HERE
	MOVE T2,[POINT 7,TILTXT] ;TO HERE
      DO.
	ILDB T1,T3		;GET A CHAR
	CAIE T1,.CHTAB
	CAIN T1," "
	LOOP.			;IGNORE LEADING SPACES AND TABS
      ENDDO.

;GOT FIRST NON-BLANK

	JUMPE T1,DEFTIL		;IF NOTHING THERE, GIVE DEFAULT ANSWER

;STORE CHARS UNTIL NULL

NXTIL:	IDPB T1,T2
	ILDB T1,T3
	JUMPN T1,NXTIL

	MOVEI T1,"."
	IDPB T1,T2
	IDPB T1,T2		;".."
	JRST DONTT1		;DONE TILL

;IF NULL ANSWER TO "TILL WHEN", STORE DEFAULT ANSWER

DEFTIL:	MOVEI T3,"?"
	IDPB T3,T2

DONTT1:	MOVEI T1,.CHCRT
	IDPB T1,T2
	MOVEI T1,.CHLFD
	IDPB T1,T2
	SETZ T1,		;NULL TO END IT
	IDPB T1,T2
;	JRST DONTTX

;WRITE RESERVED MARKER
DONTTX:	CALL WRTMAZ		;WRITE THE MAZ FILE
	 RET			;ERRORS, RETURN

; ** READY TO COPY FILE **
;NOW ACTUALLY COPY THE FILE TO MY AREA

GTCOPY:	TXNN F,F.GCPY		;Get a copy?
	 RET			;No, all done
	MOVE T1,GTFJFN
	MOVEM T1,IJFN		;FROM HERE
	MOVE T2,[POINT 7,CD]	;TO CONNECTED DIRECTORY
	MOVE T1,[POINT 7,RETJNM] ;STORE FILENAME TO ENTER HERE
	CALL CPYNUL		;COPY STRING
	HRRZ T2,GTFJFN
	MOVX T3,1B8+1B11+JS%PAF	;NAME.EXT
	JFNS%
	SETZ T2,
	IDPB T2,T1		;STORE NULL AT END

;SEE IF FILE ALREADY THERE

	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,RETJNM
	GTJFN%
	 ERJMP GTCPY2		;Isn't, good
	RLJFN%			;Didn't really want this JFN
	 NOP
	TMSG <% File >
	TYPE RETJNM		;Advise user
	TMSG < already exists.
(Supersede?) >
	CALL YESNO
	 RET			;"NO" -- quit.
GTCPY2:

;GET A JFN FOR THIS FILE

	MOVX T1,GJ%SHT+GJ%FOU
	MOVE T2,[POINT 7,RETJNM]
	GTJFN%
	 ERJMP CGETE8		;?CAN'T GET A JFN FOR IT
	MOVEM T1,OJFN		;OUTPUT FILE JFN
	MOVE T1,IJFN		;GET DATE/TIME STUFF FROM FILE NOW
	MOVEI T2,RFTAD1
	MOVEI T3,2
	RFTAD%
	CALL PRELOD		;PRELOAD PAGES TO START (OPENS FILE)
	CALL OPENO		;OPEN OUTPUT FILE
	 RET			;ERRORS, GIVE UP
	CALL PPCPY		;PAGE/PAGE COPY

	MOVE T1,IJFN
	RLJFN%
	 IFJER.
	  TMSG <% Couldn't release JFN for IFILE
>
	 ENDIF.
	MOVE T1,OJFN
	RLJFN%
	 IFJER.
	  TMSG <% Couldn't release JFN for OFILE
>
	 ENDIF.
	RET			;RETURN

;ROUTINE TO WRITE THE MAZ FILE
;ASCIZ NAME IS IN "MAZNAM"
;RETURNS .+1 IF ERRORS, .+2 IF OK

WRTMAZ:	MOVX T1,GJ%SHT
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP WRTME1

;OPEN FOR OUTPUT, AND WRITE THE MESSAGE INTO IT

	HRRZM T1,MAZJFN
	MOVX T2,7B5+OF%WR
	OPENF%
	 ERJMP WRTME2		;OPENF FAILED

	MOVEI T3,[ASCIZ/! Reserved by /]
	CALL MAZSTR		;WRITE STRING TO .MAZ FILE
	 JRST WRTMZA		;QUOTA EXCEEDED, GO TRY AGAIN
	MOVEI T3,USRNAM		;Get user name
	CALL MAZSTR		;WRITE IT
	 JRST WRTMZA		;GOT QUOTA EXCEEDED
	MOVEI T3,[ASCIZ/ at /]
	CALL MAZSTR
	 JRST WRTMZA		;QUOTA EXCEEDED
	MOVEI T3,CD		;PRINT THIS
	CALL MAZSTR
	 JRST WRTMZA		;QUOTA EXCEEDED
	MOVEI T3,[ASCIZ/ on /]
	CALL MAZSTR
	 JRST WRTMZA
	CALL MAZTIM		;WRITE TIME TO .MAZ FILE
	 JRST WRTMZA
	MOVEI T3,[ASCIZ/
!  till /]
	CALL MAZSTR
	 JRST WRTMZA
	MOVEI T3,TILTXT		;INPUT LINE
	CALL MAZSTR		;APPEND THAT TOO
	 JRST WRTMZA		;QUOTA EXCEEDED

;CLOSE AND RELEASE IT
	HRRZ T1,MAZJFN
	CLOSF%
	 ERJMP WRTMZC		;CAN'T CLOSE AND RELEASE FILE
	AOS (P)			;RETURN OK
	RET

;HERE TO TRY AGAIN IF QUOTA EXCEEDED HAS BEEN FIXED
WRTMZA:	HRRZ T1,MAZJFN		;RELEASE JFN AND TRY AGAIN
	CLOSF%
	 ERJMP WRTMZC		;GEEZ, WHAT'S THIS THEN?
	JRST WRTMAZ		;GO TRY AGAIN

WRTMZC:	CALL CHKQTE		;MAYBE QUOTA EXCEEDED AGAIN?
	 JRST WRTMZA		;YES
	TMSG <?Can't close MAZ file: >
	CALL LSTFER
	HALTF%			;SOMETHING BAD
	JRST .-1		;DON'T RECOVER

;HERE IF OUTPUT GTJFN FAILED
WRTME1:	TMSG <? GTJFN failed for >
	TYPE MAZNAM
	TMSG <: >
	CALL LSTFER		;SAY WHY
	HALTF%			;LET HIM DO STUFF
	JRST WRTMAZ		;TRY AGAIN IF "CONTINUE"

;HERE IF OPENF FAILED FOR WRITING MAZ FILE
WRTME2:	TMSG <?OPENF failed for >
	TYPE MAZNAM
	TMSG <: >
	CALL LSTFER		;SAY WHY
	HALTF%

	HRRZ T1,MAZJFN		;HE TYPED "CONTINUE", RELEASE IT'S JFN
	RLJFN%
	 JFCL			;ALL ERRORS ARE VERY BAD!
	JRST WRTMAZ		;AND GO TRY AGAIN


;ERRORS IN "GET" CODE

CGETE2:	CAIE T1,GJFX24		;FILE NOT FOUND
	CAIN T1,GJFX19		;NO SUCH FILE TYPE
	 JRST CMGET8		;OK TO GET THE FILE
;23-AUG-79 /DAW  EVEN THOUGH WE DIDN'T SUPPLY A GENERATION NUMBER,
; GTJFN RETURNS "NO SUCH GENERATION NUMBER" IF AN OLD COPY WAS
; DELETED ON THE LIBARY.
	CAIN T1,GJFX20		;NO SUCH GENERATION NUMBER
	 JRST CMGET8		; (MEANS OLD .MAZ IS DELETED)
EGTMAZ:	TMSG <? GTJFN failed for >
	TYPE MAZNAM
	TMSG <: >
	CALL LSTFER		;SAY WHY
	HALTF%
	RET

CGETE6:	TMSG <?OPENF failed for MAZ file: >
	CALL LSTFER
	HALTF%
	RET

CGETE8:	TMSG <?GTJFN failed for output file: >
	CALLRET LSTFRC		;Type why, CRLF and return

SUBTTL REPLACE COMMAND

CMDREP:	MOVEI T2,[ASCIZ/file/]
	CALL NOISE
	MOVE T2,DFLIBW		;GET DEFAULT LIBRARY (OR 0)
	MOVEM T2,JFNBLK+.GJDEV
	HRRO T2,EXTLST		;DEFAULT EXT (THE FIRST ONE)
	MOVEM T2,JFNBLK+.GJEXT
	MOVX T2,GJ%OLD
	MOVEM T2,JFNBLK+.GJGEN	;STORE FLAGS
	MOVEI T2,[FLDDB. (.CMFIL,CM%SDH,,<existing file in a library>)]
	CALL COMMND
	HRRZM T2,PRSJFN
	CALL CONFRM
	TXZ F,F.SPCR		;No special filespec
	TXZ F,F.RCPY		;Clear "DID A COPY" flag
	MOVE T1,PRSJFN
	MOVEM T1,GTFJFN		;SAVE JFN OF THE FILE WE "GOT"

	CALL GTFINL		;GET LIBRARY NUMBER WHERE FILE IS
	 RET			;?NOT IN A LIBRARY

	CALL RGUSR		;Check user access
	  RET			; ?Not allowed to use ALU replace.

	CALL FNDEXT		;FIND EXTENSION
	 RET			;CAN'T.. RETURN

	CALL GETCD		;GET CONNECTED DIRECTORY
				; DON'T LET IT BE A LIBRARY
;MAKE SURE FILE IS RESERVED.. LOOKUP ".MAZ" FILE

	CALL SKPFRF		;SKIP IF FREEZE IN EFFECT
	IFSKP.
	  HRRZM T1,MAZJFN	;SAVE JFN
	  CALL CHKFME		;YES, SEE IF BY ME
	   RET			;NO, LOSE
	  TMSG <%You have this library frozen.
>
	ENDIF.

	CALL GMAZNM		;BUILD .MAZ FILE NAME
	 RET			;ERROR

;LOOK IT UP

	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP REPLE1		;FAILED.. COMPLAIN
	HRRZM T1,MAZJFN		;SAVE JFN OF IT

	CALL CHKRME		;CHECK TO SEE IF FILE IS RESERVED BY ME..
	 RET			;NO, RETURN

;CHECK TO SEE IF HE IS CONNECTED TO
;THE SAME AREA WHERE THE RESERVED FILE WAS PUT WITH "GET"
;If not, give warning and find out what he wants to do.

	CALL CHKCNN		;This may set F.SPCR
	SKIPE SWRUID		;Replacing UID?
	SKIPN SWFUID		; and putting UID in file?
	 JRST CMDRE5		; NO, DON'T OPEN AND READ RESERVED FILE

;LOOKUP RESERVED FILE AND SEE IF IT WAS MODIFIED
;THE FOLLOWING CODE IS EXECUTED IN VERSIONS OF ALU THAT WANT
; TO MODIFY THE FIRST LINE OF THE FILE TO PUT IN INFORMATION
; ABOUT THE LAST MODIFICATION OF THE FILE.  IT MAKES A CHECK
; TO SEE IF THE RESERVED FILE HAS BEEN MODIFIED ON THE LIBRARY.

CMDRE2:	TXZ F,F.HUD!F.NUD!F.72C	;CLEAR "OLD FILE HAS A UID"
	SETZM UID1		;DON'T KNOW UID OF FILE ON MY AREA YET
	MOVE T1,GTFJFN
	MOVX T2,OF%RD+7B5	;READ OLD FILE
	OPENF%			;OPEN IT
	 ERJMP REPLE2		;?CAN'T

;READ 1ST LINE

CMDRE3:	SETZM RFBUF		;CLEAR BUFFER
	MOVE T1,[RFBUF,,RFBUF+1]
	BLT T1,RFBUF+.RFLN-1

	HRRZ T1,GTFJFN		;FROM HERE
	MOVE T2,[POINT 7,RFBUF]	;TO HERE
	MOVEI T3,LINLEN		;80 CHARS MAX
	MOVEI T4,.CHLFD		;TERMINATE WITH A LINE FEED
	SIN%
	 IFJE. (R)
	  CAIE T1,IOX4		 ;END OF FILE REACHED?
	  JRST REPLE3		;NO, UNEXPECTED ERROR
	 ENDIF.

;CLOSE BUT DON'T RELEASE JFN

CMDRE4:	HRRZ T1,GTFJFN
	TXO T1,CO%NRJ		;DON'T RELEASE JFN
	CLOSF%
	 ERJMP REPLE4		;OOPS.. CAN'T


;Here for all flavours of REPLACE.
; We have GTFJFN/ file on library to replace.
;We have confirmed that the user is not connected to a library,
; and the file was indeed reserved by him.
; Now we must get IJFN/ file to replace it with.
;See if file is on the connected directory.

CMDRE5:	MOVE T1,[POINT 7,RETJNM]
	MOVE T2,[POINT 7,CD]	;Start with connected directory
	CALL CPYNUL
	HRRZ T2,GTFJFN		;NOW APPEND FILENAME
	MOVX T3,1B8+1B11+JS%PAF	;JUST NAME.EXT
	JFNS%
	JXN F,F.SPCR,REPL81	;Jump if special filename
	MOVX T1,GJ%SHT+GJ%OLD
	MOVE T2,[POINT 7,RETJNM]
	GTJFN%
	 ERJMP REPLE6		;Can't find new source file!
	JRST REPL82

REPLE6:	TMSG <% File >
	TYPE RETJNM
	TMSG < not found
>
REPL81:	MOVE T1,[POINT 7,[ASCIZ/(Type alternate filespec) /]]
	CALL PR2SET		;SETUP 2ND PARSE
	SETZM JFNBLK		;NO DEFAULTS
	MOVE T2,[JFNBLK,,JFNBLK+1]
	BLT T2,JFNBLK+20
	MOVX T2,GJ%OLD		;GET AN EXISTING FILE
	MOVEM T2,JFNBLK+.GJGEN	;STORE FLAGS
	MOVEI T1,CM2BLK		;USING THIS PARSE BLOCK NOW
	MOVEI T2,FLCRFS		;CR to forget it, or filespec.
	CALL COMMND		;PARSE IT
	HRRZ T3,T3		;Which parse block used?
	CAIN T3,FLCFM		;CRLF = "forget this REPLACE"?
	 CALLRET RLMAZP		;Release MAZJFN, return from REPLACE command.
	MOVE T1,T2		;Good filespec, Get JFN
	JRST REPL82

;Parse blocks
FLCRFS:
FLCFM:	FLDDB. (.CMCFM,CM%SDH,,<CRLF to quit the UPDATE>,,FLFS1)
FLFS1:	FLDDB. (.CMFIL,CM%SDH,,<New source file>)



;Here when we got T1/ JFN of new source file

REPL82:	MOVEM T1,IJFN		;SAVE AS INPUT JFN

;Get date/time info for IJFN and store in RFTAD1

	MOVE T1,IJFN		;READ DATE/TIME OF INPUT FILE
	MOVEI T2,RFTAD1
	MOVEI T3,2
	RFTAD%

;GET NAME IN "IFINAM"

	MOVE T1,[POINT 7,IFINAM]
	HRRZ T2,IJFN
	MOVX T3,1B2+1B5+1B8+1B11+JS%PAF ;DEVICE:<DIRECTORY>FILENAME.EXT
	JFNS%

;GET COMPLETE NAME IN "FROMFL"

	MOVE T1,[POINT 7,FROMFL]
	MOVE T2,IJFN		; "FROM" THIS FILE
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%

	CALL SETMAB		;GET MABJFN, OJFN
	 RET			;ERRORS

	SKIPN SWFUID		;Using UID in file?
	 JRST NOUSUD		;No

; ** Here when ALU wants to put a new UID in the file **

	TXO F,F.RCPY		;Set "Did a COPY" (vs. RENAME) flag.
	CALL OPENO		;GET READY TO WRITE NEW FILE
	 RET			;ERRORS, FORGET IT
	CALL IOPEN		;OPEN FILE FOR READING
	 JRST [CALL RLOJFN	;ERRORS, RELEASE OJFN
		RET]		; AND RETURN
	SKIPE SWRUID		;REPLACING UID?
	 JRST ASKWHY		;Yes, don't read new file yet

;See if file has comment as first line which can be used as
;WHY text. It must not look like a UID line or an edit line.
;REDIT has not yet been called.

	CALL RDLIN1		;Read first line of new file
	MOVE P1,[POINT 7,RFBUF]	;PTR to first line
	ILDB T1,P1		;LOOK AT FIRST CHAR
	CAIE T1,";"		;A COMMENT CHAR?
	CAIN T1,"!"
	 SKIPA			;YES
	JRST ASKWHY		;NO, MUST ASK
	ILDB T1,P1		;CHECK NEXT CHAR
	CAIN T1,"<"		;PROBABLY EDIT LINE?
	 JRST ASKWHY		;YES, LOSE
	CAIE T1," "		;POSSIBLE START OF UID LINE?
	 JRST NASKW		;NO, OK
	MOVE T2,[POINT 7,[ASCIZ/UPD ID= /]]
	CALL CMPSTR		;PROBABLY UID LINE?
	 SKIPA			;NO
	JRST ASKWHY		;YES, LOSE
NASKW:	MOVE T1,[POINT 7,WHYTXT]
	MOVE T2,[POINT 7,RFBUF]
	IBP T2			;SKIP COMMENT CHAR
	CALL CPYNUL		;COPY LINE TO WHY TEXT
	JRST NORUI0		;GO COPY FILE

;GET "WHY" TEXT
;REDIT HAS NOT YET BEEN CALLED.

ASKWHY:	CALL PRSWHY		;PARSE WHY TEXT
	SKIPN SWRUID		;REPLACING UID?
	 JRST NORUI0		;NO

;SEE IF RESERVED FILE HAS A UID LINE

	MOVE P1,[POINT 7,RFBUF]	;LOOK FOR ; OR !
	ILDB T1,P1
	CAIE T1,";"
	CAIN T1,"!"		;EITHER IS OK
	 CAIA
	JRST NORUID		;NOPE, NO UID LINE THEN
	MOVE T2,[POINT 7,[ASCIZ/ UPD ID= /]] ;THIS MUST BE NEXT
	CALL CMPSTR		;COMPARE STRINGS
	 JRST NORUID		;NO UID LINE
	TXO F,F.HUD		; ELSE WE DID FIND ONE
	CALL PRELD0		;READ SOME PAGES IN
	HRRZ T1,STIPG2		;WHERE DOES IT START IN CORE?
	MOVE T1,(T1)		; SEE IF FIRST PAGE EXISTS
	 ERJMP NOPG0		;? NO, DON'T ALLOW COPY

	CALL CHKNUD		;CHECK FOR NEW FILE'S UID
				; (SETS OR CLEARS FLAGS; ONLY 1 RETURN)

;COMPARE UID STRING TO SEE IF RESERVED FILE WAS MODIFIED

	HRRZ P1,STIPG2
	HRLI P1,(POINT 7,)	;POINTER TO "FILE" STRING
	MOVE T2,[POINT 7,RFBUF]	;POINTER TO OLD UID STRING
	CALL CMPSTR		;SKIP IF EQUAL
	 JRST RSVFMD		; ? RESERVED FILE WAS MODIFIED
				;If he wants to replace it anyway,
				; RSVFMD returns to either GOUPDC or GOCOP

;** Come here to copy the file with UID replacement **
;COPY THE FILE. FLAGS F.HUD, F.NUD, AND F.72C ARE CORRECT
;REDIT HAS NOT YET BEEN CALLED

GOUPDC:	TXNN F,F.72C		;IF UID LINE NOT 72 CHARS,
	 JRST GOSLOW		;GO DO SLOW COPY


;EXACTLY 72 CHARS IN THIS UID LINE.. JUST REPLACE IT AND CALL
; FAST COPY ROUTINE

	CALL BLDNUI		;BUILD NEW UID
	 RET			;ERRORS.. RETURN

;REPLACE 72 CHARS IN FILE WITH 72 CHARS IN UIDTXT..

	MOVEI T1,UIDTXT		;POINTER TO UID TEXT
	MOVEM T1,FSTLIN		;TELL PPCPY WHERE IT IS

;Here when ready to copy, NEWUID set up.

GOCOP:	SKIPE SWREDT		;Call REDIT before replace?
	 CALL CALRDT		;Yes, do it
	CALL DORNAM		;RENAME OLD MAC TO MAB
	 RET			;?CAN'T

;Here when we are ready to copy new source file to place where
; the old source file was.
;REDIT has been called if necessary.
; Both new source (OJFN) and old source (IJFN) are OPEN.

GOCUID:	CALL PPCPY		;DO PAGE COPY
SCPPDN:	HRRZ T1,IJFN		;NOW DELETE FILE ON MY AREA
	MOVEI T2,0		;KEEP 0 GENERATIONS
	DELNF%			;Delete file(s)
	 IFJER.
	  TMSG <%Can't delete >
	  TYPE IFINAM		;TYPE THE NAME
	  TMSG <: >
	  CALL LSTFER		;TYPE WHY
	  TMSG <, continuing...
>
	 ENDIF.
	MOVE T1,IJFN		;Throw away new source's JFN
	RLJFN%
	 ERJMP .+1		;Can't, no big deal.
	JRST DONRPL		;Go finish up "REPLACE" actions

;RESERVED FILE WAS MODIFIED

RSVFMD:	TMSG <% Reserved file was modified
Do you want to replace it anyway? (Y,N): >
	CALL YESNO
	 RET			;NO
	SKIPE SWFUID		;YES, SKIP IF WE SHOULDN'T PUT UID IN FILE
	JRST GOUPDC		; GO DO COPY WITH UID REPLACEMENT
	JRST GOCOP		; GO DO COPY WITHOUT UID REPLACEMENT

;FILE TO REPLACE WITH HAS NO PAGE 0

NOPG0:	TMSG <? File to copy has no page 0
>
	TMSG <[REPLACE aborted]
>
	CALL RLMAB		;RELEASE MAB JFN
	CALL RLIJFN		;RELEASE IJFN
	CALL RLOJFN		;RELEASE OJFN
	RET			;RETURN FROM REPLACE

;HERE IF THE OLD UID LINE IN THE FILE IS NOT EXACTLY 72 CHARACTERS
; WE HAVE TO COPY WITHOUT USING PMAP'S.  SIGH.
;REDIT HAS NOT YET BEEN CALLED.

GOSLOW:	MOVE T3,NPAGES		;GET SIZE OF BUFFER
	IORX T3,PM%CNT		;REPEAT COUNT
	HRROI T1,-1		;SAY REMOVING PAGES
	HRLI T2,.FHSLF
	HRR T2,STIPGS
	PMAP%			;UNMAP PAGES

	MOVE T1,IJFN
	TXO T1,CO%NRJ		;DON'T RELEASE JFN
	CLOSF%
	 ERJMP .+1
	CALL IOPEN		;NOW OPEN FILE FOR READING AGAIN
	 RET			;?CAN'T


;HERE IF NO UID LINE FOUND IN RESERVED FILE.
; WE WILL HAVE TO DO THE SLOW COPY
;REDIT HAS NOT YET BEEN CALLED.

NORUID:	CALL RDLIN1		;Read first line of new file
NORUI0:	CALL BLDNUI		;BUILD NEW UID LINE
	 RET			;ERRORS.. RETURN
	SKIPE SWREDT		;Call REDIT before replace?
	 CALL CALRDT		;Yes, do it
	CALL DORNAM		;RENAME OLD MAC TO MAB
	 RET			;?CAN'T
	CALL OUT1ST		;WRITE 1ST LINE TO OUTPUT FILE
	MOVE P1,[POINT 7,RFBUF]
	ILDB T1,P1		;GET 1ST CHAR
	CAIE T1,";"
	CAIN T1,"!"		;UID LINE?
	SKIPN SWRUID		;AND REPLACING UID LINES?
	JRST OUT1L		;NOPE, OUTPUT STARTING HERE
	MOVE T2,[POINT 7,[ASCIZ/ UPD ID= /]]
	CALL CMPSTR		;COMPARE
	 JRST OUT1L		;NO MATCH, OUTPUT STARTING HERE
	MOVEI T3,^D10		;READ UID
	MOVE T1,P1
	NIN%
	 IFJER.
	  SETZ T2,		;ERROR, CLEAR UID
	 ENDIF.
	MOVEM T2,UID1

;HAVE A UID LINE, SKIP IT
;NOW JUST USE BYTE I/O TO COPY THE FILE

LNDONE:	CALL BYTWRT		;COPY BYTES
	JRST SCPPDN		;DONE SLOW COPY


;READ FIRST LINE OF NEW FILE TO CHECK FOR UID LINE, ETC.

RDLIN1:	HRRZ T1,IJFN
	MOVE T2,[POINT 7,RFBUF]
	MOVEI T3,MAXLIN-1	;MAX UID LINE LENGTH
	MOVEI T4,.CHLFD		;TERMINATE WITH LF
	SIN%
	 ERJMP FSTLER
	SETZ T4,		;TIE OFF WITH NUL
	IDPB T4,T2
	RET

;HERE IF ERROR READING TO END OF FIRST LINE IN NEW FILE

FSTLER:	TMSG <? Couldn't read 1st line in new file: >
	CALL LSTFER
	HALTF%
	JRST RDLIN1		;TRY AGAIN


;HERE IF FIRST LINE WAS NOT UID LINE, OUTPUT IT ALL

OUT1L:	MOVE T1,OJFN
	MOVE T2,[POINT 7,RFBUF]
	SETZ T3,
	SOUT%
	 ERJMP LNDON4		;ERROR
	JRST LNDONE		;DONE FIRST LINE, JUST USE SIN/SOUT LOOP NOW

LNDON4:	CALL CHKQTE		;CHECK FOR QUOTA EXCEEDED
	 JRST OUT1L		;IT WAS, TRY AGAIN
	TMSG <? Output error: >
	CALL LSTFER
	HALTF%
	JRST OUT1L		;TRY AGAIN IF CONT

; ** Here if UID lines are not to be put in the file **
; Files are not OPEN.

NOUSUD:	CALL PRSWHY		;Find out why replace.
	CALL ALUUID		;Get a UID
	SKIPE SWREDT		;Call REDIT before REPLACE?
	 CALL CALRDT		;Yes, do it
	CALL DORNAM		;Rename old MAC to MAB
	 RET			;?Can't

;Try to do a "RENAME"

GORNM:	MOVE T1,OJFN		;Get JFN of output file
	CALL SETGRC		;Set generation-retention-count from directory
	 JRST GORNM2		;?Failed, pretend RENAME failed because
				; files were not on same device, and do copy.
	MOVE T1,IJFN
	MOVE T2,OJFN
	RNAMF%			;TRY TO DO THE RENAME
	 ERJMPR GORNME
	JRST RNAMDN		;DONE

;RENAME FAILED.

GORNME:	CAIN T1,RNAMX4
	 JRST GORNM1		;?QUOTA EXCEEDED IN DEST OF RENAME
	CAIN T1,RNAMX1
	 JRST GORNM2		;?Files are not on same device
	TMSG <? Can't rename >
	TYPE IFINAM
	TMSG <: >
	CALL LSTFER		;TYPE THE ERROR
	HALTF%
	JRST GORNM		;TRY AGAIN IF HE TYPES "CONTINUE"

GORNM1:	TYPE <[ASCIZ/?Quota exceeded on library
[Please fix the problem and type "CONTINUE"]/]>
	HALTF%
	JRST GORNM		;GO TRY AGAIN

;Here if RENAME failed because files are not on same device.
; Try to copy instead.

GORNM2:	CALL OPENO		;Open output file
	 RET			;?Errors, forget it
	CALL IOPEN		;Open new source file for reading
	 JRST [CALL RLOJFN	;Errors, release OJFN
		RET]		;And return
	CALL PRELD0		;Read some pages in
	TXO F,F.RCPY		;Set "Did a COPY" (vs. RENAME) flag
	JRST GOCUID		;Go do fast copy.

;RENAME WAS SUCCESSFUL
; ** here, should delete all other generations of the source file
;  from my area before going to DONRPL **

RNAMDN:	JRST DONRPL		;Go finish REPLACE actions


;*** FILE HAS BEEN COPIED/RENAMED TO LIBRARY ***
;  The new source file has been deleted from my area.
;IJFN has been released.

DONRPL:	SKIPE SWFCOM		;DOING A FILCOM?
	 CALL FCSTR		;YES, GET STRING FOR FILCOM
	CALL DOLOG		;;OUTPUT TO "LOG" (FILUPD.HST)
	SKIPN SWBAKF		;MAKING BACKUP FILES?
	JRST REPDON		;NO
	MOVE T1,MABJFN		;RELEASE BACKUP
	RLJFN%
	 IFJER.
	  TMSG <% Couldn't Release MABJFN
>
	 ENDIF.

;HERE WHEN DONE REPLACE TO RELEASE JFNS AND DELETE MAZ FILE

REPDON:
DELOF:	MOVE T1,OJFN		;RELEASE NEW FILE
	RLJFN%
	 ERJMP [TMSG <? Couldn't release OJFN: >
		CALL LSTFER
		HALTF%		;DIE
		JRST DELOF]	;TRY AGAIN IF "CONTINUE"

;DELETE MAZ FILE

	MOVE T1,MAZJFN
	DELF%
	 IFJER.
	  TMSG <? Couldn't delete >
	  TYPE MAZNAM
	  TYPE CRLF
	 ENDIF.

;ALL DONE REPLACE.

	SKIPE SWCOPO		;COPY OUTPUT FILES TOO?
	CALL CHKOF		;CHECK FOR GENERATED OUTPUT FILES
				; AND COPY THEM


; RETURN OR RUN FILCOM

	SKIPN SWFCOM		;RUN FILCOM?
	 RET			;NO, JUST RETURN

	TMSG <[ALU: Running FILCOM]
>
	MOVE T4,[POINT 7,[ASCIZ/R FILCOM/]]
	CALL STILF		;OUTPUT STRING AND LINEFEED TO STI BUF
	MOVE T4,[POINT 7,FCTXT]
	CALL STILF		;STRING FOR FILCOM
	MOVEI T2,3		;CONTROL-C
	CALL STICH		;OUTPUT CHAR
	HALTF%			;GO DO IT
	RET

STILF:	ILDB T2,T4		;GET CHAR
	JUMPE T2,STILL		;END, OUTPUT LF
	CALL STICH		;PUT CHAR IN BUFFER
	JRST STILF		;LOOP
STILL:	MOVEI T2,.CHCRT		;GET <CR>, <LF> IS PUT ON BY SYSTEM
STICH:	MOVE T1,MYTTY		;TTY DESIGNATOR
	STI%
	RET			;RETURN


; ERRORS IN "REPLACE"
REPLE1:	TMSG <? File wasn't reserved
>
	RET			;DONE

REPLE2:	TMSG <?OPENF failed for reserved file on the library: >
	CALL LSTFER
	HALTF%
	JRST CMDRE2		;TRY AGAIN IF "CONTINUE"

REPLE3:	TMSG <? Can't read first line of reserved file: >
	CALL LSTFER
	HALTF%
	JRST CMDRE3		;TRY AGAIN IF CONTINUE

REPLE4:	TMSG <?CLOSF failed for reserved file: >
	CALL LSTFER
	HALTF%
	JRST CMDRE4		;TRY AGAIN IF CONTINUE


SUBTTL STATUS COMMAND

CMDSTT:	MOVEI T2,[ASCIZ/of/]
	CALL NOISE

	SETZM JFNBLK		;NO DEFAULTS IN FILE-SPECS NOW
	MOVE T2,[JFNBLK,,JFNBLK+1]
	BLT T2,JFNBLK+20	;CLEAR JFN BLOCK
	HRRO T2,EXTLST		;DEFAULT EXTENSION IS FIRST
	MOVEM T2,JFNBLK+.GJEXT

	MOVEI T2,FLSTTK		;THINGS THAT COULD BE PARSED NOW
	CALL COMMND		;GO GET 'EM
	HRRZ T3,T3		;OK, WHICH PARSE BLOCK USED?
	CAIN T3,FLSTTK		;KEYWORD?
	 JRST STCMDK		;YES, DISPATCH

;MUST BE A FILE-SPEC
	MOVEM T2,PRSJFN		;SAVE PARSED JFN
	MOVEM T2,GTFJFN		;SAVE HERE FOR "FNDEXT"
	CALL CONFRM		;CONFIRM
	JRST STFILE		;STATUS (OF) FILE

FLSTTK:	FLDDB. (.CMKEY,,STTTAB,,<SIGN-OUTS>,FLSTT2)
FLSTT2:	FLDDB. (.CMFIL,CM%SDH,,<Filespec of specific file to check>)

STTTAB:	STCLEN,,STCLEN		;# OF STATUS COMMAND OPTIONS
	AA LIBRARY,STLIB
	AA MY-RESERVATIONS,STUSR
	AA SIGN-OUTS,STSIGN
	STCLEN==.-STTTAB-1

;KEYWORD
STCMDK:	MOVE T2,(T2)
	JRST (T2)		;DISPATCH

;STATUS (OF) filespec
;JFN IS IN T2 AND PRSJFN
;USE JFNS TO GET FILE.EXT IN RETJNM

STFILE:	CALL FNDEXT		;ANY KNOWN EXTENSION?
	 RET			;NO, FORGET IT

	HRROI T1,RETJNM		;PLACE TO RETURN FILESPEC
	MOVE T2,GTFJFN
	MOVX T3,1B8+1B11+JS%PAF	;FILE.EXT
	JFNS%

;LOOK ON ALL THE LIBRARIES FOR A .MAZ FILE

	TXZ F,F.TLN!F.FFL	;DIDN'T SEE ANY FILES, OR TYPE LIB NAMES YET
	MOVSI P4,-NMLIBS	;AOBJN PTR TO LIBRARIES
STFIL1:	HRRZ T1,LIBLST(P4)	;POINT TO LIBRARY DIRECTORY
	HRLI T1,(POINT 7,)	;REAL POINTER
	MOVE T3,[POINT 7,LIBHLD] ;STORE WHOLE FILESPEC HERE
	MOVE T4,[POINT 7,MAZNAM] ;AT SAME TIME, BUILD .MAZ FILENAME
STFIL2:	ILDB T2,T1		;FIRST COPY DIRECTORY NAME
	JUMPE T2,STFIL3
	IDPB T2,T3
	IDPB T2,T4
	JRST STFIL2
STFIL3:	PUSH P,T3
	MOVE T1,T4		;PASS PTR TO MAZ NAME
	CALL FXMAZN		;FIX UP MAZ NAME TO INCLUDE SUBDIR
	MOVEM T1,T4		;UPDATE PTR
	POP P,T3
	MOVE T1,[POINT 7,RETJNM] ;NOW FILE.EXT
      DO.
	ILDB T2,T1
	IDPB T2,T3
	JUMPN T2,TOP.
      ENDDO.

	MOVE T1,[POINT 7,RETJNM] ;GET NAME FOR .MAZ FILESPEC
STFIL4:	ILDB T2,T1
	CAIN T2,"."
	 JRST STFIL5		;GOT TO EXTENSION
	IDPB T2,T4
	JRST STFIL4

STFIL5:	IDPB T2,T4		;STORE DOT
	MOVE T2,EXTNUM		;GET NUMBER OF EXTENSION
	HRRZ T1,STEXTS(T2)	;.MAZ OR SOMETHING
	HRLI T1,(POINT 7,)
      DO.
	ILDB T2,T1
	IDPB T2,T4
	JUMPN T2,TOP.		;LOOP TILL EVERYTHING STORED
      ENDDO.

;WHOLE FILESPEC IS NOW IN LIBHLD - LOOK FOR THE FILE
;MAZ FILESPEC IS NOW IN MAZNAM

	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,LIBHLD
	GTJFN%			;CAN WE FIND FILE ON THE LIBRARY?
	 ERJMP STFIL6		;NO
	TXO F,F.FFL		;YES, SET FLAG
	RLJFN%			;IMMEDIATELY RELEASE IT
	 JFCL			;BETTER WORK!

;SEE IF IT IS RESERVED

	MOVX T1,GJ%SHT+GJ%OLD
	HRROI T2,MAZNAM
	GTJFN%
	 ERJMP STFIL6		;NO
	HRRZ P1,T1		;SAVE JFN
	TXO F,F.TLN		;TYPE A LIBRARY NAME
	CALL TYPLNM		;TYPE LIBRARY NAME
	TYPE RETJNM		;TYPE NAME.EXT
	TYPE CRLF		;AND CRLF
	CALL TYPFIL		;TYPE OUT THE FILE
	HRRZ T1,P1		;GET BACK JFN
	RLJFN%			;AND RELEASE IT
	 JFCL			;BETTER WORK!
STFIL6:	AOBJN P4,STFIL1		;LOOP FOR ALL LIBRARIES
	TXNE F,F.FFL		;DID WE SEE THE FILE AT ALL?
	 JRST STFIL7		;YES
	TMSG < %File not found on any library
>
	RET			;SAY THAT

STFIL7:	TXNE F,F.TLN		;WAS IT EVER RESERVED?
	 RET			;YES, WE TYPED INFO
	TMSG < [File is not reserved]
>
	RET			;RETURN

;STATUS OF MY-RESERVATIONS

STUSR:	TXO F,F.SUSR		;MAGIC FLAG DOES ALL...
	; ..

;STATUS (OF) SIGN-OUTS

STSIGN:	CALL CONFRM		;CONFIRM REQUEST

;SEARCH ALL LIBRARYS FOR SIGNED OUT FILES

	MOVSI P4,-NMLIBS	;-# LIBS
	JRST STAT1


;STATUS (OF) LIBRARY library:

STLIB:	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<library:>)]
	CALL COMMND		;PARSE THE TEXT
	LDB T1,[POINT 7,ATMBUF,6] ;ANYTHING TYPED?
	JUMPE T1,[TMSG <?"library:" expected
>
		   RET]		;FORGET IT
	MOVEI T1,ATMBUF		;Convert to uppercase
	CALL CNVUPP
	MOVE T1,[ATMBUF,,LIBHLD]
	BLT T1,LIBHLD+17
	CALL FNDLIB		;FIND WHICH LIBRARY
	 RET			;?NOT A LIBRARY
	HRRZ P4,LIBNUM		;Get library number
	HRLI P4,-1		;JUST THIS ONE LIBRARY

;HERE WITH P4 = AOBJN PTR TO LIBRARIES

STAT1:	TXZ F,F.TLN		;DIDN'T TYPE THIS LIBRARY NAME YET
	HRRZM P4,LIBNUM		;GIVE LIB NUM TO SKPFRL
	CALL SKPFRL		;SEE IF FROZEN
	IFSKP.
	DO.			;BLOCK
	  HRRZ P1,T1		;JFN IN P1
	  TXNN F,F.SUSR		;LOOKING FOR SPECIFIC USER?
	  IFSKP.
	    HRRZM P1,MAZJFN	;YES, CHECK
	    CALL CHKFME		;FROZEN BY ME?
	     EXIT.		;FROZEN, BUT NOT BY ME - SAY NOTHING.
	  ENDIF.
	  TXON F,F.TLN		;TYPE LIB NAME IF NEEDED
	  CALL TYPLNM
	  MOVE T1,P1
	  CALL TYPFIL		;TYPE THE .MAZ FILE OUT
	  HRRZ T1,P1		;RELEASE .MAZ FILE
	  RLJFN%
	   ERJMPS .+1
	ENDDO.			;END BLOCK
	ENDIF.
	HRRZ T2,LIBLST(P4)	;GET A PTR TO A LIBRARY
	HRLI T2,(POINT 7,)
	MOVE T3,[POINT 7,LIBHLD]
	CALL CPT2T3		;COPY STRING FROM T2 TO T3
	MOVE T1,T3		;PASS PTR
	CALL FXMAZN		;FIX MAX NAME TO INCLUDE SUBDIR
	MOVEM T1,T3		;UPDATE PTR
	MOVE T2,[POINT 7,[ASCIZ/*.*/]]
	CALL CPT2T3		;COPY STRING FROM T2 TO T3
	IDPB T1,T3
	MOVX T1,GJ%SHT+GJ%IFG	;WILDCARD CHARS HERE!
	HRROI T2,LIBHLD
	GTJFN%
	 ERJMP STATE1		;?GTJFN FAILED
	MOVE P1,T1		;SAVE GTJFN FLAGS
	JRST STAT3A		;FIRST TIME, SKIP GNJFN

;NOW, FOR THIS LIBRARY, WE HAVE THE GTJFN WORD RETURNED IN P1.
; THE JFN NUMBER NOW REFERS TO THE FIRST FILE IN THE LIBRARY.


;LOOK AT EACH FILE UNTIL NO MORE FILES

STAT3:	MOVE T1,P1		;GET GTJFN FLAGS BACK
	GNJFN%			;LOOK FOR NEXT FILE
	 ERJMP STATE2		;ERROR.. GO SEE WHY
STAT3A:	HRRZ T2,T1		;GET JFN RETURNED
	HRROI T1,RETJNM		;PLACE TO RETURN JFN STRING
	MOVX T3,1B11		;JUST RETURN FILE TYPE
	JFNS%

;CHECK THIS EXT TO SEE IF IT IS ONE OF THE ONES IN OUR TABLE
; IF SO, TYPE IT OUT

	MOVSI P2,-NMEXTS	;-NO EXTS IN TABLE
STAT4:	MOVE T1,[POINT 7,RETJNM]
	HRRZ T2,STEXTS(P2)
	HRLI T2,(POINT 7,)
STAT4A:	ILDB T3,T1
	ILDB P3,T2
	JUMPE T3,STAT5		;END OF THIS EXT STRING
	JUMPE P3,STAT6		;NO MATCH
	CAMN T3,P3		;THIS CHAR MATCH?
	JRST STAT4A		;YES, KEEP LOOKING
;NO MATCH

STAT6:	AOBJN P2,STAT4		;LOOK AT NEXT EXT.
	JRST STAT3		;LOOK AT NEXT FILE

STAT5:	JUMPN P3,STAT6		;IF NOT NULL ON OTHER STRING TOO, NO MATCH

;WE HAVE AN EXACT MATCH (THIS EXT IS IN OUR TABLE)

	TXNN F,F.SUSR		;SPECIFIC USER?
	IFSKP.
	  HRRZM P1,MAZJFN	;YES, CHECK
	  CALL CHKRME
	   JRST STAT6		;NOT ME, SKIP THIS FILE
	ENDIF.
	; ..

;EXT MATCHES.. TYPE OUT THIS FILE
;FIRST TYPE THE FILENAME

;NOTE: FALL HERE FROM ABOVE UNLESS THE OPEN FAILS AND HE CONTINUES
;	FROM "STATE5".

	TXON F,F.TLN		;TYPED LIBRARY NAME?
	 CALL TYPLNM		;NOT YET, TYPE IT NOW

STAT5A:	HRRZ T2,P1		;GET JFN
	HRROI T1,RETJNM
	MOVX T3,1B8		;NAME
	JFNS%

	TYPE RETJNM		;NOW TYPE STRING
	MOVEI T1,"."
	PBOUT%
	HRRO T1,EXTLST(P2)	;GET EXTENSION TO TYPE
	PSOUT%
	TYPE CRLF
	CALL TYPFIL		;TYPE OUT THE FILE
	JRST STAT3		;GO ON TO NEXT FILE

;ROUTINE TO TYPE A FILE
;CALL:	P1/ JFN (NOT OPENED)
;	CALL TYPFIL
;	<RETURN HERE, JFN CLOSED BUT NOT RELEASED>

TYPFIL:	HRRZ T1,P1		;GET JFN
	MOVX T2,7B5+OF%RD
	OPENF%
	 ERJMP TYPFE1		;FAILED

;TYPE IT OUT

TYPFL1:	HRRZ T1,P1
	BIN%
	 ERJMP TYPFL2		;FAILED--PROBABLY EOF
	HRRZ T1,T2
	PBOUT%
	JRST TYPFL1

TYPFL2:	JUMPE T2,TYPFL3		;ASSUME EOF IF BYTE IS 0
	TMSG <? Error reading file: >
	CALL LSTFER
	HALTF%
	RET

TYPFL3:	MOVX T1,CO%NRJ		;DON'T RELEASE JFN
	HRR T1,P1
	CLOSF%			;CLOSE THE FILE
	 ERJMP TYPFE2		;FAILED
	RET			;OK, RETURN

;OPENF FAILED

TYPFE1:	TMSG <?OPENF failed: >
	CALL LSTFER
	HALTF%
	JRST TYPFIL		;GO TRY AGAIN

;CLOSF FAILED

TYPFE2:	TMSG <?CLOSF failed: >
	CALL LSTFER
	HALTF%
	RET			;JUST RETURN IF HE CONTINUES

;ROUTINE TO TYPE "[LIBARY <DIR>]" AND CRLF

TYPLNM:	CALL TYPLN1		;TYPE "[LIBARY <DIR>"
	TYPE <[ASCIZ/]
/]>
	RET			;RETURN

TYPLN1:	TYPE <[ASCIZ/ [Library /]>
	HRRO T1,LB1LST(P4)
	PSOUT%
	TMSG < = >
	HRRO T1,LIBLST(P4)
	PSOUT%
	RET

; ERRORS IN "STATUS" COMMAND

;GTJFN FAILED FOR <LIBRARY>*.*

STATE1:	TXNN F,F.SUSR		;MESSAGE WANTED?
	CAIN T1,GJFX32		;"NO FILES MATCH THIS SPEC"
	JRST NXTLIB		;NO, YES - GO ON TO NEXT LIBRARY
	TMSG <% Library >
	HRRO T1,LIBLST(P4)
	PSOUT%
	TMSG < not properly setup for ALU.
>
	JRST NXTLIB		;Go on to next library

;GNJFN FAILED

STATE2:
NXTLIB:	TXNN F,F.TLN		;DID WE TYPE THE NAME YET?
	TXNE F,F.SUSR
	IFSKP.
	  CALL TYPLN1		;TYPE "LIBRARY <DIR"
	  TYPE <[ASCIZ/: No files reserved]
/]>
	ENDIF.
	AOBJN P4,STAT1		;GO ON TO NEXT LIBRARY
	RET			;NO MORE, ALL DONE

STATE5:	TMSG <?OPENF failed: >
	CALL LSTFER
	HALTF%
	JRST STAT5A		;GO TRY AGAIN

STATE7:	TMSG <?CLOSF failed: >
	CALL LSTFER
	HALTF%
	RET			;JUST RETURN IF HE CONTINUES


	SUBTTL UNFREEZE COMMAND

CMDUNF:	MOVEI T2,[ASCIZ /library/]
	CALL NOISE
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<library name:>)]
	CALL COMMND
	LDB T1,[POINT 7,ATMBUF,6]
	JUMPE T1,[TMSG <?"library:" expected.
>
		RET]
	MOVEI T1,ATMBUF
	CALL CNVUPP
	MOVE T1,[ATMBUF,,LIBHLD]
	BLT T1,LIBHLD+17
	CALL FNDLIB		;LOOKUP LIBRARY NAME
	 RET
	CALL SKPFRL		;SEE IF ALREADY FROZEN
	IFNSK.
	  TMSG <?Library is not frozen.
>
	  RET
	ENDIF.
	DELF%			;DELETE THE FREEZE FILE
	IFJER.
	  TMSG <%Couldn't delete freeze file.
>
	ENDIF.
	RET

SUBTTL HELP COMMAND

CMDHLP:	MOVEI T2,[ASCIZ/with ALU/]
	CALL NOISE
	CALL CONFRM
	MOVX T1,GJ%OLD+GJ%SHT
	HRROI T2,[ASCIZ/HLP:ALU.HLP/]
	GTJFN%			;Find HLP:ALU.HLP
	 IFJER.
	  MOVX T1,GJ%OLD+GJ%SHT
	  HRROI T2,[ASCIZ/ALU:ALU.HLP/]
	  GTJFN%
	   ERJMP NOHLP		;Not on either HLP: or SYS:
	 ENDIF.
	HRRZ T4,T1		;Save JFN
	MOVE T1,T4		;Get JFN
	MOVE T2,[7B5+OF%RD]	;OPEN for read access
	OPENF%
	 ERJMP COHLPF		;?Can't open help file

;Type the file out on the terminal

CMDHL2:	MOVE T1,T4		;Get JFN
	BIN%
	 ERJMP CMDHL3		;Error on BIN, assume EOF
	MOVEI T1,.PRIOU		;Output to TTY:
	BOUT%
	 ERJMP .+1
	JRST CMDHL2		;Loop till EOF

CMDHL3:	MOVE T1,T4		;Get JFN
	CLOSF%			;Close help file
	 ERJMP .+1		;Ignore failure
	RET			;Return

;No help available

NOHLP:	TMSG <? Can't find the ALU help file on HLP: or SYS:
>
	RET			;Return giving no help

;Can't OPEN the help file

COHLPF:	TMSG <?Can't OPEN  ALU.HLP: >
	PUSH P,T4		;Get JFN
	CALL LSTFRC		;Type why and CRLF
	POP P,T1		;Try to get rid of JFN
	RLJFN%
	 ERJMP .+1
	RET


SUBTTL INFORMATION COMMAND

CMDINF:	MOVEI T2,[ASCIZ/about/]
	CALL NOISE
	MOVEI T2,[FLDDB. (.CMKEY,,INFTAB)]
	CALL COMMND		;GET KEYWORD
	MOVE T2,(T2)		;PARSED OK, GET ADDRESS
	JRST (T2)		;GO DO IT

INFTAB:	INFLEN,,INFLEN		;HEADER
	AA EXTENSIONS,INFEXT
	AA FUNCTION-CONTROL-SWITCHES,INFFT
	AA LIBRARIES,INFLIB
	AA USERS,INFUSR
	AA VERSION,INFVER

	INFLEN==.-INFTAB-1	;NUMBER OF INFORMATION COMMANDS

SUBTTL INFORMATION (ABOUT) FUNCTION-CONTROL-SWITCHES

INFFT:	CALL CONFRM		;CONFIRM COMMAND
	TMSG <
  This version of ALU is setup with the following function-control switches:
>
INFFT1:	TMSG <
SWFUID = >
	SKIPE SWFUID
	 JRST FILUDY
	TMSG <0 (No "UID" line will be placed into the
		file being replaced. ALU log entries will not point you
		to the previous edit of the file)
>
	JRST INFFT2

FILUDY:	TMSG <1 (A "UID" line will be placed into the
		file being replaced. This enables you to see who last
		edited the file, and allows ALU log entries to point you
		to the previous edit of the file)
>
	TYPE [ASCIZ /
SWRUID = /]
	SKIPN SWRUID
	JRST [	TYPE [ASCIZ /0 (New UID lines will be added to the file
		and will not replace such lines already in the file.)
/]
		JRST INFFT2]
	TYPE [ASCIZ /1 (The new UID lines will replace the one already
		in the file if there is one.)
/]
INFFT2:	TMSG <
SWCOPO = >
	SKIPN SWCOPO
	 JRST COPOFN
	TMSG <1 (Files generated from the source file
		being REPLACE'd are also copied to the library)
>
	JRST INFFT3
COPOFN:	TMSG <0 (Only the source file is REPLACE'd, files
		generated from it are left alone)
>
INFFT3:	TMSG <
SWFCOM = >
	SKIPN SWFCOM
	 JRST FTFCMN
	TMSG <1 (FILCOM is run automatically after REPLACE's)
>
	JRST INFFT4

FTFCMN:	TMSG <0 (FILCOM is not run automatically after REPLACE's)
>
INFFT4:	TYPE [ASCIZ /
SWBAKF = /]
	SKIPN SWBAKF
	JRST [	TYPE [ASCIZ /0 (Backup files, e.g. ".MAB" will not be
		generated.  Multiple generations of the source (depending
		on the generation retention count) will be left on the library.)
/]
		JRST INFFT5]
	TYPE [ASCIZ /1 (Backup files will be made by renaming the source
		being replaced to be a file with the same name and a
		related extension, e.g. ".MAB".)
/]
INFFT5:	TMSG <
SWANYU = >
	SKIPN SWANYU
	 JRST [	TYPE [ASCIZ /0 (Only registered users may use ALU).
/]
		JRST INFFT6]
	TYPE [ASCIZ /1 (Any user with access to the libraries can use ALU).
/]
INFFT6:	TMSG <
SWGCPY = >
	SKIPN SWGCPY
	 JRST [ TYPE [ASCIZ /0 (If you do a GET and the file is already reserved,
		ALU just aborts the GET and does not ask you if you'd like a copy anyway).
/]
		JRST INFFT7]
	TYPE [ASCIZ /1 (If you do a GET and the file is already reserved,
		ALU will give you the option of copying it anyway).
/]
INFFT7:	TMSG <
SWREDT = >
	SKIPN SWREDT
	 JRST [ TYPE [ASCIZ /0 (REDIT is not run automatically before REPLACE)
/]
		JRST INFFT8]
	TYPE [ASCIZ /1 (REDIT is run automatically before REPLACE)
/]
INFFT8:	TMSG <
SWCGET = >
	SKIPN SWCGET
	 JRST [ TYPE [ASCIZ \0 (Default on GET and QGET is /NOCOPY)
\]
		JRST INFFT9]
	TYPE [ASCIZ \1 (Default on GET and QGET is /COPY)
\]
INFFT9:	TYPE CRLF		;FINAL CRLF FOR AESTETICS
	RET			;RETURN

SUBTTL INFORMATION (ABOUT) LIBRARIES

;TYPES OUT THE LIBRARIES ALU IS BUILT TO LOOK AT
INFLIB:	CALL CONFRM		;CONFIRM COMMAND
	TMSG <
  This version of ALU knows about the following libraries:

LOGICAL NAME   DIRECTORY             LOG AREA
------------   ---------             --------

>
	MOVEI T1,^D16		;"DIRECTORY" starts here
	MOVEM T1,ILBCD
	MOVEI T1,^D38		;"LOG AREA" starts here
	MOVEM T1,ILBCL
	MOVEI P1,0		;Index to library
INFLB1:	MOVE T1,[POINT 7,TLINE]	;BUILD OUTPUT LINE HERE
	MOVEM T1,TEMPBP		;Save as temporary BP
	MOVEI T1,1		;Set to column 1
	MOVEM T1,TLCOLM		; . .
	MOVEI T1," "		;Assume not default lib
	SKIPN DFLIBW		;Is there a default lib?
	 JRST INFLB2		;No, skip type space here
	CAMN P1,DLBIDX		;Is this it?
	 MOVEI T1,"*"		;Yes, put out a "*" to mark it
INFLB2:	CALL TLCHR		;Put char in TLINE
	MOVEI T1," "		;GET A SPACE
	CALL TLCHR
	CALL TLCHR
INFLB3:	HRRZ T3,LB1LST(P1)
	HRLI T3,(POINT 7,)	;NOW OUTPUT NAME
      DO.
	ILDB T1,T3
	JUMPE T1,ENDLP.
	CALL TLCHR
	LOOP.
      ENDDO.
	MOVE T2,ILBCD		;Pad out to where directory will start
	CALL TLPAD
	HRRZ T3,LIBLST(P1)	;NOW OUTPUT DIRECTORY NAME
	HRLI T3,(POINT 7,)
      DO.
	ILDB T1,T3
	JUMPE T1,ENDLP.		;JUMP WHEN DONE
	CALL TLCHR
	LOOP.
      ENDDO.
	; ..

;INFLIB ROUTINE  (CONT'D).

	; ..
	MOVE T2,ILBCL		;Pad out to where log-area will start
	CALL TLPAD
	HRRZ T3,LB2LST(P1)	;Now output LOG-area name
	HRLI T3,(POINT 7,)
      DO.
	ILDB T1,T3
	JUMPE T1,ENDLP.
	CALL TLCHR
	LOOP.
      ENDDO.

	MOVEI T4,.CHCRT		;CR
	IDPB T4,TEMPBP
	MOVEI T4,.CHLFD		;LF
	IDPB T4,TEMPBP		;APPEND CRLF TO STRING
	SETZ T4,
	IDPB T4,TEMPBP		;NULL TO END STRING
	TYPE TLINE		;NOW OUTPUT THE LINE

	AOJ P1,			;Next library
	CAIE P1,NMLIBS		;Done?
	 JRST INFLB1		;No, loop
	SKIPN DFLIBW		;Was default library marked?
	 JRST INFLB7		;No
	TMSG <
"*" means this library is the default if not specified for GET, REPLACE, etc.
>
INFLB7:	TYPE CRLF		;FINAL CRLF FOR NEATNESS
	RET			;THEN RETURN


; Routines to get column output right.

;Routine to store character in TLINE.
;Call:
;	TEMPBP/ BP to TLINE
;	T1/ character value
;	CALL TLCHR
;	<return here, TLCOLM incremented>
;Uses T1 only

TLCHR:	IDPB T1,TEMPBP		;Store char
	AOS TLCOLM		;Increment column number
	RET			; and return


;Routine to pad out to column #.
;Call:
;	T2/ desired column number
;	TLCOLM/ actual column number
;	CALL TLPAD
;	<return here>
;Uses T1-T3

TLPAD:	MOVEI T1," "		;Get a space
TLPAD1:	CALL TLCHR		;Put at least one out
	MOVE T3,TLCOLM		;Get actual column number
	CAMG T2,T3		;Far enough, or too far?
	 RET			;Yes, return
	JRST TLPAD1		;No, loop

SUBTTL INFORMATION (ABOUT) EXTENSIONS

;TYPES OUT THE LIST OF KNOWN EXTENSIONS AND THEIR CHARACTERISTICS
INFEXT:	CALL CONFRM		;CONFIRM THE COMMAND
	TMSG <
   The following is a list of file types that are known to
this version of ALU.  (Note: RSVFILE is the extension of the
file on the library which will contain the "WHY" text.
BACKUP is the extension of the backup file on the library).
>
	TMSG <
SOURCE RSVFILE BACKUP
------ ------- ------
>
	MOVSI P1,-NMEXTS	;# OF KNOWN EXTENSIONS
INFEX1:	MOVE T1,[POINT 7,TLINE]	;WRITE OUTPUT LINE TO HERE
	HRRZ T2,EXTLST(P1)	;GET AN EXTENSION
	HRLI T2,(POINT 7,)	;MAKE PTR TO IT
	CALL CPYNUL
	MOVEI T3,.CHTAB
	IDPB T3,T1
	HRRZ T2,STEXTS(P1)	;.MAZ FILE EXT
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVEI T3,.CHTAB
	IDPB T3,T1
	HRRZ T2,EXBLST(P1)	;BACKUP FILE EXT
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVEI T3,.CHCRT
	IDPB T3,T1
	MOVEI T3,.CHLFD
	IDPB T3,T1
	SETZ T3,
	IDPB T3,T1		;END STRING
	TYPE TLINE		;OUTPUT THE LINE
	SKIPN SWCOPO		;GENERATED OUTPUT FILES?
	 JRST INFEXO		;NO

	TMSG < Generated output file(s): >
	SKIPN P2,EXOLST(P1)	;ANY FOR THIS FILE?
	 JRST INFEXN		;NO, SAY "NONE"
	JRST INFEX6		;JUMP OVER COMMA PRINTING
INFEX5:	TMSG <,>
INFEX6:	HRRZ T2,(P2)		;POINT TO ONE
	HRLI T2,(POINT 7,)
	MOVE T1,[POINT 7,TLINE]	;WRITE TO HERE
	CALL CPYNUL

	TYPE TLINE

	AOBJN P2,INFEX5		;LOOP IF MORE TO DO
	TYPE CRLF
	JRST INFEXO

INFEXN:	TMSG <-None-
>

INFEXO:	TYPE CRLF
	AOBJN P1,INFEX1		;LOOP FOR ALL EXTS
	RET			;DONE, RETURN

SUBTTL INFORMATION (ABOUT) USERS

;TYPES OUT THE LIST OF USERS (DIRECTORY NAMES FROM WHICH ALU CAN BE RUN)
INFUSR:	CALL CONFRM		;CONFIRM COMMAND
	TMSG <
  To reserve a file with ALU, you must be
logged in as one of the following users:

>
	MOVSI P1,-NMUSRS	;AOBJN POINTER TO USERS
INFUS1:	MOVE T1,[POINT 7,TLINE]	;BUILD STRING HERE
	HRRZ T2,USRLST(P1)	;POINT TO USER NAME
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVEI T3,.CHCRT		;APPEND CRLF TO STRING
	IDPB T3,T1
	MOVEI T3,.CHLFD
	IDPB T3,T1
	SETZ T3,
	IDPB T3,T1		;NULL TO END
	TYPE TLINE		;NOW TYPE THE LINE
	AOBJN P1,INFUS1		;GO TO NEXT USER
	SKIPN SWANYU		;ANY USER ALLOWED?
	 JRST INFUS3		;NO
	TMSG <
 or any other user with file access to the libraries.
>
INFUS3:	TYPE CRLF
	RET			;DONE, RETURN

SUBTTL INFORMATION (ABOUT) VERSION (OF ALU)

INFVER:	MOVEI T2,[ASCIZ/of ALU/]
	CALL NOISE
	CALL CONFRM
	TMSG < This is >
	TYPE AVERST		;Type version string
	TYPE CRLF
	RET			;Done, return

SUBTTL ^EDDT COMMAND

CMEDDT:	CALL CONFRM		;CONFIRM
GODDT:	TDZA P3,P3		;HAVEN'T BEEN HERE BEFORE
GODDT0:	SETO P3,		;BEEN HERE BEFORE
	MOVE 1,[400000,,770]	;[26] IS PAGE ACCESSIBLE?
	RPACS%
	AND 2,[EXP PA%RD!PA%EX!PA%PEX]
	CAME 2,[EXP PA%RD!PA%EX!PA%PEX]
	 JRST GETDD		;NO, BUT TRY TO READ DDT IN
	MOVE 1,770000		;DOES IT CONTAIN DDT?
	CAME 1,[JRST 770002]	;PROBABLY, IF EQUAL.
	 JRST NODDT		;GIVE ERROR
	TYPE <[ASCIZ/[Return from DDT by typing "POPJ 17,$X"]
/]>
	CALL 770000		;CALL DDT
	RET			;RETURN TO COMMAND SCANNER
NODDT:	TMSG <?DDT not accessible
>
	RET			;RETURN TO COMMAND SCANNER


;HERE IF PAGE IS NOT EVEN ACCESSIBLE.  TRY TO READ DDT IN (BUT
; BE CAREFUL TO NOT ALLOW IT TO WIPE OUT EXISTING DATA!)
GETDD:	JUMPN P3,NODDT		;IF BEEN HERE BEFORE, GIVE UP
	MOVX T1,GJ%OLD!GJ%SHT	;GET DDT
	HRROI T2,[ASCIZ/SYS:UDDT.EXE/]
	GTJFN%
	 ERJMP NODDT		;NOT THERE--SAY "NOT ACCESSIBLE"
	PUSH P,T1		;SAVE THE JFN
	MOVEI T1,.FHSLF		;SAVE ENTRY VECTOR INFO
	GEVEC%			; (GET% SMASHES IT)
	PUSH P,T2		;SAVE THE INFO
	MOVE T1,-1(P)		;GET JFN BACK
	HRLI T1,.FHSLF		;READ INTO SAME FORK
	TXO T1,GT%NOV		;DON'T OVERLAY EXISTING PAGES!!
	GET%			;READ IN DDT
	 ERJMP GETFAI		;FAILED
	POP P,T2		;ENTRY VECTOR INFO
	MOVEI T1,.FHSLF
	SEVEC%			;RESTORE ENTRY VECTOR
	POP P,(P)		;FORGET JFN, DON'T CARE ANYMORE
	DMOVE T1,116		;GET SYMBOL TABLE INFO
	MOVEM T1,@770001	;STORE IN DDT
	MOVEM T2,@770002	;. .
	JRST GODDT0		;GO TRY AGAIN

GETFAI:	POP P,(P)		;FORGET ENTRY VECTOR INFO
	TMSG <?GET failed-- can't read in DDT: >
	CALL LSTFER		;TYPE LAST ERROR IN THIS FORK
	TYPE CRLF
	POP P,T1		;RECOVER JFN
	RLJFN%
	 IFJER.
	  TMSG <?Can't release JFN for SYS:UDDT.EXE: >
	  CALL LSTFER
	  TYPE CRLF
	 ENDIF.
	RET			;DONE, RETURN

SUBTTL ^ESET COMMAND

CMESET:	MOVEI P3,1		;"NO" NOT TYPED
CMEST1:	MOVEI T2,[FLDDB. (.CMKEY,,ESETTB,<keyword or "NO keyword">)]
	CALL COMMND		;PARSE THE KEYWORD
	HRRZ T2,(T2)
	JRST (T2)		;GO DO IT

ESETTB:	ESETLN,,ESETLN		;HEADER
	AA ANY-USER-ALLOWED,ESANYU
	AA BACKUP,ESBAKF
	AA COPY-ON-GET,ESCGET
	AA COPY-OUTPUT-FILES,ESCOPO
	AA FILCOM-AFTER-REPLACE,ESFCOM
	AA GET-RESERVED-FILE-OPTION,ESGCPY
	AA NO,ESNO,CM%INV	;INVISIBLE "NO" COMMAND
	AA REDIT-BEFORE-REPLACE,ESREDT
	AA REPLACE,ESRUID
	AA UID-IN-SOURCE,ESFUID
	ESETLN==.-ESETTB-1	;NUMBER OF ^E SET COMMANDS

ESNO:	TRC P3,1		;COMPLEMENT "NO" FLAG
	JRST CMEST1		;GET ANOTHER ARG

ESCOPO:	CALL CONFRM
	CAME P3,SWCOPO		;ALREADY SET?
	SETCMM CNCOPO		;YES, REMEMBER WE CHANGED IT
	MOVEM P3,SWCOPO
	RET			;DONE, RETURN

ESCGET:	CALL CONFRM
	CAME P3,SWCGET
	SETCMM CNCGET
	MOVEM P3,SWCGET
	RET

ESFCOM:	CALL CONFRM
	CAME P3,SWFCOM
	SETCMM CNFCOM
	MOVEM P3,SWFCOM
	RET

ESFUID:	CALL CONFRM
	CAME P3,SWFUID
	SETCMM CNFUID
	MOVEM P3,SWFUID
	RET

ESBAKF:	CALL CONFRM
	CAME P3,SWBAKF
	SETCMM CNBAKF
	MOVEM P3,SWBAKF
	RET

ESRUID:	CALL CONFRM
	CAME P3,SWRUID
	SETCMM CNBAKF
	MOVEM P3,SWRUID
	RET

ESANYU:	CALL CONFRM
	CAME P3,SWANYU
	SETCMM CNANYU
	MOVEM P3,SWANYU
	RET

ESGCPY:	CALL CONFRM
	CAME P3,SWGCPY
	SETCMM CNGCPY
	MOVEM P3,SWGCPY
	RET

ESREDT:	CALL CONFRM
	CAME P3,SWREDT
	SETCMM CNREDT
	MOVEM P3,SWREDT
	RET

SUBTTL MAZSTR - OUTPUT STRING TO MAZ FILE

;OUTPUT STRING TO MAZ FILE
;CALL:	T3 / ADDRESS OF ASCIZ STRING
;	CALL MAZSTR
;	<RETURN HERE IF GOT "QUOTA EXCEEDED" ERROR> (ALL OTHER ERRORS BOMB OUT)
;	<RETURN HERE IF OK>

MAZSTR:	HRLI T3,(POINT 7,)	;MAKE A STRING POINTER
	HRRZ T1,MAZJFN		;T1:= JFN FOR BOUT
MAZST1:	ILDB T2,T3		;GET NEXT BYTE
	JUMPE T2,RSKP		;DONE IF NULL
MAZST2:	BOUT%			;WRITE IT
	 IFJER.
	  CALL MAZSTE		;HANDLE ERROR
	  JRST MAZST2		;TRY AGAIN
	ENDIF.
	JRST MAZST1		;LOOP

MAZSTE:	SAVEAC <T1,T2,T3,T4>
	TMSG <?Can't write string to MAZ file: >
	CALL LSTFER
	HALTF%
	RET

;OUTPUT DATE/TIME TO FILE
MAZTIM:	HRRZ T1,MAZJFN		;OUTPUT TO THE FILE
	SETO T2,		;CURRENT DATE/TIME

;SET FLAGS FOR DATE WITH SLASHES, NO TIME
	MOVX T3,OT%SLA+OT%NMN+OT%SCL+OT%DAM+OT%NTM
MAZTI1:	ODTIM%
	 IFJER.
	  CALL MAZSTE
	  JRST MAZTI1		;TRY AGAIN
	ENDIF.
	MOVEI T3,[ASCIZ/ at /]
	CALL MAZSTR
	 RET			;QUOTA EXCEEDED ERROR

	CALL GTTIM		;GET TIME IN HLDTM1
	 RET			;ERROR, TRY WRITING WHOLE FILE AGAIN
	MOVEI T3,HLDTM1
	CALL MAZSTR
	 RET			;QUOTA EXCEEDED ERROR
	JRST RSKP		;RETURN OK

SUBTTL GTTIM - GET CURRENT TIME STRING IN HLDTM1
;RETURNS .+1 IF FAILURE, .+2 IF OK

GTTIM:	HRROI T1,HLDTIM		;HOLD ASCIZ TIME
	SETO T2,		;CURRENT TIME
	MOVX T3,OT%NDA+OT%12H+OT%NSC+OT%SCL
	ODTIM%			;WRITE TIME TO BUFFER
	 ERJMP MAZTME
	SETZ T2,
	IDPB T2,T1

	MOVE T3,[POINT 7,HLDTIM] ;FROM HERE
	MOVE T4,[POINT 7,HLDTM1] ;TO HERE
GTTIM1:	ILDB T2,T3		;GET A CHAR FROM TIME
	CAIE T2,"A"
	CAIN T2,"P"
	IFNSK.
	  MOVEI T1," "
	  IDPB T1,T4
	ENDIF.
	IDPB T2,T4
	JUMPN T2,GTTIM1
	JRST RSKP		;RETURN OK

MAZTME:	TMSG <?ODTIM failed: >
	CALL LSTFER
	HALTF%
	RET			;TRY WRITING WHOLE MAZ FILE AGAIN IF CONTINUE

SUBTTL BRCHR, YESNO ROUTINES

BRCHR:	CAIE T1,15
	CAIN T1,12
	 RET
	CAIN T1,0
	 RET
	CAIN T1,32
	 RET
	CAIE T1,13
	CAIN T1,14
	 RET
	AOS (P)
	RET

;GET A "YES" OR "NO" FROM TTY
; <CR> MEANS NO.
;RETURNS .+1 IF "NO", .+2 IF "YES"

YESNO:	CALL ITTLIN
	 JRST ERESET		;ERRORS.. BACK TO COMMAND SCANNER

;CHECK FOR "YES"
	MOVE T3,[POINT 7,TLINE]	;POINT TO ANSWER
	ILDB T1,T3
	CAIE T1,"y"
	CAIN T1,"Y"
	 JRST RETYES
	CAIE T1,"n"
	CAIN T1,"N"
	 JRST RETNO
	CALL BRCHR		;<CR> IMPLIES NO
	 JRST RETNO
	TMSG <? Please type "YES" or "NO"
>
	JRST YESNO		;TRY AGAIN

RETYES:	AOS (P)
RETNO:	RET


SUBTTL GTFINL - SEE IF FILE IN GTFJFN IS IN A LIBRARY

; IF SO, SETS LIBNUM TO THE INTERNAL LIBRARY NUMBER AND SKIPS
;ELSE TYPES ERROR MESSAGE AND POPJ'S

;THIS ROUTINE USES THE "RETJNM" FILENAME BUFFER, AND P1

GTFINL:	HRROI T1,RETJNM
	HRRZ T2,GTFJFN
	MOVX T3,1B2+1B5+JS%PAF	;DEVICE AND DIRECTORY FIELD WITH PUNCTUATION
	JFNS%

	MOVSI P1,-NMLIBS
GTFIN1:	HRR T1,LIBLST(P1)	;GET PTR TO A LIB NAME
	HRLI T1,(POINT 7,)
	MOVE T2,[POINT 7,RETJNM] ;GET PTR TO RETURNED NAME
GTFIN2:	ILDB T3,T1
	ILDB T4,T2		;GET CHAR FROM EACH
	JUMPE T3,GTFIN3		; END OF FIRST
	JUMPE T4,GTFIN4		;NO MATCH
	CAMN T3,T4
	 JRST GTFIN2		;MATCH ON THIS CHAR
;NO MATCH
GTFIN4:	AOBJN P1,GTFIN1		;LOOP FOR ALL NAMES
	TMSG <? File is not in a library
>
	RET			;RETURN

GTFIN3:	JUMPN T4,GTFIN4		;JUMP IF NO MATCH

	HRRM P1,LIBNUM		;SAVE NUMBER OF THE LIBRARY
	AOS (P)			;GIVE GOOD RETURN
	RET


SUBTTL FNDEXT - SEE IF FILE IN GTFJFN HAS A KNOWN EXTENSION

; IF SO, SET "EXTNUM" AND SKIP RETURN
; ELSE GIVE ERROR AND POPJ
FNDEXT:	HRROI T1,RETJNM
	HRRZ T2,GTFJFN
	MOVX T3,1B11		;JUST EXT.
	JFNS%

	MOVSI P1,-NMEXTS	;NUMBER OF KNOWN EXTENSIONS
FNDEX1:	HRR T1,EXTLST(P1)
	HRLI T1,(POINT 7,)
	MOVE T2,[POINT 7,RETJNM]
FNDEX2:	ILDB T3,T1
	ILDB T4,T2
	JUMPE T3,FNDEX4		;END OF 1ST STRING
	JUMPE T4,FNDEX3		;NO MATCH
	CAMN T3,T4
	 JRST FNDEX2		;ALL MATCH SO FAR
;NO MATCH
FNDEX3:	AOBJN P1,FNDEX1		;LOOP FOR ALL EXTS
	TMSG <? File extension is unknown to ALU
>
	RET			;RETURN
FNDEX4:	JUMPN T4,FNDEX3		;NO MATCH

;FOUND OUR EXTENSION
	HRRM P1,EXTNUM		;SAVE EXTENSION NUMBER
	AOS (P)			;SKIP RETURN FOR SUCCESS
	RET			;RETURN


SUBTTL GMAZNM - BUILD .MAZ FILE NAME IN MAZNAM

;MAKES AN ASCII FILENAME FOR THE .MAZ FILE, GIVEN EXTNUM
; SET UP ALREADY BY FNDEXT, AND .MAC FILE JFN IN "GTFJFN".
;SKIP RETURNS IF SUCCESSFUL, WITH ASCII NAME IN "MAZNAM".

GMAZNM:	MOVE T1,[POINT 7,MAZNAM]
	HRRZ T2,GTFJFN
	MOVX T3,1B2+1B5+JS%PAF	;DEV:<DIRECTORY>
	JFNS%
	CALL FXMAZN		;FIX UP STRING TO INCLUDE SUBDIR
	HRRZ T2,GTFJFN
	MOVX T3,1B8+JS%PAF
	JFNS%			;APPEND FILE NAME

;TACK ON EXT
	MOVEI T4,"."
	IDPB T4,T1
	MOVE T2,EXTNUM		;GET NUMBER OF THE EXTENSION
	HRRZ T2,STEXTS(T2)	; .MAZ OR SOMETHING
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	RETSKP

;FIX UP DIRECTORY NAME STRING TO INCLUDE SUBDIRECTORY
; T1/ BYTE PTR TO STRING, LAST CHAR OF WHICH SHOULD BE DIR CLOSING PUNCT

FXMAZN:	BKJFN%			;BACK UP OVER CLOSING DIRECTORY PUNCT
	 ERJMPS .+1
	HRROI T2,SUBDIR		;APPEND SUBDIRECTORY STRING IF ANY
	SETZ T3,
	SOUT
	MOVEI T2,">"
	IDPB T2,T1		;FINAL PUNCTUATION
	RET

	SUBTTL GET FREEZE FILE

SKPFRL:	MOVE T1,[POINT 7,MAZNAM]
	MOVE T2,LIBNUM
	HRRZ T2,LIBLST(T2)	;MAKE PTR TO LIB STRING
	HRLI T2,(POINT 7,0)
	CALL CPYNUL		;COPY LIB NAME
	JRST SKPFR1		;JOIN COMMON CODE

SKPFRF:	MOVE T1,[POINT 7,MAZNAM]
	HRRZ T2,GTFJFN		;JFN ON REQUESTED FILE
	MOVX T3,1B2+1B5+JS%PAF	;DEVICE AND DIRECTORY
	JFNS%
	 ERCALS FATAL
SKPFR1:	CALL FXMAZN		;INCLUDE SUBDIRECTORY
	MOVE T2,[POINT 7,[ASCIZ /FREEZE.TXT/]]
	CALL CPYNUL		;BUILD REST OF FILE NAME
	MOVX T1,GJ%OLD!GJ%SHT
	HRROI T2,MAZNAM
	GTJFN%			;TRY TO FIND I
	 ERJMPS RTN
	RETSKP

SUBTTL ROUTINE TO OPEN OUTPUT FILE TO WRITE BYTES

;CALL:	OJFN/ JFN
;	CALL OPENO
;	<HERE IF ERROR, MESSAGE TYPED OUT, JFN RELEASED>
;	<HERE IF OK>

OPENO:	HRRZ T1,OJFN
	MOVX T2,7B5+OF%WR
	OPENF%
	 ERJMP OPENE1		;OPENF FAILED
	AOS (P)			;OK--RETURN
	RET

OPENE1:	TMSG <? Can't OPENF >
	MOVEI T1,.PRIOU
	HRRZ T2,OJFN
	SETZ T3,
	JFNS%

	TMSG < for writing: >
	CALL LSTFER
	TYPE CRLF

	HRRZ T1,OJFN		;NOW RELEASE JFN
	RLJFN%
	 ERJMP .+1		;IGNORE ERRORS
	RET


SUBTTL IOPEN - OPEN INPUT FILE FOR PMAP'S.

;RETURNS .+2 IF OK
IOPEN:	MOVE T1,IJFN
	MOVX T2,OF%RD+7B5	;OPEN FOR READ
	OPENF%
	 ERJMP IOPEE1		;FAILED.. GO SEE WHY
	HRRZ T1,IJFN		;GET BYTE SIZE , & BYTES
	MOVE T2,[2,,.FBBYV]
	MOVEI T3,P1
	GTFDB%
	 ERJMP IOPEE2		;?CAN'T GET FDB INFO
	LDB T1,[POINTR P1,FB%BSZ] ;GET BYTE SIZE
	MOVEM T1,BSINP		;SAVE
	MOVEM P2,BCINP		;SAVE BYTE COUNT, TOO
	AOS (P)			;OK, RETURN
	RET			;DONE, RETURN

IOPEE1:	TMSG <?IOPEN: OPENF failed: >
	CALL LSTFER
	HALTF%
	RET

IOPEE2:	TMSG <?IOPEN: GTFDB failed: >
	CALL LSTFER
	HALTF%
	RET

SUBTTL PRELOD - PAGE PRELOAD ROUTINE

;THIS ROUTINE PRE-LOADS SOME PAGES FROM IJFN FILE

NPAGES:	^D25			;MOUTH SIZE
PRELOD:	CALL IOPEN		;OPEN INPUT FILE, PAGE MODE
	 RET			;CAN'T, JUST RETURN

;ENTRY POINT IF FILE IS ALREADY OPEN
PRELD0:	MOVE P1,NPAGES		;GET SOME
	CALL FINFRE		; FREE PAGES
	MOVEM T1,STIPGS		;START OF INPUT PAGES
	LSH T1,9
	MOVEM T1,STIPG2		; ADDRESS OF THE BLOCK
	SETZM NXTBEG		;START AT PAGE 0

;ENTRY POINT TO READ NEXT FEW PAGES IN WITH PMAP

PRELD1:	HRL T1,IJFN		;MAP FROM INPUT JFN
	HRR T1,NXTBEG		;START WITH THESE PAGES
	HRLI T2,.FHSLF		;OUR PROCESS
	HRR T2,STIPGS		; STARTING HERE
	MOVX T3,PM%RD!PM%PLD!PM%CNT ;READ, PRELOAD, REPEAT COUNT GIVEN
	HRR T3,NPAGES		;READ THIS MANY
	PMAP%
	 IFJE. (R)
	  CAIE T1,LNGFX1	;OFF INTO NONX PAGE TABLE?
	  JRST PRELE1		;NO, UNEXPECTED
	 ENDIF.
	RET			;DONE, RETURN

PRELE1:	TMSG <? PMAP failed to PRE-load pages: >
	CALL LSTFER
	TYPE CRLF
	HALTF%
	RET

SUBTTL PPCPY - FAST COPY ROUTINE FOR COPYING FILES

;THIS PAGE/PAGE COPY IS THE FASTEST COPYING ROUTINE
; YOU CAN WRITE FOR TOPS20.
;Inputs:
;	IJFN/ OPEN'ed JFN for input file.
;	OJFN/ OPEN'ed JFN for output file.
;Some pages have been pre-loaded (PRELD0)
;Date/time info for IJFN is in RFTAD1.
;IF LOC "FSTLIN" IS NON-ZERO, IT POINTS TO AN ASCII LINE
; TO PUT INTO THE OUTPUT FILE (FOR "REPLACE" OPTION).
;WHEN COPY IS FINISHED, FILES ARE CLOSED.
;** Warning: Uses P1 **

PPCPY:	MOVE P1,NPAGES		;GET "N" PAGES FOR OUTPUT FILE
	CALL FINFRE
	MOVEM T1,STOPGS		;START OF OUTPUT PAGES
	LSH T1,9		;;MAKE REAL ADDRESS
	MOVEM T1,STOPG2		;STORE IT
	MOVE T2,NPAGES
	LSH T2,9
	ADDI T1,-1(T2)		;GET LAST WORD OF DEST BUFFER
	MOVEM T1,ENDPTR

;MAP FROM DESTINATION
DSKLUP:	HRL T1,OJFN
	HRR T1,NXTBEG		;CORRESPONDING PAGES OF SOURCE
	MOVE T2,STOPGS		; MAP INTO DESTINATION BUFFER
	HRLI T2,.FHSLF		;OUR FORK
	MOVX T3,PM%WR!PM%CNT	;WRITE, REPEAT COUNT
	HRR T3,NPAGES
	PMAP%

;SEE IF HE WANTS TO REPLACE THE FIRST 72 CHARS
	SKIPN FSTLIN
	 JRST DSKBL1		;NO, JUST COPY

;COPY A FEW WORDS, THEN CHANGE IT IN MEMORY

	HRL T1,STIPG2		;FROM HERE
	HRR T1,STOPG2		; TO HERE
	MOVEI T2,777(T1)	;FIRST PAGE
	BLT T1,(T2)		;COPY FIRST PAGE -- SHOULD HAVE NO ERRORS!

;CHANGE 1ST 72 CHARS
	MOVEI T4,^D72
	HRRZ T3,FSTLIN		;ADDRESS OF TEXT
	HRRZ T2,STOPG2		;CHANGE THIS
	HRLI T2,(POINT 7,)
	HRLI T3,(POINT 7,)
C72LUP:	ILDB T1,T3
	IDPB T1,T2
	SOJG T4,C72LUP

	HRRZ T1,STIPG2		;NOW SKIP FIRST PAGE..
	HRLI T1,1000(T1)
	HRR T1,STOPG2
	ADDI T1,1000
	MOVEM T1,BLTPTR
	SETZM FSTLIN		;COPIED FIRST LINE, CLEAR IT
	JRST DSKBLT		;START AT PAGE 1

;HERE TO TRY DSK BLT
DSKBL1:	HRL T1,STIPG2		;FROM HERE
	HRR T1,STOPG2		; TO HERE
	MOVEM T1,BLTPTR		;REMEMBER BLT POINTER
	 TRNA			;SKIP LOAD OF BLT PTR FIRST TIME
DSKBL0:	MOVE T1,BLTPTR		;GET BLT PTR
DSKBLT:	MOVE T2,ENDPTR		;GET ADDRESS OF LAST WORD OF DEST BUFFER
	BLT T1,(T2)		;COPY THE DATA
	 ERJMP DSKDIS		;PROBABLY END OF FILE, HOLE, OR QUOTA EXCEEDED
	MOVE T1,NPAGES		;# OF PAGES / BUFFER
	ADDM T1,NXTBEG		;UPDATE PAGE TO START WITH
DSKLU1:	CALL PRELD1		; PRELOAD SOME MORE PAGES
	JRST DSKLUP		;LOOP FOR NEXT PAGE GROUP

; HERE WHEN FINALLY A BLT FAILS.. (EOF, HOLE, OR QUOTA EXCEEDED)

DSKDIS:	MOVEM T1,SAVBLT		;SAVE HOW FAR WE GOT BEFORE ERROR
	CALL GLERR		;GET LAST ERROR CODE
	CAIN T1,IOX11		;NO ROOM?
	JRST NORQTA		;NO ROOM OR QUOTA EXCEEDED
	CAIE T1,ILLX01		;NOT ROOM PROBLEM, HIT HOLE OR END?
	JRST DSKDE1		;NO, UNEXPECTED PROBLEM
	LDB T1,[331100,,SAVBLT]	;GET MEM PAGE NUMBER ASSOC. WITH NONX SRC PAGE
	SUB T1,STIPGS		;GET REL. POSITION IN BUFFER
	ADD T1,NXTBEG		;GET ACTUAL FILE PAGE NUMBER
	HRL T1,IJFN		;SET UP FOR FFUFP
	FFUFP%			;FIND NEXT USED PAGE
	 ERJMP DSKMEF		;FAILED, PROBABLY END OF FILE
	HRRZ T3,T1		;COPY PAGE NUMBER
	SUB T3,NXTBEG		;SEE WHERE IN BUFFER PAGE IS
	CAML T3,NPAGES		;IN SUBSEQUENT BUFFER?
	 JRST DSKNXT		;YES
	LSH T3,9		;NO, IN THIS BUFFER. MAKE MEM OFFSET
	MOVE T1,BLTPTR		;GET ORIGINAL BLT POINTER
	ADJSP T1,(T3)		;ADJUST FOR CONTINUATION
	JRST DSKBLT		;CONTINUE THIS BUFFER

DSKNXT:	HRRZM T1,NXTBEG		;REMEMBER NEXT PAGE TO START WITH
	JRST DSKLU1		;GO START NEW BUFFER

DSKMEF:	CALL GLERR		;GET LAST ERROR CODE
	CAIE T1,FFUFX3		;NO MORE USED PAGES?
	 JRST DSKER2		;NO, UNEXPECTED ERROR
	JRST DONCPP		;DONE !

; BAD ERRORS IN COPY

DSKDE1:	TMSG <? Unexepected error: >
	CALL LSTFER
	HALTF%
	RET

NORQTA:	TMSG <?No room or quota exceeded
(Type "CONTINUE" when problem has been fixed)>
	HALTF%
	JRST DSKBL0

DSKER2:	TMSG <? FFUFP failed: >
	CALL LSTFER
	HALTF%
	RET			;RETURN FROM COPY IF "CONT"

;HERE WHEN COPY IS DONE

DONCPP:	MOVE T3,NPAGES		;GET SIZE OF BUFFER
	IORX T3,PM%CNT		;REPEAT COUNT
	HRROI T1,-1		;SAY REMOVING PAGES
	HRLI T2,.FHSLF
	HRR T2,STIPGS
	PMAP%			;UNMAP PAGES
	MOVE P1,NPAGES		;# PAGES TO CLEAR
	MOVE T1,STIPGS		;STARTING PAGE
	CALL CLRPMP		;TELL CORE ALLOCATOR THEY ARE FREE

	MOVE T3,NPAGES		;NOW UNMAP OUTPUT PAGES
	IORX T3,PM%CNT
	HRROI T1,-1
	HRLI T2,.FHSLF
	HRR T2,STOPGS
	PMAP%
	MOVE P1,NPAGES		;CLEAR SOME PAGES
	MOVE T1,STOPGS
	CALL CLRPMP		;TELL CORE ALLOCATOR THEY ARE FREE

;SET END PTR ON DESTINATION FILE

	MOVE T2,BCINP		;BYTE COUNT OF INPUT FILE
	HRRZ T1,OJFN
	SFPTR%			;SET FILE PTR
	 ERJMP SFPER1		;SFPTR FAILED
	HRLI T1,.FBSIZ		;SET EOF PTR IN FILE (CLOSF DOES NOT WHEN
	MOVE T3,T2		;NO SEQUENTIAL OUTPUT HAS BEEN DONE)
	SETO T2,
	CHFDB%
	 ERJMP [JSERR
		HALTF%
		RET]

;SET BYTE SIZE OF DEST FILE
; (CLOSF DOES NOT SET IT WHEN NO SEQ OUTPUT HAS BEEN DONE)

	HRLI T1,.FBBYV
	SETZ T3,
	MOVE T2,BSINP		;BYTE SIZE OF INPUT FILE
	DPB T2,[POINTR T3,FB%BSZ] ;BYTE SIZE
	MOVX T2,FB%BSZ
	CHFDB%
	 ERJMP [JSERR
		HALTF%
		RET]

;Set date/time of output file

	MOVE T1,OJFN
	MOVEI T2,RFTAD1		;From input file info
	MOVEI T3,2
	SFTAD%

;CLOSE FILES

	HRRZ T1,OJFN
	TXO T1,CO%NRJ		;DON'T RELEASE JFN
	CLOSF%
	 ERJMP CLSFE1
	HRRZ T1,IJFN
	TXO T1,CO%NRJ		;DON'T RELEASE JFN
	CLOSF%
	 ERJMP CLSFE2
	RET			;DONE, RETURN

;HERE IF SFPTR FAILS - CAN'T SET SIZE OF OUTPUT FILE
SFPER1:	TMSG <? SFPTR failed: >
	CALL LSTFER
	HALTF%
	RET

;CLOSF FAILURES
CLSFE1:	TMSG <?Can't close output file: >
	CALL LSTFER
	HALTF%
	RET

CLSFE2:	TMSG <?Can't close input file: >
	CALL LSTFER
	HALTF%
	RET

SUBTTL CHKNUD - CHECK UID LINE IN NEW FILE AND SET FLAGS

;MAY SET FLAGS F.NUD AND/OR F.72C

CHKNUD:	HRRZ P1,STIPG2		;START OF FILE
	HRLI P1,(POINT 7,)	;POINTER TO "FILE" STRING
	ILDB T1,P1		;FIRST CHAR
	CAIE T1,";"
	CAIN T1,"!"
	 CAIA
	RET			;NO UID, RETURN

	MOVE T2,[POINT 7,[ASCIZ/ UPD ID= /]] ;THIS MUST BE NEXT
	CALL CMPSTR		;COMPARE STRINGS
	 RET			;NO MATCH, NO UID
	TXO F,F.NUD		;FOUND UID LINE
	MOVE T1,P1		;READY TO READ THE UID NUMBER
	MOVEI T3,^D10		;READ DECIMAL UID
	NIN%
	 IFJER.
	  SETZ T2,
	 ENDIF.
	MOVEM T2,UID1		;SAVE

;SEE HOW LONG IT IS, SET FLAG F.72C IF 72 CHARS EXACTLY (BEFORE CRLF)

	HRRZ P1,STIPG2		;RESET POINTER
	HRLI P1,(POINT 7,)
	SETZ T4,		;CHAR COUNT
CHKNU1:	ILDB T1,P1		;GET A CHAR
	CAIN T1,.CHCRT		;CARRIAGE RETURN?
	 JRST CHKNU2		;YES, SEE IF 72 CHARS BEFORE IT
	AOJ T4,			;ANOTHER ONE
	CAIG T4,^D72
	 JRST CHKNU1		;KEEP LOOKING
	RET			; MORE THAN 72 CHARS
CHKNU2:	CAIN T4,^D72		;EXACTLY 72?
	TXO F,F.72C		;YES, SET FLAG
	RET			;AND RETURN

SUBTTL BLDNUI - ROUTINE TO BUILD A NEW UID LINE

;THIS ROUTINE GETS THE NEXT UID NUMBER AND PUTS IT IN THE
; UID TEXT. THE TEXT IS STORED IN "UIDTXT".  IT PADS SPACES
; ON THE END TO GET TO 72 CHARS.

BLDNUI:	MOVE T1,[ASCIZ/     /]	;5 SPACES
	SKIPN SWRUID		;REPLACING UID LINES?
	SETZ T1,		;NO, USE NULL INSTEAD
	MOVEM T1,UIDTXT		;FILL UIDTXT UP WITH SPACES
	MOVE T1,[UIDTXT,,UIDTXT+1]
	BLT T1,UIDTXT+LUIDTX-1
	MOVE P1,[POINT 7,UIDTXT] ;P1:= PTR TO OUTPUT TEXT

;GET WHICH COMMENT CHARACTER TO USE

	MOVE T2,EXTNUM		;WHICH EXTENSION
	HLRZ T1,EXTLST(T2)	;GET THE CHAR
	IDPB T1,P1		;STORE FIRST CHAR

;INITIAL STRING IS "UPD ID= "

	MOVE T3,[POINT 7,[ASCIZ/ UPD ID= /]]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

;GO GET A UID

	PUSH P,P1
	CALL ALUUID
	POP P,T1		;GET STRING POINTER IN T1
	MOVE T2,NEWUID		; GET UID NUMBER TO PUT IN STRING
	MOVEI T3,^D10		;RADIX 10
	NOUT%
	 ERCAL IMPERR		;ALU OR MONITOR BUG

	MOVE P1,T1		;COPY UPDATED STRING PTR

	SKIPE SWRUID		;REPLACING UID LINES?
	JRST BLDNU1		;YES, DIFFERENT FORMAT
	MOVE T3,[POINT 7,[ASCIZ/, /]]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

	MOVE T1,P1		;OUTPUT TO END OF STRING
	HRRZ T2,OJFN
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%			;OUTPUT FULL FILE NAME
	HRROI T2,[ASCIZ /,  /]
	SETZ T3,
	SOUT
	SETO T2,		;CURRENT DATE/TIME
	SETZ T3,		;STANDARD FORMAT
	ODTIM%
	 ERJMP MAZTME
	MOVEM T1,P1		;UPDATE STRING PTR
	JRST BLDNU2		;CONTINUE WITH LINE

BLDNU1:	MOVE T3,[POINT 7,[ASCIZ/ on /]]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

	MOVE T1,P1		;OUTPUT TO END OF STRING
	SETO T2,		;CURRENT DATE/TIME
	MOVX T3,OT%SLA+OT%NMN+OT%SCL+OT%DAM+OT%NTM ;DATE WITH SLASHES, NO TIME
	ODTIM%
	 ERJMP MAZTME
	MOVEM T1,P1
	MOVE T3,[POINT 7,[ASCIZ/ at /]]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

	CALL GTTIM		;READ THE TIME INTO HLDTM1
	 RET			;ERROR, RETURN

	MOVE T3,[POINT 7,HLDTM1]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

BLDNU2:	MOVE T3,[POINT 7,[ASCIZ/ by /]]
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

	MOVE T3,[POINT 7,USRNAM] ;COPY USER NAME
	CALL CPT3P1		;COPY FROM T3 TO P1 TILL NULL

	AOS (P)			;ALL OK, SKIP RETURN
	RET			;RETURN

SUBTTL OUT1ST - WRITE 1ST LINE (UID) TO OUTPUT FILE

;THIS IS DONE IN BYTE MODE I/O
;ALWAYS RETURNS .+1

OUT1ST:	MOVE T1,OJFN		;WRITE TO HERE
	MOVE T2,[POINT 7,UIDTXT] ;NEW UID TEXT
	MOVNI T3,^D72		;WRITE 72 BYTES
	SKIPN SWRUID		;IF NOT REPLACING UID LINES
	SETZ T3,		;THEN JUST WRITE TO NULL
	SOUT%
	 ERJMP OUT1ER		;FAILED-- GO SEE WHY
	HRROI T2,CRLF
	SETZ T3,
	SOUT%
	 ERJMP OUT1ER
	RET			;RETURN

OUT1ER:	CALL GLERR		;GET LAST ERROR CODE
	CAIN T1,IOX11		;QUOTA EXCEEDED
	 JRST OUT1QE		;YES
	TMSG <? Can't write 1st line of output file: >
	CALL LSTFER		;SAY WHY
	HALTF%
	RET			;RETURN IF CONTINUE

OUT1QE:	TMSG <?Quota exceeded or disk full
(Please fix the problem and type "continue")>
	HALTF%
	JRST OUT1ST		;START ROUTINE AGAIN

SUBTTL GETCD - GET CONNECTED DIRECTORY STRING AND PUT IN "CD"

GETCD:	SETO T1,		;-1 FOR CURRENT JOB
	MOVE T2,[-1,,T4]	;GET CONNECTED DIRECTORY NUM IN T4
	MOVEI T3,.JIDNO
	GETJI%
	 ERJMP GETCDE		;?FAILED

	MOVE T1,[POINT 7,CD]	;PUT IN "CD"
	MOVE T2,T4
	DIRST%
	 JFCL			;ALL ERRORS SHOULD NEVER HAPPEN

;MAKE SURE HE IS NOT CONNECTED TO ANY OF THE LIBRARIES
; IF HE IS, MAKE HIM FIX IT AND TYPE "CONTINUE"
	MOVSI P1,-NMLIBS	;AOBJN PTR TO LIBRARIES
GETC1A:	HRRZ T2,LIBLST(P1)	;POINTER TO ASCIZ <LIB>
	HRLI T2,(POINT 7,)	;MAKE A REAL B.P.
	MOVE T1,[POINT 7,CD]	;POINT TO THIS DIRECTORY NAME
GETCD2:	ILDB T3,T1
	ILDB T4,T2		;GET CHAR FROM EACH
	JUMPE T3,GETCD3		;END OF CONNECTED DIRECTORY STRING
	CAIN T3,(T4)		;STILL MATCH?
	 JRST GETCD2		;YES
GETCDO:	AOBJN P1,GETC1A		;LOOP FOR ALL LIBRARIES
	RET			;RETURN, ALL DONE

GETCD3:	JUMPN T4,GETCDO		;NO MATCH, OK

;CONNECTED DIRECTORY STRING MATCHES A LIBRARY DIRECTORY STRING
;	DON'T ALLOW THIS!


;GETCD ROUTINE (CON'T)
	TMSG <?You cannot be connected to >
	TYPE CD			;TYPE THE CONNECTED DIRECTORY NAME
	TMSG < - it is a library
[Please CONNECT somewhere else and type CONTINUE or START]
>
	HALTF%
	JRST GETCD		;TRY AGAIN IF HE CONTINUES

GETCDE:	TMSG <?Can't get your connected directory name: >
	CALL LSTFER
	HALTF%
	JRST GETCD		;TRY AGAIN

SUBTTL CHKRME - SEE IF FILE IS RESERVED BY ME.

;WE HAVE FOUND A MAZ FILE AND ITS JFN IS NOW IN "MAZJFN".
; THIS ROUTINE READS IT AND CHECKS TO MAKE SURE IT SAYS
; THE FILE WAS RESERVED BY ME.
;IF THERE IS AN ERROR, IT RELEASES THE JFN AND RETURNS
; TO .+1.
;IF EVERYTHING IS OK, IT CLOSES THE FILE AND RETURNS TO .+2.


;OPEN FOR READING

CHKRME:	TDZA T1,T1		;FLAG CHECK RESERVATION
CHKFME:	SETO T1,		;FLAG CHECK FREEZE
	SAVEAC <P1>
	TRVAR <CHKMEF>
	MOVEM T1,CHKMEF		;SAVE FLAG
	HRRZ T1,MAZJFN
	MOVX T2,OF%RD+7B5
	OPENF%
	 ERJMP CHKRE1		;?CAN'T OPEN FOR READING

;READ FIRST LINE INTO A BUFFER

CHKRM1:	SETZM MAZBUF		;CLEAR BUFFER
	MOVE T1,[MAZBUF,,MAZBUF+1]
	BLT T1,MAZBUF+.MAZLN-1

	HRRZ T1,MAZJFN		;FROM HERE
	MOVE T2,[POINT 7,MAZBUF] ;TO HERE
	MOVEI T3,LINLEN		;80 CHARS MAX
	MOVEI T4,.CHLFD		;TERMINATE WITH A LINE FEED
	SIN%
	 IFJE. (R)
	  CAIE T1,IOX4		;END OF FILE REACHED?
	  JRST CHKRE2		;NO, UNEXPECTED ERROR
	 ENDIF.

;CLOSE BUT DON'T RELEASE JFN

CHKRM2:	HRRZ T1,MAZJFN
	TXO T1,CO%NRJ		;DON'T RELEASE JFN
	CLOSF%
	 ERJMP CHKRE3		;OOPS.. CAN'T


;NOW PARSE THE LINE TO SEE IF IT WAS RESERVED BY ME

	MOVE P1,[POINT 7,MAZBUF] ;POINT TO LINE
	MOVE T2,[POINT 7,[ASCIZ/! Reserved by /]]
	SKIPE CHKMEF		;WHICH FLAVOR?
	MOVE T2,[POINT 7,[ASCIZ /! Frozen by /]]
	CALL CMPSTR		;CHECK MAZ STRING, UPDATE P1
	 JRST BADFMT		;DOESN'T MATCH, BAD FORMAT
	MOVEM P1,SAVNSP		;SAVE NAM: STRING PTR

;FALL

;READ "<NAM>" AND CHECK TO SEE IF IT'S ME.
	MOVE T2,[POINT 7,HNBUF]	;PLACE TO HOLD NAME STRING:
CHKRM3:	ILDB T1,P1		;GET CHAR FROM MAZ FILE
	JUMPE T1,CHKRE4		; ?SHOULDN'T FIND A NULL!
	IDPB T1,T2		;STORE CHAR
	CAIE T1," "		;WAS IT A SPACE?
	 JRST CHKRM3		;NO, LOOP
	SETZ T1,		;STORE NULL TO END STRING
	DPB T1,T2

;CHECK TO SEE IF ME

	MOVE T3,[POINT 7,USRNAM] ;BYTE PTR TO USER NAME STRING
	MOVE T1,[POINT 7,HNBUF]	;BYTE PTR TO MAZ STRING
CHKRM4:	ILDB T2,T1
	ILDB T4,T3
	JUMPE T2,[JUMPN T4,NOTRME ;NOT RESERVED BY ME!
		JRST RSVME]	;ELSE IS RESERVED BY ME
	CAIN T2,(T4)
	 JRST CHKRM4		;ALL RIGHT SO FAR

NOTRME:	TXNE F,F.SUSR		;MESSAGE WANTED HERE?
	IFSKP.
	  MOVEI T1,"?"
	  DPB T1,[POINT 7,MAZBUF,6] ;MAKE FIRST CHAR ?
	  TYPE MAZBUF		;?Reserved by..
	ENDIF.
	HRRZ T1,MAZJFN
	RLJFN%			;RELEASE MAZ FILE JFN
	 ERJMP .+1
	RET			;RETURN

;FILE WAS RESERVED BY ME -- READ IN DIRECTORY NAME WHERE IT IS

RSVME:	TXNN F,F.SUSR		;JUST CHECKING STATUS?
	SKIPE CHKMEF		;CHECKING FREEZE?
	RETSKP			;YES, DONE
	MOVE T2,[POINT 7,[ASCIZ/at /]]
	CALL CMPSTR		;MAKE SURE STRINGS MATCH
	 JRST BADFMT		;? FILE IS WRONG FORMAT
	MOVEM P1,SAVNSP		;SAVE POINTER INCASE ERRORS
	MOVE T2,[POINT 7,RDIR]
RSVME1:	ILDB T1,P1		;GET CHAR FROM MAZ FILE
	JUMPE T1,CHKRE4		;GO COMPLAIN
	IDPB T1,T2		;STORE CHAR
	CAIE T1,">"		;WAS THAT A CLOSING BRACKET?
	 JRST RSVME1		;NO, LOOP
	SETZ T1,		;NULL TO END STRING
	IDPB T1,T2
	AOS (P)			;SKIP RETURN
	RET


; ERRORS IN CHKRME ROUTINE

CHKRE1:	TMSG <?OPENF failed for MAZ file: >
	CALL LSTFER
	HALTF%
	JRST CHKRME		;TRY OPENF AGAIN

CHKRE2:	TMSG <? Can't read first line of MAZ file: >
	CALL LSTFER
	HALTF%
	JRST CHKRM1		;TRY AGAIN IF CONTINUE

CHKRE3:	TMSG <?CLOSF failed for MAZ file: >
	CALL LSTFER
	HALTF%
	JRST CHKRM2		;TRY AGAIN IF CONTINUE

BADFMT:	TMSG <?Bad format for MAZ file
>
	HRRZ T1,MAZJFN
	RLJFN%			;RELEASE JFN
	 ERJMP .+1
	RET			;RETURN .+1

CHKRE4:	TMSG <? Can't read name string in MAZ file, it is: >
	MOVE T1,SAVNSP		;SAVED NAME STRING PTR
	PSOUT%			;TYPE REST OF LINE
	HALTF%
	RET

	ENDTV.

SUBTTL CMPSTR - COMPARE STRING TO FILE TEXT

;ARGS:
;	P1/ POINTER TO FILE TEXT
;	T2/ POINTER TO STRING TO MATCH

;IF NO MATCH, POPJ
; ELSE SKIP WITH P1 UPDATED

CMPSTR:	ILDB T3,T2		;GET STRING MATCH CHAR
	JUMPE T3,RSKP		;MATCH IF MATCH STRING ENDED
	ILDB T1,P1		;GET MAZ CHAR
	JUMPE T1,RTN		;NO MATCH IF MAZ STRING ENDED
	CAIN T1,(T3)		;ALL RIGHT SO FAR?
	 JRST CMPSTR		;YES, KEEP GOING
	RET			;NO MATCH, POPJ
	JRST CMPSTR		;GO ON TO NEXT CHAR

SUBTTL CHKCNN - SEE IF CONNECTED DIRECTORY IS WHERE FILE IS

;THIS ROUTINE IS CALLED BY "REPLACE" TO CHECK IF THE CONNECTED
; DIRECTORY IS THE SAME ONE THAT THE FILE WILL BE REPLACED FROM.
; If not, ask the user whether he wants the file on his connected
;directory to be the replacement file. If not, F.SPCR is set.
;
;INPUT:	CD/ CONNECTED DIRECTORY
;	RDIR/ RESERVED DIRECTORY
;RETURNS: .+1  AFTER THE COMMAND IS CONFIRMED

CHKCNN:	MOVE T1,[POINT 7,CD]
	MOVE T2,[POINT 7,RDIR]
CHKCN0:	ILDB T3,T1		;GET CHAR FROM CD
	ILDB T4,T2		;GET CHAR FROM RDIR
	JUMPE T3,CHKCN1		;END OF CD
	CAIN T3,(T4)		;STILL MATCH?
	 JRST CHKCN0		;YES, LOOP 

;NO MATCH, HAVE TO CONFIRM THIS

CHKCNC:	TMSG <% File was reserved on >
	TYPE RDIR
	TMSG <, but you are now connected to >
	TYPE CD
	TMSG <.
Do you want to replace from the connected directory? >
	CALL YESNO
	 TXO F,F.SPCR		;No, say special filespec
	RET			;Yes, continue

CHKCN1:	JUMPN T4,CHKCNC		;NO MATCH
	RET			;MATCHES, OK

SUBTTL SETMAB - SET JFNS FOR MAB FILE, IFILE, OFILE

;ERRORS RETURN TO .+1 WITH ALL JFN'S RELEASED
; RETURNS .+2 IF ALL OK WITH NEW OUTPUT FILE JFN IN OJFN

SETMAB:	HRRZ T2,GTFJFN		;JFN OF RESERVED FILE
	HRROI T1,RETJNM		; RETURN STRING HERE
	MOVX T3,1B2+1B5+1B8+1B11+JS%PAF ;RETURN DEV:<DIRECTORY>NAME.EXT
	JFNS%

	SKIPN SWBAKF		;MAKING BACKUP FILES?
	JRST SETMB1		;NO
	HRRZ T2,GTFJFN
	HRROI T1,MABJNM		; GET NAME OF BAK FILE
	MOVX T3,1B2+1B5+1B8+JS%PAF ;DEV:<DIRECTORY>NAME
	JFNS%

;TACK ON EXT
	MOVEI T2,"."
	IDPB T2,T1
	HRRZ T2,EXTNUM		;WHICH EXTENSION NUMBER
	HRRZ T3,EXBLST(T2)	;MAKE T3 POINT TO IT
	HRLI T3,(POINT 7,)
DORN1:	ILDB T2,T3		;GET A CHAR
	IDPB T2,T1		;STASH IN NAME
	JUMPN T2,DORN1		;KEEP GOING TILL NULL

;GET A JFN FOR IT
DORN2:	MOVX T1,GJ%SHT+GJ%FOU
	MOVE T2,[POINT 7,MABJNM]
	GTJFN%
	 ERJMP DORNE2		;?SHOULDN'T FAIL
	MOVEM T1,MABJFN

;DO GTJFN TO WRITE A NEW ONE

SETMB1:	MOVX T1,GJ%SHT+GJ%FOU
	MOVE T2,[POINT 7,RETJNM]
	GTJFN%
	 ERJMP DORNE4		;? DARN, CAN'T.
	MOVEM T1,OJFN		;THAT BECOMES THE "OUTPUT FILE" JFN

	AOS (P)			;RETURN OK
	RET


;ERRORS IN "SETMAB" ROUTINE

DORNE2:	TMSG <?GTJFN failed for MAB file: >
	CALL LSTFER
	HALTF%
	JRST DORN2		;TRY IT AGAIN

DORNE4:	TMSG <?GTJFN failed for new output file: >
	CALL LSTFER
	HALTF%
	RET			;RETURN BAD

SUBTTL DORNAM - RENAME OLD FILE TO MAB

DORNAM:	SKIPN SWBAKF		;MAKING BACKUP FILES?
	JRST DORNA1		;NO
;RENAME IT
	HRRZ T1,GTFJFN		;SOURCE
	HRRZ T2,MABJFN		;DEST.
	RNAMF%			;RENAME IT
	 ERJMP DORNE3		;? CANT, GO COMPLAIN
DORNA1:	AOS (P)
	RET

DORNE3:	TMSG <?RNAMF failed: >
	CALL LSTFER
	HALTF%
	RET			;ERROR


SUBTTL ROUTINE TO PARSE "WHY" TEXT
;CALL:	CALL PRSWHY
;	<RETURNS HERE WITH TEXT IN WHYTXT>

PRSWHY:	MOVE T1,[POINT 7,[ASCIZ/(Why?) /]]
	CALL PR2SET		;SETUP 2ND PARSE
	MOVEI T1,CM2BLK		;USING THIS PARSE BLOCK NOW
	MOVEI T2,[FLDDB. (.CMTXT,CM%SDH,,<One-line comment for FILUPD.HST>)]
	CALL COMMND		;PARSE IT

; COPY ANSWER TO "WHYTXT" - IF NO ANSWER GIVEN, ASK AGAIN

	MOVE T3,[POINT 7,ATM2BF] ;FROM HERE
	MOVE T2,[POINT 7,WHYTXT] ;TO HERE
	ILDB T1,T3		;GET 1ST CHAR
	JUMPE T1,PRSWHY		;GO ASK AGAIN IF NOTHING TYPED
	IDPB T1,T2		;SOMETHING, STORE 1ST CHAR
PRSWH1:	ILDB T1,T3
	IDPB T1,T2
	JUMPN T1,PRSWH1		;LOOP IF MORE CHARS
	MOVEI T1,.CHCRT		;APPEND CRLF
	DPB T1,T2
	MOVEI T1,.CHLFD
	IDPB T1,T2
	SETZ T1,
	IDPB T1,T2		;AND END WITH NULL
	RET

SUBTTL COMMON ROUTINES USED BY COMMAND SCANNERS

;SETUP FOR 2ND COMMAND PARSE
;CALL:	T1/ POINTER TO CONTROL-R BUFFER
;	CALL PR2SET
;	<RETURNS HERE>

PR2SET:	SKIPN T1		;ANY BP GIVEN?
	HRROI T1,[0]		;NO, GET A NULL ONE
	MOVEM T1,CM2BLK+.CMRTY	;SETUP CONTROL-R BUFFER
	POP P,T3		;GET PUSHDOWN PTR THE WAY IT SHOULD BE
	MOVEM P,CM2P		;REMEMBER IT
	PUSH P,T3		;RESTORE P
	HRRZM T3,PR2STA		;SAVE ADDR AFTER THIS PUSHJ
	MOVEI T1,CM2BLK		;INITIALIZE
	MOVEI T2,[FLDDB. (.CMINI)]
	COMND%			;DO IT
	RET			;RETURN

;HERE IF A REPARSE IS NEEDED FOR CM2 FUNCTIONS

NEWPR2:	MOVE P,CM2P		;RESTORE PDL
	JRST @PR2STA		;START AGAIN AT THE RIGHT ADDRESS

;read a tty line
ITTLIN:	MOVEI T1,TXTIBL		;USE TEXTI BLOCK
	MOVE T2,[POINT 7,TLINE]	;BUFFER POINTER
	MOVEM T2,.RDDBP(T1)	;STORE IT
	MOVEI T2,TXTLEN		;SIZE
	MOVEM T2,.RDDBC(T1)	;STORE THAT
	MOVX T2,RD%JFN!RD%BEL	;BREAK ON END OF TTY LINE
	MOVEM T2,.RDFLG(T1)	;STORE FLAGS
	TEXTI%			;DO TEXTI
	 ERJMP [JSERR
		RET]
	AOS (P)			;GOOD RETURN
RTN:	RET			;RETURN OK

SUBTTL COMMAND ERRORS

LOSE:	TMSG <
? >				;TYPE PRELIMINARY ERROR TEXT
	CALL LSTFER		;TYPE LAST ERROR IN THIS FORK

LOSFIN:	TYPE CRLF		;TYPE FINAL STRING
ERESET:	MOVEI T1,.PRIIN		;GET READY
	CFIBF%			;CLEAR INPUT BUFFER
	MOVE P,[IOWD PDLSIZ,PDL] ;RESET STACK
	JRST NEWCMD		;AND GO GET ANOTHER COMMAND

;TYPE LAST ERROR IN THIS FORK

LSTFER:	MOVEI T1,.PRIOU		;OUTPUT TO TERMINAL
	HRLOI T2,.FHSLF		;LAST ERROR IN THIS FORK
	SETZ T3,		;ALL OF THE TEXT
	ERSTR%
	 JFCL
	  JFCL
	RET

;GET LAST ERROR IN THIS FORK

GLERR:	MOVEI T1,.FHSLF
	GETER%
	HRRZ T1,T2		;Error code only
	RET

;LSTFER + CRLF

LSTFRC:	CALL LSTFER
	TMSG <
>
	RET

;UNEXPECTED FATAL ERROR

FATAL:	TMSG <
?Unexpected error at >
	MOVE T2,0(P)		;PC FROM ERCAL
	MOVEI T1,.PRIOU
	MOVEI T3,^D8
	NOUT%
	 ERJMPS .+1
	TMSG <
?>
	CALL LSTFRC		;ERROR MSG
	HALTF
	JRST ST1		;IF CONTINUED

SUBTTL COMMAND JSYS SUBROUTINES

NOISE:	HRROM T2,NOIBLK+.CMDAT	;SAVE AS DATA
	MOVEI T2,NOIBLK		;POINT TO BLOCK
	JRST COMMND		;AND GO TO COMND JSYS

CONFRM:	MOVEI T2,[FLDDB. (.CMCFM)] ;GET CONFIRM FUNCTION
COMMND:	COMND%			;PARSE THE FUNCTION
	 ERJMP LOSE		;ERROR, GO COMPLAIN
	TXNE T1,CM%NOP		;DID IT PARSE?
	 JRST LOSE		;NO, COMPLAIN
	RET			;YES, RETURN SUCCESSFULLY

NOIBLK:	FLDDB. (.CMNOI)		;BLOCK FOR NOISE FUNCTION

SUBTTL BYTWRT - ROUTINE TO COPY FILE WITH BYTE I/O

;IJFN AND OJFN FILES ARE OPEN
; AFTER THIS ROUTINE COPIES EVERYTHING, IT CLOSES BOTH FILES
; BUT LEAVES THE JFNS ASSIGNED.
BYTWRT:	MOVEI P1,1		;GET A PAGE FOR SIN/SOUT'S
	CALL FINFRE
	MOVEM T1,STIPGS
	LSH T1,^D9
	MOVEM T1,STIPG2

RWSLUP:	MOVE T1,IJFN		;READ FROM HERE
	HRR T2,STIPG2		;TO HERE
	HRLI T2,(POINT 7,)
	MOVNI T3,^D512*5	; READ WHOLE PAGE IF WE CAN
	SIN%
	 ERJMP LNDON1		;ERROR READING.. PROBABLY EOF
RWSLP1:	MOVE T1,OJFN
	HRR T2,STIPG2
	HRLI T2,(POINT 7,)
	MOVNI T3,^D512*5	;NOW WRITE THE WHOLE PAGE BACK OUT
	SOUT%
	 ERJMP LNDON2		;ERROR WRITING.. PROBABLY NO ROOM
	JRST RWSLUP		;READ/WRITE SLOW LOOP

LNDON1:	MOVE P2,T3		;SAVE BYTE COUNT
	CALL GLERR		;GET LAST ERROR CODE
	CAIN T1,IOX4		;EOF?
	 JRST BYWEOF		;YES
	TMSG <? COPY failure reading: >
	CALL LSTFER
	HALTF%
	RET

;HERE WHEN WE GET TO EOF
BYWEOF:	MOVNI T3,^D512*5	;COMPUTE BYTE COUNT
	SUB T3,P2
	MOVE T1,OJFN
	HRRO T2,STIPG2
	SOUT%			;WRITE LAST PART
	 ERJMP LNDON3		;ERRORS...

;DONE!
	MOVE T1,OJFN		;CLOSE OUTPUT FILE
	TXO T1,CO%NRJ		;; DON'T RELEASE JFN
	CLOSF%
	 IFJER.
	  TMSG <? Couldn't close OJFN
>
	 ENDIF.
	MOVE T1,IJFN		;CLOSE INPUT FILE
	TXO T1,CO%NRJ
	CLOSF%
	 IFJER.
	  TMSG <? Couldn't close IJFN
>
	 ENDIF.
	RET			;RETURN

LNDON2:	CALL CHKQTE		;CHECK FOR QUOTA EXCEEDED
	 JRST RWSLP1		;GO TRY AGAIN
	TMSG <? Error writing file: >
	CALL LSTFER
	HALTF%
	JRST RWSLP1		;GO TRY AGAIN

LNDON3:	CALL CHKQTE		;CHECK FOR QUOTA EXCEEDED
	 JRST BYWEOF		;GO TRY AGAIN 
	TMSG <? Error writing file: >
	CALL LSTFER
	HALTF%
	JRST BYWEOF		;GO TRY AGAIN

;ROUTINE TO CHECK FOR OTHER GENERATED OUTPUT FILES AND COPY THE
;ONES CREATED AFTER THE SOURCE FILE.

CHKOF:	MOVE T2,EXTNUM		;WHICH EXTENSION?
	SKIPN T4,EXOLST(T2)	;ANY POSSIBLE OUTPUT FILES?
	 RET			;NO, JUST RETURN
	DMOVE T1,RFTAD1		;Get DATE/TIME of main source
	DMOVEM T1,RFTADS	;Save that info..

;NOW T4= AOBJN LIST TO [ASCIZ/OEXT/]
CHKOF1:	MOVEM T4,CKOFLP		;Save ptr.
	MOVE T1,[POINT 7,IFINAM] ;GET POINTER TO FILENAME STRING

;N.B.: CAN'T JUST SEARCH FOR ".",  DIRECTORY NAMES MAY CONTAIN "."

      DO.
	ILDB T2,T1		;GET CHARS FROM <DIR>FIL.EXT TEXT
	CAIE T2,76		;GET TO END ANGLE BRACKET OF DIRECTORY
	LOOP.
      ENDDO.
      DO.
	ILDB T2,T1		;NOW THE "." FOR EXTENSION
	CAIE T2,"."
	LOOP.
      ENDDO.
	HRRZ T3,(T4)		;GET ADDRESS OF ASCII OUTPUT EXT.
	HRLI T3,(POINT 7,)	;APPEND THIS EXT.
      DO.
	ILDB T2,T3
	JUMPE T2,ENDLP.
	IDPB T2,T1
	LOOP.
      ENDDO.
	SETZ T2,
	IDPB T2,T1		;NULL TO END FILENAME STRING

;DO GTJFN FOR THIS FILE, IF NOT THERE, GO ON TO NEXT

	MOVX T1,GJ%SHT!GJ%OLD
	MOVE T2,[POINT 7,IFINAM]
	GTJFN%
	 ERJMP CHKOFN		;FAILED, GO ON TO NEXT FILE
	MOVEM T1,IJFN		;SAVE INPUT JFN

;LOOK AT DATE, IF FILE IS OLDER THAN THE SOURCE, DON'T COPY IT

	MOVE T1,IJFN		;HERE'S JFN OF THE FILE
	MOVEI T2,RFTAD1		;ADDR OF ARG BLOCK
	MOVEI T3,2		;LENGTH OF ARG BLOCK
	RFTAD%			;GO GET DATE/TIME INFO
	MOVE T1,RFTAD1+.RSWRT	;TIME FILE WAS LAST WRITTEN
	CAMGE T1,RFTADS+.RSWRT	;WAS IT BEFORE THE SOURCE?
	 JRST CHKOF5		;YES, DON'T DO THE RENAME

;FILE IS NEWER THAN THE SOURCE.. COPY IT TO LIBRARY ALSO
;GET A JFN FOR OUTPUT FILE AND PUT IN "OJFN"

	MOVE T2,LIBNUM		;WHICH LIBRARY?
	HRRZ T2,LIBLST(T2)	;Get DEV:<DIR> of library
	HRLI T2,(POINT 7,)	;T2= ptr to it
	MOVE T1,[POINT 7,RETJNM] ;RETURN STRING HERE
	CALL CPYNUL
	HRRZ T2,GTFJFN		;Real source name
	MOVX T3,1B8
	JFNS%
	MOVEI T2,"."
	IDPB T2,T1
	HRRZ T2,IJFN		;Ext from this gen. output file.
	MOVX T3,1B11		;EXT
	JFNS%

	MOVX T1,GJ%SHT+GJ%FOU
	HRROI T2,RETJNM
	GTJFN%
	 ERJMP CHKOE1		;?CAN'T -- GO COMPLAIN
	MOVEM T1,OJFN		;SAVE JFN

;Tell user what we're doing a la EXEC "copy"

	TMSG < >		;Type a space
	MOVEI T1,.PRIOU		;Write to TTY:
	HRRZ T2,IJFN
	SETZ T3,
	JFNS%			;The source filespec
	TYPE TOINDI		;Look like a copy
	MOVEI T1,.PRIOU
	HRRZ T2,OJFN
	SETZ T3,
	JFNS%			;The dest filespec
	TMSG < >		;Type a space

	TXNE F,F.RCPY		;Did we copy the new source file?
	 JRST GOCPOF		;Yes, do a COPY for the new source also

GORNRL:	MOVE T1,OJFN		;Get T1= JFN of output file
	CALL SETGRC		;Set generation-retention-count
	 JRST GOCPOF		;?can't, Do a COPY instead.
	MOVE T1,IJFN		;PREPARE FOR RENAME
	MOVE T2,OJFN
	RNAMF%
	 ERJMP RNFL1		;FAILED.. GO SEE WHY

;Here when COPY or RENAME is done.
; The new file has been deleted from my area and
; IJFN has been released.

ROJFN:	MOVE T1,OJFN
	RLJFN%
	 JFCL			;NO ERROR SHOULD HAPPEN!
	TYPE <[ASCIZ/[OK]
/]>
	JRST CHKOFN		;GO ON TO NEXT OUTPUT FILE

;HERE IF RENAME FAILED

RNFL1:	CALL GLERR		;GET LAST ERROR CODE
	CAIN T1,RNAMX4
	 JRST RNFL2		;?QUOTA EXCEEDED IN DEST OF RENAME
	TMSG <
? Can't rename >
	TYPE IFINAM
	TMSG <: >
	CALL LSTFER		;TYPE THE ERROR
	HALTF%
	JRST GORNRL		;TRY AGAIN IF "CONTINUE"

RNFL2:	TYPE <[ASCIZ/
?Quota exceeded on library
[Please fix the problem and type "CONTINUE"]/]>
	HALTF%
	JRST GORNRL		;TRY IT AGAIN

;Here if we must copy the generated output file to the library
;IJFN and OJFN set up but no yet OPEN.

GOCPOF:	CALL OPENO		;Get ready to write new file
	 RET			;Errors, forget it
	CALL IOPEN		;Open file for reading
	 JRST [CALL RLOJFN	;Errors, release OJFN
		RET]		;And return
	CALL PRELD0		;Preload some pages
	CALL PPCPY		;** Copy the file **
	HRRZ T1,IJFN		;Now delete the file from my area
	MOVEI T2,0		;Keep 0 generations
	DELNF%
	 IFJER.
	  TMSG <%Can't delete >
	  TYPE IFINAM		;Type the name
	  CALL LSTFRC
	  TMSG <, continuing...
>
	 ENDIF.
	HRRZ T1,IJFN		;Throw away new object file's JFN
	RLJFN%
	 ERJMP .+1		; Error, ignore it
	JRST ROJFN		;Done with this file

;HERE IF CAN'T GTJFN OUTPUT FILE

CHKOE1:	TMSG <?Can't write output file: >
	CALL LSTFER
	TYPE CRLF
CHKOF5:	MOVE T1,IJFN
	RLJFN%			;RELEASE JFN AND CLOSE FILE
	 JFCL			;NO ERROR SHOULD HAPPEN!
CHKOFN:	MOVE T4,CKOFLP		;Get AOBJN ptr to list of extensions
	AOBJN T4,CHKOF1		;LOOP FOR ALL OUTPUT FILENAMES
	RET			;DONE, RETURN

;ROUTINE TO OUTPUT A REPLACE ENTRY TO FILUPD.HST

;CALL:	"WHY" TEXT IN "WHYTXT"
;	UID IN NEWUID

DOLOG:	CALL STLOG		;START LOG ENTRY

	MOVE T2,[POINT 7,[ASCIZ/
Replaced /]]
	CALL LOGSTR
	MOVE T1,P1
	CALL TACKLB		;LIB:
	MOVE T2,OJFN
	MOVX T3,1B8+1B11+JS%PAF	;JUST FILENAME.EXT
	JFNS%
	MOVE P1,T1

	MOVE T2,[POINT 7,[ASCIZ/

Updated file: /]]
	CALL LOGSTR
	MOVE T1,P1		;DESTINATION
	MOVE T2,OJFN		; FILE WE ARE WRITING TO
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%

	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/
Copied from: /]]
	CALL LOGSTR
	MOVE T2,[POINT 7,FROMFL]
	CALL LOGSTR

	SKIPN SWFUID		;UID IN FILE?
	 JRST DOLOG2		;NO, CAN'T PRINT UID:

	MOVE T2,[POINT 7,[ASCIZ/ UID: /]]
	CALL LOGSTR
	SKIPN T2,UID1		;ANY UID?
	 JRST DOLOG1		;NO, SAY "NONE"
	MOVE T1,P1
	MOVEI T3,^D10
	NOUT%
	 ERCAL IMPERR
	MOVE P1,T1
	JRST DOLOG2

;DOLOG ROUTINE (CONT'D)

DOLOG1:	MOVE T2,[POINT 7,[ASCIZ/NONE/]]
	CALL LOGSTR

DOLOG2:	SKIPN SWBAKF		;MAKING BACKUP FILE?
	JRST DOLOG3		;NO
	MOVE T2,[POINT 7,[ASCIZ/
Backup:	/]]
	CALL LOGSTR
	MOVE T1,P1
	MOVE T2,MABJFN
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%
	MOVE P1,T1

DOLOG3:	MOVE T2,[POINT 7,[ASCIZ/

Why:	/]]
	CALL LOGSTR
	MOVE T2,[POINT 7,WHYTXT]
	CALL LOGSTR

	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR
	SETZ T2,
	IDPB T2,P1
	CALL ALULOG		;APPEND TO LOG FILE
	RET			;RETURN


;ROUTINE TO DO A "ADD" LOG ENTRY
ADDLOG:	CALL STLOG		;START OFF THE LOG ENTRY
	MOVE T2,[POINT 7,[ASCIZ/
Added /]]
	CALL LOGSTR
	MOVE T1,P1
	CALL TACKLB		;LIB:
	MOVE T2,OJFN
	MOVX T3,1B8+1B11+JS%PAF
	JFNS%			;FILE.EXT
	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/

New file: /]]
	CALL LOGSTR
	MOVE T1,P1
	MOVE T2,OJFN
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%

	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/
Copied from: /]]
	CALL LOGSTR
	MOVE T1,P1
	MOVE T2,IJFN
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%

	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/

Why:	/]]
	CALL LOGSTR
	MOVE T2,[POINT 7,WHYTXT]
	CALL LOGSTR

	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR
	SETZ T2,
	IDPB T2,P1
	CALL ALULOG		;APPEND LOG ENTRY
	RET			;RETURN

;WRITE A DELETE LOG ENTRY

LOGDEL:	CALL STLOG		;START OFF THE LOG ENTRY
	MOVE T2,[POINT 7,[ASCIZ/
Deleted /]]
	CALL LOGSTR
	MOVE T1,P1
	CALL TACKLB		;LIB:
	MOVE T2,GTFJFN
	MOVX T3,1B8+1B11+JS%PAF
	JFNS%			;FILE.EXT
	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/

File deleted: /]]
	CALL LOGSTR
	MOVE T1,P1
	MOVE T2,GTFJFN
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%			;WHOLE FILESPEC
	MOVE P1,T1
	MOVE T2,[POINT 7,[ASCIZ/

Why:	/]]
	CALL LOGSTR

	MOVE T2,[POINT 7,WHYTXT]
	CALL LOGSTR

	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR
	SETZ T2,		;NULL TO END ENTRY
	IDPB T2,P1
	CALL ALULOG		;APPEND LOG ENTRY
	RET			;RETURN


;ROUTINE TO START OFF THE LOG ENTRY
;PUTS OUT ALU VERSION NUMBER AND UID

STLOG:	MOVE P1,[POINT 7,LOGBUF]
	MOVE T2,[POINT 7,[ASCIZ/**********

/]]
	CALL LOGSTR
	MOVE T2,[POINT 7,AVERST] ;Get ALU version number string
	CALL LOGSTR
	MOVE T2,[POINT 7,[ASCIZ/ UID: /]]
	CALL LOGSTR		;GET READY FOR UID TEXT

	MOVE T2,NEWUID
	MOVEI T3,^D10		;DECIMAL
	MOVE T1,P1
	NOUT%
	 ERCAL IMPERR
	MOVE P1,T1
	MOVEI T2,.CHTAB
	IDPB T2,P1
	CALL DTLOG		;DATE/TIME IN LOG
	MOVEI T2,.CHTAB		;ANOTHER TAB
	IDPB T2,P1		;TO SEPARATE DATE FROM NAME
	MOVE T2,[POINT 7,USRNAM] ;GET USER NAME
	CALL LOGSTR		;APPEND STRING TO LOG ENTRY
	MOVE T2,[POINT 7,CRLF]
	CALL LOGSTR
	RET

;ROUTINE TO PUT DATE/TIME IN LOG
DTLOG:	MOVE T1,P1
	SETO T2,		;CURRENT DATE/TIME
	SETZ T3,		;STANDARD FORMAT
	ODTIM%
	 ERCAL IMPERR
	MOVE P1,T1		;GET UPDATED BP
	RET

;ROUTINE LOGSTR APPEND STRING IN T2 TO P1
LOGSTR:	ILDB T1,T2
	JUMPE T1,RTN
	IDPB T1,P1
	JRST LOGSTR


;ROUTINE TO CHECK FOR QUOTA EXCEEDED ERROR
;RETURNS .+1 IF LAST ERROR WAS QUOTA EXCEEDED, AFTER HE FIXES THE PROBLEM
;RETURNS .+2 IF IT WASN'T

CHKQTE:	CALL GLERR		;GET LAST ERROR CODE
	CAMN T1,IOX11		;WAS IT QUOTA EXCEEDED?
	 JRST CHKQT1		;YES
	RETSKP

CHKQT1:	TMSG <? No room or quota exceeded
(Type "CONTINUE" after the problem has been fixed)
>
	HALTF%
	RET			;RETURN WHEN CONTINUE

; ROUTINES TO RELEASE JFNS

RLMAB:	MOVE T1,MABJFN
	RLJFN%
	 ERJMP RLMABE		;CAN'T
	RET
RLMABE:	HRROI T1,[ASCIZ/% Can't release MAB JFN: /]
	JRST RLERR		;GO SAY WHY

RLIJFN:	MOVE T1,IJFN
	RLJFN%
	 ERJMP RLIJFE
	RET
RLIJFE:	HRROI T1,[ASCIZ/% Can't release IJFN: /]
	JRST RLERR

RLOJFN:	MOVE T1,OJFN
	RLJFN%
	 ERJMP RLOJFE
	RET
RLOJFE:	HRROI T1,[ASCIZ/% Can't release OJFN: /]
	JRST RLERR

RLERR:	PSOUT%			;FIRST PART OF MESSAGE
	CALL LSTFER		;TYPE WHY
	TYPE CRLF
	RET			;RETURN OK

SUBTTL ALUUID - ALLOCATE AND RETURN A UID

ALUUID:	MOVE T1,[POINT 7,UIDNAM] ;Find out UID name
	MOVE T2,LIBNUM		;Which library are we using?
	HRRZ T2,LB2LST(T2)
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVE T2,[POINT 7,[ASCIZ/UID.TXT/]]
	CALL CPYNUL
	MOVX T1,GJ%OLD+GJ%SHT	;GET JFN FOR UID.TXT
	HRROI T2,UIDNAM
	GTJFN%
	 IFJER.

; CREATE UID.TXT SINCE IT DOESN'T EXIST

	  MOVX T1,GJ%NEW+GJ%SHT
	  HRROI T2,UIDNAM
	  GTJFN%
	   ERJMP UIDE2		;CAN'T GET JFN TO CREATE
	 ENDIF.

; NOW OPEN UID.TXT AND GENERATE NEW UID.

	MOVEM 1,UIDJFN		;SAVE JFN FOR UID.TXT
	MOVE T2,[<^D7>B5+OF%RD+OF%WR] ;OPEN THE FILE
	OPENF%
	 ERJMP UIDE3		;CAN'T OPEN IT

	SKIPE PBFPNO		;ALREADY HAVE A PAGE FOR UIDS?
	 JRST AUID.2		;YES
	MOVEI P1,1		;NO, GET ONE NOW
	CALL FINFRE
	MOVEM T1,PBFPNO		;SAVE VALUE

AUID.2:	HRLZ T1,UIDJFN		;MAP IN THE UID COUNTER PAGE
	HRRZ T2,PBFPNO
	HRLI T2,.FHSLF
	MOVX T3,PM%RD+PM%WR
	PMAP%

;GENERATE NEW UID
	MOVE T1,PBFPNO		;GENERATE NEW UID
	LSH T1,^D9
	SKIPN T2,(T1)		;ANYTHING THERE?
	 JRST AUID.3		;NO, MUST BE A BRAND NEW FILE
	HRLI T1,(POINT 7,)
	MOVEI T3,^D10		;READ DECIMAL NUMBER
	NIN%
	 ERJMP BADUID		;?NIN FAILED

;THE OLD UID IS NOW IN AC2
AUID.3:	AOJ T2,			;INCREMENT IT TO MAKE A NEW UID
	MOVEM T2,NEWUID		;AND SAVE THE NEW UID
	SETZ T4,		;COUNT # CHARS
      DO.
	IDIVI T2,^D10
	SKIPE T2
	AOJA T4,TOP.
      ENDDO.
	ADDI T4,3		;+ LAST DIGIT + CRLF

	MOVE T1,PBFPNO		;WRITE NEW UID INTO THE FILE
	LSH T1,^D9
	HRLI T1,(POINT 7,)	;GET DESTINATION DESIGNATOR
	MOVE T2,NEWUID
	MOVEI T3,^D10
	NOUT%
	 ERCAL IMPERR		;?NOTHING CAN HAPPEN!

;APPEND CRLF TO NUMBER TO MAKE USER EDITING EASIER
	MOVEI T2,.CHCRT
	IDPB T2,T1
	MOVEI T2,.CHLFD
	IDPB T2,T1

	CALL UNMAPA		;UNMAP THE FILE

;SET FILE POINTER SO OTHERS CAN EDIT IT
	MOVE T2,T4		;BYTE COUNT
	HRRZ T1,UIDJFN
	SFPTR%			;SET FILE PTR
	 ERJMP SFPER1		;?FAILED - GO COMPLAIN
	HRLI T1,.FBSIZ		;SET EOF PTR IN FILE
	MOVE T3,T2		;THE NEW VALUE IN T3
	SETO T2,		;"CHANGE ALL BITS"
	CHFDB%
	 ERCAL IMPERR
	HRLI T1,.FBBYV		;Change byte size word.
	MOVEI T2,^D7		;Set byte size to 7
	DPB T2,[POINTR T3,FB%BSZ]
	MOVX T2,FB%BSZ		;Change byte size bits
	CHFDB%
	 ERCAL IMPERR
AUID.C:	MOVE T1,UIDJFN		;CLOSE THE FILE UID.TXT
	CLOSF%
	 ERJMP UIDE4		;CAN'T

	RET			;DONE, RETURN

SUBTTL ERRORS IN ALUUID ROUTINE

;CAN'T GTJFN TO WRITE NEW UID.TXT
UIDE2:	TMSG <?ALUUID - GTJFN failed for output file UID.TXT: >
	CALL LSTFER
	HALTF%
	JRST ALUUID		;TRY AGAIN IF "CONTINUE"

;CAN'T OPENF UID.TXT

UIDE3:	TMSG <?ALUUID - OPENF failed for UID.TXT: >
	CALL LSTFER
	MOVE T1,UIDJFN
	RLJFN%			;RELEASE THE JFN
	 ERJMP .+1
	HALTF%
	JRST ALUUID		;;TRY AGAIN IF "CONTINUE"

;BAD FORMAT FOR UID

BADUID:	TMSG <?ALUUID - UID must be a decimal number, got: >
	MOVE T1,PBFPNO		;WHERE THE TEXT LIVES
	LSH T1,^D9
	HRLI T1,(POINT 7,)
	PSOUT%			;TYPE WHAT WAS THERE (GARBAGE!)

	CALL UNMAPA		;UNMAP THE FILE
	MOVE T1,UIDJFN		;CLOSE THE FILE
	CLOSF%
	 ERJMP UIDE4		;DIE IF CAN'T

	TYPE <[ASCIZ/
[Please fix /]>
	TYPE UIDNAM
	TYPE <[ASCIZ/ and type "CONTINUE"]
/]>
	HALTF%			;TO TOPS20
	JRST ALUUID		;TRY AGAIN

UNMAPA:	MOVX T1,-1
	HRRZ T2,PBFPNO		;PAGE WHERE THE UID IS KEPT
	HRLI T2,.FHSLF
	MOVX T3,0
	PMAP%
	RET			;DONE, RETURN

;CAN'T CLOSE UID.TXT

UIDE4:	TMSG <?ALUUID - CLOSF failed for UID.TXT: >
	CALL LSTFER
	HALTF%
	JRST AUID.C		;TRY CLOSF AGAIN IF CONTINUE

SUBTTL ALULOG - WRITE AN ENTRY IN THE ALU FILE UPDATE HISTORY LOG FILE

; THE TEXT OF THE ENTRY WILL BE IN "LOGBUF". IT WILL BE APPENDED TO THE
;FILE FILUPD.HST.

ALULOG:

;FIRST, IF FILUPD.HST DOESN'T EXIST, CREATE ONE.

	MOVE T1,[POINT 7,LOGNAM]
	MOVE T2,LIBNUM		;Which library?
	HRRZ T2,LB2LST(T2)	;Get place where it is
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVE T2,[POINT 7,[ASCIZ/FILUPD.HST/]]
	CALL CPYNUL

	MOVX T1,GJ%OLD+GJ%SHT
	HRROI T2,LOGNAM
	GTJFN%
	SKIPA			;FILE DOESN'T EXIST, CREATE IT
	 JRST ALG.1		;FILE EXISTS, GO PROCESS IT.

;CREATE EMPTY FILUPD.HST

ALULG0:	MOVX T1,GJ%NEW+GJ%SHT
	HRROI T2,LOGNAM
	GTJFN%
	 ERJMP ALOGE1		;CAN'T GET JFN

ALG.1:	MOVEM T1,LOGJFN		;SAVE JFN FOR THE LOG FILE
	SETZ T4,		;NOTE FIRST OPENF% ATTEMPT
ALG2:	MOVE T2,[7B5+OF%APP]	;OPEN FILE FOR APPENDING
	OPENF%
	 ERJMP ALOGE2		;CAN'T OPEN FOR APPEND
	IFG. T4
	  TYPE <[ASCIZ/ OK]
/]>
	ENDIF.

;NOW APPEND THE ENTRY

	MOVE T1,LOGJFN		;WRITE THE LOG ENTRY TO THE FILE
	HRROI T2,LOGBUF
	MOVEI T3,0
	MOVEI T4,0
	SOUT%

;NOW CLOSE THE LOG FILE.

ALULGC:	MOVE T1,LOGJFN
	CLOSF%
	 ERJMP ALOGE3		;CLOSF FAILED
	RET			;DONE, RETURN

ALOGE1:	TMSG <?GTJFN failed for new FILUPD.HST: >
	CALL LSTFER
	HALTF%
	JRST ALULG0

ALOGE2:	CALL GLERR		;GET LAST ERROR CODE
	CAIN T1,OPNX9		;BUSY?
	 JRST [	JUMPG T4,ALOG21	;JUMP IF MSG ALREADY TYPED
		TYPE <[ASCIZ/[File FILUPD.HST busy, waiting.../]>
ALOG21:		MOVEI T1,^D1000
		DISMS%
		AOJA T4,ALG2]	;TRY AGAIN
	TMSG <?OPENF% failed for FILUPD.HST: >
	CALL LSTFER
	HALTF%
	JRST ALULG0

ALOGE3:	TMSG <?CLOSF failed for FILUPD.HST: >
	CALL LSTFER
	HALTF%
	JRST ALULGC		;GO TRY AGAIN IF "CONTINUE"

SUBTTL CHECK FOR REGISTERED USER

;CALL:	CALL RGUSR
;	<RETURN HERE IF NO>
;	<HERE IF YES, INTERNAL USER # IN INTUNM>
;Checks your logged-in user number against internal list.
; If SWANYU is on (any user allowed), this routine always skips
;but does not set INTUNM.

RGUSR:	CALL RGUCHK		;CHECK
	 JRST NOTRU		;?NOT A REGISTERED USER
	JRST RSKP		;A REGISTERED USER, RETURN
NOTRU:	TMSG <? You are not a registered user.
>
	RET


;HERE IS ROUTINE TO SILENTLY CHECK FOR REGISTERED USER, AND IF SO
; PUTS USER NUMBER IN "INTUNM" AND SKIPS

RGUCHK:	SETO T1,		;-1 FOR CURRENT JOB
	MOVE T2,[-1,,P1]	;GET USER NUMBER IN P1
	MOVEI T3,.JIUNO
	GETJI%			;GET IT
	 ERJMP RGUSE1		;? FAILED

;LOOK AT ALL REGISTERED USERS AND SEE IF WE ARE ONE OF THEM
	MOVSI T4,-NMUSRS
RGUSR1:	HRRO T2,USRLST(T4)	;GET PTR TO REGISTERED USER'S NAME
	MOVX T1,RC%EMO		;EXACT MATCH ONLY
	RCUSR%			;TRANSLATE
	 ERJMP RGUSRE		;ERROR - GO SEE WHY
	TXNE T1,RC%NOM		;NO MATCH?
	 JRST RGUSR2		;RIGHT, GO ON TO NEXT
	CAMN T3,P1		;MATCH?
	 JRST RGUSR3		;YES - WE ARE A REGISTERED USER
RGUSR2:	AOBJN T4,RGUSR1		;LOOP THRU LIST
	SKIPN SWANYU		;ANY USER ALLOWED?
	 RET			;NO
	SETZM USRBIT		;UNKNOWN USER HAS NO PRIVS
	JRST RGUSR4		;CONTINUE

RGUSR3:	HLLZ T3,USRLST(T4)	;KNOWN USER, GET FLAGS
	MOVEM T3,USRBIT		;SAVE
RGUSR4:	GJINF%			;GET LOGIN USER NUM
	MOVE T2,T1
	HRROI T1,USRNAM
	DIRST%			;SAVE USER NAME STRING
	 JSHLT
	AOS (P)			;AND SKIP RETURN
	RET

RGUSE1:	TMSG <?Can't get user number: >
	CALL LSTFER
	HALTF%
	JRST RGUCHK		;TRY AGAIN IF CONTINUE

;HERE IF RCUSR FAILS TRYING TO TRANSLATE A USER NAME IN OUR LIST

RGUSRE:	CALL GLERR		;GET LAST ERROR CODE
	CAIE T1,STRX08		;INVALID USER NAME?
	 CALL IMPERR		;NO, IMPOSSIBLE ERROR
	TMSG <%Invalid user name in table: >
	TYPE <(T4)>		;TYPE IT
	JRST RGUSR2		;GO ON TO NEXT

SUBTTL SETPMP - SETUP PAGE MAP

SETPMP:	MOVE P2,[POINT 1,PAGMAP]
	SETZ T4,		;START WITH PAGE 0

;Set aside some pages for ALU itself

	MOVEI T3,LASTLC		;GET LAST USED LOC
	LSH T3,-^D9		;GET ITS PAGE NUMBER
	SETO T1,		;MARK THEM ALL AS NOT FREE
SETPM0:	IDPB T1,P2
	SOSL T3			;STOP WHEN ALL THOSE PAGES MARKED
	AOJA T4,SETPM0
	ADDI T4,1		;NOW START LOOKING AT NEXT PAGE

SETPM1:	HRLI T1,.FHSLF
	HRR T1,T4
	RPACS%
	TXNN T2,PA%PEX		;DOES THIS PAGE EXIST?
	 TDZA T1,T1		;NO, MARK AS FREE
	SETO T1,		;YES, MARK AS NOT FREE
	IDPB T1,P2
	ADDI T4,1		;GO ON TO NEXT PAGE
	CAIG T4,765		;SAVE SOME SPACE FOR DDT
	 JRST SETPM1
	SETO T1,		;MARK REST OF PAGES AS NOT FREE
SETPM2:	IDPB T1,P2
	ADDI T4,1
	CAIG T4,777
	 JRST SETPM2
	RET


SUBTTL FINFRE - FIND A CLUMP OF FREE PAGES WE CAN USE

;CALL:	MOVEI P1, # OF CONTIGUOUS PAGES WE WANT
;	CALL FINFRE
;	<RETURNS T1= NUMBER OF THE FIRST ONE>

FINFRE:	SETZ T4,		;START AT PAGE 0
	MOVE P2,[POINT 1,PAGMAP] ;POINTER TO PAGE MAP
FINFR0:
      DO.
	ILDB T2,P2		;LOOK FOR A FREE ONE
	JUMPE T2,ENDLP.
	AOJA T4,TOP.
      ENDDO.
	CAILE T4,777		;DID WE FIND ANY?
	JRST NOROOM		;NO - USED THEM ALL!

	HRRZ T1,T4		;ASSUME THIS IS IT
	HRRZ T3,P1		;COUNTDOWN
	MOVEM P2,SAVEPB		;SAVE PAGE TABLE BYTE PTR
	ADDI T4,1		;ACCOUNT FOR PAGE WE FOUND

FINFR1:	SOJLE T3,GOTEM		;GOT 'EM... MARK AS TAKEN
	ILDB T2,P2		;LOOK SOME MORE
	ADDI T4,1		;ON NEXT PAGE NOW
	CAILE T4,777
	 JRST NOROOM
	JUMPE T2,FINFR1		;STILL OK.. KEEP GOING

;This clump won't do.. try again

	JRST FINFR0

GOTEM:	MOVE P2,SAVEPB		;GET BYTE PTR AT START OF CLUMP
	SETO T2,		;SET FLAG TO -1
	DPB T2,P2		;MARK THAT PAGE
	MOVE T3,P1
      DO.
	SOJLE T3,RTN		;RETURN WHEN MARKED THEM ALL
	IDPB T2,P2
	LOOP.
      ENDDO.

NOROOM:	TMSG <? FINFRE: NOT ENOUGH FREE PAGES
>
	HALTF%
	JRST FINFRE


SUBTTL CLRPMP - CLEAR PAGE MAP & RETURN PAGES

;CLEAR PAGE MAP
;CALL:  P1/ # PAGES TO CLEAR
;	T1/ STARTING PAGE

CLRPMP:	MOVE P2,[POINT 1,PAGMAP]
	SETZ T2,		;"CLEAR" BIT
      DO.
	SOJL T1,ENDLP.		;GET TO THAT PAGE
	IBP P2
	LOOP.
      ENDDO.
      DO.
	IDPB T2,P2
	SOJG P1,TOP.
      ENDDO.
	RET

;** DEBUG **
LISTFR:	TMSG <Used pages:
>
	MOVE P2,[POINT 1,PAGMAP]
	SETZ T4,		;START AT PAGE 0
LISTF0:	ILDB T2,P2
	JUMPN T2,LISTF1		;TELL HIM NON-EMPTY
LISTF2:	ADDI T4,1
	CAILE T4,1000
	 RET
	JRST LISTF0
LISTF1:	MOVEI T1,.PRIOU
	HRRZ T2,T4		;PAGE NUMBER
	MOVEI T3,8
	NOUT%
	 ERJMP .+1
	TMSG <,>
	JRST LISTF2

SUBTTL CHECK OUT DEFAULT LIBRARY

WDFLIB:	SKIPN DFLIBW		;SKIP IF THERE IS A DEFAULT LIBRARY
	 RET			;NO, NOTHING TO CHECK

;IT MUST BE ONE OF THE KNOWN LIBRARIES

	MOVSI T4,-NMLIBS	;-# LIBS
WDFL1:	HRRZ T1,LB1LST(T4)	;Get ptr to ASCIZ/LIB:/
	HRLI T1,(POINT 7,)
	PUSH P,DFLIBW
	POP P,TEMPBP		;Save temp bp (to default lib)
WDFL2:	ILDB T2,T1		;Get char
	ILDB T3,TEMPBP		;Get char
	JUMPE T3,WDFDON		;Jump if done with default lib
	CAIN T2,(T3)		;Ok so far?
	 JRST WDFL2		;Yes, keep matching

;NO MATCH
WDFNOM:	AOBJN T4,WDFL1		;Loop for all libs
	TYPE <[ASCIZ \?DFLIB (the default library defined in ALUPRM.MAC)
is not a known library .. please fix ALUPRM.MAC and rebuild ALU

Hint: If V6: is your default library, DEFINE DFLIB,< ASCIZ /V6/ >
\]>
	HALTF%
	JRST .-1

;END OF THIS LIB
WDFDON:	CAIE T2,":"		;Better be at ":" in this library name
	 JRST WDFNOM		;No, no match

;MATCH, STORE INDEX AWAY.
	HRRZM T4,DLBIDX		;Save index for default library
	RET			;Return

SUBTTL GET ALU VERSION NUMBER STRING

;Called once-only when ALU is built to initialize AVERST.

SETAVR:	MOVE T1,[POINT 7,AVERST] ;T1 = output BP
	MOVE T2,[POINT 7,[ASCIZ/ALU %/]]
	CALL CPYNUL
	LDB T2,[POINT 6,ALUVER,11] ;Major version #
	MOVEI T3,^D8		;Output in octal
	NOUT%
	 ERCAL IMPERR		;?Nothing should happen!
	LDB T2,[POINT 6,ALUVER,17] ;Minor version #
	JUMPE T2,SETAV1		;Don't output anything if 0
	SUBI T2,1		;^D26="Z", ^D27="AA"
	IDIVI T2,^D26		;Get two letters
	JUMPE T2,SETAV0		;Don't output 1st letter if null
	MOVEI T2,100(T2)
	IDPB T2,T1		;Output it
SETAV0:	MOVEI T2,101(T3)	;Get 2nd letter
	IDPB T2,T1		;Output it
SETAV1:	HRRZ T2,ALUVER		;Get edit level
	JUMPE T2,SETAV2		;Don't output if zero
	MOVEI T3,"("
	IDPB T3,T1
	MOVEI T3,^D8		;Octal edit number
	NOUT%
	 ERCAL IMPERR
	MOVEI T3,")"
	IDPB T3,T1
SETAV2:	LDB T2,[POINT 3,ALUVER,2] ;Get "who" field
	JUMPE T2,SETAV3		;Don't output if zero
	MOVEI T3,"-"
	IDPB T3,T1		;Mark it
	MOVEI T3,^D8
	NOUT%
	 ERCAL IMPERR
	SETZ T2,		;End with null
SETAV3:	IDPB T2,T1		;Output null to end
	RET			;Done, return


SUBTTL SETUP FILCOM STRING

;SETUP STRING TO SEND TO FILCOM
;CALLED AT END OF REPLACE COMMAND, WHILE ALL JFNS ARE STILL ASSIGNED.
; THE MAC FILE IS OJFN
; THE MAB FILE IS MABJFN
; THE LIBRARY NUMBER IS IN LIBNUM
; THE UID NUMBER IS IN NEWUID

;THE FILCOM STRING IS:
;	ALU:UID=LIB:MABNAM,LIB:MACNAM

FCSTR:	MOVE T1,[POINT 7,FCTXT]
	MOVE T2,[POINT 7,[ASCIZ/ALU:/]] ;Only choice
	CALL CPYNUL		;COPY to NUL
	MOVE T2,NEWUID		;GET UID NUMBER
	MOVEI T3,^D10
	NOUT%
	 ERCAL IMPERR
	MOVEI T2,"="
	IDPB T2,T1
	CALL TACKLB		;LIB:
	MOVE T2,MABJFN		;JFN IN T2
	MOVX T3,1B8+1B11+JS%PAF
	JFNS%
	 ERCAL IMPERR
	MOVEI T2,","
	IDPB T2,T1
	CALL TACKLB		;LIB:
	MOVE T2,OJFN
	MOVX T3,1B8+1B11+JS%PAF
	JFNS%
	 ERCAL IMPERR
	MOVEI T2,0
	IDPB T2,T1
	RET			;RETURN

TACKLB:	MOVE T2,LIBNUM		;GET LIBRARY NUMBER
	HRRZ T2,LB1LST(T2)
	HRLI T2,(POINT 7,)
      DO.
	ILDB T3,T2
	JUMPE T3,ENDLP.
	IDPB T3,T1
	LOOP.
      ENDDO.
	RET

SUBTTL MISC ROUTINES

;COPY STRING TO NULL
; T1/ DESTINATION PTR
; T2/ SOURCE PTR

CPYNUL:	ILDB T3,T2		;GET SOURCE BYTE
	IDPB T3,T1		;STORE IN DEST
	JUMPN T3,CPYNUL
	DBP. T1			;BACKUP DEST OVER NUL
	RET

;SAVE AS ABOVE BUT SOURCE IN T3, DEST IN P1

CPT3P1:	ILDB T2,T3
	IDPB T2,P1
	JUMPN T2,CPT3P1
	DBP. P1			;BACKUP DEST OVER NUL
	RET

;AND AGAIN, BUT SOURCE IN T2, DEST IN T3

CPT2T3:	ILDB T1,T2
	IDPB T1,T3
	JUMPN T1,CPT2T3
	DBP. T3			;BACKUP DEST OVER NUL
	RET

;Routine to set generation-retention-count of a file.
;Call:
;	T1/ JFN of output file (another JFN will be RENAMEd to this).
;	CALL SETGRC
;	 <here if error, warning message typed>
;	<here if done>
;This must be done prior to a RENAME.
;
;  If the routine returns .+1, the program should COPY the file
;instead of RENAME'ing it.

SETGRC:	MOVEM T1,GRCJFN		;Save this a sec..
	MOVE T2,T1		;Get JFN in T2
	MOVX T1,RC%EMO		;No recognition
	RCDIR%			;Get 36-bit directory number
	 ERJMP STGRE1		;?Failed
	MOVE T1,T3		;Get directory number
	MOVEI T2,CD.LEN		;get length of CRDIR block
	MOVEM T2,GRCDBL+.CDLEN	;Store in length word of block
	MOVEI T2,GRCDBL		;Point to directory block
	GTDIR%			;Get directory parameters
	 ERJMP STGRE2		;?failed
	MOVE T4,GRCDBL+.CDRET	;Get generation-retention-count
	HRRZ T1,GRCJFN		;RH= JFN
	HRLI T1,.FBBYV
	DPB T4,[POINTR T3,FB%RET] ;Put retention-count we want in there
	MOVX T2,FB%RET		;Only change these bits
	CHFDB%			;** Change FDB of the output file **
	 ERJMP STGRE3		;?can't
	JRST RSKP		;OK, return success


;** ERRORS in SETGRC routine **

;Can't get directory number from the JFN

STGRE1:	TYPE CNTSRC		;Give warning
	CALL TCGFIL
	TMSG <RCDIR failed: >
	JRST STGREE

;Can't get directory parameters from the dir #

STGRE2:	TYPE CNTSRC
	CALL TCGFIL
	TMSG <GTDIR failed: >
	JRST STGREE

;Can't set generation-retention-count in the FDB

STGRE3:	TYPE CNTSRC
	CALL TCGFIL
	TMSG <CHFDB failed: >
;	JRST STGREE
STGREE:	CALL LSTFER
	TMSG <
; file will be copied instead of RENAME'd
>
	RET			;Return .+1 to copy

CNTSRC:	TEXT <%Can't set generation-retention-count for >

;Routine to type file name of GRCJFN

TCGFIL:	MOVEI T1,.PRIOU
	MOVE T2,GRCJFN
	SETZ T3,
	JFNS%
	TMSG <
% >
	RET

SUBTTL REDIT ROUTINES

;Routine to call REDIT
;Called when file is about to get REPLACED with COPY or RENAME.
;Input:
;	IJFN/ new source file
;	GTFJFN/ file to replace (on the library)
;	NEWUID/ UID number to use
;Call:
;	CALL CALRDT
;	<return here always>

CALRDT:	CALL IREDIT		;Initialize REDIT
	 JRST CALRD1		;?Failed, type warning
	CALL SREDIT		;Setup REDIT string
	CALLRET DREDIT		;Do REDIT and return when done


;Error initializing REDIT
CALRD1:	TMSG <% REDIT not called
>				;Clarify the situation
	RET			;Return


;Routine to initialize REDIT in a lower fork.
;Call:
;	CALL IREDIT
;	 <here if error, message typed>
;	<here if ok>

IREDIT:	SKIPE RDTFRK		;Do we have a fork handle already?
	 JRST IRDT1		;Yes

;Create a fork for REDIT

	MOVX T1,CR%CAP		;Create fork
	CFORK%
	 ERJMP CFFAI		;?Failed
	MOVEM T1,RDTFRK		;Save it's fork handle

IRDT1:	SKIPE RDTINC		;Is REDIT in core already?
	 JRST RSKP		;Yes, initialization done

;Do GTJFN and GET to read it into core

	MOVX T1,GJ%OLD
	HRROI T2,[ASCIZ/SYS:REDIT.EXE/]
	GTJFN%
	 ERJMP RDTJFL		;GTJFN failed
	HRRZ T1,T1		;RH= JFN
	PUSH P,T1		;Save JFN
	HRL T1,RDTFRK		;LH= fork handle
	GET%			;Read in a copy of REDIT
	 ERJMP RDTGFL		;?GET failed
	SETOM RDTINC		;Got it, set flag
	POP P,(P)		;Throw away JFN info, don't need it.
	JRST RSKP		;And return success

;CREATE-A-FORK failed.

CFFAI:	TMSG <?CFORK failed: >
	CALLRET LSTFRC		;Type why and give single return

;GTJFN failed for SYS:REDIT.EXE

RDTJFL:	TMSG <?Can't GTJFN SYS:REDIT.EXE: >
	CALLRET LSTFRC		;Type why and give single return

;GET failed

RDTGFL:	TMSG <?Can't GET SYS:REDIT.EXE: >
	CALL LSTFRC		;Type why and CRLF
	POP P,T1		;Release JFN
	RLJFN%
	 ERJMP .+1		;Error, don't worry.
	RET			;Return .+1


;Routine to setup REDIT string
;Called when file is about to get REPLACED with COPY or RENAME.
;Input:
;	IJFN/ new source file
;	GTFJFN/ file to replace (on the library)
;	NEWUID/ UID number to use
;Call:
;	CALL SREDIT
;	<return here always>
;Output:
;	RDTTXT/ ASCIZ string to be sent to REDIT
;	ADVTXT/ ASCIZ string to advise user what is happening

SREDIT:	STKVAR <RPTR>
	MOVE T1,[POINT 7,ADVTXT] ;INIT ADVISORY TEXT
	MOVEM T1,ADVPTR
	MOVE T1,[POINT 7,RDTTXT] ;Point to text area
	MOVE T2,[POINT 7,[ASCIZ/REDIT COMPARE (NEW SOURCE FILE) /]]
	CALL CPYNUL
	MOVEM T1,RPTR		;SAVE START OF FILESPEC
	MOVE T2,IJFN		;New source file
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF ;DEV:<DIRECTORY>FILE.EXT
	JFNS%
	MOVE T2,RPTR
	HRROI T3,[ASCIZ /[Compare:       /]
	CALL APPAVT		;BUILD ADVISORY TEXT
	MOVE T2,[POINT 7,[ASCIZ/ (WITH FILE) /]]
	CALL CPYNUL
	MOVEM T1,RPTR
	MOVE T2,GTFJFN		;File to replace
	MOVX T3,1B2+1B5+1B8+1B11+1B14+JS%PAF
	JFNS%
	MOVE T2,RPTR
	HRROI T3,[ASCIZ /
 With:          /]
	CALL APPAVT
	MOVE T2,[POINT 7,[ASCIZ/ (CHANGES TO) /]]
	CALL CPYNUL
	MOVEM T1,RPTR
	MOVE T2,LIBNUM
	HRRZ T2,LB2LST(T2)	;Get directory to make the .DIF file in
	HRLI T2,(POINT 7,)
	CALL CPYNUL
	MOVE T2,GTFJFN
	MOVX T3,1B8		;Replaced file name only
	JFNS%
	MOVEI T2,"-"		;DASH
	IDPB T2,T1
	MOVE T2,NEWUID		;Put UID in filename string
	MOVX T3,^D10		;Decimal
	NOUT%
	 ERJMPS .+1		;No error should happen
	MOVE T2,[POINT 7,[ASCIZ/.RED/]]
	CALL CPYNUL
	MOVE T2,RPTR
	HRROI T3,[ASCIZ /
 Changes to:    /]
	CALL APPAVT
	MOVE T2,[POINT 7,[ASCIZ/
/]]
	CALL CPYNUL
	MOVE T2,T1		;NO ADDITIONAL TEXT THIS TIME
	HRROI T3,[ASCIZ /]
/]
	CALL APPAVT		;FINISH UP ADVISORY STRING
	SETZ T2,		;Null
	IDPB T2,T1
	RET			;Done, return

;APPAVT - APPEND TO ADVISORY TEXT
; T1/ END OF STRING #2
; T2/ BEGINNING OF STRING #2
; T3/ PTR TO ASCIZ STRING #1

APPAVT:	SAVEAC <T1>
	STKVAR <EPTR,BPTR>
	MOVEM T2,BPTR		;SAVE SECOND STRING FOR NOW
	MOVEM T1,EPTR		;SAVE END OF STRING
	MOVE T1,ADVPTR		;PTR TO ADVISORY TEXT
	MOVE T2,T3
	HLRZ T3,T2
	CAIN T3,-1		;DEFAULT?
	HRLI T2,(POINT 7,0)	;YES, FILL IN
	CALL CPYNUL		;COPY IT
	MOVE T2,BPTR		;NOW FOR SECOND STRING
      DO.
	CAMN T2,EPTR		;END OF FIRST STRING?
	EXIT.			;YES
	ILDB T3,T2		;NO, GET NEXT CHAR FROM IT
	IDPB T3,T1		;APPEND TO ADVISORY TEXT
	LOOP.			;DO THIS UNTIL PTRS MATCH
      OD.
	MOVEM T1,ADVPTR		;SAVE PTR HERE
	SETZ T3,
	IDPB T3,T1		;ALWAYS APPEND A NULL
	RET


;Routine to actually do the work of calling REDIT.
;Waits until REDIT is done, then returns.
;If errors happen, a warning message is typed.
;IREDIT must have successfully completed before this routine will work.
;Inputs:
;	RDTTXT/ holds ASCIZ TEXT SENT TO REDIT
;Call:
;	CALL DREDIT
;	<return here always>

DREDIT:	TYPE <[ASCIZ/[ALU: Calling REDIT]
/]>
;	TYPE RDTTXT		;TYPE THE TEXT WE ARE SENDING
	TYPE ADVTXT		;TYPE ADVISORY TEXT

;Set REDIT's RESCAN buffer.

	MOVE T1,[POINT 7,RDTTXT] ;Get ptr to text string
	RSCAN%			;Put in RESCAN buffer
	 ERJMP RSCFAI		;?Failed

;Start it up

	MOVE T1,RDTFRK		;Get fork handle
	MOVEI T2,0		;Start at primary start address
	SFRKV%			;Start it up
	 ERJMP SFRFAI		;?Failed

	MOVE T1,RDTFRK		;Get fork handle
	WFORK%			;Wait for completion

;Give warning if it didn't terminate successfully

	MOVE T1,RDTFRK
	RFSTS%			;Read fork status
	HLRZ T2,T1		;Get status
	CAIN T2,.RFHLT		;Better be just "halt'ed"
	 RET			;Ok, return

;Fork status not good.

	PUSH P,T1		;Save status
	TMSG <% Problem with REDIT-- FORK STATUS = >
	POP P,T1
	CALL TYPFSS		;Type it out symbolically
	RET			;Return

;Couldn't put text in RESCAN buffer

RSCFAI:	TMSG <?Error setting RESCAN buffer for REDIT: >
	CALL LSTFRC
	JRST RDTNTD

;Couldn't start up the fork

SFRFAI:	TMSG <?Couldn't "START" REDIT: >
	CALL LSTFRC
	JRST RDTNTD

;Here to explain what happens if an error comes up, then
; return .+1

RDTNTD:	TMSG <% REDIT not called
>
	RET			;Return


SUBTTL GENERAL-PURPOSE ROUTINES

;Routine to type a fork status symbolically from T1.
;Call:
;	T1/ results from RFSTS
;	CALL TYPFSS
;	<return here always>
;Types:
;NNNNNN,,NNNNNN<CRLF>(WHAT IT MEANS)<CRLF>

TYPFSS:	PUSH P,T1		;Save info
	MOVEI T1,.PRIOU		;Output to TTY
	HLRZ T2,(P)		;Get left half
	MOVX T3,NO%LFL+NO%ZRO+6B17+^D8 ;000003
	NOUT%
	 ERJMPS .+1
	TMSG <,,>
	MOVEI T1,.PRIOU
	HRRZ T2,(P)
	MOVX T3,NO%LFL+NO%ZRO+6B17+^D8
	NOUT%
	 ERJMPS .+1
	TYPE CRLF

;Now type what that means

	TMSG <(>
	POP P,T4		;Get into T4
	TXZN T4,RF%FRZ		;Frozen?
	IFSKP.
	  TYPE [ASCIZ /Frozen, /]
	ENDIF.
	HLRZ T1,T4		;Get status code
	CAIN T1,.RFFPT		;Forced termination?
	 JRST STSFTR		;yes
	CAILE T1,.MXSTS		;Too big?
	 SKIPA T1,[[ASCIZ/?? Unknown status ??/]]
	MOVE T1,RFSTST(T1)	;Get address OF ASCIZ status
	TYPE <(T1)>		;Type the ASCIZ
	TMSG <)>
	RET			;Return

;Forced termination

STSFTR:	TMSG <Forced termination - >
	HRRZ T1,T4		;Why?
	CAILE T1,.MXFTR
	 SKIPA T1,[[ASCIZ/?? Unknown software channel ??/]]
	MOVE T1,FTRTBL(T1)	;Get address of ASCIZ
	TYPE <(T1)>
	TMSG <)>
	RET			;Return


;STATUS values from RFSTS
RFSTST:	[ASCIZ /Runnable/]
	[ASCIZ /Dismissed for I-O/]
	[ASCIZ /Halted, voluntary termination/]
	[ASCIZ /Halted/]		;.RFFPT, just type the error
	[ASCIZ /Dismissed waiting for another process to terminate/]
	[ASCIZ /Dismissed for a specified amount of time/]
	[ASCIZ /JSYS-UUO interrupt wait/] ;.RFTRP
	[ASCIZ /ADBRK interrupt wait/] ;.RFABK
.MXSTS==.-RFSTST-1

;Values of software channels for forced termination

FTRTBL:	[ASCIZ /Software channel 0/]
	[ASCIZ /Software channel 1/]
	[ASCIZ /Software channel 2/]
	[ASCIZ /Software channel 3/]
	[ASCIZ /Software channel 4/]
	[ASCIZ /Software channel 5/]
	[ASCIZ /Arithmetic overflow/]
	[ASCIZ /Arithmetic floating point overflow/]
	[ASCIZ /Software channel 8/]
	[ASCIZ /Pushdown list overflow/]
	[ASCIZ /End of file condition/]
	[ASCIZ /Data error file condition/]
	[ASCIZ /Disk full or quota exceeded/]
	[ASCIZ /Software channel 13/]
	[ASCIZ /Software channel 14/]
	[ASCIZ /Illegal instruction/]
	[ASCIZ /Illegal memory read/]
	[ASCIZ /Illegal memory write/]
	[ASCIZ /Software channel 18/]
	[ASCIZ /Inferior process termination or forced freeze/]
	[ASCIZ /System resources exhausted/]
	[ASCIZ /Software channel 21/]
	[ASCIZ /Reference to non-existant page/]
	[ASCIZ /Software channel 23/]
	[ASCIZ /Software channel 24/]
	[ASCIZ /Software channel 25/]
	[ASCIZ /Software channel 26/]
	[ASCIZ /Software channel 27/]
	[ASCIZ /Software channel 28/]
	[ASCIZ /Software channel 29/]
	[ASCIZ /Software channel 30/]
	[ASCIZ /Software channel 31/]
	[ASCIZ /Software channel 32/]
	[ASCIZ /Software channel 33/]
	[ASCIZ /Software channel 34/]
	[ASCIZ /Software channel 35/]
.MXFTR==.-FTRTBL-1		;Maximum index value

SUBTTL LOWER/UPPERCASE CONVERSION

;Used when individually parsed fields need to be converted
; to uppercase. COMND% JSYS only lets you do this with the
; whole line.

;Input:
;	t1/ address of ASCIZ string
;	CALL CNVUPP
;	<return here always>

CNVUPP:	HRLI T1,(POINT 7,)	;Make BP
CNVUP1:	ILDB T2,T1		;Get char
	JUMPE T2,RTN		;Null ends string
	CAIL T2,"A"+40
	CAILE T2,"Z"+40
	 JRST CNVUP1		;Not lowercase
	SUBI T2,40		;Convert this character to uppercase
	DPB T2,T1		;Store back
	JRST CNVUP1		;Loop until null seen

SUBTTL TABLES OF USERS, LIBRARIES, KNOWN EXTENSIONS

E.BIT==1B0			;USER MAY DO ^E COMMANDS
DEFINE USR (A,B),<
%%BTS==0
IRPC B,<
%%BTS==%%BTS!B'.BIT
>
%%BTS+[ASCIZ \'A\]
>
USRLST:	RUSERS
NMUSRS==.-USRLST


;LIBRARIES
DEFINE LIB (A,B,C),<
[ASCIZ /A/]
>
LIBLST:	LIBS
NMLIBS==.-LIBLST

DEFINE LIB (A,B,C),<
[ASCIZ /B':/]
>
LB1LST:	LIBS

DEFINE LIB (A,B,C),<
[ASCIZ /C/]
>
LB2LST:	LIBS			;Place to put FILUPD.HST, .DIF, .SCM, UID.TXT


DEFINE EXTN(A,B,C,D,E),<
[ASCIZ /B/]
>
STEXTS:	EXTS
NMEXTS==.-STEXTS

DEFINE EXTN(A,B,C,D,E),<
XWD D,[ASCIZ /A/]
>
EXTLST:	EXTS

DEFINE EXTN(A,B,C,D,E),<
[ASCIZ /C/]
>
EXBLST:	EXTS			;BACKUP EXTS


DEFINE EXTN(A,B,C,D,E),<
...X==0				;# OUTPUT EXTS
IRP E,<
...X==...X+1			;COUNT # OUTPUT EXTS
>
IFE ...X,<EXP 0>		;IF NO OUTPUT EXTS
IFN ...X,<
	-<...X>,,[
IRP E,<
[ASCIZ /E/]
>;END IRP E
]
>;END IFN ...X
>;END DEFINE EXTN

EXOLST:	EXTS			;GENERATED OUTPUT EXTS

SUBDIR:	SUBDNS			;SUBDIRECTORY NAME STRING

;DEFINE DEFAULT LIBRARY IF GIVEN
DFLIBW:
IFNDEF DFLIB,<
EXP 0				;NO DEFAULT LIBRARY
>
IFDEF DFLIB,<
POINT 7,[DFLIB]
>

SUBTTL STORAGE
;PRESET SECTION

CMDBLK:	NEWPAR			;ADDRESS OF REPARSE ROUTINE
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	-1,,[ASCIZ /ALU>/]	;CONTROL-R BUFFER
	-1,,TXTBUF		;POINTER TO TEXT BUFFER
	-1,,TXTBUF		;POINTER TO CURRENT POSITION
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	0			;NUMBER OF UNPARSED CHARACTERS
	-1,,ATMBUF		;POINTER TO ATOM BUFFER
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	EXP JFNBLK		;POINTER TO JFN BLOCK

;2ND COMMAND JSYS BLOCK (FOR PARSING RANDOM STRINGS)
CM2BLK:	NEWPR2			;ADDRESS OF 2ND REPARSE ROUTINE
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	0			;CONTROL-R BUFFER (FILLED IN)
	-1,,TX2BUF		;POINTER TO TEXT BUFFER
	-1,,TX2BUF		;POINTER TO CURRENT POSITION
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	0			;NUMBER OF UNPARSED CHARACTERS
	-1,,ATM2BF		;ATOM BUFFER
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	EXP JFNBLK		;POINTER TO JFN BLOCK

JFNBLK:	GJ%OLD			;FLAGS,,GENERATION NUMBER
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	BLOCK 20		;NO DEFAULTS


;TEXTI BLOCK FOR READING LINES
TXTIBL:	.RDRTY			;LAST WORD GIVEN
	0			;FLAGS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	0			;DESTINATION PTR (FILLED IN)
	0			;BYTES AVAILABLE (FILLED IN)
	0			;USE START OF BUFFER AS ABOVE
	0			;CONTROL-R TEXT (FILLED IN)

;TEXTI BLOCK TO READ STRING INTO ATMBUF
TXTIB:	.RDBRK			;LAST WORD GIVEN
	0			;FLAGS (FILLED IN)
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	0			;DESTINATION PTR (FILLED IN)
	0			;BYTES AVAILABLE (FILLED IN)
	0			;USE START OF ATMBUF AS ABOVE
	0			;NO CONTROL-R TEXT
	BCHRS			;ADDRESS OF BREAK CHAR MASKS

;CHARACTER MASKS, TO MAKE ONLY CONTROL-Z A BREAK CHARACTER
BCHRS:	1B<.CHCNZ>		;CONTROL-Z ONLY
	0
	0
	0

DLBIDX:	BLOCK 1			;Default library index
PAGMAP:	BLOCK ^D512/^D36 + 1	;BIT TABLE FOR PAGE MAP
PBFPNO:	BLOCK 1			;PAGE NUMBER OF PAGE BUFFER
AVERST:	BLOCK ^D20		;ASCIZ ALU version number
SAVEF:	BLOCK 1			;SAVED FLAGS
RSCANF:	BLOCK 1			;Number rescan chars to do
TEMPBP:	BLOCK 1			;Temp byte ptr.

;BEHAVIOR SWITCHES
SWFUID:	BLOCK 1			;1= PUT UID STRING IN REPLACED SOURCE FILE
SWCOPO:	BLOCK 1			;COPY GENERATED OUTPUT FILES
SWFCOM:	BLOCK 1			;RUN FILCOM AFTER REPLACING SOURCE FILE
SWRUID:	BLOCK 1			;REPLACE UID LINE
SWBAKF:	BLOCK 1			;MAKE BACKUP FILES
SWANYU:	BLOCK 1			;ALLOW ANY USER
SWGCPY:	BLOCK 1			;1= ASK USER IF HE WANTS A COPY OF
				;FILE ANYWAY IF IT IS RESERVED AND HE DOES A "GET"
SWREDT:	BLOCK 1			;1= RUN REDIT BEFORE REPLACE
SWCGET:	BLOCK 1			;1= DEFAULT IS /COPY ON GET


SUBTTL ZEROED CORE
XLIST
LIT
LIST				;LITERALS

	ZROST==.		;START OF AREA TO CLEAR ON STARTUP
MEPRIV:	BLOCK 1			;-1 IF I AM PRIVILEDGED TO DO ^E COMMANDS
PDL:	BLOCK PDLSIZ
SAVEP:	BLOCK 1			;A GOOD STACK POINTER
TXTBUF:	BLOCK TXTLEN/5+1	;BUFFER FOR COMMAND JSYS
ATMBUF:	BLOCK TXTLEN/5+1	;BUFFER FOR ATOM BUFFER
TX2BUF:	BLOCK TXTLEN/5+1	;BUFFER FOR 2ND COMND JSYS
ATM2BF:	BLOCK TXTLEN/5+1	;2ND ATOM BUFFER
PR2STA:	BLOCK 1			;START ADDR OF 2ND PARSE CODE
CM2P:	BLOCK 1			;PDL AT START OF 2ND PARSE

TLINE:	BLOCK TXTLEN/5+1	;READ LINE BY "ITTLIN"
TILTXT:	BLOCK TXTLEN/5+1	;STORED ANSWER TO (TILL WHEN?) WITH ".."
PRSJFN:	BLOCK 1			;JFN OF SOMETHING WE PARSED
UIDJFN:	BLOCK 1			;JFN OF ALU:UID.TXT
UIDNAM:	BLOCK FILWDS		;Whole Name of UID.TXT
SAVEPB:	BLOCK 1			;SAVED BP TO PAGMAP
NEWUID:	BLOCK 1			;VALUE RETURNED BY ALUUID
UID1:	BLOCK 1			;UID OF FILE ON MY AREA IN REPLACE
				; (OR 0)
LOGJFN:	BLOCK 1			;JFN FOR FILUPD.HST
LOGNAM:	BLOCK FILWDS		;Whole name of it
LOGBUF:	BLOCK LOGLEN/5+1	;BUFFER FOR OUTPUT TO LOG FILE
LIBHLD:	BLOCK FILWDS		;FOR ASCIZ /<LIBARY>*.*/
RETJNM:	BLOCK FILWDS		;PLACE FOR FILENAME

GTFJFN:	BLOCK 1			;JFN OF "GET" FILE
MAZJFN:	BLOCK 1			;JFN OF ".MAZ" FILE
MAZNAM:	BLOCK FILWDS		;ASCII FILENAME FOR .MAZ FILE

MABJFN:	BLOCK 1			;;JFN OF ".MAB" FILE
MABJNM:	BLOCK FILWDS		;ASCII NAME OF THE FILE

MAZBUF:	BLOCK LINLEN/5+1	;FIRST LINE OF MAZ FILE (S.B. THE ONLY LINE!)
.MAZLN==.-MAZBUF
RFBUF:	BLOCK MAXLIN/5+1	;FIRST LINE OF RESERVED FILE
.RFLN==.-RFBUF

LUIDTX==^D40			;LENGTH OF UID TEXT
UIDTXT:	BLOCK LUIDTX		;HOLDS BUILT UID TEXT
FSTLIN:	BLOCK 1			;ADDRESS OF 72 CHAR LINE TO CHANGE
WHYTXT:	BLOCK WHYLEN/5+1	;"WHY" TEXT

SAVNSP:	BLOCK 1			;SAVED NAM: STRING PTR
HNBUF:	BLOCK ^D20		;PLACE TO HOLD NAM: STRING
CD:	BLOCK ^D20		;MY CURRENT CONNECTED DIRECTORY <DIR>
RDIR:	BLOCK ^D20		;RESERVED DIRECTORY <DIR> FROM MAZ FILE
IJFN:	BLOCK 1			;INPUT JFN FOR COPIES
OJFN:	BLOCK 1			;OUTPUT JFN FOR COPIES
STIPGS:	BLOCK 1			;START OF PAGE BLOCK FOR IFILE
STOPGS:	BLOCK 1			;START OF PAGE BLOCK FOR OFILE
STIPG2:	BLOCK 1			;ADDRESS OF START OF IFILE BLOCK
STOPG2:	BLOCK 1			;ADDRESS OF START OF OFILE BLOCK
ENDPTR:	BLOCK 1			;ADDR OF LAST WORD OF DEST BUFFER
NXTBEG:	BLOCK 1			;PAGES WE HAVE "PRELOADED" IN FROM IJFN

BLTPTR:	BLOCK 1			;FOR MEM/MEM BLT
SAVBLT:	BLOCK 1			; SAVED BLT PTR
BCINP:	BLOCK 1			;BYTE COUNT FOR INPUT FILE
BSINP:	BLOCK 1			;BYTE SIZE FOR INPUT FILE

USRBIT:	BLOCK 1			;FLAGS FOR THIS USER
USRNAM:	BLOCK 10		;USER NAME STRING
LIBNUM:	BLOCK 1			;INTERNAL LIBRARY NUMBER
EXTNUM:	BLOCK 1			;INTERNAL EXTENSION NUMBER
HPTXTP:	BLOCK 1			;Holds help text when parsing a library

IFINAM:	BLOCK TXTLEN/5+1	;<DIR>NAME.EXT STRING FOR IJFN
RFTAD1:	BLOCK 2			;DATE/TIME INFO FOR SOURCE FILE
RFTADS:	BLOCK 2			;The main source file's RFTAD1 when copying
				; generated output files.

FROMFL:	BLOCK FILWDS		;COMPLETE JFNS TEXT FOR "FROM" FILE
HLDTIM:	BLOCK ^D10
HLDTM1:	BLOCK ^D10		;ASCII TIME
FCTXT:	BLOCK ^D20		;FILCOM TEXT
RDTTXT:	BLOCK <FILWDS*3>+^D10	;REDIT text (usually a lot!)
ADVPTR:	BLOCK 1			;WORKING PTR TO ADVTXT
ADVTXT:	BLOCK <FILWDS*3>+^D10	;REDIT ADVISORY TEXT
MYTTY:	BLOCK 1			;MY TERMINAL NUMBER
RDTFRK:	BLOCK 1			;FORK for REDIT
RDTINC:	BLOCK 1			;-1 IF REDIT IN CORE ALREADY
CKOFLP:	BLOCK 1			;AOBJN ptr for CHKOF routine
TLCOLM:	BLOCK 1			;Actual column number on output
ILBCD:	BLOCK 1			;Column # of "DIRECTORY" header
ILBCL:	BLOCK 1			;Column # of "LOG" header
GRCJFN:	BLOCK 1			;JFN used by "SETGRC" routine
GRCDBL:	BLOCK CD.LEN		;Directory block used by "SETGRC"

;CHANGE MODE SWITCHES
CNFCOM:	BLOCK 1			;FILCOM
CNCOPO:	BLOCK 1			;COPY OUTPUT FILES
CNFUID:	BLOCK 1			;UID IN SOURCE FILE
CNRUID:	BLOCK 1			;REPLACE UID
CNBAKF:	BLOCK 1			;MAKE BACKUP FILES
CNANYU:	BLOCK 1			;ANY USER ALLOWED TO USE ALU
CNGCPY:	BLOCK 1			;ASK USER IF HE WANTS A COPY ANYWAY
				;WHEN FILE IS RESERVED
CNREDT:	BLOCK 1			;RUN REDIT BEFORE REPLACE DONE
CNCGET:	BLOCK 1			;/COPY IS DEFAULT ON "GET"

	ZROEND==.-1		;END OF AREA TO CLEAR ON STARTUP
	LASTLC==.-1		;LAST NON-FREE LOC

	END 3,,AENTRY

  