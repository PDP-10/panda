.ll 7.5i
.lt 7.5i
.po .2i
.pn 1
.de TL
.sp 2
.ft 3
.ce
\\$1
.sp 1
.ft 1
..
.de PP
.sp 1
.ti 5
.fi
.ft 1
..
.de NB
.de NP
'sp 1
.tl ''%''
'bp +1
'sp 2
\\..
.ch NP -1i
..
.de NP
'bp +1
'sp 2
..
.wh -1.0i NP
.TL "LSRHS Logo Manual"
.NB
.de EX
.ft 3
.in +5
.sp 1
.nf
..
.de EE
.ft 1
.in -5
.fi
.PP
..
.de EC
.ft 1
.in -5
.sp 1
.fi
..
.de IN
.br
.in +5
..
.de OU
.sp 1
.in -5
..
.de UB
.uf 3
.cu 1
\\$1
.ft 1
.uf 2
..
.PP
.UB "Introduction."
Logo is a computer programming language which was
designed to be both simple to use and extremely powerful.  It was
designed by a group of computer scientists at MIT and at Bolt, Beranek, and
Newman.  Its structure is based largely on the LISP language, which is
widely used in Artificial Intelligence research, but the notation has been
changed to make Logo far easier for a beginner than LISP.  This manual
describes a version of Logo for the PDP-11, originally written in C at the
Boston Children's Museum and extensively modified at the Lincoln-Sudbury
Regional High School.
.PP
The power of Logo comes primarily from the idea of the \f2procedure\f1.  A
procedure is simply something the computer "knows" how to do; some
procedures are built into Logo itself (these are called \f2primitive\f1
procedures), while others are \f2defined\f1 by the programmer in terms of
these simple procedures.  Defined procedures can be used as part of the
definition of other procedures, so that a complicated program can be built
in "layers" of complexity.  This layered structure is analogous to the
description of a complex machine in terms of building blocks: an automobile
is made of a chassis, a drive train, an electrical system, and so on.  The
drive train contains an engine, a transmission, a clutch, an axle, and so
on.  The transmission contains a housing, gears, and levers.  A lever may
include connecting joints at the ends and at a pivot point.  Eventually the
description of the automobile reaches the level of bolts and washers; these
correspond to the primitive procedures in Logo.
.PP
.UB "Starting Logo."
Use the shell command \f3logo\f1 to start the Logo
interpreter.  When Logo is running it will print an asterisk (*) at the
beginning of a line to indicate that it is ready for you to type in a Logo
instruction.  The instruction may print something on the terminal, or draw a
line on a graphics display screen, or move a turtle around the floor.  Then
another asterisk is typed and you may give another instruction.  (If Logo
prints a "greater than" sign (>) instead of an asterisk, it is
in \f2procedure definition mode\f1,
which will be described later.  Type your system quit character
(control-G at Lincoln-Sudbury) to return to normal mode.)
.PP
If an argument is used with the shell command \f3logo\f1, the argument is
taken as the name of a procedure, which Logo runs before doing anything
else.  You can therefore create a shell script which will start Logo, run
a procedure automatically, and (if you say "goodbye" at the end of the
procedure) exit.
.PP
.UB "Syntax."
Unlike most computer languages, Logo has an almost
entirely uniform
syntax.  That is, all of the different commands Logo understands are
represented using the same notation: the name of a procedure is followed by
its \f2inputs\f1, which may be \f2constants\f1 (like numbers) or else may
be the results of using other procedures.  Here is a simple example:
.EX
print "hello
.EC
In this Logo instruction, the primitive procedure \f3print\f1 is used with
a constant input, the word \f3hello\f1.  The quotation mark indicates that
\f3hello\f1 is being used to represent the word itself; without the
quotation mark it would have been interpreted as the name of a procedure,
just as \f3print\f1 is the name of a procedure.  In Logo, the \f3print\f1
procedure always requires exactly one input, which is the thing to print.  The
input can be a \f2word\f1, as in this example, or a \f2list\f1, which will
be explained later.  (A \f2number\f1 is a special case of a word, and a
\f2sentence\f1 is a special case of a list.)  Here is another example:
.EX
print first "hello
.EC
In this instruction, the primitive procedure \f3first\f1 is used.  This
procedure takes one input, a word, and has an \f2output\f1 which is the
first letter of the word.  The output from \f3first\f1 is used as the input
to \f3print\f1, so what is printed is the letter \f3h\f1 rather than the
word \f3hello\f1 as in the earlier example.
.PP
Don't confuse the \f2output\f1 from a procedure with what is \f2printed\f1
by the \f3print\f1 command.  In Logo, the word "output" is not used to
refer to what is printed by a program, just as the word "input" does not
mean something you type into the program.  Instead, these words refer to
objects (words or lists) which are given to a procedure (inputs) or
produced by a procedure (outputs).  A particular procedure has a fixed
number of inputs and outputs.  The number of inputs may be anything,
including zero, whereas the number of outputs is either zero or one.  A
procedure with an output (like \f3first\f1) is called an \f2operation\f1; one
without an output (like \f3print\f1) is called a \f2command\f1.
.PP
Some operations only have two possible outputs: the word \f3true\f1 and
the word \f3false\f1.  Such a procedure is called a \f2predicate\f1.  Predicates
are used to allow a program to carry out some instruction only if a
particular condition is met.  By convention, predicates generally have
names ending with the letter "p".
.PP
.UB "Multiple inputs to operations."
Several Logo primitive procedures are
operations with two inputs.  The arithmetic operations, like \f3sum\f1, are
examples of this.  A special extension to Logo syntax allows such an operation
to have more than two inputs by enclosing the operation and its inputs in
parentheses or braces:
.EX
(sum 2 5 13 8.5)
.EC
Association is right to left.  At least two inputs must be given, except for
the \f3list\f1 operation, which can take one input if parenthesized.
.PP
.UB "Multi-instruction lines."
It is possible to put more than one instruction
on the same line when you are typing to Logo.  To do this, type a semicolon (;)
between the instructions:
.EX
print "hello; print "goodbye
.EC
Later in this manual, the phrase "instruction line" will mean one or more
instructions on a line.
.PP
.UB "Multi-line instructions."
It is possible to continue an instruction on
a second line.  To do this, end the first line with a backslash (\\),
immediately followed by the RETURN key.  If you are typing a quoted word,
you must end the word (with a space, for example) before using the
backslash-RETURN combination.  Inside a quoted word, backslash-RETURN
means to put an actual RETURN as part of the word.
.PP
.UB "Comments."
It is possible to include in an instruction line comments
which are meant for human readers of your program (including yourself, next
week), and which are not Logo instructions.  To do this, begin the comment
with an exclamation point (!).  Everything after the exclamation point on the
line will be ignored by Logo.  For example:
.EX
print [Hi, there.] ! A friendly greeting.
.EC
However, the exclamation point does not begin a comment if it is part of a
word or list (see below).  You should type a space before the exclamation
point, as in the example above, to make sure it will be interpreted as the
beginning of a comment.
.PP
.UB "Words."
Every computer language deals with particular kinds
of objects.  Most languages, like FORTRAN or BASIC or Pascal, are best at
dealing with numbers.  Logo is a \f2list processing\f1 language, which is
at its best with more complicated data structures.  The two main categories
of object are the \f2word\f1 and the \f2list\f1.
.PP
A \f2word\f1 is a string of characters.  (A \f2character\f1 is a letter,
digit, space, or punctuation mark.  Things like TAB and RETURN on the
terminal keyboard are also characters, although they are not usually used
as part of Logo words.)  A word can be any length, including zero.  The way
to indicate a word as part of a Logo program is to use the quotation mark
(") before the word.  The word begins with the character after the
quotation mark and continues until a space, a tab, the end of the
line, or one of these characters:
.EX
( ) [ ] { } " ;
.EC
A quotation mark immediately followed by a space or one of the other
word-terminating characters indicates the \f2empty word\f1, which is a word
of length zero.
.PP
Please notice that, unlike most programming languages, Logo does not use
quotation marks in pairs to delimit strings of characters.  The following
instruction is an error:
.EX
print "aardvark"
.EC
This is an error because the \f3print\f1 command is followed by \f2two\f1
words, the word \f3aardvark\f1 and an empty word which is indicated by the
second quotation mark.  Since \f3print\f1 only uses one input, the second
word has no purpose, and Logo gives the error message
.EX
There's something extra on the line.
print takes only one input.
.EE
In order to include one of the word-terminating characters in a word, you
must precede it with a backslash (\\).  Do not confuse backslash with the
regular slash (/) character.  For example, this instruction:
.EX
print "\\(boo\\)
.EC
will print the five characters \f3(boo)\f1 as its result.  The space
character may be included in a word by using a percent (%) instead of the
space.  Therefore, the following are equivalent:
.EX
print "Hello%there.
print "Hello\\ there.
.EC
To include a percent character or a backslash character in a word, you must
precede it with a backslash.
.PP
.UB "Numbers."
A number is a special case of a word, in which the
characters are all digits.  (That definition isn't quite complete, and will
be expanded in the next paragraph.)  A number need not be preceded with a
quotation mark.  (This rule is possible because normally Logo interprets
words without quotation marks as the names of procedures, but there are no
procedures whose names begin with digits.)  If a quotation mark is not
used, then any nondigit terminates the word.
.PP
Actually, numbers may be written in scientific notation.  That is, they can
include signs, decimal points, and a power of 10 by which the number is
multiplied.  This \f2exponent\f1 is indicated by the letter \f3e\f1
followed by the integer power of 10.  The following numbers have the
same value:
.EX
1000
"1000
1000.00
1e3
10.0e+2
"+1.0e3
10000e-1
.EC
Notice that if the number begins with a sign it must be quoted.  A quoted
number still must begin with a digit or a sign, not with a
decimal point or a letter \f3e\f1.  (The
letter may be a capital \f3E\f1, by the way.)  If a number is quoted, it
must end with one of the normal word-terminating characters.  A number
which contains only digits (no decimal point or exponent) is called
an \f2integer\f1.  Note that a number with a decimal point is not
considered an integer even if the digits after the decimal point are
all zero.
.PP
Since a number is a word, the usual character-manipulating procedures may
be applied to it.  For example,
.EX
print first 1024
.EC
prints the digit \f31\f1 which is the first character of the number.  In
addition, there are arithmetic procedures which apply specifically to numbers:
.EX
print sum 3 2
.EC
prints the number 5.  These procedures will be listed later.
.PP
.UB "Lists."
A word can be thought of as a list of characters; for
example, the word \f3hello\f1 is a list of five letters.  In Logo it is
possible to manipulate not only lists of characters but also lists of
words, lists of lists of words, and so on.  This is a very powerful capability
which allows very complicated data structures to be manipulated easily.  To
indicate a list in a program, you put square brackets ([ and ]) around the
list, and separate the list elements with spaces.  For example:
.EX
print [This is a list of seven words.]
.EC
A list all of whose elements are words is called a \f2sentence\f1.  Here
is an example of a list which is not a sentence:
.EX
print [[This is a list][of two sentences.]]
.EE
Within a bracketed list, square brackets delimit sub-lists (lists which are
elements of the main list).  The quotation mark, parentheses, and braces
are not considered special within a bracketed list, unlike the rules for
quoted words.  A list may extend over more than one line; that is, if you
have typed an open square bracket ([) and have not yet typed the matching
close square bracket, the Logo instruction is not ended by typing the RETURN
key.
.PP
.UB "Variables."
A variable is an entity which has a \f2name\f1, which
is a word, and a \f2thing\f1 (also called a \f2value\f1), which
can be any Logo object.  Variables
are used to "remember" a computed object for repeated or delayed use
in a program.  In Logo, the most common way that a variable acquires
a value is that it is associated with an input to a user-written
procedure.  In the following example, don't worry about the details
of the format of the procedure, which will be explained later:
.EX
to pff :sentence
print first first :sentence
end
.EC
This is the definition of a command with one input.  The name of the
command is \f3pff\f1.  It has one input because in the "title line" (the
one starting \f3to pff\f1) there is one variable name after the command
name.  The variable whose name is \f3sentence\f1 is associated with the
first (and only, in this case) input to \f3pff\f1.  In the line starting
with the word \f3print\f1, the notation \f3:sentence\f1 means "the \f2thing\f1
of the variable whose \f2name\f1 is \f3sentence\f1".  (To refer to the
name itself, quote it as you would any word.)  If this procedure is used
in a Logo instruction like this:
.EX
pff [This is the poop.]
.EC
then the variable \f3sentence\f1 has the value \f3[This is the poop.]\f1.
.PP
It is also possible to assign a value to a variable by an explicit
Logo instruction.  There is a primitive procedure to do this:
.sp 1
\f3make\f1 \(em Command, two inputs.
.IN
The first input is the name of a variable (that is, it must be a word); the
second is any Logo object.  The effect of the command is to assign the
second input as the value of the variable named by the first input.
.OU
If you are accustomed to programming in a non-procedural language like
BASIC, you should strenuously avoid the temptation to overuse \f3make\f1;
explicit assignment is almost always the wrong thing to do in Logo.  Total
abstention is the best policy for a Logo beginner.
.PP
In Logo, variables are \f2dynamically scoped\f1.  That means that a
variable can "belong to" a particular procedure; such a variable can
be used by that procedure and by any procedure which is used by an
instruction within the procedure, but is not available to the procedure
which invoked the owning procedure.  In other words, such a \f2local\f1
variable comes into being when the owning procedure starts running, and
disappears when that procedure is finished.  It is possible for a
procedure with a local variable to use another procedure with a local
variable of the same name.  In that case, the variable belonging to the
"inner" procedure is the one which is associated with the name as long
as it exists; when the inner procedure is finished, the "hidden"
variable belonging to the outer procedure is again available.
.PP
A variable which is associated with the input to a procedure is
automatically local to that procedure.  Other variables are normally
\f2global\f1: they are "permanent" and do not disappear when the
procedure in which they get their values finish.  It is both possible
and desirable to make such variables local, by an explicit instruction
to that effect:
.sp 1
\f3local\f1 \(em Command, one input.
.IN
The input must be a word.  A variable with that word as its name
is created, local to the currently running procedure (that is,
local to the procedure in which the \f3local\f1 command is used).
.OU
The virtue of local variables is that they make procedures more
independent of one another than they would be if global variables
were used.  In other words, if you use local variables consistently,
then nothing that happens in one procedure will change the values
of variables used in another procedure.  This makes it very much
easier to find program errors.
.PP
.UB "Primitive procedures to define user procedures."
There are
two ways to define your own procedure.  The first way, using the \f3to\f1
command, is simple to learn but limited in flexibility.  The second way,
using the \f3edit\f1 command, is more complicated to learn, but makes it
easy to make changes in your procedures.  The \f3edit\f1 command uses the
text editing program \f3edt\f1, just as you might use it outside of Logo
to edit a document you want to print.  Once you've learned the special
editing commands in \f3edt\f1, it's easy to use.  The \f3to\f1 command makes
it possible to begin programming in Logo without having learned how to use
\f3edt\f1.  It just lets you type in your procedure definition, without any
provision for correcting errors or changing the definition of the procedure.
It is fast and convenient for short procedures, but limited.
.sp 1
The \f3to\f1 command is unique, in Logo, in that its inputs are interpreted
in a special way.  The inputs aren't \f2evaluated\f1: Logo doesn't run any
procedures you name, or look up the values of any variables, before carrying
out the \f3to\f1 command.  The example below should make this clearer.
.sp 1
\f3to\f1 \(em Command, special form, see below.
.IN
This command takes a variable number of inputs.  The first is the name
of a procedure to be defined.  The rest, if any, must be preceded by
colons, and are the names of variables to be used as inputs to the
procedure.  Logo responds to the \f3to\f1 command by printing a
"greater than" sign (>) prompt, to show you that you are defining a procedure
rather than entering commands to be executed immediately.  You type
the instruction lines which make up the definition.  When
you are done with the definition, type the special word \f3end\f1 on
a line by itself.  For example:
.sp 1
.nf
\f3\z_*to twoprint :thing
\z_>print :thing
\z_>print :thing
\z_>end
\z_*\f1
.fi
.sp 1
This example shows the definition of a procedure named \f3twoprint\f1,
which has one input, named \f3thing\f1.  The procedure you are defining
with the \f3to\f1 command must not already be defined.
.OU
\f3edit\f1 \(em Command, zero or one input.  Abbreviation: \f3ed\f1
.IN
The input to this command must be a word, which is the name of a procedure,
or a list of words, each of which is the name of a procedure.
(Unlike the \f3to\f1 command, but like all other Logo procedures, the
\f3edit\f1 command evaluates its input, so you must use a quotation mark
before the procedure name, if only one is given, to indicate
that it is the name itself which is
the input to \f3edit\f1; otherwise Logo would actually run the procedure
to calculate the input to \f3edit\f1.)  The procedure you name may or may
not already be defined.  Logo responds to the \f3edit\f1 command by running
the text editor \f3edt\f1, editing the definition of the procedure(s) named in
its input.  (If a procedure was not previously defined, Logo creates an
initial definition for it which contains only a title line and the end line.)
You then edit the definition(s) with \f3edt\f1.  When you write the file and
leave \f3edt\f1, Logo will use the edited file as the definition(s) of the
procedure(s).  You must not put anything in the file except procedure
definitions; in other words, every nonempty line in the file must be between
a "to" line and an "end" line.
.sp 1
If the \f3edit\f1 command is given with no input, \f3edt\f1 is given the same
file as from the last time you used the \f3edit\f1 command.  This is a
convenience for editing the same procedure(s) repeatedly.
.sp 1
If, while editing, you change your mind and want to leave \f3edt\f1
without redefining anything, use the command \f3ESC ^Z\f1 instead of
the normal \f3^Z\f1.  This special way of leaving \f3edt\f1 tells Logo
not to redefine your procedures.  You have the choice, before exiting
\f3edt\f1, of writing or not writing the temporary file which contains
the definitions.  If you don't write the file, another \f3edit\f1 command
with no input will re-read the previous contents of the temporary file;
if you do, another \f3edit\f1 will re-read the new version.
.sp 1
If your Unix environment contains a variable named EDITOR, the contents of
that variable is used as the name of the text editor program instead of
the standard \f3edt\f1.  The variable can contain a full pathname, or just
a program name if the program can be found in /bin or /usr/bin.  Your favorite
editor may not have a facility like \f3edt\f1's ESC ^Z to abort redefinition.
.OU
\f3show\f1 \(em Command, one input.  Abbreviation: \f3po\f1
.IN
The input to this command is a word or a list of words.  Each word must be
the name of a procedure.  The command prints out the definition(s) of the
procedure(s) on your terminal.  (The abbreviation \f3po\f1 stands for
\f3printout\f1, which is the name used for this command in some other versions
of Logo.)
.OU
\f3pots\f1 \(em Command, no inputs.
.IN
This command types at your terminal the title lines of all procedures
you've defined.  The name is an abbreviation for "print out titles".
.OU
\f3erase\f1 \(em Command, one input.  Abbreviation: \f3er\f1
.IN
As for the \f3show\f1 command, the input is either a word, naming one
procedure, or a list of words, naming more than one.  The named procedures
are erased, so that they are no longer defined.
.OU
.ti 5
.UB "Primitive procedures to manipulate words and lists."
There are
primitive procedures to print text objects on the terminal, to read
them from the terminal, to combine them into larger objects, to split
them into smaller objects, and to determine their size and nature:
.sp 1
\f3print\f1 \(em Command, one input.  Abbreviation: \f3pr\f1
.IN
The input, which may be a word or a list, is printed on the terminal,
followed by a new line character.  (That is, the terminal is positioned
at the beginning of a new line after printing the object.)  If the
object is a list, any sub-lists are delimited by square brackets, but
the entire object is not delimited by brackets.
.OU
\f3type\f1 \(em Command, one input.
.IN
The input, which may be a word or a list, is printed on the terminal,
\f2without\f1 a new line character.  (That is, the terminal remains
positioned at the end of the object after printing it.)  Brackets
are used as with the \f3print\f1 command.
.OU
\f3fprint\f1 \(em Command, one input.  Abbreviation: \f3fp\f1
.IN
The input is printed as by the \f3print\f1 command, except that if it
is a list (as opposed to a word) it is enclosed in square brackets.  The
name of the command is short for "full print".
.OU
\f3ftype\f1 \(em Command, one input.  Abbreviation: \f3fty\f1
.IN
The input is printed as by the \f3type\f1 command, except that if it
is a list, it is enclosed in square brackets.
.OU
\f3readlist\f1 \(em Operation, no inputs.  Abbreviation: \f3rl\f1
.IN
Logo waits
for a line to be typed by the user.  The contents of the line are made
into a list, as though typed within square brackets as part of a Logo
instruction.  (The user should not actually type brackets around the
line, unless s/he desires a list of one element, which is a list
itself.)  That list is the output from the operation.
.OU
\f3request\f1 \(em Operation, no inputs.
.IN
A question mark is printed on the terminal as a prompt.  Then Logo waits
for a line to be typed by the user, as for \f3readlist\f1.
.OU
\f3word\f1 \(em Operation, two inputs.
.IN
The two inputs must be words.  The output is a word which is the
concatenation of the two inputs.  There is no space or other
separation of the two inputs in the output.
.OU
\f3sentence\f1 \(em Operation, two inputs.  Abbreviation: \f3se\f1
.IN
The two inputs may be words or lists.  The output is a list formed
from the two inputs in this way: if either input is a word, that
word becomes a member of the output list; if either input is a
list, the \f2members\f1 of that input become members of the
output.  Here are some examples:
.EX
.ta 2i 4i
first input	second input	output
"hello	"test	[hello test]
"goodbye	[cruel world]	[goodbye cruel world]
[a b]	[c d]	[a b c d]
[]	"garply	[garply]
.EC
If an input is the empty list, as in the last example above, it
contributes nothing to the output.
.OU
\f3list\f1 \(em Operation, two inputs.
.IN
The output is a list of two elements, namely, the two inputs.  The
inputs may be words or lists.
.OU
\f3fput\f1 \(em Operation, two inputs.
.IN
The first input may be any Logo object; the second must be a list.  The
output is a list which is identical with the second input except that
it has an extra first member, namely, the first input.
.OU
\f3lput\f1 \(em Operation, two inputs.
.IN
The first input may be any Logo object; the second must be a list.  The
output is a list which is identical with the second input except that
it has an extra last member, namely, the first input.
.OU
\f3first\f1 \(em Operation, one input.  Abbreviation: \f3f\f1
.IN
The input may be any non-empty Logo object.  If the input is a list,
the output is its first member.  If the input is a word, the output is
a single-letter word, namely the first letter of the input.  If the
input is empty (a word or list of length zero) an error results.
.OU
\f3last\f1 \(em Operation, one input.  Abbreviation: \f3l\f1
.IN
The input may be any non-empty Logo object.  If the input is a list,
the output is its last member.  If the input is a word, the output is
a single-letter word, namely the last letter of the input.  If the
input is empty (a word or list of length zero) an error results.
.OU
\f3butfirst\f1 \(em Operation, one input.  Abbreviation: \f3bf\f1
.IN
The input may be any non-empty Logo object.  If the input is a list,
the output is a list equal to the input list with the first member
removed.  (If the input list has only one member, the output is
the \f2empty list\f1, a list of zero members.)  If the input is
a word, the output is a word equal to the input word with the
first letter removed.  (If the input is a single-letter word, the
output is the \f2empty word\f1.)  If the input is empty, an
error results.
.OU
\f3butlast\f1 \(em Operation, one input.  Abbreviation: \f3bl\f1
.IN
The input may be any non-empty Logo object.  If the input is a list,
the output is a list equal to the input list with the last member
removed.  (If the input list has only one member, the output is
the \f2empty list\f1, a list of zero members.)  If the input is
a word, the output is a word equal to the input word with the
last letter removed.  (If the input is a single-letter word, the
output is the \f2empty word\f1.)  If the input is empty, an
error results.
.OU
\f3count\f1 \(em Operation, one input.
.IN
The input may be any Logo object.  If the input is a list, the
output is a number indicating the number of members in the list.  (Note:
only top-level members are counted, not members of members.  The count
of the list
.EX
[[This is] [a list]]
.EC
is 2, not 4.)  If the input is a word, the output is the number of
letters (or other characters) in the word.  Remember that in Logo a
number is just a particular kind of word, so the output from \f3count\f1 can
be manipulated like any other Logo word.
.OU
\f3emptyp\f1 \(em Operation (predicate), one input.
.IN
The input can be any Logo object.  The output is the word \f3true\f1 if
the input is of length zero (i.e., it is the empty word or the empty
list).  The output is the word \f3false\f1 otherwise.
.OU
\f3wordp\f1 \(em Operation (predicate), one input.
.IN
The input can be any Logo object.  The output is the word \f3true\f1 if
the input is a word.  The output is the word \f3false\f1 if the input
is a list.
.OU
\f3sentencep\f1 \(em Operation (predicate), one input.
.IN
The input can be any Logo object.  The output is the word \f3true\f1 if
the input is a sentence, i.e., a list of words.  The output is the word
\f3false\f1 if the input is a word, or if any member of the input is a
list.
.OU
\f3is\f1 \(em Operation (predicate), two inputs.
.IN
The inputs can be any Logo objects.  The output is the word \f3true\f1 if
the two inputs are identical.  That is, they must be of the same type
(both words or both lists), they must have the same count, and their
members (if lists) or their characters (if words) must be identical.  The
output is the word \f3false\f1 otherwise.  (Note: this is an exception
to the convention that names of predicates end with the letter "p".)
.OU
\f3memberp\f1 \(em Operation (predicate), two inputs.
.IN
If the second input is a word, the first input must be a word of
length one (a single character), and the output is \f3true\f1 if and
only if the first input is contained in the second as a character.  If
the second input is a list, the first input can be any Logo object,
and the output is \f3true\f1 if and only if the first input is a member
of the second input.  (Note that this is member, not subset.)
.OU
\f3item\f1 \(em Operation, two inputs.  Abbreviation: \f3nth\f1
.IN
The first input must be a positive integer less than or equal to
the \f3count\f1 of the second input.  If the second input is a word,
the output is a word of length one containing the selected character
from the word.  (Items are numbered from 1, not 0.)  If the second input
is a list, the output is the selected member of the list.
.OU
.ti 5
.UB "Primitive procedures for turtles and graphics."
An important
part of the Logo environment is a rich set of applications to which the
computer can be directed.  The most important of these is \f2turtle
geometry\f1, a way of describing paths of motion in a plane which is
well-suited to computer programming.  There are two ways to use the
turtle procedures.  First, you can control a \f2floor turtle\f1, a small
robot which can move one the floor or on a table under computer
control.  Second, you can use a \f2display turtle\f1 to draw pictures
on the TV screen of a graphics terminal.
.PP
Each computer center has a different variety of graphics hardware
available.  Floor turtles are very different from display turtles, but also
each kind of display terminal has different characteristics.  For example,
some terminals can draw in several colors; others can't.  The following
descriptions of graphics primitives explain the "best" case for each one
and mention restrictions on some graphics devices.
.PP
The floor turtle can draw pictures on paper, because it has a pen
attached to its "belly": the underside of the turtle.  Since it is
a mechanical device, however, it is not very precise; the pictures
you get may not be exactly like what your program specifies.  A more
interesting way to use the floor turtle is to take advantage of its
\f2touch sensors\f1.  Switches under the turtle's dome allow the computer
to know when the turtle bumps into an obstacle.  You can use this
information to write programs to get around obstacles or to follow
a maze.
.PP
The display turtle lives on the surface of a TV screen.  It can draw
pictures more precisely than the floor turtle, since it does not
measure distances and angles mechanically.  It is also faster than
the floor turtle.  When using the display turtle, remember that
it interprets commands relative to its own position and direction,
just as the floor turtle does.  The command \f3left\f1, for example,
turns the turtle to its own left, which may or may not be toward
the left side of the TV screen.
.sp 1
\f3turtle\f1 \(em Command, one input.  Abbreviation: \f3tur\f1
.IN
The input is the name of a turtle.  You can only control one turtle
at a time, so using this command a second time releases the turtle
previously selected.  The names of floor turtles are numbers like
\f30\f1 and \f31\f1.  If you are using
a graphics display terminal (not just a text display trminal), you can
control the display turtle by using the word \f3display\f1 (or the
abbreviation \f3dpy\f1) as the turtle name.  (As usual, the word
must be preceded by a quotation mark.)  If you use a graphics primitive
without selecting a turtle, Logo assumes that you want to use the
display turtle.  But once you select a floor turtle, you must say
\f3turtle "display\f1 explicitly to switch to the display.
.sp 1
The word \f3off\f1 as input to the \f3turtle\f1 command releases a floor
turtle, if you have one, or turns off the graphics display if you have
been using the display turtle.  This also happens when you leave Logo.
.OU
\f3forward\f1 \(em Command, one input.  Abbreviation: \f3fd\f1
.IN
The input is a number, the distance you would like the turtle
to move.  For a floor turtle, the unit of distance is however
far the turtle can travel in 1/30 second.  For a display turtle,
the unit is one dot on the TV screen.  (Note: on some displays, one
dot horizontally may not be the same length as one dot vertically.  The
\f3setscrunch\f1 command allows you to control the
relative sizes so that squares come out
square.)  The turtle moves in whatever direction it is pointing
when you use the command.
.OU
\f3back\f1 \(em Command, one input.  Abbreviation: \f3bk\f1
.IN
The input is a number, a distance to move, as in the \f3forward\f1
command.  The difference is that the turtle moves backward, i.e.,
in the direction exactly opposite to the way it's pointing.
.OU
\f3left\f1 \(em Command, one input.  Abbreviation: \f3lt\f1
.IN
The input is a number, the number of degrees of angle through
which the turtle should turn counterclockwise.  This command
does not change the \f2position\f1 of the turtle, but merely
its \f2heading\f1 (the direction in which it points).  The
turn will be only approximately correct for the floor turtle,
because of mechanical errors.  For the display turtle, the
angle will be perfectly reproducible, although it may not look
quite right on the screen because of the difference in size
between horizontal and vertical dots.  Nevertheless, a display
turtle program will work in the sense that when the turtle is
supposed to return to its starting point, it will do so.
.OU
\f3right\f1 \(em Command, one input.  Abbreviation: \f3rt\f1
.IN
The input is a number; the turtle turns through the specified
number of degrees clockwise.
.OU
\f3penup\f1 \(em Command, no inputs.  Abbreviation: \f3pu\f1
.IN
This command tells the turtle to raise its pen from the paper,
so that it does not leave a trace when it moves.  In the case
of the display turtle, there is no physical pen to move
mechanically, but the effect is the same: any \f3forward\f1 or
\f3back\f1 commands after this point do not draw a line.  The
floor turtle starts with its pen up; the display turtle starts
with its pen down.  Note: the floor turtle will not move on
the carpet correctly with its pen down; put it on a smooth
surface if you want to draw pictures.
.OU
\f3pendown\f1 \(em Command, no inputs.  Abbreviation: \f3pd\f1
.IN
This command tells the turtle to lower its pen, so that
later commands will draw lines when the turtle moves.
.OU
\f3penerase\f1 \(em Command, no inputs.  Abbreviation: \f3pe\f1
.IN
This command tells the turtle to "lower its eraser", so that lines
previously drawn will be erased when retraced by the turtle.  It
only works with the display turtle.  The commands \f3penup\f1,
\f3pendown\f1, \f3penerase\f1, and \f3penreverse\f1
are mutually exclusive; whichever
was most recently used is the one which affects the turtle.  (Graphics
terminals which cannot selectively erase lines, such as Tektronix
displays, will treat \f3penerase\f1 as \f3pendown\f1.)
.OU
\f3penreverse\f1 \(em Command, no inputs.  Abbreviation: \f3px\f1
.IN
This command tells the display turtle to lower its "reversing pen";
thereafter, when the turtle moves, it turns on any points which were
off, and turns off any points which were on.  The commands \f3penup\f1,
\f3pendown\f1, \f3penerase\f1, and \f3penreverse\f1 are mutually
exclusive; whichever was most recently used is the one which affects the
turtle.  (Note:  Graphics terminals which cannot penreverse will treat
this command as \f3pendown\f1.)
.OU
\f3penmode\f1 \(em Operation, no inputs.
.IN
This operation applies to the floor or the display turtle.  It outputs one
of the words \f3penup\f1, \f3pendown\f1, \f3penerase\f1, or
\f3penreverse\f1, depending on the current state of the turtle's pen.
.OU
\f3lampon\f1 \(em Command, no inputs.  Abbreviation: \f3lon\f1
.IN
This command applies only to the floor turtle; it turns on the
headlamps on the front of the turtle.
.OU
\f3lampoff\f1 \(em Command, no inputs.  Abbreviation: \f3loff\f1
.IN
This command turns off the floor turtle's headlamps.
.OU
\f3hitoot\f1 \(em Command, one input.  Abbreviation: \f3hit\f1
.IN
This command applies only to the floor turtle.  It sounds the
turtle's horn at the higher of its two pitches.  The input is
a number which indicates the number of quarter-seconds to toot
the horn.  Note: large numbers are likely to lead to violent
behavior on the part of other computer users.
.OU
\f3lotoot\f1 \(em Command, one input.  Abbreviation: \f3lot\f1
.IN
This command sounds the floor turtle's horn at the lower of
its two pitches.  The input is the duration of the toot.
.OU
\f3ftouch\f1 \(em Operation (predicate), no inputs.  Abbreviation: \f3fto\f1
.IN
This operation can be used only with the floor turtle.  It has as its
output the word \f3true\f1 if the front of the turtle is touching an
obstacle; otherwise it has the word \f3false\f1 as its output.
.OU
\f3btouch\f1 \(em Operation (predicate), no inputs.  Abbreviation: \f3bto\f1
.IN
This operation can be used only with the floor turtle.  It has as its
output the word \f3true\f1 if the back of the turtle is touching an
obstacle; otherwise it has the word \f3false\f1 as its output.
.OU
\f3ltouch\f1 \(em Operation (predicate), no inputs.  Abbreviation: \f3lto\f1
.IN
This operation can be used only with the floor turtle.  It has as its
output the word \f3true\f1 if the left side of the turtle is touching an
obstacle; otherwise it has the word \f3false\f1 as its output.
.OU
\f3rtouch\f1 \(em Operation (predicate), no inputs.  Abbreviation: \f3rto\f1
.IN
This operation can be used only with the floor turtle.  It has as its
output the word \f3true\f1 if the right side of the turtle is touching an
obstacle; otherwise it has the word \f3false\f1 as its output.
.OU
\f3clearscreen\f1 \(em Command, no inputs.  Abbreviation: \f3cs\f1
.IN
This command applies only to the display turtle.  It erases everything
on the TV screen, and restores the turtle to its initial position and
heading (center of the screen, facing toward the top edge).
.OU
\f3wipeclean\f1 \(em Command, no inputs.  Abbreviation: \f3clean\f1
.IN
This command applies only to the display turtle.  It erases everything
on the TV screen, but does not change the turtle's position or heading.
.OU
\f3fullscreen\f1 \(em Command, no inputs.  Abbreviation: \f3full\f1
.IN
This command applies only to the Atari display turtle.  It eliminates the
use of the bottom four lines of the screen to display the commands
you type; instead, the entire screen is available to show the
picture drawn by the turtle.  However, you can no longer see
what you're typing.  The command may be used after the picture is
already drawn; the part "hidden" by the text at the bottom of
the screen will become visible.  On other displays, \f3fullscreen\f1 and
\f3splitscreen\f1 are equivalent; they make the entire screen available
for graphics, and text appears on the bottom line (Gigis) or superimposed
(ADMs), or somewhere.
.OU
\f3splitscreen\f1 \(em Command, no inputs.  Abbreviation: \f3split\f1
.IN
This command applies only to the Atari display turtle.  It restores the
normal text display at the bottom of the screen, undoing the
effect of the \f3full\f1 command.  On other displays, \f3fullscreen\f1 and
\f3splitscreen\f1 are equivalent; they make the entire screen available
for graphics, with text superimposed in a display-dependent area.
.OU
\f3textscreen\f1 \(em Command, no inputs.  Abbreviation: \f3text\f1
.IN
This command applies only to the display turtle.  It temporarily
removes the turtle display from the screen, making the entire
screen available for text display.  The commands \f3fullscreen\f1 and
\f3splitscreen\f1 will restore the graphics display.  Note:  On the Atari
display, the picture on the screen is remembered, so that when you return
to \f3fullscreen\f1 or \f3splitscreen\f1 mode, the picture returns to the
screen.  On other displays, the picture is forgotten, and you return to
an empty graphics screen.
.OU
\f3hideturtle\f1 \(em Command, no inputs.  Abbreviation: \f3ht\f1
.IN
This command applies only to the display turtle.  It erases the
display of the turtle itself from the screen, so that only the
lines drawn when the turtle moves are visible.  The display is
faster when the turtle is hidden (only slightly faster on the Atari,
but much faster on other terminals).  Also, once a graphics
program is debugged, it may be prettier to watch without the
turtle visible.  (Note:  On the Tektronix display, the turtle is
never visible, because the terminal cannot erase selectively.)
.OU
\f3showturtle\f1 \(em Command, no inputs.  Abbreviation: \f3st\f1
.IN
This command applies only to the display turtle.  It restores
the display of the turtle, after the \f3hideturtle\f1 command
has been used.  (Note:  On the Tektronix display, the turtle is
never visible.)
.OU
\f3shownp\f1 \(em Operation (predicate), no inputs.
.IN
This predicate applies only to the display turtle.  It outputs the word
\f3true\f1 if the turtle is visible on the TV screen, \f3false\f1 otherwise.
.OU
\f3pencolor\f1 \(em Command, one input.  Abbreviation: \f3penc\f1
.IN
This command applies only to the display turtle.  Its effect is different
depending on how each type of terminal supports color.  For the Atari, the
input must be
an integer between 0 and 6.  An input of 0 enters black-and-white
display mode (which is the turtle's initial mode), in which lines
are as thin as possible but there is no control of color.  Any other
input selects color mode, in which lines are twice as thick, so the
effective size of the screen is smaller, but colors can be used.  There
are, in color mode, three possible pen colors, numbered 1 to 3.  There
are 256 possible colors, but only three can be on the screen at a time;
the \f3setcolor\f1 command is used to decide which pen draws in which
actual color.  If the input is 4, 5, or 6, the color is that of pen
1, 2, or 3, respectively, but lines are drawn in "fill mode": for each
point inked, all points to its right are also inked until a point is
reached which was already inked.  On the Gigi, there is only one mode, and
there is no loss of resolution in using color.  The input must be between
0 and 7; 0 means black, 7 means white.  The ADM, Tektronix, and Sun displays
do not have multi-color drawing.
.OU
\f3setcolor\f1 \(em Command, two inputs.  Abbreviation: \f3setc\f1
.IN
This command applies only to the Atari display turtle.  The first input
must be an integer between 0 and 3.  If the input is nonzero, the
second input specifies the color for the pen selected by the first
input.  If the first input is zero, the second input specifies the
background color for the color graphics display.  The second input
is either an integer between 0 and 15, which is a color number, or
a list of two integers, in which case the first is a color number
and the second is an intensity number, an integer between 0 and 7.
.OU
\f3setxy\f1 \(em Command, two inputs.
.IN
The two inputs must be numbers.  The turtle is moved to the point
on the screen whose x (horizontal) coordinate is the first input,
and whose y (vertical) coordinate is the second input.  The center
of the screen, where the turtle starts, has both coordinates zero.
If the pen is down, this command draws a line.  This command
applies only to the display turtle.
.OU
\f3setheading\f1 \(em Command, one input.  Abbreviation: \f3seth\f1
.IN
The input must be a number.  The turtle's heading is set to the
input, taken in degrees.  Zero points straight up, as the turtle
starts out; positive headings are clockwise from zero.  This command
applies only to the display turtle.
.OU
\f3towardsxy\f1 \(em Operation, two inputs.
.IN
This operation applies only to the display turtle.  The two inputs must
be numbers, which are the x and y coordinates of a point on the TV
screen.  The output is a number which is the heading to which the turtle
must be set, in order to point towards that point from its current
position.  Note: this operation does not actually move or turn the
turtle.  You must use it as the input to \f3setheading\f1 if that is
what you want.
.OU
\f3xcor\f1 \(em Operation, no inputs.
.IN
The output is the turtle's current x (horizontal) coordinate.  The
operation works only with the display turtle.
.OU
\f3ycor\f1 \(em Operation, no inputs.
.IN
The output is the turtle's current y (vertical) coordinate.  This
operation works only with the display turtle.
.OU
\f3heading\f1 \(em Operation, no inputs.
.IN
The output is the turtle's current heading in degrees.  This operation
works only with the display turtle.
.OU
\f3getpen\f1 \(em Operation, no inputs.
.IN
The output is the turtle's current pen color, or (on the Atari) zero
if in black-and-white
mode.  This operation works only with the display turtle.
.OU
\f3setscrunch\f1 \(em Command, one input.  Abbreviation: \f3setscrun\f1
.IN
This command is used only for display turtles.  The
input must be a number.  The vertical component of turtle motion is
multiplied by this number before each motion is taken.  If squares come
out too wide on your screen, you should increase the number; if too tall,
you should decrease it.  (You can also use \f3setscrunch\f1 to deform the
turtle's motion on purpose, so for example a circle program will draw
an ellipse instead.)  The initial scrunch value depends on the terminal
you are using: for the Atari and the Gigi, it is around 0.8 (your particular
computer center will adjust this for the particular TV monitors you use),
but for the ADM, Tektronix, and Sun, it is 1.0 because these terminals
display the same size steps horizontally and vertically.
.OU
\f3scrunch\f1 \(em Operation, no inputs.
.IN
This operation is used only for display turtles.  It outputs a number, which
is the scrunch factor (or aspect ratio) by which vertical motion is
multiplied before it is displayed.  This number is changed using the
\f3setscrunch\f1 command.
.OU
.ti +5
.UB "Primitive procedures for arithmetic."
Several procedures
are available for arithmetic operations on numbers.  In all
cases, the inputs to these procedures must be numbers, except
as otherwise indicated in the individual descriptions.
.PP
In general, procedures are used in Logo by typing first the name
of the procedure, then its inputs.  This is true of arithmetic
procedures also, e.g.
.EX
sum 3 2
.EC
However, for some arithmetic operations, Logo also recognizes the
more traditional \f2infix\f1 notation, with the operation between
the two inputs:
.EX
3 + 2
.EC
Be warned, though, that the use of infix forms makes it difficult
for Logo to know how to group operations, unless parentheses are
used.  If you stick to the standard (in Logo) prefix notation,
the grouping is always unambiguous.  For example, the first two of
these three instructions are equivalent, but the third is not:
.EX
if equalp count "hello 5 [print "Yes.]
if (count "hello) = 5 [print "Yes.]
if count "hello = 5 [print "Yes.]
.EC
The reason for the error message produced by the last of those three
instructions is that Logo interprets it as
.EX
if count equalp "hello 5 [print "Yes.]
.EC
That is, the equality test is done first, on the word \f3hello\f1
itself, rather than first taking the count of \f3hello\f1 as
was intended.
.sp 1
\f3sum\f1 \(em Operation, two inputs.  Infix: \f3+\f1
.IN
The output of this procedure is the sum of the two inputs.
.OU
\f3difference\f1 \(em Operation, two inputs.  Abbreviation: \f3diff\f1  Infix: \f3-\f1
.IN
The output of this procedure is the difference of the two inputs.
.OU
\f3product\f1 \(em Operation, two inputs.  Infix: \f3*\f1
.IN
The output of this procedure is the product of the two inputs.
.OU
\f3quotient\f1 \(em Operation, two inputs.  Infix: \f3/\f1
.IN
The output of this procedure is the quotient of the two inputs.  If both
inputs are integers, the output is also an integer; the remainder of the
division is lost.  If either input is not an integer, the quotient can
include a fractional part.  Therefore, these two are not the same:
.EX
quotient 2 3
quotient 2.0 3
.EC
.in -5
\f3remainder\f1 \(em Operation, two inputs.  Abbreviation: \f3mod\f1  Infix: \f3\\\f1
.IN
The inputs to this procedure must be integers.  The output is also an
integer, and is the remainder of dividing the first input by the
second.
.OU
\f3maximum\f1 \(em Operation, two inputs.  Abbreviation: \f3max\f1
.IN
The output of this procedure is equal to whichever of the two inputs
is numerically greater.
.OU
\f3minimum\f1 \(em Operation, two inputs.  Abbreviation: \f3min\f1
.IN
The output of this procedure is equal to whichever of the two inputs
is numerically smaller.
.OU
\f3greaterp\f1 \(em Operation (predicate), two inputs.  Infix: \f3>\f1
.IN
The output of this procedure is the word \f3true\f1 if the first input
is numerically strictly greater than the second input.  Otherwise the
output is the word \f3false\f1.
.OU
\f3lessp\f1 \(em Operation (predicate), two inputs.  Infix: \f3<\f1
.IN
The output of this procedure is the word \f3true\f1 if the first input
is numerically strictly less than the second input.  Otherwise the
output is the word \f3false\f1.
.OU
\f3equalp\f1 \(em Operation (predicate), two inputs.  Infix: \f3=\f1
.IN
The two inputs to this procedure may be any Logo objects.  If they
are numbers, then the output is the word \f3true\f1 if they are
numerically equal, \f3false\f1 if they are numerically unequal.  If
either input is not a number, then the output is the same as for the
procedure \f3is\f1: it is \f3true\f1 if the two inputs are identical,
\f3false\f1 if not.  For example, the numbers \f32\f1 and \f32.0\f1 are
numerically equal, but not identical.
.OU
\f3numberp\f1 \(em Operation (predicate), one input.
.IN
The input may be any Logo object.  The output is the word \f3true\f1 if
the input is a number, \f3false\f1 if not.
.OU
\f3zerop\f1 \(em Operation (predicate), one input.
.IN
The input must be a number.  The output is the word \f3true\f1 if the
input is numerically equal to zero, \f3false\f1 otherwise.
.OU
\f3random\f1 \(em Operation, no inputs.
.IN
The output from this procedure is an integer between 0 and 9, i.e.,
a single digit.  It is chosen randomly, so the output may be different
each time the procedure is used.
.OU
\f3rnd\f1 \(em Operation, one input.
.IN
The input must be a positive integer.  The output is a randomly
selected integer between 0 and one less than the input.
.OU
\f3sqrt\f1 \(em Operation, one input.
.IN
The input must be a nonnegative number.  The output is its square root.
.OU
\f3pow\f1 \(em Operation, two inputs.
.IN
The inputs must be numbers.  If the first is negative, the second must
be an integer.  The output is the first number raised to the power of
the second input.
.OU
\f3sin\f1 \(em Operation, one input.
.IN
The input must be numeric.  The output is the sine of the input, taken
in degrees, not radians.
.OU
\f3cos\f1 \(em Operation, one input.
.IN
The input must be numeric.  The output is the cosine of the input, taken
in degrees, not radians.
.OU
\f3arctan\f1 \(em Operation, one input.  Abbreviation: \f3atan\f1
.IN
The input must be numeric.  The output is the arctangent, in degrees, of
the input.
.OU
.ti +5
.UB "Primitive procedures for conditional execution."
The predicates
(like \f3wordp\f1) which we've mentioned above can be used to carry out
some command only if a condition is met.  The basic command for the
purpose is \f3if\f1:
.sp 1
\f3if\f1 \(em Command or operation, two or three inputs.
.IN
The first input to the \f3if\f1 procedure must be either the word \f3true\f1 or
the word \f3false\f1.  Typically, it is the output from a predicate.  The second
and (optional) third inputs are lists containing instruction lines.  The second
input is executed if the first input is \f3true\f1.  The third input, if any,
is executed if the first input is \f3false\f1:
.sp 1
.nf
\f3to greet :person
if equalp :person [Ronald Reagan] [print [Hi, turkey!]] \\
	[print sentence "Hi, :person]
end\f1
.fi
.sp 1
In that example, the first input to \f3if\f1 is the output from the expression
.br
\f3equalp :person [Ronald Reagan]\f1.
.sp 1
The \f3if\f1 procedure can be used as an operation, producing a value.  In this
case, the third input is required:
.sp 1
.nf
\f3print if equalp :person "Reagan ["Loser] ["Winner]\f1
.fi
.OU
\f3test\f1 \(em Command, one input.
.IN
The input must be the word \f3true\f1 or the word \f3false\f1.  The command
remembers its input for use in a later \f3iftrue\f1 or \f3iffalse\f1
command.  This is an alternative to \f3if\f1 which is useful if several
instructions are to be made conditional on the same condition.  The
remembered truth value is local to the current procedure, if any.
.OU
\f3iftrue\f1 \(em Command, one input.  Abbreviation: \f3ift\f1
.IN
The input must be an instruction list.  It is run if the most recent
\f3test\f1 command saved a \f3true\f1 value.
.OU
\f3iffalse\f1 \(em Command, one input.  Abbreviation: \f3iff\f1
.IN
The input must be an instruction list.  It is run if the most recent
\f3test\f1 command saved a \f3false\f1 value.
.OU
\f3both\f1 \(em Operation (predicate), two inputs.  Abbreviation: \f3and\f1
.IN
The two inputs must both be either \f3true\f1 or \f3false\f1.  The output
is \f3true\f1 if both inputs are \f3true\f1; otherwise the output is
\f3false\f1.
.OU
\f3either\f1 \(em Operation (predicate), two inputs.  Abbreviation: \f3or\f1
.IN
The two inputs must be either \f3true\f1 or \f3false\f1.  The output
is \f3true\f1 if at least one of the inputs is \f3true\f1; otherwise
the output is \f3false\f1.
.OU
\f3not\f1 \(em Operation (predicate), one input.
.IN
The input must be either \f3true\f1 or \f3false\f1.  The output is
\f3true\f1 if the input is \f3false\f1, and vice versa.
.OU
.ti +5
.UB "Primitive procedures for file input and output."
In the Unix
operating system, there are two steps in reading or writing files: first,
the file must be \f2opened\f1, thereby associating a "file descriptor"
(an integer) with the file name; second, the file descriptor is used
to specify the file for each read or write operation.  Logo has
primitive procedures for each of these steps.
.sp 1
\f3openread\f1 \(em Operation, one input.  Abbreviation: \f3openr\f1
.IN
The input to this procedure is a word, which must be a Unix filename.  It
can contain slashes to indicate directory names.  If the file can be
opened for reading, the output from the procedure is a file descriptor,
which should be stored in a variable for use in reading the file.  If the
file cannot be opened, an error results.
.OU
\f3fileread\f1 \(em Operation, one input.  Abbreviation: \f3fird\f1
.IN
The input must be a file descriptor, previously output by \f3openread\f1.  The
procedure reads one line from the file.  The output is the line, in the form
of a list.  (That is, the output is the file line as if enclosed in square
brackets in a program.)  If the end of the file has been reached, the output
is the empty word.  If the file line contains mismatched brackets, trouble
may result.
.OU
\f3fileword\f1 \(em Operation, one input.  Abbreviation: \f3fiwd\f1
.IN
The input must be a file descriptor, open for reading.  The procedure
reads one line from the file.  The output is that line, in the form of
a single word, including spaces and punctuation characters.  If the end
of the file has been reached, the output is the empty list.
.OU
\f3openwrite\f1 \(em Operation, one input.  Abbreviation: \f3openw\f1
.IN
The input must be a Unix filename.  The file is opened for writing
(replacing any previous version), if allowed, and the output is a file
descriptor, for use by file printing commands below.  If the file
cannot be opened, an error results.
.OU
.nf
\f3fileprint\f1 \(em Command, two inputs.  Abbreviation: \f3fip\f1
\f3filetype\f1 \(em Command, two inputs.  Abbreviation: \f3fity\f1
\f3filefprint\f1 \(em Command, two inputs.  Abbreviation: \f3fifp\f1
\f3fileftype\f1 \(em Command, two inputs.  Abbreviation: \f3fifty\f1
.fi
.IN
The first input must be a file descriptor previously output by
\f3openwrite\f1.  The second input is any object.  The second input
is printed (typed, fprinted, ftyped) into the file.
.OU
\f3close\f1 \(em Command, one input.
.IN
The input must be a file descriptor.  The file is closed.  This must
be done when you've finished reading or writing the file.
.sp 1
Sample program:
.sp 1
.nf
\f3make "fd openwrite "outfile
fileprint :fd "Hello.
close :fd\f1
.fi
.sp 1
This will create a file named \f3outfile\f1 containing the word \f3Hello.\f1
.OU
.ti +5
.UB "Primitive procedures for procedure exit."
A procedure written by
a user, in Logo, can be a command or an operation.  If it is an operation,
you must, in the procedure, say what its output should be.  If it is a
command, it can simply stop at the end of the procedure, or you can explicitly
make it stop before the end.
.sp 1
\f3output\f1 \(em Command, one input.  Abbreviation: \f3op\f1
.IN
This command is used in a user procedure which is meant to be an
operation.  The input to this command becomes the output from the
user procedure.  Please don't be confused by the fact that the user
procedure is an operation, while the \f3output\f1 primitive
procedure is a command used in that procedure.  Example:
.sp 1
.nf
\f3to nickname :person
if equalp :person [Peter Parker] [output "Spiderman]
if equalp :person [Lamont Cranston] [output "Shadow]
output first :person
end\f1
.fi
.OU
\f3stop\f1 \(em Command, no inputs.
.IN
This command is used in user procedures which are meant to be
commands.  It stops the user procedure.  (Note that it does not
stop all running procedures.  If user procedure A runs user procedure
B, a \f3stop\f1 command in procedure B returns to procedure A, which
continues after the point where procedure B was invoked.)
.OU
\f3toplevel\f1 \(em Command, no inputs.  Abbreviation: \f3top\f1
.IN
This command stops all running procedures.  The user at the terminal
is prompted to type another command.  This can be used when a user
procedure discovers some error condition and wants to abort the entire
program, for example.
.OU
.ti +5
.UB "Property lists."
It is possible to associate with any name a list
of "properties".  A property list contains property names and property
values.  For example:
.IN
.nf
.sp 1
\f3pprop "bh "firstname "Brian
pprop "bh "lastname "Harvey\f1
.fi
.OU
The form of a property list is
.EX
[name1 val1 name2 val2 name3 val3]
.EC
Although this data structure could be created using other Logo primitives,
special property list primitives are provided because they are faster.  The
property lists do not share storage with Logo variables, so you can change
the value of any property without having to recopy the entire property list
as you would ordinarily.  The following primitives manipulate property lists.
.sp 1
\f3pprop\f1 \(em Command, three inputs.
.IN
The first input, which must be a word, is a name with which a property list
is associated.  The second input, which must be a word, is the name of a
property.  The third input can be any Logo object.  It becomes the value
of the specified property of the specified name.
.OU
\f3gprop\f1 \(em Operation, two inputs.
.IN
Both inputs must be words.  The first is a name, and the second is a
property name.  The output is the value of the indicated property of the
indicated object.  It is not an error if there is no such property;
the output in that case is the empty list.
.OU
\f3remprop\f1 \(em Command, two inputs.
.IN
The inputs must be words, as for \f3gprop\f1.  The specified property
is removed from the specified name.
.OU
\f3plist\f1 \(em Operation, one input.
.IN
The input must be a word, which is a name.  The output is the property
list of the specified name.  Note: the output is actually a copy of the
property list.  The real property list is not a Logo list.  Any later
changes to the properties of the specified name will not change the
list which was output by an earlier \f3plist\f1.
.OU
\f3pps\f1 \(em Command, no inputs.
.IN
All properties of all names are listed on your terminal.
.OU
.ti +5
.UB "Pausing."
When you are debugging a complicated Logo program, it is
very helpful to be able to stop in the middle of a procedure, so that you
can give interactive commands to examine its inputs and other local
variables.  This is different from stopping a procedure, which destroys
its local environment.  There are three ways a procedure can pause:  (1) You
can include the command \f3pause\f1 in the procedure definition, to make the
procedure pause at a particular place you choose in advance; (2) you can
decide to pause a procedure while it is running by typing the system
"interrupt" character (this is control-C at Lincoln-Sudbury but is different
on other systems); or (3) you can arrange for an error in the processing of
the procedure to pause instead of stopping as it usually does.
.PP
Note that when you type the system "quit" character (control-G at
Lincoln-Sudbury) Logo does not pause, but returns to toplevel.  All
information about the local state of your active procedures is lost.
.PP
When you are paused, Logo accepts instructions from your terminal as it
does at toplevel, but local variables can be examined or modified.  To let
you know that you are paused, Logo prompts with the characters "\f3-*\f1"
instead of just "\f3*\f1" as usual.  It is possible to pause within a
procedure within a pause; in this case your prompt is "\f3--*\f1" to
indicate two levels of pause.  This can be continued to higher levels.
.PP
To get out of a pause, there are three things you can do.  You can give the
command \f3toplevel\f1, which stops all pending procedures and returns to
interactive top level.  You can give the command \f3stop\f1 or the command
\f3output\f1 with an input, which will terminate the current procedure
(without or with an output respectively) and return to its calling
procedure.  Or you can give the command \f3continue\f1, which will resume
the procedure at the point where you paused.
.sp 1
\f3pause\f1 \(em Command, no inputs.
.IN
This command is meaningful only within a procedure.  It causes a pause.
.OU
\f3continue\f1 \(em Command, no inputs.  Abbreviation: \f3co\f1
.IN
This command is meaningful only when typed during an interactive pause.  It
continues the current procedure from where it was paused.
.OU
\f3errpause\f1 \(em Command, no inputs.
.IN
This command tells Logo that any errors which happen during procedure
execution from now on should cause a pause, rather than a return to
toplevel.
.OU
\f3errquit\f1 \(em Command, no inputs.
.IN
This command tells Logo that any errors which happen during procedure
execution from now on should return to toplevel, rather than pausing.  This
is the initial state of affairs when you start Logo.
.OU
\f3setqpause\f1 \(em Command, no inputs.
.IN
This command tells Logo that from now on, the system quit character should
pause, and the system interrupt character should return to toplevel.  This
is the reverse of the usual interpretation.  This command is provided for
people whose systems or keyboards make one of these characters easier to
type than the other.  In particular, under Eunice there is only an interrupt
character, not a quit character.
.OU
\f3setipause\f1 \(em Command, no inputs.
.IN
This command tells Logo that from now on, the system interrupt character
should pause, and the system quit character should return to toplevel.  This
is the initial state of affairs when you start Logo.
.OU
.ti +5
.UB "Miscellaneous primitives."
The remaining primitives are one
of a kind, or very obscure, or both.
.sp 1
\f3goodbye\f1 \(em Command, no inputs.  Abbreviation: \f3bye\f1
.IN
This command is used to leave Logo.  It is the only way out, unless
there is a bug somewhere.
.OU
\f3thing\f1 \(em Operation, one input.
.IN
The input must be a word, and must be the name of a variable.  The
output is the value of the variable.  These are equivalent:
.sp 1
.nf
\f3:foo
thing "foo\f1
.fi
.OU
\f3namep\f1 \(em Operation (predicate), one input.
.IN
The input must be a word.  The output is \f3true\f1 if that word is the
name of a variable which has a value assigned to it, \f3false\f1 otherwise.
.OU
\f3wait\f1 \(em Command, one input.
.IN
The input must be a positive integer.  Logo waits that many seconds
before continuing.
.OU
\f3trace\f1 \(em Command, no inputs.
.IN
This command is used for debugging your Logo programs.  After you use
this command, every time a user-defined procedure starts or stops, a
message is typed at your terminal naming the procedure and its inputs
or its output, if any.  The message is indented according to the depth
in procedure calls.
.OU
\f3untrace\f1 \(em Command, no inputs.
.IN
This command turns off the trace messages started by the \f3trace\f1
command.
.OU
\f3unix\f1 \(em Command, one input.
.IN
The input must be a Unix shell command, which is carried out in a
forked shell.  (/bin/sh is used, not csh.)  Example:
.sp 1
.nf
\f3to whois :user
unix (sentence "grep (word "'^ :user ":') "/etc/inquir)
end\f1
.fi
.OU
\f3run\f1 \(em Command or operation, one input.
.IN
The input must be a list, containing a Logo instruction line.  The list is
run as if you typed it directly to Logo.  Example:
.sp 1
.nf
\f3to while :condition :cmd
if not run :condition [stop]
run :cmd
while :condition :cmd
end
.sp 1
make "number 1
while [:number < 5] [print :number; make "number :number+1]\f1
.fi
.sp 1
The \f3run\f1 procedure can be used as an operation, if its input is a Logo
expression which produces a value, instead of a complete instruction:
.sp 1
\f3print run [sum 2 3]\f1
.OU
\f3repeat\f1 \(em Command, two inputs.
.IN
The first input must be a positive number.  The second is an instruction list,
as for the \f3run\f1 command.  The list is run repeatedly, the number of times
specified by the first input:
.sp 1
\f3repeat 5 [print "hello]\f1
.OU
\f3repcount\f1 \(em Operation, no inputs.
.IN
This operation may be used only within the range of a repeat command.  It
outputs the number of repetitions which have been done, including the current
one.  That is, it outputs 1 the first time through, 2 the second time, and
so on.
.OU
\f3cbreak\f1 \(em Command, one input.
.IN
The input must be either the word \f3on\f1 or the word \f3off\f1.  If
the input is \f3on\f1, your terminal is placed in cbreak mode, which
means that what you type is made available to your program every
character, rather than every line.  This must be done before the
\f3readchar\f1 procedure, below, will work.  This facility is good for
writing video game programs or text editors.  While in cbreak mode, echo
is turned off also.
.OU
\f3readchar\f1 \(em Operation, no inputs.  Abbreviation: \f3rc\f1
.IN
This operation waits for you to type a single character at your terminal.  The
output is a word containing only that character.  This works only if you
have turned on cbreak mode; see above.
.OU
\f3keyp\f1 \(em Operation (predicate), no inputs.
.IN
This procedure outputs \f3true\f1 if there is a character waiting to
be read from the terminal, if you are in cbreak mode.  If not, it
outputs \f3true\f1 if there is an entire line waiting to be read.
.OU
\f3oflush\f1 \(em Command, no inputs.
.IN
Normally, when you tell Logo to print something, the printing is not done
right away.  Instead, Logo remembers everything you tell it to print, and the
printing is done all at once the next time Logo is waiting for you to type
something.  This arrangement makes Logo much faster than it would be if
everything were printed immediately.  The \f3oflush\f1 command tells Logo to
print whatever you've previously asked for right away, without waiting.
.OU
\f3help\f1 \(em Command, no inputs.
.IN
This command types at your terminal a brief message about Logo and
how to use it.
.OU
\f3describe\f1 \(em Command, one input.
.IN
The input must be the name of a Logo primitive procedure.  A brief
explanation of that primitive is typed at your terminal.
.OU
\f3go\f1 \(em Command, one input.
.IN
This command can be used only inside a procedure.  The input must be a
number.  The same number must appear at the beginning of some line in
the same procedure.  (This line number is otherwise ignored.)
The next command executed will be
the one on the indicated line in the definition.  Note: there is always
a better way to do it.  If you have previously programmed in BASIC, your
only hope of ever really learning how to program computers is NEVER EVER
to use the \f3go\f1 command!
.OU
\f3debquit\f1 \(em Command, no inputs.
.IN
This command is meant to be used only for debugging Logo itself.  It is
explained here only for completeness.  After this command is used, the
QUIT signal is not caught by Logo, so it will cause a core dump.
.OU
\f3memtrace\f1 \(em Command, no inputs.
.IN
This command is meant to be used only for debugging Logo itself.  It is
explained here only for completeness.  After this command is used, every
allocation or deallocation of memory, and every character parsed by the
interpreter, types an incomprehensible message at your terminal.
.OU
\f3yaccdebug\f1 \(em Command, no inputs.
.IN
This command is meant to be used only for debugging Logo itself.  It is
explained here only for completeness.  After this command is used, every
state transition in the yacc parser types an incomprehensible message
at your terminal.
.OU
.ti +5
.UB "The Logo library."
The directory /usr/lib/logo contains Logo
procedures which are available to all users.  They are not listed by
\f3pots\f1, but can be thought of as pseudo-primitives which happen to
be written in Logo.  Some of these procedures are only useful in conjunction
with the teaching units used in Introduction to Computers, but others are
generally useful.  This manual does not fully document the Logo
library, because it changes
too often.  Look through the /usr/lib/logo directory yourself if you want.
The procedures
\f3listp\f1, \f3home\f1, \f3pos\f1, \f3setpos\f1, \f3towards\f1, \f3setx\f1,
and \f3sety\f1 in the library are provided for partial compatibility with
Apple Logo.
  