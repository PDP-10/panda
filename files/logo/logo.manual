

                               LSRHS Logo Manual


       Introduction.  Logo is  a  computer  programming  language  which  was
  designed  to be both simple to use and extremely powerful.  It was designed
  by a group of computer scientists at MIT and at Bolt, Beranek, and  Newman.
  Its  structure  is based largely on the LISP language, which is widely used
  in Artificial Intelligence research, but the notation has been  changed  to
  make  Logo  far  easier  for a beginner than LISP.  This manual describes a
  version of Logo for the PDP-11, originally  written  in  C  at  the  Boston
  Children's  Museum and extensively modified at the Lincoln-Sudbury Regional
  High School.

       The power of Logo comes primarily from the idea of the  procedure.   A
  procedure  is  simply  something  the computer "knows" how to do; some pro-
  cedures are built into Logo itself (these are called primitive procedures),
  while  others  are  defined by the programmer in terms of these simple pro-
  cedures.  Defined procedures can be used as part of the definition of other
  procedures,  so that a complicated program can be built in "layers" of com-
  plexity.  This layered structure is analogous to the description of a  com-
  plex  machine  in  terms  of  building  blocks:  an automobile is made of a
  chassis, a drive train, an electrical system, and so on.  The  drive  train
  contains  an  engine,  a  transmission,  a clutch, an axle, and so on.  The
  transmission contains a housing, gears, and levers.  A  lever  may  include
  connecting  joints  at  the  ends  and  at  a  pivot point.  Eventually the
  description of the automobile reaches the level of bolts and washers; these
  correspond to the primitive procedures in Logo.

       Starting_Logo.  Use the shell command logo to start  the  Logo  inter-
  preter.   When  Logo is running it will print an asterisk (*) at the begin-
  ning of a line to indicate that it is ready for you to type in a  Logo  in-
  struction.   The instruction may print something on the terminal, or draw a
  line on a graphics display screen, or move a turtle around the floor.  Then
  another  asterisk  is typed and you may give another instruction.  (If Logo
  prints a "greater than" sign (>) instead of an asterisk, it is in procedure
  definition  mode,  which  will  be  described later.  Type your system quit
  character (control-G at Lincoln-Sudbury) to return to normal mode.)

       If an argument is used with the shell command logo,  the  argument  is
  taken  as  the  name  of a procedure, which Logo runs before doing anything
  else.  You can therefore create a shell script which will start Logo, run a
  procedure  automatically,  and (if you say "goodbye" at the end of the pro-
  cedure) exit.

       Syntax.  Unlike most computer languages, Logo has an  almost  entirely
  uniform  syntax.   That  is, all of the different commands Logo understands
  are represented using the same notation: the name of a  procedure  is  fol-
  lowed  by  its inputs, which may be constants (like numbers) or else may be
  the results of using other procedures.  Here is a simple example:

       print "hello

  In this Logo instruction, the primitive procedure print is used with a con-
  stant  input,  the  word hello.  The quotation mark indicates that hello is
  being used to represent the word itself;  without  the  quotation  mark  it
  would  have  been  interpreted as the name of a procedure, just as print is
  the name of a procedure.  In Logo, the print procedure always requires  ex-
  actly  one input, which is the thing to print.  The input can be a word, as

                                       1






  in this example, or a list, which will be explained later.  (A number is  a
  special  case of a word, and a sentence is a special case of a list.)  Here
  is another example:

       print first "hello

  In this instruction, the primitive procedure first is used.  This procedure
  takes one input, a word, and has an output which is the first letter of the
  word.  The output from first is used as the input  to  print,  so  what  is
  printed  is the letter h rather than the word hello as in the earlier exam-
  ple.

       Don't confuse the output from a procedure with what is printed by  the
  print  command.  In Logo, the word "output" is not used to refer to what is
  printed by a program, just as the word "input" does not mean something  you
  type  into  the  program.   Instead, these words refer to objects (words or
  lists) which are given to a procedure (inputs) or produced by  a  procedure
  (outputs).   A  particular  procedure has a fixed number of inputs and out-
  puts.  The number of inputs may be anything, including  zero,  whereas  the
  number  of outputs is either zero or one.  A procedure with an output (like
  first) is called an operation; one without an output (like print) is called
  a command.

       Some operations only have two possible outputs: the word true and  the
  word  false.   Such a procedure is called a predicate.  Predicates are used
  to allow a program to carry out some instruction only if a particular  con-
  dition  is met.  By convention, predicates generally have names ending with
  the letter "p".

       Multiple_inputs_to_operations.  Several Logo primitive procedures  are
  operations with two inputs.  The arithmetic operations, like sum, are exam-
  ples of this.  A special extension to Logo syntax allows such an  operation
  to  have  more than two inputs by enclosing the operation and its inputs in
  parentheses or braces:

       (sum 2 5 13 8.5)

  Association is right to left.  At least two inputs must  be  given,  except
  for the list operation, which can take one input if parenthesized.

       Multi-instruction_lines.  It is possible to put more than one instruc-
  tion  on  the  same  line  when you are typing to Logo.  To do this, type a
  semicolon (;) between the instructions:

       print "hello; print "goodbye

  Later in this manual, the phrase "instruction line" will mean one  or  more
  instructions on a line.

       Multi-line_instructions.  It is possible to continue an instruction on
  a  second  line.   To do this, end the first line with a backslash (\), im-
  mediately followed by the RETURN key.  If you are typing a quoted word, you
  must  end  the word (with a space, for example) before using the backslash-
  RETURN combination.  Inside a quoted word, backslash-RETURN means to put an
  actual RETURN as part of the word.

       Comments.  It is possible to include in an instruction  line  comments
  which are meant for human readers of your program (including yourself, next

                                       2






  week), and which are not Logo instructions.  To do this, begin the  comment
  with  an  exclamation point (!).  Everything after the exclamation point on
  the line will be ignored by Logo.  For example:

       print [Hi, there.] ! A friendly greeting.

  However, the exclamation point does not begin a comment if it is part of  a
  word  or  list (see below).  You should type a space before the exclamation
  point, as in the example above, to make sure it will be interpreted as  the
  beginning of a comment.

       Words.  Every computer language deals with  particular  kinds  of  ob-
  jects.   Most languages, like FORTRAN or BASIC or Pascal, are best at deal-
  ing with numbers.  Logo is a list processing language, which is at its best
  with  more  complicated data structures.  The two main categories of object
  are the word and the list.

       A word is a string of characters.  (A character is  a  letter,  digit,
  space,  or  punctuation  mark.   Things like TAB and RETURN on the terminal
  keyboard are also characters, although they are not usually used as part of
  Logo  words.)   A word can be any length, including zero.  The way to indi-
  cate a word as part of a Logo program is to use the quotation mark (")  be-
  fore the word.  The word begins with the character after the quotation mark
  and continues until a space, a tab, the end of the line, or  one  of  these
  characters:

       ( ) [ ] { } " ;

  A quotation mark immediately followed by a space or one of the other  word-
  terminating  characters indicates the empty word, which is a word of length
  zero.

       Please notice that, unlike most programming languages, Logo  does  not
  use quotation marks in pairs to delimit strings of characters.  The follow-
  ing instruction is an error:

       print "aardvark"

  This is an error because the print command is followed by  two  words,  the
  word  aardvark and an empty word which is indicated by the second quotation
  mark.  Since print only uses one input, the second word has no purpose, and
  Logo gives the error message

       There's something extra on the line.
       print takes only one input.

       In order to include one of the word-terminating characters in a  word,
  you  must  precede  it with a backslash (\).  Do not confuse backslash with
  the regular slash (/) character.  For example, this instruction:

       print "\(boo\)

  will print the five characters (boo) as its result.   The  space  character
  may  be  included  in  a  word by using a percent (%) instead of the space.
  Therefore, the following are equivalent:

       print "Hello%there.
       print "Hello\ there.

                                       3







  To include a percent character or a backslash character in a word, you must
  precede it with a backslash.

       Numbers.  A number is a special case of a word, in which  the  charac-
  ters  are  all  digits.  (That definition isn't quite complete, and will be
  expanded in the next paragraph.)  A number need not be preceded with a quo-
  tation mark.  (This rule is possible because normally Logo interprets words
  without quotation marks as the names of procedures, but there are  no  pro-
  cedures  whose  names begin with digits.)  If a quotation mark is not used,
  then any nondigit terminates the word.

       Actually, numbers may be written in  scientific  notation.   That  is,
  they  can  include  signs,  decimal  points, and a power of 10 by which the
  number is multiplied.  This exponent is indicated by the letter e  followed
  by the integer power of 10.  The following numbers have the same value:

       1000
       "1000
       1000.00
       1e3
       10.0e+2
       "+1.0e3
       10000e-1

  Notice that if the number begins with a sign it must be quoted.   A  quoted
  number still must begin with a digit or a sign, not with a decimal point or
  a letter e.  (The letter may be a capital E, by the way.)  If a  number  is
  quoted,  it must end with one of the normal word-terminating characters.  A
  number which contains only digits (no decimal point or exponent) is  called
  an  integer.   Note that a number with a decimal point is not considered an
  integer even if the digits after the decimal point are all zero.

       Since a number is a word, the usual character-manipulating  procedures
  may be applied to it.  For example,

       print first 1024

  prints the digit 1 which is the first character of the  number.   In  addi-
  tion, there are arithmetic procedures which apply specifically to numbers:

       print sum 3 2

  prints the number 5.  These procedures will be listed later.

       Lists.  A word can be thought of as a list of characters; for example,
  the  word hello is a list of five letters.  In Logo it is possible to mani-
  pulate not only lists of characters but also lists of words, lists of lists
  of  words, and so on.  This is a very powerful capability which allows very
  complicated data structures to be manipulated easily.  To indicate  a  list
  in  a  program,  you  put  square  brackets  ([ and ]) around the list, and
  separate the list elements with spaces.  For example:

       print [This is a list of seven words.]

  A list all of whose elements are words is called a sentence.   Here  is  an
  example of a list which is not a sentence:


                                       4






       print [[This is a list][of two sentences.]]

       Within a bracketed list,  square  brackets  delimit  sub-lists  (lists
  which are elements of the main list).  The quotation mark, parentheses, and
  braces are not considered special within a bracketed list, unlike the rules
  for  quoted  words.  A list may extend over more than one line; that is, if
  you have typed an open square bracket ([) and have not yet typed the match-
  ing  close  square bracket, the Logo instruction is not ended by typing the
  RETURN key.

       Variables.  A variable is an entity which has a name, which is a word,
  and a thing (also called a value), which can be any Logo object.  Variables
  are used to "remember" a computed object for repeated or delayed use  in  a
  program.   In Logo, the most common way that a variable acquires a value is
  that it is associated with an input to a user-written  procedure.   In  the
  following  example, don't worry about the details of the format of the pro-
  cedure, which will be explained later:

       to pff :sentence
       print first first :sentence
       end

  This is the definition of a command with one input.  The name of  the  com-
  mand  is pff.  It has one input because in the "title line" (the one start-
  ing to pff) there is one variable name after the command name.   The  vari-
  able whose name is sentence is associated with the first (and only, in this
  case) input to pff.  In the line starting with the word print, the notation
  :sentence  means  "the  thing of the variable whose name is sentence".  (To
  refer to the name itself, quote it as you would any word.)   If  this  pro-
  cedure is used in a Logo instruction like this:

       pff [This is the poop.]

  then the variable sentence has the value [This is the poop.].

       It is also possible to assign a value to a  variable  by  an  explicit
  Logo instruction.  There is a primitive procedure to do this:

  make - Command, two inputs.
       The first input is the name of a variable  (that  is,  it  must  be  a
       word); the second is any Logo object.  The effect of the command is to
       assign the second input as the value of  the  variable  named  by  the
       first input.

  If you are accustomed to programming  in  a  non-procedural  language  like
  BASIC,  you should strenuously avoid the temptation to overuse make; expli-
  cit assignment is almost always the wrong  thing  to  do  in  Logo.   Total
  abstention is the best policy for a Logo beginner.

       In Logo, variables are dynamically scoped.  That means that a variable
  can "belong to" a particular procedure; such a variable can be used by that
  procedure and by any procedure which is used by an instruction  within  the
  procedure,  but  is not available to the procedure which invoked the owning
  procedure.  In other words, such a local variable comes into being when the
  owning procedure starts running, and disappears when that procedure is fin-
  ished.  It is possible for a procedure with a local variable to use another
  procedure  with a local variable of the same name.  In that case, the vari-
  able belonging to the "inner" procedure is the one which is associated with

                                       5






  the  name  as  long as it exists; when the inner procedure is finished, the
  "hidden" variable belonging to the outer procedure is again available.

       A variable which is associated with the input to a  procedure  is  au-
  tomatically  local to that procedure.  Other variables are normally global:
  they are "permanent" and do not disappear when the procedure in which  they
  get  their  values  finish.  It is both possible and desirable to make such
  variables local, by an explicit instruction to that effect:

  local - Command, one input.
       The input must be a word.  A variable with that word as  its  name  is
       created,  local  to the currently running procedure (that is, local to
       the procedure in which the local command is used).

  The virtue of local variables is that they make procedures more independent
  of  one another than they would be if global variables were used.  In other
  words, if you use local variables consistently, then nothing  that  happens
  in  one  procedure will change the values of variables used in another pro-
  cedure.  This makes it very much easier to find program errors.

       Primitive_procedures_to_define_user_procedures.  There are two ways to
  define  your own procedure.  The first way, using the to command, is simple
  to learn but limited in flexibility.  The second way, using the  edit  com-
  mand,  is  more  complicated to learn, but makes it easy to make changes in
  your procedures.  The edit command uses the text editing program edt,  just
  as  you  might use it outside of Logo to edit a document you want to print.
  Once you've learned the special editing commands in edt, it's easy to  use.
  The  to command makes it possible to begin programming in Logo without hav-
  ing learned how to use edt.  It just lets you type in your procedure defin-
  ition,  without any provision for correcting errors or changing the defini-
  tion of the procedure.  It is fast and convenient for short procedures, but
  limited.

  The to command is unique, in Logo, in that its inputs are interpreted in  a
  special  way.  The inputs aren't evaluated: Logo doesn't run any procedures
  you name, or look up the values of any variables, before carrying  out  the
  to command.  The example below should make this clearer.

  to - Command, special form, see below.
       This command takes a variable number of inputs.  The first is the name
       of  a  procedure to be defined.  The rest, if any, must be preceded by
       colons, and are the names of variables to be used  as  inputs  to  the
       procedure.   Logo  responds  to  the to command by printing a "greater
       than" sign (>) prompt, to show you that you are defining  a  procedure
       rather  than  entering  commands to be executed immediately.  You type
       the instruction lines which make up the definition.  When you are done
       with  the  definition,  type the special word end on a line by itself.
       For example:

       *to twoprint :thing
       >print :thing
       >print :thing
       >end
       *

       This example shows the definition of a procedure named twoprint, which
       has  one  input, named thing.  The procedure you are defining with the
       to command must not already be defined.

                                       6






  edit - Command, zero or one input.  Abbreviation: ed
       The input to this command must be a word, which is the name of a  pro-
       cedure,  or a list of words, each of which is the name of a procedure.
       (Unlike the to command, but like all other Logo procedures,  the  edit
       command  evaluates  its input, so you must use a quotation mark before
       the procedure name, if only one is given, to indicate that it  is  the
       name  itself which is the input to edit; otherwise Logo would actually
       run the procedure to calculate the input to edit.)  The procedure  you
       name  may  or  may  not already be defined.  Logo responds to the edit
       command by running the text editor edt, editing the definition of  the
       procedure(s)  named  in its input.  (If a procedure was not previously
       defined, Logo creates an initial definition for it which contains only
       a  title  line and the end line.) You then edit the definition(s) with
       edt.  When you write the file and leave edt, Logo will use the  edited
       file  as the definition(s) of the procedure(s).  You must not put any-
       thing in the file except procedure definitions; in other words,  every
       nonempty  line  in  the  file must be between a "to" line and an "end"
       line.

       If the edit command is given with no input, edt is given the same file
       as  from  the last time you used the edit command.  This is a conveni-
       ence for editing the same procedure(s) repeatedly.

       If, while editing, you change your mind and want to leave edt  without
       redefining  anything, use the command ESC ^Z instead of the normal ^Z.
       This special way of leaving edt tells Logo not to redefine  your  pro-
       cedures.   You  have the choice, before exiting edt, of writing or not
       writing the temporary file which contains  the  definitions.   If  you
       don't  write the file, another edit command with no input will re-read
       the previous contents of the temporary file; if you do,  another  edit
       will re-read the new version.

       If your Unix environment contains a variable named  EDITOR,  the  con-
       tents  of that variable is used as the name of the text editor program
       instead of the standard edt.  The variable can contain  a  full  path-
       name,  or  just  a program name if the program can be found in /bin or
       /usr/bin.  Your favorite editor may not have a facility like edt's ESC
       ^Z to abort redefinition.

  show - Command, one input.  Abbreviation: po
       The input to this command is a word or a list  of  words.   Each  word
       must  be  the  name  of  a  procedure.   The  command  prints  out the
       definition(s) of the procedure(s) on your terminal.  (The abbreviation
       po  stands  for  printout,  which is the name used for this command in
       some other versions of Logo.)

  pots - Command, no inputs.
       This command types at your terminal the title lines of all  procedures
       you've defined.  The name is an abbreviation for "print out titles".

  erase - Command, one input.  Abbreviation: er
       As for the show command, the input is either a word, naming  one  pro-
       cedure,  or  a  list  of  words, naming more than one.  The named pro-
       cedures are erased, so that they are no longer defined.

       Primitive_procedures_to_manipulate_words_and_lists.  There are  primi-
  tive  procedures  to  print text objects on the terminal, to read them from
  the terminal, to combine them into  larger  objects,  to  split  them  into

                                       7






  smaller objects, and to determine their size and nature:

  print - Command, one input.  Abbreviation: pr
       The input, which may be a word or a list, is printed on the  terminal,
       followed  by  a  new  line character.  (That is, the terminal is posi-
       tioned at the beginning of a new line after printing the object.)   If
       the  object is a list, any sub-lists are delimited by square brackets,
       but the entire object is not delimited by brackets.

  type - Command, one input.
       The input, which may be a word or a list, is printed on the  terminal,
       without  a  new  line character.  (That is, the terminal remains posi-
       tioned at the end of the object after printing it.)  Brackets are used
       as with the print command.

  fprint - Command, one input.  Abbreviation: fp
       The input is printed as by the print command, except that if it  is  a
       list  (as  opposed  to a word) it is enclosed in square brackets.  The
       name of the command is short for "full print".

  ftype - Command, one input.  Abbreviation: fty
       The input is printed as by the type command, except that if  it  is  a
       list, it is enclosed in square brackets.

  readlist - Operation, no inputs.  Abbreviation: rl
       Logo waits for a line to be typed by the user.  The  contents  of  the
       line  are  made into a list, as though typed within square brackets as
       part of a Logo instruction.  (The user should not actually type brack-
       ets  around the line, unless s/he desires a list of one element, which
       is a list itself.)  That list is the output from the operation.

  request - Operation, no inputs.
       A question mark is printed on the terminal as  a  prompt.   Then  Logo
       waits for a line to be typed by the user, as for readlist.

  word - Operation, two inputs.
       The two inputs must be words.  The output is a word which is the  con-
       catenation  of  the two inputs.  There is no space or other separation
       of the two inputs in the output.

  sentence - Operation, two inputs.  Abbreviation: se
       The two inputs may be words or lists.  The output  is  a  list  formed
       from  the two inputs in this way: if either input is a word, that word
       becomes a member of the output list; if either input is  a  list,  the
       members of that input become members of the output.  Here are some ex-
       amples:

            first input         second input        output
            "hello              "test               [hello test]
            "goodbye            [cruel world]       [goodbye cruel world]
            [a b]               [c d]               [a b c d]
            []                  "garply             [garply]

       If an input is the empty list, as in the last example above,  it  con-
       tributes nothing to the output.

  list - Operation, two inputs.
       The output is a list of two elements, namely, the two inputs.  The in-

                                       8






       puts may be words or lists.

  fput - Operation, two inputs.
       The first input may be any Logo object; the second  must  be  a  list.
       The  output  is a list which is identical with the second input except
       that it has an extra first member, namely, the first input.

  lput - Operation, two inputs.
       The first input may be any Logo object; the second  must  be  a  list.
       The  output  is a list which is identical with the second input except
       that it has an extra last member, namely, the first input.

  first - Operation, one input.  Abbreviation: f
       The input may be any non-empty Logo object.  If the input is  a  list,
       the output is its first member.  If the input is a word, the output is
       a single-letter word, namely the first letter of the  input.   If  the
       input is empty (a word or list of length zero) an error results.

  last - Operation, one input.  Abbreviation: l
       The input may be any non-empty Logo object.  If the input is  a  list,
       the  output is its last member.  If the input is a word, the output is
       a single-letter word, namely the last letter of the input.  If the in-
       put is empty (a word or list of length zero) an error results.

  butfirst - Operation, one input.  Abbreviation: bf
       The input may be any non-empty Logo object.  If the input is  a  list,
       the output is a list equal to the input list with the first member re-
       moved.  (If the input list has only one member, the output is the emp-
       ty  list, a list of zero members.)  If the input is a word, the output
       is a word equal to the input word with the first letter removed.   (If
       the  input is a single-letter word, the output is the empty word.)  If
       the input is empty, an error results.

  butlast - Operation, one input.  Abbreviation: bl
       The input may be any non-empty Logo object.  If the input is  a  list,
       the  output is a list equal to the input list with the last member re-
       moved.  (If the input list has only one member, the output is the emp-
       ty  list, a list of zero members.)  If the input is a word, the output
       is a word equal to the input word with the last letter  removed.   (If
       the  input is a single-letter word, the output is the empty word.)  If
       the input is empty, an error results.

  count - Operation, one input.
       The input may be any Logo object.  If the input is a list, the  output
       is a number indicating the number of members in the list.  (Note: only
       top-level members are counted, not members of members.  The  count  of
       the list

            [[This is] [a list]]

       is 2, not 4.)  If the input is a word, the output  is  the  number  of
       letters  (or  other  characters) in the word.  Remember that in Logo a
       number is just a particular kind of word, so the output from count can
       be manipulated like any other Logo word.

  emptyp - Operation (predicate), one input.
       The input can be any Logo object.  The output is the word true if  the
       input  is  of  length  zero  (i.e.,  it is the empty word or the empty

                                       9






       list).  The output is the word false otherwise.

  wordp - Operation (predicate), one input.
       The input can be any Logo object.  The output is the word true if  the
       input is a word.  The output is the word false if the input is a list.

  sentencep - Operation (predicate), one input.
       The input can be any Logo object.  The output is the word true if  the
       input  is  a  sentence, i.e., a list of words.  The output is the word
       false if the input is a word, or if any member of the input is a list.

  is - Operation (predicate), two inputs.
       The inputs can be any Logo objects.  The output is the  word  true  if
       the  two inputs are identical.  That is, they must be of the same type
       (both words or both lists), they must have the same count,  and  their
       members  (if  lists) or their characters (if words) must be identical.
       The output is the word false otherwise.  (Note: this is  an  exception
       to the convention that names of predicates end with the letter "p".)

  memberp - Operation (predicate), two inputs.
       If the second input is a word, the first  input  must  be  a  word  of
       length one (a single character), and the output is true if and only if
       the first input is contained in the second as  a  character.   If  the
       second  input  is  a list, the first input can be any Logo object, and
       the output is true if and only if the first input is a member  of  the
       second input.  (Note that this is member, not subset.)

  item - Operation, two inputs.  Abbreviation: nth
       The first input must be a positive integer less than or equal  to  the
       count  of the second input.  If the second input is a word, the output
       is a word of length one containing the  selected  character  from  the
       word.   (Items  are numbered from 1, not 0.)  If the second input is a
       list, the output is the selected member of the list.

       Primitive_procedures_for_turtles_and_graphics.  An important  part  of
  the  Logo  environment  is a rich set of applications to which the computer
  can be directed.  The most important of these is turtle geometry, a way  of
  describing paths of motion in a plane which is well-suited to computer pro-
  gramming.  There are two ways to use the turtle procedures.  First, you can
  control  a floor turtle, a small robot which can move one the floor or on a
  table under computer control.  Second, you can use a display turtle to draw
  pictures on the TV screen of a graphics terminal.

       Each computer center has a  different  variety  of  graphics  hardware
  available.  Floor turtles are very different from display turtles, but also
  each kind of display terminal has different characteristics.  For  example,
  some  terminals  can  draw  in several colors; others can't.  The following
  descriptions of graphics primitives explain the "best" case  for  each  one
  and mention restrictions on some graphics devices.

       The floor turtle can draw pictures on paper, because it has a pen  at-
  tached to its "belly": the underside of the turtle.  Since it is a mechani-
  cal device, however, it is not very precise; the pictures you get  may  not
  be exactly like what your program specifies.  A more interesting way to use
  the floor turtle is to take advantage of its touch sensors.  Switches under
  the  turtle's dome allow the computer to know when the turtle bumps into an
  obstacle.  You can use this information to write  programs  to  get  around
  obstacles or to follow a maze.

                                      10






       The display turtle lives on the surface of a TV screen.  It  can  draw
  pictures  more  precisely  than the floor turtle, since it does not measure
  distances and angles mechanically.  It is also faster than the  floor  tur-
  tle.   When  using the display turtle, remember that it interprets commands
  relative to its own position and direction, just as the floor turtle  does.
  The  command left, for example, turns the turtle to its own left, which may
  or may not be toward the left side of the TV screen.

  turtle - Command, one input.  Abbreviation: tur
       The input is the name of a turtle.  You can only control one turtle at
       a time, so using this command a second time releases the turtle previ-
       ously selected.  The names of floor turtles are numbers like 0 and  1.
       If  you are using a graphics display terminal (not just a text display
       trminal), you can control the display turtle by using the word display
       (or  the  abbreviation  dpy)  as the turtle name.  (As usual, the word
       must be preceded by a quotation mark.)  If you use a  graphics  primi-
       tive without selecting a turtle, Logo assumes that you want to use the
       display turtle.  But once you select a floor turtle, you must say tur-
       tle "display explicitly to switch to the display.

       The word off as input to the turtle command releases a  floor  turtle,
       if  you  have  one, or turns off the graphics display if you have been
       using the display turtle.  This also happens when you leave Logo.

  forward - Command, one input.  Abbreviation: fd
       The input is a number, the distance you would like the turtle to move.
       For a floor turtle, the unit of distance is however far the turtle can
       travel in 1/30 second.  For a display turtle, the unit is one  dot  on
       the  TV screen.  (Note: on some displays, one dot horizontally may not
       be the same length as one dot vertically.  The setscrunch command  al-
       lows  you  to  control  the  relative  sizes  so that squares come out
       square.)  The turtle moves in whatever direction it is  pointing  when
       you use the command.

  back - Command, one input.  Abbreviation: bk
       The input is a number, a distance to move, as in the forward  command.
       The  difference is that the turtle moves backward, i.e., in the direc-
       tion exactly opposite to the way it's pointing.

  left - Command, one input.  Abbreviation: lt
       The input is a number, the number of degrees of  angle  through  which
       the turtle should turn counterclockwise.  This command does not change
       the position of the turtle, but merely its heading (the  direction  in
       which it points).  The turn will be only approximately correct for the
       floor turtle, because of mechanical errors.  For the  display  turtle,
       the  angle  will  be  perfectly reproducible, although it may not look
       quite right on the screen because of the difference  in  size  between
       horizontal  and vertical dots.  Nevertheless, a display turtle program
       will work in the sense that when the turtle is supposed to  return  to
       its starting point, it will do so.

  right - Command, one input.  Abbreviation: rt
       The input is a number; the turtle turns through the  specified  number
       of degrees clockwise.

  penup - Command, no inputs.  Abbreviation: pu
       This command tells the turtle to raise its pen from the paper, so that
       it  does  not leave a trace when it moves.  In the case of the display

                                      11






       turtle, there is no physical pen to move mechanically, but the  effect
       is the same: any forward or back commands after this point do not draw
       a line.  The floor turtle starts with its pen up; the  display  turtle
       starts with its pen down.  Note: the floor turtle will not move on the
       carpet correctly with its pen down; put it on a smooth surface if  you
       want to draw pictures.

  pendown - Command, no inputs.  Abbreviation: pd
       This command tells the turtle to lower its pen, so that later commands
       will draw lines when the turtle moves.

  penerase - Command, no inputs.  Abbreviation: pe
       This command tells the turtle to "lower its  eraser",  so  that  lines
       previously  drawn will be erased when retraced by the turtle.  It only
       works with the display turtle.  The commands penup, pendown, penerase,
       and  penreverse  are  mutually  exclusive; whichever was most recently
       used is the one which affects the turtle.  (Graphics  terminals  which
       cannot selectively erase lines, such as Tektronix displays, will treat
       penerase as pendown.)

  penreverse - Command, no inputs.  Abbreviation: px
       This command tells the display turtle to lower  its  "reversing  pen";
       thereafter,  when  the turtle moves, it turns on any points which were
       off, and turns off any points which were on.  The commands penup, pen-
       down,  penerase,  and penreverse are mutually exclusive; whichever was
       most recently used is  the  one  which  affects  the  turtle.   (Note:
       Graphics  terminals which cannot penreverse will treat this command as
       pendown.)

  penmode - Operation, no inputs.
       This operation applies to the floor or the display turtle.  It outputs
       one of the words penup, pendown, penerase, or penreverse, depending on
       the current state of the turtle's pen.

  lampon - Command, no inputs.  Abbreviation: lon
       This command applies only to the floor turtle; it turns on  the  head-
       lamps on the front of the turtle.

  lampoff - Command, no inputs.  Abbreviation: loff
       This command turns off the floor turtle's headlamps.

  hitoot - Command, one input.  Abbreviation: hit
       This command applies only to the floor turtle.  It sounds the turtle's
       horn  at  the  higher of its two pitches.  The input is a number which
       indicates the number of quarter-seconds to toot the horn.  Note: large
       numbers  are  likely  to lead to violent behavior on the part of other
       computer users.

  lotoot - Command, one input.  Abbreviation: lot
       This command sounds the floor turtle's horn at the lower  of  its  two
       pitches.  The input is the duration of the toot.

  ftouch - Operation (predicate), no inputs.  Abbreviation: fto
       This operation can be used only with the floor turtle.  It has as  its
       output  the word true if the front of the turtle is touching an obsta-
       cle; otherwise it has the word false as its output.

  btouch - Operation (predicate), no inputs.  Abbreviation: bto

                                      12






       This operation can be used only with the floor turtle.  It has as  its
       output  the  word true if the back of the turtle is touching an obsta-
       cle; otherwise it has the word false as its output.

  ltouch - Operation (predicate), no inputs.  Abbreviation: lto
       This operation can be used only with the floor turtle.  It has as  its
       output  the  word  true  if the left side of the turtle is touching an
       obstacle; otherwise it has the word false as its output.

  rtouch - Operation (predicate), no inputs.  Abbreviation: rto
       This operation can be used only with the floor turtle.  It has as  its
       output  the  word  true if the right side of the turtle is touching an
       obstacle; otherwise it has the word false as its output.

  clearscreen - Command, no inputs.  Abbreviation: cs
       This command applies only to the display turtle.  It erases everything
       on  the TV screen, and restores the turtle to its initial position and
       heading (center of the screen, facing toward the top edge).

  wipeclean - Command, no inputs.  Abbreviation: clean
       This command applies only to the display turtle.  It erases everything
       on  the  TV screen, but does not change the turtle's position or head-
       ing.

  fullscreen - Command, no inputs.  Abbreviation: full
       This command applies only to the Atari display turtle.  It  eliminates
       the use of the bottom four lines of the screen to display the commands
       you type; instead, the entire screen is available to show the  picture
       drawn  by the turtle.  However, you can no longer see what you're typ-
       ing.  The command may be used after the picture is already drawn;  the
       part  "hidden"  by  the  text  at the bottom of the screen will become
       visible.   On  other  displays,   fullscreen   and   splitscreen   are
       equivalent;  they  make  the entire screen available for graphics, and
       text appears on the bottom line (Gigis)  or  superimposed  (ADMs),  or
       somewhere.

  splitscreen - Command, no inputs.  Abbreviation: split
       This command applies only to the Atari display  turtle.   It  restores
       the  normal  text display at the bottom of the screen, undoing the ef-
       fect  of  the  full  command.   On  other  displays,  fullscreen   and
       splitscreen  are equivalent; they make the entire screen available for
       graphics, with text superimposed in a display-dependent area.

  textscreen - Command, no inputs.  Abbreviation: text
       This command applies only to the display turtle.  It  temporarily  re-
       moves  the  turtle  display  from the screen, making the entire screen
       available for text display.  The commands fullscreen  and  splitscreen
       will  restore  the graphics display.  Note:  On the Atari display, the
       picture on the screen is  remembered,  so  that  when  you  return  to
       fullscreen or splitscreen mode, the picture returns to the screen.  On
       other displays, the picture is forgotten, and you return to  an  empty
       graphics screen.

  hideturtle - Command, no inputs.  Abbreviation: ht
       This command applies only  to  the  display  turtle.   It  erases  the
       display  of  the turtle itself from the screen, so that only the lines
       drawn when the turtle moves are visible.  The display is  faster  when
       the turtle is hidden (only slightly faster on the Atari, but much fas-

                                      13






       ter on other terminals).  Also, once a graphics program  is  debugged,
       it  may  be  prettier to watch without the turtle visible.  (Note:  On
       the Tektronix display, the turtle is never visible, because the termi-
       nal cannot erase selectively.)

  showturtle - Command, no inputs.  Abbreviation: st
       This command applies only to the  display  turtle.   It  restores  the
       display  of  the  turtle,  after the hideturtle command has been used.
       (Note:  On the Tektronix display, the turtle is never visible.)

  shownp - Operation (predicate), no inputs.
       This predicate applies only to the display  turtle.   It  outputs  the
       word true if the turtle is visible on the TV screen, false otherwise.

  pencolor - Command, one input.  Abbreviation: penc
       This command applies only to the display turtle.  Its effect  is  dif-
       ferent depending on how each type of terminal supports color.  For the
       Atari, the input must be an integer between 0 and 6.  An  input  of  0
       enters  black-and-white  display  mode  (which is the turtle's initial
       mode), in which lines are as thin as possible but there is no  control
       of  color.   Any  other  input  selects color mode, in which lines are
       twice as thick, so the effective size of the screen  is  smaller,  but
       colors  can  be  used.   There  are, in color mode, three possible pen
       colors, numbered 1 to 3.  There are  256  possible  colors,  but  only
       three  can be on the screen at a time; the setcolor command is used to
       decide which pen draws in which actual color.  If the input is  4,  5,
       or 6, the color is that of pen 1, 2, or 3, respectively, but lines are
       drawn in "fill mode": for each point inked, all points  to  its  right
       are  also  inked until a point is reached which was already inked.  On
       the Gigi, there is only one mode, and there is no loss  of  resolution
       in  using  color.  The input must be between 0 and 7; 0 means black, 7
       means white.  The ADM, Tektronix, and Sun displays do not have  multi-
       color drawing.

  setcolor - Command, two inputs.  Abbreviation: setc
       This command applies only to the Atari display turtle.  The first  in-
       put  must be an integer between 0 and 3.  If the input is nonzero, the
       second input specifies the color for the pen selected by the first in-
       put.  If the first input is zero, the second input specifies the back-
       ground color for the color graphics display.  The second input is  ei-
       ther  an  integer between 0 and 15, which is a color number, or a list
       of two integers, in which case the first is a  color  number  and  the
       second is an intensity number, an integer between 0 and 7.

  setxy - Command, two inputs.
       The two inputs must be numbers.  The turtle is moved to the  point  on
       the  screen  whose  x  (horizontal) coordinate is the first input, and
       whose y (vertical) coordinate is the second input.  The center of  the
       screen,  where  the  turtle starts, has both coordinates zero.  If the
       pen is down, this command draws a line.  This command applies only  to
       the display turtle.

  setheading - Command, one input.  Abbreviation: seth
       The input must be a number.  The turtle's heading is set to the input,
       taken  in degrees.  Zero points straight up, as the turtle starts out;
       positive headings are clockwise from zero.  This command applies  only
       to the display turtle.


                                      14






  towardsxy - Operation, two inputs.
       This operation applies only to the display  turtle.   The  two  inputs
       must  be  numbers, which are the x and y coordinates of a point on the
       TV screen.  The output is a number which is the heading to  which  the
       turtle  must  be  set,  in  order to point towards that point from its
       current position.  Note: this operation does not actually move or turn
       the  turtle.   You  must  use it as the input to setheading if that is
       what you want.

  xcor - Operation, no inputs.
       The output is the turtle's current  x  (horizontal)  coordinate.   The
       operation works only with the display turtle.

  ycor - Operation, no inputs.
       The output is the turtle's  current  y  (vertical)  coordinate.   This
       operation works only with the display turtle.

  heading - Operation, no inputs.
       The output is the turtle's current heading in degrees.  This operation
       works only with the display turtle.

  getpen - Operation, no inputs.
       The output is the turtle's current pen color, or (on the  Atari)  zero
       if  in  black-and-white  mode.   This  operation  works  only with the
       display turtle.

  setscrunch - Command, one input.  Abbreviation: setscrun
       This command is used only for display turtles.  The input  must  be  a
       number.  The vertical component of turtle motion is multiplied by this
       number before each motion is taken.  If squares come out too  wide  on
       your  screen,  you should increase the number; if too tall, you should
       decrease it.  (You can also use setscrunch to deform the turtle's  mo-
       tion  on purpose, so for example a circle program will draw an ellipse
       instead.)  The initial scrunch value depends on the terminal  you  are
       using:  for  the Atari and the Gigi, it is around 0.8 (your particular
       computer center will adjust this for the particular  TV  monitors  you
       use),  but  for  the  ADM, Tektronix, and Sun, it is 1.0 because these
       terminals display the same size steps horizontally and vertically.

  scrunch - Operation, no inputs.
       This operation is used only for display turtles.  It outputs a number,
       which is the scrunch factor (or aspect ratio) by which vertical motion
       is multiplied before it is displayed.  This number  is  changed  using
       the setscrunch command.

       Primitive_procedures_for_arithmetic.  Several procedures are available
  for  arithmetic  operations  on numbers.  In all cases, the inputs to these
  procedures must be numbers, except as otherwise indicated in the individual
  descriptions.

       In general, procedures are used in Logo by typing first  the  name  of
  the  procedure,  then  its  inputs.   This is true of arithmetic procedures
  also, e.g.

       sum 3 2

  However, for some arithmetic operations,  Logo  also  recognizes  the  more
  traditional infix notation, with the operation between the two inputs:

                                      15







       3 + 2

  Be warned, though, that the use of infix forms makes it difficult for  Logo
  to know how to group operations, unless parentheses are used.  If you stick
  to the standard (in Logo) prefix notation, the grouping is always unambigu-
  ous.    For  example,  the  first  two  of  these  three  instructions  are
  equivalent, but the third is not:

       if equalp count "hello 5 [print "Yes.]
       if (count "hello) = 5 [print "Yes.]
       if count "hello = 5 [print "Yes.]

  The reason for the error message produced by the last of  those  three  in-
  structions is that Logo interprets it as

       if count equalp "hello 5 [print "Yes.]

  That is, the equality test is done first, on the word hello itself,  rather
  than first taking the count of hello as was intended.

  sum - Operation, two inputs.  Infix: +
       The output of this procedure is the sum of the two inputs.

  difference - Operation, two inputs.  Abbreviation: diff  Infix: -
       The output of this procedure is the difference of the two inputs.

  product - Operation, two inputs.  Infix: *
       The output of this procedure is the product of the two inputs.

  quotient - Operation, two inputs.  Infix: /
       The output of this procedure is the quotient of the  two  inputs.   If
       both inputs are integers, the output is also an integer; the remainder
       of the division is lost.  If either input is not an integer, the  quo-
       tient can include a fractional part.  Therefore, these two are not the
       same:

            quotient 2 3
            quotient 2.0 3

  remainder - Operation, two inputs.  Abbreviation: mod  Infix: \
       The inputs to this procedure must be integers.  The output is also  an
       integer,  and  is  the  remainder  of  dividing the first input by the
       second.

  maximum - Operation, two inputs.  Abbreviation: max
       The output of this procedure is equal to whichever of the  two  inputs
       is numerically greater.

  minimum - Operation, two inputs.  Abbreviation: min
       The output of this procedure is equal to whichever of the  two  inputs
       is numerically smaller.

  greaterp - Operation (predicate), two inputs.  Infix: >
       The output of this procedure is the word true if the  first  input  is
       numerically  strictly  greater  than  the second input.  Otherwise the
       output is the word false.


                                      16






  lessp - Operation (predicate), two inputs.  Infix: <
       The output of this procedure is the word true if the  first  input  is
       numerically strictly less than the second input.  Otherwise the output
       is the word false.

  equalp - Operation (predicate), two inputs.  Infix: =
       The two inputs to this procedure may be any Logo objects.  If they are
       numbers,  then  the  output  is  the word true if they are numerically
       equal, false if they are numerically unequal.  If either input is  not
       a  number,  then the output is the same as for the procedure is: it is
       true if the two inputs are identical, false if not.  For example,  the
       numbers 2 and 2.0 are numerically equal, but not identical.

  numberp - Operation (predicate), one input.
       The input may be any Logo object.  The output is the word true if  the
       input is a number, false if not.

  zerop - Operation (predicate), one input.
       The input must be a number.  The output is the word true if the  input
       is numerically equal to zero, false otherwise.

  random - Operation, no inputs.
       The output from this procedure is an integer between 0 and 9, i.e.,  a
       single  digit.   It is chosen randomly, so the output may be different
       each time the procedure is used.

  rnd - Operation, one input.
       The input must be a  positive  integer.   The  output  is  a  randomly
       selected integer between 0 and one less than the input.

  sqrt - Operation, one input.
       The input must be a nonnegative number.   The  output  is  its  square
       root.

  pow - Operation, two inputs.
       The inputs must be numbers.  If the first is negative, the second must
       be  an integer.  The output is the first number raised to the power of
       the second input.

  sin - Operation, one input.
       The input must be numeric.  The output is the sine of the input, taken
       in degrees, not radians.

  cos - Operation, one input.
       The input must be numeric.  The output is the  cosine  of  the  input,
       taken in degrees, not radians.

  arctan - Operation, one input.  Abbreviation: atan
       The input must be numeric.  The output is the arctangent, in  degrees,
       of the input.

       Primitive_procedures_for_conditional_execution.  The predicates  (like
  wordp)  which  we've  mentioned above can be used to carry out some command
  only if a condition is met.  The basic command for the purpose is if:

  if - Command or operation, two or three inputs.
       The first input to the if procedure must be either the  word  true  or
       the  word  false.   Typically, it is the output from a predicate.  The

                                      17






       second and (optional) third inputs are  lists  containing  instruction
       lines.   The second input is executed if the first input is true.  The
       third input, if any, is executed if the first input is false:

       to greet :person
       if equalp :person [Ronald Reagan] [print [Hi, turkey!]] \
                           [print sentence "Hi, :person]
       end

       In that example, the first input to if is the output from the  expres-
       sion
       equalp :person [Ronald Reagan].

       The if procedure can be used as an operation, producing a  value.   In
       this case, the third input is required:

       print if equalp :person "Reagan ["Loser] ["Winner]

  test - Command, one input.
       The input must be the word  true  or  the  word  false.   The  command
       remembers  its  input  for  use  in a later iftrue or iffalse command.
       This is an alternative to if which is useful if  several  instructions
       are  to  be  made  conditional  on the same condition.  The remembered
       truth value is local to the current procedure, if any.

  iftrue - Command, one input.  Abbreviation: ift
       The input must be an instruction list.  It is run if the  most  recent
       test command saved a true value.

  iffalse - Command, one input.  Abbreviation: iff
       The input must be an instruction list.  It is run if the  most  recent
       test command saved a false value.

  both - Operation (predicate), two inputs.  Abbreviation: and
       The two inputs must both be either true or false.  The output is  true
       if both inputs are true; otherwise the output is false.

  either - Operation (predicate), two inputs.  Abbreviation: or
       The two inputs must be either true or false.  The output is true if at
       least one of the inputs is true; otherwise the output is false.

  not - Operation (predicate), one input.
       The input must be either true or false.  The output is true if the in-
       put is false, and vice versa.

       Primitive_procedures_for_file_input_and_output.  In the Unix operating
  system,  there  are  two steps in reading or writing files: first, the file
  must be opened, thereby associating a "file descriptor" (an  integer)  with
  the  file name; second, the file descriptor is used to specify the file for
  each read or write operation.  Logo has primitive procedures  for  each  of
  these steps.

  openread - Operation, one input.  Abbreviation: openr
       The input to this procedure is a word, which must be a Unix  filename.
       It  can  contain slashes to indicate directory names.  If the file can
       be opened for reading,  the  output  from  the  procedure  is  a  file
       descriptor,  which  should  be stored in a variable for use in reading
       the file.  If the file cannot be opened, an error results.

                                      18






  fileread - Operation, one input.  Abbreviation: fird
       The input must be a file descriptor, previously  output  by  openread.
       The  procedure  reads one line from the file.  The output is the line,
       in the form of a list.  (That is, the output is the file  line  as  if
       enclosed in square brackets in a program.)  If the end of the file has
       been reached, the output is the empty word.  If the file line contains
       mismatched brackets, trouble may result.

  fileword - Operation, one input.  Abbreviation: fiwd
       The input must be a file descriptor, open for reading.  The  procedure
       reads one line from the file.  The output is that line, in the form of
       a single word, including spaces and punctuation  characters.   If  the
       end of the file has been reached, the output is the empty list.

  openwrite - Operation, one input.  Abbreviation: openw
       The input must be a Unix filename.  The file  is  opened  for  writing
       (replacing any previous version), if allowed, and the output is a file
       descriptor, for use by file printing commands below.  If the file can-
       not be opened, an error results.

  fileprint - Command, two inputs.  Abbreviation: fip
  filetype - Command, two inputs.  Abbreviation: fity
  filefprint - Command, two inputs.  Abbreviation: fifp
  fileftype - Command, two inputs.  Abbreviation: fifty
       The first input  must  be  a  file  descriptor  previously  output  by
       openwrite.   The  second  input  is  any  object.  The second input is
       printed (typed, fprinted, ftyped) into the file.

  close - Command, one input.
       The input must be a file descriptor.  The file is closed.   This  must
       be done when you've finished reading or writing the file.

       Sample program:

       make "fd openwrite "outfile
       fileprint :fd "Hello.
       close :fd

       This will create a file named outfile containing the word Hello.

       Primitive_procedures_for_procedure_exit.  A  procedure  written  by  a
  user,  in  Logo,  can be a command or an operation.  If it is an operation,
  you must, in the procedure, say what its output should be.  If it is a com-
  mand, it can simply stop at the end of the procedure, or you can explicitly
  make it stop before the end.

  output - Command, one input.  Abbreviation: op
       This command is used in a user procedure  which  is  meant  to  be  an
       operation.  The input to this command becomes the output from the user
       procedure.  Please don't be confused by the fact that  the  user  pro-
       cedure is an operation, while the output primitive procedure is a com-
       mand used in that procedure.  Example:

       to nickname :person
       if equalp :person [Peter Parker] [output "Spiderman]
       if equalp :person [Lamont Cranston] [output "Shadow]
       output first :person
       end

                                      19







  stop - Command, no inputs.
       This command is used in user procedures which are  meant  to  be  com-
       mands.   It stops the user procedure.  (Note that it does not stop all
       running procedures.  If user procedure A runs user procedure B, a stop
       command  in  procedure B returns to procedure A, which continues after
       the point where procedure B was invoked.)

  toplevel - Command, no inputs.  Abbreviation: top
       This command stops all running procedures.  The user at  the  terminal
       is  prompted  to  type  another command.  This can be used when a user
       procedure discovers some error condition and wants to abort the entire
       program, for example.

       Property_lists.  It is possible to associate with any name a  list  of
  "properties".  A property list contains property names and property values.
  For example:

       pprop "bh "firstname "Brian
       pprop "bh "lastname "Harvey

  The form of a property list is

       [name1 val1 name2 val2 name3 val3]

  Although this data structure could be created using other Logo  primitives,
  special property list primitives are provided because they are faster.  The
  property lists do not share storage with Logo variables, so you can  change
  the value of any property without having to recopy the entire property list
  as you would ordinarily.   The  following  primitives  manipulate  property
  lists.

  pprop - Command, three inputs.
       The first input, which must be a word, is a name with which a property
       list  is  associated.   The second input, which must be a word, is the
       name of a property.  The third input can be any Logo object.   It  be-
       comes the value of the specified property of the specified name.

  gprop - Operation, two inputs.
       Both inputs must be words.  The first is a name, and the second  is  a
       property  name.   The output is the value of the indicated property of
       the indicated object.  It is not an error if there is no such  proper-
       ty; the output in that case is the empty list.

  remprop - Command, two inputs.
       The inputs must be words, as for gprop.  The specified property is re-
       moved from the specified name.

  plist - Operation, one input.
       The input must be a word, which is a name.  The output is the property
       list  of  the  specified name.  Note: the output is actually a copy of
       the property list.  The real property list is not a  Logo  list.   Any
       later  changes to the properties of the specified name will not change
       the list which was output by an earlier plist.

  pps - Command, no inputs.
       All properties of all names are listed on your terminal.


                                      20






       Pausing.  When you are debugging a complicated  Logo  program,  it  is
  very  helpful  to be able to stop in the middle of a procedure, so that you
  can give interactive commands to examine its inputs and other  local  vari-
  ables.  This is different from stopping a procedure, which destroys its lo-
  cal environment.  There are three ways a procedure can pause:  (1) You  can
  include  the  command  pause  in the procedure definition, to make the pro-
  cedure pause at a particular place you choose in advance; (2) you  can  de-
  cide  to pause a procedure while it is running by typing the system "inter-
  rupt" character (this is control-C at Lincoln-Sudbury but is  different  on
  other  systems);  or  (3) you can arrange for an error in the processing of
  the procedure to pause instead of stopping as it usually does.

       Note that when you type the  system  "quit"  character  (control-G  at
  Lincoln-Sudbury)  Logo does not pause, but returns to toplevel.  All infor-
  mation about the local state of your active procedures is lost.

       When you are paused, Logo accepts instructions from your  terminal  as
  it  does  at toplevel, but local variables can be examined or modified.  To
  let you know that you are paused, Logo prompts with the characters "-*" in-
  stead  of  just  "*"  as usual.  It is possible to pause within a procedure
  within a pause; in this case your prompt is "--*" to indicate two levels of
  pause.  This can be continued to higher levels.

       To get out of a pause, there are three things you  can  do.   You  can
  give  the  command toplevel, which stops all pending procedures and returns
  to interactive top level.  You can give the command  stop  or  the  command
  output  with  an input, which will terminate the current procedure (without
  or with an output respectively) and return to its  calling  procedure.   Or
  you  can  give the command continue, which will resume the procedure at the
  point where you paused.

  pause - Command, no inputs.
       This command is meaningful only  within  a  procedure.   It  causes  a
       pause.

  continue - Command, no inputs.  Abbreviation: co
       This command is meaningful  only  when  typed  during  an  interactive
       pause.  It continues the current procedure from where it was paused.

  errpause - Command, no inputs.
       This command tells Logo that any errors which happen during  procedure
       execution  from  now  on should cause a pause, rather than a return to
       toplevel.

  errquit - Command, no inputs.
       This command tells Logo that any errors which happen during  procedure
       execution  from now on should return to toplevel, rather than pausing.
       This is the initial state of affairs when you start Logo.

  setqpause - Command, no inputs.
       This command tells Logo that from now on, the  system  quit  character
       should  pause, and the system interrupt character should return to to-
       plevel.  This is the reverse of the usual interpretation.   This  com-
       mand  is  provided  for  people whose systems or keyboards make one of
       these characters easier to type than the other.  In particular,  under
       Eunice there is only an interrupt character, not a quit character.

  setipause - Command, no inputs.

                                      21






       This command tells Logo that from now on, the system interrupt charac-
       ter  should  pause, and the system quit character should return to to-
       plevel.  This is the initial state of affairs when you start Logo.

       Miscellaneous_primitives.  The remaining primitives are one of a kind,
  or very obscure, or both.

  goodbye - Command, no inputs.  Abbreviation: bye
       This command is used to leave Logo.  It is the only  way  out,  unless
       there is a bug somewhere.

  thing - Operation, one input.
       The input must be a word, and must be the name  of  a  variable.   The
       output is the value of the variable.  These are equivalent:

       :foo
       thing "foo

  namep - Operation (predicate), one input.
       The input must be a word.  The output is true if that word is the name
       of a variable which has a value assigned to it, false otherwise.

  wait - Command, one input.
       The input must be a positive integer.  Logo waits  that  many  seconds
       before continuing.

  trace - Command, no inputs.
       This command is used for debugging your Logo programs.  After you  use
       this  command,  every time a user-defined procedure starts or stops, a
       message is typed at your terminal naming the procedure and its  inputs
       or its output, if any.  The message is indented according to the depth
       in procedure calls.

  untrace - Command, no inputs.
       This command turns off the trace messages started by  the  trace  com-
       mand.

  unix - Command, one input.
       The input must be a Unix shell command, which  is  carried  out  in  a
       forked shell.  (/bin/sh is used, not csh.)  Example:

       to whois :user
       unix (sentence "grep (word "'^ :user ":') "/etc/inquir)
       end

  run - Command or operation, one input.
       The input must be a list, containing a  Logo  instruction  line.   The
       list is run as if you typed it directly to Logo.  Example:

       to while :condition :cmd
       if not run :condition [stop]
       run :cmd
       while :condition :cmd
       end

       make "number 1
       while [:number < 5] [print :number; make "number :number+1]


                                      22






       The run procedure can be used as an operation, if its input is a  Logo
       expression which produces a value, instead of a complete instruction:

       print run [sum 2 3]

  repeat - Command, two inputs.
       The first input must be a positive number.  The second is an  instruc-
       tion  list,  as  for the run command.  The list is run repeatedly, the
       number of times specified by the first input:

       repeat 5 [print "hello]

  repcount - Operation, no inputs.
       This operation may be used only within the range of a repeat  command.
       It  outputs  the number of repetitions which have been done, including
       the current one.  That is, it outputs 1 the first time through, 2  the
       second time, and so on.

  cbreak - Command, one input.
       The input must be either the word on or the word off.  If the input is
       on,  your terminal is placed in cbreak mode, which means that what you
       type is made available to your program every  character,  rather  than
       every  line.   This must be done before the readchar procedure, below,
       will work.  This facility is good for writing video game  programs  or
       text editors.  While in cbreak mode, echo is turned off also.

  readchar - Operation, no inputs.  Abbreviation: rc
       This operation waits for you to type a single character at your termi-
       nal.  The output is a word containing only that character.  This works
       only if you have turned on cbreak mode; see above.

  keyp - Operation (predicate), no inputs.
       This procedure outputs true if there is a character waiting to be read
       from the terminal, if you are in cbreak mode.  If not, it outputs true
       if there is an entire line waiting to be read.

  oflush - Command, no inputs.
       Normally, when you tell Logo to print something, the printing  is  not
       done  right  away.   Instead, Logo remembers everything you tell it to
       print, and the printing is done all at once  the  next  time  Logo  is
       waiting  for  you to type something.  This arrangement makes Logo much
       faster than it would be if everything were printed  immediately.   The
       oflush  command  tells  Logo to print whatever you've previously asked
       for right away, without waiting.

  help - Command, no inputs.
       This command types at your terminal a brief message about Logo and how
       to use it.

  describe - Command, one input.
       The input must be the name of a Logo primitive procedure.  A brief ex-
       planation of that primitive is typed at your terminal.

  go - Command, one input.
       This command can be used only inside a procedure.  The input must be a
       number.   The same number must appear at the beginning of some line in
       the same procedure.  (This line number is otherwise ignored.) The next
       command  executed will be the one on the indicated line in the defini-

                                      23






       tion.  Note: there is always a better way to do it.  If you have  pre-
       viously  programmed  in  BASIC, your only hope of ever really learning
       how to program computers is NEVER EVER to use the go command!

  debquit - Command, no inputs.
       This command is meant to be used only for debugging Logo  itself.   It
       is  explained here only for completeness.  After this command is used,
       the QUIT signal is not caught by Logo, so it will cause a core dump.

  memtrace - Command, no inputs.
       This command is meant to be used only for debugging Logo  itself.   It
       is  explained here only for completeness.  After this command is used,
       every allocation or deallocation of memory, and every character parsed
       by  the  interpreter, types an incomprehensible message at your termi-
       nal.

  yaccdebug - Command, no inputs.
       This command is meant to be used only for debugging Logo  itself.   It
       is  explained here only for completeness.  After this command is used,
       every state transition in the yacc parser  types  an  incomprehensible
       message at your terminal.

       The_Logo_library.  The  directory  /usr/lib/logo  contains  Logo  pro-
  cedures which are available to all users.  They are not listed by pots, but
  can be thought of as pseudo-primitives which happen to be written in  Logo.
  Some  of  these procedures are only useful in conjunction with the teaching
  units used in Introduction to Computers, but others are  generally  useful.
  This  manual  does  not fully document the Logo library, because it changes
  too often.  Look through the /usr/lib/logo directory yourself if you  want.
  The procedures listp, home, pos, setpos, towards, setx, and sety in the li-
  brary are provided for partial compatibility with Apple Logo.




























                                      24




