;<SUBSYS.CMU>FTPSRT.MAC.40, 18-Nov-85 03:09:52, Edit by VAF
;CS129	Remove generation defaulting code. Sigh. GTJFN already can do this.
;	Specify highest-generation-only for STAT & co (as for NLST)
;	Fix bug introduced by change to print xfer byte count.
;<SUBSYS.CMU>FTPSRT.MAC.37, 13-Nov-85 17:09:44, Edit by VAF
;CS129	Only do generation/name defaulting for STAT/RSTA, not LIST/NLST
;<SUBSYS.CMU>FTPSRT.MAC.36,  7-Nov-85 17:17:59, Edit by VAF
;CS129E	In DATABE, don't specify CO%WCL if error occurred.
;	Fix CLOSED to support flags.
;	Flush CONSYN altogether.
;<SUBSYS.CS>FTPSRT.MAC.35, 18-Sep-85 16:39:38, Edit by VAF
;CS129	Delete TCPF and TCPP flags.
;CS129D	Add SETPFL flag for setting file protections of paged transfer files.
;<SUBSYS.CS>FTPSRT.MAC.34, 11-Sep-85 11:48:03, Edit by VAF
;CS129	Remove CMU conditional around new autologout code.
;<SUBSYS.CS>FTPSRT.MAC.33, 23-Aug-85 12:03:15, Edit by VAF
;CS129	(CMU-CS Only) Allow ANONYMOUS write if lowest bit of dir prot is 1.
;<SUBSYS.CS>FTPSRT.MAC.32, 14-Aug-85 05:40:43, Edit by VAF
;CS129	Fix name defaulting code when ^V's seen (e.g. EMACS:MMAIL.^V:EJ)
;<SUBSYS.CS>FTPSRT.MAC.31, 11-Aug-85 22:39:25, Edit by VAF
;CS129C	Use large buffers for data connections (under BIGBUF conditional)
;CS129	Allow TYPE A N retrieve of 36-bit files also.
;	Reset stack pointer when doing autologout
;<SUBSYS.CS>FTPSRT.MAC.30,  7-Aug-85 01:43:36, Edit by VAF
;CS129	Check for data connection synchonized, a la FTP.
;	Do STAT% for TVT info symbolically.
;<SUBSYS.CS>FTPSRT.MAC.27, 21-Jun-85 00:08:52, Edit by VAF
;CS129	Default name and type to "*" when defaulting generation to 0.
;	Turn on ANONYMOUS access restrictions at CMU-CSD.
;	Re-do ANONYMOUS restrictions with GXJFN%.
;<SUBSYS.CS>FTPSRT.MAC.26, 18-Jun-85 13:43:03, Edit by VAF
;CS129	Refuse user sends only at CMU.
;<SUBSYS.CS>FTPSRT.MAC.25, 17-Jun-85 13:48:18, Edit by VAF
;CS129	Reject arguments to SITE command.
;<SUBSYS.CS>FTPSRT.MAC.24, 14-Jun-85 13:16:32, Edit by VAF
;CS129	Very hairy code to simulate JFNS using GTJDEV and GTJDIR (CWD).
;	Only return "dev:<dir>name.ext.n" for NLST, not extra garbage
;	Default STAT to highest generation, rather than all generations.
;	Fix DOGTJ1 to exit if no files match... Sigh.
;<SUBSYS.CS>FTPSRT.MAC.23, 13-Jun-85 13:56:34, Edit by VAF
;CS129	Print number of bytes transferred in 226/250 message.
;<SUBSYS.CS>FTPSRT.MAC.22, 27-Mar-85 22:43:11, Edit by VAF
;CS129	Vile code for intercepting DDT breakpoints when debugging...
;	(under DBGHAK conditional, since it is site-specific)
;	Fix (badly) TYPE I/TYPE L 36 nonpaged for non-36 bit file.
;<SUBSYS.CS>FTPSRT.MAC.21, 21-Mar-85 14:12:21, Edit by VAF
;CS129X	Implement RSTA and RLST commands (proposed FTP extensions).
;	Update GNJFN flags properly in %GNJFN.
;	Don't muck with tty modes if debugging.
;<SUBSYS.CS>FTPSRT.MAC.20, 26-Feb-85 12:24:57, Edit by VAF
;CS129	(CMU-CS Only) Implement new ANONYMOUS access scheme.
;	(removes some of the CS129 stuff for restricting ANONYMOUS logins)
;	(CMU Only) Do autologout of real users, but give twice as much
;	idle time as NLI/ANONYMOUS. Redo autologout logic.
;CS129	Fix bug - RETR needs to do TIMEOK's on each buffer like STOR...
;<SUBSYS.CS>FTPSRT.MAC.17,  5-Dec-84 18:45:33, Edit by VAF
;CS129	Don't allow TYPE A retrieves of non-7 bit files.
;<SUBSYS.CS>FTPSRT.MAC.16, 30-Oct-84 18:08:04, Edit by VAF
;CS129	Remove search of TCPSYM since all necessary symbols should be in MONSYM
;	now, and old versions of TCPSYM will cause problems.
;<SUBSYS.CS>FTPSRT.MAC.15, 25-Oct-84 13:09:29, Edit by VAF
;CS129	Refuse sends in addition to system messages, if .MOSEN defined.
;<SUBSYS.CS>FTPSRT.MAC.14, 23-Aug-84 11:00:12, Edit by VAF
;CS129B	From Gregg Satz: Get connection info from TVT, not from FTSCTT.
;<SUBSYS.CS>FTPSRT.MAC.13,  7-Jul-84 17:27:47, Edit by VAF
;CS129	Rename all [VAF] changes to be CS129
;     	Fix logic for printing "structure mounted/access" crud
;CS129A	Change DOBE during hangup to SOBE/DISMS loop. There's a bug in DOBE.
;<VAF.FTP.EXP>FTPSRT.MAC.12, 11-Apr-84 15:15:24, Edit by VAF
; Don't send unsolicited replies when implicit structure mount done.
; Merge Columbia changes from CHRIS@COLUMBIA-20:
;   CU4	Print a different message if login failed because of ACJ.
;   CU3	Detached jobs aren't going away; do logout in .TICRF handler
;   CU2	Don't exit timout interrupt routine at interrupt level
;	Don't try tty output in fatal PSI routines, it's not very useful
;	and causes us to miss carrier off interrupts (job never goes away).
;   CU1	Allow use of passwords with CWD, don't mount unregulated structures.
;	Might as well mount structures as necessary for the LIST commands.
;	Get args to ACCES% right, don't forget password in CWD,PASS sequence.
;	Don't ITRAP if user says "SMNT PS:" instead of "SMNT PS", etc.
;	Correctly trap quota exceeded interrupts.
;	Search TCPSYM to find symbols for the BBN TCP interface.
;<SUBSYS.CS>FTPSRT.MAC.11,  9-Apr-84 22:13:20, Edit by VAF
; Handle bad password during LOGIN correctly.
; Close local file on ABOR command.
; Change ANONYMOUS login logic (CMU-CS only):
;   - Correct password always allows (if ANOP==1)
;   - CMU-CC sites need password.
;<SUBSYS.CS>FTPSRT.MAC.8, 23-Mar-84 13:59:48, Edit by VAF
; Change SOJLE at USRAN4+2 to SOJL.
;<SUBSYS.CS>FTPSRT.MAC.7, 14-Mar-84 17:05:47, Edit by VAF
; Make port confirmation give host & port number (debugging info)
;<SUBSYS.CS>FTPSRT.MAC.6, 10-Feb-84 13:30:46, Edit by VAF
; Make structure mount/access code obey protocol better.
; (CMU-CS only) Disallow anonymous login from non CMU-CSD/RI sites.
; (the above change is temporarily REPEAT 0'ed pending policy descision).
; (CMU-CS only) Log file opens during RETR/STOR/APPE
;<SUBSYS.CS>FTPSRT.MAC.4, 27-Oct-83 21:15:15, Edit by VAF
;Call DOMSTR at CWD time. Fix puctuation of directory name in DOMSTR.
;<SUBSYS.CS>FTPSRT.MAC.3, 21-Sep-83 15:17:14, Edit by VAF
;Flush vestiges of mail support.
;<SUBSYS.CS>FTPSRT.MAC.2, 20-Sep-83 23:49:33, Edit by VAF
;Make PASS command check for already logged in first, so CWD works.
;Implement CWD to set defaults when not really connected.
;Do ACCESS of structure after mounting, if possible.
;<SUBSYS.CS>FTPSRT.MAC.1, 20-Sep-83 21:04:26, Edit by VAF
;Create this version - merged FTP1,FTP2S,FTP4 together & remove SERVER/USER
;conditionals.
;<VAF.FTP>MFTP2S, 18-Aug-83 16:20:15, Edit by VAF
;Attempt to mount regulated structures if GTJFN says so.
;<VAF.FTP>MFTP4.MAC.2, 18-Aug-83 16:21:01, Edit by VAF
;Add LCLSTR - name of structure for LCLJFN.
;<VAF.MAC.TCP>MFTP2S.MAC.4, 20-Jun-83 12:27:28, Edit by VAF
;Allow ANONYMOUS writes, but only to <ANONYMOUS>.
;<VAF.MAC.TCP>MFTP1.MAC.2, 20-May-83 00:08:22, Edit by VAF
;This version from MIT-XX. Remove all TCPF/TCPP conditionals.
;Rip out REPEAT 0's.
;#13 14Feb83 /Rcc
;   Fixes from ISI, PARC and BBNRCC versions
;#6-12 Were used in various local copies (without hanging VWHO!)
;#5 Fix problem with not recognizing quoted file names
;#4 Add RETAIN and NORETAIN commands
;#3 Fix to cause byte count conversion when byte size of write differs from 
;   byte size of open & Fix to finesse around the vax bbn-tcp close code
;#2 Temporary fix to prevent copies of FTPSRT from hanging around
;   Add detach before logout
;FTP1.MAC.1 CLynn Based on old NCP version, with lots of changes
;NB: Versions with TCPF or TCPP not 1 are unsupported, untested, etc
;NB: May have to be modified at each site due to TCP version skew,
;    see TCPOLD for hints. TCPOLD==1 assumes new TCP on TOPS20 and
;    old TCP on TENEX.  Differences are CDB format and STAT JSYS/
;    monitor TCB format.


	TITLE FTPSRT - TCP-based File Transfer Protocol - Server Program
DEFINE OURNAME <HRROI B,[ASCIZ / FTP Server Process /]>
	SUBTTL C Lynn - BBN - Version 25

	SEARCH MONSYM,MACSYM,TCPUNV
	.REQUIR TCPSIM
	SALL
	.DIRECT FLBLST
STANSW==0 ; CHANL% stuff doesn't work...
DEFINE REP0,<REPEAT 0>
DEFINE REP1,<REPEAT 1>
DEFINE CS,<IFN CSFLG>		;CMU-CSD only features
DEFINE CMU,<IFN CMUFLG>		;CMU-Only features
DEFINE NOCMU,<IFE CMUFLG>
DEFINE NOCS,<IFE CSFLG>
DEFINE CU,<IFN CUFLG>		;Columbia-only features
DEFINE ANR,<IFN ANRFLG>		;ANONYMOUS restrictions
DEFINE NAN,<IFE ANRFLG>

VWHO==7		; Last edited by VAF
VMAJOR==5	; Major Version #
VMINOR==^D26	; Make "Z" to be higher than "T" in standard version...
VEDIT==40	; Edit Number


	LOC	<.JBVER==137>
VERSIO:	<VWHO>B2+<VMAJOR>B11+<VMINOR>B17+VEDIT ; Versions for typeout
	RELOC
	TWOSEG			; The high seg contains code used after LOGIN
	RELOC 400000		; Create the high segment
HSBAS:
	LOC 5000		;CS129 Origin of code in low segment
LSBAS:

	SUBTTL	Configuration Definitions

DEFINE ND (X,Y)<
IFNDEF X,<X==Y>>

ND CSFLG,0			;CS129 Default is not CMU-CS
ND CMUFLG,0			;CS129 Default is not CMU
ND CUFLG,0			;CS129 Default is not Columbia
ND ANRFLG,0			;CS129 Default is normal ANONYMOUS
ND BIGBUF,0			;CS129 Default is small buffers
ND DBGHAK,0			;CS129 Default is no debug hack
ND SETPFL,0			;CS129D Default is not set file protections
CS,<ANRFLG==1>			;CS129 CMU-CS has ANONYMOUS restrictions
ANR,<				;CS129
     IFNDEF GXJFN%,<		;CS129
	PRINTX ?Can't do ANONYMOUS restrictions - GXJFN% not present
     >				;CS129
     DEFINE %GTJFN<CALL DOGTJ>	;CS129
     DEFINE %GNJFN<CALL DOGNJ>>	;CS129
NAN,<DEFINE %GTJFN<GTJFN%>	;CS129
     DEFINE %GNJFN<GNJFN%>>	;CS129
IF1,<				;CS129 *** Begin ***
  CMU,<PRINTX Assembling CMU conditionals>
  CS,<PRINTX Assembling CS conditionals>
  CU,<PRINTX Assembling CU conditionals>
  ANR,<PRINTX Assembling ANONYMOUS restrictions>
  IFN DBGHAK,<PRINTX Assembling 777-DDT breakpoint hack>
  IFN BIGBUF,<PRINTX Assembling to use large data buffers>
  IFN SETPFL,<PRINTX Assembling to set file protections>
  >				;CS129 *** End ***

ND REL4,1	;0 - If not TOPS20 Release 4 or later
		;1 - If assembling for TOPS20 Release 4 or later

;CS129 Delete TCPF and TCPP flags - they are unused

IFN REL4,<	T20FDB==.FBLEN>		; FDB lengths
IFE REL4,<	T20FDB==30>		; 101B
		TNXFDB==25		; TENEX
MINFDB==TNXFDB				; Minimum acceptable FDB
MAXFDB==37+10				; Maximum FDB - extra for padding

PGSBSY=='FTP'			; Name of subsystem for SETSN JSYS
PGNAME=='FTPSRT'		; Name of this program for SETNM JSYS


ND PDLL,100	; Stack length
ND DWTIME,^D120	; Seconds to wait for data connection
ND DEBUG,0	; Debugging code assembly switch
ND LCMDIB,^D512	; Words to hold TELNET line. Make ridiculously huge
		; because of NLS users' inability to type carriage return
ND LREPLY,^D100	; Words to hold reply. Shouldn't need nearly this much

ND IPCLOG,0	;0 - No ICPF logging (TENEX or TOPS20)
		;1 - Rudimentary logging via IPCF (TOPS20 only)
		; Not yet implemented

ND ENABL,1	;0 - No special capabilities
		;1 - Enable all user capabilities

ND ANOP,1	;0 - ANONYMOUS users must supply correct password
		;1 - ANONYMOUS users do not need password (give USER)
		;Note: ANONYMOUS logins are not allowed unless
		;	the file "ANONYMOUS.USERFILE" exists,  see T__.AU

ND WATTIM,^D300	; Seconds to wait for user to type something

	SUBTTL	System Dependent String Constants
; TOPS20 - T20.xx, TENEX - TNX.xx, Same - TXX.xx

DEFINE PARMAC	(SYSTEM<SYSTEM>,SYS<SYS>,SUBSYS<SUBSYS>)<
				; (Use other names when debugging)
T20.DV:	ASCIZ /PS:/		; Device prefix
TNX.DV:	0

TXX.SY:	ASCIZ /SYSTEM/		; System

T20.NV:	ASCIZ /.-1;P770000/	; New version of a file
TNX.NV:	ASCIZ /;-1;P770000/

TXX.AN:	ASCIZ /ANONYMOUS/	; ANONYMOUS user name

; Filespec of file containing ANONYMOUS user password
; Note: If this file does not exist, ANONYMOUS logins are not allowed
T20.AU:	ASCIZ /SYSTEM:ANONYMOUS.USERFILE/
TNX.AU:	ASCIZ /<SYSTEM>ANONYMOUS.USERFILE/

T20.UE:	ASCIZ /SYS:UDDT.EXE/	; Filespec of file containing UDDT
TNX.US:	ASCIZ /<SUBSYS>UDDT.SAV/

> ; End of DEFINE PARMAC

	SUBTTL	AC Definitions

F=0		; Flags
A=1		; A-D are JSYSI args & temps
B=2
C=3
D=4
E=5		; AC used in call to mail routines

T1=6		; Temps
T2=7
P1=10		; Permanent over subr calls
P2=11
P3=12

BP=14		; Byte pointer for collecting, parsing strings
X=15		; Msg pointer in mail errors

P=17		; Stack

	SUBTTL	Constants

C.NUL==0	; NUL character
C.CC==3		; Control-C
C.BELL==7	; Bell
C.BS==10	; Backspace (character delete)
C.TAB==11	; Tab
C.LF==12	; Line Feed
C.FF==14	; Form Feed
C.CR==15	; Carriage Return
C.ESC==33	; Escape
C.SPACE==" "	; Space

C.COMNT==";"	; Starts comment lines to server
C.QUOTE=="V"&37	; Quote character in file names, etc
C.TTYE=="Z"&37	; End of file for TTY:
C.HRLD=="*"	; The herald for typein
C.SRVH=="<"	; "Less-Than" prefixes server output

; Editting Characters
; Backspace (^H) is also a character delete

T20CDL==177	; TOPS20 Character delete (Rubout)
T20CD2==C.BS	; TOPS20 Character delete (Backspace)
T20WDL=="W"&37	; TOPS20 Word delete (^W)
T20WD2==-1	; TOPS20 Word delete
T20LDL=="U"&37	; TOPS20 Line delete (^U)
T20LD2==-1	; TOPS20 Line delete
T20EOL==C.LF	; TOPS20 End-of-line

TNXCDL=="A"&37	; TENEX Character delete (^A)
TNXCD2==C.BS	; TENEX Character delete (Backspace)
TNXWDL=="W"&37	; TENEX Word delete (^W)
TNXWD2==-1	; TENEX Word delete
TNXLDL==177	; TENEX Line delete (Rubout)
TNXLD2=="X"&37	; TENEX Line delete (Control-X)
TNXEOL==37	; TENEX End-of-line

.TTNVT==4	; TENEX NVT terminal type
.TTIDL==11	; TOPS20 Ideal terminal type

DECRAD==12	; Decimal radix
OCTRAD==10	; Octal radix


..DEVA==FLD(.JSAOF,JS%DEV)	; Abbreviations for JFNS JSYS format
..DEVD==FLD(.JSSSD,JS%DEV)
..DIRA==FLD(.JSAOF,JS%DIR)
..DIRD==FLD(.JSSSD,JS%DIR)
..NAMA==FLD(.JSAOF,JS%NAM)
..TYPA==FLD(.JSAOF,JS%TYP)
..GENA==FLD(.JSAOF,JS%GEN)
..PROA==FLD(.JSAOF,JS%PRO)
..ACTA==FLD(.JSAOF,JS%ACT)

	SUBTTL	Macros

DEFINE MSG (XMSG)<		HRROI A,[ASCIZ \XMSG\]
				PSOUT	>

DEFINE VMSG (XMSG)<		PUSH P,A
				HRROI A,[ASCIZ \XMSG\]
				SKIPE F$VBOS		; Verbose typeout?
				  PSOUT
				POP P,A	>

DEFINE NOISE (XMSG)<		HRROI A,[ASCIZ \XMSG\]
				MOVE C,BREAKC
				CAIN C,C.ESC
				  PSOUT	>

; Macro to define keyword tables
; The default is by definition the first entry in each table

DEFINE KM (A,B,C)<ZZ==0
		XWD N'A'S,N'A'S		; Maybe COMD one day
IRP B,<	IF2 <IFNDEF A'$'B,<	IFB  <C>,<A'$'B==A'$>
				IFNB <C>,<A'$'B==C>
		>>
		XWD [ASCIZ \B\],A'$'B
	A'.'B==ZZ
	ZZ==ZZ+1
    > ; End of IRP
	N'A'S==ZZ
> ; End of DEFINE KM

DEFINE CLOSD (FILE,FLAGS)<	MOVEI A,FILE
		IFNB <FLAGS>,<	HRLI A,(FLAGS)>
				CALL CLOSED	> ; End of DEFINE CLOSD

DEFINE CLOSK (FILE,FLAGS)<	MOVEI A,FILE
		IFNB <FLAGS>,<	HRLI A,(FLAGS)>
				CALL CLOSEK	> ; End of DEFINE CLOSK

DEFINE CLOSR (FILE,FLAGS)<	MOVEI A,FILE
		IFNB <FLAGS>,<	HRLI A,(FLAGS)>
				CALL CLOSER	> ; End of DEFINE CLOSR

DEFINE ASCIZS (NF,NT,S,SF,ST,T)<XLIST
				ASCIZ \NT'S'ST'T\
				LIST> ; End of DEFINE ASCIZS

MSKSTR DV$TYP,B,DV%TYP		; Device type from DVCHR JSYS
MSKSTR FB$BSZ,FDBBLK+.FBBYV,FB%BSZ ; FDB byte size, in FDBBLK
MSKSTR OF$BSZ,0,OF%BSZ		; File byte size for OPENF JSYS
MSKSTR PT$BSZ,0,77B11		; Byte size in POINT N,...

T.BFSZ==200			;CS129C Small buffers for TELNET
T.NDBF==3			;CS129C with triple buffering
IFE BIGBUF,<	T.BFSB==1200	;CS129C default data buffer size
		T.NDBB==4>	;CS129C default number of data buffers
IFN BIGBUF,<	T.BFSB==10000	;CS129C Huge buffers for data transfer
		T.NDBB==6>	;CS129C with sextuple buffering


	SUBTTL	Flags in AC F

; Following flags are in Global Storage for inter-fork communication

;F$SEND ; CD  Non-zero SEND, zero RECEIVE
;F$FLST ; CR  File status is being requested
;F$KPGN ; CD  May rename local file to retain generation number
;F$DOPN ; CD  Data connection open
;F$DTRQ ; C   Data xfer requested (inhibit pre-mature "no completion" msg)
;F$DTIP ; CR  Data xfer in progress (set when F$DTRQ cleared)
;F$WORK ; CD  Data is being received (TIMEOK incrs, Cleared by CWFORK loop)
;F$DTDR ; CR  Data xfer completion reply received (set when F$DTIP cleared)
;F$STAR ; CR  Input at command prompt
;F$TCLS ; CRD (Obsolete) Close TELNET & data connections
;F$VBOS ; CR  Verbose mode if non-zero


; Following used by data fork

F.CLSD==<400000,,0> ; D  Connection should be closed at end of data transfer
F.DSK==<0200000,,0> ; D  Local file is on DSK
F.ERR==<0100000,,0> ; D  Error in transfer
F.FDB==<0040000,,0> ; D  Processed FDB
F.IMG==<0020000,,0> ; D  CHANNEL mode bit shuffling required
F.NUL==<0010000,,0> ; D  Receive side going to NUL:
F.RLPT==<004000,,0> ;sD  On if receiving for spooled LPT
F.SEND==<002000,,0> ; D  Distinguish data sends (1) from receives (0) F$SEND
F.TYPX==<001000,,0> ; D  Transfer is PAGED


F.ABOR==<000400,,0> ;sC  Received ABOR during file activity (not tested)
F.ANON==<000100,,0> ;sC  ANONYMOUS login (1)
F.APPE==<000040,,0> ;sC  APPEND (1) versus STOR (0)
F.CMDK==<000020,,0> ;sC  ERRRPL sets this. Causes GETCOM to hang up.
F.LOGI==<000004,,0> ;sC  Job is logged in (1)
F.LTL==<0000002,,0> ;sC  LINEIN sets this. Line was ridiculously long.
F.DGTJ==<0000001,,0> ;CS129 DOGTJ is doing GTJFN not GNJFN...

F.NLST==<0,,200000> ;sC  Distinguish LIST/STAT (0) from NLST (1)
F.NUMA==<0,,100000> ;sC  Flag non-numeric string (1) in ACCOUNT command
F.PASV==<0,,020000> ;sC  In passive mode
F.PDIR==<0,,010000> ;sC  Print directory name, in LIST and STAT
F.QUOC==<0,,004000> ; C  Set when C.QUOTE (^V, Control-V) last char in
F.STAT==<0,,000200> ;sC  STAT (1) versus LIST/NLST (0)
F.TOPN==<0,,000040> ; C  TELNET connection open
F.T1==<000,,000020> ;sC  Directory listing routine - need CR
F.T2==<000,,000010> ;sC  Directory listing routine - extension changed
F.RONL==<0,,000004> ;CS129X RLST command
F.RSTA==<0,,000002> ;CS129X RSTA command
;F.XSEM==<00000004> ;sC  Distinguish XSEM from XSEN

	SUBTTL	MACREL routines we need (SIGH!)

.STKST::ADD P,0(.A16)		;BUMP STACK FOR VARIABLES USED
	JUMPGE P,STKSOV		;TEST FOR STACK OVERFLOW
STKSE1:	PUSH P,0(.A16)		;SAVE BLOCK SIZE FOR RETURN
	PUSHJ P,1(.A16)		;CONTINUE ROUTINE, EXIT TO .+1
.STKRT::JRST STKRT0		;NON-SKIP RETURN COMES HERE
	POP P,.A16		;SKIP RETURN COMES HERE-RECOVER COUNT
	SUB P,.A16		;ADJUST STACK TO REMOVE BLOCK
	AOS 0(P)		;NOW DO SKIP RETURN
	RET

STKRT0:	POP P,.A16		;RECOVER COUNT
	SUB P,.A16		;ADJUST STACK TO REMOVE BLOCK
	RET			;DO NON-SKIP RETURN

STKSOV:	SUB P,0(.A16)		;STACK OVERFLOW- UNDO ADD
	HLL .A16,0(.A16)	;SETUP TO DO MULTIPLE PUSH, GET COUNT
STKSO1:	PUSH P,[0]		;DO ONE PUSH AT A TIME, GET REGULAR
	SUB .A16,[1,,0]		; ACTION ON OVERFLOW
	TLNE .A16,777777	;COUNT DOWN TO 0?
	JRST STKSO1		;NO, KEEP PUSHING
	JRST STKSE1

	SUBTTL	Initialization

; Start of program. Initialize stuff.

GO:	RESET			; Start here, clean slate
	SETZ F,			; All flags off
	MOVE P,GPDP		; Initial stack pointer

;CS129B *** Begin replacement ***
;Don't depend on FTSCTT to pass connection info - get it ourself
;N.B. Someday, this has to be changed when the STAT% jsys is obsolete.

	GJINF			; See what my condition is & save
	SKIPGE A,D		; get line number
	 JRST HANGUP		; detached??
	SETZM FHSTN		; no foriegn host yet
	SETZM LHOSTN		; or local host
	SETZM FORNS		; or foriegn port
	SETZM FTPDAT		; or port number
	TXO A,TCP%TV!TCP%SY	; Argument is TVT, doing symbolically
	MOVX B,<-4,,[ASCII/TFH/	; Want foriegn host
		     ASCII/TLH/	; 	local host
		     ASCII/TFP/	;	foriegn port
		     ASCII/TLP/]> ;	local port
	MOVX C,<-4,,STATMP>	; To temporary area
	STAT%			; Do it...
	IFSKP.			; Success...
	  MOVE A,STATMP		; Get foriegn host
	  MOVEM A,FHSTN		; Save
	  MOVE A,STATMP+1	; local host
	  MOVEM A,LHOSTN
	  MOVE A,STATMP+2	; foriegn port
	  MOVEM A,FORNS
	  MOVE A,STATMP+3	; local port
	  MOVEM A,FTPDAT
	ENDIF.
	SOS A,FTPDAT		; Default Local (Server) Data port is one
	MOVEM A,MYDATS		;  less than control port
;CS129B *** End ***

	MOVX A,.FHSLF		; Get capabilities
	SETOB B,C
	EPCAP

CMU,<	CALL OPNLOG>		;CS129 Go get JFN on log file...
	MOVX D,<T20PAR,,TENEX>	; Assume TOPS20
	MOVE A,['PTYPAR']	; Table to check for system type
	SYSGT
	CAMN A,['PTYPAR']	; If name still there, no such table
	  HRLI D,TNXPAR		; If no such table then TENEX
	BLT D,EOL		; Set system dependent variables

	MOVX A,<.HST20>
	SKIPE TENEX
	  MOVX A,<.HS10X>
	MOVEM A,LHSTYP		; Set our system type

	SUBTTL	Set Program & System Names

	MOVX A,PGSBSY		; Subsystem name
	MOVX B,PGNAME		; Program name
	SKIPN TENEX
	 SETSN			; TOPS20 sets both
	  JFCL
	MOVE A,B
	SKIPE TENEX
	 SETNM			; TENEX only has name
	  JFCL

; Get local host information

	MOVX A,.GTHSZ		; Get local host number from system
	GTHST
	 JRST [MSG <Cannot get local host number from system >
		JRST HALTGO]	; This is fatal for now
				; User leaves it wild to get best address
	MOVE C,D		; And make a string out of it too
	HRROI B,LHSTNM
	MOVX A,.GTHNS
	GTHST			; Ask system for our name
;CS129 *** Begin *** Flush CVHST attempt, reorganize, & add some stuff...
	IFJER.			; Failed
	  MOVE A,[ASCII /Site /]
	  MOVEM A,LHSTNM
	  HRROI A,LHSTNM+1
	  MOVX D,<POINT 8,LHOSTN,3> ; Point at local host number
	  CALL HST4DA		; #.#.#.#
	ENDIF.
	ANDI D,HS%STY		; Extract system type
	MOVEM D,LHSTYP		; Local host system type
ANR,<	SETOM ANONOK >		; Assume anonymous access is OK
	MOVX A,.GTHNS
	HRROI B,FHSTNM		; Place to put 4n host name
	MOVE C,FHSTN		; 4n host number
	GTHST%			; Get it
	 ERJMP [MOVE A,[ASCII /Site /]
		MOVEM A,FHSTNM
	  	HRROI A,FHSTNM+1
	  	MOVX D,<POINT 8,FHSTN,3> ; Point at 4n host number
	  	CALL HST4DA	; #.#.#.#
ANR,<	  	SETZM ANONOK >	; He is random
		JRST HSTDON]
ANR,<	TXNN D,HS%FRI		; Friendly host?
	 SETZM ANONOK		; No... Restrict anonymous access
  >;ANR
HSTDON:
;CS129 *** End ***

	SUBTTL	Build Signon Message

SIGNON:	HRROI A,VERSTR		; Build version message here
	SETZ C,
	HRROI B,LHSTNM		; Sign on message
	SOUT
	OURNAME			; FTP User/Server Program
	SOUT

	LDB B,[POINT 9,VERSIO,11] ; Get major version
	MOVX C,OCTRAD		; Octal numbers
	SKIPE B			; Print if non-zero
	 NOUT
	  JFCL
	LDB B,[POINT 6,VERSIO,17] ; Get minor version
	JUMPE B,VERSI1		; Skip if 0
	SUBI B,1
	IDIVI B,^D26		; Make 2 letters
	JUMPE B,VERSI0		; Any first letter?
	HRRZI B,"A"-1(B)	; Yes, print
	BOUT
VERSI0:	HRRZI B,"A"(C)		; Print second letter
	BOUT
VERSI1:	HRRZ B,VERSIO		; Get edit number
	MOVX C,OCTRAD		; Octal numbers
	JUMPE B,VERSI2		; Skip if edit is 0
	MOVX B,"("		; Print open paren
	BOUT
	HRRZ B,VERSIO		; Get edit number again
	NOUT			; Print it
	  JFCL
	MOVX B,")"		; Print close paren
	BOUT
VERSI2:	LDB B,[POINT 3,VERSIO,2] ; Get group code
	JUMPE B,VERSI3		; Skip if zero
	MOVX B,"-"		; Print -
	BOUT
	LDB B,[POINT 3,VERSIO,2] ; Get group code
	NOUT
	  JFCL
VERSI3:
	MOVX B,C.NUL		; End the string
	BOUT

	SUBTTL FTP Server dependant routines
;
;VAF--FTP2S begins here
;
	MOVX A,<HSBAS/1000>	; Remove access to high segment
	PUSH P,A		; Where the file activity code is
GOSPLP:	MOVX A,<.FHSLF,,0>	; Page in this fork
	HRR A,0(P)		; Here in the address space
	RPACS			; See if the page exists
	TXNN B,PA%PEX
	  JRST GONXTP		; No such page. See if any more.
	MOVX B,1B8		; Access to none, but trap if referenced
	SPACS
GONXTP:	AOS B,0(P)		; On to next page
	CAIGE B,HSPMAX		;CS129C To end of HISEG?
	  JRST GOSPLP		; No, discard another one
	POP P,(P)		; Discard page number

	SUBTTL	Re-Initialization

GOBAK:	SETZ F,			; Clear flags
	MOVX A,^D1000		; Sleep a sec
	DISMS

	MOVE A,PREPLY		; Initialize pointer
	MOVEM A,REPLYP		; and store

	GJINF			; See what my condition is & save
	MOVEM A,GJINF1		; 0 since not logged in (or User #)
	MOVEM B,GJINF2		; Connected directory #
	MOVEM C,GJINF3		; Job #
	MOVEM D,GJINF4		; -1 or attached terminal #

	SKIPN A			; Am I logged in already?
	 TXZA F,F.LOGI		; No.
	  TXO F,F.LOGI		; Yes.

	JUMPGE D,INIT1		; Jump if I'm attached.


	JRST HANGUP
	SUBTTL	Re-Initialization, cont.

INIT1:	TXO F,F.TOPN		; TELNET connection is open

	TXNE F,F.LOGI		; If logged in,
	  CALL GETHI		; Map the high seg back in, unwritable.

	MOVX A,.FHSLF		; Get capabilities
	SETOB B,C		; So can enable Control C,
	EPCAP
	CALL TIMEOK		; Set up initial time before PSI is on
	SETOM TFORKX		; No timing fork yet

	SKIPE DBUGSW		;CS129 Skip this batshit if debugging...
	IFSKP.			;CS129
	  MOVX A,.PRIIN		; Set the wakeup set for the NVT
	  MOVX B,.TTIDL		; Ideal terminal - set for no padding
	  SKIPE TENEX		; Except on TENEX, which has no .TTIDL,
	  MOVX B,.TTNVT		; Use next best thing, and hope no TELNET
				;  handling gets in the way
	  STTYP

	  RFMOD			; See what it is
	  TXZ B,TT%WKP+TT%WKA+TT%UOC+TT%LIC ; Forget the printing characters
				; Make lower case come in and out ok
	  TXO B,TT%WKF+TT%WKN	; Turn on all control char wakeups
	  TXO B,TT%MFF+TT%TAB+TT%LCA ; Allow lower case, TABs, FF's
	  TXZ B,TT%WID+TT%OSP	; Make line width be infinite & half duplex
	  SFMOD			; Put the rest back
	  STPAR

	  MOVX A,<TL%SAB+<0*TL%ABS>+TL%CRO+TL%COR+<0,,-1>>
	  MOVEI B,-1		; Refuse and break links
	  TLINK
	   CALL BOMB

	  SKIPN TENEX		; TOPS-20 lacks ADVIZ
	   JRST INIT1A
				; For TENEX
	  MOVE A,GJINF4		; Terminal number
	  TXO A,.TTDES		; Designator
	  HRLI A,(1B0)		; Clear advice
	  JSYS 315 		; ADVIZ
	   CALL BOMB
	  JRST INIT1B		; Skip a little TOPS-20 stuff
	SUBTTL	Re-Initialization, cont.
INIT1A:

IFN REL4,<
	  MOVX A,.PRIOU		; For this terminal
	  MOVX B,.MOSNT		; We don't want
	  MOVX C,.MOSMN		; System messages
	  MTOPR
CMU,<	  MOVX A,.PRIOU		;CS129
	  MOVX B,.MOSEN		;CS129 Setting user SEND status
	  MOVX C,.MOREF		;CS129 to REFUSE
	  MTOPR%		;CS129
   >				;CS129
>	; End Release 4 conditional

INIT1B:	  MOVX A,.PRIIN		; Set Ctrl chr echoing to all self
	  MOVX B,<BYTE (2)2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2>
	  MOVE C,B
	  SFCOC
	ENDIF.			;CS129X

	SETZM $STRU
	SETZM $MODE		; For file connection and so on
	SETZM $TYPE		; Initialize all params to default
	MOVX A,^D8		; Default byte size
	MOVEM A,$BYTE

	SETZM $FORM
	SETZM $LTYPE
	MOVX A,^D7
	MOVEM A,$LBYTE
	MOVX A,FILTAB+0
	MOVEM A,$FILLB


	SETOM $PATH1
	SETOM $PATH2
	SETOM $SOCK
	SETOM $HOST
;INIT2:
	SETZM USRFCT		; No bad user names yet
	SETZM PASFCT		; No password failures yet.
	SETZM USERNM		; User ID has not been declared yet
				; ID is	TENEX Directory #
				;  or	TOPS-20 User #
	SETZM $CWD		; No CWD argument yet
	SETOM $ACCES+2		; Always connecting this job
	SETZM PRVKWD		; No previous keyword yet,
	SETZM KEYWRD		; And no current one either.
	SETOM LGOCNT		; Init logout forcer counter

	SETOM LCLJFN		; Clear JFN's used later
	SETOM DATCON

	SUBTTL	Once-only Initialization

	SKIPE RESTRT		; Are we restarting? (Came through HANGUP)
	  JRST INIT6		; Yes, skip this next

	SETZM ANOUNO		; No ANONYMOUS User ID
	HRROI B,TXX.AN		; ANONYMOUS
	CALL USRCHK		; Check if ANONYMOUS is a user
	  JFCL
	  SETZ B,		; None if error
	MOVEM B,ANOUNO		; Yes, save the User ID

	SETZM SYSDNM		; See what SYSTEM's User Num is
	HRROI B,TXX.SY		; SYSTEM
	CALL DIRCHK		; See if SYSTEM has a directory
	  CALL BOMB		; What??
	MOVEM B,SYSDNM		; Store it

	SUBTTL	Once-only Initialization, cont.
INIT6:
	SUBTTL	Initialize PSI system & create & start timing fork

PSIINI:	MOVX A,<.TICCC,,CTCCHN>	; Assign ^C interrupt
	SKIPE DBUGSW		; or ^E if debugging
	  MOVX A,<.TICCE,,CTCCHN> ; To this channel
	ATI
	MOVX A,<.TICRF,,DETCHN>	; NVT detaching (^D30, Carrier Off)
	ATI			; To this channel
	MOVX A,<.TICCT,,CTTCHN>	; And Control-T
	ATI

	MOVX A,.FHSLF		; Set up PSI system
	MOVX B,<LEVTAB,,CHNTAB>
	SIR
	MOVE B,ONCHNS		; Turn on these channels
	AIC
	MOVX A,.FHSLF		; Now turn the system on
	EIR

;MAKTFK:
	MOVX A,.FHINF		; Kill all inferiors
	KFORK
	SETOM TFORKX		; No timing fork

	MOVX A,CR%MAP!CR%CAP	; Create a fork for timing

	CFORK			; Create it
	  JRST FULL		; If system can't make it

	HRRZM A,TFORKX		; Save the fork index
	RPCAP			; Make sure it can poke me
	TXO B,SC%SUP
	TXO C,SC%SUP
	EPCAP
	MOVEI B,TFRKSA		; Where it starts
	SFORK			; Start it. It will give me time checks
;FALL THRU
	SUBTTL	IPCF Logging Facility

;FALLS IN FROM ABOVE
IFN IPCLOG,<
GETPID:	MOVX A,IP%CPD		; Get a PID for self
	MOVEM A,PIDARG+.IPCFL
GPIDL:	SETZM PIDARG+.ICPFS	; No PID of sender yet
GPID2:	SETZM PIDARG+.ICPFR	; Receiver is 0, ie <SYSTEM>INFO
	MOVX A,<ENDMSG-INFMSG,,INFMSG>
	MOVEM A,PIDARG+.ICPFP	; The data of the message to INFO

	MOVX A,4		; Count
	MOVEI B,PIDARG		; Descriptor
	MSEND			; Get PID of FTSCTL
	 JRST [ MOVX A,^D1000
		DISMS
		JRST GPIDL]
	MOVX B,IP%CPD		; Don't create another
	ANDCAM B,PIDARG+.ICPFL
	MOVE A,PIDARG+.ICPFS	; Stash my new PID
	MOVEM A,MYPID
GETAGN:	SETZM PIDARG+ICPFL	; No flags
	SETZM PIDARG+.ICPFS	; No particular sender
	MOVE A,MYPID		; I am receiver
	MOVEM A,PIDARG+.ICPFR
	MOVX A,<10,,IPCDAT>	; Receive this much data
	MOVEM A,PIDARG+.ICPFP

	MOVX A,4		; Length of descriptor
	MOVEI B,PIDARG		; Addr of descriptor
	MRECV
	  JFCL
	MOVE A,PIDARG+.ICPFL	; Get flags
	ANDI A,7B32
	CAIE A,1B32		; Sent by monitor? <SYSTEM>ICPF .ICPCC
	CAIN A,2B32		; Sent by INFO? <SYSTEM>INFO .ICPCF
	SKIPA			; Yes.
	  JRST GETAGN		; No, not interested.
	MOVE A,PIDARG+.ICPFL
	TRNE A,7 ;IP%CFM	; Was the packet undeliverable?
	  JRST GPID2		; Yes.
	TRNE A,77B29 ;IP%CFE	; Trouble?
	  JRST GETAGN		; Yes.
	MOVE A,IPCDAT+.ICPI1	; Get FTSCTL's PID
	MOVEM A,CTLPID		; Save it.
>


	HRROI A,[ASCIZS (300,220,< >)]
	PSOUT
	MOVX A,.PRIOU		; Output greeting
	HRROI B,VERSTR
	SETZ C,
	SOUT

	HRROI A,[ASCIZ / at /]
	PSOUT
	MOVX A,.PRIOU
	SETO B,0		; Current time stamp
	MOVX C,<OT%DAY+<0*OT%FDY>+OT%NSC+OT%TMZ+OT%SCL>
	ODTIM			; Format of time

	HRROI A,CRLFM
	PSOUT
	JRST GETCOM		; Go read first command

	SUBTTL	Error Replys - NOLINE, SYNERR, ARGSYN, FULL


;	JRST NOLINE	NVT/TVT Detached, thus no reply possible

NOLINE:	GJINF			; See if I got detached
	JUMPL D,HANGUP		; If so, hang up and logout
	JSP B,RPCRLP		; Must be super long line
	ASCIZS (500,500,< Last line was not comprehensible.>)




;	JRST SYNERR	Bad Initial Character in Command Line

SYNERR:	JSP B,RPCRLP		; Syntactical error in command
	ASCIZS (501,500,< Syntax error at start of last command line.>)




;	JRST SYNERR	Bad Character after Verb

SYNER2:	JSP B,RPCRLP
	ASCIZS (501,500,< Syntax error - Character after command verb is bad.>)




;	JRST ARGSYN	Bad Argument Syntax

ARGSYN:	CALL BEGREP		; Here to complain of argument syntax
	ASCIZS (502,501,< Syntax error in argument of >)
	CALL ADDKEY		; Append 6-bit keywrd
	JSP B,RPCRLP		; Close off msg
	ASCIZ / command./

	SUBTTL	Error Replys - BOMB, NVTNLI, FULL

;	CALL BOMB	Fatal Error, return gives PC
;NEVER RETURNS		May be called BEFORE initialized

BOMB:	MOVEM 16,PI3AC+16	; Save ACs
	MOVX 16,<0,,PI3AC>
	BLT 16,PI3AC+15

	POP P,C			; Return
	MOVEI C,-1(C)		; Address w/o flags

	MOVEM P,PI3AC+17

	HRROI B,[ASCIZS (435,421,< Fatal system error at >)]
	MOVEI D,PI3AC
	CALL DMPREG

	HRROI A,[ASCIZ / Goodbye./]
	PSOUT
	JRST HANGUP



;	JRST NVTNLI	Don't allow Network logins

NVTNLI:	JSP B,ERRRPL		; Don't allow the LOGIN - due to TMON
	ASCIZS (453,421,< Network logins not allowed at this time. Please try later.>)



;	JRST FULL	System is Full

FULL:	JSP B,ERRRPL		; Cause hangup after sending this
	ASCIZS (401,421,< Service full, please try later. Goodbye.>)

	SUBTTL	Reply Subroutines - BEG/ADDREP, ADDARG, ADDKEY, SYNER2

;	CALL ADDREP or BEGREP	Add to or begin a new reply message
;	ASCIZ /.../
;	<RETURN HERE>

BEGREP:	SKIPA A,PREPLY		; Begin a new reply
ADDREP:	  MOVE A,REPLYP		; Add text after call to reply buffer
	HRRO B,0(P)		; String ptr to text
	SETZ C,			; ASCIZ form
	SOUT
	MOVEM A,REPLYP		; Update reply pointer
	HRRM B,0(P)		; Pointer to word with NULL
	AOS 0(P)		; One more is where to return to
	RET			; Return there.




;	CALL ADDARG (ARGWRD)	CALL ADDKEY (KEYWRD)
;LEAVES		A/ Pointing to end of text (after NULL)
;UPDATES	REPLYP (Before NULL)
;PRESERVES	B
;KILLS		C

ADDARG:	HRROI C,ARGWRD		; Append ARGWRD to reply REPLYP
	SKIPA
ADDKEY:	  HRROI C,KEYWRD	; Append KEYWRD to reply REPLYP
	PUSH P,B		; Save
	MOVE A,REPLYP		; Add sixbit word in C to reply
	MOVE B,C
	SETZ C,
	SOUT
	MOVEM A,REPLYP		; End of reply so far
	IDPB C,A		; Append NULL.
	POP P,B			; Restore
	RET

	SUBTTL	Error Message Completion

;	JRST NOTIMP	Unimplemented Command

NOTIMP:	CALL BEGREP
	ASCIZS (506,502,< The >)
	CALL ADDKEY		; Append verb to message
	JSP B,RPCRLP
	ASCIZ / command is not yet implemented./

PCRLF:	HRROI A,CRLFM
	PSOUT
	RET

CRLFM:	BYTE (7)C.CR,C.LF,C.NUL

PREPLY:	POINT 7,REPLYM




;	MOVX B,[ASCIZ /.../]
;	JRST ERRRPL/RPCRLP
; OR
;	JSP B,ERRRPL/RPCRLP
;	ASCIZ /.../

NURPLY:	MOVE A,PREPLY		; Start over
	JRST RPCRLP+1	; ******
ERRRPL:	  TXO F,F.CMDK		; Flag this was a fatal error
RPCRLP:	  MOVE A,REPLYP		; Append msg in B to reply
	SETZ C,			; It's ASCIZ
	HRLI B,(POINT 7,0)	; String pointer (allows JSP B,RPCRLP)
	SOUT
	HRROI B,CRLFM		; Append CRLF
	SOUT
	HRROI A,REPLYM		; Now send it down TELNET line
	PSOUT
;	JRST GETCOM		; And get another command
;FALL INTO GETCOM

	SUBTTL	Get Next Command

; Here to get a command line. First see if system still up

GETCOM:	MOVE A,PREPLY		; Initialize pointer to reply
	MOVEM A,REPLYP		; For other routines to append to
	MOVE P,GPDP		; Restore stack level, just in case.
	CALL TIMEOK		; Mark that timeout hasn't happened

	TXNE F,F.CMDK		; Asked to kill job before cmd reading?
	  JRST HANGUP		; Yes, do so.
	MOVX A,<'ENTFLG'>	; See if system still open
	SYSGT
	JUMPE B,GETCM1		; If no such table,
	JUMPN A,GETCM1		; Or ENTFLG is non-zero, go to it
SHUTDN:	JSP B,ERRRPL		; Hang up on him
	ASCIZS (436,421,< Service shutting down. Goodbye.>)
;CWL spontaneous response violates protocol??

GETCM1:
	CALL LINEIN		; Collect a command line from TTY
	  JRST NOLINE		; EOF or super-long line

	MOVX A,<'ENTFLG'>	; Flag went off during typein wait, maybe
	SYSGT
	JUMPE B,GETCM2		; Continue if no flag avail
	JUMPN A,GETCM2		; Or flag still ok
	JRST SHUTDN		; No good. Hang up.
GETCM2:
	SKIPN CMDIB		; Blank line?
	  JRST [JSP B,RPCRLP	; Blank line
		ASCIZ /200 Blank line ignored./]

	MOVX BP,<POINT 7,CMDIB>	; Initialize saved byte pointer
GETCM3:	MOVEM BP,SBP
	ILDB C,BP		; Skip leading spaces and tabs
	CAIE C,C.SPACE		; SST routine fails at start of line
	CAIN C,C.TAB		; So do it this way
	  JRST GETCM3		; That was a space. Skip it.

	HRROI B,[ASCIZ /200 Comment OK./]
	CAIN C,C.COMNT		; Let's allow comments
	  JRST RPCRLP		; Line started with semicolon
; Fall thru

	SUBTTL	Get Next Command, cont.

; Falls thru from above
		
	CALL GETWRD		; Collect a word
	  JRST SYNERR		; Didn't start with a good character

	LDB C,SBP		; Get the break character
	CALL SST		; Step over spaces or tabs
	JUMPE A,SYNERR		; Bad if first char on line not alphanum.

	CAIE C,C.SPACE		; Spacing character after verb?
	CAIN C,C.TAB
	  SKIPA			; Yes
	JUMPN C,SYNER2		; Jump unless end of line

	SKIPN C,KEYWRD		;CU1 Any previous keyword?
	IFSKP.			;CU1 Yes, and not PASS?
	 CAME C,[ASCIZ "PASS"]	;CU1 We want to allow multiple PASS attempts
	  MOVEM C,PRVKWD	; Yes, save it.
	ENDIF.			;CU1
	MOVEM A,KEYWRD		; Save the sixbit keyword

	MOVX C,<-NCOMS,,COMAND+1> ; See if we can find the keyword
	HLRZ D,(C)
	CAMN A,(D)		; This one?
	  JRST KEYFND		; Yes
	AOBJN C,.-3		; No, look thru list
NOTKEY:	CALL BEGREP
	ASCIZ /500 I never heard of the /
	CALL ADDKEY		; Append keyword
	SETZM KEYWRD		; So don't move garbage into PRVKWD
	JSP B,RPCRLP		; Finish the line
	ASCIZ / command. Try HELP./

KEYFND:	HRRZ B,(C)		; Dispatch to routine
	TRNE B,400000		; Need to be logged in? (highseg routine)
	 TXNE F,F.LOGI		; Yes. Am I?
	  SKIPA			; Logged in, or don't need to be
	   JRST [JSP B,RPCRLP	; No good. Complain.
		 ASCIZS (451,530,< Please log in first, with USER, PASS and ACCT.>)]
	CALL 0(B)		; Call it (must set B to message)
	  JRST RPCRLP
	JRST RPCRLP

	SUBTTL	Command Definitions

C.LGN==1B18	; Need to log in to use this command  NB: LH sign bit

DEFINE COMS <		; Keywords
CC (USER,0)
CC (PASS,0)
CC (ACCT,0)
CC (HELP,0)
CC (ABOR,0)
CC (NOOP,0)
CC (QUIT,0)
CC (SITE,0)
CC (REIN,0)
CC (MSND,0)
CC (MSOM,0)
CC (MSAM,0)
CC (MRCP,0)
CC (PORT,C.LGN)
CC (PASV,C.LGN)
CC (SMNT,C.LGN)
CC (TYPE,0)
CC (STRU,0)
CC (MODE,0)
CC (RETR,C.LGN)
CC (STOR,C.LGN)
CC (APPE,C.LGN)
CC (RNFR,C.LGN)
CC (RNTO,C.LGN)
CC (DELE,C.LGN)
CC (LIST,C.LGN)
CC (NLST,C.LGN)
CC (RLST,C.LGN)			;CS129X
CC (ALLO,C.LGN)
CC (REST,C.LGN)
CC (STAT,0)		; Allow STAT<RETURN>
CC (RSTA,C.LGN)			;CS129X
CC (CWD,C.LGN)
; FOLLOWING ARE NOT PART OF FORMAL SYNTAX BUT ARE ACCEPTED
CC (NOP,0)
CC (DEBUG,C.LGN)
CC (CRASH,0)
CC (BOMB,0)
>
	SUBTTL	Command Symbol & Dispatch Table

DEFINE CC(A,B)<	XWD [ASCIZ \A\],Z'A
IFE B,<.IF Z'A,RELOCATABLE,<PRINTX ? Move Z'A to low segment>>
IFN B,<.IF Z'A,ABSOLUTE,<PRINTX ? Move Z'A to high segment>>
> ; End of DEFINE CC

COMAND:	XWD NCOMS,NCOMS		; Maybe COMND...
	COMS
NCOMS==.-COMAND-1		; Length of table

	SUBTTL	Subroutines - LINEIN - Get Next Input Line

; The line collector. Performs character and word and line editting.
; Reads a line into CMDIN buffer, terminated by NULL, CRLF stripped off.
;	CALL LINEIN
;Ret+1:	  Blank
;Ret+2: Have line

LINEIN:	PUSH P,P1
	PUSH P,P2
	PUSH P,P3
				; Reenter here on line delete
LINICU:	TXZ F,F.LTL!F.QUOC	; Clear this routine's flags
	MOVX P1,<5*LCMDIB>-3	; Maximum line length to read
	MOVE P2,LINEIP		; Initial byte pointer to buffer
	SETZM CMDIB		; Clear the buffer, to be neat
	MOVX A,<CMDIB,,CMDIB+1>
	BLT A,CMDIB+LCMDIB-1

LININL:	CALL TELBIN		; BIN from NVT
	  JRST LININX		; Non-skip if TTY gets EOF
	TXZE F,F.QUOC		; C.QUOTE (^V) seen?
	  JRST LININ2		; Yes. Store character EXACTLY
	CAIN B,C.LF		; Is it a linefeed?
	  JRST LINEOL		; Yes. Quit.
	CAIE B,C.NUL		; NUL or CR?
	 CAIN B,C.CR
	  JRST LININL		; Yes, ignore completely

	CAIE B,C.BS		; Editting. Backspace?
	 CAMN B,CDELCH		; Editting character delete?
	  JRST LINICH		; Yes
	CAMN B,CDELWD		; Editting word delete?
	  JRST LINICW		; Yes
	CAMN B,CDELLN		; Editting line delete?
	  JRST LINICU		; Yes.

	CAIN B,C.QUOTE		; Super-Quote?
	  TXO F,F.QUOC		; Flag Control-V seen, then store it
LININ2:	IDPB B,P2		; Store this character
	SOJG P1,LININL		; Accumulate line
	TXO F,F.LTL		; Line too long
LININX:	POP P,P3		; Non-skip return
	POP P,P2
	POP P,P1
	RET

LINEOL:	SETZ B,			; Normal end of line. Terminate with EOL
	IDPB B,P2		; Terminate the string
	AOS -3(P)		; Skip return
	JRST LININX
LINEIP:	010700,,CMDIB-1		; Initial pointer to buffer
	SUBTTL	Subroutines - LINEIN - Editing Routines LINICH, LINICW

LINICH:	CAMN P2,LINEIP		; Already at start of line?
	  JRST LININL		; Yes, ignore this ^A
	MOVX B,C.NUL		; Clobber the current character
	DPB B,P2
	ADD P2,[070000,,0]	; Back up the pointer
	SKIPGE P2		; If off end of word,
	  SUB P2,[430000,,1]	; Previous word.
	AOJA P1,LININL		; Un-count the deleted character


LINICW:	LDB B,P2		; Get current character
	CALL ALNUMQ		; Skip if alphanumeric
	  JRST LINCW1		; No, a break char.
LINCW2:	MOVX B,C.NUL		; This is alphanumeric. Clobber it.
	DPB B,P2
	ADDI P1,1		; Un-count it.
	ADD P2,[070000,,0]	; Back up pointer
	SKIPGE P2
	  SUB P2,[430000,,1]
	CAMN P2,LINEIP		; Back to start of buffer?
	  JRST LININL		; Yes. Done deleting
	LDB B,P2		; No, see if this is still in the word.
	CALL ALNUMQ		; Skip if alphanumeric
	  JRST LININL		; Break. Done.
	JRST LINCW2		; Still in word. Go delete it.

LINCW1:	MOVX B,C.NUL		; Current char is a break. Get back to
	DPB B,P2		; Word before break(s), then delete it.
	ADDI P1,1		; Delete break character
	ADD P2,[070000,,0]
	SKIPGE P2
	  SUB P2,[430000,,1]
	CAMN P2,LINEIP		; Back to start of buffer?
	  JRST LININL		; Yes. Quit.
	LDB B,P2		; See if multi-breaks after last word
	CALL ALNUMQ		; Alphanumeric?
	  JRST LINCW1		; No, more breaks. Delete this one too
	JRST LINCW2		; Into the word. Delete the word.

	SUBTTL	Subroutines - ALNUMQ

;	B/ CHARACTER
;	CALL ALNUMQ	; Alphanumeric?
;	  RET+1		; Break
;	RET+2		; Alphanumeric or -
;PRESERVES ALL

ALNUMQ:	CAIL B,"a"		; Lower case?
	CAILE B,"z"
	SKIPA			; No.
	  JRST ALNUMS		; Yes. Skip return.
	CAIL B,"A"		; Upper case?
	CAILE B,"Z"
	SKIPA			; No
	  JRST ALNUMS		; Yes. Skip return
	CAIL B,"0"		; Digit?
	CAILE B,"9"
	SKIPA			; No
	  JRST ALNUMS		; Yes. Skip return.
	CAIN B,"-"		; Hyphen?
ALNUMS:	  AOS 0(P)		; Yes. Skip return
	RET			; Something else. Non-skip.

	SUBTTL	Subroutine - GETWRD

;	SBP/ Points to input
;	CALL GETWRD	Get word
;	  RET+1		; No word before break
;	RET+2		; ASCIZ word in a
;Saves all but A, BP	SBP updated to point to break

GETWRD:	PUSH P,B		; Answer to A, preserve B and C
	PUSH P,C

	MOVE BP,SBP		; Current byte pointer
	SETZ A,			; Clear the answer
	MOVX C,<POINT 7,A>	; Start pointer to answer

GETWRL:	ILDB B,BP		; Get a character
	CALL ALNUMQ		; A-Z, 0-9, or Hyphen?
	  JRST GETWR1		; No, break character

	CAIL B,"a"		; If lower case
	 CAILE B,"z"
	  SKIPA
	   TRZ B,40		; Make upper

	TLNE C,760000		; Room for another character?
	  IDPB B,C		; Yes, store in keyword
	JRST GETWRL		; On to the break

GETWR1:	MOVEM BP,SBP		; Update stored byte pointer (points to break)

	POP P,C			; Restore AC's
	POP P,B
	SKIPE A			; Skip return unless no word
	  AOS 0(P)		; Skip return
	RET

	SUBTTL	Subroutines - SST

;	SBP point to next input character
;	CALL SST	Skip over tabs and spaces
;PRESERVES ALL

SST:	PUSH P,A		; Skip spaces and/or tabs at current SBP
	TXZ F,F.QUOC		; Flag first character
SSTL:	LDB A,SBP		; Get the current character
	CAIE A,C.SPACE		; Is it a space or tab?
	CAIN A,C.TAB
	  TXOA F,F.QUOC		; Yes. Flag moving up at least one char.
	    JRST SST01		; No. Quit here
	IBP SBP			; It's a space/tab. Move past it
	JRST SSTL		; And go check the next one.
SST01:	TXZN F,F.QUOC		; Unless didn't move forward at all.
	  JRST SST3		; In which case leave it here.
	MOVX A,<070000,,0>	; Back up so ILDB gets the non-space
	ADD A,SBP
	SKIPGE A
	  SUB A,[430000,,1]
	MOVEM A,SBP
SST3:	JRST APOPJ

	SUBTTL	Subroutines - TELBIN

;	CALL TELBIN	Get Input Character
;	  RET+1		; EOF
;	RET+2		; Character in B

TELBIN:	MOVX A,.PRIIN		; BIN from primary input
	BIN			; Character to AC B
	JUMPE B,[MOVX A,.PRIIN
		 GTSTS		; See if EOF or NULL
		 TXNN B,GS%EOF
		  JRST TELBIN	; Discard the NULL.
		 RET]		; EOF. Give non-skip return. But
				; Detach will probably cause PSI anyhow
; Cannot do this if looking for escapes, etc
; 	TRZ B,200		; Clear bit 200

	CAIN B,C.CR		; CR's?
	  JRST TELBIN		; Wait for LF
	CAIN B,TNXEOL		; TENEX EOL? (Not occur in TCPP)
	  MOVX B,C.LF		; Become linefeeds

CPOPJ1:	AOS 0(P)		; Ok. Skip return.
	RET

	SUBTTL	Subroutines - FORCLO, HANGUP, LOGOUT

;	JRST FORCLO	On timeout interrupt/abort
;CWL does this "extra" message violate protocol

FORCLO:	HRROI A,[ASCIZS (434,421,< Autologout - job idle too long/time exceeded without login.
>)]				;CS129
	PSOUT
;	JRST HANGUP


;	JRST HANGUP	Close TELNET connection & logout
;			may be called BEFORE initialized

HALTGO:				; (Compatability)
HANGUP:	MOVE P,GPDP		;CS129 Restore stack level, just in case.
	CLOSD DATCON		; Make sure data connection is closed

	GJINF			; Get latest TTY number
	JUMPL D,NOCLSD		; If already detached
;CS129A	MOVX A,.PRIOU		; Wait for end of output
;CS129A	DOBE
	MOVX D,^D15		;CS129A Wait 15 seconds max (like LGOUT jsys)
	DO.			;CS129A
	  MOVX A,.PRIOU		;CS129A
	  SOBE			;CS129A Output buffer empty yet?
	  TRNA			;CS129A Nope.
	  EXIT.			;CS129A Yes. Done
	  MOVEI A,^D1000	;CS129A Wait a little while for it
	  DISMS%		;CS129A
	  SOJG D,TOP.		;CS129A Try again or punt
	ENDDO.			;CS129A
	SKIPN DBUGSW		; Don't close TTY if debuging
	  CALL CLSTTY		; Close the terminal
NOCLSD:
; ;;;	CALL DELTMP		; Flush and delete temp file if exists

	CALL LOGOUT		; LOGOUT or HALTF if debugging

	MOVE P,GPDP		; Restore stack level, just in case.
	MOVX A,.FHSLF		; For this fork
	CIS			; And clear pending ones
	CALL TIMEOK		; Reset clock
	SETOM RESTRT		; Mark ourselves as RESTARTING
	SETO A,			; Make us as clean as possible
	CLOSF			; by closing
	  SETO A,
	RLJFN			; and releasing
	  JFCL			; all JFNS
	JRST GOBAK		; And return to start

;	CALL LOGOUT	LOGOUT (no return) unless debuging (halt & return)

LOGOUT:	SETO A,			; Logout me
	SKIPN DBUGSW		;  But not if debuging
	 LGOUT
	  ERJMP [HALTF]		;#2 die on failure
	SKIPE DBUGSW
	  HALTF			; Halt if debuging
	RET

	SUBTTL	Subroutines - CLSTTY

; Try to detach TTY and close the connection so system logout message
; isn't sent to server -- its not part of the protocol.

;	CALL CLSTTY	Close/Detach TTY

CLSTTY:	DTACH			; Get off the TTY
	SKIPN TENEX		; Different on TOPS20
	  JRST CLSTTX
; TENEX
	MOVEI A,.TTDES(D)	; TENEX - line # to a TTY dev designator
	ASND			; Assign it
	  RET
	MOVEI A,.TTDES(D)	; Again
	RELD			; Cause the NVT to close
	  JFCL
	RET

; TOPS20
CLSTTX:	HRROI A,GTJSTR		; TOPS-20
	HRROI B,[ASCIZ /TTY/]
	SETZ C,
	SOUT			; Build TTY name
	MOVEI B,(D)
	MOVX C,OCTRAD		; Octal TTY #
	NOUT
	  JFCL
	HRROI B,[ASCIZ /:/]
	SETZ C,
	SOUT
	MOVX A,GJ%SHT		; Now get JFN for it
	HRROI B,GTJSTR		; Point to string
	GTJFN
	  RET
	PUSH P,A		; Save JFN for later
	MOVX A,.FHSLF		; Adjust caps
	RPCAP
	PUSH P,C		; Save these to restore
	PUSH P,B
	TRZ C,-1		; Ask for everything
	EPCAP
	MOVE A,-2(P)		; Now open TTY
	MOVX B,<FLD(7,OF%BSZ)+OF%WR>
	OPENF
	  JFCL
	MOVX A,.FHSLF
	POP P,B			; Capabilities to be restored
	POP P,C
	EPCAP
	POP P,A			; JFN to be closed & released
	CLOSF			; This to close net conn.
	  JFCL			; Shouldnt fail
	RET

	SUBTTL	Subroutines - DECIN (OCTIN)

; Numeric input routine. Decimal unless preceded by "O" or "X".
;	BP/ Points to separator before input
;	CALL DECIN
; Ret+1	  Bad input
; Ret+2	A/ number
;Kills C;  Saves B,D;  BP/ points to break

DECIN:	ILDB C,BP		; Skip separator first
	SETZ A,			; Collect number here
	PUSH P,BP		; Save original byte POINTER
DECINL:	CAIL C,"0"		; Decimal digit?
	CAILE C,"9"
	  JRST DECINX		; No.
	IMULI A,DECRAD		; Yes, accumulate number
	ADDI A,-"0"(C)
	ILDB C,BP		; On to next character
	JRST DECINL		; See if break or digit

DECINX:	CAME BP,0(P)		; Has any digit been seen?
	  JRST RADIXY		; Yes, skip return
	CAIE C,"O"		; Octal prefix?
	CAIN C,"o"		; Or lower case "O"
	  JRST OCTIN		; Yes. Go read it
	CAIE C,"X"		; Hex input?
	CAIN C,"x"
	  JRST HEXIN		; Yes. Go collect hex number
	JRST RADIXZ		; No good. Discard pointer on stack
				; and give non-skip return

OCTIN:	ILDB C,0(P)		; Update start of number, skip the "O"
	MOVE BP,0(P)
OCTINL:	CAIL C,"0"		; Octal digit?
	CAILE C,"7"
	  JRST RADIXX		; No. Quit.
	LSH A,3			; Yes. Accumulate number
	ADDI A,-"0"(C)
	ILDB C,BP		; Get next character
	JRST OCTINL		; See if end of number

	SUBTTL	Subroutines - DECIN (HEXIN)

HEXIN:	ILDB C,0(P)		; Skip the "X". Update start of number
	MOVE BP,0(P)
HEXINL:	CAIL C,"a"		; Lower case letter?
	CAILE C,"z"
	SKIPA			; No
	  TRZ C,"a"-"A"		; Yes. Make upper case
	CAIL C,"A"		; Now, is it a hex digit-letter?
	CAILE C,"F"
	SKIPA			; No
	  SUBI C,"A"-"9"-1	; Yes. Squunch down to digits
	CAIL C,"0"		; Digit (including A-F)?
	CAILE C,"0"+17
	  JRST RADIXX		; No
	LSH A,4			; Yes. Accumulate number
	ADDI A,-"0"(C)
	ILDB C,BP		; On to next character
	JRST HEXINL		; Continue till break character

RADIXX:	CAME BP,0(P)		; Any digits seen at all?
RADIXY:	AOS -1(P)		; Yes. Skip return
RADIXZ:	POP P,(P)		; Discard starting byte pointer
	RET

	SUBTTL	Subroutines - DIRCHK

; Dirchk checks a directory name
; B/	A pointer to the name (W/ or W/o PS:<...>)
;	CALL DIRCHK
; Ret+1	  If fails
; Ret+2	Recognized, directory number in B

DIRCHK:	PUSH P,A		; Save some AC's
	PUSH P,B
	PUSH P,C
	SKIPN TENEX
	  JRST DIRCK1
	SETZ A,			; TENEX
	STDIR
	  JRST DIRCK6
	  JRST DIRCK6
	HRRZ C,A		; Hw directory number
	JRST DIRCK4
DIRCK1:	MOVX A,RC%EMO		; TOPS-20 exact match only
	RCDIR			; Try to recognize
	  ERJMP DIRCK2		; If fail
	TXNN A,RC%NOM!RC%EMO	; Check if good
	  JRST DIRCK4		; Yes
DIRCK2:	HRROI A,RCDSTR		; Where to build string
	HRROI B,[ASCIZ /PS:</]	; Start of string
	SETZ C,
	SOUT
	MOVE B,-1(P)		; Pointer
	SOUT
	HRROI B,[ASCIZ />/]
	SOUT			; And finish with new string
	MOVX A,RC%EMO
	HRROI B,RCDSTR
	RCDIR			; And try again with new string
	  ERJMP DIRCK6		; Still bad
	TXNE A,RC%NOM!RC%AMB	; Exists?
	  JRST DIRCK6		; No
DIRCK4:	MOVE B,C		; Yes, number into B
	AOS -3(P)		; Skip return
DIRCK6:	POP P,C			; Restore C
	POP P,(P)		; Discard pointer
	POP P,A
	RET			; And return

	SUBTTL	Subroutines - USRCHK - Validate User Name String
; USRCHK Checks a user name string
;	B/	a pointer to the name
;	CALL USRCHK
;	  RET+1		If fails
;	  RET+2		FILES-ONLY
;	RET+3		Recognized, User ID # is in B

;User ID number is	TOPS-20 User Number (36-bit)
;			TENEX Directory Number (18 bit)

USRCHK:	PUSH P,A		; Save some AC's
	PUSH P,B
	PUSH P,C

	SKIPN TENEX
	  JRST USRCK1		; TOPS-20
				; TENEX
	SETZ A,			; Positive number for exact match
	STDIR			; Check name pointed to by B
	  JRST USRCK6		; No match
	  JRST USRCK6		; Ambiguous
	HRRZ B,A		; TENEX directory number
	TXNE A,1B0		; FILES-ONLY?
	  JRST USRCK4		; Yes, lose (but return number)
	JRST USRCK2		; No, ok

USRCK1:	MOVX A,RC%EMO		; Exact match only
	RCUSR			; Try to recognize
	ERJMP USRCK6		; Fail
	MOVE B,C		; Possible user # to B
	TXNN A,RC%NOM!RC%AMB	; Exists?
	  JRST USRCK2		; Yes
				; No, or FILES-ONLY
	EXCH B,-1(P)		; Restore pointer & save user #
	CALL DIRCHK		; Special test for FILES-ONLY
	  JRST USRCK6		; Not even FILES-ONLY
	MOVE B,-1(P)		; Get back user #
	JRST USRCK4		; Ok means FILES-ONLY

USRCK2:	AOS -3(P)		; Ok ret+3
USRCK4:	AOS -3(P)		; FILES-ONLY ret+2
USRCK6:	POP P,C			; Restore C
	POP P,(P)		; Drop B
	POP P,A
	RET			; And return

	SUBTTL	Subroutines - SNDCTL
IFN IPCLOG,<			; Don't use this feature yet
SNDCTL:	PUSH P,A
	PUSH P,B
	PUSH P,C
	SETZM PIDARG+.ICPFL	; Send data to FTSCTL
	MOVX C,3		; Try three times
SNDCT1:	MOVE A,MYPID
	MOVEM A,PIDARG+.IPCFS
	MOVE A,CTLPID
	MOVEM A,PIDARG+.IPCFR
	MOVX A,<20,,IPCDAT>	; Should put correct length on
	MOVEM A,PIDARG+.IPCFP

	MOVX A,4		; Length of descriptor
	MOVEI B,PIDARG		; Addr of descriptor
	MSEND
	  JRST [MOVX A,^D1000
		DISMS
		SOJGE C,SNDCT1
		JRST .+1]
	POP P,C
	POP P,B
	POP P,A
	RET
>
	SUBTTL	Subroutines - TIMEOK

;	CALL TIMEOK	; Still ok, set timer fork for WATTIM from now

TIMEOK:	PUSH P,A		; Update time till hangup forced
	MOVEI A,TMLINI		;CS129 Assume logged-in
	TXNE F,F.LOGI		;CS129 Not-logged-in?
	TXNE F,F.ANON		;CS129 or ANONYMOUS?
	MOVEI A,TMOINI		;CS129 Use this counter, then
	MOVEM A,TMOCNT		;CS129 Reset timeout counter
IFN DEBUG,<			;CS129
	PUSH P,B		;CS129 Save some more stuff here
	PUSH P,C		;CS129
	HRROI A,[ASCIZ/100 Timer update, TMOCNT=/] ;CS129
	PSOUT%			;CS129
	MOVEI A,.PRIOU		;CS129
	MOVE B,TMOCNT		;CS129
	MOVEI C,^D8		;CS129
	NOUT%			;CS129
	 TRN			;CS129
	HRROI B,[ASCIZ/
/]				;CS129
	SETZ C,			;CS129
	SOUTR%			;CS129
	POP P,C			;CS129
	POP P,B			;CS129
   >				;CS129

APOPJ:	POP P,A
	RET

	SUBTTL	Forks - TFORKX/TFRKSA - Timing Fork

; Timing fork to wake us up each minute

TFRKSA:	MOVX A,^D60000
	DISMS
	MOVEI A,.FHSUP		; My superior
	MOVX B,<1B<TIMCHN>>	; Channel to poke him on
	IIC			; Do so
	JRST TFRKSA		; And return

	SUBTTL	PSI Handlers - Level 1 (Fatal) - INSINT, MEMINT, PDLINT, FULINT

INSINT:	MOVEM 17,PI1AC+17	; Stash the AC's
	MOVEI 17,PI1AC
	BLT 17,PI1AC+16
	MOVE P,L1PDP		; Set up a stack
	JSP B,L1INTS
	ASCIZS (,,<Illegal Instruction trap>)



MEMINT:	MOVEM 17,PI1AC+17	; Stash the AC's
	MOVEI 17,PI1AC
	BLT 17,PI1AC+16
	MOVE P,L1PDP		; Set up a stack
	JSP B,L1INTS
	ASCIZS (,,<Illegal memory reference trap>)



PDLINT:	MOVEM 17,PI1AC+17	; Stash the AC's
	MOVEI 17,PI1AC
	BLT 17,PI1AC+16
	MOVE P,L1PDP		; Set up a stack
	JSP B,L1INTS
	ASCIZS (,,<Pushdown stack overflow trap>)



FULINT:	MOVEM 17,PI1AC+17	; Stash the AC's
	MOVEI 17,PI1AC
	BLT 17,PI1AC+16
	MOVE P,L1PDP		; Set up a stack
	JSP B,L1INTS
	ASCIZS (,,<Disk or Drum overflow>)


; Output registers and error message, if possible

L1INTS:	MOVE C,RETPC1		; PC
	MOVEI D,PI1AC		; Pointer to registers
;CU2 Begin addition
	MOVEI A,L1INTX		; Where to continue
	MOVEM A,RETPC1		; Put where DEBRK% can find it
	DEBRK%			; Get out of this psi before trying to
	 ERJMP .+1		;  write to the terminal, so we don't
L1INTX:				;  miss carrier off and hang on tty output.
;CU2 End addition
	CALL DMPREG		; Tell the bad news
	HRROI A,[ASCIZ / Goodbye.
/]
	PSOUT
	ERJMP .+1
	JRST HANGUP

	SUBTTL	PSI Handlers - Level 2 (Non-Fatal) - TIMINT, DETINT

; Timeout

TIMINT:	MOVEM 17,PI2AC+17	; Stash the AC's
	MOVEI 17,PI2AC
	BLT 17,PI2AC+16
	MOVE P,L2PDP		; And set up a stack
IFN DEBUG,<			;CS129
	HRROI A,[ASCIZ/100 Timer int, TMOCNT=/] ;CS129
	PSOUT%			;CS129
	MOVEI A,.PRIOU		;CS129
	MOVE B,TMOCNT		;CS129
	SUBI B,1		;CS129 Since it will be decremented...
	MOVEI C,^D8		;CS129
	NOUT%			;CS129
	 TRN			;CS129
	HRROI B,[ASCIZ/
/]				;CS129
	SETZ C,			;CS129
	SOUTR%			;CS129
>				;CS129
	SOSLE TMOCNT		;CS129 Count another timeout
	 JRST L2DBRK		;CS129 Not enough yet... leave job alone
	TXNN F,F.ANON		;CS129 Yes. ANONYMOUS user?
	 TXNN F,F.LOGI		; Or not logged in at all?
	  SKIPA			; Yes. Autologout him.
	   JRST L2DBRK		;CS129 Real logged in user. Let it sit idle.
	AOS A,LGOCNT		; Count the force-level counter
	CAIL A,2		; Panic?
	  JRST L2HNGU		;CU2 Yes. Get out
	MOVX B,<PC%USR+FORCLO>	; Assume forced logout
	CAIL A,1		; Still not seen at process level. First?
	  MOVEM B,RETPC2	; Break out of present work & force off 
L2DBRK:	MOVX 17,<PI2AC,,0>	; Restore AC's
	BLT 17,17
	DEBRK			; And return from lev 2 PSI
	 ERJMP DBKFA1

;CU2 Begin addition - dismiss (instead of JRST) to hangup routine

L2HNGU:	MOVX A,<PC%USR+HANGUP>	; set up level 2 dismiss to hangup routine
	MOVEM A,RETPC2		; ...
	JRST L2DBRK		; go restore registers and dismiss interrupt

;CU2 End addition

; NVT Detached; No reply possible

DETINT:	MOVEM 17,PI2AC+17	; Stash AC's
	MOVEI 17,PI2AC		; Just for symmetry
	BLT 17,PI2AC+16
;CU3 Begin addition
	SKIPN DBUGSW		;CS129 Not if debugging
	 DTACH%			; make sure we're really detached
	SETOM A			; get a -1 for logout
	SKIPN DBUGSW
	 LGOUT%
	  ERJMP [HALTF%]
;CU3 End addition
	MOVE P,L2PDP		; Set up stack
	MOVX A,<PC%USR+HANGUP>	; They went away, go hangup
	MOVEM A,RETPC2		; Save for return
	DEBRK			; And return
	 ERJMP DBKFAL		; #2 go detach and logout
	JRST DBKFAL		; Just in case

	SUBTTL	PSI Handlers - Level 2 (Non-Fatal) - CTCINT, IOXINT, QTAINT

; ^C (^E if debug)

CTCINT:	MOVEM 17,PI2AC+17	; Stash the AC's
	MOVEI 17,PI2AC
	BLT 17,PI2AC+16
	MOVE P,L2PDP		; And set up a stack
	SETOM CTCFLG
ABODBK:	MOVX A,<PC%USR+ABORPC>	; Force it to break out at this PC
	MOVEM A,RETPC2
	JRST L2DBRK



;  IO Error

IOXINT:	MOVEM 17,PI2AC+17	; Stash the AC's
	MOVEI 17,PI2AC
	BLT 17,PI2AC+16
	MOVE P,L2PDP		; And set up a stack
	SETOM IOXFLG		; Flag the I/O error
	JRST ABODBK		; Abort to ABORPC on debreak



; Quota Exceeded

QTAINT:	MOVE P,GPDP		; Restore stack level, just in case.
	HRROI X,[ASCIZS (456,552,< Exceeded working quota>)]
	MOVX A,<PC%USR+DATABE>	; Debreak out to close conn etc.
	MOVEM A,RETPC2
	DEBRK
	 ERJMP DBKFA3

IFN STANSW,< ;;; break out of DISMS when RECV or SEND finished.
DONINT:	PUSH P,A
	MOVE A,RETPC2		;get PC where we interupted
	MOVE A,-1(A)		;get instruction in progress
	CAMN A,[DISMS%]		;sleeping?
	 JRST DONIN1
	POP P,A
	DEBRK			;no - just continue
DONIN1:	CIS			;clear interupt in progress
	POP P,A
	JRST @RETPC2		;continue after the DISMS
>;IFN STANSW

	SUBTTL	PSI Handlers - Level 2 (Non-Fatal) - Control-T

CTTINT:	MOVEM 17,PI2AC+17	; Save registers
	MOVX 17,<0,,PI2AC>	; Here
	BLT 17,PI2AC+16

	MOVX A,.PRIOU
	DOBE

	HRROI A,[ASCIZS (100,111,< Awaiting data transfer command.
>)]
	SKIPN F$DTRQ		; Transfer requested or
	 SKIPE F$DTIP		; In progress
	  SKIPA			; Yes, report state
	   JRST CTINT7		; No, simple reply

	HRROI A,[ASCIZS (100,111,< Data transfer in progress, >)]
	PSOUT
	MOVX A,.PRIOU
	MOVE B,NBYTES
	MOVX C,DECRAD
	NOUT
	  JFCL
	HRROI A,[ASCIZ /. bytes sent/]
	SKIPN F$SEND		; Which direction
	  HRROI A,[ASCIZ /. bytes received/]
	PSOUT

	TXNN F,F.TYPX
	  JRST CTINT4
	HRROI A,[ASCIZ / (page /]
	PSOUT
	MOVX A,.PRIOU
	MOVE B,PAGENO
	NOUT
	  JFCL
	HRROI A,[ASCIZ /)/]
	PSOUT
CTINT4:
	HRRZ B,LCLJFN
	JUMPE B,CTINT6
	HRROI A,[ASCIZ / from /]
	SKIPN F$SEND		; Which direction
	  HRROI A,[ASCIZ / for /]
	PSOUT
	MOVX A,.PRIOU
	MOVX C,<..DEVD+..DIRD+..NAMA+..TYPA+..GENA+JS%PAF>
	JFNS
CTINT6:	HRROI A,[ASCIZ /.
/]
CTINT7:	PSOUT

	JRST L2DBRK		; All done

	SUBTTL	Command Execution Routines - USER

ZUSER:	GJINF			; See if logged in already
	JUMPN A,[JSP B,RPCRLP	; If so, complain
		 ASCIZS (504,503,< You are already logged in.>)]
	TXZ F,F.ANON		; Make sure not ANONYMOUS
	SETZM $ACCT		; Clear any account junk
	CALL SST		; Skip leading spaces
	MOVX A,<POINT 7,$USER>	; User name string storage
	MOVEI C,^D39		; Maximum length
USER01:	ILDB B,SBP		; Get a character
	IDPB B,A		; Store in string
	JUMPE B,USER02		; Quit on null
	SOJG C,USER01		; Loop for whole name
USERNG:	SETZM USERNM		; Too long. No User ID.
	AOS A,USRFCT		; Count bad user names
	CAIL A,5		; Allow him a few, then force him out
	  JRST USER03		; Too many
	CALL ADDREP		; Tell him user doesn't exist
	ASCIZS (431,530,< No such user as >)
	HRROI B,$USER
	SOUT
	MOVEM A,REPLYP
	JSP B,RPCRLP		; Return error msg
	ASCIZ /./

USER03:	JSP B,ERRRPL		; Hang up with following msg
	ASCIZS (430,421,< Too many login failures. Goodbye.>)

USER02:	MOVX B,<POINT 7,$USER>	; Name string
	CALL USRCHK		; Check if valid user
	  JRST USERNG		;  Failed
	  JRST [AOS A,USRFCT	; Cannot login to a FILES-ONLY Directory
		CAIL A,5	; Count failures, allow a few
		  JRST USER03	; Too many. Hang him up.
		JSP B,RPCRLP	; Tell him that's FILES-ONLY
		ASCIZS (431,530,< You can't log in under that directory name.>)]
	MOVEM B,USERNM		; Ok, save User ID #
	CAME B,ANOUNO		; ANONYMOUS?
	  JRST USER04		; No. Skip over ANONYMOUS
	SUBTTL	Anonymous User

; Anonymous User - Get ANONYMOUS' password from system file

	SETZM ANOPSW		; Collect ANONYMOUS password
	MOVX A,GJ%OLD+GJ%SHT	; From system file
	HRROI B,T20.AU		;TOPS-20
	SKIPE TENEX		;ANONYMOUS.USERFILE
	  HRROI B,TNX.AU	;TENEX
	GTJFN
	  JRST USRAN1		; File not there - don't allow logins
	MOVEM A,ANNJFN		; Stash JFN here
	MOVX B,<FLD(7,OF%BSZ)+OF%RD> ; Read ASCII from first line
	OPENF			; Open file
	  JRST USRAN2		; Can't?
	MOVX D,<POINT 7,ANOPSW>	; Store text here
	MOVX C,^D39		; Max length in case file bad
USRAN4:	BIN			; Get a character of password
	IDPB B,D		; Store in string
	SOJL C,USRAN2		;CS129 SOJLE=> SOJL Too long
	CAIL B,C.SPACE		; Valid character?
	  JRST USRAN4		; Yes, get next
	MOVX B,C.NUL		; Terminate with NULL
	DPB B,D			; Over invalid byte
	TXO F,F.ANON		; ANONYMOUS is the user name
USRAN2:	CLOSR ANNJFN		; Finished with file
USRAN1:	TXNE F,F.ANON		; Get password ok?
	  JRST USER04		; Yes
	SETZM USERNM		; Invalid user (ANONYMOUS)
	AOS A,USRFCT
	CAIL A,5		; Count failures, allow a few
	  JRST USER03		; Too many. Hang up.
	JSP B,RPCRLP
	ASCIZS (431,530,< ANONYMOUS logins are not allowed.>)
USER04:				; Continue...

; IFN REL4,<
	SKIPN TENEX		; No GDACC in TOPS-20
	  JRST USER06		; Have one in TENEX
;>	;END RELEASE 4 CONDITIONAL

	MOVX A,<POINT 7,$ACCT+1> ; Back here from ANONYMOUS
	MOVE B,USERNM		; See if user has a default account
	JSYS 331		; TENEX GDACC
	  JRST USER06		; No.
	MOVEM A,$ACCT		; Yes. Store it for LOGIN JSYS
USER06:
	HRROI B,[ASCIZS (330,331,< ANONYMOUS user ok, send real ident as password.>)]
	TXNE F,F.ANON		; ANONYMOUS or real user?
	  JRST RPCRLP		; ANONYMOUS. Ask for name (specal msg)
	JSP B,RPCRLP		; Real. Ask for password
	ASCIZS (330,331,< User name ok. Password, please.>)

	SUBTTL	Command Execution Routines - PASS

ZPASS:	SETZM $PASS		; Make sure no junk left around
;CS129~~~The following is questionable. Make sure CWD with password still workd
;CU1	TXNE F,F.LOGI		;CS129 Am I already logged in?
;CU1	  JRST PASCWD		;CS129 Yes, maybe for CWD
	SKIPN USERNM		; Has a user been seen?
	  JRST PASS06		; No.
	CALL SST		; Skip leading (unquoted) spaces
	MOVX A,<POINT 7,$PASS>	; Password string storage
	MOVX C,^D39		; Maximum length
PASS01:	ILDB B,SBP		; Get a character
	CAIN B,C.QUOTE		; Quote character?
	  JRST [ILDB B,SBP	; Quoted character. Copy it.
		JRST PASS03]	; Without crunching lower case to upper
	CAIL B,"a"		; Not quoted, make LC be UC
	CAILE B,"z"
	SKIPA			; Not lower case
	  SUBI B,"a"-"A"	; Make lower be upper
PASS03:	IDPB B,A		; Store the character
	JUMPE B,PASS04		; Jump at end.
	SOJG C,PASS01		; Space counter
PASSNG:	SETZM $PASS		; Clear. Flags that no good pswd yet.
	AOS A,PASFCT		; Count bad passwords
	HRROI B,[ASCIZS (430,421,< Password wrong again. Goodbye.>)]
	CAIL A,5		; Allow a few, then force off
	  JRST ERRRPL		; Hang up on him
	JSP B,RPCRLP		; Bad, but not too many times yet
	ASCIZS (431,530,< Password incorrect.>)
PASS04:				;CS129 Moved a few lines up
	TXNE F,F.LOGI		;CU1 Am I already logged in?
	  JRST PASCWD		;CU1 Yes, maybe for CWD
IFN REL4,<SKIPN TENEX
	    JRST PASS4A		; If TOPS-20
> ; End of Release 4 conditional
				; TENEX
	HRRZ A,USERNM		; Check the password. User ID
	TXO A,1B0		; Check, don't connect
	HRROI B,$PASS		; The supplied password
IFN ANOP,<			; Do not demand user give password
	TXNE F,F.ANON		; ANONYMOUS?
	 HRRI B,ANOPSW		; Yes, different password.
 >
	TXNE F,F.ANON		; If trying ANONYMOUS,
	 SKIPE $PASS		; Phony password must be non-null.
	  CNDIR			; Check it
	   JRST PASSNG		; Fail. Count it, reply, maybe hangup.

PASS4A:
	SUBTTL	Command Execution Routines - PASS, cont.

IFN REL4,<SKIPE TENEX		; If REL4 try without an account
>
	   SKIPE $ACCT		; Any default account?
	    JRST PASS10		; Yes. Go do the login.
PASSAC:	JSP B,RPCRLP		; No. ask for the account.
	ASCIZS (331,332,< Password OK, Account please.>)

PASS06:	JSP B,RPCRLP		; Pass w/o user
	ASCIZS (431,503,< User name before password, please.>)

	SUBTTL	Command Execution Routines - PASS/ACCT - Try to login

;Back here from ACCT command, too, if not yet logged in.

PASS10:	MOVX A,.SFNVT		; Are logins on NVT's allowed?
	TMON
	JUMPE B,NVTNLI		; If not, don't allow FTP service either
	MOVE A,USERNM		; User ID
	JUMPE A,PASS06		; If no user name yet, don't login.


	SKIPE TENEX		; Not supported on TOPS-20
	  HRLI A,(1B16)		; TENEX bit to suppress login date update
	MOVX B,<POINT 7,$PASS>	; Password
	MOVE C,$ACCT		; And account
IFN ANOP,<			; Do not demand user give password
;	SKIPN ANONOK		;CS129 Anonymous OK?
;	IFSKP.			;CS129 Yes
	  TXNE F,F.ANON		; ANONYMOUS?
	   HRRI B,ANOPSW	; Yes. Here's its password.
;	ENDIF.			;CS129
 >

	LOGIN			; Failed? Strange. Report it.
	  SKIPA			; Lose
	    JRST PASS12		; Ok, continue
CU,<				;CS129
;CU4 Begin addition

	CAIE A,GOKER2		; ACJ turned us down?
	IFSKP.
	 AOS A,USRFCT		; Count his mistakes
	 CAIL A,5		; Allow him a few, then force him out
	  JRST USER03		; Too many
	 CALL BEGREP		; Start a reply.
	 ASCIZS (431,530,<-Guest logins are not allowed at this time.
>)
	 JSP B,RPCRLP		; Finish reply and loop for more commands.
	 ASCIZS (431,530,< Please try again after 6PM EDT, or anytime on weekends.>)
	ENDIF.

;CU4 End addition
>;CU				;CS129

	SKIPN $ACCT		; See if defaulting
	  JRST [CAIN A,LGINX1	; Invalid account?
		 JRST PASSAC	; Yes
		CAIN A,602111	; VACCX0 - invalid account
		  JRST PASSAC
		CAIN A, 602112	; VACCX1 - string too long
		  JRST PASSAC
		CAIN A,602126	; VACCX2 - account expired
		  JRST PASSAC
		JRST .+1]	; Go give ERRSTR message
	CALL CLRPSW		; No, clear secret info
	CAIN A,LGINX4		;CS129 Bad password?
	  JRST PASSNG		;CS129 Handle it correctly
	PUSH P,A
	CALL ADDREP		; Build a reply
	ASCIZS (431,530,< Login failed unexpectedly, >)
	POP P,B
	HRLI B,.FHSLF		; Error in this fork
	ERSTR			; String for the error
	  JFCL
	  SKIPA
	MOVEM A,REPLYP		; End of string
	JSP B,RPCRLP		; Carriage return and reply
	ASCIZ /./

	SUBTTL	Command Execution Routines - PASS/ACCT - Logged in

PASS12:	TXO F,F.LOGI		; Flag that I am logged in.
	CALL CLRPSW		; Clear secret info

IFN ENABL,<
	MOVX A,.FHSLF		; Enable caps
 	SETOB B,C
	EPCAP
> ; End of ENABL

	GJINF			; Update job info
	MOVEM A,GJINF1
	MOVEM B,GJINF2
	MOVEM C,GJINF3
	MOVEM D,GJINF4

	MOVE A,REPLYP		; Compose a pretty login message
	HRROI B,[ASCIZ /230 User /]
	SETZ C,
	SOUT
	MOVE B,USERNM		; Convert User ID to name string
	DIRST
	ERJMP .+1		; Can't fail
	HRROI B,[ASCIZ / logged in at /]
	SETZ C,
	SOUT
	SETO B,
	MOVX C,<OT%DAY+<0*OT%FDY>+OT%NSC+OT%TMZ+OT%SCL>
	ODTIM			; Format of date/time
	HRROI B,[ASCIZ /, job /]
	SETZ C,
	SOUT
	HRRZ B,GJINF3		; Job number
	MOVX C,DECRAD
	NOUT
	  JFCL
	HRROI B,[ASCIZ /. /]
	SETZ C,
	SOUT
	MOVEM A,REPLYP		; Message pointer so far.

	HRROI B,CRLFM		; End of line
	SOUT

	SUBTTL	Command Execution Routines - Logged in, Get high segment

IFN IPCLOG,<
	HRROI A,IPCDAT		; And tell controller
	HRROI B,[ASCIZ /FTP Server: /]
	SETZ C,
	SOUT
	MOVE B,PREPLY		; Get initial pointer
	IBP B
	IBP B
	IBP B			; After the 230
	SOUT
	CALL SNDCTL
>

; Here to get in the file activity portion now that program is 
; safely logged in. Note that this greatly reduces security errors.

	GJINF			; Find out from system whether I am 
	SKIPN A			; really logged in.
	  CALL BOMB		; Not logged in! Quit and hang up.
	CALL GETHI		; Map the high segment back to life
	JSP B,RPCRLP		; All set, give greeting
	0

	SUBTTL	Subroutines - GETHI, CLRPSW

;	CALL GETHI	Map High Segment back in (Only if logged in)

GETHI:	MOVX A,<HSBAS/1000>	; First page of critical code
	PUSH P,A		; Current page number to stack
GETLP:	MOVX A,<.FHSLF,,0>	; In this fork,
	HRR A,0(P)		; At this page,
	RPACS			; See if page is there
	TXNN B,PA%PEX
	  JRST GETLPN		; No, so can't make it accessible
	MOVX B,PA%RD+PA%EX	; Set access to read execute (no write)
	SPACS
GETLPN:	AOS A,0(P)		; Look at next page
	CAIGE A,HSPMAX		;CS129 Unless up to DDT area
	  JRST GETLP
	POP P,A			; Discard page number
	RET			; End of GETHI



;	CALL CLRPSW	Clear Passwords
;SAVES	ALL

CLRPSW:	PUSH P,A		; Be transparent
	SETZM $PASS		; Clear secret info
	MOVX A,<$PASS,,$PASS+1>	; In all password areas
	BLT A,$PASS+7
	SETZM ANOPSW
	MOVX A,<ANOPSW,,ANOPSW+1>
	BLT A,ANOPSW+7
	SETZM CMDIB
	MOVX A,<CMDIB,,CMDIB+1>
	BLT A,CMDIB+20
	JRST APOPJ

	SUBTTL	Command Execution Routines - ACCT

ZACCT:	CALL SST
	MOVE A,SBP		; Pick up account characters here
	MOVX B,<POINT 7,$ACCT+1>; Store string here
	MOVX D,^D39		; Max length of string
	SETZ T1,		; Accumulate number here
	TXZ F,F.NUMA		; So far, it may be a number
	SETZM $ACCT+1		; Clear so can tell if null argument
ACCT01:	ILDB C,A		; Get a character of the account
	JUMPE C,ACCT02		; End of argument
	CAIL C,"a"		; Lower case?
	CAILE C,"z"
	SKIPA			; No
	  SUBI C,"a"-"A"	; Yes, make upper.

	SKIPN TENEX		; Test system
	  JRST ACCTNN		; If TOPS-20 only string accounts
	CAIL C,"0"		; Decimal digit?
	CAILE C,"9"
	  JRST ACCTNN		; Not numeric
	IMULI T1,12		; Accumulate number
	ADDI T1,-"0"(C)
	SKIPA
ACCTNN:	  TXO F,F.NUMA		; Not numeric
	IDPB C,B		; Add to text string
	SOJG D,ACCT01		; Loop if still space.
ACCTNG:	JSP B,RPCRLP		; String too long or otherwise bad
	ASCIZS (431,530,< Account not valid.>)

ACCT02:; MOVX C,C.NUL		; (It had to be to get here)
	IDPB C,B		; Terminate string
	SKIPN $ACCT+1		; Was string non-null?
	  JRST ACCTNG		; No. Empty string is no good
	TXNE F,F.NUMA		; Numeric?
	  JRST ACCT03		; No, alphabetic.
	TXNE T1,NMFLG		; 33 bit value or less?
	  JRST ACCTNG		; No. Bad.
	TXOA T1,<FLD(NUMVAL,NMFLG)> ; Ok.
ACCT03:	  MOVX T1,<POINT 7,$ACCT+1> ; Here for string account
	MOVEM T1,$ACCT		; This is the designator

	SKIPN A,USERNM		; Do we know who we are?
	  GJINF			; Get who we are
	MOVEM A,USERNM		; Save User ID
	MOVE B,$ACCT		; Get pointer or number
	SKIPN TENEX		; Different on TOPS20
	  JRST ACCT3A
	JSYS 330		; TENEX VACCT, is it ok?
	  JRST ACCTNG		; No
IFN REL4,<SKIPA>		; Skip TOPS-20 stuff
ACCT3A:
	SUBTTL	Command Execution Routines - ACCT, cont.

IFN REL4,<VACCT			; JSYS 566, TOPS-20 is it ok?
	   ERJMP ACCTNG		; Bad
> ; 101B doesn't validate accounts

	TXNN F,F.LOGI		; Am I logged in already?
	  JRST PASS10		; No, go do LOGIN.
	MOVE A,$ACCT		; Yes, change to this account
	MOVX B,0		; No flags
	CACCT			; Do the change
	  JRST ACCTNG		; This should not fail
	JSP B,RPCRLP		; Ok, account has been changed.
	ASCIZ /230 Account OK./

	SUBTTL	Command Execution Routines - TYPE

ZTYPE:	CALL BEGREP		; Start building ok reply
	ASCIZ /200 Type /
	MOVX P1,<-NTYPES,,TYPTAB+1> ; # & Table of known types
	CALL GETARG		; Look for arg in table
	  JRST ARGSYN		; Has to be one
	  JRST ARGUNK		; Arg was there but not known
	MOVEM B,CARG1		; Save argument so far
	CALL 0(C)		; Go to it
LCMRET:	JSP B,RPCRLP		; Finish msg and return
	ASCIZ / ok./

TYPTAB:	KM(TYPE,<A,E,I,L>,ARGNIM)

FILTAB:	40			; ASCII <SPACE>
	100			; EBCDIC <SPACE>
	0			; NULL
	0			; NULL

TYPE$L:	CALL ADDREP
	ASCIZ / bytesize /
	MOVE BP,SBP		; For DECIN
	LDB B,BP		; Get break
	CAIE B,C.SPACE		; Must have space
	  JRST [JSP B,NURPLY	; Need byte size
		ASCIZ /501 TYPE L must specify byte size./]

				; Support byte sizes 1-36
	CALL DECIN		; Get logical byte size
	  JRST [JSP B,NURPLY	; Something wrong
		ASCIZ /504 Error in TYPE L logical byte size parameter./]

	HRROI B,[ASCIZ /504 TYPE L only implemented for logical byte sizes 1 to 36./]
	CAIL A,^D1		; Min
	 CAILE A,^D36		; Max
	  JRST NURPLY		; Out of range

	MOVE B,A		; Byte size
	MOVE A,REPLYP		; Where to put it
	MOVX C,DECRAD		; In decimal
	NOUT			; For the user
	  JFCL
	MOVEM A,REPLYP		; Updated pointer
	MOVE A,B		; Byte size for following
	CALLRET TY$LN		; Ok

	SUBTTL	Command Execution Routines - TYPE, cont.

TYPE$A:	LDB B,SBP		; Get break
	JUMPE B,TY$DEF		;  EOL means default (0)
	CALL ADDREP
	ASCIZ / /
	CALL SST		; Skip break, spaces, tabs
	MOVX P1,<-NFORMS,,FRMTAB+1>
	CALL GETARG		; Get format arg
	  JRST ARGSYN		; Has to be one
	  JRST ARGUNK		; Has to be implemented
	JRST (C)		; Call routine

FRMTAB:	KM(FORM,<N,T,C>,ARGNIM)



TY$DEF:	SETZB T2,CARG1
FORM$N:	MOVEM B,$FORM		; Save format
	MOVX A,0		; Local packed words
	MOVEM A,$LTYPE
	MOVX A,7		; Local ASCII size
	MOVEM A,$LBYTE
	MOVX A,^D8		; ASCII is 8-bit bytes
	JRST TCMRET

TYPE$I:	  MOVX A,^D36
TY$LN:	MOVEM A,$LBYTE		; A/ byte, CARG1/ type
TCMRET:	MOVEM A,$BYTE
				; CARG1/ type
	MOVE B,CARG1		; Get type argument
	MOVE T1,FILTAB(B)	; Fill character
	MOVEM T1,$FILLB		; For this type
	MOVEM B,$TYPE		; Save the index into table
	RET

	SUBTTL	Subroutines - ARGUNK, ARGNIM, GETARG

;	JRST ARGUNK	Unknown Letter Argument

ARGUNK:	CALL BEGREP		; An argument that isn't even in table
	ASCIZS (501,504,< I never heard of >)
	CALL ADDKEY		; Put command name in
	CALL ADDREP
	ASCIZ / with argument /
	JRST ARGUN1


;	JRST ARGNIM	Unimplemented Letter Argument

ARGNIM:	CALL BEGREP		; An arg in the table but unimplemented
	ASCIZS (506,504,< >)
	CALL ADDKEY
	CALL ADDREP
	ASCIZ / is not implemented for argument /

ARGUN1:	CALL ADDARG		; Add ARGWRD
	JSP B,RPCRLP
	ASCIZ /./


; SBP/	Points to next input
;	MOVX P1,<-TABLE LENGTH,,TABLE ADDRESS>
;	CALL GETARG
; Ret+1	  Syntax Error
; Ret+2	  Not in table
; Ret+3	Found in table: Index in B, arg added to REPLYM, SBP updated

GETARG:	CALL GETWRD		; Get a word
	  RET ;+1		; Syntax error
	AOS 0(P)		; Ok, skip at least one
	MOVEM A,ARGWRD		; Save for error msgs, replies
	SETZ B,			; Index into table
GETAR2:	HLRZ C,(P1)		; Get address of ASCIZ keyword
	CAMN A,(C)		; (First 5 char) same as typein?
	  JRST GETAR4		; Yes, found the word
				; Go append to reply & skip return
	ADDI B,1		; No, next index
	AOBJN P1,GETAR2		; Loop looking for it
	RET ;+2			; Not in table

GETAR4:	PUSH P,C		; Save all
	PUSH P,B
	PUSH P,A
	CALL ADDARG		; Append keyletter to reply
	POP P,A
	POP P,B
	POP P,C
	HRRZ C,(P1)		; Dispatch address
	AOS (P)
	RET;+3
	SUBTTL	Command Execution Routines - MODE

ZMODE:	CALL BEGREP		; Start building ok reply
	ASCIZ /200 Mode /
	MOVX P1,<-NMODES,,MODTAB+1> ; # & Table of known MODEs
	CALL GETARG		; Look for arg in table
	  JRST ARGSYN		; Syntax error
	  JRST ARGUNK		; Argument not in table
	CALL 0(C)		; Go to it
	JRST LCMRET		; Common return for good letter commands

MODTAB:
	KM(MODE,<S,B,C>,ARGNIM)


MD$DEF:	SETZ B,
MODE$S:	MOVEM B,$MODE		; Save the index into table
	RET

	SUBTTL	Command Execution Routines - STRU

ZSTRU:	CALL BEGREP		; Build a success reply
	ASCIZ /200 Structure /
	MOVX P1,<-NSTRUS,,STRTAB+1> ; # & Args to structure
	CALL GETARG		; Look for arg in table
	  JRST ARGSYN		; Syntax error
	  JRST ARGUNK		; Not in table
	CALL 0(C)		; Go to it.
	JRST LCMRET		; Finish it up

STRTAB:
	KM(STRU,<F,R,P>,ARGNIM)


ST$DEF:	SETZ B,
;STRU$R:	; Record length??
STRU$P:
STRU$F:	MOVEM B,$STRU		; Store the arg
	RET

	SUBTTL	Command Execution Routines - ABOR (^C or IO Error)

;	DEBRK to ABORPC		On ^C or IO Error

ABORPC:	MOVE P,GPDP		; Restore stack level, just in case.
	HRROI A,[ASCIZS (456,500,< ? Unknown error interrupt.
>)]
	SKIPE CTCFLG		; Was it a ^C?
	  HRROI A,[ASCIZS (456,552,< Interrupt by user.
>)]
	SETZM CTCFLG

	SKIPE IOXFLG		; I/O error?
	  HRROI A,[ASCIZS (456,552,< System I/O Error.
>)]
	SETZM IOXFLG

	PSOUT			; Report error, fake ABOR


; ABORt command

ZABOR:	SKIPE F$DTIP		; File activity?
	  JRST DOABOR		; Yes. Abort it
				; No
	SKIPLE DATCON		; Data connection open?
	 SKIPN DATCON+T.JCN
	  JRST ZABOR5		; No
	JSP B,RPCRLP		; Yes, report it
	ASCIZS (<202 ABOR request ignored.>,<225 No file transfer in progress, Data connection OPEN.>)
ZABOR5:

	JSP B,RPCRLP		; Report data connection closed
	ASCIZS (<202 ABOR request ignored.>,<226 No file transfer in progress, Data connection CLOSED. >)

; Abort data transfer

DOABOR:	SETO A,			;CS129 Deleting page
	MOVX B,<.FHSLF,,<WINDOW/1000>> ;CS129 Window page in this address space
	SETZ C,			;CS129 No count, or flags
	PMAP%			;CS129 Flush window page out
	CLOSK (LCLJFN)		;CS129 Close file
	SKIPN F$SEND		;CS129 Doing STOR?
	IFSKP.			;CS129 Yes
	  HRRZ A,LCLJFN		;CS129 Get jfn again
	  TXO A,DF%EXP		;CS129 Expunge
	  DELF%			;CS129 Nuke partial file
	  TRNA			;CS129 Failure.... do release
	ELSE.			;CS129
	  HRRZ A,LCLJFN		;CS129 Get jfn again
	  RLJFN%		;CS129 Try this way
	   TRN			;CS129 Too bad. Sigh.
	ENDIF.			;CS129
	SETOM LCLJFN		;CS129 No more LCLJFN....
	
	CLOSD DATCON		; Close the data connection
	SETZM F$DTIP		; Data transfer no longer in progress

	JSP B,RPCRLP		; Back to top.
	ASCIZS (<200>,<226>,< File transfer aborted, Data connection CLOSED.>)

	SUBTTL	Command Execution Routines - BOMB, BYE/QUIT, CRASH, HELP, NOOP

ZBOMB:	CALL BOMB		; Another one


ZBYE:
ZQUIT:	JSP B,ERRRPL		; Send this message, then hang up.
	ASCIZS (<231 BYE>,<221 QUIT>,< command received. Goodbye.>)


ZCRASH:	JRST 4,.		; Test command for fatal errors


ZNOP:
ZNOOP:	JSP B,RPCRLP
	ASCIZS (200,200,< No-operation OK.>)



ZSITE:	CALL GETARG		;CS129 Have any argument?
	IFSKP.			;CS129 Yes. Can't do it
	  MOVEM A,ARGWRD	;CS129 Stash arg word
	  CALLRET ARGNIM	;CS129 You lose.
	ENDIF.			;CS129
	JSP B,RPCRLP
	ASCIZS (100,214,< Use SMNT <structure-name> to use unregulated structures.>)

	SUBTTL	Command Execution Routines - HELP

;CWL ARG & MORE INFO

ZHELP:
	HRROI B,HMSNL		; Pre-login message
	TXNE F,F.LOGI
	  HRROI B,HMSLI		; Post-login message
	JRST RPCRLP

HMSNL:	ASCIZ /214-The following commands are allowed before logging in:
214-  USER, PASS, ACCT, HELP, QUIT,
214-  SITE, TYPE A, MODE S, STRU F, and NOOP.
214-After logging in, the following are also allowed:
214-  TYPE I, TYPE L 1 to 36, STRU P,
214-  RETR, STOR, APPE, RNFR, RNTO, SMNT, CWD,
214-  DELE, LIST, NLST, STAT, PASV, and PORT.
214 End of help text./

HMSLI:	ASCIZ /214-The following commands are allowed:
214-  PASS, ACCT, HELP, QUIT, NOOP,
214-  SITE, TYPE I, TYPE L 1 to 36, STRU P,
214-  RETR, STOR, APPE, RNFR, RNTO, SMNT, CWD,
214-  DELE, LIST, NLST, STAT, RSTA, RLST, PASV,
214-  and PORT.
214 End of help text./

	SUBTTL	Password when logged in may be for CWD

.ORG ;BACK TO HIGH SEGMENT
; Here on PASS Command when already logged in. See if it goes with a CWD.

PASCWD:	MOVE A,PRVKWD		; See what previous command keyword was
;CU1 Begin edit
	CAMN A,[ASCIZ "CWD"]	; Previous command was CWD?
	IFSKP.
	  JSP B,PASCW4		; No. What's with this silly PASS?
	  ASCIZS (504,503,< You are already logged in. I don't know what this password is for.>)
	ENDIF.
;CU1 End edit
	GJINF			; It follows CWD. See if already
	CAMN B,$CWD		; Connected to the desired directory.
	  JRST [JSP B,PASCW4	; Yes, ignore password.
		ASCIZ /250 Password not needed for this CWD./]
				; No, go do it.
IFN REL4,<SKIPN TENEX		; TENEX?
	   JRST CWDCHK		; Nope
> ; End of IFN REL4
	HRRZ A,$CWD		; Desired Directory
	MOVX B,<POINT 7,$PASS>	; Password
	CNDIR			; Do the connect
	  JRST PASCW3		; Failed
	JRST CWDOK
CWDCHK:				;TOPS-20
	MOVEI B,$ACCES		; Get address of argument block
	MOVE A,$CWD		; Desired directory
	MOVEM A,.ACDIR(B)	; Put in argument block
	MOVX A,<POINT 7,$PASS>	; Password
	MOVEM A,.ACPSW(B)	; Put in argument block
	SETOM .ACJOB(B)		; This job

	MOVX A,<AC%CON+3>	; Three word argument block
	ACCES			; Connect to directory
	 ERJMP PASCW3		; Failed
CWDOK:
	SETZM GTJDEV		;CS129 Since now connected, delete defauls
	SETZM GTJDIR		;CS129  for device and directory set by CWD
	CALL ADDREP		; CWD command joins here
	ASCIZS (200,250,< Connected to >)
	MOVE B,$CWD		; Plug name into message
	DIRST
	  MOVE A,REPLYP		; Can't fail here, I hope.
	MOVEM A,REPLYP		; Update pointer
	JSP B,PASCW4		; Ok
	ASCIZ /./

PASCW3:
;CU1 Begin addition
	AOS A,PASFCT		; Count bad passwords
	HRROI B,[ASCIZS (430,421,
	  < Password wrong for CWD - too many failures, Goodbye.>)]
	CAIL A,5		; Allow a few, then force off
	  JRST ERRRPL		; Hang up on him
;CU1 End addition
	JSP B,PASCW4		; ACCES failed
	ASCIZS (431,530,< CWD - Password incorrect.>) ;CS129

PASCW4:	CALL CLRPSW		; Clear secret info (preserve B)
	JRST RPCRLP

	SUBTTL	Post-Login Command Execution Routines - DEBUG

ZDEBUG:	MOVX A,.FHSLF		; See if I am a WHEEL
	RPCAP
	TXNN B,<SC%WHL>		; Was also SC%OPR
	  JRST NOTIMP		; No. Pretend not implemented
DEBUG1:	SKIPE 770000		; Yes. Is DDT there?
	  JRST DEBUG0		; Yes, go to it.
	MOVX A,GJ%SHT+GJ%OLD	; No, get it
	HRROI B,T20.UE		; TOPS-20
	SKIPE TENEX		; UDDT filespec
	  HRROI B,TNX.US	; TENEX
	GTJFN
	  JRST NOTIMP
	HRLI A,.FHSLF		; Into this fork
	GET
	MOVE A,116		; JOBSYM
	MOVEM A,@770001		; to $I-1
DEBUG0:	MOVX A,<.FHSLF,,<HSBAS/1000>> ; Now put on copy/write bit in access
				; So DDT can do breakpoints
DEBUGL:	RPACS			; See if page there
	TXNN B,PA%PEX
	  JRST DEBUGN		; No
	MOVX B,<PA%RD+PA%WR+PA%EX> ; Assume private. R,W,E
	TXNN B,PA%PRV		; If shared, put on CW
	  MOVX B,<PA%RD+PA%EX+PA%CPY> ; Make it R,E,CW
	SPACS
DEBUGN:	ADDI A,1		; Next page
	HRRI B,(A)
	CAIGE B,700		; Continue up to DDT
	  JRST DEBUGL

IFN DBGHAK,<			;CS129 Begin gross hack...
	SKIPE DBPJMP		;CS129 Already set up?
	IFSKP.			;CS129 No
	  MOVE B,DDPADR		;CS129 Get instruction for entering breakpoint
	  MOVE A,(B)		;CS129 Get actual instruction there
	  MOVEM A,DBPJMP	;CS129 Tell our routine where to return
	  MOVE A,[JRST DBPRNT]	;CS129 Routine for printing 777 reply
	  MOVEM A,(B)		;CS129 Overwrite breakpoint entry with this
	ENDIF.			;CS129
   >;IFN DBGHAK			;CS129

	HRROI A,[ASCIZ/777 Starting debug.
/]				;CS129
	PSOUT			;CS129
	
	CALL 770000		; Call DDT
DRETN:	JSP B,RPCRLP
	ASCIZS (200,200,< End of debug.>)

IFN DBGHAK,<			;CS129...
DBPRNT:	PUSH P,A		;CS129
	HRROI A,[ASCIZ/777 ** Debug breakpoint **
/]
	PSOUT			;CS129 Print it
	POP P,A			;CS129
DBPJMP:	0			;CS129 (JRST BP, filled in when DDT loaded)
DDPADR:	766310			;CS129 addr of JRST in DDT for breakpoint entry
   >;IFN DBGHAK			;CS129

	SUBTTL	Post-Login Command Execution Routines - ALLOcate

; Allocate command - not really necessary on TOPS20

ZALLO:	JSP B,RPCRLP
	ASCIZ /202 Allocations are not required at this site./

	SUBTTL	Post-Login Command Execution Routines - RESTart

;	Restart Command

ZREST:	JSP B,RPCRLP		; Restart command not implemented
	ASCIZS (200,502,< Restart command received but ignored.>)

	SUBTTL	Post-Login Command Execution Routines - SMNT

ZSMNT:	HRROI B,[ASCIZS (200,202,< SMNT is not required at this site>)]
	SKIPE TENEX		; Only TOPS20 needs this
	  JRST RPCRLP

	CALL SST		; Down to the argument

	MOVE B,SBP		; Just collect string
	MOVX A,<POINT 7,LCLSTR>	;CS129 Where to stash it
	MOVNI C,10*5-1		;CS129 Length up to 39 chars
	SOUT

	HRROI A,LCLSTR		;CS129 Point at structure name
	CALL DOMSTR		;CS129 Attempt to mount structure
	 TRNA			;CS129 Failed - say why
	  JRST GETCOM		;CS129 OK - return to command parser
	MOVX A,<.FHSLF>		; Get error code
	GETER
	HRRZS B
	CAIE B,MSTX31		; Already mounted?
	IFSKP.
	  CALL ADDREP
	  ASCIZS (200,202,< Structure already mounted>)
	ELSE.
	  CALL ADDREP
	  ASCIZS (451,550,< Failed to mount structure: >)
	  MOVX B,<.FHSLF,,-1>
	  ERSTR
	    JFCL
	    JFCL
	  MOVEM A,REPLYP
	ENDIF.
	JSP B,RPCRLP
	ASCIZ /./

	SUBTTL	Post-Login Command Execution Routines - CWD

ZXCWD:				; Change working directory
ZCWD:	CALL SST		; Down to the argument

	MOVE B,SBP		; Pointer to argument
	CALL DIRCHK		; See if valid directory name
	  JRST XCWD1		; No
	MOVEM B,$CWD		; Save in case password follows
	
	HRROI A,USERST		; To (garbage) string for user name
	DIRST
	  JRST XCWD1		; Cant fail
	MOVE A,[POINT 7,LCLSTR]	;CS129 Point at where DOMSTR expects
	MOVE B,[POINT 7,USERST]	;CS129 Point at string just gotten
	DO.			;CS129
	  ILDB C,B		;CS129 Get a char
	  CAIN C,":"		;CS129 At end of device name?
	   EXIT.		;CS129 Done
	  IDPB C,A		;CS129 Append it
	  JUMPN C,TOP.		;CS129 And loop.
	ENDDO.			;CS129
	  
	MOVX A,.FHSLF		; Get current caps
	RPCAP
	PUSH P,B		; Save them
	PUSH P,C
	SETO C,			; Enable for the CNDIR
	EPCAP
	CALL DOMSTR		;CS129 Mount struture if necessary&possible
	 TRN			;CS129 Ignore any failure...
	MOVE A,$CWD		; See if can do a CNDIR to it
	SETZ B,			; Without a password

	SKIPN TENEX
	  JRST CWD6		; TOPS-20
	CNDIR			; TENEX
	  JRST XCWD2		; No.
	JRST CWD8		; Jump around TOPS-20 stuff
				; TOPS-20
CWD6:	MOVEM A,$ACCES		; Put in arg block
	MOVEM B,$ACCES+1	; Without password
	MOVX A,<AC%CON+3>	; Connect to directory
	MOVEI B,$ACCES		; Get address of block
	ACCES			; Connect
	  ERJMP XCWD2		; No
CWD8:
	POP P,C			; Yes, restore caps
	POP P,B
	MOVX A,.FHSLF
	EPCAP
	JRST CWDOK		; Go send success message

	SUBTTL	Post-Login Command Execution Routines - CWD, cont.

;	Connect W/o password failed, ask for it
;CS129 Also, set up defaults for GTJFN block to do CWD

XCWD2:	POP P,C			; Acces failed.
	POP P,B
	MOVX A,.FHSLF
	EPCAP
	MOVE A,[POINT 7,GTJDEV]	;CS129 Point at device string buffer
	MOVE B,[POINT 7,USERST]	;CS129 Point at directory argument
	DO.			;CS129
	  ILDB C,B		;CS129 Get a character
	  CAIN C,":"		;CS129 At the punctuation yet?
	   EXIT.		;CS129 Yup - exit
	  IDPB C,A		;CS129 Append to device string
	  LOOP.			;CS129 Loop for next char
	ENDDO.			;CS129
	SETZ C,			;CS129 A null
	IDPB C,A		;CS129 To close off device string
	MOVE A,[POINT 7,GTJDIR]	;CS129 Point at directory string buffer
	ILDB C,B		;CS129 Skip the open-pointy-bracket
	DO.			;CS129
	  ILDB C,B		;CS129 Get a char
	  CAIN C,76		;CS129 At close-pointy yet?
	   EXIT.		;CS129 Yup - done
	  IDPB C,A		;CS129 Append to buffer
	  LOOP.			;CS129 and do next
	ENDDO.			;CS129
	SETZ C,			;CS129 Null
	IDPB C,A		;CS129 To close off string
	JSP B,RPCRLP		; Say just prefix accepted.
	ASCIZS (200,331,< Default name accepted. Send password to connect to it.>)


;	Bad Directory Name (TOPS-20 structure ACCESS?)

XCWD1:	JSP B,RPCRLP
	ASCIZS (431,501,< No such directory - CWD.>)

	SUBTTL	Post-Login Command Execution Routines - SOCK/PORT

				; TCP	PORT H1,H2,H3,H4,P1,P2
P$SOCK:	POINT 16,$SOCK,15	; Leftmost 16 bits

ZPORT:	MOVSI T2,-6		; 4 bytes of $HOST & 2 of $SOCK
	MOVE T1,[POINT 8,$HOST,3] ; Rightmost 32 bits
	SETZM $HOST
;		Check break characters?
SOCK02:	CALL DECIN		; Get next byte
	  JRST SOCKX1
	SKIPL A
	  CAILE A,377
	    JRST SOCKX1		; Must be 0 to 377
	IDPB A,T1		; Save it
	AOBJN T2,SOCK02		; Get rest

	SKIPG $HOST
	  SETOM $HOST
;		Verify CR/EOL?
	LDB A,P$SOCK		; Get 16 bits
	MOVEM A,$SOCK		; Save sock/port #

	CLOSD DATCON		; Make sure data connection is closed

;CS129 *** Begin ***
;Would like more info about port chosen
	HRROI A,TEMSTR		;Place to build the message
	HRROI B,[ASCIZ/200 Port /]
	SETZ C,
	SOUT%
	LDB B,[POINT 8,$SOCK,^D27] ;Get high byte
	MOVEI C,^D10
	NOUT%
	 TRN
	MOVEI B,"."
	IDPB B,A
	LDB B,[POINT 8,$SOCK,^D35] ;Low byte
	NOUT%
	 TRN
	HRROI B,[ASCIZ/ at host /]
	SETZ C,
	SOUT%
	LDB B,[POINT 8,$HOST,^D11]
	MOVEI C,^D10
	NOUT%
	 TRN
	MOVEI B,"."
	IDPB B,A
	LDB B,[POINT 8,$HOST,^D19]
	NOUT%
	 TRN
	MOVEI B,"."
	IDPB B,A
	LDB B,[POINT 8,$HOST,^D27]
	NOUT%
	 TRN
	MOVEI B,"."
	IDPB B,A
	LDB B,[POINT 8,$HOST,^D35]
	NOUT%
	 TRN
	HRROI B,[ASCIZ/ accepted./]
	SETZ C,
	SOUT%
	MOVEI B,TEMSTR		;Point at message
	JRST RPCRLP		;Send & return to command loop
;CS129 *** End ***

	SUBTTL	Post-Login Command Execution Routines - SOCK/PORT, cont.

SOCKX1:	HRROI B,[ASCIZS (501,501,< Syntax error in >,SOCK,PORT,< command.>)] ; EOL not at right place
; Fall into SOCKXX


;	HRROI B,[ASCIZ /.../]
;	JRST SOCKXX		JSP B,SOCKXX
;				ASCIZ /.../

SOCKXX:	SETOM $SOCK		; Clear to defaults
	SETOM $HOST
	JRST RPCRLP		; Reply



	SUBTTL	Post-Login Command Execution Routines - PASV

;  Choose a port number, enter passive mode & listen for a connection

ZPASV:	CLOSD DATCON		; Make sure connections are closed

	TXO F,F.PASV		; Entering passive mode

	CALL PREDAT		; To listen
	  JRST NURPLY		; B/ has pointer to msg; F.PASV cleared

	CALL PRE255		; Reply with pseudo PORT command.

	JSP B,RPCRLP
	0	;ASCIZ //

	SUBTTL	Post-Login Command Execution Routines - DELE

ZDELE:	HRROI A,JFNTXS		; Copy argument for file name
	MOVE B,SBP
	SETZ C,
	SOUT
	IDPB C,B		; End string

	CALL JBKINI		; Set up for delete file request
				; Set A/JBLOCK, B/SBP
	MOVX C,<GJ%OLD+.GJLEG>	; Old file required
	MOVEM C,.GJGEN(A)
	%GTJFN			;CS129
	  JRST [JSP B,DELXX	; No such file
		ASCIZS (450,550,< DELE: No such>)]
	MOVEM A,LCLJFN
	LDB C,B			; Make sure got to EOL
	JUMPN C,[JSP B,DELXX	;  No. Bad syntax.
		ASCIZS (550,501,< DELE: Bad name syntax (not confirmed) in>)]
	CALL JFNTXT		; Store text string for this filename
	DVCHR			; See what the device is
	LOAD D,DV$TYP		; Get device type
	CAIE D,.DVDSK		; Disk?
	  JRST [JSP B,DELXX	; No. Error.
		ASCIZS (506,504,< DELE: Only implemented for DISK files, not>)]
	IFXN. F,F.ANON		;CS129 Anonymous?
	  HRRZ A,LCLJFN		;CS129
	  CALL CKWANN		;CS129 See if anonymous write OK for file
	   JRST [JSP B,DELXX	;CS129 Lose
		 ASCIZS (451,550,< DELE: ANONYMOUS deletes must be in PS:<ANONYMOUS>>)]	;CS129
	ENDIF.			;CS129
	HRRZ A,LCLJFN		; JFN
	DELF			; Do the delete
	  JRST [JSP B,DELXX	;  Can't. Assume access rights bad
		ASCIZS (451,550,< DELE: You do not have access rights to delete>)]
	SETOM LCLJFN		; JFN released by DELF JSYS
DELEOK:	MOVEI A,JBLOCK		; Try to get next lowest
	MOVE B,SBP		; Name string
	GTJFN
	  JRST [JSP B,DELXX
		ASCIZS (254,250,< File deleted ok,>)]
				; Message used to be "only copy" but
				; that could be wrong if user typed an
				; explicit version (generation) number
	RLJFN
	  JFCL
	HRROI B,[ASCIZS (254,250,< Lowest generation deleted ok,>)]

DELXX:	CLOSR LCLJFN
	MOVE A,REPLYP
	TLO B,-1
	SETZ C,
	SOUT			; Part of message to reply buffer
	SKIPN JFNTXS		; A file name?
	  JRST DELXX1		; No
	HRROI B,[ASCIZ / file /]
	SOUT
	HRROI B,JFNTXS
	SOUT			; Yes, tack on filename
DELXX1:	MOVEM A,REPLYP
	JSP B,RPCRLP		; Return a message
	ASCIZ /./

	SUBTTL	Post-Login Command Execution Routines - RNFR/RNTO

ZRNFR:	MOVE B,SBP		; Rename from. Just collect string
	MOVX A,<POINT 7,$PTHS1>	; Where to stash it
	MOVNI C,<5*40>-2	; Length
	SOUT
	JSP B,RPCRLP		; Send this back
	ASCIZS (200,350,< Rename-from name stored.>)


ZRNTO:	SKIPN $PTHS1		; Have old name from some previous RNFR?
	  JRST [JSP B,RPCRLP	;  No, error
		ASCIZS (431,503,< Please send old file name (RNFR) before new.>)]
	SETOM $PATH1		; No JFN's here yet
	SETOM $PATH2

	CALL JBKINI		; Set A/JBLOCK, B/SBP
	MOVX C,<GJ%FOU+GJ%NEW>	; Output new file only
	MOVEM C,.GJGEN(A)
	%GTJFN			;CS129 See if the file is there
	  JRST RNMX1		; Can't get "to" JFN
	MOVEM A,$PATH2
	IFXN. F,F.ANON		;CS129 Anonymous?
	  CALL CKWANN		;CS129 See if anonymous write OK for file
	   JRST [JSP B,DELXX	;CS129 Lose
		 ASCIZS (450,550,< RNTO: ANONYMOUS Renames must be in PS:<ANONYMOUS>>)]	;CS129
	ENDIF.			;CS129

	CALL JBKINI		; Ok. Try the from JFN
				; Set A/JBLOCK, B/SBP
	MOVX C,<GJ%OLD>		; Old file only
	MOVEM C,.GJGEN(A)
	HRROI B,$PTHS1		; Stored from RNFR command
	%GTJFN			;CS129
	  JRST [PUSH P,A	; Save error code
		CALL ADDREP	; Start reply
		ASCIZS (450,550,< Cannot access old-named file: >)
		JRST RNMXE]
	MOVEM A,$PATH1		; Store JFN
	IFXN. F,F.ANON		;CS129 Anonymous?
	  CALL CKWANN		;CS129 See if anonymous write OK for file
	   JRST [JSP B,DELXX	;CS129 Lose
		 ASCIZS (450,550,< RNTO: ANONYMOUS Renames must be in PS:<ANONYMOUS>>)]	;CS129
	  MOVE A,$PATH1		;CS129 Get back JFN
	ENDIF.			;CS129

	MOVE B,$PATH2		; Ok, get new name
	RNAMF			; Do the rename
	  JRST [PUSH P,A	; Save error code
		CALL ADDREP	; Start reply
		ASCIZS (455,550,< Rename failed: >)
		JRST RNMXE]
	SETOM $PATH1		; Good. This JFN now gone.

	MOVE A,$PATH2
	CALL JFNTXT

	CALL ADDREP		; Build fancy reply
	ASCIZS (253,250,< Old file renamed >)
	HRROI B,JFNTXS		; New file name
	SETZ C,
	SOUT
	JRST RNMXU

	SUBTTL	Post-Login Command Execution Routines - RNFR/RNTO, cont.
; GTJFN of new name failed, error code in A
RNMX1:	PUSH P,A		; Save error code
	CAIE A,GJFX20		; Errors for file exists already
	CAIN A,GJFX27
	  JRST RNMX2
	CALL ADDREP
	ASCIZS (455,450,< Can't get JFN for New file name: >)
	JRST RNMXE

RNMX2:	CALL ADDREP
	ASCIZS (456,503,< "New Name" already exists. Delete it first: >)
	JRST RNMXE

;RNMX2:	PUSH P,A
;	CALL ADDREP
;	ASCIZS (451,550,< No access rights to create new file: >)
;	JRST RNMXE

;RNMX4:	PUSH P,A
;	CALL ADDREP
;	ASCIZS (451,550,< No access rights to delete old filename: >)
;	JRST RNMXE

RNMXE:	POP P,B			; Error code
	HRLI B,.FHSLF
	ERSTR			; Append system error code
	  JFCL
	  JFCL
RNMXU:	MOVEM A,REPLYP		; Save end of message so far
	CLOSR $PATH1		; Clean up JFNs
	CLOSR $PATH2
	JSP B,RPCRLP
	ASCIZ /./

	SUBTTL	Post-Login Command Execution Routines - STAT

; Outer level sets up for TELNET connection, then calls DOLIST

;STAT - TELNET Connection, TYPE A or E
;During file xfer, <CR> - State of transfer
;Between Transfers
;	<CR> - Status including current transfer parameters
;	<DIR> - File names w/o dir, all generations (one line)
;	<FILE> - File info

; 211,212,213,504,530,550


.ORG ;BACK TO LOW SEGMENT

ZSTAT:	TXO F,F.STAT		; Tell DOLIST it's a STAT
	TXZ F,F.NLST!F.RSTA!F.RONL ;CS129X Similar to LIST

	MOVX A,.PRIOU		; Data goes to primary output
	CALL DOLIST		; Do the work
	JRST GETCOM		; Done.

.ORG ;BACK TO HIGH SEGMENT

	SUBTTL	Post-Login Command Execution Routines - LIST/NLST

; Outer level sets up for data connection, then calls DOLIST

;LIST - Data Connection	<CR> - Connected Directory
;	TYPE A or E	<DIR> - File names w/o dir, all generations (one line)
;			<FILE> - File Info
;NLST - Data Connection	<CR> - Connected Directory
;	TYPE A or E	<DIR> - File names w/ dir, top generation

; 150-226, 504


;CS129X New RSTA command

ZRSTA:	LDB A,SBP		;First character of argument
	IFE. A			;Null?
	  JSP B,RPCRLP		;Error
	   ASCIZS (450,550,< File name required>)
	ENDIF.
	TXO F,F.RSTA		;Say this is RSTAT
	TXZ F,F.NLST!F.RONL!F.STAT ;Similar to LIST, not STAT/RSTA
	MOVX A,.PRIOU		;Data goes to primary output
	CALL DOLIST		;Do the work
	JRST GETCOM		;Done.

;CS129X *** End ***

ZRLST:	TXO F,F.RONL!F.NLST	;CS129X RLST command - readable-only NLST
	JRST ZNLST1		;CS129X
ZLIST:	TXZA F,F.NLST		; LIST, not NLST
ZNLST:	  TXO F,F.NLST		; NLST, not LIST.
	TXZ F,F.RONL		;CS129X Not RLST
ZNLST1:				;CS129X
	SKIPGE A,$BYTE
	  MOVX A,^D8
	MOVEM A,$BYTE
	CAIN A,^D8		; Must be 8-bit
	 SKIPLE $TYPE		; ASCII
	  JRST LISTX1		; Lose
	SKIPG $MODE		; Better be an ASCII connection
	 SKIPLE $STRU
	  JRST LISTX1		; Lose

	TXZ F,F.STAT!F.RSTA	;CS129X Tell DOLIST it's a LIST, not STAT.
	TXO F,F.SEND		; Set up a send connection
	SETOM F$DTIP		; Data transfer in progress
	CALL PREDAT		;  ..
	  JRST RPCRLP		; No good.

	MOVX A,.PRIOU
	HRROI B,[ASCIZS (250,150,< List started.
>)]
	SETZ C,
	SOUT			; Send msg and dump buffer to SJFN

	MOVE A,DATCON		; Where DOLIST should send answers
	CALL DOLIST

	CLOSD DATCON		; Done with the data connection

	SETZM F$DTIP		; Data transfer no longer in progress
	HRROI B,[ASCIZS (252,226,< Transfer completed.>)] ; & data closed
	JRST RPCRLP


LISTX1:	JSP B,RPCRLP
	ASCIZS (506,504,< Parameters for LIST command must be STRU F, MODE S, TYPE A.>)

	SUBTTL	Post-Login Command Execution Routines - RETR

;Retrieve Command. File from server to user

; 150-<226,250,451>, 425, 501, 504, 550


ZRETR:	TXZ F,F.TYPX!F.FDB!F.ERR ; Assume not paged mode, and error
	TXZ F,F.DSK!F.NUL	; Clear a couple flags
	TXO F,F.SEND		; This is a send connection of data
	SKIPG B,$BYTE		; Any declared byte size?
	  MOVX B,^D8		; No. Set it to default eight-bit
	MOVEM B,$BYTE

	SKIPLE $MODE		; See if default stream mode.
	  JRST RETX0		; No.
	MOVE C,$TYPE		; Get type
	MOVE D,$STRU		; See if paged structure
	CAIE D,STRU.P		; Is it paged?
	 JRST RETR01		; No, will filter later

; Paged Stru/Type
	CAIE C,TYPE.I		; Allow TYPE I
	 CAIN C,TYPE.L		; TYPE L 36 and
	  CAIE B,^D36		; 36 bits and paged?
	   JRST RETX0		; No. Error
	TXO F,F.TYPX		; It is 36-bit paged mode. Remember in flag.
	JRST RETR02		; Already know STRU ok


RETR01:	SKIPLE $STRU		; Structure must be default file
	  JRST RETX0

RETR02:	CALL TIMEOK		; Update timeout
	SETZM TYXSCT		; Clear net sequence count for page mode

	CALL JBKINI		; Initilize GTJFN block
				; Set A/JBLOCK, B/SBP
	SETZM LCLSTR		;CS129 No structure known yet
RETR20:	MOVX C,GJ%OLD		; Existing file for reading
	MOVEM C,.GJGEN(A)	; No default version
	%GTJFN			;CS129 GTJFN the local file
	IFNSK.			;CS129 Failed...
	  CALL TRYMOU		;CS129 Maybe try to mount structure
	   JRST RETX1		;CS129 Failed - punt
	  JRST RETR20		;CS129 Try GTJFN again, with structure mounted
	ENDIF.			;CS129
	MOVEM A,LCLJFN		; Save it

	LDB C,B			; Was terminator the end of line?
	JUMPN C,RETX2		; If not, complain

	CALL JFNTXT		; Stash file name in txt storage

	SUBTTL	Post-Login Command Execution Routines - RETR, cont.

	MOVE A,LCLJFN		; Ok. See what type device it is on
	DVCHR
	LOAD D,DV$TYP
	CAIN D,.DVDSK		; Disk?
	  TXO F,F.DSK		; Yes, Local disk file.
	CAIN D,.DVNUL		; Is it the NUL:?
	  TXO F,F.NUL		; Yes, Flag to phony up a NUL:

	HRROI X,[ASCIZS (457,504,< Paged transfer must be on DSK: or NUL:.>)]
	TXNN F,F.TYPX		; Paged mode?
	  JRST RET02B		; No.
	TXNN F,F.NUL!F.DSK	; DSK: or NUL:?
	  JRST DATABE		; RETXPX: No.
RET02B:
	TXNE F,F.NUL		; Nul:?
	  JRST RET02		; Yes, Bypass OPENF

	MOVX A,^D36		; Common byte size
	MOVE P1,$TYPE		; Get type
	CAIE P1,TYPE.I		; Image type?
	 TXNE F,F.TYPX		; Or Paged?
	  JRST RETOPN		; Yes, All set

	CAIE P1,TYPE.A		;CS129 Ascii?
	IFSKP.			;CS129 Yes
	  MOVE A,LCLJFN		;CS129 Get jfn again
	  MOVE B,[1,,.FBBYV]	;CS129 word we want
	  MOVEI C,D		;CS129 put it in D
	  GTFDB%		;CS129 Get file I/O flags
	   ERJMP RETX1		;CS129 This should never happen
	  LDB C,[POINTR D,FB%BSZ] ;CS129 Get byte size of file
	  CAIE C,^D36		;CS129 Allow 36-bit
	  CAIN C,7		;CS129 or 7-bit, for text files
	  TRNA			;CS129
	  JRST RETX6		;CS129 No. Can't retrieve in text mode, then
	  MOVX A,^D7		;CS129 Set the byte size for below
	  JRST RETOPN		; Yes
	ENDIF.			;CS129
	MOVE A,$BYTE		; Get the connection byte size
	CAIN P1,TYPE.L		; Local byte?
	  JRST RETOPN		; Yes

	JRST RETX4		; No. Unknown type. (impossible)
	SUBTTL	Post-Login Command Execution Routines - RETR, cont.

RETOPN:	MOVEM A,$LBYTE		; Local file byte size ($BYTE unless ASCII)
	MOVX B,OF%RD		; Build OPENF parameter
	STOR A,OF$BSZ,+B

RETOPO:	MOVE A,LCLJFN		; Get local JFN back
	PUSH P,B		; Save open flags.
	OPENF
	  JRST [POP P,B
		TXON B,OF%THW	; Try it thawed
		  JRST RETOPO
		JRST RETX5]	; Already did. Fail.
CMU,<	CALL LOGOPN>		;CS129 Log the event
	POP P,B			; Clear stack
RET02:	; Enter here if NUL:
	CALL SETCLSD		; Setup F.CLSD

	SETOM F$DTIP		; Data transfer in progress

	CALL PREDAT		; Set up the data connection
	  JRST RPCRLP		; Can't. Return reason.

	MOVE A,REPLYP		; Send started msg
	HRROI B,[ASCIZS (250,150,< Retrieve of >)]
	SKIPL D,$TYPE		; Or more specific message.
	 CAIN D,TYPE.A		; ASCII type?
	  HRROI B,[ASCIZS (250,150,< ASCII retrieve of >)]
	CAIN D,TYPE.I
	  HRROI B,[ASCIZS (250,150,< IMAGE retrieve of >)]
	TXNE F,F.TYPX
	  HRROI B,[ASCIZS (250,150,< Paged retrieve of >)]
	SETZ C,
	SOUT

	HRRZ B,LCLJFN		; File name
	MOVX C,<..DEVD+..DIRA+..NAMA+..TYPA+..GENA+JS%TMP+JS%PAF> ; Format
	JFNS
	HRROI B,[ASCIZ / started.
/]
	SETZ C,
	SOUT
	HRROI A,REPLYM		; Send it
	PSOUT
	MOVE A,PREPLY		; And prepare for next one
	MOVEM A,REPLYP
	SETZM REPLYM

	CALL XFRDAT		; Transfer file

	CLOSR LCLJFN		; Close these files if open
	SETZM F$DTIP		; Data transfer no longer in progress
	HRROI B,0(X)		; Pointer to reply message
	JRST RPCRLP		; Reply
	SUBTTL	Post-Login Command Execution Routines - APPE/STOR

;CS129 ***Begin***
;Routine to attempt to mount structure after GTJFN failes. Assumes that
;that JBLOCK and SBP are setup and that the failing GTJFN just occurred 
;(i.e. error code is in A).
;Returns: +1/ Failed - Not STRX09/can't mount structure/etc.
;	  +2/ Success, with A/JBLOCK and B/SBP ready to try another GTJFN

TRYMOU: CAIE A,STRX09		; Structure mount req'd?
	 RET			; Nope - he loses
	SKIPE LCLSTR		; Did we already try this?
	 RET			; Punt, then
	HRROI A,LCLSTR		; a/ destination
	MOVE B,SBP		; b/ source
	MOVEI C,10*5-1		; c/ max length
	SETZ D,			; d/ break character
	SOUT%			; copy the structure name
	MOVE A,[POINT 7,LCLSTR]	; get a pointer to it
	DO.
	 ILDB B,A		; get a byte
	 CAIN B,":"		; is it a colon?
	  EXIT.			; yes, exit the loop
	 JUMPN B,TOP.		; no, loop till we find it or a null
	 RET			; if we found no structure name, punt
	OD.
	SETZ B,			; get a null
	DPB B,A			; deposit it over the ":"
	HRROI A,LCLSTR		; Point at name
	CALL DOMSTR		; Attempt to mount/access structure
	 RET			; Failed - return
	MOVEI A,JBLOCK		; Get back JFN block address
	MOVE B,SBP		; And user byte ptr
				; Fall through below

RSKP:	AOS (P)			; Prepare skip return
R:	RET			; And return

;Routine to mount and access the requested structure. Increments mount count
;for specified structure and attempts to access the user's directory on it.
;Called with LCLSTR/ name of local structure
;Returns +1/+2

DOMSTR:	MOVE A,[XWD 2,.MSGSS]	; a/ nargs,,function
	MOVEI B,C		; b/ arg block starts at c
	HRROI C,LCLSTR		; c/ pointer to structure name
	MSTR%			; Get the structure's status in d
	 ERJMP [RET]		; Failed?? Structure must not exist, then
	TXZ D,1			; Clear "accessed" flag bit
	IFXE. D,MS%NRS		; Structure is regulated?
	  MOVE A,[1,,.MSIMC]	; Block length,,function code
	  MOVEI B,C		; Block is at C
	  HRROI C,LCLSTR	; Name of structure
	  MSTR%			; Attempt to mount structure
	   ERJMP [RET]		; Failed - he loses
	  TXO D,2		; Set "mounted" flag bit
	ENDIF.
	AOS (P)			; Prepare skip return
	HRROI A,RCDSTR		; Buffer to build directory name
	HRROI B,LCLSTR		; Structure name
	SETZ C,			; Entire string...
	SOUT%			; Copy string
	LDB B,A			; Get the last byte copied
	CAIN B,":"		; Structure already punctuated?
	IFSKP.			; No, so...
	  MOVEI B,":"		; Punctuate!!!
	  IDPB B,A		; ...
	ENDIF.
	MOVEI B,74		; Start directory name
	IDPB B,A		; Open pointy-bracket
	PUSH P,A		; Save byte ptr
	PUSH P,D		; and flags
	GJINF%			; Get job info
	MOVE B,A		; Copy user number
	POP P,D
	POP P,A			; Get back byte ptr
	DIRST%			; Make a directory name
	 TRN			; Shouldn't ever fail
	MOVEI B,76		; Close-pointy
	IDPB B,A		; Put it on
	SETZ B,			; A null
	IDPB B,A		; To close off string
	MOVX A,RC%EMO		; Want exact match
	HRROI B,RCDSTR		; Point at our string
	SETZ C,			; No stepping
	RCDIR%			; Have a directory on the structure?
	IFNJE.			; Make sure no errpr
	  TXNE A,RC%NOM!RC%AMB	; RCDIR worked?
	ANSKP.			; Yes
	  MOVEM C,$ACCES+.ACDIR	; Put directory number in block
	  SETZM $ACCES+.ACPSW	; Assume no pwd required
	  SETOM $ACCES+.ACJOB	; Want access for this job
	  MOVX A,<AC%OWN!.ACJOB+1> ; Function code+length
	  MOVEI B,$ACCES	; Address of argblk
	  ACCES%		; Attempt to access structure
	   ERJMP .+2		; Failed
	  TXO D,1		; Indicate accessing structure
	ENDIF.

	MOVE A,KEYWRD		; Get command keyword
	CAME A,[ASCIZ/SMNT/]	; Explicit mount?
	 RET			; Nope. Don't want unsolicited messages
	IFXN. D,2		; Was structure mounted?
	  HRROI A,[ASCIZS (200,202,<>)] ;Just reply code
	  PSOUT%		; Print it
	  MOVEI A," "		; Separator character
	  TXNE D,1		; Was access done also?
	   MOVEI A,"-"		; Yes - obey protocol with continuation char
	  PBOUT%		; Print separator
	  HRROI A,[ASCIZ/Structure /]
	  PSOUT%		; Print word...
	  HRROI A,LCLSTR	; Structure name
	  PSOUT%
	  HRROI A,[ASCIZ/ mounted
/]
	  PSOUT%
	ENDIF.
	TXNN D,1		; Access done on structure?
	 RET			; Nope. Done, then
	HRROI A,[ASCIZS (200,202,< Accessing >)]
	PSOUT%
	HRROI A,RCDSTR		; Point at directory name
	PSOUT%
	HRROI A,[ASCIZ/
/]				; Close it off nicely
	PSOUT%
	RET


;Routine to check for ANONYMOUS write access. At present, just verifies
;that the required file is in the <ANONYMOUS> directory.
;Called with: A/JFN on file
;Returns: +1/ File may not be written by ANONYMOUS
;	  +2/ File may be written by ANONYMOUS

CKWANN:	MOVE B,A		;Local file JFN here
	HRROI A,GTJSTR		;Re-use this block for space
NAN,<	MOVX C,<FLD(.JSAOF,JS%DIR)>> ;Only want directory field
ANR,<	MOVX C,<FLD(.JSAOF,JS%DIR)!FLD(.JSAOF,JS%DEV)!JS%PAF>> ;Want dev:<dir>
	JFNS%			;Read directory field of file
	 ERJMP R		;Failed - he loses
NAN,<	DMOVE A,GTJSTR		;Get the directory name
	CAMN A,TXX.AN		;First = 'ANONY'?
	 CAME B,TXX.AN+1	;Second = 'MOUS'?
	  TRNA
	AOS (P)			;Success reuturn
	RET
   >;NAN
ANR,<	MOVX A,RC%EMO		;Exact-match only
	HRROI B,GTJSTR		;Directory name
	RCDIR%			;Translate to directory number
	 ERJMP R		;Failed - lose.
	TXNE A,RC%NOM		;No match?
	 RET			;Punt.
	MOVX A,.CDDPT+1		;Need directory protection word
	MOVEM A,GTJSTR+.CDLEN
	MOVE A,C		;Directory number
	MOVEI B,GTJSTR		;Where to put info
	SETZ C,			;No password
	GTDIR%			;Read directory info
	 ERJMP R		;Nope.
	MOVE A,GTJSTR+.CDDPT	;Get directory protection
	TXNE A,1		;Is the magic bit set for ANONYMOUS?
	 AOS (P)		;Yes - sucess return
	RET
   >;ANR

ANR,<

;Routine to do possibly wild GTJFN, returning first file which is accessable
;to user (normal GTJFN unless ANONYMOUS).
;Accepts: GTJFN parameters
;Returns: +1/ GTJFN "failure"
;	  +2/ GTJFN "success" with JFN in A

DOGTJ:	GTJFN%			;Do the GTJFN
	 RET			;Failed. Easy.
	TXNE F,F.ANON		;Not ANONYMOUS?
	SKIPE ANONOK		;Or OK?
	RETSKP			;Good return, then
	STKVAR <<SAVAB,2>,<SAVCD,2>>
	DMOVEM A,SAVAB
	DMOVEM C,SAVCD
	HRRZS A			;Just JFN part
	MOVE B,[1,,.FBPRT]	;word we want
	MOVEI C,D		;put it in D
	GTFDB%			;Read file protection
	 ERJMP DOGTJ1		;Failed - step to next, then
	IFXE. D,1		;First file unreadable?
DOGTJ1:	  MOVE A,SAVAB		;Get back jfn again
	  MOVX B,<GX%EQL+.FBPRT> ;Test equality on protection word
	  MOVX C,1		;Bit 1
	  MOVX D,1		;Must be a 1
	  GXJFN%		;Step to next ANONYMOUS-accessable file
	  IFNSK.		;None.
	    MOVX A,.FHSLF
	    MOVX B,<GJFX32>	;Return canonical error
	    SETER%		;Simulate GTJFN failure...
	    MOVE A,B		;Fix A
	    JRST DOGTJ2		;Return w/o restoring A
	  ENDIF.
	ENDIF.
	AOS (P)			;Skip return
	MOVE A,SAVAB		;Restore jfn and flags
DOGTJ2:	MOVE B,1+SAVAB		;Restore other acs...
	DMOVE C,SAVCD		;...
	RET
	ENDSV.

;Magic GNJFN - requires that GXJFN% exist.

DOGNJ:	TXNE F,F.ANON		;Not anonymous?
	SKIPE ANONOK		;or OK?
	JRST [	GNJFN%		;Just to the GNJFN, then
		TRNA		;Failed.
		AOS (P)		;Success
		RET]
	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVX B,<GX%EQL+.FBPRT>	;Test equality on protection word
	MOVX C,1		;Bit 1
	MOVX D,1		;Must be a 1
	GXJFN%			;Step to next ANONYMOUS-accessable file
	TRNA			;Failed.
	AOS -3(P)		;OK
	POP P,D
	POP P,C
	POP P,B
	RET
   >;ANR

CMU,<
;Get a jfn on the log file - should be done while process enabled.

OPNLOG:	MOVX A,<GJ%SHT!GJ%OLD>	;GTJFN flags
	HRROI B,[ASCIZ/PS:<SPOOL>FTPSRT.LOG/]
	GTJFN%			;Is it there?
	 RET			;Failed
	MOVEM A,LOGJFN		;Remember the JFN
	RET

;Routine to log file opening. Logs username info, filename, and access bits.

LOGOPN:	SKIPG A,LOGJFN		;Get & check for log jfn
	 RET			;No log jfn - just return
	HRROI A,STRTMP		;Point at temp buffer area
	SETO B,			;Current time wanted
	MOVX C,<OT%NSC>		;Seconds are useless
	ODTIM%			;Get current time
	MOVEI B," "		;Separator
	IDPB B,A		;Copy it
	MOVE B,[POINT 7,FHSTNM]	;Point at foriegn host name
	DO.
	  ILDB C,B		;Get char
	  JUMPE C,ENDLP.	;Until null
	  IDPB C,A		;Append to string
	  LOOP.			;For all string
	ENDDO.
	MOVEI B,":"		;Separator
	IDPB B,A
	MOVE B,USERNM		;Get user number
	DIRST%			;Print it
	 JRST LOGOPX		;Shouldn't fail, but handle it anyway
	MOVE B,[POINT 7,[ASCIZ/ STOR /]]
	TXNE F,F.APPE		;Really append?
	MOVE B,[POINT 7,[ASCIZ/ APPE /]]
	TXNE F,F.SEND		;Or really retrieve?
	MOVE B,[POINT 7,[ASCIZ/ RETR /]]
	DO.
	  ILDB C,B		;Get a char
	  JUMPE C,ENDLP.	;Done
	  IDPB C,A		;Copy character to string
	  LOOP.			;And loop for more
	ENDDO.
	MOVE B,LCLJFN		;Get jfn on local file
	MOVX C,<FLD(.JSAOF,JS%DEV)!FLD(.JSAOF,JS%DIR)!FLD(.JSAOF,JS%NAM)!
		FLD(.JSAOF,JS%TYP)!FLD(.JSAOF,JS%GEN)!JS%PAF>
	SETZ D,
	JFNS%			;Print the file name
	 ERJMP LOGOPX
	MOVX B,.CHCRT		;CR
	IDPB B,A
	MOVX B,.CHLFD		;LF
	IDPB B,A
	MOVX B,.CHNUL		;And null terminator
	IDPB B,A
	MOVE A,LOGJFN		;Get back log jfn
	MOVX B,<OF%APP!OF%THW!FLD(7,OF%BSZ)> ;Append, thaw, 7-bit mode
	OPENF%			;Open the file
	RET			;Open failed - just punt
	HRROI B,STRTMP		;Point at string to write
	SETZ C,
	SOUT%			;Write it
	 ERJMP LOGOPX		;Failed...
LOGOPX:	MOVE A,LOGJFN		;Get back log file jfn
	TXO A,CO%NRJ		;Don't want to release JFN
	CLOSF%			;Close the file
	 TRN			;Ignore failure...
	RET			;Done
   >;CMU
;CS129 ***End***

; Store and Append commands. File from remote to server.
; (111) 150-<226,250,451>, 425, 501, 504, 550

ZAPPE:	TXOA F,F.APPE		; Append. Much like STOR.
ZSTOR:	  TXZ F,F.APPE		; Not append
	TXZ F,F.DSK+F.NUL+F.SEND ; Assume not DSK: or NUL:, not send
	TXZ F,F.RLPT+F.TYPX+F.FDB!F.ERR	; Assume not to spooled LPT,
	SETZM F$KPGN		; not paged mode, and error
	SETZM TYXSCT		; But if it is, start at seq zero
	MOVX B,PGT$AP		; Data page with access control
	MOVEM B,RECTYP		; In case EOF comes in immediately.
	SETZM IBITCT		; Image bit count is 0

	SKIPLE A,$MODE		; Stream mode?
	  JRST STOX0		; No. Unsupported.
	MOVE B,$STRU
	MOVE C,$TYPE		; Get type
	SKIPG D,$BYTE		; Byte still at default?
	  MOVX D,^D10		; Yes. Set to real size
	MOVEM D,$BYTE

	CAIE B,STRU.P		; Is it paged?
	 JRST STO00		; No
; Paged

	CAIE C,TYPE.I		; Allow TYPE I or
	 CAIN C,TYPE.L		; TYPE L 36 and
	  CAIE D,^D36		; Paged and 36 bit bytes?
	   JRST STOX0		; No. Bad.
	TXNE F,F.APPE		; Yes. STOR, I hope.
	  JRST STOX0		; No. Can't append in page mode
	TXO F,F.TYPX		; Ok. Flag page mode
	SETOM F$KPGN		; Allow rename to retain generation #
	JRST STO02		; Already know STRU ok

STO00:	SKIPLE $STRU		; Only file structured so far.
	  JRST STOX0
STO02:	CALL TIMEOK		; Update timeout.
	CALL JBKINI		; Set up the default strings in GTJFN blk
				; Set A/JBLOCK, B/SBP
	SETZM LCLSTR		;CS129 No structure yet
	MOVX C,GJ%FOU+GJ%FLG	; Output use bit and request flags bit
	TXNE F,F.APPE		; Unless append, whence
	  MOVX C,GJ%FLG		; Use current version if any.
;CS129	TXNE F,F.ANON		; If ANONYMOUS, no new files at all.
;CS129	  MOVX C,GJ%OLD+GJ%FLG	; So don't default to new version
	MOVEM C,.GJGEN(A)
STO020:	GTJFN			;CS129 Get it.
	IFJER.			;CS129 Failed...?
	  CALL TRYMOU		;CS129 Maybe mount structure...
	   JRST STOX1		;CS129 Failed - punt
	  JRST STO020		;CS129 Try again.
	ENDIF.			;CS129
	HRRZM A,LCLJFN		; Store the JFN
	TXNN A,GJ%NHV		; Want higher generation #?
	  SETZM F$KPGN		; No, don't rename
	
	SUBTTL	Post-Login Command Execution Routines - APPE/STOR, cont.

	SKIPE JBLOCK+.GJACT	; Was there an account?
	  JRST STO01		; Yes. Main string pointer not needed.

;CWL WHAT GOES HERE??

STO01:	LDB C,B			; Get the terminator
	JUMPN C,STOX2		; Jump if not EOL
	MOVE A,LCLJFN		; Ok. Name was good.
	CALL JFNTXT		; Store the text string for file name

	IFXN. F,F.ANON		;CS129 Anonymous?
	  MOVE A,LCLJFN		;CS129
	  CALL CKWANN		;CS129 See if anonymous write OK for file
	   JRST STOX7		;CS129 Nope. Punt him.
	ENDIF.			;CS129

STO011:	MOVE A,LCLJFN
	DVCHR			; See what device it's on.
	LOAD A,DV$TYP		; Get device type
	CAIN A,.DVDSK		; Disk
	  TXO F,F.DSK		; Yes.
	CAIN A,.DVNUL		; NUL device?
	  TXO F,F.NUL		; Yes

	HRROI X,[ASCIZS (457,504,< Paged transfer must be on DSK: or NUL:.>)]
	TXNN F,F.TYPX		; Paged mode?
	  JRST STO02B		; No.
	TXNN F,F.NUL!F.DSK	; Disk or NUL?
	  JRST DATABE		; RETXPX: No.
STO02B:
	CAIE A,.DVLPT		; LPT:?
	  JRST STO03		; No

; Check if spooled line printer??

STOLPT:	TXNE F,F.ANON		; ANONYMOUS login?
	  JRST [JSP X,DATABE	; STOX8: Let's not have ANONYMOUS listings
		ASCIZS (450,504,< Anonymous users may not write on LPT:.>)]

	MOVX A,^D7		; Spooled byte size
	MOVE B,$BYTE		; For now, only allow ASCII 8-bit.
				; This should be fixed, though.
	CAIN B,^D8		; Eight bit conn?
	 SKIPLE P1,$TYPE	; And ASCII?
	  JRST .+2		; No.
	   JRST STOOPN		; Yes.
	JSP X,DATABE		; Error.
	ASCIZS (503,504,< Transfers to LPT: must be ASCII, 8-bit connections.>)

	SUBTTL	Post-Login Command Execution Routines - APPE/STOR, cont.

STO03:	MOVX A,^D36		; Common byte size
	MOVE P1,$TYPE		; Get type
	CAIE P1,TYPE.I		; Image type?
	 TXNE F,F.TYPX		; Or Paged?
	  JRST STOOPN		; Yes, All set

	MOVX A,^D7
	CAIN P1,TYPE.A		; Ascii?
	  JRST STOOPN		; Yes

	MOVE A,$BYTE		; Get the connection byte size
	CAIN P1,TYPE.L		; Local byte?
	  JRST STOOPN		; Yes

	JRST STOX4		; No. Unknown type. (impossible)

STOOPN:	MOVEM A,$LBYTE		; Local file byte size ($BYTE unless ASCII)
	MOVX B,OF%WR		; Build OPENF parameter - Writeing
	TXNE F,F.APPE		; or
	  TXO B,OF%APP		; Appending
	STOR A,OF$BSZ,+B

	MOVE A,LCLJFN		; Restore the JFN
	OPENF			; Open according to stuff in B
	  JRST STOX5		; Can't.
CMU,<	CALL LOGOPN>		;CS129 Log open event

	CALL SETCLSD		; Setup F.CLSD

	SETOM F$DTIP		; Data transfer in progress

	CALL PREDAT		; Set up common params,
	  JRST RPCRLP		; No good. Msg in B.

	SUBTTL	Post-Login Command Execution Routines - APPE/STOR, cont.

	MOVE A,REPLYP		; Send started msg
	HRROI B,[ASCIZS (250,150)]
	SKIPL D,$TYPE		; Or more specific message.
	 CAIN D,TYPE.A		; ASCII type?
	  HRROI B,[ASCIZS (250,150,< ASCII>)]
	CAIN D,TYPE.I
	  HRROI B,[ASCIZS (250,150,< IMAGE>)]
	TXNE F,F.TYPX
	  HRROI B,[ASCIZS (250,150,< Paged>)]
	SETZ C,
	SOUT

	HRROI B,[ASCIZ / Store of /]
	TXNE F,F.APPE		; Or append msg
	  HRROI B,[ASCIZ / Append to /]
	SOUT

	HRRZ B,LCLJFN		; File name
	MOVX C,<..DEVD+..DIRA+..NAMA+..TYPA+..GENA+..PROA+..ACTA+JS%TMP+JS%PAF> ; Format
	JFNS
	HRROI B,[ASCIZ / started.
/]
	SETZ C,
	SOUT
	HRROI A,REPLYM		; Send it
	PSOUT
	MOVE A,PREPLY		; And prepare for next one
	MOVEM A,REPLYP
	SETZM REPLYM

	CALL XFRDAT		; Transfer file

	TXNN F,F.ERR 		; Have a local error?
	  JRST STO08		; No, seems ok
	CLOSK (LCLJFN)
	HRRZ A,LCLJFN		; File to be deleted
	TXO A,<DF%EXP>
	DELF			; Delete and expunge file
	  JFCL
	SETOM LCLJFN		; Gone
STO08:


	SKIPA
DATABE:	  TXO F,F.ERR		; Have error (Interrupt break-out address)

	TXNN F,F.ERR		; Close if error or
	  TXNE F,F.CLSD		; EOF requires it
	    CAIA		; Have to close
	     JRST STO09		; Leave open - paged & ok
	MOVEI A,DATCON		;CS129E Data connection
	TXNE F,F.ERR		;CS129E Aborting?
	 TXOA A,CZ%ABT		;CS129E Yes - abort data connection
	  TXO A,CO%WCL		;CS129E No - wait for other end to see close
	CALL CLOSED		;CS129E Close data connection
STO09:

;DATABT:
	CLOSR LCLJFN		; Close these files if open
	SETZM F$DTIP		; Data transfer no longer in progress
	HRROI B,0(X)		; Pointer to reply message
	JRST RPCRLP		; Reply

	SUBTTL	File Transfer Errors

RETX0:	STOX0:			; Neither LCLJFN nor DATCON
RETX4:	STOX4:			; LCLJFN 
	JSP X,DATABE		; Paged & not 36, unknown type, mode, stru
	ASCIZS (457,504,< Parameter combination illegal or unimplemented.>)

RETX1:				; GTJFN failed
RETX5:	JSP X,ERRMSG		; OPEN filed
	ASCIZS (450,550,< File not accessable. >)

RETX2:	STOX2:			; LCLJFN - bad terminator - Syntax
	JSP X,DATABE
	ASCIZS (550,501,< Bad terminator after file name.>)

RETX3:	STOX3:
	JSP X,DATABE		; Access denied message
	ASCIZS (451,550,< You do not have access for that file operation.>)

RETX6:	JSP X,DATABE		;CS129
	ASCIZS (450,550,< File byte size not 7 or 36 bit - not a text file>) ;CS129

RETX7:	JSP X,DATABE		;CS129
	ASCIZS (451,550,< ANONYMOUS access not allowed>) ;CS129

STOX1:				; GTJFN failed
STOX5:	JSP X,DATABE		; OPEN failed
	ASCIZS (450,550,< Can't write such a file.>)

NAN,<				;CS129
STOX7:	JSP X,DATABE		;CS129 GTJFN failed for anonymous
	ASCIZS (450,550,< ANONYMOUS writes must be to PS:<ANONYMOUS>>) ;CS129
   >;NAN			;CS129
ANR,<				;CS129
STOX7:	JSP X,DATABE		;CS129
	ASCIZS (450,550,< ANONYMOUS not allowed to write directory>) ;CS129
   >;ANR			;CS129

STOX6:	JSP X,DATABE		; No account specified
	ASCIZS (433,532,< Account must be supplied to store files. Send ACCT.>)

SLOWM1:	ASCIZS (<050 >,<111->,<Image mode requires 36-bit bytes for efficiency.
>,050,111,< Use TYPE L instead if possible. Proceeding...
>)


ERRMSG:	CALL ERRSUB
	JSP X,DATABE
	0

ERRSUB:	HRROI A,(X)
	PSOUT			; Output message

	MOVX A,.PRIOU		; Output the error message
	MOVX B,<.FHSLF,,-1>	; Last error for this process
	SETZ C,
	ERSTR
	  JFCL
	  JFCL
	RET
	SUBTTL	Subroutines - PREDAT

; Subroutine called by commands which need the data connection.
; Prepares the data socket, sends the 255 socket reply, and
; then opens the connection.
; Skip return if ok, else non-skip with error msg in B.
; Arguments are F.SEND (for direction) and the socket/host/byte params

; Ok or 425


PREDAT:	SKIPGE A,DATCON		; Connection already there?
	  JRST PRED2A		; No.
	$GTSTS			; Yes. Is it the right kind?
	TXNN B,GS%OPN		; Open?
	  JRST PRED2		; No. Flush.

	JRST PRED2I		; Go set byte size, etc

	SUBTTL	Subroutines - PREDAT, cont.

PRED2:	$CLOSF			; Get rid of old connection
	  JFCL			; If can't, just get another JFN
PRED2A:	SETOM DATCON		; No useful old connection

	SUBTTL	Subroutines - PREDAT, cont.

				; Opend TCP data connection
	MOVEI A,T.CDB+DATCON	; Connection descriptor block
	MOVE B,GJINF3		; Our job # is
	LSH B,^D8		; High byte of port
	TXNN F,F.PASV		; If PASV
	  SETZ B,		; Otherwise high byte is 0
	ADD B,FTPDAT		; Low byte is Data socket number
	MOVEM B,.TCPLP(A)	; To CDB
	MOVE C,LHOSTN		; Must use address by which we
	MOVEM C,.TCPLH(A)	; were initially contacted

	SKIPGE B,$HOST		; Specific host given?
	  MOVE B,FHSTN		; No, use TELNET host
	SKIPG C,$SOCK		; Specific port specified
	  MOVE C,FORNS		; No, use same as TELNET
	TXNE F,F.PASV		; However if PASV then
	  SETZB B,C		; Wild foreign Host/Port
	MOVEM B,.TCPFH(A)
	MOVEM C,.TCPFP(A)

	MOVEI A,DATCON		; File block
	MOVX B,<-T.NDBB,,DATBUF> ;CS129C
	MOVX C,T.BFSB		;CS129C
	TXNN F,F.PASV		; If passive, don't wait or force sync
	  TXO C,<TCP%WT!TCP%FS>
	$GTJFN	
	  JRST PREDX1		; Failed
	MOVEM A,DATCON		; Initialized

	TXNE F,F.PASV		; Passive?
	  JRST PRED3		; Passive open - need F.SEND for $OPENF

PRED2I:	SKIPG A,DATCON		; Should contain DATCON here
	  JRST PREDX0		; ??
	SKIPG C,$BYTE
	  MOVX C,^D8
	MOVEM C,$BYTE
	SETZ B,
	STOR C,OF$BSZ,+B	; For open
	TXNE F,F.SEND		; Sending?
	 TXOA B,OF%WR		; Yes
	  TXO B,OF%RD		; No, reading
	$OPENF
	  JRST PREDX0		; Failed
IFN STANSW,< ;;; Turn on RECV/SEND data interupts for data connection
	MOVX B,<Byte(6) 77,RCVCHN,SNDCHN,77,77,77>
	MOVE A,DATCON+T.JCN	;get JCN
	CHANL%			;assign Interupt channels
	 TRN
	MOVE A,DATCON
>;IFN STANSW

PRED3:	AOS 0(P)		; Success return from PREDAT
	RET

	SUBTTL	Subroutines - PREDAT, cont.

PREDX0:	CLOSD DATCON
PREDX1:	TXZ F,F.PASV		; Not in PASV mode either
	HRROI A,STRTMP		; Build error msg here
	HRROI B,[ASCIZS (454,425,< Data connection failed: >)]
	SETZ C,
	SOUT
	HRLOI B,.FHSLF
	SETZ C,
	ERSTR
	  JFCL
	  JFCL
	HRROI B,STRTMP		; Point to msg
	RET			; Fail return








	SUBTTL	Subroutines - PRE255

;	CALL PRE255

PRE255:	MOVE A,PREPLY		; Build reply
	HRROI B,[ASCIZS (<255 SOCK >,<227 Entering Passive mode, use PORT >)]
	SETZ C,
	SOUT			; Send server socket reply in specified

	MOVX C,DECRAD		; Network virtual radix

	SUBTTL	Subroutines - PRE255, cont.

	MOVX D,<POINT 8,LHOSTN,3> ; First 8 bits
	MOVSI T1,-4		;  4 bytes of host

PRE257:	ILDB B,D
	NOUT
	  CALL BOMB
	MOVX B,","
	BOUT

	AOBJN T1,PRE257

	MOVX D,<POINT 8,.TCPLP+T.CDB+DATCON,27> ; Two byte socket #
	LDB B,D
	NOUT
	  CALL BOMB
	MOVX B,","
	BOUT
	ILDB B,D
	NOUT
	  CALL BOMB

	MOVEM A,REPLYP		; For whoever to finish

;CWL ???
	JRST PRE25X
	MOVEI X,^D120
PRE25L:	MOVEI A,^D1000
	DISMS
	MOVE A,DATCON+T.JCN
;CWL *** TOPS20 & TENEX
;	LOADI B,TSTAT		;  Get TSTAT word
;	HRRO B,B
;	HRROI C,C
;	STAT
;	 JRST PRE25X
;	ANDI C,TRSYN!TSSYN	; Still synchable
;	CAIN C,<FLD(4,TRSYN)+FLD(4,TSSYN)>
;	 SOJG X,PRE25L		; Yes, wait
PRE25X:

	RET

	SUBTTL	Subroutines - DOLIST

; DOLIST is the guts of LIST, NLST and STAT.

; 211, 212, 213, 504, 530, 550

.ORG ;BACK TO LOW SEGMENT


DOLIST:	MOVEM A,LSTJFN		; Save the destination.

	LDB B,SBP		; First character of argument
	TXNE F,F.STAT		; Jump if not STAT
	 SKIPE B		; Or if STAT with non-null argument
	  JRST DOLI00

; STAT<RETURN>

	HRROI A,$FILST		; Build string here

	CALL LCLSTS		; Append info to string A/

	SOUT
	IDPB C,A		; End string

	MOVE A,LSTJFN		; TELNET or data connection
	HRROI B,$FILST		; Accumulated string
	$SOUT			; Send it

	RET			; Return from DOLIST

	SUBTTL	DOLIST - Return directory/file info

DOLI00:	TXNE F,F.LOGI		; Am I logged in?
	  JRST DOLI01		; Yes, continue in high segment

	JSP B,RPCRLP		; No good. Complain.
	ASCIZS (451,530,< Please log in first, with USER, PASS and ACCT.>)


.ORG ;BACK TO HIGH SEGMENT


DOLI01:	TXZ F,F.PDIR		; Clear flags: omit directory
	TXZ F,F.T1!F.T2		; Not need CR, more than generation changed

	CALL JBKINI		; See if his string makes sense
				; Set A/JBLOCK, B/SBP
	HRROI T1,[ASCIZ /*/]	; Set up for defaults
	MOVEM T1,.GJNAM(A)
	MOVEM T1,.GJEXT(A)	; Name and ext

	MOVX T1,<GJ%OLD+GJ%IFG+.GJDEF>	; Flags for wild, hi gen of old files
	TXNN F,F.NLST!F.RONL!F.STAT!F.RSTA ;CS129 These use high gen only...
	  HRRI T1,.GJALL	; "Star" for version default (for LIST)
	MOVEM T1,.GJGEN(A)

	MOVE T1,A		; Save args
	MOVE T2,B
	%GTJFN			;CS129
;CU1	  JRST DOLIX1		; No good
;CU1 Begin addition
	IFNSK.			; GTJFN failed
	 CALL TRYMOU		; Attempt structure mount
	  JRST DOLIX1		; Failed, punt
	 %GTJFN			; Try again
	  JRST DOLIX1		; Failed, tell her
	ENDIF.
;CU1 End addition
	MOVEM A,LCLJFN		; Save it
	JXN F,F.RSTA,DORSTA	;CS129X If RSTA, then special

	TXNN A,GJ%DEV+GJ%UNT+GJ%DIR+GJ%NAM+GJ%EXT+GJ%VER ; Any wild cards?
	  JRST DOLINS		; No stars, single file

	TXNE A,GJ%DEV+GJ%UNT+GJ%DIR ; Wild dev?
	  JRST DOLIX3		; Yes. Don't allow whole dumps.

; Stars don't necessairly mean multiple files...

	MOVE A,LCLJFN
	%GNJFN			;CS129 More than one?
	 TXOA F,F.T1		; No, only one (and lost JFN too)
	  RLJFN			; Get to common state - no JFN
	   JFCL

	MOVE A,T1		; Restore args
	MOVE B,T2
	%GTJFN			;CS129 Get JFN back
	  JRST DOLIX1		; No good
	MOVEM A,LCLJFN		; Save it
	IFXN. F,F.RONL		;CS129X Doing RLST?
	  DO.			;CS129X
	    HRRZS A		;CS129X Isolate JFN part
	    MOVX B,<OF%RD>	;CS129X
	    OPENF%		;CS129X Check for file readability
	     ERJMP .+2		;CS129X No.
	    EXIT.		;CS129X Yes - OK
	    MOVE A,LCLJFN	;CS129X Get JFN again
	    %GNJFN		;CS129X Skip to next file
	     ERJMP DOLIX1	;CS129X None available - punt
	    LOOP.		;CS129X Try next file
	  ENDDO.		;CS129X
	  HRRZ A,LCLJFN		;CS129X
	  TXO A,CO%NRJ		;CS129X
	  CLOSF%		;CS129X Close file...
	   TRN			;CS129X
	ENDIF.			;CS129X

	TXZE F,F.T1		; What was the result?
	  JRST DOLINS		; Only one found
	SUBTTL	Subroutines - DOLIST - Multiple files

	TXNN F,F.NLST		; If LIST command, then
	  TXO F,F.PDIR		; Print directory name first time

DOLIL0:	MOVX A,<POINT 7,STRTMP>	; Build line here
	MOVEM A,T1		; Beginning of string
	MOVEM A,T2		; Current end
	TXZ F,F.T1		; Need prefix (not appending a generation)

DOLIL1:	CALL TIMEOK		; Update time kill.

	MOVE A,T2		; Append to this string
	HRROI B,[ASCIZS (<151 >,<212->)] ; Header for TELNET connection
	SETZ C,
	TXON F,F.T1		; Already started line?
	 TXNN F,F.STAT!F.RSTA	;CS129X No. Need the header?
	  SKIPA			; Yes, don't need header again
	   SOUT			; New line and need header

	MOVX B,","		; Separating versions only?
	TXNE F,F.T2
	  BOUT			; Yes.

	HRRZ B,LCLJFN		; The file name to be listed

	TXZN F,F.PDIR		; Want directory line?
	  JRST DOLI03		; Not now

; Output a directory name line

	MOVX C,<..DEVA+..DIRA+JS%PAF> ; TOPS-20
	SKIPE TENEX
	  MOVX C,<..DIRA+JS%PAF> ; TENEX only dir name, punctuated
	JFNS			; Append to string

	HRROI B,CRLFM		; Force an end of line here.
	SETZ C,
	SOUT
	MOVEM A,T1		; Beginning of next line
	MOVEM A,T2		; Always have another line following
	TXZ F,F.T1		; And say not started this line
	JRST DOLIL1		; Back for first file name

	SUBTTL	Subroutines - DOLIST - Multiple files, append filespec

DOLI03:	MOVX C,<..NAMA+..TYPA+..GENA+JS%TMP+JS%PAF>
	TXZE F,F.T2		; Just a new version?
	  MOVX C,<..GENA>	; Yes. Just print that.

	TXNE F,F.NLST		; But if NLST, send different format.
	  MOVX C,<..DEVD+..DIRD+..NAMA+..TYPA+..GENA+JS%TMP+JS%PAF>
	TXNE F,F.STAT		;CS129 Doing STAT?
	 JFNS%			;CS129 Just do normally...
	TXNN F,F.STAT		;CS129 Else...
	 CALL XJFNS		;CS129 Do special JFNS
	MOVEM A,T2		; Save string pointer

	MOVE A,LCLJFN		;Step the handle
	%GNJFN			;CS129
	  JRST DOLILZ		; No more. Go bash "-".
	IFXN. F,F.RONL		;CS129X Is this really an RLST
	  SETZ C,		;CS129X Clear flags
	  DO.			;CS129X
	    IOR C,A		;CS129X Update GNJFN flags
	    HRRZ A,LCLJFN	;CS129X Get jfn
	    MOVX B,OF%RD	;CS129X Make sure readable, then
	    OPENF%		;CS129X Can I open it?
	    IFSKP.		;CS129X Yes...
	      TXO A,CO%NRJ	;CS129X
	      CLOSF%		;CS129X Close again, then
	       TRN		;CS129X
	      EXIT.		;CS129X Done
	    ENDIF.		;CS129X
	    MOVE A,LCLJFN	;CS129X Get jfn again
	    %GNJFN		;CS129X Try for next
	      JRST DOLILZ	;CS129X No more - done
	    LOOP.		;CS129X Check next
	  ENDDO.		;CS129X
	  MOVE A,C		;CS129X Get back flags,,jfn
	ENDIF.			;CS129X

	TXNE F,F.NLST		; NLIST command?
	  JRST DOLIN2		; Yes. Always separate lines.
	TXNN A,GN%DIR+GN%NAM+GN%EXT ; Just version change?
	  JRST DOLI02		; Yes.

	TXNE A,GN%DIR		; New directory?
	  TXO F,F.PDIR		; Yes. Want to mention it.
	SKIPN TENEX
	 TXNN A,GN%STR		; New structure on TOPS-20?
	  SKIPA			; No
	   TXO F,F.PDIR		; Yes. Want to mention it.

DOLIN2:	MOVE A,T2		; String pointer
	HRROI B,CRLFM		; End line.
	SETZ C,
	SOUT
	MOVEM A,T2		; Save pointer again
	IDPB C,A		; End string
	MOVE A,LSTJFN		; Output this file
	HRROI B,STRTMP
	$SOUT
	JRST DOLIL0		; Loop to next line & file.

; Only version changed, pointer is on top of stack

DOLI02:	TXO F,F.T2		; Ext is all that changes
	JRST DOLIL1		; Loop

; End of list, send last line

DOLILZ:	MOVE A,T2
	ILDB B,T1		; Skip 3 digits
	ILDB B,T1
	ILDB B,T1
	MOVX B," "
	TXNE F,F.STAT!F.RSTA	;CS129X Only STAT has header
	  IDPB B,T1		; Whose last line has a space
	JRST DOLIZ1		; A/ points to end

	SUBTTL	Subroutines - DOLIST - Single file

;CS129X DORSTA - Single file, just name, fail if not unique

DORSTA:	MOVX A,<POINT 7,STRTMP>	;Where to put string
	HRROI B,[ASCIZS (150,213,< >)]
	SETZ C,
	SOUT%			;Start with this
	HRRZ B,LCLJFN		;The JFN
	MOVX C,<..DEVD+..DIRD+..NAMA+..TYPA+..GENA+JS%PAF> ;Full name, only
	JFNS%			;Print the name
	MOVE B,A		;Copy string ptr
	MOVE A,LCLJFN		;Get JFN again
	%GNJFN			;See if there are any more matches....
	IFSKP.			;Error...
	  CLOSR (LCLJFN)	;Flush the JFN
	  JSP B,RPCRLP		; No good. Complain.
	   ASCIZS (450,550,< File name is ambiguous.>)
	ENDIF.
	MOVE A,B		;Get back string ptr
	JRST DOLIZ1		;and go finish up

;CS129X *** End ***

;CS129 *** Begin ***

;Special version of JFNS that behaves as if connected to GTJDEV and GTJDIR

XJFNS:	CAME C,[..GENA]		;Only doing generation number?
	IFSKP.			;Yes
	  JFNS			;Do normal jfns
	  RET			;And return
	ENDIF.
	PUSH P,B		;Preserve ACs throughout
	PUSH P,C
	MOVX D,.JSAOF		;Flag...
	SKIPE GTJDEV		;Have CWD device?
	 STOR D,JS%DEV,+C	;Must get device field, then
	SKIPE GTJDIR		;Have CWD directory
	 STOR D,JS%DIR,+C	;Must get directory field, then
	PUSH P,A		;Stash the string ptr
	PUSH P,[POINT 7,TEMSTR] ;Pointer to end of device field
	HRROI A,TEMSTR		;Place to put string
	JFNS%			;get string
	SKIPN GTJDEV		;Any CWD device field?
	IFSKP.			;Yes
	  DMOVE A,[POINT 7,TEMSTR ;Point at our string
		   POINT 7,GTJDEV] ;and the CWD device string
	  DO.
	    ILDB C,A		;Get character
	    ILDB D,B		;...
	    CAIN C,(D)		;Are they the same?
	    LOOP.		;Keep looking until different
	  ENDDO.
	  SKIPN D		;D must be a null...
	  CAIE C,":"		;Were they identical?
	  JRST CPYDEV		;No - copy device field
	  MOVEM A,(P)		;Save pointer to end of device field
	ELSE.			;*No GTJDEV - use what JFNS gave us
CPYDEV:	  DMOVE A,-1(P)		;Get pointers to string & JFNS string
	  DO.
	    ILDB C,B		;Get a character
	    IDPB C,A		;Append to string
	    CAIE C,":"		;Hit end of device field?
	    JUMPN C,TOP.	;Keep going...
	  ENDDO.
	  SKIPE C		;Found device field?
	   DMOVEM A,-1(P)	;Yes - update pointers
	ENDIF.

;Now, do similarly for the directory field

	SKIPN GTJDIR		;Have a CWD directory field?
	IFSKP.			;Yes
	  MOVE A,(P)		;Get pointer past device field in TEMSTR
	  MOVE B,[POINT 7,GTJDIR] ;Point at GTJDIR value
	  IBP A			;Skip over open-pointy
	  DO.
	    ILDB C,A		;Get char from JFNS string
	    ILDB D,B		;Get char from GTJDIR string
	    CAIN C,(D)		;Are they the same?
	    LOOP.		;Yes
	  ENDDO.
	  SKIPN D		;D must be a null...
	  CAIE C,76		;Were they identical (must end in pointy)?
	  JRST CPYDIR		;No - copy directory field
	  MOVEM A,(P)		;Point to end of directory name
	ELSE.			;*No GTJDIR - copy what JFNS returned
CPYDIR:	  DMOVE A,-1(P)		;Get pointers
	  ILDB C,B		;Get char from JFNS string
	  CAIE C,74		;Is there a directory field?
	  IFSKP.		;Yes
	    MOVE B,(P)		;Get back, to clean up loop
	    DO.
	      ILDB C,B		;Get next byte
	      IDPB C,A		;Store it
	      CAIN C,76		;Until end of directory name
	      LOOP.
	    ENDDO.
	    DMOVEM A,-1(P)	;Update pointers to end of directory spec
	  ENDIF.
	ENDIF.

;Finally, copy the rest of the file name.

	POP P,B			;Restore pointer into TEMSTR
	POP P,A			;and pointer to string we are returning
	DO.
	  ILDB C,B		;Get next char of name
	  IDPB C,A		;append it
	  JUMPN C,TOP.		;until a null
	ENDDO.
	SETO B,
	ADJBP B,A		;Fix byte ptr
	MOVE A,B		;...
	POP P,C			;Restore unchanged ACs
	POP P,B
	RET
;CS129 *** End ***

DOLINS:	MOVX A,<POINT 7,STRTMP>	; Build string here
	HRROI B,[ASCIZS (150,213,< >)]
	SETZ C,
	TXNE F,F.STAT		; Cue needed?
	  SOUT			; Yes
;CS129 *** Start ***
LSTFMT=<..DEVD+..DIRA+..NAMA+..TYPA+..GENA+..PROA+..ACTA+JS%TMP+JS%SIZ+JS%CDR+JS%LWR+JS%LRD+JS%PSD+JS%PAF> ; flags for LIST command
NLSFMT=<..DEVD+..DIRA+..NAMA+..TYPA+..GENA+JS%PAF> ;For NLST
	HRRZ B,LCLJFN		;Get file jfn
	IFXE. F,F.STAT		;Not doing stat?
	  MOVX C,LSTFMT		;Assume LIST
	  TXNE F,F.NLST		; But if NLST, send different format.
	   MOVX C,NLSFMT	;...
	  CALL XJFNS		;Do special JFNS
	  JRST DOLIZ1		;Skip special STAT stuff
	ENDIF.
;CS129 *** End ***

;Remainder assumes doing STAT command...

	MOVX C,<..DEVA+..DIRA+..NAMA+..TYPA+..GENA+..PROA+..ACTA+JS%TMP+JS%SIZ+JS%CDR+JS%LWR+JS%LRD+JS%PSD+JS%PAF> ; QFD format
	JFNS
;CS129 *** End ***

; Return creator/writer names with STAT

	SKIPE TENEX		; TENEX?
	  JRST DOLINX		; Yes

; TOPS20 names via GFUST

	MOVE D,A		; Save pointer to string
	HRRZ A,LCLJFN
	MOVX B,<OF%RD+OF%WR>	; ? Why do we need writing??
 skipa;	OPENF
	  JRST DOLINT
	MOVE A,D
	MOVX B,","		; Append creator & last writer
	BOUT
	MOVE B,A		; String pointer
	HRRZ A,LCLJFN		; File &
	HRLI A,<.GFAUT>		; Function
	GFUST
	ERJMP DOLINT
	MOVE D,B
	MOVE A,B
	MOVX B,","
	BOUT
	MOVE B,A
	HRRZ A,LCLJFN
	HRLI A,<.GFLWR>
	GFUST
	ERJMP DOLINT
	MOVE A,B
	JRST DOLIZ1

DOLINT:	MOVE A,D
	JRST DOLIZ1

; TENEX names via GTFDB/DIRST

DOLINX:	PUSH P,A		; Save pointer

	HRRZ A,LCLJFN
	MOVE B,[1,,.FBUSE]	; LH is writer's number
	MOVEI C,D
	GTFDB

	MOVX A,<.NULIO>
	HLRZ B,D		; User number
	DIRST
	  JRST DOLINZ

	MOVE A,(P)		; String
	MOVX B,","		; Append creator & last writer
	BOUT

	HLRZ B,D		; User number
	DIRST
	  JRST .+1

	MOVX B,","		; Append creator & last writer
	BOUT

	HLRZ B,D		; User number
	DIRST
	  JRST .+1

	MOVEM A,(P)
DOLINZ:	POP P,A

; Common wrapup for last line

DOLIZ1:	HRROI B,CRLFM		; Output EOL
	SETZ C,
	SOUT
	IDPB C,A		; End string

	CLOSR (LCLJFN)		; Release STAT JFN

	MOVE A,LSTJFN		; TELNET or data connection
	HRROI B,STRTMP		; Accumulated string
	$SOUT			; Send it

	RET			; Return from DOLIST
	SUBTTL	Subroutines - DOLIST - Error Exits

; GTJFN error on user argument

DOLIX1:	HRROI B,[ASCIZS (450,550,< >)]	; File status
	HRROI D,[ASCIZ /? Not found.
/]
	JRST DOLIXX


; Star for device or directory is illegal

DOLIX3:	HRROI B,[ASCIZS (451,504,< >)]
	HRROI D,[ASCIZ /? * not allowed for device or directory.
/]

DOLIXX:	HRRZ A,LCLJFN		; Close JFN which has too many stars
	RLJFN
	  JFCL
	SETOM LCLJFN

	MOVE A,LSTJFN
	SETZ C,
	TXNE F,F.STAT!F.RSTA	;CS129X Header needed on TTY conn?
	  $SOUT			; Yes.

	MOVE B,D
	$SOUT

	RET			; Error return from DOLIST

	SUBTTL	Subroutines - JBKINI, JFNTXT
;	CALL JBKINI	Initialize long-form GTJFN block
;SETS	A/ JBLOCK	Address of long form block for GTJFN
;	B/ C(SBP)	Frequent string to GTJFN

JBKINI:	MOVEI A,JBLOCK		; Address of block
	SETZM (A)		; Set up for long for GTJFN
	MOVX B,<JBLOCK,,JBLOCK+1>
	BLT B,EJBLOK		; Clear it first
	MOVX B,<.NULIO,,.NULIO>	; No TTY I/O
	MOVEM B,.GJSRC(A)
	SKIPN GTJDEV		;CS129 Any default device? (CWD sets this)
	IFSKP.			;CS129 Yes
	  HRROI B,GTJDEV	;CS129 Point at it
	  MOVEM B,.GJDEV(A)	;CS129 And put in JBLOCK
	ENDIF.			;CS129
	SKIPN GTJDIR		;CS129 Any default directory? (CWD sets this)
	IFSKP.			;CS129 Yes
	  HRROI B,GTJDIR	;CS129 Point at it
	  MOVEM B,.GJDIR(A)	;CS129 Put into JBLOCK
	ENDIF.			;CS129
	MOVE B,SBP		; Rest of user's argument
	RET			; Return


;	CALL JFNTXT

JFNTXT:	PUSH P,A		; Preserve AC's
	PUSH P,B
	PUSH P,C
	SETZM JFNTXS		; Clear text storage
	MOVX A,<JFNTXS,,JFNTXS+1>
	BLT A,EJFNTX
	HRRZ B,-2(P)		; The JFN
	HRROI A,JFNTXS		; Store string here
	MOVX C,<..DEVD+..DIRA+..NAMA+..TYPA+..GENA+JS%PAF> ; Bits for format
	JFNS
	POP P,C
	POP P,B
	POP P,A
	RET
	SUBTTL	Subroutine - SETCLSD

;	CALL SETCLSD		; Sets F.CLSD if data connecion has to
;				; be closed to indicate EOF, Else cleared


SETCLS:	TXO F,F.CLSD		; Assume close at EOF (NCP always closes)

				; Have to close data connection for EOF?
	SKIPGE A,$MODE2		; Get current parameters
	  SETZ A,		; Default
	SKIPGE B,$STRU2
	  SETZ B,

	CAIE A,MODE.C		; Modes Compressed or
	 CAIN A,MODE.B		; Blocked
	  TXZ F,F.CLSD		; Don't have to
	CAIN A,MODE.S		; Mode S and
	 CAIE B,STRU.P		; Structure P
	  SKIPA			; No
	   TXZ F,F.CLSD		; Yes, don't have to
	RET


;	TXNN F,F.CLSD
;	  RET

.ORG ;BACK TO LOW SEGMENT

	SUBTTL	Routine to trap DEBRK failures
;#2 Called with pointer to asciz string, identifying routine, in A
DBKFA1: HRROI D,[ASCIZ / TIMINT or CTTINT
/]
	JRST DBKFAI
DBKFA2:	HRROI D,[ASCIZ / DETINT
/]
	JRST DBKFAI
DBKFA3:	HRROI D,[ASCIZ / QTAINT
/]
	TRN
DBKFAI:
DBKFAL:	GJINF			;#2 add detach of controlling terminal
	CALL CLSTTY		;#2 detach it 
	JRST LOGOUT		;#2 and logout

	SUBTTL Common FTP user & server I/O routines
;
;VAF--FTP4 begins here
;
	SUBTTL	Subroutine DMPREG

; B/	Address of message
; C/	xx,,PC
; D/	Address of saved ACs
;	CALL DMPREG	Dump registers on .PRIOU
;Ret+1:	Always, Need CRLF to end last line

DMPREG:	HRROI A,[ASCIZS (456,421,<->)]
	TXNE F,F.STAT
	  PSOUT			; TELNET prefix if on TELNET connection
	ERJMP .+1

	HRROI A,(B)		; Make pointer to message
	PSOUT			; Specific failure message
	ERJMP .+1

	HRROI A,[ASCIZ / at /]
	PSOUT
	ERJMP .+1

	MOVX A,<.PRIOU>		; Type the PC
	HRRZ B,C		; PC
	MOVX C,<OCTRAD>
	NOUT
	  ERJMP .+1

	MOVX B,<" ">
	BOUT
	ERJMP .+1

	MOVX B,<.FHSLF,,-1>	; Current error, this fork
	SETZ C,			; No limit on message
	ERSTR			; Print the error
	  JFCL
	  JFCL
	HRROI A,[ASCIZ /.
/]
	PSOUT
	ERJMP .+1

	HRROI A,[ASCIZS (456,421,<-AC00: >)]
	CALL N4AC
	HRROI A,[ASCIZS (456,421,<-AC04: >)]
	CALL N4AC
	HRROI A,[ASCIZS (456,421,<-AC10: >)]
	CALL N4AC
	HRROI A,[ASCIZS (456,421,<-AC14: >)]
	CALL N4AC

	HRROI A,[ASCIZS (456,421,< Please report it. Thank you. >)]
	TXNN F,F.STAT		; If User Program
	  HRLI A,(POINT 7,0,27)	; Omit reply code
	PSOUT
	RET
	SUBTTL	Subroutine used by DMPREG

; Routine to print next four registers, A/ title, D/ pointer to values

N4AC:	TXNN F,F.STAT		; If User Program
	  HRLI A,(POINT 7,0,27)	; Omit reply code
	PSOUT			; Output TELNET header & title
	ERJMP .+1

	MOVX A,<.PRIOU>
	MOVX C,<NO%MAG+NO%LFL+FLD(^D14,NO%COL)+OCTRAD>
	HRLI D,-4		; Do 4 more registers
N4ACL:	MOVE B,(D)		; Get register
	NOUT			; Its value
	  MOVX C,<NO%MAG+NO%LFL+FLD(^D14,NO%COL)+OCTRAD>
	AOBJN D,N4ACL		; Back for another

	HRROI A,CRLFM
	PSOUT
	ERJMP .+1
	RET

	SUBTTL	Subroutine HMSMS

; Output title H:M:S.MSC

; A/	Output designator
; B/	Pointer to title
; D/	Time, msec
;	CALL HMSMS

HMSMS:	SETZ C,
	SOUT

	MOVE C,D
	IDIV C,[^D<60*60*1000>]
	MOVE B,C
	MOVX C,<DECRAD>
	NOUT
	  JFCL

	MOVX B,<":">
	BOUT

	MOVE C,D
	IDIVI C,<^D<60*1000>>
	MOVE B,C
	MOVX C,<DECRAD>
	NOUT
	  JFCL

	MOVX B,<":">
	BOUT

	MOVE C,D
	IDIVI C,<^D<1000>>
	MOVE B,C
	MOVX C,<DECRAD>
	NOUT
	  JFCL

	MOVX B,<".">
	BOUT

	MOVE B,C
	MOVX C,<NO%LFL!NO%ZRO!FLD(3,NO%COL)!DECRAD>
	NOUT
	  JFCL
	RET

	SUBTTL	Subroutine LCLSTS

; F.STAT	Set to insert Reply Codes (i.e. is Server Program)
; A/	Destination pointer
;	CALL LCLSTS

LCLSTS:	SETZ C,			; Build long string at A/
	PUSH P,C		; For NOUT of byte size string

	HRROI B,VERSTR		; Identify ourselves
	CALL BCRLF

	HRROI B,[ASCIZ /The current data transfer parameters are:/]
	CALL BCRLF

	HRROI B,[ASCIZ /    MODE /]
	SKIPGE C,$MODE
	  SETZ C,
	HLRO D,MODTAB+1(C)
	CALL BCCRLF

	HRROI B,[ASCIZ /    STRU /]
	SKIPGE C,$STRU
	  SETZ C,
	HLRO D,STRTAB+1(C)
	CALL BCCRLF

	HRROI B,[ASCIZ /    TYPE /]
	SKIPGE C,$TYPE
	  SETZ C,
	HLRO D,TYPTAB+1(C)

	CAIN C,TYPE.A
	  JRST [SKIPGE B,$FORM
		  SETZ B,
		HLRO D,FRMTAB+1(B)
		HRROI B,[ASCIZ /    TYPE A /]
		JRST .+1]

	CAIN C,TYPE.L		; Logical byte?
	  JRST [PUSH P,A
		HRROI A,-1(P)	; Byte size into stack
		SETZM (A)	; Clear for digits
		SKIPGE B,$BYTE
		  MOVX B,<^D8>
		MOVX C,<DECRAD>
		NOUT
		  CALL BOMB
		HRROI D,-1(P)	; Location of digits
		HRROI B,[ASCIZ /    TYPE L /]
		POP P,A
		JRST .+1]

	CALL BCCRLF

	HRROI B,[ASCIZ /NORETAIN generations /]	;#4 
	SKIPE RETVER		;#4 
	 HRROI B,[ASCIZ /RETAIN generations /]	;#4 
	TXNN F,F.STAT		;#4 SERVER?
	 CALL BCRLF		;#4 NO

	TXNN F,F.STAT		; Server?
	 TXNE F,F.TOPN		; Connection open now?
	  JRST LCLST6		; Yes
	HRROI B,[ASCIZ / There is no connection currently open./]
	CALL BCRLF
	JRST LCLSTX		; Done

LCLST6:
	PUSH P,A		; Save destination pointer

	SETZM STRTMP
	MOVX B,<STRTMP,,STRTMP+1>
	BLT B,STRTMP+20

	MOVX A,<.GTHNS>		; Try for string
	HRROI B,STRTMP		; User temp string
	MOVE C,FHSTN
	MOVX D,<POINT 8,FHSTN,3> ; Point before first byte
	GTHST			; Try for name
	  CALL HST4DB		; If error, print decimal #s

	POP P,A

	HRROI B,[ASCIZ /A connection is open to host /]
	HRROI D,STRTMP
	CALL BCCRLF

	SETZ B,			; Assume User
	HRROI D,[ASCIZ /The data connection is CLOSED./]
	SKIPLE DATCON
	  HRROI D,[ASCIZ /The data connection is OPEN./]

	TXNE F,F.STAT		; Server?
	  HRROI B,[ASCIZS (<100 >,<211 >,<>)] ; Prefix if on TELNET connection
	SKIPN B
	  EXCH B,D
	CALL BDCRLF
LCLSTX:	POP P,(P)		; Drop temp string
	RET

	SUBTTL	Subroutines HST4DA/B

; Routine to print TELNET header and string pointed to be B and D

BCRLF:	SETZ D,			; Just string in B
BCCRLF:	PUSH P,B		; String in B & possibly D
	HRROI B,[ASCIZS (<100 >,<211->)] ; Prefix if on TELNET connection
	SETZ C,
	TXNE F,F.STAT		; LIST or STAT?
	  SOUT			; STAT.
	POP P,B

; Routine to print strings pointed to by B and, if non-zero, D

BDCRLF:	SETZ C,			; Print string in B
	SOUT
	HRROI B,(D)		; Possible second string
	SKIPE D			; Don't bother if nothing
	  SOUT
	HRROI B,CRLFM		; End the line
	SOUT
	RET

;	MOVX D,<POINT 8,32-bit-address,3> ; Point before first byte
;	CALL HST4DA if A/ has destination designator
; or	CALL HST4DB if B/ has destination designator
;Ret+1:	Always, #.#.#.#

HST4DB:	MOVE A,B		; Build address here
HST4DA:	MOVX C,<DECRAD>		; Type as four decimal bytes
	JRST HST4DM		; Skip over dot

HST4DL:	MOVX B,<".">
	BOUT
HST4DM:	ILDB B,D		; Get next byte
	NOUT
	  JFCL
	TLNE D,770000		; Bit position zero?
	  JRST HST4DL		; No, have another byte
	MOVX B,<C.NUL>
	BOUT
	RET

	SUBTTL	Subroutines - CLOSER, CLOSEK, CLOSED

; Note: LH of A may contain flags to be passed to "CLOSF"

;	MOVEI A,jfn-variable
;	CALL CLOSER		Close File & Release JFN

CLOSER:	SKIPG 0(A)		; Anything there?
	  RET			; No such JFN. Return.
	PUSH P,A		; Yes. Save a couple AC's
	PUSH P,B
	HRRZ A,0(A)		; Get JFN itself
	GTSTS
	JUMPL B,CLOSR1
	RLJFN			; Not open. Just release JFN
	  JFCL
	JRST CLOSR2

CLOSR1:	CLOSF			; Open, close & release JFN
	  JFCL
CLOSR2:	POP P,B			; Restore AC's
	POP P,A
	SETOM 0(A)		; And flag JFN gone
	RET



;	MOVEI A,jfn-variable
;	CALL CLOSEK		Close File but Keep JFN

CLOSEK:	SKIPG (A)		; Close, keeping JFN. File there?
	  RET			; No.
	PUSH P,A		; Yes, save addr where JFN is
	HRRZ A,(A)		; Get the JFN
	TXO A,CO%NRJ		; Flag to keep the JFN
	CLOSF			; Close it
	  JFCL
	POP P,A			; Restore pointer
	RET			; Return


;	MOVEI A,jfn-variable - DATCON
;	CALL CLOSED		Close data connection

CLOSED:	PUSH P,A		;CS129E Save A
	HRRZS A			;CS129E Flush flags
	SKIPG (A)		;CS129E Data connection there?
	IFSKP.			;CS129E Yes
	  HRRZ A,(A)		;CS129E Get the JFN
	  HLL A,(P)		;CS129E Get flags requested by user
	  $CLOSF		; Close it
	   JFCL
	ENDIF.			;CS129E
	HRRZ A,(P)		;CS129E Get back pointer
	SETOM 0(A)		; Data connection gone
	POP P,A			;CS129E Restore parameter
	RET			; Return

LLITS:	XLIST			; Low-seg lits for DMPREG
	LIT
	LIST
	SUBTTL Subroutine UPDFIL

.ORG ;BACK TO HIGH SEGMENT


; Update file's attributes, assumes everything is setup


UPDFIL:	SKIPLE LCLJFN		; Have a local file?
	 SKIPN $FILST		; And information about it?
	  JRST UPDFI8		; No, Error??

	CLOSK (LCLJFN)		; Make sure closed

UPDFI8:
	RET

	SUBTTL	Data Transfer Routine, Common to FTP User & Server

;	F.SEND, $MODE3, $STRU3, $TYPE3, $BYTE3
;	DATCON, LCLJFN open
;	CALL XFRDAT
;	X/	address of comletion/error message [226,250,451]

XFRDAT:	TXZ F,F.ERR!F.FDB!F.TYPX!F.NUL!F.DSK!F.IMG ; Clear flags

	MOVE A,$MODE3		; Get current parameters
	MOVE B,$STRU3
	MOVE C,$TYPE3
	MOVE D,$BYTE3

	TXO F,F.CLSD		; Assume close at EOF (NCP always closes)
				; Have to close data connection for EOF?
	CAIE A,MODE.C		; Modes Compressed or
	 CAIN A,MODE.B		; Blocked
	  TXZ F,F.CLSD		; Don't have to
	CAIN A,MODE.S		; Mode S and
	 CAIE B,STRU.P		; Structure P
	  SKIPA
	   TXZ F,F.CLSD		; Doesn't have to

	  CAIE B,STRU.P
	   TXZA F,F.TYPX	; Not PAGED xfer
	    TXO F,F.TYPX	; PAGED xfer
	SETZM TYXSCT		; Start sequence numbers at 1
	SETZM NBYTES		; # bytes processed

	HRRZ A,LCLJFN		; See what the local device is
	DVCHR
	LOAD A,DV$TYP		; Get dev type field
	CAIN A,.DVDSK		; Local file DSK:?
	  TXO F,F.DSK		; Yes
	CAIN A,.DVNUL		; NUL: file?
	  TXO F,F.NUL		; Yes

	TXNN F,F.SEND		; Send or receive?
	  JRST DRECV		; Go to DRECV
; Fall into DSEND

	SUBTTL	Send Process, decide which case

; Four cases: Paged from Disk, from Disk, from NUL:, Other

DSEND:	TXNE F,F.NUL		; NUL: file?
	  JRST DSENUL		; Yes.
	TXNN F,F.DSK		; Local file DSK:?
	  JRST DSEBY1		; No, byte by byte

	CALL GETFDB		; Set up the FDB copy of local file
	  JRST DSEEFD		; Illegal instruction interrupt

	TXNE F,F.TYPX		; PAGED (DSK:) transfer?
	  JRST DSEDXT		; Yes.
	JRST DSEDSK		; No.



	SUBTTL	Send Byte by Byte, neither DSK: nor NUL:

DSEBY1:	HRRZ A,LCLJFN		; Get some input
	BIN
	JUMPN B,DSEBY3		; Got a byte

	GTSTS			; Zero byte or EOF/error?
	TXC B,GS%OPN+GS%RDF
	TXNE B,GS%OPN+GS%RDF+GS%EOF
	  JRST DSENDX		; EOF/error

	MOVX B,<0>		; Zero data byte
DSEBY3:
	MOVE A,DATCON		; Write it out
	$BOUT
	ERJMP DSEEWR

	AOS NBYTES		; Count data bytes

	CALL TIMEOK		; Wasteful, every byte, but...
	JRST DSEBY1

	SUBTTL	Send from NUL: (a million bits)

DSENUL:	SETZM FDBBLK		; Zero FDB block
	MOVX A,<FDBBLK,,FDBBLK+1>
	BLT A,FDBBKE

	MOVX A,<400100,,0>	; Make up a phony FDB for the NUL file
	HRR A,LFDB		; System dependent FDB length	
	MOVEM A,FDBBLK+.FBHDR
	MOVX A,<FB%TMP>		; Call it a temp file
	MOVEM A,FDBBLK+.FBCTL
	MOVX A,<FLD(NUMVAL,NMFLG)+770000> ; Make a protection
	MOVEM A,FDBBLK+.FBPRT

	MOVE P2,$BYTE3		; Byte size in B6-B11
	STOR P2,FB$BSZ		; Into FDB
	MOVX BP,<POINT 0,WINDOW> ; Now build byte pointer
	STOR P2,PT$BSZ,+BP

	MOVX P1,<^D36>		; Bits per word
	IDIVI P1,(P2)		; Bytes per word
	MOVE D,P1		; Save for IDPB count
	LSHC P1,<^D<-36+9>>	; Bytes per page in P2

	MOVX T1,<^D1000000>	; A million bits
	IDIV T1,$BYTE3		; Is this many bytes
	SKIPE T2		; Partial word?
	  ADDI T1,1		; Yes, round up
	MOVE P1,T1		; Number of bytes
	MOVEM P1,FDBBLK+.FBSIZ	; Save length for EOF



; D/  # bytes per word
; BP/ Points to data in WINDOW
; P1/ # bytes left to send
; P2/ # bytes per page

	SETO A,			; Free up the window page
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; No count
	PMAP

	MOVE A,BP		; Fill two words
DSENU2:	SETZ B,			; with alternating
	IDPB B,A		; zero and one
	SETO B,			; bytes
	IDPB B,A
	SOJG D,DSENU2

	MOVX A,<WINDOW,,WINDOW+2>
	BLT A,WINDOW+777	; Whole page of them

	MOVX A,<PGT$SP>		; Page type
	MOVEM A,RECTYP
	SETOM PAGNO
	SETZM ACCESS

; BP/ POINT $BYTE3,WINDOW, P1 is # bytes left to send, P2 is bytes per page

DSENUP:	MOVE T2,P1		; Number of bytes left in megabit
	CAILE P1,(P2)		; This page make a million?
	  MOVEI T2,(P2)		; No, send a whole page
	SUB P1,T2		; Bytes remaining after this page

	MOVEM T2,TYXNPW		; # Bytes in a page to be sent
	ADDM T2,NBYTES
	AOS A,PAGNO		; Next page
	MOVEM A,PAGENO
	
	TXNE F,F.TYPX		; If paged mode,
	 JRST DSENUX		; Go send header

	MOVN C,T2		; Negative byte count
	MOVE B,BP		; Starting pointer
	MOVE A,DATCON		; Send connection
	$SOUT			; Send this bunch
	ERJMP DSEEWR
	JUMPN C,DSEEWR
	SKIPA
DSENUX:	  CALL DSEXHD		; Send PAGED header & data in window
	JUMPG P1,DSENUP		; If more to go, send more.
				; No more if fall thru. Close file.
	TXNE F,F.TYPX		; Paged type?
	  CALL DSEXFD		; Yes, send FDB & EOF
	JRST DSENDX		; End of the NUL: file
	SUBTTL	Send from disk, not paged

; Bytes of size specified in FDB are packed into $BYTE3 bits for sending
;		$BYTE3	$LBYTE3==OPENF	File
; ASCII		8	7	7	(7)	transform 7 into 8
; IMAGE		36	36	36	x	IMAGE 36 overrides x
; LOCAL n	n	n	n	x	transform x into n
;
; Find # words in file assuming no holes (Hole is a page of zeros)


DSEDSK:	LOAD D,FB$BSZ		; File byte size (writer's)
	SKIPG D 		; In case bad
	  MOVX D,<^D36>		; Assume words

	SKIPG P1,FDBBLK+.FBSIZ	; Bytes in file (in writer's size)
	  MOVX P1,<1B1>		; If not specified, assume infinite

	HRRZ A,LCLJFN		; File
	RFBSZ			; Get bytesize in which file is now open
	  JFCL			; Error return.	Should not happen
	ANDI B,77		; In case junk
	MOVE C,B		; Copy
;=	MOVE C,$LBYT3

	MOVX BP,<POINT 0,WINDOW> ; Make pointer to window page
	STOR C,PT$BSZ,+BP	; Insert byte size

;#3 convert # of bytes written to # of bytes in mode currently open
	PUSH P,C		;#3 SAVE BYTE SIZE
	PUSH P,D		;#3 USED ELSEWHERE?
	MOVE C,D		;#3 
	CAMGE B,C		;#3 OPEN LESS THAN WRITE ?
	IFSKP.			;CS129 No - open is greater...
	  PUSH P,P2		;CS129 Don't trash P2
	  IDIVI B,(C)		;CS129 Compute dividing factor
	  IDIVI P1,(B)		;CS129 And fix byte count to send
	  SKIPE P2		;CS129 Any remainder?
	  ADDI P1,1		;CS129 Yes - make an extra byte to transfer
	  POP P,P2		;CS129 Restore
	ELSE.			;CS129
	  IDIVI C,(B)		;#3 YES
	  IMULI P1,(C)		;#3 NUMBER OF BYTES IN CURRENT SIZE
	ENDIF.			;CS129
DSEDS1:	POP P,D			;#3 RESTORE
	POP P,C			;#3 RESTORE BYTE SIZE

	MOVX A,<^D36>		; Find conversion to local bytes per word
	IDIVI A,(C)		; as OPENFed
	LSH A,^D9		; Bytes per page
	MOVEM A,P2

; Look for holes in file, if hole, set byte count to + infinity

	SETOM PAGNO		; Scan to see if any holes
DSEDSH:	AOS A,PAGNO		; A page to check
	HRL A,LCLJFN		; In this file
	RPACS			; See if its there
	TXNE B,PA%PEX		; Exist?
	  JRST DSEDSH		; Yes. Look onward.
	FFUFP			; See if any pages are used beyond here.
	 SKIPA			; No. Simple sequential file.
	  MOVX P1,<1B1>		; Yes. Make length be infinite

	SUBTTL	Send DSK: file, page by page

; BP/ POINT $BYTE3,WINDOW, P1 is # bytes left to send, P2 is bytes per page

	SETOM PAGENO		; Starts at page zero-1
DSEDSP:	JUMPLE P1,DSENDX	; Leave if all bytes sent
	AOS A,PAGENO		; Next page #
	HRL A,LCLJFN		; In local file
	RPACS			; Page access bits
	TXNE B,PA%PEX		; Page exist?
	  JRST DSEDSQ		; Yes. Send it.
	FFUFP			; See if any more pages beyond.
	  JRST DSENDX		; No. End of file.
	SETO A,			; Yes. Pretend this hole was a page of 0.
DSEDSQ:
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	MOVX C,<PA%RD>		; Map in the page
	PMAP

	MOVE C,P1		; Bytes left to send
	CAMLE C,P2		; If more than a page
	  MOVE C,P2		; Just a page now
	ADDM C,NBYTES		; Count bytes sent
	MOVNS C			; - Number of words for SOUT
	ADDM C,P1		; Bytes remaining after this page

	MOVE B,BP		; Pointer for SOUT

	HRRZ A,DATCON		; Send the data
	$SOUT
	ERJMP DSEEWR
	JUMPN C,DSEEWR

	CALL TIMEOK		; Update timer
	JRST DSEDSP		; Back for next page

	SUBTTL	Send from DSK:, PAGED type/structure

DSEDXT:	SETOM PAGENO		; Set window page number to zero-1
DSEDX1:	AOS A,PAGENO		; Next page to consider
DSEDX2:	HRRZM A,PAGNO		; Store file page number for net
	HRL A,LCLJFN		; Page pointer
	RPACS			; Find the access for the page
	MOVEM B,ACCESS		; Save bits for net

	TXNN B,PA%PEX		; Does page exist?
	  JRST DSEDX3		; No. Go see if any more.

	MOVX B,<.FHSLF,,<WINDOW/1000>>
	MOVX C,<PM%RD>		; Map it in for reading
	PMAP

	MOVX A,<PGT$SP>		; Simple page (TOPS20)
	SKIPE TENEX
	  MOVX A,<PGT$AP>		; Access controlled page (TENEX)
	MOVEM A,RECTYP		; This is a data record

	MOVX A,<1000>		; Length is one page of 36-bit bytes

; Kludge compression

	SKIPN WINDOW-1(A)	; Or less
	  SOJG A,.-1		; Drop trailing zeros
	CAIGE A,2		; Make sure at least some data
	  MOVX A,<2>		; So loops work

	MOVEM A,TYXNDW		; Store in header
	ADDM A,NBYTES		; And count in transfer length

	CALL DSEXHD		; Send this page

	CALL TIMEOK		; Update timeout timer
	JRST DSEDX1		; On to next page

; Missing page

DSEDX3:	FFUFP			; Are there any more pages?
	  JRST DSEDX4		; No.
	HRRZM A,PAGENO		; Yes, save the page number found
	JRST DSEDX2		; Go send it.

DSEDX4:	CALL DSEXFD		; Last page handled. Send FDB

; Send reached end of file

DSENDX:	MOVX B,<.MOSND>		; Send partial buffer
	MOVE A,DATCON		; May omit PUSH if going to close
;#3 always push, the current vax code can't handle data and FIN in same packet
;#3	TXNN F,F.CLSD		; Going to close?
	 $MTOPR			; No, PUSH data out
	  ERJMP DSEEMT
	JRST XFRDAX		; Done, all ok
	SUBTTL	Subroutine DSEXFD - Send PAGED descriptor block

DSEXFD:	SETZM ACCESS		; Send FDB & EOF for PAGED DSK: file
	SETZM PAGNO		; Clear access and page number
	MOVX A,<PGT$DP>		; Descriptor page
	MOVEM A,RECTYP		; To header

	SETO A,			; Release window
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; Just one page
	PMAP

	MOVX A,<FDBBLK,,WINDOW>	; Put the FDB in it
	MOVE C,FDBBLK		; Actual length
	ANDI C,77		; Remove other info
	BLT A,WINDOW-1(C)

	HRROI A,WINDOW(C)	; Pointer to free word
	SETZ C,
	MOVX D,<-FDTXSN,,FDTXST> ; Locations of times & user names

DSEXFL:	HRRO B,(D)		; String
	SOUT			; After FDB
	IDPB C,A		; End string with a NUL
	HRROI A,1(A)		; Next free word
	AOBJN D,DSEXFL		; Back for next

	HRRZI C,-WINDOW(A)	; Words used
	MOVEM C,TYXNDW		; To header for net

				; TCPP has LAST-PAGE after DESCRIPTOR-PAGE
	CALL DSEXHD		; Send descriptor page
	TXO F,F.FDB		; FDB sent

	MOVX A,<PGT$LP>		; Last page
	MOVEM A,RECTYP
	SETZM TYXNDW		; No data

	SUBTTL	Subroutine DSEXHD - Send PAGED header & data blocks

; Send PAGED header and data (if any)
;	CALL DSEXHD	Send header & TYXNDW words from page in window

DSEXHD:	AOS A,TYXSCT		; Count the net seq number

	MOVE C,RECTYP		; Get page type
	MOVE B,PGLEN(C)		; Get corresponding header length
	MOVEM B,TYXNPW		; Into header

	MOVE A,DATCON
	MOVN C,B		; Now that many words of hdr
	MOVX B,<POINT ^D36,TYXHED> ; Point to the data
	$SOUT			; Send the header
	ERJMP DSEEWR
	JUMPN C,DSEEWR

	MOVN C,TYXNDW		; And the data area, this long.
	MOVX B,<POINT ^D36,WINDOW>
	SKIPE C			; Omit if none
	 $SOUT
	  ERJMP DSEEWR
	JUMPN C,DSEEWR

	RET

	SUBTTL	Receive direction after JFN's are both open. Swallow the data


DRECV:	SETO A, 		; Get the window page free
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; Just one page
	PMAP


DRCVL1:	TXNE F,F.TYPX		; Paged transfer?
	  JRST DRCX		; Yes.

	MOVE A,$BYTE3		; Byte size sent

	MOVX B,<^D36>		; Bits per word
	IDIVI B,(A)		; Bytes per word
	IMULI B,1000		; Page's worth of bytes
	MOVNS C,B		; Negative for SIN

	MOVX B,<POINT 0,WINDOW>	; Build byte pointer to WINDOW
	STOR A,PT$BSZ,+B

	PUSH P,B		; Save starting byte ptr
	PUSH P,C		; And count
	HRRZ A,DATCON		; Connection from net
	$SIN
	ERJMP DRCERE
	POP P,D 		; Starting count
	POP P,B 		; And pointer
	SUB C,D			; Actual count read by SIN



DRCOUT:	JUMPE C,DRCEOF		; If no bytes then EOF
	ADDM C,NBYTES		; Bytes transferred so far

	MOVNS C 		; Negative for SOUT
	HRRZ A,LCLJFN		; Where to put the data
	TXNN F,F.NUL		; Don't waste time on NUL:
	 SOUT
	  ERJMP DRCERE

DRCEFQ:		; PAGED enters here

	CALL TIMEOK		;CS129 Poke timer for every page
	MOVE A,DATCON		; See if have gotten to EOF yet
	$GTSTS
	TXNE B,GS%OPN+GS%RDF	; Still happy?
	 TXNE B,GS%ERR
	  JRST DRCERD		; No.
	TXNE B,GS%EOF		; End of file?
	  JRST DRCEOF		; Yes
	JRST DRCVL1

	SUBTTL	Receive PAGED transfer.

DRCX:	SETO A,			; Throw away any junk in window page
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; Just one page
	PMAP

	SKIP WINDOW		; Touch it to get a blank page

	MOVE A,DATCON		; Now get the header length
	$BIN
	ERJMP DRCERE
	JUMPN B,DRCXB		; Got a non-zero header lmngth

; Following should be NCP only, TCPP should be JRST DRCETD

	$GTSTS			; Should be EOF and "last" page
	TXNE B,GS%OPN+GS%RDF
	 TXNE B,GS%ERR
	  JRST DRCERD		; Error - not open, not read, error
	TXNN B,GS%EOF		; EOF?
	  JRST DRCETD		; No. Should not have a zero byte here.

	MOVE C,RECTYP		; EOF. Was last record the "last" page?
	CAME C,[PGT$LP]
	  JRST DRCELP		; No. Error.
	TXNN F,F.FDB		; Get FDB?
	  JRST DRCENF		; No. Error.
	JRST XFRDAX		; Good. Finish up.

DRCXB:	MOVEM B,TYXHDR		; Store in scratch area
	CAIL B,LTYXMN		; Range check it
	 CAIL B,NTXHDR		; Will it fit in this buffer?
	  JRST DRCEHL		; No good. Format error

	MOVN C,B		; Ok, read the header
	ADDI C,1		; Count included count word
	MOVX B,<POINT ^D36,TYXHDR+1>
	$SIN
	ERJMP DRCERE
	JUMPN C,DRCEHR		; If didn't get it all, format error

	MOVX C,<TYXHDR,,TYXHED> ; Copy it to real area known length
	BLT C,TYXHED+TYXHDN-1



	MOVE C,TYXNDW		; Get the data length out of the header
	CAIL C,0		; Make sure it's reasonable
	 CAILE C,1000		; Up to a page
	  JRST DRCEDL		; Format error

	MOVX B,<POINT ^D36,WINDOW> ; Ok, read it into the window
	MOVNS C			; This many words, negative.
	SKIPE C 		; Allow for empty body
	 $SIN
	  ERJMP DRCERE
	JUMPN C,DRCEDR		; Make sure got it all

	AOS C,TYXSCT		; Check the sequence number

	MOVE A,RECTYP		; Get data record type
	TXNE F,F.DSK		; To disk?
	  JRST DRCXDS		; Yes.

; PAGED type/structure NOT to DSK:

	CAME A,[PGT$SP]		; Simple page or
	 CAMN A,[PGT$AP]	; Access controlled page?
	  SKIPA			; Yes
	   JRST DRCEFQ		; No, ignore non-data info

	MOVE C,TYXNDW		; Yes. Output the data to local file.
	MOVX B,<POINT ^D36,WINDOW> ; Set AC's like non-paged code.
	JRST DRCOUT		; And rejoin that code.




; PAGED type/structure header & data to DSK:

DRCXDS:	CALL TIMEOK		;CS129 Poke timer for each page
	CAME A,[PGT$SP]		; Simple page or
	 CAMN A,[PGT$AP]	; Access controlled page?
	  JRST DRCXDA		; Yes, process data
	CAMN A,[PGT$LP]		; Last page?
	  JRST XFRDAX		; Yes, done all ok
	CAMN A,[PGT$DP]		; Descriptor page?
	  JRST DRCXFD		; Yes
	JRST DRCEFQ		; No, ignore others for growth

	SUBTTL	PAGED data page to DSK: file
				; Put the data in the window into the file
DRCXDA:	MOVX A,<.FHSLF,,<WINDOW/1000>>
	HRRZ B,PAGNO		; Here in the file
	MOVEM B,PAGENO
	HRL B,LCLJFN
	MOVX C,<PM%WR>		; Write access
	PMAP			; In it goes

	MOVE A,RECTYP		; Get page type
	CAME A,[PGT$AP]		; Access controlled page
	  JRST DRCXD2		; No
	MOVE A,TYXNPW		; Header length
	CAML A,PGLEN+PGT$AP	; Correct length to contain ACCESS?
	 SKIPN TENEX		; Invalid under TOPS-20
	  JRST DRCXD2		; Omit ACCESS processing

	MOVE A,B		; Now set the file access
	MOVE B,ACCESS
	SPACS
	ERJMP DRCESP
DRCXD2:
	SETO A,0		; And release window (to the file)
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; Just one page
	PMAP

	MOVE A,TYXNDW		; Count the transferred bytes
	ADDM A,NBYTES
	JRST DRCEFQ		; See if any more.



	SUBTTL	Process recieved PAGED descriptor page

; Check for reasonable FDB length

DRCXFD:	MOVE A,WINDOW		; Length of FDB
	ANDI A,77
	CAIL A,MINFDB		; Look like an FDB?
	 CAILE A,MAXFDB+10
	  JRST DRCEFL		; No, say format error


; Get extra ASCIZ information after FDB into individual strings

	MOVE B,TYXNDW		; Information words there
	HRROI B,WINDOW(B)	; Pointer beyond end (negative)
	PUSH P,B

	HRROI A,WINDOW(A)	; String pointer from window
	SETZ C,
	MOVX D,<-FDTXSN,,FDTXST>

DRCXFI:	HRRO B,(D)		; String
	SIN			; Get it
	IDPB C,B		; End string with a NUL
	HRROI A,1(A)		; Beginning of next string
	CAMLE A,(P)		; Anythingthere?
	  SETZB D,@(D)		; No, stop
	AOBJN D,DRCXFI		; Back for next
	POP P,(P)		; Discard end address

; Convert date & time strings to internal format (TOPS20 & TENEX differ)

	MOVX D,<-FDTXTN,,FDTXT>
DRCXFJ:	HRRO A,(D)		; String pointer
	SETZ B,			; Any format
	IDTIM
	  TLO B,-1		; No time on error
	HLRZ A,(D)		; FDB offset to corresponding time
	MOVE C,B		; Keep FDB value if equivalent to string
	SUB C,WINDOW(A)		; See if close to FDB value
	MOVMS C			; If magnitude of difference is bigger
	CAILE C,4		;  than a few ticks,
	MOVEM B,WINDOW(A)	; Use time from string
	AOBJN D,DRCXFJ

; Update FDB information

	MOVX D,<-FDBTXN,,0> 	; Update the FDB
	MOVX C,<-FDBTMN,,0>	; Last are times
	PUSH P,C
DRCXFN:	MOVE A,LCLJFN		; Make pointer to FDB word
	HRL A,FDTXT1(D) 	; This word of FDB
	MOVE B,FDTXT2(D)	; This mask to change
	MOVE C,FDTXT1(D)	; From this word of net FDB
	MOVE C,WINDOW(C)
	CAML D,(P)		; A time?
	 SKIPL C		; Yes, valid?
	  CHFDB			; No. Put in the data
CHFDPC:	ERJMP .+1 ;DRCECF
	AOBJN D,DRCXFN		; Loop for changeable words of FDB
	POP P,(P)



; Set original writer/creator name, if possible

	SKIPE TENEX
	  JRST DRCXFT		; TENEX
				; TOPS20
	MOVX D,<-FDTXUN,,FDTXUS>
DRCXFR:	HRRZ A,LCLJFN		; File
	HLL A,(D)		; Function
	HRRZ B,(D)		; Build pointer to string
	HRLI B,440700		; ..
	ILDB C,B		; See if it's null
	JUMPE C,DRCXF1		; If null, don't set it
	HRLI B,440700		; Rebuild string pointer
	SFUST
	ERJMP .+1		; Probably not enabled
DRCXF1:	AOBJN D,DRCXFR
	JRST DRCXFU

DRCXFT:	SETZ A,			; Literal string
	HRROI B,FDBUS0		; String DIRST
   SKIPA
	STDIR
	  ERJMP .+2
	  ERJMP .+1
	JFCL
DRCXFU:
	JRST DRCEFQ		; Should be EOF now if NCP.

FDTXT1:	EXP .FBCTL		; Can change these words
	EXP .FBBYV
	EXP .FBSIZ
	EXP .FBUSW
IFN SETPFL,<EXP .FBPRT>		;CS129D Set protection
..Z=.
	EXP .FBCRV
	EXP .FBWRT
	EXP .FBREF
FDBTMN==.-..Z			; Number of times
FDBTXN==.-FDTXT1

FDTXT2:	EXP FB%TMP+1000000	; Temp and (TENEX) ephemeral bits
	EXP FB%BSZ		; Byte size
	EXP -1			; EOF
	EXP -1			; User settable word
IFN SETPFL,<EXP .RHALF>		;CS129D Protection is RH only

	EXP -1			; Time this version created
	EXP -1			; Time this version last modified
	EXP -1			; Time last referenced

FDTXST:	EXP FDBTM1,FDBTM2,FDBTM3,FDBUS0,FDBUS1
FDTXSN=.-FDTXST

	SUBTTL	Data transfer Error Messages

DRCECF:	JSP X,XFRERR
	ASCIZS (452,451,< ? Unable to update local file descriptor.>)
DRCEDL:	JSP X,XFRERR
	ASCIZS (452,451,< ? Invalid PAGED data block length.>)
DRCEDR:	JSP X,XFRERR
	ASCIZS (452,451,< ? Premature EOF from network during PAGED data read.>)
DRCEFL:	JSP X,XFRERR
	ASCIZS (452,451,< ? Invalid PAGED FDB length.>)
DRCEHL:	JSP X,XFRERR
	ASCIZS (452,451,< ? Invalid PAGED header length.>)
DRCEHR:	JSP X,XFRERR
	ASCIZS (452,451,< ? Premature EOF from network during PAGED header read.>)
DRCELP:	JSP X,XFRERR
	ASCIZS (452,451,< ? Last block of PAGED transfer missing.>)
DRCENF:	JSP X,XFRERR
	ASCIZS (452,451,< ? No descriptor (FDB) information received.>)
DRCERD:	JSP X,XFRERR
	ASCIZS (452,451,< ? Error on network data connection.>)
DRCERE:	JSP X,XFRERR
	ASCIZS (452,451,< ? Read error on network data connection.>)
DRCESP:	JSP X,XFRERR
	ASCIZS (452,451,< ? Error setting local file page access.>)
DRCETD:	JSP X,XFRERR
	ASCIZS (452,451,< ? PAGED header length was zero.>)
DSEEFD:	JSP X,XFRERR
	ASCIZS (452,451,< ? Internal Error - Cannot access local file's FDB.>)
DSEEMT:	JSP X,XFRERR
	ASCIZS (452,451,< ? Internal Error - MTOPR failed.>)
DSEEWR:	JSP X,XFRERR
	ASCIZS (452,451,< ? Unexpected close of data connection.>)

MSG226:	ASCIZS (252,226,< Transfer completed. >) ;CS129 Ok & Connection closed
MSG250:	ASCIZS (252,250,< Transfer completed. >) ;CS129 Ok & connection open


; X/ Address of reply message

XFRERR:	TXO F,F.ERR		; Forces close of connection

	SUBTTL	Data Transfer Exit

DRCEOF:				; Received end of file
XFRDAX:	SETO A,			; Unmap the window pages
	MOVX B,<.FHSLF,,<WINDOW/1000>>
	SETZ C,			; No count
	PMAP
	ADDI B,1
	PMAP
	HRRI B,<WINDW2/1000>
	PMAP
	ADDI B,1
	PMAP

;CS129 *** Begin change/addition ***
;Here, X has error msg if error, otherwise need to build it
;	F.CLSD or F.ERR means close necessary on data connection.

	HRROI B,MSG250		;Assume OK and leaving open...
	IFXN. F,F.CLSD!F.ERR	;Have to close (or error)?
	  CLOSD (DATCON,CO%WCL)	;Wait for other end to see close
	  HRROI B,MSG226	;Data connection is closed...
	ENDIF.
	IFXE. F,F.ERR		;If no error, need to build full reply string
	  HRROI A,STRTMP	;Where to put the string (B has reply code str)
	  SETZ C,		;To end of string
	  SOUT%			;Copy
	  MOVE B,NBYTES		;# of bytes transferred
	  MOVEI C,^D10		;decimal
	  NOUT%
	   TRN
	  MOVEI B," "
	  IDPB B,A
	  MOVEI B,"("
	  IDPB B,A
	  MOVE B,$BYTE		;Get byte size
	  NOUT%			;print
	   TRN
	  HRROI B,[ASCIZ/) bytes transferred./]
	  SETZ C,
	  SOUT%
	  HRROI X,STRTMP	;Make pointer to string
	ENDIF.
;CS129 *** End ***
	HRRZM X,$REPLM		; Local reply message address for superior
	RET			; Return from XFRDAT

	SUBTTL	Subroutine GETFDB

;	CALL GETFDB	Copies Disk FDB into FDBBLK
;Ret+1:	  Illegal instruction interupt
;Ret+2:	Ok

GETFDB:	SETZM FDBBLK		; Clear it in case not DSK: or NUL:
	MOVX A,<FDBBLK,,FDBBLK+1>
	BLT A,FDBBKE

	HRRZ A,LCLJFN		; Local file
	HRLZ B,LFDB		; System dependent FDB length
	MOVEI C,FDBBLK		; Store it here
	TXNN F,F.DSK		; If not disk,
	  JRST GETFDX		; Ok return
	GTFDB			; Get the info
	  ERJMP GETFDY

	MOVE A,FDBBLK		; Size of FDB
	ANDI A,777
	PUSH P,A		; For testing

	MOVX D,<-FDTXTN,,FDTXT>
	MOVX C,<OT%4YR!OT%TMZ!OT%SCL>
GETFD1:	HRRO A,(D)		; String pointer
	HLRZ B,(D)		; FDB offset
	CAMLE B,(P)		; In FDB?
	  JRST GETFD2		; No
	MOVE B,FDBBLK(B)	; Get time
	ODTIM
	ERJMP .+1
	AOBJN D,GETFD1
GETFD2:
	SKIPE TENEX
	  JRST GETFD5		; TENEX
				; TOPS20
	MOVX D,<-FDTXUN,,FDTXUG>
GETFD3:	HRRZ A,LCLJFN		; File
	HLL A,(D)		; Function
	HRRO B,(D)		; String pointer
	GFUST
	AOBJN D,GETFD3
	JRST GETFD6

GETFD5:	HRROI A,FDBUS0		; String pointer
	HLRZ B,FDBBLK(D)	; Directory number
	DIRST
	ERJMP .+1
GETFD6:
	POP P,(P)		; Drop FDB length
GETFDX:	AOS (P)			; Skip return
GETFDY:	RET



FDTXT:	XWD .FBCRV,FDBTM1	; Times  FDB offset,,String variable
	XWD .FBWRT,FDBTM2
	XWD .FBREF,FDBTM3
FDTXTN==.-FDTXT

FDTXUG:	XWD .GFAUT,FDBUS0	; User name  Function code,,String variable
	XWD .GFLWR,FDBUS1
FDTXUN==.-FDTXUG

FDTXUS:	XWD .SFAUT,FDBUS0	; User name  Function code,,String variable
	XWD .SFLWR,FDBUS1

DLITS:;	LIT
	XLIST
	LIT
	LIST

HSTOP==.-1
HSPMAX==HSTOP/1000		;CS129C Max hi seg page for SPACS

.ORG ;BACK TO LOW SEGMENT

	SUBTTL	Interrupt Tables

LEVTAB:	EXP RETPC1,RETPC2,RETPC3

CHNTAB:	0			; 0
	0			; 1
	0			; 2
	0			; 3
	0			; 4
	0			; 5
	0			; 6  Arithmetic Overflowl/nodiv
	0			; 7  Floating Point overflow/FXU
	0			; 8
	1,,PDLINT		; 9  PDLOV
	0			; 10 EOF
	2,,IOXINT		; 11 IO Data Error
	2,,QTAINT		; 12 Quota Exceeded
	0			; 13
	0			; 14 Time of Day
	1,,INSINT		; 15 Illeg Instruction Int
	1,,MEMINT		; 16 Illeg Memory Read
	1,,MEMINT		; 17 Illeg Memory Write
	1,,MEMINT		; 18 Illeg Memory Execute
	0			; 19 Fork Term
	1,,FULINT		; 20 Machine size exceeded (Disk/Drum??)
	0			; 21 Trap to User
	0			; 22 New Page
	0			; 23
TIMCHN==.-CHNTAB	; Channel poked by timing fork every now and then
	2,,TIMINT		; 24 Timing Fork Int
CTCCHN==.-CHNTAB	; Channel for Control-C
	2,,CTCINT		; 25 Control-C (or E in debug)
DETCHN==.-CHNTAB	; Channel for NVT hangup
	2,,DETINT		; 26 Detach Interrupt
CTTCHN==.-CHNTAB	; Channel for Control-T
	2,,CTTINT		; 27 Control-T
IFN STANSW,< ;;; Channels for RECV / SEND done
RCVCHN==.-CHNTAB
	2,,DONINT		;28 RECV finished
SNDCHN==.-CHNTAB
	2,,DONINT		;29 SEND finished
>;IFN STANSW
IFE STANSW,<
	0			; 28
	0			; 29
>;IFE STANSW
	0			; 30
	0			; 31
	0			; 32
	0			; 33
	0			; 34
	0			; 35
IFN <.-44-CHNTAB>,<PRINTX ; CHNTAB not 36 long>

IFE STANSW,<
ONCHNS:	1B<.ICPOV>!1B<.ICDAE>!1B<.ICILI>!1B<.ICIRD>!1B<.ICIWR>!1B18!1B<.ICMSE>!1B<TIMCHN>!1B<CTCCHN>!1B<DETCHN>!1B<CTTCHN>!1B<.ICQTA> ;CU1
>;IFE STANSW
IFN STANSW,<
ONCHNS:	1B<.ICPOV>!1B<.ICDAE>!1B<.ICILI>!1B<.ICIRD>!1B<.ICIWR>!1B18!1B<.ICMSE>!1B<TIMCHN>!1B<CTCCHN>!1B<DETCHN>!1B<CTTCHN>!1B<.ICQTA>!1B<RCVCHN>!1B<SNDCHN>
>;IFN STANSW
FAIJFN:	BLOCK 1

	SUBTTL Constants

DEFINE CC (A,B) <
IFNDEF Z'A, <Z'A==NOTIMP>
>

	COMS


	PARMAC


IFN IPCLOG,<
INFMSG:	1,,.IPCIW		; .IPCI0 message to info
	0			; .IPCI1 no copy
	ASCIZ /[SYSTEM]FTSCTT/	; .IPCI2 get a PID for this name
ENDMSG==.
>
	SUBTTL	Constants

GPDP:	IOWD PDLL,GPDL		; Global (top-level) stack
PDP:	IOWD PDLL,PDL

L1PDP:	IOWD PDLL,L1PDL		; Lev 1 PSI stack
L2PDP:	IOWD PDLL,L2PDL		; Lev 2 PSI stack
L3PDP:	IOWD PDLL,L3PDL		; Lev 3 PSI stack

CMDIP0:	POINT 7,CMDIB-1,34	;  Initial pointer to command buffer
WRDBP0:POINT 7,WORDBF-1,34	;u Initial pointer to word buffer

FTPDAT: ^D<21-1>		;s Local port for data connection

T20PAR:	EXP	 0,T20FDB,T20CDL,T20CD2,T20WDL,T20WD2,T20LDL,T20LD2,T20EOL
TNXPAR:	EXP	-1,TNXFDB,TNXCDL,TNXCD2,TNXWDL,TNXWD2,TNXLDL,TNXLD2,TNXEOL

PATCHX=VERSIO			; Update version number if patched
PAT:
PATCH:	BLOCK 400		; For patching the binary
DBUGSW:	0			; Nonzero for debugging

; End of all code. Now the literals.

LITS:	XLIST ; LIT Statement
	LIT
	LIST

LSTOP==.

FREPAG==100			;u Page of free storage

	SUBTTL	Global Variables

	LOC 200000
GSBAS:
FREE:	BLOCK 1			;u Pointer to (end of) free core

GPDL:	BLOCK PDLL		;  Stack for top fork


; NB: order must match T20PAR & TNXPAR
TENEX:	BLOCK 1			; Non-zero if running on a TENEX system
LFDB:	BLOCK 1			; Length of disk FDB
EDIT0:
CDELCH:	BLOCK 1			; System-dependent character delete character
CDE2CH:	BLOCK 1
CDELWD:	BLOCK 1			; System-dependent word delete character
CDE2WD:	BLOCK 1
CDELLN:	BLOCK 1			; System-dependent line delete character
CDE2LN:	BLOCK 1
NEDITS==.-EDIT0
EOL:	BLOCK 1			; System-dependent end of input line character
; NB: order must match T20PAR & TNXPAR

VERSTR:	BLOCK 20		; ASCII version number

				;s Results of GJINF at start and LOGIN
GJINF1:	BLOCK 1			;s User ID # (TENEX 18-bit Dir # or
				;  TOPS20 36-bit User #)
GJINF2:	BLOCK 1			;s Connected directory #
GJINF3:	BLOCK 1			;s Job #
GJINF4:	BLOCK 1			;s -1 or attached TTY #

SYSDNM:	BLOCK 1			;s Dir number of SYSTEM
ANOUNO:	BLOCK 1			;s User number of ANONYMOUS or 0
ANNJFN:	BLOCK 1			;s JFN of ANONYMOUS.USERFILE while open
ANOPSW:	BLOCK 10		;s Where to store ANONYMOUS's password 
ANONOK:	BLOCK 1			;CS129 s if ANONYMOUS login allowed from host
ANOPSE==.			;  from system text file

USERNM:	BLOCK 1			;s TENEX: Directory Number (STDIR($USER))
; or				;s TOPS20: User Number (RCUSR($USER))



DIRJFN:				;u Directory JFN in MULTIPLE GET
LSTJFN:	BLOCK 1			;s JFN where LIST or STAT goes.
LCLJFN:	BLOCK 1			;  JFN of local temp files
LOGJFN:	BLOCK 1			;CS129 sJFN on PS:<SPOOL>FTPSRT.LOG, if any
LCLSTR:	BLOCK 10		;s Name of structure, or zero if not appl.
LCLGEN:	BLOCK 1			;u Local generation #
PRGJFN:	BLOCK 1			;s JFN from RMAP of this program
TJFN:	BLOCK 1			;u JFN of temporary file
$PATH1:	BLOCK 1		;-1	;s JFN for Rename From
$PATH2:	BLOCK 1		;-1	;s JFN for Rename To

$PTHS1:	BLOCK 40		;s String space for old name in RNFR




F$SEND:	BLOCK 1			;uCD 0 for rcv data from net, else send.
F$FLST:	BLOCK 1			; CR File status is being requested
F$KPGN:	BLOCK 1			; CD May rename local file to keep gen #
F$DOPN:	BLOCK 1			;uCD Flag to assure data conn opened
F$DTRQ:	BLOCK 1			;uC  Data transfer about to be requested
F$DTIP:	BLOCK 1			; C  Data transfer in prog (250, no 252)
F$WORK:	BLOCK 1			;uCD TIMEOK increments, CWFORK test/clears
F$DTDR:	BLOCK 1			;uCR Data trans done reply (252-4) came in.
F$STAR:	BLOCK 1			;uC  Flag top level is at left margin TYI
F$TCLS:	BLOCK 1			;u   Close foreign connection if non-0
F$VBOS:	BLOCK 1			;uCR -1 => VERBOSE typeout;  0 => brief

CGCOUNT:BLOCK 1			;u   -1 if no Control-G, counts upward

$FILST:	BLOCK 200		; CR  File status from STAT 213 reply
EFILST==.-1			;     Global for TELNET receiver to top fork

$REPLM:	BLOCK 1			; CD  Local data trans reply message address

	SUBTTL Network Information

HOSTNN:	BLOCK 1			;u Pointer to host number table
HOSTN:	BLOCK 1			;u Ptr to table of
				;  <Host #s and bits,,Ptr to ASCIZ>
HSTNAM:	BLOCK 1			;u ASCIZ pointed to from HOSTN table
; Tables above are in the FREE area

HOSTNP:	BLOCK 1			;  -# host names,,0 (from GTHST)
LHOSTN:	BLOCK 1			;  Local host # (32-bit Internet fmt)
LHSTYP:	BLOCK 1			;u Local host system type (in HS%STY field)
LHSTNM:	BLOCK 20		;  Local host name in ASCIZ
;NETLSK:BLOCK 1			;  Local Socket
MYDATS:	BLOCK 1			;s CVSKT of my data connection

FHSTN:	BLOCK 1			;  Foreign host # (32-bit Internet fmt)
FHSTYP:	BLOCK 1			;u Foreign host system type (in HS%STY field)
FTNXX:	BLOCK 1			;u Foreign host TENEX/-1, TOPS20/1, other/0
HOSTX:	BLOCK 1			;u Index into HOSTN for that host
FHSTNM:	BLOCK 10		;s Foreign host name in ASCIZ
FORNS:	BLOCK 1			;s Even numbered foreign NVT socket

	SUBTTL	Data Transfer Parameter Blocks

; Define transfer parameter blocks.  The User has three copies:  first
; is what has most recently been specified by the user,  second is the
; values to be used for the next data transfer (either user values
; or values appropriate for an internal operation (e.g. getting a
; directory listing),  third is the values most recently sent to the
; server (eliminates unnecessary commands to the server which
; remembers the parameters which are in effect.  The Server has a
; single copy, but defines dummy second and third copies on top of
; the first (allows code to be shared between User & Server programs).


; Note: User requires that $HOST be immediately followed by $SOCK
; (PORT command processing).


DEFINE XFRPAR (L,N<HOST,SOCK,MODE,STRU,TYPE,BYTE,FORM>)<ZZ==.
IRP N,<$'N'L=ZZ
	ZZ==ZZ+1> ; End of IRP N
> ; End of DEFINE XFRPAR


PARAMS:	XFRPAR			;  The data transmission parameters
EPARAMS==ZZ-1			;  End of first copy
NPARS==ZZ-PARAMS		;  Number of parameters in block

PARAM2:	XFRPAR 2		;  Copy during actual transfer
EPAR2==ZZ-1

PARAM3:	XFRPAR 3		;  Last ones sent out
;EPAR3==ZZ-1

	LOC ZZ			;  One copy occupies space


$LTYPE:	BLOCK 1			;  Local packing
$LBYTE:	BLOCK 1			;  Local byte size
$FILLB:	BLOCK 1			;  Local filler byte



IBITCT:	BLOCK 1			;  Bit count for logging: RETR/STOR/APPE
TSBITS:	BLOCK 1			;  Bits sent by RETR (cumulative, never used)

NBYTES:	BLOCK 1			;  Bytes moved by last file transfer command
PAGENO:	BLOCK 1			;  Page # to map in DSK file (global for ^T)
TYXSCT:	BLOCK 1			;  Sequence number for paged mode

	SUBTTL Paged Mode Header

	; Do NOT separate the next few. They are the "STRU P" header
TYXHED:	BLOCK 0			;  Tag the header area
TYXNPW:	BLOCK 1			;  Header length (4 or 5)
PAGNO:	BLOCK 1			;  Page number in disk file
TYXNDW:	BLOCK 1			;  Number of data words goes here
RECTYP:	BLOCK 1			;  Page type
	PGT$LP==:0		;  Last page
	PGT$SP==:1		;  Simple data page
	PGT$DP==:2		;  Descriptor page
	PGT$AP==:3		;  Access controlled page
ACCESS:	BLOCK 1 ;(OPTIONAL)	;  RPACS arg for disk file
TYXHDN==.-TYXHED		;  Length of this header
; End of unseparable stuff

PSTOP==.			;  Following are constants, not variables
	LOC LSTOP		;  So back to low segement
PGLEN:	EXP 4,4,4,5		;  Header lengths for PGT$LP, $SP, $DP, $AP
LTYXMN==4			;  Minimum header length
LSTOP==.
	LOC PSTOP		;  Back to process-private area

NTXHDR==40			;u Length to allow on reading net
TYXHDR:	BLOCK NTXHDR		;u Make longer in case it grows

	SUBTTL	TELNET & Data Connection Control & Data Blocks

PRT227:	BLOCK 1			;u Port # from PORT reply (host in SOC255)

;CS129C Delete RCON, SCON et. al.

JFNTXS:	BLOCK 60		;  Text string from JFNS (used by simulation)
EJFNTX==.-1

GSTOP==.

	SUBTTL	Process-Private Variable Storage

	LOC 300000
PSBAS:	BLOCK 1

IFL PSBAS-GSTOP,<
	PRINTX ? Global space overlaps process space
	PRINTX ? PSBAS=\PSBAS  GSTOP=\GSTOP
	END
	>

NTIIA:	BLOCK 1			;u Save AC A here in NTIINT

RETPC1:	BLOCK 1			;  Return PC's for PSI system
PI1AC:	BLOCK 20		;  Storage for Lev 1 AC's
L1PDL:	BLOCK PDLL		;  Another on Lev 1 PSI

RETPC2:	BLOCK 1
PI2AC:	BLOCK 20		;  Storage for Lev 2 AC's
L2PDL:	BLOCK PDLL		;  And another on Lev 2

RETPC3:	BLOCK 1			;  ..
PI3AC:	BLOCK 20
PI3PDL:
L3PDL:	BLOCK PDLL

PDL:	BLOCK PDLL		;  Stack for a fork

; Top fork

IRFMOD:	BLOCK 1			;u What RFMOD got after RESET at go
ICOCB:	BLOCK 1			;u Initial FCOC
ICOCC:	BLOCK 1
FCOCB:	BLOCK 1			;u Initial FCOC, adjusted
FCOCC:	BLOCK 1

RESTRT:	BLOCK 1			;s Flag that we've run before

CPUTIM:	BLOCK 1			;u Timing cells
DAYTIM:	BLOCK 1			;u ..
IFRKTM:	BLOCK 1			;s Time meter for logging
TMOCNT:	BLOCK 1			;CS129  # of timeouts before logging-out
TMOINI==5			;CS129 initially, 5 minutes
TMLINI==^D15			;CS129 but 15 minutes when logged-in
IOXFLG:	BLOCK 1			;s Flag set by IO err PSI
CTCFLG:	BLOCK 1			;s Flag set by ^C PSI
LGOCNT:	BLOCK 1			;s Counter to force logout on time.

DFORKH:	BLOCK 1			;u Fork handle of data copier
RFORKH:	BLOCK 1			;u Fork handle of TELNET receiver
SFORKH:	BLOCK 1			;u Fork handle of TELNET sender
;THISFK:BLOCK 1			;u This fork's handle
TFORKX:	BLOCK 1			;s Fork handle of timing fork

IFN IPCLOG,<
IPCDAT:	BLOCK 100		;s Data area for msgs to/from IPCF
PIDARG:	BLOCK 10		;s Arg block for IPCF calls
CTLPID:	BLOCK 1			;s PID of FTSCTL
MYPID:	BLOCK 1			;s PID of FTPSRV
>

	SUBTTL Command Parsing

PRVKWD:	BLOCK 2			;s Previous keywrd, for sequence-
				;  dependant commands RNTO, PASS
KEYWRD:	BLOCK 2			;s The command verb
ARGWRD:	BLOCK 2			;s The arg for some commands
CARG1:	BLOCK 1			;s First argument to command
CARG2:	BLOCK 1			;s Second argument to command

$ACCES:	BLOCK 3			;s Argument block for ACCES JSYS

USRFCT:	BLOCK 1			;s Bad user names counter
$USER:	BLOCK 11		;s User name text string

PASFCT:	BLOCK 1			;s Password failure counter
$PASS:	BLOCK 11		;s Password text string

$ACCT:	BLOCK 12		;s Account word or string

$CWD:	BLOCK 1		; 0	;s Dir Num of CWD command

TEMSTR:	BLOCK 50		;#5 MORE RANDOM STRING SPACE
STRTMP:	BLOCK 100		;  A random string space
ESTRTM==.-1

ERRSTR:	BLOCK 30		;s Error string
LPTSTR:	BLOCK 30		;s Arg of XLPTF command
RCDSTR:	BLOCK 20		;s Space to build up a dir name
USERST:	BLOCK 20		;s Name string of directory from CWD



WORDXP:	BLOCK 1			;u Argument to GETWRD. -N,,Table of ASCIZ
RECX:	BLOCK 1			;u Index when found by RECOG, or -1 if none

BREAKC:	BLOCK 1			;u Character after word
LASTCC:	BLOCK 1			;u Last char read by GCH.

WORDBP:	BLOCK 1			;u Pointer into word string storage
WORDBF:	BLOCK 40		;u Word storage
EWORDB==.-1

GCHSAV:	BLOCK 1			;u Saved char (ESC) to read at GCH, or 0

TSINIX:	BLOCK 1			;u Initial count for TSIN routine
WRDBPS:	BLOCK 1			;  Beginning of current word/string
CMDIC:	BLOCK 1			;u Input line count, >=0
CMDIP:	BLOCK 1			;u Input line pointer, POINT 7,LINBF
CMDIS:	BLOCK 1			;u Input line space, free <= 5*NLINBF
RDTTYC:	BLOCK 1			;u Control-R text address for RDTTY


SBP:	BLOCK 1			;s Byte pointer as command is scanned
CMDIB:	BLOCK LCMDIB		;  The TELNET line collected from net


REPLYP:	BLOCK 1			;s Pointer to reply being built
REPLYM:	BLOCK LREPLY		;s And answer being built for reply

USERBF:	BLOCK 20		;u User name
EUSRBF==.-1

PASSBF:	BLOCK 20		;u Password
EPASBF==.-1

ACCTBF:	BLOCK 20		;u Account
EACTBF==.-1

PREFIX:	BLOCK 1			;u Flag there is a prefix
SUFFIX:	BLOCK 1			;u Flag there is a suffix
PREFXB:	BLOCK 40		;u String storage for prefix and suffix
SUFFXB:	BLOCK 40

FRNPTH:	BLOCK 40		;u Foreign pathname
EFRNPT==.-1

FRNPT2:	BLOCK 40		;u Second foreign path (RENAME)
EFRNP2==.-1

	SUBTTL	Variables Used by XGTJFN to Parse Filespecs

; PARSE block
JBLOCK:				;s  Arg block for long GJTFN
GTJBLK:	BLOCK 20;1+.GJJFN+.GJRTY-.GJJFN ; Long GTJFN control block
EJBLOK==.-1
GTJBKE==.-1			;  Last word in block

FJFNS:	BLOCK 1			;  Fields specified flag word

LGJDEV==10
GTJDEV:	BLOCK LGJDEV		;  Device string
LGJDIR==20
GTJDIR:	BLOCK LGJDIR		;  Directory string
LGJNAM==10
GTJNAM:	BLOCK LGJNAM		;  Name string
GTJEXT:	BLOCK 10		;  Type string
GTJGEN:	BLOCK 1			;  Pointer to position of generation #
LGJPRO==10
GTJPRO:	BLOCK LGJPRO		;  Protection string
LGJACT==10
GTJACT:	BLOCK LGJACT		;  Account string

FILTMP:	BLOCK 1			;  -1 if ;T, 0 otherwise
FILSIZ:	BLOCK 1			;  File size
FILTCR:	BLOCK 1			;  Time file created
FILTWR:	BLOCK 1			;  Time file last written
FILTRD:	BLOCK 1			;  Time file last referenced
LFLUCR==10
FILUCR:	BLOCK LFLUCR		;  User name of creator
LFLUWR==10
FILUWR:	BLOCK LFLUWR		;  User name of last writer
GTJEND:	BLOCK 1			;  (Unused)
; End of PARSE block


GTJLCL:	BLOCK GTJEND+1-GTJBLK	;  PARSE block for local filespec


GTJSTR:	BLOCK 60		;  Space to build a filename string

; .GE. MAX(TENEX=25,101B=30,TOPS-20=.FBLEN)
FDBBLK:	BLOCK 50		;  Area to hold an FDB
FDBTM1:	BLOCK 10		;  Times
FDBTM2:	BLOCK 10
FDBTM3:	BLOCK 10
FDBUS0:	BLOCK 10		;  User names
FDBUS1:	BLOCK 10
FDBBKE==.-1			;  End for BLT to clear

STATMP:	BLOCK 2			;u Values returned by STAT JSYS
RETVER: Z			;#4 FLAG WORD FOR VERSION NUMBER

	SUBTTL	TELNET receiver fork

RCVLIN:	BLOCK 100		;u Space for the incoming TELNET line
ERCVLN==.-1			;u End of same
RCVLST:	BLOCK 101		;u Last TELNET line received
TNRSSS:	BLOCK 1			;u TELNET state
REPCOD:	BLOCK 1			;u Reply code as a number
REPIDX:	BLOCK 1			;u And index into reply tables

	LOC <<<.+777>/1000>*1000>

TPAG:	BLOCK 2000		;  Catches GTJFN echos (-FTP-ECHO.TMP)
WINDOW:	BLOCK 2000		;  File window.
WINDW2:	BLOCK 2000		;  Pages for expanding 32/36 images

IFN .&777,<PRINTX Storage not on page boundaries!!!>

PSTOP==.

IFL HSBAS-PSTOP,<
	PRINTX ? Process storage overlaps code
	PRINTX ? HSBAS=\HSBAS  PSTOP=\PSTOP
	END
	>

;CS129C *** Begin ***

	LOC 500000		;Start here for buffers
BSBAS:	BLOCK 0			;Define start of buffer space

				; TCP File block including CDB + Buffer headers
DATCON: BLOCK T.SIZE		;  Data connection file block including CDB
	BLOCK 2*T.NDBB*.TCPBS	;  Data connection buffer headers
DATBUF:	BLOCK <2*T.BFSB*T.NDBB> ;  Data connection data buffers

BSTOP==.

;;Gives "E" Error
;;IFL BSBAS-HSTOP,<
;;	PRINTX ? Code overlaps buffers
;;	PRINTX ? BSBAS=\BSBAS  HSTOP=\HSTOP
;;	END
;;	>

;CS129C *** End ***

	'END'			;  Convince loader to put symbols above here

	LOC LSTOP
	LIT		; Shouldn't be any
LSTOP==.

IFL GSBAS-LSTOP,<
	PRINTX ? Globals overlap lowseg
	PRINTX ? GSBAS=\GSBAS  LSTOP=\LSTOP
	>

	END GO
 