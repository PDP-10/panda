
title maichk

;This program gets loaded into a TECO buffer and executed
;to check for the existence of new mail.
;We don't know where in core we will be,
;but the address of the start of our code (S) will be in AC 5.

;Use the SHRINK file on MAICHK.EXE to create a MAICHK.CODE file
;containing a core image which TECO can load.

	ascii	/Start/		; for SHRINK
S:				; Everything offset from S to make this code
				; position-independent
START:	SKIP			; convention for emacs code
	JRST	REALSTART-s(5)	; skip over scratch area
result:	block	16

realstart:
	MOVEM	3,callarg-s(5)	; ac3 contains arg.  nonzero means explicit
	movei	1,result-s(5)	; point at username caller passed us
	hrli	1,440700
	move	2,1
	ildb	3,1		; is it null?
	movem	3,explicitdir-s(5)	; note it
	jumpn	3,gotit-s(5)	; no, use it as the dir
	SKIPE	INIT-s(5)	; Have we created the user's dirnam?
	 jrst	GOTSTRING-s(5)	; yup, skip initialization
	GJINF			; info: login dir is in ac1
	move	2,1
	hrroi	1,Username-s(5)	; point to block to keep dir
	dirst			; fill in directory string: ptr in ac1, dir in
				; ac2; updates ptr in 1
	 jrst	fail-s(5)
	setom	init-s(5)	; done with initialization
gotstring:
	hrroi	2,username-s(5)	; point at default username

gotit:	movem	2,jfndir-s(5)	; put ptr to dir in jfnblk
	hrroi	2,msgtxt-s(5)	; ptr to "mail.txt.0"
	movei	1,jfnblk-s(5)	; point at block
	gtjfn			; get mail jfn in ac1
	 jrst	fail-s(5)
	movei	2,fdblk-s(5)	; address of argument block
	movei	3,4		; and its length
	rftad			; read in the dates on jfn in 1
	hrli	1,1		; flag to get last writer of file
	move	2,pauth-s(5)	; and a place to store string
	gfust			; and get the string
	setz	3,
	idpb	3,2		; and add a null at the end of the name
	rljfn			; get rid of jfn
	 jfcl
	move	2,written-s(5)
	camg	2,read-s(5)	; write > read ?
	 jrst	nope-s(5)	; nope, no new mail
	skipe	explicitdir-s(5) ; did caller default dir?
	 jrst	newmail-s(5)	; no, we don't have dates stored for it
	skiple	callarg-s(5)	; explicit arg passed?
	 jrst	notemail-s(5)	; yes, so always say something
	camg	2,lastmail-s(5)	; more recent than last we checked?
	 jrst	nope-s(5)	; nope, don't bother repeating ourselves
notemail:
	movem	2,lastmail-s(5)	; update last noticed date
newmail:
	move	1,prslt-s(5)	; get the pointer to the result string into 1
	move	2,pstr1-s(5)	; "mail waiting"
	pushj	17,copystr-s(5)
	move	2,written-s(5)	; date written
	hrlzi	3,400301	; format: time only, no seconds, do am/pm
	odtim
	move	2,pstr2-s(5)	; " from "
	pushj	17,copystr-s(5)
	move	2,pauth-s(5)	; "author"
	pushj	17,copystr-s(5)
	move	2,pstr3-s(5)	; terminating str
	pushj	17,copystr-s(5)
	skipa
nope:	setzm	result-s(5)	; blank result to show failure
	popj	17,

fail:	move	1,prslt-s(5)	; pointer to result area
	move	2,fail1-s(5)	; .fhslf,,most recent error
	move	3,fail2-s(5)	; -ve of max length to transfer,,0
	erstr			; and get the error string
	 jfcl
	 jfcl
	move	2,pstr4-s(5)	; and add a crlf
	pushj	17,copystr-s(5)
	popj	17,


copystr:			; come here to copy str from ac2 to ac1.
				; smashes ac3
lp:	ildb	3,2
	skipg	3
	 popj	17,		; return when we hit null byte
	idpb	3,1
	jrst	lp-s(5)


JFNBLK:				; Table for long GTJFN
	100000,,0		; flags = old file ,, vers = 0
	377777,,377777		; jfn pair for input,,output
	440700,,devstr-s(5)	; pointer to device string (assume PS:)
jfndir:	0			; dir
	0			; name.  Leave this null and pass in 2
	0			; extension
	0			; protection
	0			; acct
	0			; silliness

devstr:	asciz	/PS:/
fdblk:
	block 2
read:	0
written: 0
lastmail: 0
init:	0
explicitdir: 0			; true if caller passed a dirname
callarg: 0			; true if caller gave explicit arg
author:	block 8			; place to store last writer
pauth:	440700,,author-s(5)	; point to last writer string
prslt:	440700,,result-s(5)	; pointer to the result buffer
username: block 8		; store login username here
msgtxt: asciz /MAIL.txt.0/
fail1:	400000,,-1		; args for erstr jsys
fail2:	-75.,,0			; as above
pstr1:	440700,,str1-s(5)
pstr2:	440700,,str2-s(5)
pstr3:	440700,,str3-s(5)
pstr4:	440700,,str4-s(5)
str1:	asciz	/[Mail waiting - /
str2:	asciz	/ from /
str3:	asciz	/]
/
str4:	asciz	/
/
	0
	asciz	/Stop/

TEST:	hrroi	1,[asciz /User: /]
	psout
	hrroi	1,result
	movei	2,40		; max input length
	setz	3,		; no fanciness
	RDTTY			; read string
	setz	3,
	dpb	3,1		; smash terminator with null
	movei	3,1		; always pass arg
	MOVEI	5,start
	movei	17,stack
	pushj	17,start
	skipn	result
	 haltf
	hrroi	1,result
	psout
	haltf

stack:	block 4

	end 	test
