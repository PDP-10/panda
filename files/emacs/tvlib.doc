		    Intro to EMACS for TVEDIT users
		    -------------------------------

EMACS is a TECO-based display editor from MIT.	With a few exceptions,
it does everything that TVEDIT can do, and more.  This document is
intended as a guide for users accustomed to TVEDIT who wish to learn
EMACS, and hence describes the editor in terms of TVEDIT instead of as
an independent editor.	To the extent that E (the SAIL editor)
resembles TVEDIT, this may be of assistance to users of E as well.


Advantages of EMACS: a quick rundown.
------------------------------------

EMACS permits handling of numerous files at once.  Also permits you to
view two files at once on the same screen for comparison purposes, or to
move text between them.  EMACS has commands for justifying and filling
text, and automatically breaking long lines on typein ("autofill" mode).

EMACS has good self-documentation.  You can find out what any given
command does while in EMACS, or ask for a command that does a certain
thing given a keyword.

It is possible to put any EMACS function on any character.  It is this
ability that permits the TV library described below, and you can further
change even these settings to suit your own preferences.  If you know
TECO (which, unfortunately, tends to be incomprehensible to all but MIT
hackers), you can extend the command set almost arbitrarily.

EMACS processes input and screen updating asynchronously, hence often is
much better about not writing more than it needs to; TVEDIT makes you
wait for display to be completed before obeying the next command.  E.g.
if you type two window commands in quick succession in TV, it will
completely display the first before moving on to the second.  In EMACS,
as soon as it has processed the second command it knows you want to see
a different window, and it will stop writing the first one and go right
on to the second.

EMACS has commands for string substitution.


Disadvantages of EMACS, or things TVEDIT does better:
----------------------------------------------------

EMACS does not remember which file you edited last, or where you were
in the file (though you can continue after quitting out of emacs and
your file will still be there; this only applies to starting up EMACS
afresh).

EMACS does not view pages very specially.  Due to some fundamental
limitation, it can't tell you what page it is on, though it can find
pages (i.e. there is a "go to next page" command).  It does not maintain
a directory like TVEDIT does, so locating an arbitrary page in the file
may take longer (I have no data on this; emacs seems as fast as TV in
most operations).

While EMACS is smart about your typeahead, it often updates the screen
after changes less than perfectly optimally.  This is usually not a
problem, but can be annoying at times.

EMACS so far has no good commands for refreshing portions of the screen
if your display gets trashed by line noise or system messages.


Notation in this document
-------------------------

"Control" means the CTRL key, and is designated by a "c" or "^" in
front of the modified character.  "Meta" means the EDIT key, denoted
"m".  Some commands use both modifiers: "control-meta" denoted by "cm".
The Altmode (ESC) character is designated "$" (no true dollar signs
appear in this document).  For further confusion, I will sometimes
follow the TV convention of enclosing a sequence of characters inside
brackets to denote that all of them are typed with the EDIT key down,
e.g. [20K] = m2m0mK.

Note that while meta is a true modifier bit and can be applied to ANY
character, "control" on tenex is ascii control, and hence only applies
to letters (also @, [, \, and ]).  E.g. ^4 is exactly the same char as
^T.  Hence, it is not always possible to type a control or control-meta
char in one stroke.  This is handled by having "prefix" chars to
designate control and control-meta for those commands you couldn't
otherwise type.  Prefix "control" is ^^ (control-uparrow) and
"control-meta" is m$ (edit-escape).  Thus, you can type ^C as ^^C, or
"cm<" as "m$<".  There is no need for a meta prefix on datamedias, since
you can type any character with the meta (edit) key down, but for
completeness, and compatibility with TV, $ is defined as meta-prefix.
Thus, $$ (two characters) is also control-meta prefix.	Generally you
can type control-meta-letter in one keystroke by holding down both ctrl
and edit; it is only the funny chars that need the m$ prefix.


EMACS commands
--------------

EMACS commands come in three varieties: single character, double
character, and named commands.	TVEDIT has the first of these, and a
limited form of the second (the M, D, etc commands which take a RET, DEL
or SPACE as second char), but none of the third.

Single-char commands are typed with control, meta, or both.  The m$
prefix for control-meta was selected to be natural for TV users:
typically cm commands are related to the corresponding m command by
being "larger" in some sense, and m$ in TV means "infinity" as a
modifier.  So "m)" advances one word, while "cm)" advances to the end of
the line.

The second type of command is the ^X command: ^X followed by a second
char, which is generally either a letter or a control char.  These exist
because there are too many commands to put on the single chars, yet
these commands are useful enough to want to be easily typed.  You may
find them a little difficult to remember at first.

The third type of command is the named, or Extend, command, which is
typed by mX followed by the name of the command.  When you type "mX" you
will get the prompt "Extended Command: "  You need only type as much of the
command as is needed to uniquely identify it.  You can type escape to
get command completion, and ? to get alternatives (the command set is
such that most commands complete after a few characters, or at least
partially complete).  Backspace with DEL; ^U will delete the command
typed so far (^U is tops10/20's version of ^Q line delete).  Some extend
commands take one or more string arguments; terminate the command name
with an escape followed by the string args, separated with escapes.  In
either case, the whole command is terminated by cr.

I will generally refer to an extended command as "mX <command>".  Note
that although the description here gives the whole name of the command,
you can abbreviate most commands with a few letters.

Most commands of any flavor can take a repeat argument, which is an
integer typed by holding down meta (edit) and typing the digits (or
minus sign) before the command.  A special arg is ^U, which means "4
times" (roughly the same as m4), but easier to type before control
commands (since you don't have to switch shift keys).  Two ^U's means
"16 times".  Some commands only care about the presence or absence of
ANY argument, and some even test for presence of ^U.  Non-commands may
also take a repeat arg; e.g.  [20]x will get you 20 x's.

Universal abort: ^G.  Much like ^L in TV.  Interrupts whatever
you are doing and returns to toplevel EMACS.  There is no shutup char
analogous to ^O; it would have less use anyway: since EMACS listens to
your typeahead, there is rarely a need to make EMACS shut up.

This document assumes you have loaded the TV library (TVLIB).  You can
do this by issuing mX Load Library$TVLIB, or more easily with
an init file (see below).

Starting and Stopping
---------------------

Start EMACS just by calling it in the normal fashion:
@EMACS

You need to tell EMACS what file you want to edit.  EMACS calls this
"visiting" a file.  The file and buffer manipulation commands are almost
all ^X commands, as follows:

^X^V -- Visit a file.  Assumes you want to write the file if it changes.
^X^R -- Read a file, i.e. edit readonly.  Assumes you do not want to
	write it, even if you change it.  "(RO)" appears in the mode
	line to inform you of this condition.

The practical difference between the two is what EMACS does when you
decide to start editing a new file.  If the previous file was edited
with ^X^E and you had made changes to it, EMACS will offer to save it
for you.  With ^X^R it will just ignore your changes.  In both cases,
your file is only opened for read; if changes are made, THEN a file will
be written (always a new version).  One other difference if you have
Auto Save Default set (below): ^X^R will keep autosave off, so that the
file will not be automatically written by an auto save either.

^X^S -- Save file.  Type this anytime to save the changes you have made.
	If you haven't changed anything, does nothing.	You can have
	emacs do this automatically every so often by setting autosave
	mode (more on that later)

^X^Z -- Exits EMACS.  If you are in autosave mode, does a save
	(see more on that below); otherwise, this is merely a graceful
	^C, and EVEN IF YOU HAVE CHANGED YOUR FILE, IT IS NOT SAVED THIS
	WAY (you can tell when your file is saved, since EMACS always
	prints the filename when it happens).  However, give it an
	argument: ^U^X^Z, and it will save your file if you have made
	changes (roughly the same as doing ^X^S ^X^Z).

cmF -- (or [$F]) same as ^X^Z, for you tv users.

^X^W -- Write File.  Like ^X^S, except asks you for a new file to write
	the buffer to.  This is like giving an argument to SOS's exit
	command.

What you see on the screen
--------------------------

The first 20 lines of the screen contain your text, or the "window".
The remaining 4 lines are the "echo" or "prompt" area.	The first line
of the echo area, termed the "mode line" tells you the state of emacs;
normally it looks like

EMACS  (One or more modes)  Buffername:   <filename>	--nn%--

This tells you what mode EMACS is in (it has several, some described
below), what buffer you are editing (you can have more than one), the
name of the file in the buffer, and where you are in the file as a
percentage of the way thru it (since EMACS doesn't count pages, only
characters).  If the mode line does not begin "EMACS", it means your
input is being treated as something other than EMACS commands applied to
your text (particular cases are described later).  The remaining lines
in the echo area are used to echo Extend commands, print out some
information, and prompt for input for certain commands.  Also, if you
pause in the middle of a command, emacs will sometimes echo what you
have typed thus far, in case you're confused about where you are.

When EMACS has to type out something longer than a line or two, e.g. in
response to a help query, it generally types in the main window,
obscuring whatever text was there.  That typeout stays there until you
type another character; if you type a space, it will restore the text to
view and do nothing else, while any other char will also be obeyed as a
command.  Sometimes the typeout will be more than a screenfull, in which
case the mode line says "--MORE--".  If you type a space, it will
continue with the next screenfull; if you type a DEL it will flush the
typeout.  Any other char will also flush the typeout, but will also be
obeyed as a command.

The command cmN blanks the screen and redraws it.  Unlike in TVEDIT,
however, it may choose a new window to redraw, depending on where the
cursor is.  Crock.  The command mN refreshes the line the cursor is on,
sort of -- it refuses to refresh the first character.  I'm investigating.
Entering text
-------------

EMACS behaves as though you are always in insert mode.	That is,
anything you type without the ctrl and meta keys will be taken as text
to be inserted in front of the cursor (in front of the char the cursor
is under).  DELETE will delete the char before the cursor (i.e. what
you'd expect it to do if you were typing in something to be inserted).
CR will insert a crlf, i.e. break the line.  Delete at the beginning of
a line will delete the preceding crlf, joining the present line to the
previous.  This will probably be confusing at first; in fact, I find it
the single most confusing thing in switching back and forth between
EMACS and TV.  I have specially undefined mI so that if you type it out
of habit nothing disastrous happens (emacs will beep at you).

EMACS has an "overwrite" mode, in which normal chars overwrite rather
than inserting, described somewhere below.  It is not tremendously
useful, however, since there is no "insert" command to use in this mode.

You can enter control characters in the file by quoting them with ^Q;
e.g. ^Q^Y inserts a ^Y at the current cursor position.	^Q followed by a
non-control character controlifies it, e.g. ^QY would also insert a ^Y.
This is how you have to enter control characters that you couldn't
otherwise type, e.g. ^C or ^_.  DELETE ('177) is not really a control
character, but it is represented as ^? (? = '77), and can be entered as
either ^Q<del> or ^Q?.  Anyway, this is all much nicer than TV's awkward
edit-' hack for typing control chars.  Also note that, like most other
things, ^Q can take an argument to insert n copies of a character.

Control chars appear on the screen as two chars: ^x, but you can tell
it's just one character if you space over it.  This makes it more
obvious what chars are there (making m= (below) of relatively little
use); however, this may be awkward if precise spacing is important to
you.  Oh well, can't have it both ways.  Escape appears as $.

There is one major exception to the "insert mode" behavior: if you end a
line with a CR, and the next line is blank, EMACS does not create
another blank line.  I.e. CR only creates a blank line if it "needs" to.
The following commands for manipulating blank lines are very useful:

cO -- insert crlf at the position of the cursor, but leave the cursor
      alone.  With an argument, inserts that many blank lines; e.g. ^U^O
      inserts 4 blank lines, and is a convenient way to make space all
      at once for a new insertion.  You could, of course, just do crlfs
      one at a time to get the same effect, but then EMACS has to glitch
      the screen for each one, while with ^O it just eats up the blank
      lines you have created.  ^O is also very useful if you want to
      insert a lot of text in the middle of a line.  If you just type
      the text, the line grows and overflows the right margin quickly;
      if you type ^O first the line is broken and the insertion is much
      smoother.

cmO -- similar to cO, but the remainder of the line is shoved vertically
      down so that it is in the same horizontal position as before; i.e.
      inserts crlf plus enough tabs/spaces to maintain the position.

^X^O -- deletes blank lines.  If you do a large ^O and don't use up all
      the lines, a ^X^O will flush the remainder.

Commands for moving around in the file
--------------------------------------

These have been mostly redefined to be the same as TV's, in particular,
the meta commands on the keypad:

m^ -- move up one line		mLF -- move down
m< or mDEL -- move left one	m> or mSPACE -- move right one
m(  -- move left one word	m)  -- move right one word
m^L or cm( or cm< -- move to beginning of line
mTAB or	cm) or cm> -- move to end of line
mRETURN -- move to start of next line
cm^ -- move to top of screen	cm\ -- move to bottom of screen

[cmLF does not move to bottom of screen.  Sorry, folks.  You see, LF is
really ^J, and mLF is thus cmJ, which is exactly the same as cmLF, so it
can't tell them apart.	m-cm^ (i.e. [-$^]) will move to bottom of screen
also (the logical negation of cm^, though it takes 3 keystrokes).  Same
problem with cmRET, which is the same as mRET.]

Note that LF is NOT defined the same as mLF, i.e. you need the edit key
down for all of the above commands.  LF is defined as crlf followed by
tab, with tab defined according to whatever the current mode thinks it
should do.  You can change LF to be mLF if you prefer, in an init file.

m^L and mTAB are from E (AI lab's editor), and are convenient
single-stroke commands for cm( and cm).  The word and char movement
commands do not confine themselves to the current line (in fact, only
commands which explicitly mention the start or end of line do).  Also,
no movement command will put the cursor where there is no text (unlike
in TV); if you try to move to where there is no text, it will move to
the nearest thing it can.

You may find that EMACS has a different concept of "word" than TV;
specifically, it notices punctuation, such as period, comma, and hyphen,
as being not part of the word, and the word moving commands do not
always go quite where you expect them to at first.  This turns out to be
a win sometimes and an annoyance at others.  It is perfectly permissible
to have bare CR's or LF's in a file; they will be displayed as ^M and
^J, rather than as the usual invisible end-of-line chars.

Bigger moves
------------

mW -- this is the general windowing command.  W windows forward; -W
	windows backward; any other argument scrolls that many lines,
	forward or backward (not limited by size of window, as in TV).
mV -- window backward, i.e. -W; with argument scrolls that many lines
	back.

Successive windows overlap by 2 lines, as compared to 5 or so in TV.  If
you don't like that, you can window by smaller amounts.  You can do any
amount of windowing with mW with a suitable arg, but I added the
following special cases for 3 of the keys on the left keypad, all typed
WITHOUT the edit key:

^L -- single window forward (for you E users).
^\ -- (unlabeled key below ^L on the left) half window backward.
^] -- (middle unlabeled key on the left) half window forward.


m[ -- backward paragraph	cA -- backward sentence
m] -- forward paragraph		cE -- forward sentence

EMACS defines "paragraph" and "sentence" according to what mode you're
in.  In text mode, a paragraph ends on a blank line, or a line which is
indented, or one which begins with a period (hence it at least knows
about the existence of pub commands).  A sentence ends with a period (or
? or !) which is followed by crlf or two spaces; also a blank line.

mP or mG -- go to next page; -P goes to previous pagemark, i.e. to start
	of current page, or previous page if already at the start of a
	page; nP for positive n goes to the nth page (absolute) in the
	file; -nP goes backward n pages.  A pagemark is simply a crlf
	followed by a formfeed (^L), and is displayed in the file as
	such.  For a different view of pages, see description of
	PAGE library below.
m{ -- move to beginning of file.
m} -- move to end of file.


Skip/Zap
--------

mS -- Skip to target char: reads the next char you type and skips to it.
	Case and edit key are ignored.
mB -- Backward skip, i.e. -S.
mZ -- Zap to char: kills text up to the target char.
mA -- Repeats the last S,B,Z command, regardless of any intervening
	commands.

These are all roughly the same as in TV (except mB is new).  However,
unlike in TV, the skip/zap commands are not confined to the current
line, and the interpretation of mA ("again") applies only to the
skip/zap commands.  This is often convenient.  You can skip to a char,
do something locally, then type mA to skip to the next occurrence.  As
with other kill commands, mZ is undoable in case you went too far.

Searching
---------

cS -- Search forward for a target string.
cR -- Reverse search for a target string.

EMACS standard searching commands have the novel behavior that they
search while you are typing the search string (and hence are called
"incremental search").	You need only type as many chars of the string
as are needed to get you where you want to go.	Once you have gotten to
one ocurrence of the target, type cS to skip to the next occurrence;
and/or type more characters of the target to narrow the search more.  If
you type DEL to erase a char of the search string the search backs up to
where it had gotten before you typed the deleted char.	Type ESC to
terminate the search.  If you type any other command, the search will
also terminate, but the command is executed as well.  A common error is
typing text after you get to the target, thinking that your typein is
being inserted; rather, it continues the search!

During the search, the mode line changes to "I-Search" to tell you that
your typein is being searched for, not being entered as text.  If the
search fails, that changes to "Failing I-Search", and EMACS will beep.

cR is like cS, but searches backward.  Typing cR or cS in the middle of
the other's search command will reverse the search.


Overwrite Mode
--------------

In overwrite mode, ordinary chars replace existing text, rather than
inserting themselves.  You can enter and leave overwrite mode with ^XI.
While you are in overwrite mode, the mode line says "Ovwrt" to remind
you.  Regular commands still work in overwrite mode; this includes
RETURN, which is a command that inserts a crlf.  In effect, you could
make overwrite be your default mode, and do a ^XI to get into insert mode
when you want to insert; however, that means you still need an explicit
^XI command to return to overwrite mode, and that may be more of a pain
than it's worth.  Overwrite mode is probably most useful for operations
like drawing pictures; once you get used to insert being the default
mode, I doubt you'll want to switch back and forth much.


Killing text
------------

mK -- kill current character	 cmK or cK -- kill to end of line
cD or ^W -- kill previous word	 mD -- kill next word
cmD -- kill to end of sentence	 cmA -- kill back to start of sentence

cmK on an empty line deletes the line.	mK or cK at the end of a line
joins to the next line.  If you give an arg to cmK, it will delete that
many lines; e.g. [10cK] deletes 10 lines.  Neither command deletes
anything before the cursor, so if you issue that [10cK] in the middle of
a line, the first part of the line will still be there, joined to the
first non-deleted line.

cD and mD kill to word boundaries from the current cursor position.  So
cD really means "kill backwards to the start of a word", and mD means
"kill forward to the end of a word".  Either command can take a repeat
arg.  There is no command to delete an entire word while you are
sitting in the middle of it.

cmD and cmA are both useful.  cmA is provided for the common case
where you start a sentence and then change your mind and want to start
over.


Unkilling
---------

cY -- restore the last region killed.
mY -- replace region with the PREVIOUS region killed.
cmY -- append next kill.

Whenever you give a command which kills text (other than single char
deletions, such as with mK and DEL), the killed text is saved in the
"kill ring".  The last n kills (I think n=8) are saved.  Successive
kills with no intervening commands are all saved as one killed region.
In addition, if you type cmY before a kill command, the killed text will
be appended to the previously killed region, rather than creating a new
entry on the kill ring [note: see more below under "region"].

The cY command (Yank) pulls in the latest kill and restores is at the
current cursor position.  If it is not the one you wanted, you can then
type mY to get the previous kill instead.  Successive mY's will select
earlier members on the kill ring.  mY is only meaningful after a cY.
Alternatively, if you know which block of killed text you want, you
can give an arg to cY, e.g. m3cY will get you the 3rd previous killed
block of text.

Note that unlike in TVEDIT, where killed text is stored independently as
lines or words, in EMACS there is just the killed "region", which can be
lines, words, or some combination.  The region includes the line
boundaries.

Killing and unkilling is the standard way of moving text around.  Not
very elegant, but no worse than TV.

More on the Region
------------------

The REGION is defined as the area of text between the cursor (sometimes
called "point") and the "mark".  Actually, there is a stack of marks,
and you can push and pop them at will.	There exist several commands for
setting the mark, restoring it, and manipulating the region.  Note that
the region can be either before or after the cursor, depending on where
mark is.

^@ or NUL -- set (push) the mark where the cursor currently is.
^U^@ -- pop the mark into point, i.e. move the cursor to where the
	latest mark is, and discard the mark.
^X^X -- exchange point and mark.  This is a convenient way of seeing
	where the region currently is.

mM  -- mark the current paragraph, i.e. go to the beginning of the graph
	and set mark at the end.
cmM -- mark current sentence (must type this as [$M]).
^X^P -- mark current page.
^X{ -- set mark at beginning of file.
^X} -- set mark at end of file.

m,  -- kill the region.
m.  -- copy the region as though it had been killed.  Useful for copying
	a block of text within one file, or copying from one file to
	another.

Some common operations from this: [M,] kills the current paragraph;
[M.] copies it.  [m, and m. were not the original emacs choices (which
were awkwardly on cW and mW), and I would welcome better suggestions.
I chose m. to resemble TV's .D commands, and m, because it's next door
(also [M,] is easy to type).]

To select a region, type ^@ to set the mark, then move around to the end
of the region and issue the desired command.  To remember a place in the
file, type ^@, go elsewhere, and come back with ^U^@.  Note that if you
did something in between to push the mark you may have to type ^U^@ more
than once.

To move disjoint blocks of text, cmY is handy.	Just kill a region, go
to the next one and say cmY before killing it.	Repeat this until you
have assembled all the text you want, and then go deposit it in the
desired location with a single cY.  There is one thing to be careful of
with cmY, however: it notices the orientation of the region.  If you
kill forward, the new kill will be stuck on the end of the old kill; if
you kill backwards, it goes on the front.  Most major kills (line,
sentence, paragraph, page (using ^X^P m,)) are forward, and hence
accumulate the way you'd expect.  However, if you kill arbitrary regions
by marking the front of the region, going to the end and killing, the
region will be backward, and the killed block will be appended to the
front.  When you finally go to restore, you may thus find your text
jumbled.  I personally find this a misfeature.  Easiest solution: if you
kill by region, do a ^X^X (if you're at the end of region) before the kill.

cY sets the mark at the beginning and cursor at the end of the restored
region.  Use ^X^X or ^U^@ to go to the beginning of it, or [,] to kill
it again if you decided you didn't want it after all.

Commands for English Text
-------------------------

mL -- Lowercase current word ("current word" is same as for mD, so that
	if you are in the middle of a word, it only acts from there to
	the end of the word).
mU -- Uppercase current word.
mC -- Capitalize current word.
^X^L -- lowercase the entire region.
^X^U -- uppercase region.

mQ -- Justify-fill the current paragraph.

With no arg, just fills (joins and breaks lines so as to put as many
words on a line as the fill column allows).  With a positive argument,
actually performs justification, filling out to the margin.  With a
negative arg does a fill that also removes extra spaces, such as were
inserted by a justify.	Recall that "paragraph" is defined as something
delimited by blank or indented lines.  If you have a block of text which
is wholly or partially indented, you can use m_ (below) to unindent it
first.

Unfortunately, there is little control over margins and crown, etc., but
this is adequate for many small justifying tasks that you'd never want
to pub; mostly I use it to fill paragraphs that have gotten ragged from
editing.  The right margin (the variable Q$Fill Column$) is initially
set to 72 by TVLIB.  You can set it to another value with the command
^XF.  With a numeric arg, ^XF sets fill column to the arg; with no arg,
sets fill column to current cursor position.  Left margin is always
zero.  There is a special hack for changing that (see ^X. below), but it
is less than perfect.

cmQ -- Fill the region.  Arg as with mQ.  E.g. to justify fill a whole
	page, do ^X^P followed by cmQ.

cmS -- center (Scenter?) the current line.  Margin same as with mQ.

mT -- Transpose (switch) the words before and after the cursor.  With an
	arg, moves the first word over more than one.  Try it on the
	hyphen of a hyphenated word and see how smart it is!

m_ -- Horizontally shift the region to the right (sorry, wrong direction
	of arrow, but we don't have a right arrow) by the amount given
	by arg.  Arg may be negative. 

mX Replace String -- does string substitution.	The substitution occurs
	from the cursor position to the end of the file.  Give it old
	string, escape, new string:
		mX Replace String$old$new$
	If you give an argument to this command, only replaces
	occurrences of old string that are delimited by separators
	(non-letter/digit).  As with regular searches, the case of the
	target string is ignored; however, if you give old and new
	string in lowercase, Replace String will look at the case of
	the target, and substitute the appropriate version of the new
	string (lowercase, uppercase or capitalized).

	For fanciness, old string may contain special characters:
	^Q -- quote next character.
	^B -- matches any separator.
	^N -- ("not") -- matches anything except next char.
	^X -- matches any character.

mX Query Replace -- like Replace String, except pauses at each
	occurrence of the target and waits for you to type a character
	accepting or rejecting the substitution.  Space accepts, rubout
	rejects, and several other possibilities exist; type ? to find
	out what you can do.


Help Facility
-------------

EMACS provides extensive online help.  The command m? followed by any
character will tell you what that character does as a command.	The
character may be a prefix char, i.e. you can find out about ^X
commands and control-meta commands this way, too.  Probably most often
you will want to know "which character performs function x", rather than
"what function does character y perform", but occasionally the latter is
useful, if, say, you don't know the details of its operation, such as
what, if any, argument it expects.  For the former, read on.

The other help facilities are invoked by typing the "help" character,
which is ^_.  The next character you type determines what sort of help
you want.  The most useful options are:

A (Apropos) -- follow this with a keyword, and EMACS will list all the
    	commands which "contain" that keyword, with a brief description
    	of each and which, if any, character will invoke it.  E.g.
	^_ASentence will list all the sentence manipulation commands.

D (Describe) -- follow this with the name of an Extend command and it
	will describe it in more detail.  This is like m? for mX cmds.

L (List) -- displays the last 60 characters you typed.	Do this if
	something unexpected happened and you want to figure out how the
	hell you did it.

I (Info) -- runs the INFO program.  This is a program that peruses the
	EMACS documentation files.  Type ? if you've never used it
	before.  It's fairly simple: the documentation is in a massive
	tree structure, and you issue a small set of one-letter commands
	to move around in it.  This is how to find out more detail about
	any thing you can't get the other ways.  Beware of what it says
	particular characters do, though -- TVLIB redefines many of
	them.

Manipulating multiple files
---------------------------

EMACS lets you edit several files at once, and also permits you to
view two files (or the same file) on the same screen, for purposes
of comparison, or to move text back and forth.

Every file you edit resides in a BUFFER.  When you "edit a file" you
are really editing a buffer -- the file is read into the buffer, you
manipulate the buffer, and then write it back out to a file when done.
You can have more than one buffer, and each one has a name.  The one you
are currently editing appears in the mode line; initially you are
editing buffer Main.  The regular file-visiting commands merely change
the file you are viewing in the currently selected buffer; to switch
buffers, use the commands below.

^XB -- select Buffer.  Follow this with the name of the buffer.  If this
	is a new buffer, it will be empty; otherwise you will be
	wherever you last left off editing the buffer.	Type ? to the
	buffer prompt to see what buffers you currently have.  CR
	defaults to the previous buffer, i.e. repeated ^XB<cr>'s will
	flip back and forth between two buffers.  You can also give this
	command a numeric arg, which is the number of the buffer (as
	given by the ^X^B display).
mH -- Home -- special version of ^XB.  With no argument, returns to
	previous buffer (like ^XB<cr>); with arg is treated the same as
	<arg>^XB.
^X^B -- displays a list of the current buffers, what file is being
	edited in each, and whether the buffer contains changes that
	need to be written out. 
^X^F -- (Find file)  Like ^X^E, but reads the file into its own buffer,
	rather than into the current buffer.  The name of the buffer is
	taken from the filename.  If you give ^X^F a negative arg, it
	will edit the file readonly (a la ^X^R).  This command thus
	effectively does a ^XB to select a new buffer, followed by a
	^X^E (or ^X^R), and is the easiest way to bring in auxiliary
	files to edit or copy from.
^XK -- Kill buffer.  Give the name of the buffer you want to kill; CR
	for the current buffer, in which case it asks you for the name
	of a buffer to switch to.  Can also give a numeric arg to ^XK,
	as with ^XB.  This is a good thing to do if you know you are
	finished with the file, so as not to clutter up emacs with a lot
	of idle buffers.

^X2 -- go into 2 window mode.	The screen is split in half, and the
	bottom half contains the second window, where the cursor is then
	placed.  If you have been in 2-window mode before, you will be
	in the same buffer/file as was last in that window; otherwise,
	you are in a new empty buffer named W2.
^X3 -- like ^X2, but the cursor stays in window 1.
^X4 -- like ^X2, but you get to pick what you want to put in the second
	window.  Follow this with B to select a buffer, a la ^XB, or F
	(or ^F) to select a file, a la ^X^F.  I often find this more
	useful than ^X2.
^X1 -- go back to 1 window mode.  The second window disappears from the
	screen (although the buffer is still there, and can be selected
	again by ^XB, or brought back to window 2 by ^X2).
mO or ^XO -- (Other window)  Stay in 2-window mode, but move cursor back
	to the other window.
cmW -- Scroll the other window.  I.e. you want to stay in the current
	window, but advance the other one.  An explicit arg scrolls by
	that many lines.
^X^ -- (^X-uparrow) Grow window.  Increases the size of the currently
	selected window by the amount of the argument, or decreases it
	if arg is negative.  Initially the windows are (roughly) the
	same size.

While you are in 2-window mode, you can do anything you ordinarily would
do.  The mode line corresponds to which ever window you're currently in.
Help messages appear only in the selected window.  Use kill and unkill
commands to move text back and forth between the windows.


Special modes
-------------

EMACS is always in some major mode, and possibly some minor ones.  The
major mode determines what kind of text you are editing, and mostly
affects EMACS' concept of what is a "word", "paragraph" "comment", etc.
TVLIB puts you in Text mode.  Other modes exist for editing LISP, TECO,
PL1, FAIL, and other less useful things.  Major modes are all set by a
command "mX <name> Mode".

Minor modes determine special processing.  The two most useful are:

mX Auto Save Mode -- when in this mode, emacs does a simulated ^X^S
	every so often to save your changes.  This happens every 250
	characters you type (I think), or if you have been idle for a
	few minutes.  There is a parameter you can twiddle to affect
	this.

mX Auto Fill Mode -- when in this mode, every time you type a space or
	cr beyond the right margin (Q$Fill Column$, as with the justify
	commands), emacs will start a new line, moving the last word
	down from the previous line so as not to violate the margin
	constraint.  Thus you can just type straight text to your
	heart's content, and it will automatically be "filled", a la mQ.

Giving an arg of zero to either command turns off that mode.  Auto Fill
Mode is global, i.e. once you set it, it applies to all files.	Auto
Save mode affects only the current file.  You can turn on autosave for
every file automatically by setting the variable Q$Auto Save Default$
non-zero, say, in your init file.  In this case, you can turn OFF auto
save mode for a particular file you are visiting by giving an argument
to the visiting command, e.g. ^U^X^V edits a file with autosave off.
TVLIB also turns off autosave when you edit a file readonly, though you
can certainly turn it back on if for some reason you think you'll want
it.

Miscellaneous commands and comments
-----------------------------------

m= -- Prints info about where you are: x,y coordinate of the cursor on
	the screen, the	ascii code of the char the cursor is under, and
	the current byte pointer in the file.  This is not as useful as
	in TV, since control chars are displayed more obviously in
	emacs; the main need for this is to distinguish dollar from
	escape, since they both print the same.  Also useful if you
	wonder which column you're in.

cm= -- More useful indication of where you are in the file: prints page
	and line number, and number of lines on page.  Unlike the m=
	information, emacs doesn't keep track of this information, so it
	has to be computed afresh; however, that doesn't usually take
	long unless the file is monstrous.

mX View Page Directory -- For each page in the file, prints the page
	number and the first non-blank line of the page, thereby
	producing a "directory" of the file, a la E.  Useful for
	figuring out where you want to go in the file.

^X~ -- Pretend the buffer has not been changed.  Since emacs keeps
	track of whether you have made changes, and autosave will
	automatically dump them if you do, this is necessary if you
	"accidentally" make a change, e.g. insert something and then
	delete it.

^X^Q -- Change state of current file to read only (assuming you had done
	^X^V or ^X^F to edit it in the first place).  Give an arg of
	zero for the inverse function, i.e. to change a readonly file to
	readwrite.  In neither case is autosave affected, so watch out;
	if you change to readonly and still have autosave on it will
	still save the file if you change it.

mX Set Visited Filename$newname -- changes the name of the file emacs
	thinks is in the buffer.  Doesn't actually perform any file
	manipulation, but next time you give a command that writes out
	the current buffer (or autosave does), the new name will be
	used.  Thus, for example, you can read in someone else's file,
	edit it, and write it out to some other (new) file.  Sort of
	like giving a filename to the exit command in SOS.  To do this
	operation and write out the file immediately (a somewhat more
	common operation) use ^X^W.

m\ -- Removes spaces and tabs around the cursor, i.e. closes the gap
	between pieces of text.

TAB -- in text mode, TAB behaves much as in tvedit: it inserts a tab to
	get to the next tabstop, so ordinarily you don't have to worry
	about it -- it behaves like an ordinary char which inserts
	itself.  However, tab IS a command, and some modes redefine it.
	In such cases (as the next command below), to insert a real tab,
	you have to quote it with ^Q.

mX Edit Indented Text -- goes into a special submode with the following
	characteristics:  TAB is defined as "indent relative": it
	indents to the indentation on the previous line, or if the
	previous line was unindented, to a word break on the previous
	line; autofill performs indent relative on each new line it
	creates (Auto fill mode ordinarily does not indent new lines);
	paragraphs are defined solely by blank lines, not indentation.
	This mode facilitates entering text in the form of the paragraph
	you are now reading: body of text is indented, but topics appear
	at the margin.  It's not a total win for actually EDITING such
	text, though, since mQ doesn't know about it.  Exit this mode
	with cmZ.

^X. -- sets Fill Prefix to be everything on the current line up to the
	cursor.  When you're in autofill mode, new lines will try to
	have this as indentation.  Justify sticks this on the front of
	every line.  If justify were really smart, it would also think
	that lines beginning with the fill prefix were all part of the
	same paragraph and justify accordingly, but life is not so rosy.
	Indented lines still start paragraphs (unless you're in indented
	text mode), so what you have to do is delimit the region and do
	a cmQ (justify region) instead of mQ (justify paragraph).
	Alternatively, go into indented text mode, where "paragraph" is
	defined more appropriately.

mX Interlisp Mode -- enters major mode Interlisp.
	EMACS has an extensive set of
	commands for editing lisp code, developed for maclisp.  Since
	this community consists principally of interlisp users who use
	interlisp's editor rather than a text editor, Lisp mode may not
	be all that useful, and in defining TVLIB commands many commands
	replaced the original lisp commands (which were mostly ctrl-meta
	characters).  In lisp mode, TAB is defined as tab to current
	level in the s-expression, i.e. pretend you are prettyprinting
	the current text, and indent appropriately.

mX Revert File -- cancels any change you made since the last save.  E.g.
	if you do something disastrous, Revert File will save you.
	Actually, you don't need this usually, since EMACS always writes
	new versions of the file, so you could just go back and get the
	last one yourself.

mX Strip SOS Line Numbers -- Strips line numbers and nulls from current
	file.  EMACS ordinarily considers nulls to be significant, and
	will neither add nor remove them.  TV routinely adds nulls to
	files, and if you edit such a file, you may have an ungodly
	mass of ^@'s on your screen at some point.

Init files
----------

When you first start up EMACS, it looks on your login directory for a
file called EMACS.INIT, and if it finds it, reads it in.  The file is
interpreted as a list of TECO commands.  It actually takes very little
knowledge of teco to write most of the common things you want in an init
file, such as reassigning characters and setting variables, and I'm
willing to assist you with that if you desire.	If you just copy my init
file <rgsmith>emacs.init to your directory, you'll get my
initialization.  You can edit out what you don't want, if anything: the
first line loads TVLIB, the last invokes the standard initialization.
The remaining lines set Auto Fill mode and Auto Save Default.


More on Commands
----------------

While I have only mentioned mX commands as "named" commands, actually
almost all EMACS commands are named; the ones you use most often have
simply been assigned to certain characters.  TVLIB, for example, does a
massive reassignment of commands.  The commands which are intended to be
put on characters are "^R commands", and all have names beginning "^R"
(that's uparrow R).  If you do a ^_Apropos, you may see several commands
which are not assigned to characters.  You can still run them, by
invoking them as Extend commands, e.g. mX ^R Kill Sexp; you can also get
documentation on them from ^_Describe in the same way.  If you think you
want one of these commands regularly, I can tell you how to assign it to
a character.


Macros
------

If you know TECO, you can write TECO macros to do just about anything,
and assign them to arbitrary characters.  Of course, if you know TECO
you probably didn't need this document in the first place.

There is a library of commands which implement somewhat TV-like keyboard
macros, i.e. the macros are written as EMACS commands, rather than TECO
commands.  You define the macro by typing in the commands that perform
it; the commands are also executed, so you can see what's happening.
When you finish, you can invoke the same sequence of commands again,
give it a repeat arg (unlike in TV), create an Extend command to do it,
and/or assign the command to a character.  These are, of course, not
nearly as powerful as TECO macros, nor is there any way to store them
and use them on a later day.  They are principally useful for some
repetitive task you find yourself wanting to do in a given editing
session.

^X( -- begin macro.  Everything you type from here to the end of the
	macro becomes part of the macro, and is executed as you go.

^X) -- end macro.

^XE -- repeat the last macro you defined.  Give it a repeat arg if you
	want.

mX Name KBD Macro$NAME -- names the most recent macro "NAME", i.e.
	creates an extend command for it.  Also prompts you for a
	character to put the macro on; type CR if you don't want to.
	You can only assign macros to currently unassigned chars, of
	which there aren't too many.  Try m+, and m* for easy ones.
	It is possible to undefine existing characters if you want to
	use them for macros.

mX View KBD Macro$NAME -- prints the definition of the named macro.  If
	you don't give it a name, it will prompt for the character you
	put it on.


Narrow/Widen
------------

EMACS has commands that let you pretend you are editing just a piece of
the file.  The rest of the file disappears from view, and cannot be
accessed by any commands until you exit this mode.  This is useful for
confining searches and replacements, for example.  Actually, that's
about the only use it has outside of macros.

^XN -- Narrow bounds to the current region (between cursor and mark).
^XW -- Widen back out to the whole file.
^XP -- narrow bounds to the current Page.


PAGE library
------------

It's been noted that EMACS doesn't pay as much attention to pages as
TVEDIT does.  All the commands
related to pages work simply by looking for pagemarks in the files, but
pagemarks are not displayed distinctively or labeled by number, and they
do not alter the scope of commands.  Stew Rubenstein has written a
library of macros using the bounds-narrowing facilities to let you
view pages individually, with the page number appearing in the mode
line.  The page-switching commands (mG) move between pages, but ordinary
commands (up line, down line, etc) are confined to the page.  You can
load this library by issuing the command mX Load Library$PAGE.   The
command mX List One File will tell you what commands are in the library.
You can also arrange to load it in your init file if you like it.  I
think it has promise, but at the moment is not worth the trouble;
however, the winning command Print File Directory described above was
adapted from the PAGE library. 15-Jul-79 13:44:46-PDT,1128;000000000001
  