;;;-*-MIDAS-*-
;[SIMTEL20.ARPA]PS:<EMACS165>TECTRM.MID.51,  2-Mar-86 13:52:24, Edit by WANCHO
;;; Modified VT1INI to envelope a Save and Restore Cursor around the
;;; reset of ORIGIN Mode.  Otherwise, the cursor may not end up where
;;; expected.
;[SU-SCORE.ARPA]PS:<EMACS165>TECTRM.MID.50, 21-Nov-85 15:56:13, Edit by BILLW
;;; add SUNCPS cause sunwindows is broken  (SUN terminal type)
;[SU-SCORE.ARPA]PS:<EMACS165>TECTRM.MID.47, 21-Sep-85 00:33:40, Edit by BILLW
;;; fix c100 code - it was calling padding routines at weird entry points,
;;; causing the padding to be sent before the escape sequences.
;;; Also add support for AJ510 terminal (code from Tyson@SRI-AI)
;;;<EMACS165>TECTRM.MID.2,  6-Feb-85 18:18:46, Edit by BILLW
;;; make more efficient.  Avoid pbouts, short psouts.  Buffer
;;; and use explicit count, which has been optimized in tops20.
;;; consider using CR, LF for cursor positioning.  Start work on
;;; using "insert MODE" more effectively.
;;;[WASHINGTON]PS:<EMACS>TECTRM.MID.2, 11-Nov-83 15:30:16, Edit by FHSU
;;; beginnings of a "termcap" file for TECO.MID
;;; 4-June-84 Added FR100, ESPRIT, FR100, ANSI

ife stansw,[
PRINTX /?This versionof TECTRM has been extensively modified, and will not
?Work unless STANSW is turned on to get the coresponding edits in
?the main TECO.MID module.  The changes here are too numerous to
?Individually put inside of conditional assembly blocks!
/
	.FATAL INCOMPATABLE TECTRM
]

;;; HERE IS WHAT A TERMINAL TYPE TABLE LOOKS LIKE.

IFN 0,[

;;; DISPATCH VECTOR FOR FOO TERMINAL.
FOOTB:	3000+24.,,79.		;  24 LINES, 79 COLS NOT INCLUDING CONTINUATION COLUMN.
				;  3 MSEC PER LINE MOVED FOR I/D LINE OPERATIONS.
				;  THIS IS THE TOTAL FOR INSERTION PLUS DELETION.
				;  IT WILL SOMEDAY BE USED FOR OPTIMIZATION CALCULATIONS.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)	; BITS SAYING WHAT TERMINAL CAN DO.
;;; REMAINING ENTRIES ARE INSTRUCTIONS WHICH MAY CLOBBER ONLY A AND B
;;; UNLESS IT SAYS OTHERWISE FOR THE PARTICULAR ENTRY.
	CALL FOOCPS		; MOVE CURSOR.  B CONTAINS VPOS,,HPOS.  CAN CLOBBER A,B.
	CALL FOCEOL		; CLEAR TO END OF LINE.
	CALL FOCEOS		; CLEAR TO END OF SCREEN (NOT VERY IMPORTANT).
	CALL FOCLRS		; CLEAR SCREEN AND HOME CURSOR.
	JFCL			; SLOT NOW UNUSED.
	CALL FODSMV		; DEPOSIT APPROPRIATE 8-BIT CHARACTERS IN DISBF1.
				;  GIVEN A VPOS IN BP AND HPOS IN DISCPH, STORES CHARACTERS
				;  IN DISBF1 THROUGH DISBF1+5 TO MOVE THE CURSOR
				;  TO THAT POSITION AND CLEAR THE ENTIRE LINE.
				;  THIS WILL USUALLY INVOLVE MOVING TO THE FRONT OF THE LINE,
				;  CLEARING TO END OF LINE, THEN MOVING TO THE FINAL SPOT.
				;  IT IS MOST EFFICIENT TO USE THE LAST FEW WORDS OF DISBF1
				;  (AS MANY AS NECESSARY) LEAVING THE FIRST FEW WDS ALONE.
	CALL FODMV1		; LIKE THE PREVIOUS ROUTINE EXCEPT DON'T CLEAR THE LINE.
	CALL FOINSL		; INSERT LINES.  BP SAYS WHICH VPOS,  Q SAYS HOW MANY.
	CALL FODELL		; DELETE LINES.  ARGS AS ABOVE.
	CALL FOINSC		; INSERT CHARACTER AFTER THE CURSOR.
	CALL FODELC		; DELETE CHARACTER AFTER THE CURSOR.
	CALL FOORST		; TAKE TERMINAL OUT OF DISPLAY MODES USED BY TECO
				;  (FOR RETURNING TO EXEC, ETC.).
	CALL FOOSUP		; SCROLL UP, FOR THOSE TERMINALS WHICH CAN
				; PARTS OF SCREEN AROUND.
	CALL FOOSDN		; SCROLL DOWN, FOR THOSE TERMINALS WHICH CAN
				; MOVE PARTS OF SCREEN AROUND
	CALL FOOINI		; INITIALIZE TERMINALS (ON RETURN FROM FZ
				; ETC.) FOR THOSE TERMINALS WHICH NEED IT.
	CALL FOORSS		; RESET DISPLAY MODES TEMPORARILY,
				;  NOT EXPECTING TO CHANGE THE SCREEN.
				; USED FOR :ET.
	CALL FOOIVI		; TO INIT FOO'S INVERSE CHARACTER MODE
	CALL FOOIVC		; TO CLEAR INVERSE VIDEO MODE.

] ;IFN 0

IFN DM2500,[
SUBTTL DM2500

DM25TB:	2000+24.,,79.
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPMTA
	CALL DMCPS
	CALL DMCEOL
	CALL DMCEOL		;CLOSEST WE CAN COME
	CALL DMCLRS
	JFCL
	CALL DMDSMV
	CALL DMDMV1
	CALL DMINSL
	CALL DMDELL
	CALL DMINSC
	CALL DMDELC
	CALL DMRST
REPEAT 3,JFCL
	CALL DMRST
REPEAT 2,JFCL

DMCPS:	JUMPE B,[MOVEI A,^B	;HOME IS EASY
		  CALL %PBOUT
		  RET]
	MOVEI A,^L		;ELSE ^L<HPOS#140><VPOS#140>
	CALL %PBOUT
	HRRZ A,B
	XORI A,"`
	CALL %PBOUT
	HLRZ A,B
	XORI A,"`
DMCP2:	CALL %PBOUT
	RET

DMCEOL:	MOVEI A,^W
	JRST DMCP2

DMCLRS:	MOVEI A,^^
	CALL %PBOUT				;[
DMRST:	MOVEI A,^]			;RESTORE ROLL MODE
	JRST DMCP2

DMINSL:	SAVE C
	SAVE B
	CALL DMINS1			;POSITION RIGHT AND ENTER I/D MODE
	MOVEI A,30.			;COMPUTE AMOUNT OF FILL NEEDED
	SUBI A,(BP)			;((30.-(BP))*OSPEED-2400.)/14400.
	JUMPL A,[SETZ B,
		 JRST DMINS2]
	SKIPN B,OSPEED			;SPEED OF OUTPUT
	 MOVEI B,DEFOSP			;ASSUME MAX IF UNKNOWN
	IMULI B,(A)
	SUBI B,2400.
	IDIVI B,14400.			;MAGIC NUMBER IN B
DMINS2:	MOVEI A,^J			;INSERT A LINE
	CALL %PBOUT
	MOVE A,B			;PAD WITH RUBOUTS; NUMBER IN A.
	CALL EXPPAD
	SOJG Q,DMINS2			;REPEAT FOR NUMBER OF LINES REQUESTED
	REST B
DMINS3:	REST C
	MOVEI A,^X
	JRST DMCP2

DMDELL:	SAVE C
	CALL DMINS1
DMDEL2:	MOVEI A,^Z			;DELETE A LINE
	CALL %PBOUT
	MOVEI A,177			;ONE FILL CHAR
	SKIPN C,OSPEED
	 MOVEI C,DEFOSP
	CAIL C,9600.
	 CALL %PBOUT				;ONLY FOR 9600 BAUD OR MORE THOUGH
	SOJG Q,DMDEL2
	JRST DMINS3

DMINS1:	HRROI A,[.BYTE 7 ? ^L ? "` ? 0]
	CALL %PSOUT
	MOVEI A,(BP)
	XORI A,"`
	CALL %PBOUT
	MOVEI A,^P
	CALL %PBOUT
	RET

DMDSMV:	SAVE B
	SETZB A,B
	MOVEI B,(BP)		;DESIRED VPOS
	LSH B,8+4
	XOR B,[.BYTE 8 ? ^L ? "` ? "` ? ^W]
	SKIPN DISCPH		;DESIRED HPOS = 0?
	 JRST DMDSM2		;YES, DONT NEED SECOND CURSOR ADDRESS THEN
	LSHC A,16.-4
	CALL DMDSM1
	LSH A,4
DMDSM2:	MOVEM A,DISBF1+4
	MOVEM B,DISBF1+5
	JRST POPBJ

DMDSM1:	IOR B,DISCPH
	LSHC A,8.
	IORI B,(BP)
	LSHC A,4
	XOR B,[.BYTE 8 ? 0 ? ^L ? "` ? "`]
	RET

DMDMV1:	SAVE B
	SETZB A,B
	CALL DMDSM1
	JRST DMDSM2

DMINSC:	SAVE C
	HRROI A,[.BYTE 7 ? ^P ? ^\ ? ^X ? 0]
	SKIPN C,OSPEED
	 MOVEI C,DEFOSP
	CAIL C,9600.		;IF AT 9600 OR MORE,
	 HRROI A,[.BYTE 7 ? ^P ? 40 ? 177 ? ^X ? ^H ? 40 ? ^H]	;USE HAIRY ONE
	CALL %PSOUT
	REST C
	SOJG Q,DMINSC
	RET

DMDELC:	SAVE C
	HRROI A,[.BYTE 7 ? ^P ? ^H ? ^X ? 0]
	SKIPN C,OSPEED
	 MOVEI C,DEFOSP
	CAIL C,9600.		;IF AT 9600 OR MORE,
	 HRROI A,[.BYTE 7 ? ^P ? ^H ? 177 ? ^X ? 0]
	CALL %PSOUT
	REST C
	SOJG Q,DMDELC
	RET
]	;DM2500

IFN ESPRIT,[
SUBTTL HAZELTINE ESPRIT TABLES
ESPRTB:	8.*1000+24.,,79.	;DISPATCH VECTOR FOR ESPRIT
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID)
	CALL ESCPS
	CALL ESCEOL
	CALL ESCEOS
	CALL ESCLRS
	JFCL
	CALL ESDSMV
	CALL ESDMV1
	CALL ESINSL
	CALL ESDELL
REPEAT 9.,JFCL

ESCPS:	SAVE C
	MOVE C,[.BYTE 7 ? 33 ? ^Q ? "` ? "` ? 0]
	MOVEI A,140(B)
	CAIL A,177
	 SUBI A,140
	DPB A,[170700,,C]
	HLRZ A,B
	LSH A,7+1
	IOR C,A
	HRROI A,C
	CALL %PSOUT
	REST C
	RET

ESCEOL:	HRROI A,[.BYTE 7 ? 33 ? ^O ? 177 ?0]
	CALL %PSOUT
	RET

ESCEOS:	HRROI A,[.BYTE 7 ? 33 ? ^X ?177?177?177?177?177?0]
	CALL %PSOUT
	RET

ESCLRS:	HRROI A,[.BYTE 7 ? 33 ? ^\ ?177?177?177?177?0]
	CALL %PSOUT
	RET

ESINSL:	CALL ESIDPS
ESINS1:	HRROI A,[.BYTE 7 ? 33 ? ^Z ? 0]
	CALL %PSOUT
	CALL ESPAD
	SOJG Q,ESINS1
	RET

ESDELL:	CALL ESIDPS
ESDEL1:	HRROI A,[.BYTE 7 ? 33 ? ^S ? 0]
	CALL %PSOUT
	CALL ESPAD
	SOJG Q,ESDEL1
	RET

ESPAD:	SAVE B			;CALCULATE PADDING NEEDED FOR IL/DL
	HLRZ A,TTLPOS		;(c1 - abs(y-12)) * bps div c2
	SUBI A,12.		;we use c1=18.,c2=4050.
	MOVM A,A
	SUBI A,18.		;ie (30 - y)*bps Div 4050. for  y GE 12
	MOVM A,A		;    (6 + y)*bps Div 4050. for  y LT 12
	SKIPN B,OSPEED
	 MOVEI B,DEFOSP		;USE 9600. Baud FOR NET, I GUESS
	IMUL A,B
	IDIVI A,4050.		;EMPIRICALLY DETERMINED
	CALL EXPPD1		;GO DO PADDING (NOTE THAT B IS PROTECTED)
	JRST POPBJ		;AND RETURN

ESIDPS:	SAVE C
	MOVEI C,140(BP)
	LSH C,7+1
	IOR C,[.BYTE 7 ? 33 ? ^Q ? "` ? "` ? 0]
	HRROI A,C
	CALL %PSOUT
	REST C
	RET

;MOVE TO LINE START, CEOL, MOVE TO HPOS ON SAME LINE
ESDSMV:	SAVE B
	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,4
	IOR A,[.BYTE 8 ? 33 ? ^Q ? "` ? "`]	;MOVE TO LINE START
	MOVE B,[.BYTE 8 ? 33 ? ^O ? 177 ? 177]	;CEOL
	MOVEM A,DISBF1+3
	MOVEM B,DISBF1+4
	SETZM DISBF1+5		;ASSUME NO HORIZ POSITIONING NECSY
	SKIPN DISCPH		;DESIRED HPOS = 0?
	 JRST POPBJ		;YES, DONT NEED SECOND CURSOR ADDRESS THEN
ESDSM2:	MOVE A,[.BYTE 8 ? 33 ? ^Q ? "` ? "`]
	CALL ESDSM1
	MOVEM A,DISBF1+5
	JRST POPBJ

ESDSM1:	SAVE A
	DPB BP,[041000+P,,]	;VPOS
	MOVE B,DISCPH
	DPB B,[141000+P,,]	;HPOS
	JRST POPAJ

ESDMV1:	SAVE B
	SETZM DISBF1+3 ? SETZM DISBF1+4
	JRST ESDSM2

];ESPRIT

IFN H1500\HMOD1\H1510,[
SUBTTL H1500 AND HAZELTIME MODULAR ONE

IFN HMOD1,[
HZM1TB:	8.*1000+24.,,79.	;DISPATCH VECTOR FOR HZ1500
	(%TOMVB+%TOMVU+%TOLWR+%TOLID)
	CALL HZCPS
	CALL HZ1EOL
	CALL HZ1EOS
	CALL HZCLRS
	JFCL
	.VALUE
	CALL HZDMV1
	CALL HZINSL
	CALL HZDELL
REPEAT 9.,JFCL
] ;HMOD1

IFN H1500\H1510,[
HZ15TB:	8.*1000+24.,,79.	;DISPATCH VECTOR FOR HZ1500
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID)
	CALL HZCPS
	CALL HZCEOL
	CALL HZCEOS
	CALL HZCLRS
	JFCL
	CALL HZDSMV
	CALL HZDMV1
	CALL HZINSL
	CALL HZDELL
REPEAT 9.,JFCL
];H1500\H1510

HZCPS:	SAVE C
	MOVE C,[.BYTE 7 ? 176 ? ^Q ? "` ? "` ? 0]
	MOVEI A,140(B)
	CAIL A,177
	 SUBI A,140
	DPB A,[170700,,C]
	HLRZ A,B
	LSH A,7+1
	IOR C,A
	HRROI A,C
	CALL %PSOUT
	REST C
	RET

IFN H1500\H1510,[  ;THE STUPID MODULAR ONE DOESN'T HAVE THESE FUNCTIONS.
HZCEOL:	HRROI A,[.BYTE 7 ? 176 ? ^O ? 177 ?0]
	CALL %PSOUT
	RET

HZCEOS:	HRROI A,[.BYTE 7 ? 176? ^X ?177?177?177?177?177?0]
	CALL %PSOUT
	RET
];H1500\H1510

IFN HMOD1,[
HZ1EOS:				;CEOL IS AS CLOSE AS WE CAN COME TO CEOS
HZ1EOL:	JSR SAVABC		;CLEAR TO END OF SCREEN - WE PUT OUT
				;  ENOUGH SPACES TO GET TO END OF LINE
				;  EXCEPT IF AT LEFT HAND, KILL THE LINE
	SKIPGE C,EOLFLG		; NO. OF SPACES SET?
	 JRST HZ1EO1		; YES, USE THAT
	HRRZ C,TTLPOS		;C _ CURRENT POSITION
	JUMPE C,HZ1DIL		;IF C = 0 THEN DELETE; INSERT
	SUBI C,80.		;C _ - (80 - CURPOS) = NO. SPACES NEEDED
HZ1EO1:	HRROI B,SPACES
	MOVEI A,.PRIOU
	SOUT			;PUT OUT THAT MANY SPACES
	SETZM EOLFLG
	MOVE B,TTLPOS		;GO BACK WHERE WE WERE BEFORE
	CALL HZCPS
	JRST POPCBA

HZ1DIL:	HRROI A,[.BYTE 7 ? 176 ? 19. ? 176 ? 26. ? 0] ;DELETE, INSERT LINE
	CALL %PSOUT
	JRST POPCBA
] ;HMOD1

HZCLRS:	HRROI A,[.BYTE 7 ? 176? ^\ ?177?177?177?177?0]
	CALL %PSOUT
	RET

HZINSL:	CALL HZIDPS
HZINS1:	HRROI A,[.BYTE 7 ? 176 ? ^Z ? 0]
	CALL %PSOUT
	CALL HZPAD
	SOJG Q,HZINS1
	RET

HZDELL:	CALL HZIDPS
HZDEL1:	HRROI A,[.BYTE 7 ? 176 ? ^S ? 0]
	CALL %PSOUT
	CALL HZPAD
	SOJG Q,HZDEL1
	RET

HZPAD:	SAVE B			;CALCULATE PADDING NEEDED FOR IL/DL
	HLRZ A,TTLPOS		;(c1 - abs(y-12)) * bps div c2
	SUBI A,12.		;we use c1=18.,c2=4050.
	MOVM A,A
	SUBI A,18.		;ie (30 - y)*bps Div 4050. for  y GE 12
	MOVM A,A		;    (6 + y)*bps Div 4050. for  y LT 12
	SKIPN B,OSPEED
	 MOVEI B,DEFOSP		;USE 9600. Baud FOR NET, I GUESS
	IMUL A,B
	IDIVI A,4050.		;EMPIRICALLY DETERMINED
	CALL EXPPD1		;GO DO PADDING (NOTE THAT B IS PROTECTED)
	JRST POPBJ		;AND RETURN

HZIDPS:	SAVE C
	MOVEI C,140(BP)
	LSH C,7+1
	IOR C,[.BYTE 7 ? 176 ? ^Q ? "` ? "` ? 0]
	HRROI A,C
	CALL %PSOUT
	REST C
	RET

IFN H1500\H1510,[
;MOVE TO LINE START, CEOL, MOVE TO HPOS ON SAME LINE
HZDSMV:	SAVE B
	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,4
	IOR A,[.BYTE 8 ? 176 ? ^Q ? "` ? "`]	;MOVE TO LINE START
	MOVE B,[.BYTE 8 ? 176 ? ^O ? 177 ? 177]	;CEOL
	MOVEM A,DISBF1+3
	MOVEM B,DISBF1+4
	SETZM DISBF1+5		;ASSUME NO HORIZ POSITIONING NECSY
	SKIPN DISCPH		;DESIRED HPOS = 0?
	 JRST POPBJ		;YES, DONT NEED SECOND CURSOR ADDRESS THEN
HZDSM2:	MOVE A,[.BYTE 8 ? 176 ? ^Q ? "` ? "`]
	CALL HZDSM1
	MOVEM A,DISBF1+5
	JRST POPBJ
] ;H1500\H1510

HZDSM1:	SAVE A
	DPB BP,[041000+P,,]	;VPOS
	MOVE B,DISCPH
	DPB B,[141000+P,,]	;HPOS
	JRST POPAJ

HZDMV1:	SAVE B
	SETZM DISBF1+3 ? SETZM DISBF1+4
	JRST HZDSM2

]	;H1500\H1510\HMOD1

IFN VT52\VT61\VT100\VT100V\VT100W\VT100X\TL4041\TL1061\HEATH\E19\V200\PTV\AMBASS\MIME2A\BUR80\VT132\BEE2\GIGI,[
SUBTTL VT52S OF VARIOUS SORTS

IFN VT52,[
VT52TB:	24.,,79.		;DISPATCH VECTOR FOR VIRGIN VT52
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
REPEAT 11.,JFCL
]	;VT52
IFN VT61,[
VT61TB:	24.,,79.		;DISPATCH VECTOR FOR VT61
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL VTINSL
	CALL VTDELL
	CALL VTINSC
	CALL VTDELC
REPEAT 5,JFCL
	CALL VTINVI
	CALL VTINVC

;THE VT61 FLAVOUR OF I/D LINE/CHAR FOR A VT52
VTINSL:	SKIPA A,[[ASCIZ /PF/]]		;$PF - INSERT LINE
VTDELL:	MOVEI A,[ASCIZ /PD/] 		;$PD - DELETE LINE
	SETZ B,
	JRST VTIDL

VTDELC:	HRROI A,[.BYTE 7 ? 33 ? "P ? "S ? 0]
	CALL %PSOUT
	SOJG Q,VTDELC
	RET

VTINSC:	HRROI A,[.BYTE 7 ? 33 ? "P ? "I ? 40 ? 33 ? "P ? "I+40 ? 10 ? 0]
	CALL %PSOUT
	SOJG Q,VTINSC
	RET

;VT61 INVERSE VIDEO ROUTINES
VTINVI:	HRROI A,[.BYTE 7 ? 33 ? "O ? "J ? 0]
	CALL %PSOUT
	RET

VTINVC:	HRROI A,[.BYTE 7 ? 33 ? "O ? "j ? 0]
	CALL %PSOUT
	RET

]	;VT61

IFN PTV,[			;Plasma TV system version of VT52
PTVTB:	49.,,84.		;(Note hook in ^PK handler)
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOOVR,,%TPMTA
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
REPEAT 11.,JFCL
]	;PTV

IFN BEE2,[
SUBTTL	BEE2 TABLE AND OWN ROUTINES
BEE2TB:	24.,,79.		;DISPATCH VECTOR FOR VIRGIN VT52
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL B2INSL
	CALL B2DELL
	CALL B2INSC
	CALL B2DELC
	JFCL

B2INSL:	MOVEI A,[ASCIZ /L/]
	SETZ B,
	JRST VTIDL

B2DELL:	MOVEI A,[ASCIZ /M/]
	SETZ B,
	JRST VTIDL

B2INSC:	HRROI	A,[.BYTE 7 ? 33 ? "Q ? 0]	;INSERT C(Q) CHAR AT CUR POS
	CALL %PSOUT
B2INS3:	HRROI	A,[.BYTE 7 ? 40 ? 10 ? 0]
	CALL %PSOUT
	SOJG	Q,B2INS3
	HRROI	A,[.BYTE 7 ? 33 ? "@ ?0]
	CALL %PSOUT
	RET

B2DELC:	HRROI	A,[.BYTE 7 ? 33 ? "P ? 0]	;DELET C(Q) CHAR AT CUR POS
	CALL %PSOUT
	RET

]	;BEE2

IFN V200,[
V200TB:	24.,,79.		;DISPATCH VECTOR FOR VISUAL 200
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL V2CEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL V2INSL
	CALL V2DELL
	CALL V2INSC
	CALL V2DELC
REPEAT 7,JFCL

V2CEOS:	MOVEI A,"J		;CLEAR EOS NEEDS 2 PAD CHARS AT 9600 BAUD.
	CALL OUTESC
	MOVE A,OSPEED
	CAIGE A,9600.
	 RET
	HRROI A,[.BYTE 7 ? 177 ? 177]
	CALL %PSOUT
	RET

;THE V200 FLAVOUR OF I/D LINE/CHAR FOR A VT52
V2INSL:	MOVEI A,[ASCIZ /L/]	;$L - INSERT LINE
	MOVEI B,2
	JRST V2IDL		;[1]

V2DELL:	MOVEI A,[ASCIZ /M/]	;$M - DELETE LINE
	MOVEI B,2

V2IDL:	SAVE A			;[1]
	SAVE B
	MOVS B,BP		;[1] V200 ADDRESSING IS REVERSE ORDER FROM VT52
	JRST VTIDL2		;[1] JOINT COMMON VT52 IDL CODE

V2DELC:	MOVEI A,"O
	CALL OUTESC
	SOJG Q,.-1
	RET

V2INSC:	HRROI A,[.BYTE 7 ? 33 ? "i ? 0]	;start insert
	CALL %PSOUT
	PUSH P,Q
	MOVEI A,40		;make space
	CALL %PBOUT
	SOJG Q,.-1		;once per char
	POP P,Q
	HRROI A,[.BYTE 7 ? 33 ? "j ? 0]	;end insert
	CALL %PSOUT
	MOVEI A,10		;now go back to start
	CALL %PBOUT
	SOJG Q,.-1
	RET
] ;V200

IFN TL4041\TL1061,[
TL40TB:	8.*1000+24.,,79.	;DISPATCH VECTOR FOR TELERAY 4041
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPMTA
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL TLINSL
	CALL TLDELL
	CALL TLINSC
	CALL TLDELC
REPEAT 7,JFCL

;THE TELERAY 4041 VERSION OF I/D LINE/CHAR
TLINSL:	MOVEI A,[ASCIZ /L/]	;$L - INSERT LINE
	CAIA
TLDELL:	 MOVEI A,[ASCIZ /M/]	;$M - DELETE LINE
	MOVE B,RGETTY
	CAIE B,TL106I
	 TDZA B,B
	  MOVEI B,51.		;51 MS SEEMS TO BE NEEDED FOR THE 1061.
	JRST VTIDL

TLDELC:	MOVEI A,"Q
	CALL OUTESC
	SOJG Q,TLDELC
	RET

TLINSC:	MOVEI A,"P
	CALL OUTESC
	SOJG Q,TLINSC
	RET
]	;TL4041,TL1061

IFN VT100\VT100V\VT100W\VT100X\AMBASS\VT132\GIGI\BITGRA\AVT\SUN\AVTX,[
IFN BITGRA,[				;[FHSU] FOR V2.0+ BITGRAPH

;;; BBN Bitgraph terminal.  Like an ANSI VT100 with insert/delete
;;; line, char I/D, and scrolling.

BBNTB:	62.,,84.
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPRSC
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
	CALL AMINSL		;[fHsu] THESE NEVER GET CALLED
	CALL AMDELL		;[fHsu] IF SCROLLING IS ON.
	CALL AMINSC		;[fHsu] INS CHAR
	CALL AMDELC		;[fHsu] DEL CHAR
	CALL BBNRST		;[fHsu] RESET
	CALL BBNSUP		;[fHsu] SCROLL UP
	CALL BBNSDN		;[fHsu] SCROLL DOWN
	JFCL			;[fHsu] INIT
	JFCL			;[fHsu] RESET TEMPORARILY
	CALL AMINV		;SET/RESET INVERSE VIDEO MODE
	CALL AMCINV

BBNRST:	HRROI A,[ASCIZ /[1;64r[64;1H/]	;RESET SCROLL REGION and PUT CURSOR
						;AT BOTTOM OF SCREEN.
	CALL %PSOUT
	RET

;SCROLL Q LINES STARTING WITH LINE IN BP UP
BBNSUP:	PUSH P,["D]	;INDEX NEEDED TO CAUSE SCROLLING (DOESNT TAKE ARGUMENT)
	JSP A,BBNSCR	;SETUP SCROLL REGION AND BYTE POINTER IN A
	MOVE B,BOTLIN	;POSITION TO BOTTOM OF SCROLL REGION, OFFSET
BBNUP2:	CALL VT1ARG
	MOVEI B,"H
	IDPB B,A
	MOVEI B,0	;MAKE ASCIZ
	IDPB B,A
	HRROI A,BBNBUF	;GET COMMANDS BACK
	CALL %PSOUT	;SET SCROLLING REGION
	MOVEI A,(Q)	;CALCULATE PADDING
	IDIVI A,10.	;CHANGE THIS AS NEEDED
	MOVEM A,BBNPAD	;SAVE PAD CALCULATION
BBNUP3:	MOVE A,-2(P)	;GET CURSOR COMMAND - INDEX OR REVERSE INDEX
	CALL OUTESC	;OUTPUT IT
	MOVEI A,0	;BG PAD CHARACTER - DONT USE DELS!
	MOVE B,BBNPAD	;GET BACK PADDING
BBNLUP:	CALL	%PBOUT
	SOJG B,BBNLUP
	SOJG Q,BBNUP3
	JRST POPCBA	;ALSO FLUSH SCROLLING COMMAND

BBNSDN:	PUSH P,["M]	;REVERSE INDEX TO SCROLL BACKWARDS
	JSP A,BBNSCR	;SETUP SCROLL REGION
	MOVEI B,1(BP)	;MOVE TO TOP LINE, OFFSET
	JRST BBNUP2

BBNSCR:	PUSH P,B
	PUSH P,C
	PUSH P,A	;SAVE RETURN ADDRESS AS WELL
	MOVE A,[440700,,BBNBUF]	;MAKE STRING POINTER
BBNSC1:	MOVEI B,1(BP)	;STARTING LINE, OFFSET
	CALL VT1ARG
	MOVEI B,";
	IDPB B,A
	MOVE B,BOTLIN	;BOTTOM LINE, OFFSET
	CALL VT1AR1
	MOVEI B,"r	;SET SCROLL REGION
	IDPB B,A
	RET

]  ;IFN BITGRA

IFN AMBASS,[
AMBATB:	48.,,79.		;Nominally 48 lines, can use more or less
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPMTA
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL AMCLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
	CALL AMINSL
	CALL AMDELL
	CALL AMINSC
	CALL AMDELC
REPEAT 3,JFCL			;(Reset, scroll up, scroll down)
	CALL AMINI		;Need to be sure in right "edit extent" modes
	JFCL			;(Reset temporarily)
	CALL AMINV		;Set/reset inverse video mode
	CALL AMCINV

AMCLR:	TIME
	EXCH A,AALSCL		;Remember this clear time, get previous
	JUMPE A,AMCLR1		;Haven't yet, no padding necessary
	SUB A,AALSCL		;Get negative of difference
	ADDI A,1000.		;Add in theoretical maximum (gross amounts)
	SKIPLE A		;If none needed, don't do it
	 CALL TIMPAD		;Else, pad this much
AMCLR1: JRST VT1CLR

AMCINV:	SAVE Q
	MOVEI Q,0		;Back to normal
	JRST AMVERS		;Join common code
AMINV:	SAVE Q
	MOVEI Q,7		;Reverse-video
AMVERS:	MOVEI A,"m		;Select graphic rendition
	CALL AMDOIT
	REST Q
	RET

AMINSL:	MOVEI A,"L
AMXXXL:	SAVE A
	SAVE Q
	MOVEI Q,1(BP)
	MOVEI A,"H
	CALL AMDOIT
	REST Q
	REST A
	JRST AMDOIT


AMDELL:	MOVEI A,"M
	JRST AMXXXL

AMDOIT:	SAVE A
	HRROI A,[ASCIZ/[/]	;]
	CALL %PSOUT
	MOVE A,Q
	CALL VT1PAR
	REST A
	CALL %PBOUT
	RET

AMINSC:	MOVEI A,"@
	JRST AMDOIT

AMDELC:	MOVEI A,"P
	JRST AMDOIT

AMINI:	SETZM AALSCL		;haven't cleared screen yet.
	RET
REPEAT 0,[
AMINI:	SAVE Q
	SETZM AALSCL		;Haven't cleared the screen yet
	SETOM PADCHR		;Use delays for gross padding
	MOVEI Q,1		;"edit in line"
	MOVEI A,"Q		;Select editing extent mode
	CALL AMDOIT
	HRROI A,[ASCIZ/[/]	;]
	CALL %PSOUT
	MOVE A,NVLNS		;Now, set the terminal's page and screen
	CALL VT1PAR		; sizes to the supposed length
	HRROI A,[ASCIZ/;;;/]
	CALL %PSOUT
	MOVE A,NVLNS
	CALL VT1PAR
	MOVEI A,"p
	CALL %PBOUT
	REST Q
	RET
];REPEAT 0
];IFN AMBASS,

VT10TB:	24.,,79.		;DISPATCH VECTOR FOR VT100 IN ANSI MODE
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID,,%TPRSC
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
REPEAT 4,JFCL		;LID ROUTINES NEVER GET CALLED
	CALL VT1RST
	CALL VT1SUP
	CALL VT1SDN
	CALL VT1INI
	CALL VT1RST
	CALL VT1IVI
	CALL VT1IVC

;GIGI IN ANSI MODE.
GIGITB:	24.,,79.		;DISPATCH VECTOR FOR GIGI IN ANSI MODE
	%TOERS+%TOMVB+%TOMVU+%TOLWR,,
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
REPEAT 13,JFCL		;LID ROUTINES NEVER GET CALLED

;DISPATCH VECTOR FOR VT100 IN VT52 MODE
;NOTE: IT IS IMPOSSIBLE TO POSITION BEYOND COLUMN 80 IN THIS MODE.
;IF YOU WANT TO USE 132 COLUMNS, YOU MUST USE ANSII MODE.
VT15TB:	24.,,79.
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID,,%TPRSC
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VT15CL
	JFCL
	CALL VTDSMV
	CALL VTDMV1
REPEAT 4,JFCL		;LID ROUTINES NEVER GET CALLED
	CALL VT15RS
	CALL VT1SUP
	CALL VT1SDN
	CALL VT15IN
	CALL VT15RS
	CALL VT15IV
	CALL VT15IC

VT1WTB:	24.,,79.		;DISPATCH VECTOR FOR VT100 IN ANSI MODE INSIDE, VT52 OUTSIDE
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID,,%TPRSC
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
REPEAT 4,JFCL		;LID ROUTINES NEVER GET CALLED
	CALL VT15RS
	CALL VT1SUP
	CALL VT1SDN
	CALL VT1INI
	CALL VT15RS
	CALL VT1IVI
	CALL VT1IVC

VT1XTB:	24.,,79.		;DISPATCH VECTOR FOR VT100 IN VT52 MODE INSIDE, ANSI OUTSIDE
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID,,%TPRSC
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VT15CL
	JFCL
	CALL VTDSMV
	CALL VTDMV1
REPEAT 4,JFCL		;LID ROUTINES NEVER GET CALLED
	CALL VT1RST
	CALL VT1SUP
	CALL VT1SDN
	CALL VT15IN
	CALL VT1RST
	CALL VT15IV
	CALL VT15IC

V132TB:	24.,,79.		;DISPATCH VECTOR FOR VT132 IN ANSI MODE
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPRSC
	CALL VT1CPS
	CALL VT1CEL
	CALL VT1CES
	CALL VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
REPEAT 2,JFCL		;LID ROUTINES NEVER GET CALLED
	CALL VT1INC
	CALL VT1DEC
	CALL VT1RST
	CALL VT1SUP
	CALL VT1SDN
	CALL VT1INI
	CALL VT1RST
	CALL VT1IVI
	CALL VT1IVC

; V1CPS - OUTPUT VT-100 CURSOR POSITIONING COMMANDS TO TERMINAL.
; ARGUMENT:
;   B	LINE,,COLUMN

VT1CPS:	SAVE B
	HRROI A,[ASCIZ /[/]	;]
	CALL %PSOUT
	JUMPE B,VT1CP8		; SKIP ALL THIS FOR HOMING
	HLRZ A,B		; VERTICAL POS
	AOS A			; USES 1 BASED ADDRESSING
	CALL VT1PAR
	HRRZ A,B
	JUMPE A,VT1CP8
	SAVE A
	MOVEI A,";
	CALL %PBOUT
	REST A
	AOS A
	CALL VT1PAR
VT1CP8:	MOVEI A,"H
	CALL %PBOUT
	REST B
	RET

; VT1ESC - OUTPUT ANSII CONTROL SEQUENCE INTRODUCER (CSI)

VT1ESC:	SAVE A
	HRROI A,[ASCIZ /[/]	;]
	CALL %PSOUT
	REST A
	CALL %PBOUT
	RET

; VT1PAR - OUTPUT ASCII STRING EQUIVALENT TO NUMBER IN A
; ARGUMENT:
;   A	NUMBER TO BE CONVERTED TO A STRING OF ASCII DIGITS
;	ASSUMES SCREEN WIDTH OF LESS THAN 999! (IE. 132 COL MODE WORKS)

VT1PAR:	SAVE B
	IDIVI A,10.
	SAVE B
	JUMPE A,VT1PA1
	IDIVI A,10.
	JUMPE A,VT1PA2
	ADDI A,"0
	CALL %PBOUT
VT1PA2:	MOVEI A,"0(B)
	CALL %PBOUT
VT1PA1:	REST B
	MOVEI A,"0(B)
	CALL %PBOUT
	REST B
	RET

; VT1CEL - CLEAR FROM CURSOR TO END OF LINE
VT1CEL:	MOVEI A,"K
	JRST VT1ESC

; VT1CES - CLEAR FROM CURSOR TO END OF SCREEN
VT1CES:	MOVEI A,"J
	JRST VT1ESC

; VT1CLR - CLEAR WHOLE SCREEN
VT1CLR:	HRROI A,[ASCIZ /[H[J/]	;]]
	CALL %PSOUT			; clear screen
	RET


; VT1DSM - CALC. VT-100 COMMANDS TO MOVE TO THE SPECIFIED POSITION AND
; CLEAR THE WHOLE LINE.  THE COMMANDS ARE PUT IN DISBF1, AS CLOSE TO DISBUF
; AS POSSIBLE.  8 BIT BYTES ARE USED.
; ARGUMENTS:
;   BP		LINE NO.
;   DISCPH	COLUMN NO.

VT1DSM:	MOVEI A,2		; SET UP INDEX INTO DISBF1
	CALL VT1DAA		; GO PUT COMMANDS TO MOVE INTO DISBF1
	MOVE A,[.BYTE 8 ? 33 ? "[ ? "2 ? "K]	;] SET UP TO CLEAR A LINE
	MOVEM A,DISBF1+5	; CLEAR GOES AT END
	RET

; VT1DMV - SAME AS VT1DSM EXCEPT DOESN'T CLEAR.
; ARGUMENTS:
;   BP		LINE NO.
;   DISCPH	COLMN NO.

VT1DMV:	MOVEI A,3		; SET UP INDEX INTO DISBF1
	CALL VT1DAA		; GO PUT MOVE IN DISBF1
	RET

; VT1DAA - PUT COMMAND TO MOVE TO A LOCATION, IN DISBF1 (INDEXED BY A)
; ARGUMENTS:
;   A		INDEX TO STARTING WORD OF STRING IN DISBF1
;   BP		LINE NO.
;   DISCPH	COLUMN NO.

VT1DAA:	SAVE B			;
	SAVE C			;
	MOVE C,[.BYTE 8 ? 0 ? 0 ? 0 ? 33]	; FIRST LINE
	MOVEM C,DISBF1(A)	; AND PUT IT IN
	AOS A			; AND POINT TO NEXT
	SAVE A			; HIDE INDEX
	MOVE A,BP		;GET TARGET LINE
	AOS A			; ONE BASED ADDRESSING
	IDIVI A,10.		; GET TWO DIGITS (ASSUME LINE NO. <99)
	LSH A,8.		; MOVE MSD UP 1 CHAR
	ADDI B,(A)		; AND ADD IN LSD
	LSH B,8.+4		; AND MOVE TO CORRECT POSITION IN WORD
	ADD B,[.BYTE 8 ? "[ ? "0 ? "0 ? ";]	;] AND ADD OTHER CHARS.
	REST A			; GET BACK INDEX
	MOVEM B,DISBF1(A)	; AND PUT STRING IN DISBF1
	AOS A			; BUMP INDEX
	SAVE A			; AND HIDE IT AGAIN UNTILL WE GET COL.
	MOVE A,DISCPH		; GET COL. NO.
	AOS A			; AND ADD 1
	IDIVI A,10.		; AND SPLIT OFF 10'S AND 100'S
	SAVE B			; HIDE UNITS
	IDIVI A,10.		; SEPARATE 100'S AND 10'S
	LSH A,8.		; SHIFT UP 100'S
	ADDI A,(B)		; AND ADD BACK IN 10'S
	LSH A,8.		; SHIFT THEM UP
	REST B			; GET BACK UNITS
	ADDI A,(B)		; AND ADD THEM IN
	MOVEM A,B		;
	LSH B,8.+4		; AND PUT THEM IN THE RIGHT POSITION
	ADD B,[.BYTE 8 ? "0 ? "0 ? "0 ? "H]	; ADD IN ASCII STRING
	REST A			; GET INDEX BACK
	MOVEM B,DISBF1(A)	; AND PUT STRING IN DISBF1
	REST C			;
	REST B			;
	RET			;

VT1RST:	HRROI A,[ASCIZ /<7[r8/]	;] RESET SCROLL REGION
	CALL %PSOUT
	RET

VT15CL:	HRROI A,[ASCIZ "<[?2lHJ"] ;]
	CALL %PSOUT
	RET

VT15RS:	HRROI A,[ASCIZ /<7[1;24r8[?2l/]	;]] RESET SCROLL REGION
	CALL %PSOUT
	RET

;SCROLL Q LINES STARTING WITH LINE IN BP UP
VT1SUP:	PUSH P,["D]	;INDEX NEEDED TO CAUSE SCROLLING (DOESNT TAKE ARGUMENT)
	JSP A,VT1SCR	;SETUP SCROLL REGION AND BYTE POINTER IN A
	MOVE B,BOTLIN	;POSITION TO BOTTOM OF SCROLL REGION, OFFSET
VT1UP2:	CALL VT1ARG
	MOVEI B,"H
	IDPB B,A
	MOVEI B,0
	IDPB B,A	;MAKE ASCIZ OF POSITIONING STUFF
	HRROI A,VT1BUF
	CALL %PSOUT		;TYPE IT ALL OUT
VT1UP3:	MOVE A,-2(P)	;GET CURSOR COMMAND
	CALL OUTESC	;SCROLL RIGHT DIRECTION
	MOVE A,RGETTY
	CAIN A,VT132I
	 JRST [	MOVEI A,32.
		CALL TIMPAD
		JRST VT1UP4]
	MOVEI A,10.
	CALL EXPPAD
VT1UP4:	SOJG Q,VT1UP3
	MOVE A,RGETTY
	CAIE A,VT152I
	 CAIN A,VT10XI
	 SKIPA
	 JRST POPCBA
	HRROI A,[ASCIZ /[?2l/]	;] BACK INTO VT52 MODE
	CALL %PSOUT
	JRST POPCBA	;ALSO FLUSH SCROLLING COMMAND

VT1SDN:	PUSH P,["M]	;REVERSE INDEX TO SCROLL
	JSP A,VT1SCR	;SETUP SCROLL REGION
	MOVEI B,1(BP)	;MOVE TO TOP LINE, OFFSET
	JRST VT1UP2

VT1SCR:	PUSH P,B
	PUSH P,C
	PUSH P,A	;SAVE RETURN ADDRESS AS WELL
	MOVE A,[440700,,VT1BUF]	;MAKE STRING POINTER
	MOVE B,RGETTY
	CAIE B,VT152I
	 CAIN B,VT10XI
	 SKIPA
	 JRST VT1SC1
	MOVEI B,33
	IDPB B,A
	MOVEI B,"<	;ENTER ANSI MODE
	IDPB B,A
VT1SC1:	MOVEI B,1(BP)	;STARTING LINE, OFFSET
	CALL VT1ARG
	MOVEI B,";
	IDPB B,A
	MOVE B,BOTLIN	;BOTTOM LINE, OFFSET
	CALL VT1AR1
	MOVEI B,"r	;SET SCROLL REGION
	IDPB B,A
	RET

VT1INI:	HRROI A,[ASCIZ "<7[?6l8"] ; FORCE ANSI MODE, RESET ORIGIN MODE
	CALL %PSOUT
	RET

VT15IN:	HRROI A,[ASCIZ "<[?2l"] ;] FORCE VT52 MODE
	CALL %PSOUT
	RET

VT1INC:	HRROI A,[ASCIZ /[4h/]	;]Insert chars by inserting spaces then
	CALL %PSOUT			;backing up over them
	MOVEI A,40
	CALL OUTN
	SAVE B
	MOVE A,Q
	IMULI A,10
	CALL TIMPAD		;PAD 8 MSEC PER CHAR (FOR VT132)
	REST B
	HRROI A,[ASCIZ /[4l/]	;]
	CALL %PSOUT
	MOVEI A,^H
	JRST OUTN

VT1DEC:	HRROI A,[ASCIZ /[/]	;]Delete Q characters in line.
	CALL %PSOUT
	MOVE A,Q
	CALL VT1PAR
	MOVEI A,"P
	CALL %PBOUT
	SAVE B
	MOVE A,Q
	IMULI A,10
	CALL TIMPAD		;PAD 8 MSEC PER CHAR (FOR VT132)
	REST B
	RET

;ENTER INVERSE VIDEO MODE IF IN ANSI MODE.
VT1IVI:	SAVE A
	MOVEI A,"7
	CALL VT1ESC
	MOVEI A,"m
	CALL %PBOUT
	JRST POPAJ

;LEAVE INVERSE VIDEO MODE IF IN ANSI MODE.
VT1IVC:	SAVE A
	MOVEI A,"m
	CALL VT1ESC
	JRST POPAJ

;ENTER INVERSE VIDEO MODE IF IN VT52 MODE.
;MUST ENTER ANSI MODE AND THEN LEAVE IT.
VT15IV:	SAVE A
	HRROI A,[ASCIZ/<[7m[?2l/]	; ]]
	CALL %PSOUT
	JRST POPAJ

;LEAVE INVERSE VIDEO MODE IF IN VT52 MODE.
;MUST ENTER ANSI MODE AND THEN LEAVE IT.
VT15IC:	SAVE A
	HRROI A,[ASCIZ/<[m[?2l/]	; ]]
	CALL %PSOUT
	JRST POPAJ

VT1ARG:	MOVEI C,33
	IDPB C,A
	MOVEI C,"[	;]
	IDPB C,A
VT1AR1:	IDIVI B,10.
	JUMPE B,VT1AR2	;NO TENS DIGIT
	ADDI B,"0
	IDPB B,A	;ELSE PUT IT IN
VT1AR2:	ADDI C,"0
	IDPB C,A	;AND DIGITS
	RET

ifn AVT,[
AVTTB:	24.,,78.		; see comments in C100 code
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VT1CPS
	CALL VT1CEL
	CALL avtCES
	CALL avtCLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
	CALL AMINSL
	CALL AMDELL
	CALL AVXNSC		;INS CHAR
	CALL AMDELC		;DEL CHAR
	call	AVTRST		;reset
REPEAT 2,JFCL			;(scroll up, scroll down)
	call	AVTINI		;INIT TERMINAL
	jfcl
	CALL VT1IVI		;Set/reset inverse video mode
	CALL VT1IVC

AVTXTB:	24.,,78.		; see comments in C100 code
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VT1CPS
	CALL VT1CEL
	CALL avtCES
	CALL avtCLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
	CALL AMINSL
	CALL AMDELL
	CALL AVXNSC		;INS CHAR
;	CALL AVTNSC		;INS CHAR
	CALL AMDELC		;DEL CHAR
	call	AVXRST		;reset
REPEAT 2,JFCL			;(scroll up, scroll down)
	call	AVXINI		;INIT TERMINAL
	call	XICFIX		;(Reset temporarily) (turn off insert mode
	CALL VT1IVI		;Set/reset inverse video mode
	CALL VT1IVC

AVTNSC:	save	1
	hrroi	1,[asciz/[4h/]		;turn on insert mode ]
	call %psout
	CALL OUTNSP
	MOVEI A,^H
	CALL OUTN
	hrroi	1,[asciz/[4l/]		;turn off insert mode ]
	call %psout
	rest	1
	ret

AVXNSC:	jumpl	Q,AVINSO	; <0 implies turn off insert mode >
	skiple	INSCNT		;note that we should be called only
	 call	XICFIX		;when INSCNT is 0!
	movem	Q,INSCNT	;increment count of chars to be inserted
	skipe	INSFLG		;check whether we are still in insert mode
	 ret
	hrroi	1,[asciz/[4h/]		;turn on insert mode ]
	setom	INSFLG
	jrst	%PSOUT
AVINSO:	hrroi	1,[asciz/[4l/]		;turn off insert mode ]
	setzm	INSFLG		;no longer in insert mode
	setzm	INSCNT		;0 chars (as opposed to -1, so ADDM will work!)
	jrst	%PSOUT


AVTCES:	CALL VT1CES
	movei	A,96
	jrst	TIMPAD

AVTCLR:	CALL VT1CLR
	movei	A,96
	jrst	TIMPAD

AVXRST:	hrroi	1,[asciz/[1!w[1;9!w/]	;back to window #1 (keyboard too) ]]
	call %psout
AVTRST:	save	1
	call	XICFIX		 ;maybe finish inserting characters
	hrroi	1,[asciz/[1;1*q/]	;turn xon/xoff back on,etc ]
	call %psout
	rest	1
	ret

AVXINI:	save	1
	hrroi	1,[asciz/[4!w[4;9!w/]	; use window 4 (line & keyboard) ]]
	call %psout
	jrst	avtini+1
AVTINI:	save	1
	save	2
	save	3
	hrroi	1,[asciz/[0;1*q[1;/]	;] turn off xon/xoff
	call %psout
	movei	1,.priou
	move	2,nvlns
	movei	3,12
	call	%TFLSH			;lazy lazy.
	nout
	 trn
	hrroi	1,[asciz/w[24;1H/] 	;] define small window
	call %psout
	rest	3
	rest	2
	rest	1
	ret

];ifn AVT
ifn SUN,[
SUNTB:	34.,,79.		;Nominally 34 lines; otherwise like AMB
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL SUNCPS
	CALL VT1CEL
	CALL VT1CES
	call VT1CLR
	JFCL
	CALL VT1DSM
	CALL VT1DMV
	CALL AMINSL
	CALL AMDELL
	CALL AMINSC
	CALL AMDELC
REPEAT 3,JFCL			;(Reset, scroll up, scroll down)
	jfcl			 ; no ini code for SUN
	JFCL			;(Reset temporarily)
	CALL AMINV		;Set/reset inverse video mode
	CALL AMCINV

SUNCPS:	SAVE B
	HRROI A,[ASCIZ /[/]	;]
	CALL %PSOUT
	JUMPE B,VT1CP8		; SKIP ALL THIS FOR HOMING
	HLRZ A,B		; VERTICAL POS
	AOS A			; USES 1 BASED ADDRESSING
	CALL VT1PAR
	MOVEI A,";
	CALL %PBOUT
	HRRZ A,B
	AOS A
	CALL VT1PAR
	MOVEI A,"H
	CALL %PBOUT
	REST B
	RET
]; ifn SUN
];VT100\VT100V\VT100W\VT100X\AMBASS\VT132\BITGRA\AVT\SUN\AVTX

IFN E19\HEATH,[
IFN HEATH,[
HTHTB:	5*1000+24.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL HTINSL
	CALL HTDELL
	CALL HTINSC
	CALL HTDELC
ifn stansw,[
	call XICFIX	;turn off insert mode on exit
repeat 3, JFCL		; scrolling regions, initialize
	call XICFIX	;turn off inster mode on temporary exit.
];ifn stansw
.ELSE,[
REPEAT 5,JFCL
]
	CALL HTINVI	; FOR THE INVERSE VIDEO STUFF
	CALL HTINVC

HTINSC:
ifn stansw,[
	jumpl	Q,HTINSO	; <0 implies turn off insert mode >
	skiple	INSCNT		;note that we should be called only
	 call	XICFIX		;when INSCNT is 0!
	caile	Q,2		; On and H29, insterting too many charactber
	 jrst	OHTNSC		; can cause lossage - use old method
	movem	Q,INSCNT	;increment count of chars to be inserted
	skipe	INSFLG		;check whether we are still in insert mode
	 ret
	movei	A,"@
	setom	INSFLG
	jrst	outesc		; turn on insert mode
HTINSO:	movei	a,"O
	call	outesc
	setzm	INSFLG		;no longer in insert mode
	setzm	INSCNT		;0 chars (as opposed to -1, so ADDM will work!)
	ret
OHTNSC:	setzm	INSFLG		;Old method will take us out of insert mode.
];ifn stansw
	MOVEI A,"@
	CALL OUTESC
IFE STANSW,[		;THIS WORKS ONLY FOR H-19
	CALL OUTNSP
	MOVEI A,^H
	CALL OUTN
];IFE STANSW
IFN STANSW,[		;THIS WORKS FOR BOTH H-19 AND H-29
	SAVE B
	SAVE Q
	MOVE B,[ASCIZ/ /]
HTINC1:	HRROI	A,B
	CALL %PSOUT
	MOVE A,OSPEED		;check our output speed.
	CAIGE A,4800.		; are we fast?
	JRST HNSCNP		;  No, dont pad.
	 HRLZ A,(P)		;get back number of character we are inserting.
	TLNE A,777774		;more than 4?
	 CALL %PBOUT		; yes add a padding character (a null)
	TLNE A,777770		;more than 8?
	 CALL %PBOUT		; add another padding char
	TLNE A,777760		;more than 16?
	 CALL %PBOUT		; add still another padding char (sigh)
HNSCNP:	SOJG Q,HTINC1
	REST Q
	REST B
];IFN STANSW
	MOVEI A,"O
	JRST OUTESC

HTDELC:	MOVEI A,"N
	CALL OUTESC
	SOJG Q,HTDELC
	RET
] ;IFN HEATH

HTINSL:	SKIPA A,["L]
HTDELL:	 MOVEI A,"M
	SETZM PADCHR	;MUST USE NULLS FOR PADDING
	SAVE A
	HRLZ B,BP		;put VPOS in LEFT halfword where it goes
	CALL VTCPS
	CAILE Q,3		;;;IF OVER 2
	 JRST HTANSI		;USE ANSI MODE
HTINS1:	MOVE A,(P)
	CALL OUTESC
	MOVEI A,30
	CALL TIMPAD
	SOJG Q,HTINS1
	JRST POPAJ

HTANSI:	HRROI A,[ASCIZ "<["]	; ]
	CALL %PSOUT
	MOVE A,Q
	IDIVI A,10.
	ADDI A,"0
	CAIE A,"0
	 CALL %PBOUT
	MOVEI A,"0(B)
	CALL %PBOUT
	REST A
	CALL %PBOUT
HTANS1:	MOVEI A,30
	IMULI A,(Q)
	CALL TIMPAD
	HRROI A,[ASCIZ "[?2h"]	; ]
	CALL %PSOUT
	RET

HTINVI:	SAVE A
	HRROI A,[ASCIZ/p/]
	CALL %PSOUT
	JRST POPAJ

HTINVC:	SAVE A
	HRROI A,[ASCIZ/q/]
	CALL %PSOUT
	JRST POPAJ

IFN E19,[
E19TB:	24.,,79.
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPRSC
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL HTINSL
	CALL HTDELL
	CALL E19IC
	CALL E19DC
	JFCL
	CALL E19WUP
	CALL E19WDN
	JFCL
	JFCL
	CALL HTINVI	; FOR THE INVERSE VIDEO STUFF
	CALL HTINVC

E19IC:	MOVEI A,"i
	CALL OUTESC
	MOVEI A,37(Q)
	CALL %PBOUT
	RET

E19DC:	MOVEI A,"d
	CALL OUTESC
	MOVEI A,37(Q)
	CALL %PBOUT
	RET

; ARGUMENTS:
;   BP		STARTING LINE OF REGION.
;   BOTLIN	LAST LINE OF REGION.
;   Q		NUMBER OF LINES TO SCROLL UP.
E19WUP:	SAVE B
	MOVSI B,(BP)
	CALL VTCPS
	MOVEI B,(Q)
	LSH B,7
	ADD B,BOTLIN
	SUB B,BP
	LSH B,8.
	ADD B,[.BYTE 7 ? 33 ? "s ? 100 ? 37]
	HRROI A,B
	CALL %PSOUT
	JRST POPBJ

; ARGUMENTS:
;   BP		STARTING LINE OF REGION.
;   BOTLIN	LAST LINE OF REGION.
;   Q		NUMBER OF LINES TO SCROLL UP.
E19WDN:	SAVE B
	MOVSI B,(BP)
	CALL VTCPS
	MOVN B,Q
	ADDI B,100
	LSH B,7
	ADD B,BOTLIN
	SUB B,BP
	LSH B,8.
	ADD B,[.BYTE 7 ? 33 ? "s ? 0 ? 37]
	HRROI A,B
	CALL %PSOUT
	JRST POPBJ
] ;IFN E19
] ;IFN HEATH\E19

IFN MIME2A,[
MI2ATB:	42.*1000+24.,,79.	; DISPATCH VECTOR FOR MIME-2A EMULATING A VT52
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)	; NO %TOCID OR %TOLID, BUT CODE IS
					;HERE IF USER WANTS TO TURN IT ON (IF
					;HE IS ON A VERY SLOW TERMINAL!)
	CALL VTCPS
	CALL VTCEOL
	CALL MICEOS		; REQUIRES LOTS OF PADDING
	CALL MICLRS		; REQUIRES SOME PADDING 
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL MI2AIL		; REQUIRES UP TO 1/2 SECOND PADDING!
	CALL MI2ADL		;   DITTO
	CALL MI2AIC		; BEEPS EACH TIME
	CALL MI2ADC
REPEAT 5,JFCL
	CALL MI2AVI
	CALL MI2AVC
	
MI2AIL:	SKIPA A,[^A]
MI2ADL:	MOVEI A,^W
	SAVE A
	SAVE B
	HRLZ B,BP
	CALL VTCPS		; POSITION FOR I/D LINE
MI2ALN:	MOVE A,-1(P)		; THE CODE TO SEND
	CALL %PBOUT
	MOVEI A,25.		; COMPUTE NUMBER OF LINES TO MOVE
	SUBI A,(BP)		;   24-(BP)
	IMULI A,21.		; MILLISECS PER LINE
	CALL TIMPAD
	SOJG Q,MI2ALN
	JRST POPBAJ

MI2AIC:	MOVEI A,^O
	CALL %PBOUT
	CALL OUTNSP
	SKIPA A,[^H]		; ANY CONTROL CHAR ENDS INSERT MODE
MI2ADC:	MOVEI A,^N
	JRST OUTN

MI2AVI:	SKIPA A,["8]
MI2AVC:	MOVEI A,"9
	JRST OUTESC

MICEOS:	MOVEI A,"J
	CALL OUTESC
	MOVEI A,9600		; AT 9600 BAUD, THE PADDING IS RIDICULOUS
	CAML A,OSPEED
	 SKIPA A,[200.]		; EMPIRICALLY DETERMINED
	MOVEI A,14		; BUT AT SLOWER SPEED (1200), IT IS REASONABLE
	JRST MI2PAD		; GO PAD

MICLRS:	MOVEI A,^L
	CALL %PBOUT
	MOVEI A,27.		; ABOUT 26 PAD CHARS AT 9600
MI2PAD:	SAVE B
	CALL TIMPAD		; CLOBBERS B
	JRST POPBJ
	
] ; MIME2A

IFN BUR80,[
SUBTTL BUR80			;Cal Tech modified Burroughs TD850.

BUR80T: 24.,,79.	;Dispatch vector for modified Burroughs TD850
        (%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL BUINSL
	CALL BUDELL
	CALL BUINSC
	CALL BUDELC
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL

;Insert and delete line for Burroughs terminal
BUINSL: SKIPA A,["F]	    ;$F - Insert line
BUDELL: MOVEI A,"E	    ;$E - Delete line
	SAVE A
	MOVEI A,"Y
	CALL OUTESC
	MOVEI A,40(BP)
	CALL %PBOUT
	MOVEI A,40
	CALL %PBOUT                ;move to start of line pointed to by BP 
BUINS1: MOVE A,(P)	     ;get back the command letter
	CALL OUTESC	     ;send <esc><command letter>
	SOJG Q,BUINS1	     ;repeat Q times
	JRST POPAJ

BUINSC: HRROI A,[.BYTE 7 ? 33 ? "L ? 0]	;insert character
	CALL %PSOUT		     ;do insert
	SOJG Q,BUINSC        ;loop as needed
	RET

BUDELC: HRROI A,[.BYTE 7 ? 33 ? "C ? 33 ? "G ? 0]  ;delete char
	CALL %PSOUT	             ;move right, delete char
	SOJG Q,BUDELC
	RET

]       ;BUR80

VTCPS:	JUMPE B,[MOVEI A,"H	;HOME IS EASY
		JRST OUTESC]
	SAVE B
	HLRZ A,B
	LSH A,7
	ADDI A,(B)
	LSH A,8
	MOVE B,A
	ADD B,[.BYTE 7 ? 33 ? "Y ? 40 ? 40]
	HRROI A,B
	CALL %PSOUT
	JRST POPBJ

VTCEOL:	MOVEI A,"K		;CLEAR EOL
	JRST OUTESC

VTCLRS:	MOVEI A,"H		;CLEAR SCREEN
	CALL OUTESC
VTCEOS:	MOVEI A,"J		;CLEAR EOS
	CALL OUTESC
	SAVE C
	MOVE A,RGETTY
	CAIE A,VT61I
	 CAIN A,VT52I		;REAL VT52 NEEDS PADDING AFTER CLEAR SCREEN
	  TDZA C,C
	   JRST POPCJ
	SKIPN A,OSPEED		;ABOVE 4800 BAUD, TO AVOID ^S^Q LOSSAGE.
	 MOVEI A,DEFOSP
	CAIN A,9600.
	 MOVEI C,26.		;26 RUBOUTS AT 9600 BAUD, 5 AT 4800
	CAIN A,4800.		;(EMPIRICALLY DETERMINED.  DON'T ASK ME WHY).
	 MOVEI C,5
	SKIPE A,C
	 CALL EXPPAD
	JRST POPCJ

VTDSMV:	SAVE B
	MOVEI B,40(BP)
	LSH B,24.+4
	IOR B,[.BYTE 8 ? 0 ? 40 ? 33 ? "K]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "Y]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST VTDSM2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST $Y ? <VPOS><HPOS>$K
	MOVEM B,DISBF1+5
	JRST POPBJ
VTDSM2:	MOVEM A,DISBF1+3	;NEED HPOS TOO, USE $Y ? <VPOS><HPOS>$K ? ...
	MOVEM B,DISBF1+4
	CALL VTDMV1
	JRST POPBJ

VTDMV1:	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,8
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "Y ? 40 ? 40]
	MOVEM A,DISBF1+5	;$Y<VPOS><HPOS>
	RET

;USED FOR INSERT/DELETE LINE ON VARIOUS MODIFIED VT52'S.
;A SHOULD HAVE ADDRESS OF STRING TO OUTPUT.
;B SHOULD HAVE # MSEC PADDING PER OPERATION.
VTIDL:	SAVE A
	SAVE B
	MOVE B,BP
VTIDL2:	CALL VTCPS	;[1] COMMON ENTRY POINT FROM OTHER VT52 LOOKALIKES
VTIDL1:	HRRO A,-1(P)
	CALL %PSOUT
	MOVE A,(P)
	CALL TIMPAD
	SOJG Q,VTIDL1
	JRST POPBAJ
]	;VT52

IFN FOX\OWL\BANTAM,[
SUBTTL FOX AND OWL

IFN FOX,[
FOXTB:	24.,,79.		;DISPATCH VECTOR FOR PERKIN-ELMER FOX
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL FXCPS
	CALL FXCEOL
	CALL FXCEOS
	CALL FXCLRS
	JFCL
	CALL FXDSMV
	CALL FXDMV1
REPEAT 11.,JFCL
];FOX

IFN OWL,[
OWLTB:	24.,,79.		;DISPATCH VECTOR FOR PERKIN-ELMER OWL
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL FXCPS
	CALL FXCEOL
	CALL OWCEOS
	CALL OWCLRS
	JFCL
	CALL FXDSMV
	CALL FXDMV1
	CALL OWINSL
	CALL OWDELL
	CALL OWINSC
	CALL OWDELC
REPEAT 7,JFCL
];OWL

IFN BANTAM,[
BANTB:	24.,,79.		;DISPATCH VECTOR FOR PERKIN-ELMER BANTAM
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL FXCPS
	CALL BTCEOL		; ONLY THESE THREE ARE DIFFERENT
	CALL BTCEOS		; ...
	CALL BTCLRS		; ...
	JFCL
	CALL FXDSMV
	CALL FXDMV1
REPEAT 11.,JFCL
];BANTAM

FXCPS:	JUMPE B,[MOVEI A,"H	;HOME IS EASY
		JRST OUTESC]
	MOVEI A,"X		;ELSE SEND $X
	CALL OUTESC
	HLRZ A,B
	ADDI A,40		;<VPOS>+40
	CALL %PBOUT
	MOVEI A,"Y		;$Y
	CALL OUTESC
	MOVEI A,40(B)		;<HPOS>+40
	CALL %PBOUT
	RET

FXCEOL:	MOVEI A,"I		;CLEAR EOL
	JRST OUTESC

FXCLRS:	MOVEI A,"H		;CLEAR SCREEN
	CALL OUTESC
	MOVEI A,"J		;FOX NEEDS DELAY LIKE VT52
	CALL OUTESC		;TO ALLOW CLEAR TO WORK
	call %TFLSH		;[wew] first do any buffer output
	SKIPN A,OSPEED		;CHECK SPEED
	 MOVEI A,DEFOSP
	CAIG A,2400.		;HIGH SPEED?
	 RET			;NO, EASY WAY
	MOVEI A,100.		;DELAY 100 MSEC
	DISMS			;PADDING MESSES UP THE SCREEN.
	RET

FXCEOS:	MOVEI A,"J		;CLEAR EOS
	JRST OUTESC

IFN OWL,[
OWCLRS:	MOVEI A,"H		;CLEAR SCREEN
	CALL OUTESC
OWCEOS:	MOVEI A,"J		;CLEAR EOS
	CALL OUTESC
	SAVE BP
	MOVEI BP,0		;OWL NEEDS PADDING FOR THIS.
	CALL OWIDPD
	JRST POPBPJ
];OWL

FXDSMV:	SAVE B
	MOVEI B,(BP)		;DESIRED VPOS
	SKIPE A,DISCPH		;DESIRED HPOS = 0?
	 JRST FXDSM2		;NO, MUST GO THERE AFTERWARDS
	LSH B,8+4
	ADD B,[.BYTE 8 ? 33 ? "X ? 40 ? 33]	;$X<VPOS>$
	MOVE A,[.BYTE 8 ? "Y ? 40 ? 33 ? "I]	;Y<HPOS>$I
FXDSM1:	MOVEM B,DISBF1+4
	MOVEM A,DISBF1+5
	JRST POPBJ
FXDSM2:	LSHC A,4
	ADD B,[.BYTE 8 ? 0 ? 33 ? "X ? 40]	;$X<VPOS>
	MOVEM B,DISBF1+3
	MOVE B,[.BYTE 8 ? 33 ? "Y ? 40 ? 33]	;$Y<0>$
	ADD A,[.BYTE 8 ? "I ? 33 ? "Y ? 40]	;I$Y<HPOS>
	JRST FXDSM1

FXDMV1:	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "X]
	MOVEM A,DISBF1+4	;$X
	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,24.
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 40 ? 33 ? "Y ? 40]
	MOVEM A,DISBF1+5	;<VPOS>$Y<HPOS>
	RET

IFN OWL,[
; OWINSL - OUTPUT OWL COMMANDS TO INSERT SEVERAL BLANK LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO INSERT
;   Q	NO. OF LINES TO INSERT
OWINSL:	MOVEI A,"L		; $L - INSERT LINE
	JRST OWDEL1

; OWDELL - OUTPUT OWL COMMANDS TO DELETE SEVERAL LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO DELETE
;   Q	NO. OF LINES TO DELETE
OWDELL:	MOVEI A,"M		; $M - DELETE LINE
OWDEL1:	SAVE B			; SAVE AC
	MOVS B,BP		; HPCPS ARG: LINE NO.,,COLUMN NO.
	SAVE A
	CALL FXCPS		; MOVE TO DESIRED LINE NO.
	REST A
	MOVEI B,33		; ESC
OWID1:	EXCH A,B
	CALL %PBOUT			; OUTPUT ESC
	EXCH A,B
	CALL %PBOUT			; OUTPUT "L" OR "M"
	CALL OWIDPD		;PAD THE INSERT/DELETE.
	SOJG Q,OWID1
	JRST POPBJ

;PAD AN INSERT OR DELETE LINE OPERATION.
;EACH OPERATION REQUIRES 5.6MS PADDING PER LINE MOVED.
;THE VPOS OF THE LINE WE ARE OPERATING ON IS IN BP.
OWIDPD:	SAVE A
	SAVE B			;TIMPAD clobbers this critter
	MOVE A,NVLNS
	SUB A,BP		;NUMBER OF LINES BEING MOVED.
	IMULI A,5*9
	LSH A,-3
	CALL TIMPAD
	REST B
	JRST POPAJ

OWDELC:	HRROI A,[ASCIZ "O"]
	CALL %PSOUT
	SOJG Q,OWDELC
	RET

OWINSC:	HRROI A,[.BYTE 7 ? " ? "N ? 40 ? 177 ? 177 ? 177 ? 177 ? ^H ? 0]
	CALL %PSOUT
	SOJG Q,OWINSC
	RET
];OWL

IFN BANTAM,[
BTCEOS:				; HAVE TO JUST FAKE CLEAR TO EOS WITH CEOL
BTCEOL:	MOVEI A,"I		; CLEAR EOL
	CALL OUTESC		; DO IT
	MOVEI A,20.		; MUST PAD FOR 20 MS
	JRST TIMPAD

BTCLRS:	MOVEI A, "K		; CLEAR SCREEN, NO MOVEMENT NEEDED
	CALL OUTESC		; DO IT
	MOVEI A,44.		; MUST PAD FOR 44 MS
	JRST TIMPAD
]	;BANTAM

]	;FOX, OWL AND BANTAM

IFN INTEXT,[
SUBTTL Interactive Systems INtext (modified OWL-1200)
;I wonder why it's called a modified OWL.
;Perhaps the hardware is similar, but the command codes
;are totally like that of the OWL or anything else.

INTXTB:	24.,,79.		;Dispatch vector for INtext
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL IXCPS		;Postion cursor
	CALL IXCEOL		;Clear to EOL
	CALL IXCEOS		;Clear to EOS
	CALL IXCLRS		;Clear screen
	JFCL			;Slot unused
	CALL IXDSMV		;Move to position and clear
	CALL IXDMV1		;Move to position
	CALL IXINSL		;Insert line(s)
	CALL IXDELL		;Delete line(s)
	CALL IXINSC		;Insert characters
	CALL IXDELC		;Delete characters
	CALL IXRST		;Reset terminal modes
	JFCL			;Scroll up (not yet...)
	JFCL			;Scroll down (not yet...)
	JFCL			;Init terminal (unused)
	JFCL			;Reset display modes (unused)
	JFCL			;Init Inverse character mode (unused)
	JFCL			;Clear Inverse character mode (unused)

;IXCPS - output cursor positioning commands to terminal.
; argument:
;   B	line,,column
IXCPS:	SAVE C
	MOVE C,[.BYTE 7 ? 17]	;Prefix with <SI>
	MOVSS B			;Reverse line and column
	MOVEI A,40(B)		;Get line number
	LSH A,7+7+7+1
	ADD C,A
	HLRZ A,B		;Get column number
	ADDI A,40
	LSH A,7+7+1
	ADD C,A
	HRROI A,C
	CALL %PSOUT
	REST C
	RET

;Clear to end of line
IXCEOL:	HRROI A,[.BYTE 7 ? 26 ? 43 ? 0]
	CALL %PSOUT			;Erase to EOL, then do a <CR> (yuck!)
	SAVE B
	MOVE B,TTLPOS		;Get current position
	CALL IXCPS		;Move back to where we were...
	REST B
	RET

;Clear to end of screen
IXCEOS:	HRROI A,[.BYTE 7 ? 26 ? 43 ? 0]
	CALL %PSOUT			;Clear to EOL, then <CR> (sigh...)
	HLRZ A,TTLPOS		;Get current line no.
	CAIN A,23.		;At last line?
	 JRST IXCEO1		;Yes, don't clear anything else
	HRROI A,[.BYTE 7 ? 12 ? 26 ? 61 ? 17 ? 37+24. ? 37+80. ? 21 ? 0]
	CALL %PSOUT			;Close thru end of screen
	CALL IXPAD		;Send padding
IXCEO1:	SAVE B
	MOVE B,TTLPOS		;Get current position
	CALL IXCPS		;Reposition to where we were...
	REST B
	RET

;Clear screen
IXCLRS:	MOVEI A,14		;Send <FF>
	CALL %PBOUT
	CALL IXPAD		;Send padding
	RET

;Sends padding for Clear to EOS and Clear screen functions
IXPAD:	SAVE C
	MOVE A,OSPEED		;Get baud rate
	SETZ C,
	CAIN A,9600.		;At 9600 baud?
	 MOVEI C,42.		; Yes, use 42 nulls
	CAIN A,4800.		;At 4800 baud?
	 MOVEI C,21.		; Yes, use 21 nulls
	JUMPE C,POPCJ		;None needed at 1200 (hopefully)
	LSH C,7+7+7+1
	ADD C,[.BYTE 7 ? 13 ? 40]
	HRROI A,C
	CALL %PSOUT			;Prefix with repeat setup
	MOVEI A,0
	CALL %PBOUT			;Send null
	JRST POPCJ

;Insert several lines
; arguments:
;   BP	line no. at which to insert
;   Q	no. of lines to insert
IXINSL:	SAVE C
	CALL IXIDPS		;Position and setup repeat
	MOVEI A,20		;Send <DLE> in insert line
	CALL %PBOUT
	REST C
	RET

;Delete several lines
; arguments:
;   BP	line no. at which to delete
;   Q	no. of lines to delete
IXDELL:	SAVE C
	CALL IXIDPS		;Position and setup repeat
	MOVEI A,21		;Send <DC1> to delete line
	CALL %PBOUT
	REST C
	RET

;Go to beginning of line specified in BP, and setup a repeat Q times command
IXIDPS:	MOVE C,[.BYTE 7 ? 17 ? 0 ? 40]	;<SI> <line> <column>
	MOVEI A,40(BP)
	LSH A,7+7+7+1
	ADD C,A			;Add in line number
	HRROI A,C
	CALL %PSOUT
	CAIG Q,1		;enough to use a repeat count?
	 RET
	MOVE C,[.BYTE 7 ? 13]	;Setup for repeat
	MOVEI A,40(Q)
	LSH A,7+7+7+1
	ADD C,A			;Add repeat count
	HRROI A,C
	CALL %PSOUT
	RET

;Delete character(s)
IXDELC:	MOVEI A,22		;Send <DC2> to delete character
	CALL %PBOUT
	SOJG Q,IXDELC		;Non-optimal multicharacter delete
	RET

;Insert character(s)
IXINSC:	HRROI A,[.BYTE 7 ? 26 ? 63 ? 0]	;Send <SYN> 3 to insert space
	CALL %PSOUT
	SOJG Q,IXINSC		;Non-optimal multicharacter insert
	RET

;Calculate commands to move to the specified postion and
;clear the whole line.  Uses 8-bit bytes.
; arguments:
;   BP		line no.
;   DISCPH	column no.
IXDSMV:	SAVE B
	MOVE A,[.BYTE 8 ? 17 ? 40 ? 40 ? 26]
	MOVEI B,(BP)		;get line number
	LSH B,8.
	IOR B,DISCPH		;include column number
	LSH B,8.+4
	IOR A,B
	LSH B,-8.
	IOR B,[.BYTE 8 ? 43 ? 17 ? 40 ? 40]
	MOVEM A,DISBF1+4	;<SI> <line> <column> <SYN>
	MOVEM B,DISBF1+5	; # <SI> <line> <column>
	JRST POPBJ

;IXDMV1 is just like IXDSMV, except that is does not clear.
;Calculate commands to move to the specified position.
; arguments:
;   BP		line no.
;   DISCPH	column no.
IXDMV1:	MOVEI A,(BP)		;Get line number
	LSH A,8.
	IOR A,DISCPH		;include column number
	LSH A,8.+4
	ADD A,[.BYTE 8 ? 17 ? 40 ? 40]
	MOVEM A,DISBF1+5
	RET

;Reset scroll and auto line feed modes
IXRST:	HRROI A,[.BYTE 7 ? 26 ? 65 ? 26 ? 46]
	CALL %PSOUT
	RET

]; INtext

IFN IM3101,[
IM31TB:	24.,,80.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL VTCPS
	CALL FXCEOL
	CALL VTCEOS
	CALL IM31CS
	JFCL
	CALL IM31MV
	CALL VTDMV1
REPEAT 11.,JFCL

IM31CS:	HRROI A,[.BYTE 7 ? 33 ? "L ? 0]
	CALL %PSOUT			;Clear memory
	MOVEI A,50.		;Delay 50 msec
	CALL TIMPAD
	HRROI A,[.BYTE 7 ? "Y ? 40 ? 50 ? 33 ? 60
		 .BYTE 7 ? 33 ? "Y ? 40 ? 60 ? 33
		 .BYTE 7 ? 60 ? 33 ? "Y ? 40 ? 70
		 .BYTE 7 ? 33 ? 60 ? 33 ? "Y ? 40
		 .BYTE 7 ? 100 ? 33 ? 60 ? 33 ? "Y
		 .BYTE 7 ? 40 ? 110 ? 33 ? 60 ? 33
		 .BYTE 7 ? "Y ? 40 ? 120 ? 33 ? 60
		 .BYTE 7 ? 33 ? "Y ? 40 ? 130 ? 33
		 .BYTE 7 ? 60 ? 33 ? "Y ? 40 ? 140
		 .BYTE 7 ? 33 ? 60 ? 15 ? 0]
	CALL %PSOUT			;Set tabs
	RET

IM31MV:	SAVE B
	MOVEI B,40(BP)
	LSH B,24.+4
	IOR B,[.BYTE 8 ? 0 ? 40 ? 33 ? "I]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "Y]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST IM31M2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST $Y ? <VPOS><HPOS>$I
	MOVEM B,DISBF1+5
	JRST POPBJ
IM31M2:	MOVEM A,DISBF1+3	;NEED HPOS TOO, USE $Y ? <VPOS><HPOS>$I ? ...
	MOVEM B,DISBF1+4
	CALL VTDMV1
	JRST POPBJ
];IM3101

IFN DM1520,[
SUBTTL DM1520

DM15TB:	24.,,79.		;DISPATCH VECTOR FOR DATAMEDIA 1520
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL D1CPS
	CALL D1CEOL
	CALL D1CEOS
	CALL D1CLRS
	JFCL
	CALL D1DSMV
	CALL D1DMV1
REPEAT 11.,JFCL

D1CPS:	JUMPE B,[MOVEI A,^Y	;HOME IS EASY
		  CALL %PBOUT
		  RET]
	MOVEI A,^^		;ELSE ^^<HPOS+40><VPOS+40>
	CALL %PBOUT
	MOVEI A,40(B)
	CALL %PBOUT
	HLRZ A,B
	ADDI A,40
D1CP2:	CALL %PBOUT
	RET

D1CEOS:	MOVEI A,^K			;ERASE EOS
	JRST D1CP2			;[
D1CEOL:	MOVEI A,^]			;ERASE EOL
	JRST D1CP2
D1CLRS:	MOVEI A,^L			;ERASE SCREEN
	JRST D1CP2

D1DSMV:	SAVE B
	SETZB A,B
	MOVEI B,(BP)		;DESIRED VPOS
	LSH B,8+4		;[
	ADD B,[.BYTE 8 ? ^^ ? 40 ? 40 ? ^] ]
	SKIPN DISCPH		;DESIRED HPOS = 0?
	 JRST D1DSM2		;YES, DONT NEED SECOND CURSOR ADDRESS THEN
	LSHC A,16.-4
	CALL D1DSM1
	LSH A,4
D1DSM2:	MOVEM A,DISBF1+4
	MOVEM B,DISBF1+5
	JRST POPBJ

D1DSM1:	IOR B,DISCPH
	LSHC A,8.
	IORI B,(BP)
	LSHC A,4
	ADD B,[.BYTE 8 ? 0 ? ^^ ? 40 ? 40]
	RET

D1DMV1:	SAVE B
	SETZB A,B
	CALL D1DSM1
	JRST D1DSM2
]	;DM1520

IFN DM3052,[
DM35TB:	130.*1000+24.,,79.		;DISPATCH VECTOR FOR DATAMEDIA 3000
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL VTCPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL VTDSMV
	CALL VTDMV1
	CALL D5INSL
	CALL D5DELL
	CALL D5INSC
	CALL D5DELC
REPEAT 5,JFCL
	CALL DM5IVI
	CALL DM5IVC

D5DELC:	MOVEI A,"P		;ENTER INSERT MODE
	CALL OUTESC
D5DLC1:	MOVEI A,"D		;DELETE CHAR
	CALL OUTESC
	SOJG Q,D5DLC1		;REPEAT
	MOVEI A,"Q		;LEAVE INSERT MODE
	JRST OUTESC

D5INSC:	MOVEI A,"P
	CALL OUTESC		;ENTER INSERT MODE
	CALL OUTNSP		;INSERT SPACES
	MOVEI A,"Q		;LEAVE INSERT MODE
	CALL OUTESC
	MOVEI A,^H		;BACK OVER THEM.
	JRST OUTN

D5INSL:	SAVE B			;SAVE AC
	MOVS B,BP		;VTCPS ARG
	CALL CURPS1		;MOVE TO LOCATION (MAYBE DM3025 OR DM3052)
	MOVEI A,"P		;TURN INSERT DELETE MODE ON
	CALL OUTESC
D5INL1:	MOVEI A,12		;LINE FEED GETS US INSERT LINE
	CALL %PBOUT
	CALL DM5PAD
	SOJG Q,D5INL1
	MOVEI A,"Q		;TURN OFF INSERT DELETE MODE
	CALL OUTESC
	JRST POPBJ

D5DELL:	SAVE B			;SAVE AC
	MOVS B,BP		;VTCPS ARG
	CALL CURPS1		;MOVE TO LOCATION (MAYBE DM3025 OR DM3052)
	MOVEI A,"P		;TURN INSERT DELETE MODE ON
	CALL OUTESC
D5DL1:	MOVEI A,"A		;<ESC> A DELETES A LINE
	CALL OUTESC
	CALL DM5PAD
	SOJG Q,D5DL1		;MORE LINES...
	MOVEI A,"Q		;TURN OFF INSERT DELETE MODE
	CALL OUTESC
	JRST POPBJ

DM5PAD:	MOVE A,RGETTY
	CAIE A,DM32I		;PADDING REQUIRED FOR I/D LINE ON DM3025
	 RET
	MOVEI A,130.
	JRST TIMPAD

DM5IVI:	SAVE A
	HRROI A,[ASCIZ/O1/]
	CALL %PSOUT
	JRST POPAJ

DM5IVC:	SAVE A
	HRROI A,[ASCIZ/O0/]
	CALL %PSOUT
	JRST POPAJ
]	;DM3052

IFN DM3045,[
SUBTTL DM3045
DM34TB:	24.,,79.		;DISPATCH VECTOR FOR DATAMEDIA 3000
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOCID)	;KNOW HE HAS THESE
	CALL D3CPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL D3DSMV
	CALL D3DMV1
	JFCL
	JFCL
	CALL D3INSC
	CALL D3DELC
REPEAT 7,JFCL

D3CPS:	JUMPE B,[MOVEI A,"H	;HOME IS EASY
		JRST OUTESC]
	MOVEI A,"Y		;ELSE SEND $Y
	CALL OUTESC
	HRRZ A,B
	ADDI A,40		;<HPOS>+40
	CALL %PBOUT
	HLRZ A,B
	ADDI A,40		;<VPOS>+40
	CALL %PBOUT
	RET

D3DSMV:	SAVE B
	MOVEI B,40(BP)
	LSH B,16.+4
	IOR B,[.BYTE 8 ? 40 ? 0 ? 33 ? "K]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "Y]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST D3DSM2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST $Y ? <HPOS><VPOS>$K
	MOVEM B,DISBF1+5
	JRST POPBJ

D3DSM2:	MOVEM A,DISBF1+3	;NEED HPOS TOO, USE $Y ? <HPOS><VPOS>$K ? ...
	MOVEM B,DISBF1+4
	CALL D3DMV1
	JRST POPBJ

D3DMV1:	MOVE A,DISCPH		;DESIRED HPOS
	LSH A,8
	IOR A,BP
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "Y ? 40 ? 40]
	MOVEM A,DISBF1+5	;$Y<HPOS><VPOS>
	RET

D3DELC:	MOVEI A,"B
	CALL OUTESC
	SOJG Q,D3DELC
	RET

D3INSC:	MOVEI A,"R
	CALL OUTESC
	SOJG Q,D3INSC
	RET
]	;DM3045

IFN DM3025,[
SUBTTL DM3025
DM32TB:	24.,,79.		;DISPATCH VECTOR FOR DATAMEDIA 3000
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)	;KNOW HE HAS THESE
	CALL D3CPS
	CALL VTCEOL
	CALL VTCEOS
	CALL VTCLRS
	JFCL
	CALL D3DSMV
	CALL D3DMV1
	CALL D5INSL
	CALL D5DELL
	CALL D32INC
	CALL D32DLC
REPEAT 7,JFCL

D32DLC:	MOVEI A,^H		;DELETE CHAR
D32IDC:	SAVE A
	MOVEI A,"P		;ENTER INSERT MODE
	CALL OUTESC
D3IDC1:	MOVE A,(P)
	CALL %PBOUT
	MOVEI A,6
	SAVE B
	CALL TIMPAD
	REST B
	SOJG Q,D3IDC1		;REPEAT
	MOVEI A,"Q		;LEAVE INSERT MODE
	CALL OUTESC
	JRST POPAJ

D32INC:	SAVE Q
	MOVEI A,40		;INSERT CHAR
	CALL D32IDC
	REST Q
	MOVEI A,^H		;BACK OVER THEM.
	JRST OUTN
]	;DM3025

IFN IMLAC\SIMLAC\IIMLAC,[
SUBTTL IMLAX

IMLCTB:	44.,,88.		;DISPATCH TABLE FOR IMLAX
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID+%TOOVR)
	CALL IMCPS
	CALL IMCEOL
	CALL IMCEOS
	CALL IMCLRS
	JFCL
	CALL IMDSMV
	CALL IMDMV1
	CALL IMINSL
	CALL IMDELL
	CALL IMINSC
	CALL IMDELC
REPEAT 7,JFCL

SIMLTB:	61.,,94.		;DISPATCH TABLE FOR SIMULATED IMLAX
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID+%TOOVR+%TOSAI,,%TPRSC+%TPMTA
	CALL IMCPS
	CALL IMCEOL
	CALL IMCEOS
	CALL IMCLRS
	JFCL
	CALL IMDSMV
	CALL IMDMV1
	CALL IMINSL
	CALL IMDELL
	CALL IMINSC
	CALL IMDELC
	JFCL
	CALL IMLWUP
	CALL IMLWDN
	JFCL
	JFCL
	JFCL
	JFCL

IIMLTB:	45.,,95.		;DISPATCH TABLE FOR SIMULATED IMLAX WITH FCI
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOOVR+%TOSAI+%TOFCI,,%TPRSC
	CALL IMCPS
	CALL IMCEOL
	CALL IMCEOS
	CALL IMCLRS
	JFCL
	CALL IMDSMV
	CALL IMDMV1
	CALL IMINSL
	CALL IMDELL
	CALL IMINSC
	CALL IMDELC
	JFCL
	CALL IMLWUP
	CALL IMLWDN
	JFCL
	JFCL
	JFCL
	JFCL

IMCPS:	MOVEI A,217	;%TDMV0
	CALL IMCEO2
	HLRZ A,B	;VPOS
	CALL %PBOUT
	MOVEI A,(B)	;HPOS
IMCPS2:	CALL %PBOUT
	RET

IMCEOS:	MOVEI A,202	;%TDEOF
IMCEO2:	SAVE A		;<
	MOVEI A,177	;SEND > 200 BY ESCAPING FIRST
	CALL %PBOUT
	REST A
	SUBI A,176	;SEND REST
	JRST IMCPS2
IMCEOL:	MOVEI A,203	;%TDEOL
	JRST IMCEO2
IMCLRS:	MOVEI A,220	;%TDCLR
	JRST IMCEO2

IMINSL:	SKIPA A,[223]	;%TDILP
IMDELL:	MOVEI A,224	;%TDDLP
	SAVE A		;SAVE DESIRED FUNCTION
	MOVEI A,217	;%TDMV0 TO BEGINNING OF DESIRED LINE
	CALL IMCEO2
	MOVEI A,(BP)	;VPOS
	CALL %PBOUT
	MOVEI A,0
	CALL %PBOUT
	REST A		;GET BACK DESIRED FUNCTION
	CALL IMCEO2
	MOVEI A,(Q)	;GET REPEAT COUNT
	JRST IMCPS2

IMLWUP:	SKIPA A,[232]		;%TDRSU
IMLWDN:	 MOVEI A,233		;%TDRSD
	SAVE A
	MOVEI A,217		;%TDMV0 TO THE BEGINNING OF THE DESIRED LINE
	CALL IMCEO2
	MOVE A,BP
	CALL %PBOUT
	MOVEI A,0
	CALL %PBOUT
	REST A
	CALL IMCEO2
	MOVE A,BOTLIN
	SUB A,BP
	CALL %PBOUT
	MOVE A,Q
	JRST IMCPS2

IMINSC:	SKIPA A,[225]	;%TDICP
IMDELC:	MOVEI A,226	;%TDDCP
	CALL IMCEO2
	MOVE A,Q	;NUMBER OF CHARS TO INSERT/DELETE
	JRST IMCPS2

IMDSMV:	SAVE B
	MOVEI B,(BP)
	LSH B,24.+4
	IOR B,[.BYTE 8 ? 0 ? 0 ? 177 ? 203-176]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 177 ? 217-176]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST IMDSM2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST %TDMV0 ? <VPOS><HPOS> %TDEOL
	MOVEM B,DISBF1+5
	JRST POPBJ
IMDSM2:	MOVEM A,DISBF1+3	;HPOS TOO, %TDMV0 ? <VPOS><HPOS> %TDEOL ? ...
	MOVEM B,DISBF1+4

IMDMV1:	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,8
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 177 ? 217-176 ? 0 ? 0]
	MOVEM A,DISBF1+5	;%TDMV0 <VPOS><HPOS>
	RET
];IMLAX

IFN VT05,[
SUBTTL VT05

VT05TB:	20.,,71.		;DISPATCH VECTOR FOR VT05
	(%TOERS+%TOMVB+%TOMVU)	;CANT EVEN DISPLAY LOWERCASE
	CALL V0CPS
	CALL V0CEOL
	CALL V0CEOS
	CALL V0CLRS
	JFCL
	CALL V0DSMV
	CALL V0DMV1
REPEAT 11.,JFCL

;[
V0CPS:	JUMPE B,[MOVEI A,^]	;HOME IS EASY
		 JRST V0EOS2]	;WELL, AS EASY AS ANYTHING ELSE
	MOVEI A,^N
	CALL %PBOUT
	HLRZ A,B
	ADDI A,40
	CALL V0EOS2	;TYPE YPOS+40 AND FILL (MUST FILL IN THE MIDDLE OF IT!)
	MOVEI A,40(B)	;THEN XPOS+40
	CALL %PBOUT
	RET
			;[
V0CLRS:	MOVEI A,^]	;HOME
	CALL V0EOS2	;WITH FILL
V0CEOS:	MOVEI A,^_	;CLEAR EOS
V0EOS2:	CALL %PBOUT
V0FILL:	SETZ A,		;NEEDS 4 NULLS (CANT BE RUBOUTS CAUSE SENT IN MIDDLE
REPEAT 4,CALL %PBOUT		;OF THE CURSOR ADDRESSING)
	RET
V0CEOL:	MOVEI A,^^
	JRST V0EOS2

V0DSMV:	SAVE B
	MOVEI A,40(BP)
	LSH A,16.+4
	TLO A,(.BYTE 8 ? ^N ? 0)
	MOVE B,[.BYTE 8 ? 0 ? 0 ? 40 ? ^^]
	SKIPE DISCPH	;ANY HPOS?
	 JRST V0DSM2	;YES
	MOVEM A,DISBF1+3
	MOVEM B,DISBF1+4
	JRST POPBJ
V0DSM2:	MOVEM A,DISBF1+1
	MOVEM B,DISBF1+2
V0DSM3:	MOVEM A,DISBF1+4
	MOVE B,DISCPH	;GET HPOS
	ADDI B,40
	LSH B,8+4
	MOVEM B,DISBF1+5
	JRST POPBJ

V0DMV1:	SAVE B
	MOVEI A,40(BP)
	LSH A,16.+4
	TLO A,(.BYTE 8 ? ^N ? 0)
	JRST V0DSM3

] ;IFN VT05

IFN TK4025,[
SUBTTL TEKTRONIX 4025S

; BECAUSE OF THE LOOSING FEATURE OF THE 4025 TERMINALS THAT WILL NOT ALLOW IT
; TO INSERT A LINE ABOVE THE TOP LINE, WE HAVE TO FAKE IT INTO THINKING IT
; HAS ONLY 33 LINES, STARTING ONE FROM THE TOP.
TK40TB:	33.,,78.		;DISPATCH TABLE FOR TEKTRONIX 4025
	(%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL TKCPS
	CALL TKCEOL
	CALL TKCEOS
	CALL TKCLRS
	JFCL
	.VALUE
	CALL TKDMV1
	CALL TKINSL
	CALL TKDELL
	CALL TKINSC
	CALL TKDELC
REPEAT 7,JFCL

; TKCPS - OUTPUT TEK4025 CURSOR POSITIONING COMMANDS TO TERMINAL.
; ARGUMENT: 
;   B	LINE,,COLUMN

TKCPS:	JUMPE B,[HRROI A,[ASCIZ /`UP34;`DOW;/]
		 JRST TKCLR2]	;IF HOME, BE SURE TO RESYNCH
	SAVE B			;SAVE DESIRED POSITION
	SAVE TTLPOS		;WHERE WE ARE NOW.
	HLRZ B,TTLPOS		;JUST ROW
	CAIL B,28.		;CAN'T TRUST IT IF AT MODE LINE OR BELOW
	 JRST TKCPS8		;SO USE FUDGED ABSOLUTE
	HLRZ A,-1(P)		;GET NEW
	SUBI B,(A)		;GET OLD-NEW
	JUMPE B,TKCPS1		;NO DIFF THERE
	HRROI A,[ASCIZ /`DOW/]	;ASSUME NEGATIVE => DOWN
	SKIPL B
	 HRROI A,[ASCIZ /`UP/]	;POSITIVE => UP
	CALL %PSOUT
	CALL TKCPS7
TKCPS1:	REST B			;GET BACK OLD
	ANDI B,-1		;JUST COL
	HRRZ A,(P)		;GET NEW
	SUBI B,(A)
	JUMPE B,POPBJ
	JUMPE A,[MOVEI A,^M	;FASTER IF GOING TO BEGINNING OF LINE
		 CALL %PBOUT
		 JRST POPBJ]
	HRROI A,[ASCIZ /`RIG/]	;ASSUME NEGATIVE => RIGHT
	SKIPL B
	 HRROI A,[ASCIZ /`LEF/]
	CALL %PSOUT
	CALL TKCPS7
	JRST POPBJ

TKCPS7:	MOVM A,B
	SOJE A,TKCPS3
TKCPS2:	CALL TKCPS4
TKCPS3:	MOVEI A,";
	CALL %PBOUT
	RET

TKCPS4:	SAVE [CALL %PBOUT]
TKCPS5:	SAVE B
	AOJ A,			;OFFSET TO 1,1 AS ORIGIN
	IDIVI A,10. 
	JUMPE A,TKCPS6
	MOVEI A,"0(A)
	XCT -1(P)
TKCPS6:	MOVEI A,"0(B)
	XCT -1(P)
	JRST POPBAJ

TKCPS8:	
	HRROI A,[ASCIZ /`UP34;/]
	CALL %PSOUT
	REST B			;POP OFF OLD STUFF
	HLRZ B,(P)		;GET LINE
	AOJ B,			;THE REAL LINE IS ONE LOWER
	HRROI A,[ASCIZ /`DOW/]
	CALL %PSOUT
	CALL TKCPS7
TKCPS9:	HRRZ B,(P)
	JUMPE B,POPBJ
	HRROI A,[ASCIZ /`RIG/]
	CALL %PSOUT
	CALL TKCPS7
	JRST POPBJ


TKCEOS:				; CLOSE ENOUGH FOR MOST THINGS
TKCEOL:	JSR SAVABC		; SAVE ACs
	SKIPGE C,EOLFLG		; NO. OF SPACES SET?
	 JRST TKCEO1		; YES, USE THAT
	HRRZ C,TTLPOS		; GET CURRENT POSITION
	SUBI C,79.		; MAKE HPOS-79 FOR NEGATIVE COUNT
TKCEO1:	HRROI B,SPACES
	MOVEI A,.PRIOU
	SOUT
	SETZM EOLFLG
	MOVEI A,^M
	CALL %PBOUT			; BACK TO LEFT
	HRRZ B,TTLPOS		; GET BACK OLD POS
	JUMPE B,POPCBA
	HRROI A,[ASCIZ /`RIG/]
	CALL %PSOUT
	CALL TKCPS7
	JRST POPCBA

TKCLRS:	HRROI A,[ASCIZ /`ERA;/]
TKCLR2:	CALL %PSOUT
	RET

TKINSC:	HRROI A,[ASCIZ "`ICH;"]
	CALL %PSOUT
	CALL OUTNSP
	HRROI A,[ASCIZ "`LEF"]
	CALL %PSOUT
	SOSE A,Q
	 JRST TKCPS2
	JRST TKCPS3

TKDELC:	HRROI A,[ASCIZ /`DCH;/]
	CALL %PSOUT
	SOJG Q,TKDELC
	RET

; TKDELL - OUTPUT TEK4025 COMMANDS TO DELETE SEVERAL LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO DELETE
;   Q	NO. OF LINES TO DELETE

TKDELL:	MOVS B,BP
	CALL TKCPS
	MOVEM B,TTLPOS
	HRROI A,[ASCIZ /`DLI/]
	CALL %PSOUT
	MOVEI A,(Q)
	SOJA A,TKCPS2		;ACCOUNT FOR INCREMENTING THAT WILL BE DONE


; TKINSL - OUTPUT TEK4025 COMMANDS TO INSERT SEVERAL BLANK LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO INSERT
;   Q	NO. OF LINES TO INSERT

TKINSL:	MOVSI B,-1(BP)
	JUMPGE B,.+2
	 MOVEI B,0		; THIS WILL LOSE BUT ITS BETTER THAN NOTHING
	CALL TKCPS
	MOVEM B,TTLPOS
	SKIPN BP		;IF NOT THE TOP LINE, WE CAN SKIP THIS
	 CALL [HRROI A,[ASCIZ /`UP;/]
		CALL %PSOUT		;DON'T ASK, IT IS THE DUMB TERMINAL'S FAULT
		RET]
	HRROI A,[ASCIZ /`ILI/]
	CALL %PSOUT
	MOVEI A,(Q)
	SOS A
	CALL TKCPS2
	HRROI A,[ASCIZ /`UP/]	;REPOSITION CURSOR
	CALL %PSOUT
	MOVEI A,(Q)
	SOJA A,TKCPS2

TKDMV1:	MOVE A,[141000,,DISBF1+1]
	SKIPE DISCPH		;ANY HPOS?
	 MOVE A,[441000,,DISBF1]	;YES, WILL NEED WHOLE BUFFER
	SAVE A
	SAVE B
	MOVE B,TTLPOS
	MOVEI A,^M
	TRNE B,-1		;IF NOT THERE ALREADY...
	 IDPB A,-1(P)		;START AT BEGINNING OF CURRENT LINE
	HLRZS B			;GET CURRENT ROW
	SUBI B,(BP)		;GET OLD-NEW
	JUMPE B,TKDSM5		;ALREADY ON RIGHT LINE
	MOVEI A,[ASCIZ /`DOW /]	;ASSUME NEGATIVE => DOWN
	SKIPL B
	 MOVEI A,[ASCIZ /`UP /]
	CALL TKDSMS
	MOVM A,B
	CALL TKDSMN
	MOVEI A,";
	IDPB A,-1(P)
TKDSM5:	SKIPN DISCPH		;GET HPOS IF ANY
	 JRST POPBAJ
	MOVEI A,[ASCIZ /`RIG /]
	CALL TKDSMS
	MOVE A,DISCPH
	CALL TKDSMN
	MOVEI A,";
	IDPB A,-1(P)
	JRST POPBAJ

TKDSMS:	SAVE B
	HRLI A,440700
TKDSS2:	ILDB B,A
	JUMPE B,POPBJ
	IDPB B,-3(P)
	JRST TKDSS2

TKDSMN:	SOJE A,CPOPJ
	SAVE [IDPB A,-4(P)]
	JRST TKCPS5
]

IFN HP2645,[
SUBTTL HP2645

HPTB:	24.,,79.		;DISPATCH VECTOR FOR HP2645
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL HPCPS
	CALL HPCEOL
	CALL HPCEOS
	CALL HPCLRS
	JFCL
	CALL HPDSMV
	CALL HPDMV1
	CALL HPINSL
	CALL HPDELL
	CALL HPINSC
	CALL HPDELC
ifn stansw,[
	call XICFIX	;turn off insert mode on exit
repeat 3, JFCL		; scrolling regions, initialize
	call XICFIX	;turn off inster mode on temporary exit.
];ifn stansw
.ELSE,[
REPEAT 5,JFCL
]
	CALL HPINVI		;DF FOR THE INVERSE VIDEO STUFF
	CALL HPINVC		;DF 

; HPCPS - OUTPUT HP2645 CURSOR POSITIONING COMMANDS TO TERMINAL.
; ARGUMENT: 
;   B	LINE,,COLUMN

HPCPS:	SAVE A			; SAVE AC
	MOVE A,[440700,,HPBUF]	; HPMOVE ARG: B.P. TO BUFFER
	CALL HPMOVE		; GET COMMANDS TO DO CURSOR MOVEMENT
	MOVE A,[440700,,HPBUF]	; SEND COMMANDS
	CALL %PSOUT			; ...
	JRST POPAJ


; HPMOVE - CALCULATE HP2645 CURSOR POSITIONING COMMANDS.
; ARGUMENTS:
;   A	B.P. TO OUTPUT BUFFER (UPDATED ON RETURN)
;   B	LINE,,COLUMN

HPMOVE:	SAVE B			; SAVE ACS
	SAVE C			; ...
	JUMPE B,[		; SIMPLE HOME
		MOVEI C,33	; $H WILL DO
		IDPB C,A
		MOVEI C,"H
		IDPB C,A
		JRST HPMOV1
		]
IRP X,,[33,"&,"a]		; SEND THE START OF THE CURSOR POSITIONING
	MOVEI C,X		;  SEQUENCE
	IDPB C,A
TERMIN
	HLRZ B,-1(P)		; GET LINE NO.
	CALL HPNO		; OUTPUT AS DECIMAL NO.
	HRRZ B,-1(P)		; GET COLUMN NO.
	JUMPE B,[		; IF COLUMN NO. IS ZERO THEN USE DIRECT
		MOVEI C,"R	;  CURSOR POSITION FOR LINE NO. ONLY
		IDPB C,A
		MOVEI C,^M	; THEN FOLLOW WITH A CR
		IDPB C,A	; ...
		JRST HPMOV1
		]
	MOVEI C,"r		; TERMINATE LINE NO.
	IDPB C,A		; ...
	CALL HPNO		; OUTPUT COLUMN NO. AS DECIMAL NO.
	MOVEI C,"C		; TERMINATE COLUMN NO.
	IDPB C,A		; ...
HPMOV1:	MOVEI C,0		; TERMINATE WITH A NULL
	IDPB C,A		; ...
	REST C			; RESTORE ACS
	JRST POPBJ

; INTERNAL SUBROUTINE - OUTPUT B AS DECIMAL NO.
HPNO:	IDIVI B,10.		; CONVERT TO TENS AND ONES DIGITS
	JUMPE B,HPN1		; SKIP TENS DIGIT IF ZERO
	ADDI B,"0		; CONVERT TENS DIGIT TO ASCII
	IDPB B,A		; OUTPUT TENS DIGIT
HPN1:	ADDI C,"0		; CONVERT ONES DIGIT TO ASCII
	IDPB C,A		; OUTPUT ONES DIGIT
	RET


; HPCEOL - OUTPUT HP2645 COMMANDS TO CLEAR TO END OF LINE.

HPCEOL:	MOVEI A,"K
	JRST OUTESC


; HPCEOS - OUTPUT HP2645 COMMANDS TO CLEAR TO END OF SCREEN.

HPCEOS:	MOVEI A,"J
	JRST OUTESC


; HPCLRS - OUTPUT HP2645 COMMANDS TO CLEAR THE SCREEN.

HPCLRS:	HRROI A,[ASCIZ "HJ"]
	CALL %PSOUT
	RET


; HPINSL - OUTPUT HP2645 COMMANDS TO INSERT SEVERAL BLANK LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO INSERT
;   Q	NO. OF LINES TO INSERT

HPINSL:	MOVEI A,"L		; $L - INSERT LINE
	JRST HPDEL1


; HPDELL - OUTPUT HP2645 COMMANDS TO DELETE SEVERAL LINES.
; ARGUMENTS:
;   BP	LINE NO. AT WHICH TO DELETE
;   Q	NO. OF LINES TO DELETE

HPDELL:	MOVEI A,"M		; $M - DELETE LINE
HPDEL1:	SAVE B			; SAVE AC
	MOVS B,BP		; HPCPS ARG: LINE NO.,,COLUMN NO.
	CALL HPCPS		; MOVE TO DESIRED LINE NO.
	MOVEI B,33		; ESC
HPID1:	EXCH A,B
	CALL %PBOUT			; OUTPUT ESC
	EXCH A,B
	CALL %PBOUT			; OUTPUT "L" OR "M"
	SOJG Q,HPID1
	JRST POPBJ		; RESTORE AC

HPDELC:	MOVEI A,"P
	CALL OUTESC
	SOJG Q,HPDELC
	RET

HPINSC:	jumpl	Q,HPINSO	; <0 implies turn off insert mode >
	skiple	INSCNT		;note that we should be called only
	 call	XICFIX		;when INSCNT is 0!
	movem	Q,INSCNT	;increment count of chars to be inserted
	skipe	INSFLG		;check whether we are still in insert mode
	 ret
	MOVEI A,"Q
	setom	INSFLG
	jrst OUTESC
HPINSO:	movei 	A,"R		;turn off insert mode 
	setzm	INSFLG		;no longer in insert mode
	setzm	INSCNT		;0 chars (as opposed to -1, so ADDM will work!)
	jrst	OUTESC

; HPDSMV - CALCULATE HP2645 COMMANDS TO MOVE TO THE SPECIFIED POSITION AND
; CLEAR THE WHOLE LINE.  THE COMMANDS ARE PUT IN DISBF1, AS CLOSE TO DISBUF
; AS POSSIBLE.  8 BIT BYTES ARE USED.

; ARGUMENTS:
;   BP		LINE NO.
;   DISCPH	COLUMN NO.

HPDSMV:	JSR SAVABC		; SAVE ACS
	MOVE A,[441000,,HPBUF]	; HPMOVE ARG: B.P. TO BUFFER
	HRLZ B,BP		; HPMOVE ARG: LINE NO.,,COLUMN NO.
	CALL HPMOVE		; MOVE TO BEGINNING OF SPECIFIED LINE
	MOVEI B,33		; CLOBBER TERMINATING ZERO BYTE WITH
	DPB B,A			;  AN ESCAPE - 1ST PART OF CLEOL SEQUENCE
	MOVEI B,"K		; PUT IN "K" - 2ND PART OF CLEOL SEQUENCE
	IDPB B,A		; ...
	SKIPN B,DISCPH		; DESIRED COLUMN ZERO?
	 JRST HPDSM1		; YES, ALREADY THERE
IRP X,,[33,"&,"a]		; SEND THE START OF THE CURSOR POSITIONING
	MOVEI C,X		;  SEQUENCE
	IDPB C,A
TERMIN
	CALL HPNO		; OUTPUT COLUMN NO. AS DECIMAL NO.
	MOVEI B,"C		; TERMINATE COLUMN NO. AND CURSOR POSITIONING
	IDPB B,A
HPDSM1:	MOVEI B,0		; TERMINATE WITH ZERO BYTE
	IDPB B,A		; ...
HPDSM2:	SUBI A,HPBUF		; CALCULATE NO. OF BYTES WE'VE GENERATED
	MULI A,4		; (SEE HAKMEM NOTE 165)
	SUBI B,1-4(A)		; ...
	MOVNI A,(B)		; CALCULATE BYTE ADDRESS TO START AT,
	ADD A,[DISBUF*4]	;  I.E. DISBUF*4-NBYTES
	IDIVI A,4		; CONVERT TO B.P.
	HRL A,(B)[441000 ? 341000 ? 241000 ? 141000]	; ...
	MOVE B,[441000,,HPBUF]	; B.P. TO BUFFER
HPDSM3:	ILDB C,B		; GET BYTE FROM HPBUF
	JUMPE C,POPCBA		; ZERO BYTE TERMINATES
	IDPB C,A		; PUT INTO DISBF1
	JRST HPDSM3
	JRST POPCBA


; HPDMV1 IS JUST LIKE HPDSMV, EXCEPT THAT IT DOES NOT CLEAR.

HPDMV1:	JSR SAVABC		; SAVE ACS
	MOVE A,[441000,,HPBUF]	; HPMOVE ARG: B.P. TO BUFFER
	MOVE B,DISCPH		; HPMOVE ARG: LINE NO.,,COLUMN NO.
	HRL B,BP		; ...
	CALL HPMOVE		; MOVE TO SPECIFIED POSITION
	JRST HPDSM2

HPINVI:	SAVE A			;Turn on inverse video.
	HRROI A,[ASCIZ/&dJ/]
	CALL %PSOUT
	JRST POPAJ

HPINVC:	SAVE A			;Turn off inverse video.
	HRROI A,[ASCIZ/&d@/]
	CALL %PSOUT
	JRST POPAJ

];IFN HP2645

IFN I400,[
SUBTTL INFOTON 400

I400TB:	4*1000+24.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOCID+%TOLID)
	CALL I4CPS
	CALL I4CEOL
	CALL I4CEOS
	CALL I4CLRS
	JFCL
	CALL I4DSMV
	CALL I4DMV1
	CALL I4INSL
	CALL I4DELL
	CALL I4INSC
	CALL I4DELC
	CALL I4RST
REPEAT 2,JFCL
	CALL I4INI
	CALL I4RSS
REPEAT 2,JFCL

I4CPS:	MOVEI A,33
	CALL %PBOUT
	JUMPE B,I4CPS8		; SKIP ALL THIS FOR HOMING
	HLRZ A,B		; VERTICAL POS
	AOS A			; USES 1 BASED ADDRESSING
	CALL I4PAR
	HRRZ A,B
	JUMPE A,I4CPS8	
	PUSH P,A
	MOVEI A,";
	CALL %PBOUT
	POP P,A
	AOS A
	CALL I4PAR
I4CPS8:	MOVEI A,"H
	CALL %PBOUT
	RET

I4PAR:	SAVE B
	IDIVI A,10.
	JUMPE A,I4PAR1
	ADDI A,"0
	CALL %PBOUT
I4PAR1:	MOVEI A,"0(B)
	CALL %PBOUT
	JRST POPBJ

I4CEOL:	MOVEI A,"N
	JRST OUTESC

I4CEOS:	HRROI A,"J
	JRST outesc		;[R]

I4CLRS:	HRROI A,[ASCIZ /6h2Q2J6l/] ;[R] set erase all mode, edit field
	CALL %PSOUT			;[R] erase all, reset erase all mode
	SAVE B
	HRLZ B,USZ		; GO TO MORE LINE
	CALL I4CPS
	REST B
	HRROI A,[ASCIZ /7mH/]	;[R] set reverse video; home
	CALL %PSOUT			;[R]
	RET

;Put into DISBF1 code to go to a cursor position and clear the line.
;DSMV puts the code to clear the current line into DISBF1+5, and
;then calls DMV3 to put code to go to the position into DISBF1+4.
;That causes the cursor pos. to happen first, and then the clear line.
I4DSMV:	SAVE C
	MOVEI C,5		; INDEX INTO DISBF1
	MOVE A,[.BYTE 8 ? 33 ? "2 ? "N ] ;clear entire current line
	MOVEM A,DISBF1(C)
	SOS C			; causes position code to go in PREVIOUS word
	JRST I4DMV3		; generate code to cursor position.

;Put into DISBF1 code to go to a cursor position.
I4DMV1:	SAVE C
	MOVEI C,5		; INDEX INTO DISBF1
I4DMV3:	MOVE A,DISCPH		; create second coordinate
	AOS A
	IDIVI A,10.
	LSH A,8
	ADDI A,(B)
	LSH A,8+4
	ADD A,[.BYTE 8 ? "; ? "0 ? "0 ? "H ]
	MOVEM A,DISBF1(C)
	SOS C
	MOVEI A,1(BP)
	IDIVI A,10.
	LSH A,8
	ADDI A,(B)
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "[ ? "0 ? "0 ]	;]
	MOVEM A,DISBF1(C)		
	REST C
	RET

;Note: line operations require roll mode.  Character operations require
; non-roll mode.  Hence we leave it in non-roll mode by default, since
; character operations are done more often and require faster response.
I4INSL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,I4CPS		;POSTION CURSOR TO IT
I4INS1:	HRROI A,[ASCIZ /Q/]
	CALL %PSOUT
	MOVE A,Q		;PUT OUT NUMBER OF LINES
	CALL I4PAR
	MOVEI A,"L		;AND THE INSERT COMMAND
	CALL %PBOUT
	JRST I4PAD

I4DELL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,I4CPS		;POSITION CURSOR TO IT
I4DEL1:	HRROI A,[ASCIZ /Q/]
	CALL %PSOUT
	MOVE A,Q		;PUT OUT NUMBER OF LINES
	CALL I4PAR
	MOVEI A,"M		;DELETE LINES
	CALL %PBOUT
	JRST I4PAD

;I4PAD IS ASSUMED TO BE DONE AFTER A LINE OPERATION, SO IT PUTS OUT
; A $2Q AFTER THE PADDING, TO CLEAR ROLL MODE.  AC Q
; CONTAINS THE NUMBER OF LINES INSERTED OR DELETED.
I4PAD:	MOVEI A,18.		;PAD 16 MSEC.
	IMULI A,(Q)		;TIMES NUMBER OF LINES
	CALL TIMPAD
	HRROI A,[ASCIZ /2Q/]	;PUT BACK IN CHAR MODE
	CALL %PSOUT
	RET

;Insert Q characters - the Q is used in OUTNSP and OUTN, both of which
; garbage A and preserve Q.  We must be in non-roll mode for this.  That
; is true by default.
I4INSC:	HRROI A,[ASCIZ /4h/]
	CALL %PSOUT			;ENTER INSERT MODE
	CALL OUTNSP		;INSERT SPACES
	HRROI A,[ASCIZ /4l/]	;LEAVE INSERT MODE.
	CALL %PSOUT
	MOVEI A,^H		;BACK OVER THEM.
	JRST OUTN

I4DELC:	MOVEI A,"P
	CALL OUTESC
	SOJG Q,I4DELC
	RET

;Reset - clear funny modes for return to monitor.  Set roll mode.
I4RST:	SAVE B
	HRLZ B,USZ
	ADD B,[-1,,79.]		;GO TO CHAR BEFORE MODE LINE
	CALL I4CPS
	REST B
	HRROI A,[asciz /6hJ6lQ /]	;set erase all mode, eos
	CALL %PSOUT			;reset erase all mode, edit display mode
	RET

;Temporary reset - for doing normal monitor read, but leave mode line.
I4RSS:	MOVEI A,"Q
	JRST OUTESC

;Initialize modes - in this case clear roll mode so that char ins/del changes
; only one line.
I4INI:	HRROI A,[ASCIZ /2Q/]	;non-roll mode
	CALL %PSOUT
	RET
] ;IFN I400

IFN I100,[
SUBTTL INFOTON 100

I100TB:	24.,,79.		;DISPATCH VECTOR FOR I100
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID)
	CALL I1CPS
	CALL I1CEOL
	CALL I1CEOS
	CALL I1CLRS
	JFCL
	CALL I1DSMV
	CALL I1DMV1
	CALL I1INSL
	CALL I1DELL
	JFCL
	JFCL
	JFCL
REPEAT 6,JFCL

I1INSL:	SKIPA A,["L]		;$L - INSERT LINE
I1DELL:	MOVEI A,"M		;$M - DELETE LINE
	SAVE A
	MOVEI A,"f
	CALL OUTESC
	MOVEI A,40
	CALL %PBOUT
	MOVEI A,40(BP)
	CALL %PBOUT
I1INS1:	MOVE A,(P)		; GET DESIRED FUNCTION AGAIN
	CALL OUTESC
	SOJG Q,I1INS1
	JRST POPAJ


I1CPS:	JUMPE B,[MOVEI A,"H	;HOME IS EASY
		JRST OUTESC]
	MOVEI A,"f		;ELSE SEND $f
	CALL OUTESC
	MOVEI A,40(B)		;<HPOS>+40
	CALL %PBOUT
	HLRZ A,B
	ADDI A,40		;<VPOS>+40
	CALL %PBOUT
	RET

I1CEOL:	MOVEI A,"K		;CLEAR EOL
	JRST OUTESC

I1CLRS:	MOVEI A,"H		;CLEAR SCREEN
	CALL OUTESC
I1CEOS:	MOVEI A,"J		;CLEAR EOS
	JRST OUTESC

I1DSMV:	SAVE B
	MOVEI B,40(BP)
	LSH B,16.+4
	IOR B,[.BYTE 8 ? 40 ? 0 ? 33 ? "K]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "f]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST I1DSM2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST $f ? <HPOS><VPOS>$K
	MOVEM B,DISBF1+5
	JRST POPBJ
I1DSM2:	MOVEM A,DISBF1+3	;NEED HPOS TOO, USE $f ? <HPOS><VPOS>$K ? ...
	MOVEM B,DISBF1+4
	CALL I1DMV1
	JRST POPBJ

I1DMV1:	MOVE A,DISCPH		; GET WANTED HPOS
	LSH A,8
	IORI A,(BP)		;DESIRED VPOS
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "f ? 40 ? 40]
	MOVEM A,DISBF1+5	;$f<HPOS><VPOS>
	RET
]	;I100

IFN TK4023,[
SUBTTL TEKTRONIX 402 (UGH) 3

; Note - this currently runs with the screen (except the mode line) in
; inverse video, for greater readability.  If you don't like this see
; T3CLRS for how to fix it.

TK43TB:	24.,,77.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL T3CPS
	CALL T3CEOL
	CALL T3CEOS
	CALL T3CLRS
	JFCL
	CALL T3DSMV
	CALL T3DMV1
REPEAT 11.,JFCL

T3CPS:	MOVEI A,28.
	CALL %PBOUT
	MOVEI A,41(B)		; X POS
	CALL %PBOUT
	HLRZ A,B		; Y POS
	ADDI A,40
	CALL %PBOUT
	RET

T3CLRS:	JSR SAVABC
	MOVEI A,33		; ESCAPE
	CALL %PBOUT
	MOVEI A,^L		; FORMFEED
	CALL %PBOUT

	MOVSI C,-24.		; AOBJN PTR
T3CLR1:	HRLOI B,(C)		; GO TO X = -1
	CALL T3CPS
	MOVEI A,31.		; SET A PROTECTED ATTRIBUTE
	CALL %PBOUT
	MOVEI A,"J		; NOTE - MAKE THIS "B FOR NON-INVERT SCREEN
	CALL %PBOUT
	AOBJN C,T3CLR1
	SETZ B,			; GO BACK HOME
	CALL T3CPS
	JRST POPCBA

T3DSMV:	SAVE B
	MOVE B,[[.BYTE 8 ? 28. ? 41 ? 40 ? 31.
			   "@ ? 33 ? "O ? 0 
			    0 ? 0 ?  0  ? 28.
			   41 ? 40 ? 40 ? ^H],,DISBF1+2]
	BLT B,DISBF1+5
	MOVE B,DISCPH
	LSH B,8
	ADDI B,(BP)
	LSH B,8+4
	ADDM B,DISBF1+2
	LSH B,8
	ADDM B,DISBF1+5
	JRST POPBJ

T3DMV1:	SAVE B
	MOVE B,DISCPH		; X POS
	LSH B,8.
	ADDI B,40(BP)		; Y POS
	LSH B,4
	ADD B,[.BYTE 8 ? 0 ? 28. ? 41 ? 0]
	MOVEM B,DISBF1+5
	JRST POPBJ

T3CEOS:
T3CEOL:	JSR SAVABC
	HRROI A,[.BYTE 7 ? 31. ? "H ? 33 ? "O]
	CALL %PSOUT
	SKIPN C,OSPEED		; GOTTA PAD?
	 MOVEI C,DEFOSP
	SETZ A,
	CAIL C,4800.
	 HRROI A,[.BYTE 7 ? 1 ? 1]
	CAIL C,9600.
	 HRROI A,[.BYTE 7 ? 1 ? 1 ? 1 ? 1]
	SKIPE A
	 CALL %PSOUT
	MOVE B,TTLPOS		; MUST REPOSITION CURSOR
	CALL T3CPS
	HRROI A,[.BYTE 7 ? 40 ? ^H]
	CALL %PSOUT
	JRST POPCBA

] ;IFN TK4023

IFN ANNARB,[
SUBTTL ANN ARBOR

AATB:	40.,,78.		;DISPATCH TABLE FOR ANN ARBOR
	(%TOMVB+%TOMVU+%TOLWR)
	CALL AACPS		;NOTE: WIDTH MUST BE 78 DUE TO CRETINOUS
	CALL EOLSIM		;AUTO CRLF AND SCROLL AFTER WRITING IN COLUMN 79.
	CALL EOLSIM		;SO THE "!" MUST GO IN COLUMN 78.
	CALL AACLRS
	JFCL
	.VALUE
	CALL AADMV1
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
REPEAT 6,JFCL

; AACPS - OUTPUT ANN ARBOR CURSOR POSITIONING COMMANDS TO TERMINAL.

; ARGUMENT: 
;   B	LINE,,COLUMN

AACPS:	JUMPE B,[MOVEI A,^K	; SIMPLE HOME?
		 CALL %PBOUT		; YES, USE HOME COMMAND INSTEAD OF ABSOLUTE
		 RET]		; POSITIONING
	MOVEI A,^O		; SEND START OF ABSOLUTE CURSOR POSITION
	CALL %PBOUT			; SEQUENCE
	SAVE B			; SAVE LINE,,COLUMN
	MOVEI A,(B)		; GET COLUMN NO.
	IDIVI A,10.		; CONVERT TO FUNNY BCD REPRESENTATION
	LSH A,4			; ...
	IOR A,B			; ...
	CALL %PBOUT			; OUTPUT
	HLRZ A,(P)		; GET LINE NO.
	CAIL A,20.		; THIS IS WEIRD
	 ADDI A,12.		; ...
	ADDI A,100
	CALL %PBOUT
	JRST POPBJ		; RESTORE CURSOR POSITION

AACLRS:	MOVEI A,^L
	CALL %PBOUT
	RET

; AADMV1 - CALCULATE ANN ARBOR COMMANDS TO MOVE TO THE SPECIFIED POSITION
; THE COMMANDS ARE PUT IN DISBF1, AS CLOSE TO DISBUF
; AS POSSIBLE.  8 BIT BYTES ARE USED.

; ARGUMENTS:
;   BP		LINE NO.
;   DISCPH	COLUMN NO.

AADMV1:	SAVE B			; SAVE AC
	MOVE A,DISCPH		; GET COLUMN NO.
	IDIVI A,10.
	LSH A,4
	IORI A,^O_8.(B)
	LSH A,8.
	ADDI A,100(BP)
	CAIL BP,20.
	 ADDI A,12.
	LSH A,4			; SHIFT INTO HIGH 32 BITS OF THE WORD
	MOVEM A,DISBF1+5	; ^O COLUMN LINE
	JRST POPBJ		; RESTORE AC

] ; IFN ANNARB

IFN C100,[
SUBTTL HDS C100
;   SUPPORT FOR THE HUMAN DESIGNED SYSTEMS' CONCEPT-100 AND CONCEPT-APL
; TERMINALS.
;
;   NOTES: THESE TERMINALS MUST BE IN `PROGRAMMER MODE' FOR THINGS LIKE
; CURSOR ADDRESSING TO WORK; WE ALWAYS PUT THE TERMINAL IN THIS MODE,
; WHICH IS THE CORRECT ONE FOR FULL-DUPLEX SYSTEMS, AT EACH SCREEN CLEAR,
; UNDER THE ASSUMPTION THAT THE FIRST USEFUL THING DONE BY EMACS IS TO CLEAR
; THE SCREEN.  LEAVING THE TERMINAL IN THIS MODE CAN'T HURT.
;
;   THE CONCEPT SERIES NEEDS A FAIR AMOUNT OF FILL CHARACTERS FOR MOST
; OF THE MORE COMPLICATED FUNCTIONS; AT WORST, 50 MS. OF FILL WOULD BE
; NEEDED (EG, FOR AN INSERT-CHARACTER FUNCTION AT THE START OF A FULL
; SCREEN).  IN THIS CODE, WE'VE TRIED TO PARAMETRIZE THE FILL FACTOR
; FOR EACH FUNCTION, AND COMPUTE THE ACTUAL AMOUNT OF FILL (NULS ARE
; USED), DEPENDING ON THE SPEED.  NOTE THAT WE CAN ONLY USE 79. COLUMNS
; ON THE CONCEPT, AS PROBLEMS OCCUR WITH LINE FEEDS IF AUTO-CRLF HAS
; HAPPENED ON THE LAST LINE OF THE WINDOW (IT'S TOO UGLY TO DESCRIBE
; HERE).

C100TB:	24.,,78.		; CONCEPT DESCRIPTOR TABLE: SIZE,
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPRSC	; CAPABILITIES,
	CALL CPCPS		; ROUTINES: CURSOR POSITIONING
	CALL CPCEOL		;  CLEAR TO END OF LINE
	CALL CPCEOS		;  CLEAR TO END OF SCREEN
	CALL CPCLRS		;  CLEAR SCREEN
	JFCL			;  UNUSED AS OF NOW.
	CALL CPDSMV		;  SET UP DISBF1 FOR MOVING TO, CLEARING LINE
	CALL CPDMV1		;  DITTO, BUT DON'T DO ANY CLEARING
	CALL CPINSL		;  INSERT SOME LINES
	CALL CPDELL		;  DELETE 'EM, TOO
	CALL CPINSC		;  INSERT A CHAR
	CALL CPDELC		;   AND MAYBE DELETE ONE
	CALL CPTRST		;  RESET THE TERMINAL (RESET WINDOW)
	CALL CPWUP		;  MOVE LINES VIA WINDOWING UP
	CALL CPWDN		;  DOWN
	CALL CPINI		; PUT THE C100 IN PROGRAMMER MODE
	CALL CPTRST		;  RESET THE TERMINAL (RESET WINDOW)
	CALL CPINVI		; ENTER REVERSE VIDEO
	CALL CPINVC		; EXIT REVERSE VIDEO

; FUNCTION CODES (FOR DELAY CALCULATIONS); IF YOU EVER CHANGE THESE, CHANGE
; THE DELAY TABLE IN CPFILC, TOO.

%FCIDL==0			;  INSERT/DELETE LINE
%FCIDC==1			;  I/D CHAR, CLEAR EOL & EOW
%FCCLW==2			;  CLEAR SCREEN WITH ^L

; POSITION CURSOR TO (VERTICAL POSTION,,HORIZONTAL POSTION) IN B

CPCPS:	JUMPE B,[MOVEI A,"?	; GOING HOME IS EASY
		JRST OUTESC ]	; OUTPUT `$?'
	SAVE C			; SAVE WORK REG
	MOVE C, [.BYTE 7 ? 33 ? "a ? 40 ? 40 ? 0] ; BUILD POSITIONER IN C
	HLRZ A, B		; GET VERTICAL POSITION
	LSH A, 7		; MOVE IT INTO POSITION
	IORI A, (B)		; FOLLOWED BY THE HORIZONTAL
	LSH A, 7+1		;  POSITION
	ADD C, A		; DROP IT IN
	HRROI A, C		; FINALLY, OUTPUT IT ALL
	CALL %PSOUT			;  ...
	JRST POPCJ

; CLEAR TO END OF SCREEN

CPCEOS:	MOVEI A,^E		; OUTPUT CLEAR-ALL TO
	CALL OUTESC		;  END OF WINDOW
	PUSH P,[24.]		; WORST CASE ASSUMED
	MOVEI A,%FCIDC		; AND FILL APPROPRIATELY
	CALL CPFILL		;  FOR THIS FUNCTION AND SPEED
	RET			; EVERYONE'S HAPPY

; CLEAR TO END OF LINE

CPCEOL:	MOVEI A,^U		; OUTPUT CLEAR-ALL TO 
	CALL OUTESC		;  END OF LINE
	MOVEI A,%FCIDC		; FILL FOR THIS FUNCTION
	PUSH P,[1]		; NO MULTIPLIER NEEDED
	CALL CPFILL
	RET			; ALL OK

; CLEAR SCREEN ENTIRELY (SEE NOTE ABOVE)

CPCLRS:	HRROI A, [.BYTE 7 ? ^L ? 0]	; CLEAR SCREEN.  ASSUMES
	CALL %PSOUT			; PROGRAMMER MODE IS SET (SEE CPINI)
	MOVEI A, %FCCLW		; DELAY APPROPRIATELY
	PUSH P, [24.]		; ASSUME WORST CASE
	CALL CPFILL
	RET

; CPDSMV - CALCULATE C100 COMMANDS TO MOVE TO THE SPECIFIED POSITION AND
; CLEAR THE WHOLE LINE.  THE COMMANDS ARE PUT IN DISBF1, AS CLOSE TO DISBUF
; AS POSSIBLE.  8 BIT BYTES ARE USED.
; ARGUMENTS:
;   BP		LINE NO.
;   DISCPH	COLUMN NO.

CPDSMV:	SAVE B
	SAVE C
	SAVE D
	MOVEI B,1		; MULITPLIER FOR FILLS
	MOVEI A,%FCIDC		; AND SET UP FOR FILLS
	CALL CPFILC		; COMPUTE FILLS NEEDED
	MOVE D,A		; <PATCH FOR CHANGE IN C1FILC ARG>!!
	SKIPE DISCPH		; DESIRED HPOS = 0
	 ADDI D,4		; NO? COUNT 4 EXTRA CHARS
	CAILE D,18.		; GET MIN D AND 18.
	 MOVEI D,18.		; INTO D (SKIMPS A BIT AT 9600 BAUD)
	MOVNI B,6(D)		; -TOTAL CHAR COUNT INTO B
	ADD B,[DISBUF*4]	; BYTE ADDRESS OF START
	IDIVI B,4		; CONVERT TO BYTE POINTER
	HRL B,[441000 ? 341000 ? 241000 ? 141000](C)
	MOVEI C,33		; START WITH <ESC>
	IDPB C,B
	MOVEI C,"a		; CURSOR ADDRESS
	IDPB C,B
	MOVEI C,40(BP)		; GET DESIRED VPOS
	IDPB C,B
	MOVEI C,40		; HPOS = 0
	IDPB C,B
	MOVEI C,33		; START OF CEOL
	IDPB C,B
	MOVEI C,^U
	IDPB C,B
	JUMPLE D,.+4
	 MOVEI C,177		; USE DEL FOR FILL
	  IDPB C,B
	  SOJG D,.-1		; LOOP BACK
	SKIPE DISCPH		; DESIRED HPOS = 0
	 CALL CPDMV1		; NO? THEN GO THERE
	REST D
	REST C
	JRST POPBJ

; SET UP DISBF1 TO MOVE TO POSITION AS CODED BY (BP, DISCPH); DON'T
; CLEAR ANYTHING.

CPDMV1:	SETZM DISBF1+3		; CLEAR OUT UNUSED PART OF DISPLAY
	SETZM DISBF1+4		;  BUFFER
	MOVEI A, (BP)		; GET VERTICAL POSITION
	LSH A, 8		; MAKE ROOM FOR HORIZONTAL
	IOR A, DISCPH		;  POSITION
	LSH A, 4		; ACCOUNT FOR POSITION OF 4 8.-BIT BYTES
	ADD A, [.BYTE 8 ? 33 ? "a ? 40 ? 40] ; BUILD POSITIONER
	MOVEM A, DISBF1+5	;  AND DROP INTO ITS FINAL RESTING PLACE
	RET			; ALL DONE


; INSERT AND DELETE C(Q) LINES (AT THE VERTICAL POSITION IN BP); ON
; CONCEPT'S, THE CURSOR DOESN'T MOVE.

				; ENTER HERE WITH SCREEN SIZE IN A
CPINSW:	SAVE B			; (USED BY CPWIN ROUTINE ONLY)
	PUSH P, A		; AND PUT IT WHERE USED LATER
	JRST CPINS5		; GO JOIN COMMON CODE

CPINSL:	SAVE B			; SAVE A WORK REG
	PUSH P, [24.]		; AT THIS POINT, ASSUME FULL SCREEN
CPINS5:	MOVEI B, 40(BP)		; FIRST, GO TO THE LINE ASKED FOR
	LSH B, 7+7+1
	ADD B, [.BYTE 7 ? 33 ? "a ? 0 ? 40 ? 0]
	HRROI A, B
	CALL %PSOUT
	POP P,B			; GET WINDOW SIZE INTO B
	SUBI B,(BP)		; AND COMPUTE NUMBER OF LINES BEING MOVED
	ADDI B,1		; +1 FOR LINE CLEARED
CPINS1:	MOVEI A,^R		; FOR EACH LINE TO BE
	CALL OUTESC		; INSERTED, `$^R' DOES IT
	PUSH P,B		; PASS # LINES FOR FILL ACTION
	MOVEI A,%FCIDL		;  AND DELAY APPROPRIATELY
	CALL CPFILL
	MOVEI A,"<		; NOW, GO ONTO NEXT LINE
	CALL OUTESC
	SUBI B,1		; BUMP DOWN NUMBER OF LINES BEING SHOVED DOWN
	SOJG Q,CPINS1		; DO FOR NUMBER OF LINES REQUESTED
	JRST POPBJ

CPDELL:	SAVE B			; SAVE A WORK REG
	MOVEI B, 40(BP)		; FIRST, GO TO THE LINE ASKED FOR
	LSH B, 7+7+1
	ADD B, [.BYTE 7 ? 33 ? "a ? 0 ? 40 ? 0]
	HRROI A, B
	CALL %PSOUT
	MOVEI B,25.		; COMPUTE NUMBER OF LINES
	SUBI B,(BP)		;  BEING AFFECTED
CPDEL1:	MOVEI A,^B		; DELETE A LINE
	CALL OUTESC		; ...
	PUSH P,B		; PASS # LINES FOR FILL ACTION, AND
	MOVEI A,%FCIDL		;  WAIT FOR THIS SLOW
	CALL CPFILL		;  TERMINAL
	SOJG Q,CPDEL1		; DO IT NUMBER OF TIMES REQUESTED
	JRST POPBJ

; INSERT AND DELETE CHARACTER; THE INSERT-CHARACTER WORKS BY ACTUALLY
; ENTERING INSERT MODE, DROPPING IN A SPACE TO MAKE ROOM, AND LEAVING
; INSERT MODE; THEN, MOVE BACK OVER THE SPACE.

CPINSC:	MOVEI A,^P		; ENTER INSERT CHARACTER MODE
	CALL OUTESC		; ...
	SAVE Q			; SAVE INSERT COUNT
CPIC1:	MOVEI A,40		; INSERT SPACES
	CALL %PBOUT			; ...
	MOVEI A,%FCIDC		; FILL FOR THIS FUNCTION
	PUSH P,[1]		; NO MULTIPLIER NEEDED
	CALL CPFILL
	SOJG Q,CPIC1
	REST Q			; RESTORE INSERT COUNT
	MOVEI A,33		; EXIT INSERT CHARACTER MODE
	CALL %PBOUT			; ...
	MOVEI A,0		; ...
	CALL %PBOUT			; ...
	MOVEI A,^H		; BACK OVER INSERTED SPACES
	JRST OUTN		; ...

CPDELC:	MOVEI A,^Q		; DELETE CHARACTER IN LINE
	CALL OUTESC		; ...
	MOVEI A,%FCIDC		; FILL FOR THIS FUNCTION
	PUSH P,[1]		; NO MULTIPLIER NEEDED
	CALL CPFILL
	SOJG Q,CPDELC
	RET

; ROUTINE TO FILL APPROPRIATELY FOR ANY GIVEN FUNCTION
; (AS CODED BY %FCXXX, ABOVE).  THE FUNCTION CODE IS IN A.
; CLOBBERS A.  THE FILL FACTOR (E.G., NUMBER OF LINES AFFECTED) IS
; AT -1(P), AND IS PEELED OFF THE STACK.

CPFILL:	EXCH B,(P)		; GET RETURN ADDRESS, SAVE WORK REG
	EXCH B,-1(P)		; GET FILL FACTOR, SAVE RETURN ADDRESS
	CALL CPFILC		; COMPUTE HOW MANY NULS ARE NEEDED (TO A)
	CALL %TFLSH		;[wew] send any buffered output.
	CALL EXPPD1		; SEND THAT MANY RUBOUTS
	JRST POPBJ


; CPFILC - CALCULATE # OF FILLS REQUIRED FOR C100 AND CAPL
; ARGUMENTS:
;   %FCXX CODE IS IN A (IE. WHAT OPERATION)
;   FILL FACTOR IS IN B (IE. HOW MANY CHARS/LINES AFFECTED)
;   RETURNS RESULT IN A (THE NO. OF NULLS REQ'D)
;
;  %FCIDL==0 CORRESPONDS TO A MULTIPLIER OF .75 (I/D LINE)
;  %FCIDC==1 CORRESPONDS TO A MULTIPLIER OF 4.0 (I/D CHAR, CLEAR EOL & EOW)
;  %FCCLW==2 CORRESPONDS TO A MULTIPLIER OF 0.5 (CLEAR SCREEN WITH ^L)
;  THE FILL FACTOR (FF) CORRESPONDS TO THE NUMBER OF LINES/CHARS. AFFECTED.
;
; NFILL = MULT*FF*OSPEED/(1.E4*(1.0-(0.45+(0.30*OSPEED/9600.))))

CPFILC:	FSC B,233
	FMPR B,(A)[	.00075	;  %FCIDL
			.004	;  %FCIDC
			.0005	;  %FCCLW
			]
	FMPR B,C1PADF
	MOVE A,B
	FADR A,[0.5]
	MULI A,400		; FIX B,A
	ASH B,-243(A)		; ...
	MOVE A,B
	RET

; MOVE LINES AROUND ON SCREEN USING HARDWARE WINDOWING TO WIN ON SPEED.
; (SIGH; THIS CODE WILL PROBABLY BE USELESS WHEN THEY SPEED UP INSERT/
; DELETE LINE).  SEE MOVWIN ROUTINE FOR INPUTS.

CPWDN:	SAVE B			; SAVE WORK REG
	MOVEI B, (BP)		; GET DESTINATION LINE (TOP LINE OF WINDOW)
	MOVE A, BOTLIN		; GET # OF LINES IN
	SUBI A, (B)		;  HARDWARE WINDOW
	CALL CPSETW		; SET UP THE WINDOW
	SETZ BP,		; WANNA INSERT C(Q) LINES AT TOP OF SCREEN
	CALL CPINSW		; GO INSERT THEM
	CALL CPWRST		; RESET THE HARDWARE WINDOW TO WHOLE SCREEN
	JRST POPBJ		; RESTORE B AND GET OUT

; HERE TO MOVE A GROUP OF LINES UP

CPWUP:	JSR SAVABC
	MOVE B, BP		; GET DESTINATION LINE (TOP OF NEW WINDOW)
	MOVE A, BOTLIN		; GET # OF LINES
	SUBI A, (B)		;  IN WINDOW
	CALL CPSETW		; SET THE WINDOW
	MOVEI B, (A)		; GET # OF LAST LINE IN WINDOW
	SUBI B, 1		;  ...
	HRLZ B, B		; MAKE INTO (VPOS,,HPOS) OF LAST LINE
	CALL CPCPS		; GO THERE
	call %tflsh		;[wew]
	MOVEI A, .PRIOU		; TTY OUT PORT
	HRROI B, [.BYTE 7	; MAKE LOTS OF <LF>S WITH PADDING
		REPEAT 24., ^J ? 177 ? 177 ? 177 ? 177 ? 177 ? 177
		]
	MOVNI C, (Q)		; GET NEGATIVE # OF LINES TO MOVE UP
	IMULI C, 7		; TIME # CHARS PER LINE SHIFT
	SOUT			; SCROLL IT UP WITH <LF>S
	CALL CPWRST		; RESET WINDOW
	JRST POPCBA

; WINDOW-SETTING UTILITY ROUTINES
; SET UP A WINDOW; A/ # OF LINES WANTED ON SCREEN, B/ LINE # OF HOME

CPSETW:	JSR SAVABC		; SAVE WORK REGS
	SAVE D
	SAVE E
	MOVE D,[.BYTE 7 ? 33 ? "v ? 40 ? 40 ? 40]
	MOVE E,[.BYTE 7 ? 80.+40 ? 177 ? 177 ? 177 ? 177]	; GET SKELETON
	LSH B, 7+7+1		; GET STARTING LINE AND
	LSH A, 1		;  LENGTH INTO POSITION
	ADD D, B		; AND DROP THEM IN
	ADD D, A
	MOVEI A, .PRIOU
	HRROI B, D		; NOW SET THE WINDOW
	MOVNI C, 10.
	SOUT
	REST E
	REST D
	JRST POPCBA		; RESTORE WORK REGS

; RESET THE HARDWARE WINDOW TO ITS FULL (?) GLORY

CPWRST:	JSR SAVABC		; SAVE WORK REGS
	MOVEI A,.PRIOU
	HRROI B,[.BYTE 7 ? 33 ? "v ? 40 ? 40 ? 24.+40 ? 80.+40 ? 177 ? 177 ? 177 ? 177]
	MOVNI C,10.
	SOUT			; OUTPUT WINDOW-RESET SEQUENCE
	JRST POPCBA		; ALL DONE


; RESET THE WHOLE TERMINAL, UPON EXIT.

CPTRST:	SAVE B			; SAVE WORK REG
	CALL CPWRST		; RESET THE WINDOW
	MOVE B,TTLPOS		; BACK TO OLD POSITION
	CALL CPCPS		; ...
	JRST POPBJ		; RESTORE B AND GET OUT

;CPINI -- INITIALIZE THE TERMINAL TO PROGRAMMER MODE ON ENTRY
CPINI:	SAVE A
	SAVE B
	HRROI A,[.BYTE 7 ? 33 ? "U ? 0]
	CALL %PSOUT
	SKIPN A,OSPEED		; GET OUTPUT SPEED IN BPS
	 MOVEI A,DEFOSP		; UNKNOWN, USE DEFAULT
	IDIVI A,10.		; CONVERT TO CPS
	FSC A,233		; FLOAT IT
	MOVE B,A
	FDVR B,[-3200.0]	; .3*(OSPEED/960.)
	FADR B,[.55]		; 1.0 - (.45 + .3*(OSPEED/960.))
	FDVR A,B		; OSPEED/(1.0 - (.45 + .3*(OSPEED/960.)))
	MOVEM A,C1PADF		; SAVE FOR USE
	JRST POPBAJ

CPINVI:	SAVE A
	MOVEI A,"D
	CALL OUTESC
	JRST POPAJ
CPINVC:	SAVE A
	MOVEI A,"d
	CALL OUTESC
	JRST POPAJ
] ;C100

IFN VC404,[

SUBTTL VC404

VC44TB:	24.,,79.		;DISPATCH VECTOR FOR VC404
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)	;CANT EVEN DISPLAY LOWERCASE
	CALL VCCPS
	CALL VCCEOL
	CALL VCCEOS
	CALL VCCLRS
	JFCL
	CALL VCDSMV
	CALL VCDMV1
REPEAT 11.,JFCL

VCCPS:	JUMPE B,[MOVEI A,^Y	;HOME IS EASY
		 JRST VCEOS2]	;WELL, AS EASY AS ANYTHING ELSE
	MOVEI A,^P
	CALL %PBOUT
	HLRZ A,B
	ADDI A,40
	CALL %PBOUT
	MOVEI A,40(B)
	CALL %PBOUT
	RET

VCCLRS:	MOVEI A,^X	;HOME
	JRST VCEOS2	;WITH FILL

VCCEOS:	MOVEI A,^W	;CLEAR EOS
VCEOS2:	CALL %PBOUT
VCFILL:	SETZ A,		;NEEDS 4 NULLS (CANT BE RUBOUTS CAUSE SENT IN MIDDLE
REPEAT 2,CALL %PBOUT		;OF THE CURSOR ADDRESSING)
	RET

VCCEOL:	MOVEI A,^V
	JRST VCEOS2

VCDSMV:	SAVE B
	MOVEI A,40(BP)
	LSH A,16.+4
	TLO A,(.BYTE 8 ? ^P ? 0)
	IOR A,[.BYTE 8 ? 0 ? 0 ? 40 ? ^V]
	SKIPE DISCPH	;ANY HPOS?
	 JRST VCDSM2	;YES
	MOVEM A,DISBF1+3
	SETZM DISBF1+4
	JRST POPBJ

VCDSM2:	MOVEM A,DISBF1+1
	SETZM DISBF1+2
VCDSM3:	MOVE B,DISCPH	;GET HPOS
	ADDI B,40
	LSH B,8+4
	TDZN A,[.BYTE 8 ? 0 ? 0 ? 377]
	IOR A,B
	MOVEM A,DISBF1+4
	SETZM DISBF1+5
	JRST POPBJ

VCDMV1:	SAVE B
	MOVEI A,40(BP)
	LSH A,16.+4
	TLO A,(.BYTE 8 ? ^P ? 0)
	JRST VCDSM3
] ;IFN VC404

IFN CNCPT,[

SUBTTL CN/CP TERMINAL (INFOTON 130)

CNCPTB:	24.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOCID+%TOLID)
	CALL CNCPS
	CALL CNCEOL
	CALL CNCEOS
	CALL CNCLRS
	JFCL
	CALL CNDSMV
	CALL CNDMV1
	CALL CNINSL
	CALL CNDELL
	CALL CNINSC
	CALL CNDELC
REPEAT 7,JFCL

CNCPS:	JUMPE B,[MOVEI A,"H
		JRST OUTESC]
	MOVEI A,"Y
	CALL OUTESC
	HLRZ A,B		; VERTICAL POS
	CALL CNPAR
	HRRZ A,B
	JRST CNPAR
CNPAR:	SAVE B
	IDIVI A,16.
	CAIL A,10.
	 ADDI A,7		;A HEX DIGIT OF 10. SHOULD BE "A, NOT "9+1.
	ADDI A,"0
	CALL %PBOUT
	CAIL B,10.
	 ADDI B,7		;A HEX DIGIT OF 10. SHOULD BE "A, NOT "9+1.
	MOVEI A,"0(B)
	CALL %PBOUT
	JRST POPBJ

CNCEOL:	MOVEI A,"K
	JRST OUTESC

CNCEOS:	MOVEI A,"J
	JRST OUTESC

CNCLRS:	MOVEI A,14
	CALL %PBOUT
	RET

CNDSMV:	MOVEI C,5		; INDEX INTO DISBF1
	MOVE A,[.BYTE 8 ? 33 ? "K ]
	MOVEM A,DISBF1(C)
	SOS C
	JRST CNDMV3		; ENTER REST OF CODE

CNDMV1:	MOVEI C,5		; INDEX INTO DISBF1
CNDMV3:	MOVE A,DISCPH
	IDIVI A,16.
	CAIL A,10.
	 ADDI A,7		;A HEX DIGIT OF 10. SHOULD BE "A, NOT "9+1.
	LSH A,8
	CAIL B,10.
	 ADDI B,7
	ADDI A,(B)
	LSH A,16.+4
	ADD A,[.BYTE 8 ? "0 ? "0 ]
	MOVEM A,DISBF1(C)
	SOS C
CNDSM2:	MOVEI A,(BP)
	IDIVI A,16.
	CAIL A,10.
	 ADDI A,7
	LSH A,8
	CAIL B,10.
	 ADDI B,7
	ADDI A,(B)
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "Y ? "0 ? "0 ]
	MOVEM A,DISBF1(C)		
	RET

CNINSL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,CNCPS		;POSTION CURSOR TO IT
CNINS1:	MOVEI A,"L
	CALL OUTESC
	PUSHJ P,CNPAD		;PAD THE INSERT
	SOJG Q,CNINS1		;AND LOOP IF MORE TO DO
	RET

CNDELL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,CNCPS		;POSITION CURSOR TO IT
CNDEL1:	MOVEI A,"M		;HAVE TO SWITCH MODES AND BACK
	CALL OUTESC
	PUSHJ P,CNPAD		;PAD FOR THE DELETION
	SOJG Q,CNDEL1		;AND LOOP IF MORE TO DO
	RET

;PAD 16 MSEC
CNPAD:	MOVEI A,16.
	JRST TIMPAD

CNINSC:	HRROI A,[ASCIZ /E /]	;ALTMODE E SPACE BACKSPACE.
	CALL %PSOUT
	SOJG Q,CNINSC
	RET

CNDELC:	MOVEI A,"F
	CALL OUTESC
	SOJG Q,CNDELC
	RET
] ;IFN CNCPT

IFN TVI912\TVI950,[

SUBTTL TVI-912/920/950

IFN TVI912,[
TVITB:	24.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOCID)   ;No %TOLID since too slow.
	CALL TVCPS
	CALL TVCEOL
	CALL TVCEOS
	CALL TVCLRS
	JFCL
	CALL TVDSMV
	CALL TVDMV1
	CALL TVINSL
	CALL TVDELL
	CALL TVINSC
	CALL TVDELC
REPEAT 7,JFCL
];TVI912

IFN TVI950,[
TV5TB:	24.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOCID+%TOLID)
	CALL T5CPS
	CALL T5CEOL
	CALL T5CEOS
	CALL T5CLRS
	JFCL
	CALL TVDSMV
	CALL TVDMV1
	CALL T5INSL
	CALL T5DELL
	CALL TVINSC
	CALL TVDELC
REPEAT 5,JFCL
	CALL TV5INV
	CALL TV5INC

TV5INV:	MOVEI A,"j
	JRST OUTESC

TV5INC:	MOVEI A,"k
	JRST OUTESC
];TVI950

IFN TVI912,[
TVCPS:	JUMPE B,[MOVEI A,36	;IF ADDRESS IS HOME,
		PBOUT		;  SEND ^^
		RET]
	MOVEI A,"=
	CALL OUTESC
	HLRZ A,B
	ADDI A,40
	CALL	%PBOUT
	MOVEI A,40(B)
	CALL	%PBOUT
	JRST TVPAD2

TVCEOL:	MOVEI A,"t
	JRST OUTESC

TVCEOS:	MOVEI A,"y
	CALL OUTESC
	PUSH P,B
	CALL TVPAD2
	JRST POPBJ

TVCLRS:	MOVEI A,"*
	CALL OUTESC

;PAD 1/10 SECOND.
TVPAD2:	MOVEI A,100.
	JRST TIMPAD

TVINSL:	HRLZ B,BP		;GET TO LINE
	CALL TVCPS
TVINS1:	MOVEI A,"E
	CALL OUTESC
	CALL TVPAD
	SOJG Q,TVINS1
	RET

TVDELL:	HRLZ B,BP		;GET TO LINE
	CALL TVCPS
TVDEL1:	MOVEI A,"R
	CALL OUTESC
	CALL TVPAD
	SOJG Q,TVDEL1
	RET

TVDELC:	MOVEI A,"W
	CALL OUTESC
	SOJG Q,TVDELC
	RET

TVINSC:	MOVEI A,"Q
	CALL OUTESC
	SOJG Q,TVINSC
	RET
];TVI912

IFN TVI950,[
T5CPS:	JUMPE B,[MOVEI A,36	;IF ADDRESS IS HOME,
		PBOUT		;  SEND ^^
		RET]
	MOVEI A,"=
	CALL OUTESC
	HLRZ A,B
	ADDI A,40
	CALL	%PBOUT
	MOVEI A,40(B)
	CALL	%PBOUT
	RET

T5CEOL:	MOVEI A,"t
	JRST OUTESC

T5CEOS:	MOVEI A,"y
	CALL OUTESC
	PUSH P,B
	JRST POPBJ

T5CLRS:	MOVEI A,"*
	CALL OUTESC
	RET

T5INSL:	HRLZ B,BP		;GET TO LINE
	CALL T5CPS
T5INS1:	MOVEI A,"E
	CALL OUTESC
	SOJG Q,T5INS1
	RET

T5DELL:	HRLZ B,BP		;GET TO LINE
	CALL T5CPS
T5DEL1:	MOVEI A,"R
	CALL OUTESC
	SOJG Q,T5DEL1
	RET
];TVI950

TVDSMV:	SAVE B
	MOVEI A,40(BP)
	LSH A,8+4
	IOR A,[.BYTE 8 ? 33 ? "= ? 40 ? 40]
	MOVEM A,DISBF1+0
	MOVE A,[.BYTE 8 ? 177 ? 177 ? 177 ? 177]
	MOVEM A,DISBF1+1
	MOVE B,[.BYTE 8 ? 33 ? "t ? 177 ? 177]
	MOVEM B,DISBF1+2
	MOVE B,[.BYTE 8 ? 177 ? 177 ? 177 ? 177]
	MOVEM B,DISBF1+3
	SKIPE B,DISCPH
	CALL TVDMV1
	JRST POPBJ

TVDMV1:	MOVEI A,(BP)
	LSH A,8
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "= ? 40 ? 40]
	MOVEM A,DISBF1+4
	MOVE A,[.BYTE 8 ? 177 ? 177 ? 177 ? 177]
	MOVEM A,DISBF1+5
	RET

IFN TVI912,[
;PAD FOR 1/2 SECOND.
TVPAD:	MOVEI A,500.
	JRST TIMPAD
];TVI912
]  ;TVI912\TVI950

IFN ADM3A,[
SUBTTL ADM3

ADM3TB:	24.,,79.		; DISPATCH TABLE FOR ADM3
	(%TOMVB+%TOMVU+%TOLWR)
	CALL A3CPS
	CALL EOLSIM
	CALL EOLSIM
	CALL A3CLRS
	JFCL
	.VALUE
	CALL A3DMV1
REPEAT 11.,JFCL

; A3CPS - OUTPUT ADM3 CURSOR POSITIONING COMMANDS TO THE TERMINAL.

; ARGUMENT:
;   B	LINE,,COLUMN

A3CPS:	JUMPE B,[MOVEI A,^^	;  SIMPLE HOME?
		 CALL %PBOUT		;  YES, GO HOME INSTEAD
		 RET]		;  OF DIRECT CURSOR MOVE.
	MOVEI A,^[		;] ; START SEQUENCE WITH "ESC"
	CALL %PBOUT			;  AND AN
	MOVEI A,"=		;  "=".
	CALL %PBOUT
	HLRZ A,B		;  GET LINE #
	ADDI A,40		;  ADJUST IT
	CALL %PBOUT			;  AND OUTPUT IT
	HRRZ A,B		;  GET COL #
	ADDI A,40		;  ADJUST IT
	CALL %PBOUT			;  AND OUTPUT THAT
	RET			;  RETURN
	
A3CLRS:	MOVEI A,^Z		;  THIS IS AN EASY ONE
	CALL %PBOUT
	RET			;  RETURN

; A3DSM1 - SUPPOSED TO CALCULATE COMMANDS TO MOVE TO SPECIFIED POSITION 
; AND STORE THEM IN DISBF1 AS CLOSE AS POSSIBLE TO DISBUF.

; ARGUMENTS:							
;   BP		LINE #						
;   DISCPH	COLUMN #					
	
A3DMV1:	MOVEI A,(BP)		;  GET LINE #
	LSH A,8.		;  MOVE IT A BYTE
	IOR A,DISCPH		;  OR IN COLUMN #
	LSH A,4			;  POSITION THEM
	ADD A,[.BYTE 8 ? ^[ ? "= ? 40 ? 40]	;  ADD CONTROLS ;]
	MOVEM A,DISBF1+5	;  AND STORE IT
	RET			;  RETURN

] ; IFN ADM3A

IFN ADM42\IQ120,[

IQ12TB:	24.,,79.	;DISPATCH VECTOR FOR SOROC IQ120.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)
	CALL A42CPS
	CALL A42EOL
	CALL A42EOS
	CALL A42CLR
	JFCL
	CALL A42DMV
	CALL A42DM1
REPEAT 11.,JFCL

ADM42T:	24.,,79.	;DISPATCH VECTOR FOR ADM 42
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL A42CPS
	CALL A42EOL
	CALL A42EOS
	CALL A42CLR
	JFCL
	CALL A42DMV
	CALL A42DM1
	CALL A42INL
	CALL A42DLL
	CALL A42INC
	CALL A42DLC
	CALL A42RST
	JFCL
	JFCL
	CALL A42INI
	CALL A42RST
REPEAT 2,JFCL

A42CPS:	JUMPE B,[MOVEI A,^^	;HOME IS EASY
		CALL %PBOUT
		RET]
	MOVEI A,"=		;ELSE SEND =
	CALL OUTESC
	HLRZ A,B
	ADDI A,40		;<VPOS>+40
	CALL %PBOUT
	MOVEI A,40(B)		;<HPOS>+40
	CALL %PBOUT
	RET

A42EOL:	MOVEI A,"T
	JRST OUTESC

A42EOS:	MOVEI A,"Y
	JRST OUTESC

A42CLR:	MOVEI A,"+		;CLEAR ALL TO SPACES.
	JRST OUTESC

A42DMV:	SAVE B
	MOVEI B,40(BP)
	LSH B,24.+4
	IOR B,[.BYTE 8 ? 0 ? 40 ? 33 ? "T]
	MOVE A,[.BYTE 8 ? 0 ? 0 ? 33 ? "=]
	SKIPE DISCPH		;DESIRED HPOS = 0?
	 JRST A42DM2		;NO, MUST GO THERE AFTERWARDS
	MOVEM A,DISBF1+4	;JUST $= ? <VPOS><HPOS>$T
	MOVEM B,DISBF1+5
	JRST POPBJ

A42DM2:	MOVEM A,DISBF1+3	;NEED HPOS TOO, USE $= ? <VPOS><HPOS>$T ? ...
	MOVEM B,DISBF1+4
	CALL A42DM1
	JRST POPBJ

A42DM1:	MOVEI A,(BP)		;DESIRED VPOS
	LSH A,8
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "= ? 40 ? 40]
	MOVEM A,DISBF1+5	;$=<VPOS><HPOS>
	RET

A42INL:	SKIPA A,["E]		;$E - INSERT LINE
A42DLL:	MOVEI A,"R		;$R - DELETE LINE
	SAVE A
	MOVEI A,"=
	CALL OUTESC
	MOVEI A,40(BP)
	CALL %PBOUT
	MOVEI A,40
	CALL %PBOUT
	REST A			;GET DESIRED FUNCTION AGAIN
A42IN1:	CALL OUTESC
	SAVE A
	MOVE A,NVLNS		;PADDING IS 3 MSEC PER LINE MOVED.
	SUB A,BP		;COMPUTE NUMBER OF LINES MOVED.
IFE STANSW,[
	IMULI A,3
];IFE STANSW
IFN STANSW,[
	IMULI A,10.		;MUST BE 10 MSEC/LINE FOR THE FREEDOM-100
]IFN STANSW
	CALL TIMPAD		;PAD THAT LONG.
	REST A
	SOJG Q,A42IN1		;DO THIS FOR HOWEVER MANY LINES TO INSERT OR DELETE.
	RET

A42DLC:	MOVEI A,"W
	CALL OUTESC
	SOJG Q,A42DLC
	RET

A42INC:	MOVEI A,"Q
	CALL OUTESC
	SOJG Q,A42INC
	RET

A42RST:	RET

A42INI:	MOVEI A,"Z
	JRST OUTESC

] ;END ADM42

IFN FR100\FR200,[
SUBTTL FREEDOM-100 AND FREEDOM-200

;Freedom-100 is a slightly modified ADM-42.  Differences are inverse video
; and an 80 column screen.  A Freedom-200 is the same as a Freedom-100 except
; that no padding is necessary.

FREETB:	24.,,80.		;24 lines, 80 columns
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL A42CPS		;Cursor positioning
	CALL A42EOL		;Clear EOL
	CALL A42EOS		;Clear EOS
	CALL FRDCLR		;Home and clear Screen 
	JFCL			;Unused
	CALL A42DMV		;Clear line and position
	CALL A42DM1		;Position
	CALL A42INL		;Insert line
	CALL A42DLL		;Delete line
	CALL A42INC		;Insert character
	CALL A42DLC		;Delete character
REPEAT 5, JFCL			;(Reset, scroll up, scroll down, init, reset)
	CALL FRDINV		;Set inverse video mode
	CALL FRDNVC		;Set normal video 

FRE2TB:	24.,,80.		;24 lines, 80 columns
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL A42CPS		;Cursor positioning
	CALL A42EOL		;Clear EOL
	CALL A42EOS		;Clear EOS
	CALL FRDCLR		;Home and clear Screen 
	JFCL			;Unused
	CALL A42DMV		;Clear line and position
	CALL A42DM1		;Position
	CALL FR2INL		;Insert line
	CALL FR2DLL		;Delete line
	CALL A42INC		;Insert character
	CALL A42DLC		;Delete character
REPEAT 5, JFCL			;(Reset, scroll up, scroll down, init, reset)
	CALL FRDINV		;Set inverse video mode
	CALL FRDNVC		;Set normal video 

FRDCLR:	MOVEI A,":		;Clear to nulls (faster than spaces)
	JRST OUTESC

FRDINV:	SAVE A
	HRROI A,[ASCIZ/G4/]	;Inverse video
	CALL %PSOUT
	JRST POPAJ

FRDNVC:	SAVE A
	HRROI A,[ASCIZ/G0/]	;Normal video
	CALL %PSOUT
	JRST POPAJ

FR2INL:	SKIPA A,["E]		;$E - Insert line
FR2DLL:	MOVEI A,"R		;$R - Delete line
	SAVE A
	MOVEI A,"=
	CALL OUTESC
	MOVEI A,40(BP)
	CALL %PBOUT
	MOVEI A,40
	CALL %PBOUT
	REST A			;GET DESIRED FUNCTION AGAIN
FR2IN1:	CALL OUTESC
	SOJG Q,A42IN1		;REPEAT FOR ALL LINES (NO PADDING!)
	RET
];IFN FR100\FR200

SUBTTL NIH5200

IFN NIH5200,[
NH52TB:	2000+27.,,79.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL NHCPS
	CALL NHCEOL
	CALL NHCEOL		; CLOSEST WE CAN COME
	CALL NHCLRS
	JFCL
	CALL NHDSMV
	CALL NHDMV1
	CALL NHINSL
	CALL NHDELL
	CALL NHINSC
	CALL NHDELC
REPEAT 7,JFCL

NHCPS:	JUMPE B,NHOME
	MOVEI A,^A		; ELSE ^A <HPOS#177> <VPOS#177>
	CALL %PBOUT
	HRRZ A,B
	XORI A,177
	CALL %PBOUT
	HLRZ A,B
	XORI A,177
NHPBR:	CALL %PBOUT
	RET

NHOME:	HRROI A,[ASCIZ /Q/]
	CALL %PSOUT
	RET

NHCEOL:	HRROI A,[ASCIZ /U/]
NHPSDL:	CALL %PSOUT
	JRST NHMPAD

NHCLRS:	HRROI A,[ASCIZ /Re /]
	CALL %PSOUT
	CALL NHMPAD
	JRST NHOME

NHINSL:	HRLZ B,BP
	CALL NHCPS
NHINL1:	HRROI A,[ASCIZ /M/]
	CALL %PSOUT
	SOJG Q,NHINL1
	RET

NHDELL:	HRLZ B,BP
	CALL NHCPS
NHDEL1:	HRROI A,[ASCIZ /L/]
	CALL NHPSDL
	SOJG Q,NHDEL1
	RET

NHMPAD:	SAVE A
	SAVE B
	MOVEI A,<80.*1440.+2850.>/1000.
	SETZM PADCHR
	CALL TIMPAD
	JRST POPBAJ

NHDSMV:	SAVE B
	MOVE B,[441000,,DISBF1]
	CALL NHDSM1
	MOVEI A,^N
	IDPB A,B
	MOVEI A,"U
	IDPB A,B
	JRST POPBJ

NHDSM1:	MOVEI A,^A
	IDPB A,B
	HRRZ A,DISCPH
	XORI A,177
	IDPB A,B
	HRRZ A,BP
	XORI A,177
	IDPB A,B
	RET

NHDMV1:	SAVE B
	MOVE B,[441000,,DISBF1+4]
	CALL NHDSM1
	SETZ A,
	IDPB A,B
	IDPB A,B
	JRST POPBJ

NHINSC:	HRROI A,[ASCIZ /Y/]
	CALL %PSOUT
	SAVE Q
NHINC1:	MOVEI A,40		; SPACE
	CALL %PBOUT
	SOJG Q,NHINC1
	REST Q
NHINC2:	MOVEI A,^H
	CALL %PBOUT
	SOJG Q,NHINC2
	MOVEI A,^R
	JRST NHPBR

NHDELC:	HRROI A,[ASCIZ /V/]
	CALL %PSOUT
	SOJG Q,NHDELC
	RET
] ; NIH5200

SUBTTL NIH7000

IFN NH7000,[
NH70TB:	28.,,79.		; 28 lines, 79 chars/line
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)	; full display
	CALL N7CPS		; move cursor
	CALL N7CEOL		; clear to EOL
	CALL N7CEOS		; clear to EOS
	CALL N7CLRS		; clear screen, home cursor
	JFCL			; unused
	CALL N7DSMV		; set up DISBF1 for moving to, clearing line
	CALL N7DMV1		; move w/o clearing line
	CALL N7INSL		; insert lines
	CALL N7DELL		; delete line
	CALL N7INSC		; insert character
	CALL N7DELC		; delete character
	JFCL			; reset terminal (to return to EXEC)
	JFCL			; scroll up
	JFCL			; scroll down
	JFCL			; initialize terminal
	JFCL			; reset display modes temporarily
	CALL N7INVI		; init inverse video
	CALL N7INVC		; clear inverse video

N7CPS:	JUMPE B,N7HOME		; position cursor: do home if address [0,0]
	MOVEI A,"_		; ESC-_
	CALL OUTESC
	HRRZ A,B		; column number
	XORI A,377		; complemented...
	CALL %PBOUT
	HLRZ A,B		; line number
	XORI A,377		; complemented...
N7OUT:	CALL %PBOUT
	RET

N7HOME:	MOVEI A,"l		; home cursor: ESC-l
	JRST OUTESC

N7CEOS:	SKIPA A,["X]		; clear EOS: ESC-X
N7CEOL:	 MOVEI A,"U		; clear EOL: ESC-U
	JRST OUTESC

N7CLRS:	MOVEI A,^L		; clear screen: CTRL/L
	JRST N7OUT

N7DELL:	SKIPA A,["S]		; delete line: ESC-S
N7INSL:	 MOVEI A,"T		; insert line: ESC-T
	SAVE A			; save escape command
	HRLZ B,BP		; move cursor to BOL 
	CALL N7CPS
	REST A			; retrieve escape command
N7INL1:	CALL OUTESC
	SOJG Q,N7INL1		; continue until done requested number of lines
	RET

N7DSMV:	SAVE B
	MOVE B,[441000,,DISBF1]
	CALL N7DSM1
	MOVEI A,33
	IDPB A,B
	MOVEI A,"U
	IDPB A,B
	JRST POPBJ

N7DSM1:	MOVEI A,33
	IDPB A,B
	MOVEI A,"_
	IDPB A,B
	HRRZ A,DISCPH
	XORI A,377
	IDPB A,B
	HRRZ A,BP
	XORI A,377
	IDPB A,B
	RET

N7DMV1:	SAVE B
	MOVE B,[441000,,DISBF1+4]
	CALL N7DSM1
	SETZ A,
	IDPB A,B
	IDPB A,B
	JRST POPBJ

N7INSC:	MOVEI A,"Q		; insert character: ESC-Q to enter insert mode
	CALL OUTESC
	SAVE Q			; save requested number of characters
N7INC1:	MOVEI A,<" >		; insert that many spaces
	CALL %PBOUT
	SOJG Q,N7INC1
	REST Q			; restore argument
N7INC2:	MOVEI A,^H		; backspace cursor that many places
	CALL %PBOUT
	SOJG Q,N7INC2
	MOVEI A,"R		; ESC-R to end insert mode
	JRST OUTESC

N7DELC:	MOVEI A,"P		; delete character: ESC-P
	CALL OUTESC
	SOJG Q,.-1		; delete requested number of characters
	RET

N7INVI:	MOVEI A,42		; init inverse video: ESC-"
	JRST OUTESC

N7INVC:	MOVEI A,"*		; clear inverse video: ESC-*
	JRST OUTESC
] ; NH7000

IFN GILL,[
SUBTTL GILLOTINE
GILLTB:	24.,,79.		;0 GILLOTINE DESCRIPTOR TABLE:  SIZE,
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,%TPMTA	; CAPS
	CALL GLCPS		; ROUTINES: CURSOR POSITIONING
	CALL GLCEOL		;  CLEAR TO END OF LINE
	CALL GLCEOS		;4 CLEAR TO END OF SCREEN
	CALL GLCLRS		;  CLEAR SCREEN
	JFCL			;  UNUSED AS OF NOW.
	CALL GLDSMV		;  SET UP DISBF1 FOR MOVING TO, CLEARING LINE
	CALL GLDMV1		;10 DITTO, BUT DON'T DO ANY CLEARING
	CALL GLINSL		;  INSERT SOME LINES
	CALL GLDELL		;  DELETE THEM, TOO
	CALL GLINSC		;  INSERT CHARS
	CALL GLDELC		;14  DELETE SOME CHARS
	CALL GLRST		;  RESET THE TERMINAL (RESET WINDOW)
	JFCL			;CALL GLWUP	;  MOVE LINES VIA WINDOWING UP
	JFCL			;CALL GLWDN	;  DOWN
	CALL GLINI		;20 INITIALIZE
	JFCL			;CALL GLTRST	;  RESET THE TERMINAL
	CALL GLIVI		;  SET STANDOUT
	CALL GLIVC		;  CLEAR STANDOUT
;The GILLOTINE is a modified Hazeltine 1500, 1510, or Mod 1, with a custom
;ROM developed by John T. Gill at Stanford University.
;N.B.  We assume that the Gillotine has an Edit key, although this is
; a separate modification from the custom ROM, and may not be installed on
; all extant Gillotines.
;FUNCTION 2:  CURSOR POSITIONING
GLCPS:	JUMPE B,GLHOM		; SKIP ALL THIS FOR HOMING
	SAVE B			; PROBABLY UNNECESSARY
	MOVSS B
	HLRZ A,B
	LSH A,7
	ADDI A,(B)
	LSH A,7+7+1
	MOVE B,[.BYTE 7 ? ^F ? 40 ? 40 ? 0 ? 0 ]
	ADD B,A			;CREATE STRING IN B
	HRROI A,B
GLPSBJ:	CALL %PSOUT
	JRST POPBJ
;HOME CURSOR
GLHOM:	MOVEI A,^E
GLBOUT:	CALL %PBOUT
	RET
;FUNCTION 3:   CLEAR TO END OF LINE
GLCEOL:	HRROI A,[.BYTE 7 ? 177 ? 177 ? 34 ? 0 ]
	JRST GLSOUT
;FUNCTION 4:   CLEAR TO END OF SCREEN
GLCEOS:	MOVEI A,35
	JRST GLBOUT
;FUNCTION 5:  CLEAR SCREEN
GLCLRS:	HRROI A,[.BYTE 7 ? ^E ? ^Y ? 177 ? 177 ? 177 ? 177 ? 177 ? 0 ]
GLSOUT:	CALL %PSOUT
	RET
;FUNCTION 7:  SET UP DISBF1 FOR MOVING TO, CLEARING LINE
;Put into DISBF1 code to go to a cursor position and clear the line.
GLDSMV:	MOVE A,DISCPH		; create second coordinate
	LSH A,8
	ADDI A,(BP)
	LSH A,4+8.
	ADD A,[.BYTE 8 ? ^F ? 40 ? 40 ? ^X]	; ^F<HPOS><VPOS>^X
	MOVEM A,DISBF1+5	; AND CLOBBER CELL
	RET
;FUNCTION 10:  SET UP DISBF1 FOR MOVING TO LINE, BUT DON'T DO ANY CLEARING
;Put into DISBF1 code to go to a cursor position.
GLDMV1:	MOVE A,DISCPH		; create second coordinate
	LSH A,8
	ADDI A,(BP)
	LSH A,4
	ADD A,[.BYTE 8 ? 0 ? ^F ? 40 ? 40 ]	;^F<HPOS><VPOS>
	MOVEM A,DISBF1+5
	RET
;FUNCTION 11:  INSERT SOME LINES
GLINSL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,GLCPS		;POSTION CURSOR TO IT
	MOVEI A,^W		;AND THE INSERT COMMAND
	JRST GLREP		;PERFORM FUNCTION Q TIMES
;FUNCTION 12:  DELETE SOME LINES
GLDELL:	HRLZ B,BP		;GET TARGET LINE
	PUSHJ P,GLCPS		;POSITION CURSOR TO IT
	MOVEI A,^V		;DELETE LINES
	JRST GLREP		;PERFORM FUNCTION Q TIMES
;FUNCTION 13:  INSERT SOME CHARACTERS AT CURSOR
GLINSC:	MOVEI A,^U		;INSERT SPACES
	JRST GLREP		;PERFORM FUNCTION Q TIMES
;FUNCTION 14:  DELETE SOME CHARACTERS AT CURSOR
GLDELC:	MOVEI A,^T		;DELETE CHARACTERS
	JRST GLREP		;PERFORM FUNCTION Q TIMES
;PERFORM FUNCTION IN A SEVERAL TIMES, BASED ON A REPEAT COUNT FROM
; REGISTER Q.  <^R><40+value Q><value A>
GLREP:	SAVE B
	MOVEI B,(Q)
	LSH B,7
	ADDI B,(A)
	LSH B,7+7+1
	ADD B,[.BYTE 7 ? ^R ? 40 ? 0 ? 0 ? 0 ]
	HRROI A,B
	JRST GLPSBJ
;FUNCTION 15: Reset - clear funny modes for return to monitor.  Set roll mode.
;TAKE TERMINAL OUT OF DISPLAY MODE, AND CLEAR FUNNY STUFF SUCH AS REVERSE
; VIDEO FROM SCREEN.  USED ONLY FOR FAIRLY FINAL EXITS, WHEN THE USER IS
; GOING TO REDISPLAY THE SCREEN IF HE EVER GETS BACK.
GLRST:	HRROI A,[ASCIZ/j/]	; SET ROLL, CLEAR STANDOUT
	JRST GLSOUT
;FUNCTION 16: Temporary reset -- apparently unnecessary. 
;TAKE TERMINAL OUT OF DISPLAY MODE TEMPORARILY FOR :ET COMMAND.
GLTRST:
;FUNCTION 16:   MOVE LINES VIA WINDOWING UP
;SCROLL LINES IN WINDOW FROM BP TO BELOW BOTLIN UP Q LINES.
;Note: it is faster to use I/D line, since the window is full-width.  But
; note that the GILLOTINE supports windows consisting of any rectangular
; region of the screen.
;Sequence would be:
;    <ESC><c><^@><O><40+value BP><40+value BOTLIN><^Q><value Q><^T><ESC><d>
GLWUP:
;FUNCTION 17: SCROLL LINES IN WINDOW FROM BP TO BELOW BOTLIN DOWN Q LINES.
;Note: it is faster to use I/D line, since the window is full-width.  But
; note that the GILLOTINE supports windows consisting of any rectangular
; region of the screen.
;Sequence would be:
;    <ESC><c><^@><O><40+value BP><40+value BOTLIN><^Q><value Q><^S><ESC><d>
GLWDN:	.VALUE			;error!
;FUNCTION 20: Initialize modes
GLINI:	HRROI A,[ASCIZ /di/] ; reset window and home cursor, clear bright,
	JRST GLSOUT		; set roll (nonscroll) mode
;FUNCTION 22: SET STANDOUT
GLIVI:	MOVEI A,^N
	JRST GLBOUT
;FUNCTION 23: CLEAR STANDOUT
GLIVC:	MOVEI A,^O
	JRST GLBOUT
] ;IFN GILL

IFN DG132,[
SUBTTL DG132
DG13TB:	30.,,131.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID)
	CALL DGCPS
	CALL DGCEOL
	CALL DGCEOS
	CALL DGCLRS
	JFCL
	CALL DGDSMV
	CALL DGDMV1
	CALL DGINSL
	CALL DGDELL
	CALL DGINSC
	CALL DGDELC
REPEAT 7,JFCL

DGCPS:	JUMPE B,[MOVEI A,"T
		 JRST OUTESC]
	SAVE B
	MOVEI A,"8
	CALL OUTESC
	HLRZ A,B
	CALL DG1NUM
	HRRZ A,B
	CALL DG1NUM
	JRST POPBJ

DG1NUM:	SAVE B
	ADDI A,1		;ONE BASED ADDRESSING
	IDIVI A,10.
	SAVE B
	IDIVI A,10.
	ADDI A,"0
	CALL %PBOUT
	MOVEI A,"0(B)
	CALL %PBOUT
	REST B
	MOVEI A,"0(B)
	CALL %PBOUT
	JRST POPBJ

DGCEOL:	MOVEI A,"O
	JRST OUTESC

DGCEOS:	MOVEI A,"I
	JRST OUTESC

DGCLRS:	MOVEI A,"H
	JRST OUTESC

DGDSMV:	SAVE C
	MOVEI C,5
	MOVE A,[.BYTE 8 ? 33 ? "O]
	MOVEM A,DISBF1(C)
	SOJA C,DGDMV3

DGDMV1:	SAVE C
	MOVEI C,5
DGDMV3:	MOVEI A,1(BP)
	IDIVI A,10.
	SAVE B			;VERTICAL UNITS
	IDIVI A,10.
	LSH A,8.		;ALIGN VERTICAL HUNDREDS
	IORI A,(B)		;ADD IN VERTICAL TENS
	LSH A,4
	ADD A,[.BYTE 8 ? 33 ? "8 ? "0 ? "0]
	MOVEM A,DISBF1-1(C)	;STORE IN FIRST WORD
	MOVE A,DISCPH
	ADDI A,1
	IDIVI A,10.
	EXCH B,(P)		;SAVE HORIZONTAL UNITS
	SAVE B			;RESAVE VERTICAL UNITS
	IDIVI A,10.
	EXCH A,(P)		;SAVE HORIZONTAL HUNDREDS, GET VERTICAL UNITS
	LSH A,8.		;ALIGN VERTICAL UNITS
	IOR A,(P)		;ADD IN HORIZONTAL HUNDREDS
	LSH A,8.		;ALIGN
	IORI A,(B)		;ADD IN HORIZONTAL TENS
	LSH A,8.
	REST B
	REST B
	IORI A,(B)		;ADD IN HORIZONTAL UNITS
	LSH A,4
	ADD A,[.BYTE 8 ? "0 ? "0 ? "0 ? "0]
	MOVEM A,DISBF1(C)
	JRST POPCJ

DGINSL:	HRLZ B,BP		;GET TO LINE
	CALL DGCPS
DGINS1:	MOVEI A,"3
	CALL OUTESC
	SOJG Q,DGINS1
	RET

DGDELL:	HRLZ B,BP		;GET TO LINE
	CALL DGCPS
DGDEL1:	MOVEI A,"4
	CALL OUTESC
	SOJG Q,DGDEL1
	RET

DGINSC:	MOVEI A,"0
	CALL OUTESC		;ENTER INSERT MODE
	CALL OUTNSP		;INSERT SPACES
	MOVEI A,"5		;LEAVE INSERT MODE
	CALL OUTESC
	MOVEI A,^H		;BACK OVER THEM.
	JRST OUTN

DGDELC:	MOVEI A,"6
	CALL OUTESC
	SOJG Q,DGDELC
	RET
];IFN DG132

SUBTTL VTS VIRTUAL TERMINAL (MIT TWENEX)

IFN VTS,[
IFN 10X\FNX,[
VTSTB==PRINTB			;TREAT AS PRINTING ON 10X
]
IFN 20X,[
VTSTB:	0			;SIZE AND CAPS FILLED IN
	0
	CALL VSCPS
	CALL VSCEOL
	CALL VSCEOS
	CALL VSCLRS
	JFCL 
	CALL VSDSMV
	CALL VSDMV1
REPEAT 2,JFCL			;USE REGION SCROLL
	CALL VSINSC		
	CALL VSDELC
	JFCL
	CALL VSSUP
	CALL VSSDN
REPEAT 4,JFCL	

VSCPS:	PUSH P,C
	MOVE C,B
	MOVE B,[DP%AG1+.VTMOV]
	MOVEI A,.PRIOU
	VTSOP
	POP P,C
	RET

VSCLRS:	HRROI A,[ASCIZ /C/]
	JRST .+3	
VSCEOL:	SKIPA A,[-1,,[ASCIZ /L/]]
VSCEOS:	HRROI A,[ASCIZ /E/]
	CALL %PSOUT
	RET

VSDELC:	SKIPA A,[-1,,[ASCIZ /J/]]
VSINSC:	HRROI A,[ASCIZ /I/]
	PUSH P,A
VSINS0:	MOVE A,(P)
	CALL %PSOUT
	SOJG Q,VSINS0
	POP P,(P)
	RET
	
VSDMV1:	MOVE A,[.BYTE 8 ? 0 ? 0 ? ^P ? "V]
	MOVEM A,DISBF1+4
	JRST VSDSM0

VSDSMV:	MOVE A,[.BYTE 8 ? ^P ? "L ? ^P ? "V]
	MOVEM A,DISBF1+4
	MOVEI A,10(BP)
	LSH A,8.+4
	IOR A,[.BYTE 8 ? ^P ? "V ? 0 ? ^M]
	MOVEM A,DISBF1+3	

VSDSM0:	MOVEI A,10(BP)
	LSH A,24.
	IOR A,DISCPH
	LSH A,4
	ADD A,[.BYTE 8 ? 0 ? ^P ? "H ? 10]
	MOVEM A,DISBF1+5
	RET

VSSDN:	SKIPA B,Q
VSSUP:	 MOVNI B,(Q)
	PUSH P,C
	PUSH P,D
	MOVE C,B
	MOVE D,BOTLIN
	SOJ D,
	HRLI D,(BP)
	MOVE B,[DP%AG1+DP%AG2+.VTLID]
	MOVEI A,.PRIOU
	VTSOP
	POP P,D
	POP P,C
	RET
] ;20X
] ;VTS

IFN ACT4,[

;;; DISPATCH VECTOR FOR ACT-IV TERMINAL.
ACT4TB:	24.,,79.		;  24 LINES, 79 COLS NOT INCLUDING CONTINUATION COLUMN.
	(%TOERS+%TOMVB+%TOMVU+%TOLWR)	; BITS SAYING WHAT TERMINAL CAN DO.
	CALL AC4CPS		; MOVE CURSOR.  B CONTAINS VPOS,,HPOS.  CAN CLOBBER A,B.
	CALL AC4CEL		; CLEAR TO END OF LINE.
	CALL AC4CES		; CLEAR TO END OF SCREEN (NOT VERY IMPORTANT).
	CALL AC4CLS		; CLEAR SCREEN AND HOME CURSOR.
	JFCL			; SLOT NOW UNUSED.
	CALL AC4DMV
	CALL AC4DM1
	REPEAT 4,JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL

;[[ MOVE CURSOR RIGHT NOW TO <VPOS>,,<HPOS> IN B.
AC4CPS:	MOVEI A,^]		;^] TO HOME UP.
	JUMPE B,AC4OUT
	MOVEI A,^T		;^T <VPOS> <HPOS> TO DO ABS POSITION.
	CALL %PBOUT
	HLRZ A,B
	CALL %PBOUT
	HRRZ A,B
	JRST AC4OUT

AC4CEL:	MOVEI A,^^
	JRST AC4OUT

AC4CLS:	SKIPA A,[^L]
AC4CES:	 MOVEI A,^_
AC4OUT:	CALL %PBOUT
	RET

AC4DMV:	CALL AC4DM1		;DEPOSIT COMMANDS TO MOVE CURSOR AND CLEAR LINE
	MOVEI A,^^
	IDPB A,B
	RET

AC4DM1:	MOVE B,[441000,,DISBF1+5]	;DEPOSIT COMMANDS TO JUST MOVE CURSOR.
	MOVEI A,^T
	IDPB A,B
	HRRZ A,BP
	IDPB A,B
	HRRZ A,DISCPH
	IDPB A,B
	RET

] ;ACT4

;;	Adds Viewpoint
;;	Added 27/8/81 by Macrakis@eclb following A42 code

ifn advpt,[

advptb:	24.,,79.	;Dispatch table
	(%toers+%tomvb+%tomvu+%tolwr)	;Isn't there any way to indicate
					; highlighting ability?
	call advcps
	call adveol
	call adveos
	call advlrs
	jfcl
	call advsmv
	call advmv1
	repeat 4,jfcl
	call advrst
	repeat 2,jfcl
	call advini
	jfcl
	call advivi
	call advivc
ifn .-advptb-20., .err Adds viwpoint (Advptb) table wrong size


advcps:
;	jumpe b,[movei a,^A	;Home	;Viewpoint usually used in scroll mode,
;		 jrst pboutret]		; so home is at bottom.
	movei a,"Y
	call outesc
	hlrz a,b
	addi a,40
	call %PBOUT
	movei a,40(b)
pboutret: call %PBOUT			;Standard thing
	ret

adveol:	movei a,"K
	jrst outesc

adveos:	movei a,"k	;Note case difference!
	jrst outesc

advlrs:	movei a,^L
	jrst pboutret

advsmv:	save b
	movei b,40(bp)
	lsh b,3*8+4	;Put row # in 1st byte
;;  We will assemble either $Y# $K$Y## or $Y# $K
	ior b,[.byte 8 ? 0 ? 40 ? 33 ? "K]
	move a,[.byte 8 ? 0 ? 0 ? 33 ? "Y]
	skipe discph	;Col 0?
	 jrst adv001
	movem a,disbf1+4
	movem b,disbf1+5
	jrst popbj

adv001:	movem a,disbf1+3
	movem b,disbf1+4
	call advmv1
	jrst popbj

advmv1:	movei a,(bp)
	lsh a,8
	ior a,discph
	lsh a,4
	add a,[.byte 8 ? 33 ? "Y ? 40 ? 40]
	movem a,disbf1+5
	ret

advivc:
advrst:	movei a,^O
	jrst pboutret

advini:	movei a,"0
	call outesc
	movei a,"`
	jrst pboutret

advivi:	movei a,^N
	jrst pboutret

]	;End of Adds Viewpoint

ifdef ideal,[
ifn IDEAL,[

;Here we define the "IDEAL" terminal, which can do all the EMACS operations
;in a minimum number of characters.  heres the code used:
;
;	|--Byte-1--|-BYTE-2-|-BYTE-3-|		Function
;	|X|CODE|SUB|
;	|X|CODE|CNT|						;CNT= Count-1
;	|X|CODE|SUB|-COUNT--|
;	|X|CODE|-XY-POSIT---|					;25*HPos+YPos
;	|X|CODE|-YY-POSIT---|-COUNT--|				;TOP*25+BOT
;
;	 0				normal ascii output.
;	 1 00    XY-POSIT		Move cursor.
;	 1 01	 XY-POSIT		Move cursor and clear line.
;	 1 02   0			Clear to End of Line.
;	 1 02	1			Clear to End of Page.
;	 1 02	2			Clear all and Home.

;	 1 03	0			Reset terminal.
;	 1 03	1			Reset terminal temporarilly.
;	 1 03	2     Character		Set META prefix character.
;	 1 03	3     "{"		Enter Ideal mode (note= escape { )
;	 1 03	3     "}"		Leave Ideal mode (note= escape } )
;	 1 03	4			Inverse Video On
;	 1 03	5			Inverse Video Off
;	 1 03	6			Insert mode On.
;	 1 03	7			Insert Mode off.

;	 1 04	2     COUNT		Delete N Characters, N > 8.
;	 1 05	CNT			Delete N Characters, N <= 8.
;	 1 06	 YY-POSIT   COUNT	Scroll region Up.
;	 1 07	 YY-POSIT   COUNT	Scroll region Down.
;	 1 10	 XY-POSIT		Insert X lines at Y.
;	 1 11	 XY-POSIT		Delete X lines at Y.
;	 1 12				** Unused **
;	 1 13				** Unused **
;	 1 14				** Unused **
;	 1 15				** Unused **
;	 1 16				** Unused **
;	 1 17				** Unused **

;

IDEALT:	24.,,79.
	%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID,,TP%RSC ;has everything
	CALL IDECPS
	CALL IDECEL
	CALL IDECES
	CALL ideCLR
	JFCL
	CALL ideSMV
	CALL ideMV1
	CALL ideINL
	CALL ideDLL
	CALL ideNSC		;INS CHAR
	CALL ideDLC		;DEL CHAR
	call ideRST		;reset
	call ideRSU
	call ideRSD
	call ideINI		;INIT TERMINAL
	call ideRSS
	CALL ideINV		;Set/reset inverse video mode
	CALL ideIVC

ideCPS:	save B
	hlrz A,B
	tlz B,-1		;isolate HPOS
	imuli B,25.		;HPOS*25
	addi B,210*400(A)	;add in VPOS and code.
ideOUT:	save C
	save Q
	imuli B,2
	hrlz Q,B		;left justify 8 bit bytes
	move B,[441000,,Q]	;8 bit byte pointer
	movei A,.priou
	movni C,2		;2 characters
	sout
	rest Q
	rest C
	rest B
	ret

ideCEL:	movei A,220
	pbout
	ret
ideCEP: movei A,221
	pbout
	ret
ideCLR: movei A,222
	pbout
	ret

;	 1 03	 XY-POSIT		Insert X lines at Y.
;	 1 04	 XY-POSIT		Delete X lines at Y.
ideINL:	save B
	hrrz B,Q		;get X (count of lines to insert)
	imuli B,25.		;count *25
	addi B,230*400(bp)	;add in VPOS and code.
	jrst ideOUT		; output 2 bytes

ideDLL:	save B
	hrrz B,Q		;get X (count of lines to delete)
	imuli B,25.		;count *25
	addi B,240*400(bp)	;add in VPOS and code for Delete line
	jrst ideOUT		; output 2 bytes

ideDLC:	caile Q,4+4		;8 or less chars can be done in one char
	jrst ideDC1
	movei A,260-1(Q)
	pbout
	ret
ideDC1:	save B
	movei B,252*400(Q)	; code for del lines, count in next byte
	jrst ideOUT		; output 2 bytes

idensc:	jumpl	Q,IDENSO	; <0 implies turn off insert mode >
	skiple	INSCNT		;note that we should be called only
	 call	XICFIX		;when INSCNT is 0!
	movem	Q,INSCNT	;increment count of chars to be inserted
	skipe	INSFLG		;check whether we are still in insert mode
	 ret
	setom	INSFLG
	movei	1,236
	pbout
	ret
idenso: movei	1,237
	pbout
	setzm	INSFLG		;no longer in insert mode
	setzm	INSCNT		;0 chars (as opposed to -1, so ADDM will work!)
	ret

;	 1 07	0			Inverse video On.
;	 1 07	1			Inverse Video Off.
ideinv:	movei 1,234
	pbout
	ret
ideinc:	movei 1,235
	pbout
	ret

;	 1 10	 YY-POSIT   COUNT	Scroll region Up.
;	 1 11	 YY-POSIT   COUNT	Scroll region Down.
ideRSU:	push P,B
	move B,BOTLIN		;bottom line of region
	imuli B,25.
	addi B,260*400(BP)	;add top line of region, and code.
	jrst	ide3ch
ideRSD:	push P,B
	move B,BOTLIN		;bottom line of region
	imuli B,25.
	addi B,270*400(BP)	;add top line of region, and code.
ide3ch:	lsh B,8
	addi B,(Q)		;finnally put in count
	save Q
	save C
	move Q,B
	move B,[point 8,11,Q]
	movni C,3
	sout
	REST C
	rest Q
	rest B
	ret

];ifn IDEAL
];ifdef IDEAL

IFN AJ510,[
SUBTTL Anderson Jacobson AJ510
AJ510T: 24.,,79.		;24 lines of 80 columns
	(%TOERS+%TOMVB+%TOMVU+%TOLWR+%TOLID+%TOCID) ;selectively erase, bs, move up, lowercase, line i/d, char i/d
	CALL AJCPS		;Move cursor
	call ajceol		;Clear to end of line
	call ajceos		;Clear to end of screen
	call ajclrs		;Clear screen and home cursor
	jfcl			;not used
	call ajdsmv		;Deposit appropriate 8 bit chars in disbf1...
	call ajmv1		; ditto but don't clear the line
	call ajinsl		;insert lines
	call ajdell		;delete lines
	call ajinsc		;insert character after cursor
	call ajdelc		;delete character
	call ajexit		;reset terminal to normal mode
	jfcl			;scroll up
	jfcl			;scroll down
	call ajinit		;initialize terminal
	jfcl			;reset display modes temporarily
	call ajivi		;inverse character mode
	call ajivc		;clear inverse character mode

ajinit: hrroi a,[asciz /&O&C"J'F"NH/]	;Turn on normal modes
	call %psout
	setom padchr		;use timing as padding
	ret

ajexit: hrroi a,[asciz /&C"J'F"N/]
	call %psout
	ret

ajcps:	jumpe b,[movei a,"H	;Home is easy
		 jrst outesc]
	save b
	hlrz b,b
	save c
	movei c,"B		;Doing vertical position
	call ajcps1
	hrrz b,-1(p)		;Pick b off stack
	movei c,"A
	call ajcps1
	rest c
	jrst popbj

ajcps1: call ajcps2		;Get right thing in c
	save d
	setz d,			;Need a 0-byte
	hrroi a,c		;Pointer to c and d
	call %psout			;Output the string
	rest d			;Restore d
	movei a,3		;Delay 3ms
	jrst timpad

ajcps2:	addi c,33_7		;Start constructing a 7-byte expression starting with escape
	movei a,(b)
	idivi a,100.		;Divide by 100
	lsh c,7
	addi c,"0(a)		;Convert to digit and add in
	movei a,(b)		;Get mod 100
	idivi a,10.		;Get 10s
	lsh c,7
	addi c,"0(a)		;Convert to digit and add in
	lsh c,7
	addi c,"0(B)		;convert to digit and put in A
	lsh c,1			;Offset to make it line up right
	ret

ajceol: movei a,"L		;Clear eol - Output an ESC-'-L
	call ajcext
	movei a,5		;Guess at 5 ms to do this
	jrst timpad

ajclrs: movei a,"H		;Clear screen
	call outesc
ajceos: movei a,"P		;Clear eos - Output an ESC-'-P
	call ajcext
	movei a,15		;Guess at 15ms to do this
	jrst timpad

;Do an extended command
ajcext:	movsi b,(ASCII/'/)	;Like OUTESC but does ESC-'
	dpb a,[170700,,B]
	hrroi a,b
	call %psout
	ret

;;; Stuff a move command into pointer represented by a
;;; Uses 5 bytes
ajcps3: movei d,33
	idpb d,a		;escape
	idpb c,a		;command character
	idivi b,100.
	addi b,"0
	idpb b,a		;100s digit
	move b,c
	idivi b,10.
	addi b,"0
	idpb b,a		;10s digit
	addi c,"0
	idpb c,a		;1s digit
	ret

ajdsmv: save c			;Save c around all this
	save d
	move a,[341000,,disbf1+1]	;We use 18 8-bit bytes
	movei b,(BP)		;Desired VPOS
	movei c,"B
	call ajcps3		;Get code into disbf1 buffer
	setz b,			;Say going to column 0
	movei c,"A
	call ajcps3
	movei b,33		;Give Escape-'-L to clear line
	idpb b,a
	movei b,"'
	idpb b,a
	movei b,"L
	idpb b,a
	jrst ajmv2

;;; Vpos in BP, Hpos in DISCPH, store code to get there in disbf1..disbf1+5
ajmv1:	save d
	save c			;Save c around all this
	move a,[341000,,disbf1+3]	;use a total of 10 bytes
	movei b,(BP)		;Desired VPOS
	movei c,"B
	call ajcps3		;Get code into disbf1...
ajmv2:	movei c,"A		;Going to a column
	move b,DISCPH		;Desired hpos
	call ajcps3		;Code is in disbf1...
	rest c
	rest d
	ret
	
ajinsl:	skipa a,[[ASCIZ /&I/]]	;$&I insert line
ajdell: movei a,[ASCIZ /&D/]	;$&D delete line
	save a
	save c
	movei b,(BP)		;Desired vpos
	movei c,"B
	call ajcps2		;Code into C
	save d			;Save D
	setz d,			;Zero it (for the 0 byte)
	hrroi a,c		;Pointer to c and d
	call %psout			;Go to right line
	rest d
	rest c
ajidl1:	hrro a,(p)		;code to use
	call %psout
	movei a,50		;msecs of padding  (determined emiprically)
	call timpad
	sojg q,ajidl1		;Loop until done
	jrst popaj

ajinsc:	movei a,"I		;Start insert character
	call ajcext		;Esc-'-I
	call outnsp
	movei a,(q)		;Pad that number of msecs
	call timpad
	movei a,^H
	call outn
	movei a,"J		;Stop insert character
	jrst ajcext

ajdelc: movei a,"D		;Delete character
	call ajcext		;Esc-'-D
	sojg q,ajdelc		;Loop until done
	ret

ajivi:	skipa a,["I]		;Turn on inverse video
ajivc:	movei a,"N		;Reset to normal video
	movsi b,(ASCII/"/)	;Like OUTESC but does ESC-'
	dpb a,[170700,,B]
	hrroi a,b
	call %psout
	ret

] ;ifn aj510


OUTNSP:	MOVEI A,40
OUTN:	SAVE Q
	CALL %PBOUT
	SOJG Q,.-1
	REST Q
	RET

;OUTPUT AN ALTMODE FOLLOWED BY THE CHARACTER IN A, PRESERVING ALL ACS.
OUTESC:	SAVE A
	movei A,33
	call %PBOUT
	rest A
	jrst %PBOUT


;PAD WITH A SPECIFIC NUMBER OF RUBOUTS (IN A).
EXPPAD:	SAVE B
	call %TFLSH		;[wew] first do any buffered output
	CALL EXPPD1		;OUTPUT THEM ALL.
	JRST POPBJ

;PAD FOR A SPECIFIC LENGTH OF TIME.
;A CONTAINS THE NUMBER OF MSEC.  WE CLOBBER A AND B.
TIMPAD:	call %TFLSH		;[wew] first do any buffered output
	SKIPGE B,PADCHR		;PADCHR NONZERO MEANS WAIT INSTEAD OF PADDING.
	 JRST [	SAVE A
		MOVEI A,.PRIOU
		DOBE
		REST A
		DISMS
		RET]
	IMUL B,[<.BYTE 7 ? 1 ? 1 ? 1 ? 1 ? 1>_-1]
	LSH B,1
	CAME B,TIMPDS		;CHECK THAT WE HAVE THE RIGHT PAD CHARACTER
	 JRST [	MOVEM B,TIMPDS
		MOVE B,[TIMPDS,,TIMPDS+1]
		BLT B,TIMPDE-1
		JRST .+1]
	SKIPN B,OSPEED
	 MOVEI B,DEFOSP		;IF UNKNOWN, USE DEFAULT
	IMUL A,B
	CAIGE A,8000.		;IF MUCH LESS THAN 1 CHAR NEEDED, DON'T SEND ANY.
	 RET
	ADDI A,10000.-1
	IDIVI A,10000.		;GET NUMBER OF CHARS TO SEND
EXPPD1:	CAIL A,100.		;WE ONLY HAVE 100. RUBOUTS,
	 JRST [ SAVE A		;SO IF WE NEED MORE THAN THAT,
		MOVEI A,100.	;SEND 100. AT A TIME.
		CALL EXPPD2
		REST A
		SUBI A,100.
		JRST .-1]
EXPPD2:	JUMPE A,CPOPJ
	PUSH P,C
	MOVN C,A
	MOVEI A,.PRIOU		;NUMBER OF RUBOUTS TO OUTPUT
	HRROI B,TIMPDS
	SOUT
	JRST POPCJ

; SIMULATE CLEAR-TO-EOL ON A TERMINAL WHICH DOESN'T HAVE IT.
; THE DISPATCH VECTOR ENTRY FOR CLEAR-TO-EOL (AND THE ONE FOR CLEAR EOS,
; IF THAT IS ALSO MISSING) SHOULD CALL THIS ROUTINE.

;IF EOLFLG IS NEGATIVE, IT IS MINUS THE NUMBER OF COLUMNS THAT REALLY NEED CLEARING.
;THIS IS USED WHEN IT IS KNOWN THAT THE LINE USED TO BE BLANK PAST
;A CERTAIN POINT.
EOLSIM:	JSR SAVABC		; SAVE ACs
	SKIPGE C,EOLFLG		; NO. OF SPACES SET?
	 JRST EOLSI1		; YES, USE THAT
	HRRZ C,TTLPOS		; GET CURRENT POSITION
	SUB C,NHLNS
	SUBI C,1
EOLSI1:	HRROI B,SPACES
	MOVEI A,.PRIOU
	SOUT
	SETZM EOLFLG
	MOVE B,TTLPOS
	XCT @CURPSX
	JRST POPCBA

SPACES:	ASCII /                                                                                /

;	Efficent code.
;
; By BillW:  I have mode modifications to TOPS20 that increase the
; efficiency of special cases of SOUTs to a terminal by 50% or so.
; This occurs when the count of chars to be output is known ahead of
; time (-n in ac3).  TECO already uses this form to output text from
; the buffers, but the individual terminal-dependent cursor routines
; have always done PSOUTs and PBOUTs with careless lack of concern
; that this is terribly inefficient.  This code buffers the characters
; until %TFLSH is called, and then does one of the effiecient SOUTs.
; Even if you dont have the monitor patch, this improves efficiency.
;
%PBOUT:	idpb	1,TBFPTR	;put character in buffer
	aos	TBFCNT		;increment count
	push	P,4
TCKSIZ:	move	4,TBFCNT
	cail	4,TBFSIZ	;no rooms left  (+ slop)?
	 call	%TFLSH
	pop	P,4
	ret

; Note that %PSOUT only checks for space being left after the entire
; string has been put in the buffer.  We think we can get away with this
; because most of the PSOUTs in TECTRM are very short (typically 2 chars!),
; and there is some slack at the end of the bufer.
;
%PSOUT:	TLC 1,-1		;;Want to see if it's -1,,FOO
	TLCN 1,-1		;;Do the actual test
	 HRLI 1,440700		;;Make it a string pointer
	push	P,4
%PSOLP:	ildb	4,1
	jumpe	4,TCKSIZ	;done. check for space left.
	idpb	4,TBFPTR
	aos	TBFCNT
	jrst	%PSOLP


;Flush the buffer.  Note that this code is called by DDPYTB in the main
; TECO.MID module, which is a very convenient common exit point.  This
; is also called by %PSOUT or %PBOUT if the buffer becomes full, and
; by various padding routines if they decide to wait instead of actually
; outputting padding characters.
;
%TFLSH:	skipg	tbfcnt		;check that there are chars to output
	 ret
	save a
	save b
	save c
	movei	a,.priou
	hrroi	b,tbuffer
	movn	c,tbfcnt
	sout
	rest	c
	rest	b
	rest	a
%TINIT:	save	a		;entry point to initialize things.
	setzm	tbfcnt
	move	a,[440700,,tbuffer]
	movem	a,tbfptr
	rest	a
	ret

;
; here we try to do some optimization of moving the cursor by allowing
; terminals that do CR and LF 'properly' to use them for moving the
; cursor.  For example, when redisplaying a screen, it is likely that
; a frequently used sequence is "goto the beginning of the next line".
; using CRLF for this is better than (on a VT100) $[12;0H or whatever!
;
CRLFMV:

ifdef INSCNT,[
;fancy optimization for terminals with insert mode.  Basically, the
;idea is that whenever we are requested to inster N character positions,
;we just turn on insert mode, and wait for EMACS to output that many
;printing characters (It was noted on a earlier version of a tops10
; SUPDUP program that EMACS invariably outputs these characters
; immediately following the insert character operation).  Insert mode
;is not turned OFF until the N+1st character is about to be output.
;Compared to the old method where the terminal was put into insert mode,
;N spaces were output, and insert mode was turned off, the new method
;is extremely efficient!  [BillW@SRI-KL]

;This is a fixup routine for the insert mode optimization.  If the
;cursor is moved or some such while there are still characters to
;be inserted, this routine inserts the proper number of spaces.
XICFIX:	skipn	INSFLG		;are we in insert mode ?
	 ret			; no, do nothing
	save	1
	save	Q
	skiple	Q,INSCNT	;how many chars left to insert ?
	 call	OUTNSP		; insert them
	call	%TFLSH		;flush spaces to terminal if necessary
	setob	A,INSCNT	;no character left NOW!
	call	INSCHR		;turn off insert mode
	rest	Q
	rest	1
	ret
];ifdef inscnt
