;<FINGER>GETLOC.MAC.56,  2-Feb-2003 14:10:38, Edit by MRC
; Truncate host name in Pup and CHKDEF cases too
;<FINGER>GETLOC.MAC.55,  2-Feb-2003 13:26:45, Edit by MRC
; Remove prefix for Internet entirely
;<FINGER>GETLOC.MAC.54,  2-Feb-2003 13:23:42, Edit by MRC
; Change "IP:" to "@", truncate host name to 15 chars if have TTYLOC info
;<FINGER>GETLOC.MAC.53,  2-Feb-2003 13:16:17, Edit by MRC
; Change "Internet:" and "Ethernet:" to "IP:" and "Pup:"
;<FINGER>GETLOC.MAC.52, 26-Apr-2002 18:20:00, Edit by MRC
; Try just increasing THISNM
;<FINGER>GETLOC.MAC.51, 26-Apr-2002 18:09:41, Edit by MRC
; Increase MAXHNL
;<FINGER>GETLOC.MAC.50,  1-May-86 21:23:03, Edit by MRC
;<FINGER>GETLOC.MAC.49,  1-May-86 21:22:29, Edit by MRC
; Kevin created .HSTAC instead of reusing .HSTIP
;<FINGER>GETLOC.MAC.47    26-Nov-84 15:55:27    TECO'd by MRC
; Increase MAXTLD again.  Goddamnit, where did these guys learn to program?
;<FINGER>GETLOC.MAC.46, 26-Nov-84 15:33:15, Edit by MRC
; Increase TLCMAX
;<FINGER>GETLOC.MAC.44, 17-Jun-84 20:11:17, Edit by MRC
; Protect against not having Stanford .MORSP MTOPR% hack
;<FINGER>GETLOC.MAC.43,  5-Apr-84 02:17:29, Edit by MRC
; No more TCPSYM
;<FINGER>GETLOC.MAC.42,  5-Apr-84 02:14:42, Edit by MRC
; Use $RMREL in Internet too
;<FINGER>GETLOC.MAC.41, 18-Dec-83 19:17:13, Edit by MRC
; Fix TAC port output which I broke by invaliding the stack context...
;<FINGER>GETLOC.MAC.40, 17-Dec-83 13:12:26, Edit by MRC
; Flush INIHST routine, use $PUPNS instead.  Allow it to fail
;<FINGER>GETLOC.MAC.39, 17-Dec-83 02:28:39, Edit by MRC
; Use $RMREL for Ethernet hosts
;<FINGER>GETLOC.MAC.38, 17-Dec-83 02:21:23, Edit by MRC
; Flush explicit GTHST% and PUPNM% calls
;<FINGER>GETLOC.MAC.37,  3-Oct-83 12:19:02, Edit by MRC
; Allow TTYLOC.CMD stuff to be greater than TTNHST
;<FINGER>GETLOC.MAC.36,  3-Oct-83 12:03:27, Edit by MRC
; Double the size of MAXTLD
;<FINGER>GETLOC.MAC.35, 27-Sep-83 12:10:05, Edit by FMF
; Clear host in MAPHST if we need to unmap previous
;<FINGER>GETLOC.MAC.34, 24-Sep-83 18:36:06, Edit by FMF
; Change to use TTYINI.NET-BIN.  If can't find, then use old TTYINI.BIN and
;  TTYLOC.CMD (or TTYINI.CMD).
;<FINGER>GETLOC.MAC.33, 20-Sep-83 12:24:55, Edit by FMF
; Support GL%DES - only show description of location, not location string
;<FINGER>GETLOC.MAC.32, 19-Sep-83 08:45:48, Edit by FMF
; Suppress "Tip-" everywhere if wanted
;<FINGER>GETLOC.MAC.31, 19-Sep-83 08:10:37, Edit by FMF
; Typo in previous edit
;<FINGER>GETLOC.MAC.30, 19-Sep-83 08:07:06, Edit by FMF
; Set GL%TIP if want to possibly suppres "Tip-" on ether tips
; "Local:" if on a hardwired tty for locations
;<FINGER>GETLOC.MAC.29,  2-Sep-83 02:00:39, Edit by FMF
; Display real TAC port number, not just 0
;<FINGER>GETLOC.MAC.28, 23-Aug-83 12:56:46, Edit by FMF
; Fix smashed pointer in .DOPNV
;<FINGER>GETLOC.MAC.27, 22-Aug-83 18:20:54, Edit by FMF
; Changed my mind:  map in only pages that are there, but don't lookup
;  TTYINI.BIN unless that page exists
;<FINGER>GETLOC.MAC.26, 22-Aug-83 18:07:01, Edit by FMF
; Map in as many pages for .BIN files as we can
;<FINGER>GETLOC.MAC.25, 18-Aug-83 20:38:45, Edit by FMF
; Job numbers are decimal, not octal (sigh)
;<FINGER>GETLOC.MAC.24, 18-Aug-83 12:24:00, Edit by FMF
; Allow for GL%TST and make GL%USD do something useful
;<FINGER>GETLOC.MAC.23, 17-Aug-83 17:22:57, Edit by FMF
; Restore correct pointer if GTHST% in .DOTVT fails
;<FINGER>GETLOC.MAC.22, 15-Aug-83 13:19:18, Edit by FMF
; If no specific TTYLOC string give, use default
;<FINGER>GETLOC.MAC.21, 12-Aug-83 15:47:34, Edit by MRC
; Missing ENDIF.
;<FINGER>GETLOC.MAC.20, 12-Aug-83 15:45:07, Edit by MRC
; Checks for PTY, etc. weren't right
;<FINGER>GETLOC.MAC.19, 12-Aug-83 14:17:00, Edit by FMF
; If no SYSTEM:TTYINI.BIN, then try compiling SYSTEM:TTYINI.CMD
;  But be warned it expects Score-style TTYINI.CMD...
; If first word of location string -1, no location string
;<FINGER>GETLOC.MAC.15, 10-Aug-83 10:37:34, Edit by FMF
; Simplify code
; Restore destination pointer if couldn't find TTYINI
;<FINGER>GETLOC.MAC.14, 8-Aug-83 12:58:05, Edit by FMF
; Don't map in TTYINI/TTYLOC bin file if not found
;<FINGER>GETLOC.MAC.13,  3-Aug-83 14:31:56, Edit by FMF
; Fix dotted output of internet number
;<FINGER>GETLOC.MAC.10,  3-Aug-83 13:19:42, Edit by FMF
;<FINGER>GETLOC.MAC.9,  3-Aug-83 13:18:18, Edit by FMF
; Also report hung inactive ether nvts
;<FINGER>GETLOC.MAC.8,  3-Aug-83 11:53:27, Edit by FMF
; If couldn't get ether or internet name, output as a number
;<FINGER>GETLOC.MAC.6,  3-Aug-83 10:58:37, Edit by FMF
; Distinguish hung ethernet nvt
; Don't go to TTYINI for Ether, Internet, or Pseudo if not logged in
;<FINGER>GETLOC.MAC.5,  2-Aug-83 09:34:13, Edit by FMF
; Don't die if TTYLOC of TTYINI not found
;<FINGER>GETLOC.MAC.4, 30-Jul-83 18:48:10, Edit by FMF
; Set flag saying we've returned a batch job
;<FINGER>GETLOC.MAC.3, 30-Jul-83 18:40:49, Edit by FMF
; Fix Internet string
;<FINGER>GETLOC.MAC.2, 30-Jul-83 18:16:13, Edit by FMF
; Restore pointer before printing "Batch job"

TITLE GETLOC - Get a terminal's location
SUBTTL Frank M. Fujimoto / Stanford University / July, 1983

SEARCH MONSYM,MACSYM,JOBDAT,FNGDEF,TINIDF
.REQUIRE HSTNAM
ASUPPRESS
SALL

EXTERN $GTHNS,$PUPNS,$RMREL

IFNDEF TCP%TV,TCP%TV==1B11
IFNDEF TCP%NT,TCP%NT==1B12

SUBTTL Macro definitions

;Give a warning
DEFINE WMSG (STRING) <
	HRROI A,[ASCIZ \%'STRING\] ;;'%' means warning
	PSOUT%			;;Just want to output the message
>;WMSG

;Load an error message and return +1
DEFINE ERRRET (STRING) <
	HRROI A,[ASCIZ \STRING\] ;;Get the string
	RET			;;And go back +1
>;ERRRET

;See if something is within the bounds of fooMIN and fooMAX
;returns +1 if not, +2 if so
DEFINE BOUND (AC,TYPE) <
	CAML AC,TYPE'MIN
	 CAML AC,TYPE'MAX
>;BOUND

;AND if not JSYS error
DEFINE ANNJE. <
	..TAGF (ERJMP,)
>;ANNJE.

;AND if JSYS error
DEFINE ANJER. <
	ERJMP .+2
	..TAGF (JRST,)
>;ANJER.

SUBTTL Constant definitions

FL=0
A=1
B=2
C=3
D=4

B%STRL==6			;how many words long for location string
MAXTLD==1400			;Maximum number of TTYLOC default entries
MAXHNL==5			;Maximum number of words for host name (hope)
TTLMAX==<MAXTTY*.TDLEN>/1000+1	;Longest we can expect TTYLOC.BIN to be
TLCMAX==20			;Arbitrary number for TTYLOC.CMD
TTCMAX==<MAXTTY*^D82>/1000+1	;Longast we can expect TTYINI.CMD to be
				; (82 = 80 chars/line + CR + LF)
B%MAX==22			;Length of TTYINI record (old TTYINI)
B%HDRL==3			;Length of header for TTYINI.BIN
TTIMAX==<MAXTTY*B%MAX+B%HDRL>/1000+1 ;Longest we can expect TTYINI.BIN to be
MAXHSL==10			;Maximum number of pages to map in for host

OPDEF SKPA [TRNA]		;A faster skip always

.PSECT DATA

GETINI:	0			;GETLOC initialized: 0 = no
THISNM:	BLOCK 20		;Current Ether or Internet name
TTLJFN:	BLOCK 1			;JFN for TTYLOC.BIN file
TTIJFN:	BLOCK 1			;JFN for TTYINI.BIN/CMD/NET-BIN
TLCJFN:	BLOCK 1			;JFN for TTYLOC.CMD
LOCHST:	BLOCK 1			;Local host number
USENET:	BLOCK 1			;.LT. 0 if using NET-BIN
CURHST:	BLOCK 1			;Current network/host we're working with
HSTLEN:	BLOCK 1			;How many pages for this host's TTYINI
MAXTLE:	BLOCK 1			;Max TTYLOC entry+1
NMTTYS::BLOCK 1			;How many terminals we have on this sys
PTYMIN::BLOCK 1			;Minimum PTY number
PTYMAX::BLOCK 1			;Maximum PTY number+1
PNVMIN::BLOCK 1			;Minumum Ethernet NVT number
PNVMAX::BLOCK 1			;Maximum Ethernet NVT number+1
TVTMIN::BLOCK 1			;Minimum Internet NVT number
TVTMAX::BLOCK 1			;Maximum Internet NVT number+1
PUPBUF::BLOCK 1			;Location of Ether free storage
.NVTPU::BLOCK 1			;Table number for NVTPUP
.PUPFP::BLOCK 1			;Table number for PUPFPT
.PUPBU::BLOCK 1			;Table number for PUPBUF
LOCBUF:	BLOCK .TDLLN		;Hold TTYLOC location here
OVRFLW:	BLOCK 1			;Whether we have an overflow below

.ENDPS

.PSECT PURE

TTLNAM:	ASCIZ \FINGER:TTYLOC.BIN\ ;Name of TTYLOC.BIN file
TTINAM:	ASCIZ \SYSTEM:TTYINI.BIN\ ;Same for TTYINI
TLCNAM:	ASCIZ \FINGER:TTYLOC.CMD\ ;Name of default TTYLOC file
TTCNAM:	ASCIZ \SYSTEM:TTYINI.CMD\ ;If we couldn't find the BIN file
TTNNAM:	ASCIZ \SYSTEM:TTYINI.NET-BIN\ ;Network binary file

.ENDPS

.PSECT PAGED

TTLLOC::BLOCK TTLMAX*1000	;Location of TTYLOC.BIN
TTILOC::BLOCK TTIMAX*1000	;Location of TTYINI.BIN
TLCLOC::BLOCK TLCMAX*1000	;Location of TTYLOC.CMD
TTCLOC::BLOCK TTCMAX*1000	;Location of TTYINI.CMD if needed
TTNPG0::BLOCK 1000		;Location of TTYINI.NET-BIN page 0
TTNNET::BLOCK 1000		;NET-BIN's network page
TTNHST::			;NET-BIN's host TTYINI data

;The following three definitions overlap TTNHST.  This can happen because
; TLCTAB and TLCFRS will only be used if TTYINI.NET-BIN does not exist,
; thus they are never used simultaneously

TLCTAB:	BLOCK MAXTLD+1		;Entries for host names
TLCFRS:	BLOCK MAXTLD*<MAXHNL+.TDLLN> ;Storage for host name entries
TLCFRP:	BLOCK 1			;Pointer into TLCFRS (must be here!)

...XXX=<MAXHSL*1000>-<.-TTNHST>	;Space for TTNHST minus what above uses
IFG ...XXX,<
	BLOCK XXX		;Additional TTNHST space, if any
>;IFG ...XXX

.ENDPS

.PSECT CODE

;GETLOC - Return a string describing a terminal's location
;Takes A/ Byte or string pointer of destination, must be absolute
;      B/ Terminal number
;         GL%PRE (B0) - Prepend "Ethernet: " or "Internet: " if needed
;	  GL%LOC (B1) - Use TTYLOC, ignore GL%PRE if TTYLOC string found
;	  GL%TST (B2) - Only return strings if tty satisfies bits below
;	  GL%TIP (B3) - Suppress "Tip-" if it's there
;	  GL%DES (B4) - Only show description, not location string
;Returns +1 - Failed, pointer to error string in A
;	 +2 - Success
;	      A/ Updated byte pointer
;	      B/ Bits in left half
;		 GL%TST (B2)  - Set if a string (even if null) was produced
;		 GL%USD (B11) - This terminal is in use
;		 GL%HWR (B12) - This was a hardwired terminal
;		 GL%DIA (B13) - This was a dialin
;		 GL%BAT (B14) - This was a batch job
;		 GL%PTY (B15) - This was a Pseudo Terminal
;		 GL%INT (B16) - This was an Internet location
;		 GL%ETH (B17) - This was an Ethernet location

GETLOC::SAVEAC <C,D>
	STKVAR <SAVFLG>
	SKIPE GETINI		;Is GETLOC initialized?
	IFSKP.			;No...
	  CALL INIGET		;Initialize ourselves
	   RET			;If got an error, propagate it
	ENDIF.
	TLC A,-1		;Complement the left half
	TLCN A,-1		;See if we were given a string pointer
	 HRLI A,(<POINT 7,0>)	;Yes, make it a byte pointer
	MOVEM FL,SAVFLG		;Save away any flags we could have had
	HLLZ FL,B		;Get the flags that were passed to us
	HRRZS B			;And clear them from B
	TRZ B,.TTDES		;Make sure we weren't passed a tty designator
	CALL .GTLOC		;Get the location
	 SKPA			;It failed, we will return +1
	  AOS (P)		;It succeeded, set up a skip return
	MOVEM FL,B		;Save the flags
	MOVE FL,SAVFLG		;And restore the ones the user might have had
	RET			;Go back

;.GTLOC - Do the actual work
;Takes A/ BYTE pointer to destination
;      B/ Terminal number (not designator)
;      FL/ Flags as per B in GETLOC
;Returns: same as above, but flags in FL, not B

.GTLOC:	SAVEAC <B,C,D>
	ACVAR <TTYNUM>
	STKVAR <PTR>
	TXZ FL,GL%USD		;Assume terminal isn't in use
	MOVEM B,TTYNUM		;Save terminal number
	CAMG TTYNUM,NMTTYS	;Is this number larger than our largest tty#?
	 IFL. TTYNUM		;Or is it .LT. 0?
	   ERRRET <Terminal number out of range> ;It's bad, say so
	 ENDIF.
	CALL GTTLOC		;Get a location from TTYLOC
	BOUND TTYNUM,PNV	;Ethernet?
	 SKPA
	  CALLRET .DOPNV	;Yes
	TXZ FL,GL%TIP		;Don't need this flag any more
	BOUND TTYNUM,TVT	;Internet?
	 SKPA
	  CALLRET .DOTVT
	BOUND TTYNUM,PTY	;Are we a PTY?
	 SKPA
	  CALLRET .DOPTY	;Yes, do it
	MOVEM A,PTR		;Save our pointer
	MOVEI A,.TTDES(TTYNUM)	;Get the terminal designator
	HRROI B,D		;Want to put the result in D
	MOVEI C,.JIJNO		;Get the job number
	GETJI%			;Try to get it
	IFNJE.
	  SKIPL D		;Is this terminal in use?
	   TXO FL,GL%USD	;Yes, say so
	ENDIF.
	MOVEI B,.MORSP		;Want to see if we're a remote
	MTOPR%			;Get the info
	IFJER.
	  SETZ B,
	ENDIF.
	MOVE A,PTR		;Restore the pointer
	TXNE B,MO%RMT		;Are we on a dialin?
	 CALLRET .DORMT		;Yes, do it
	CALLRET .DOHWR		;Otherwise do hardwired
	ENDSV.

.DOPTY:	STKVAR <CTRLJB,CTRLUS,PTR>
	MOVEM A,PTR
	MOVEI A,.TTDES(TTYNUM)	;Get the terminal designator
	HRROI B,C		;Put the result in C
	MOVEI C,.JIJNO		;Want to get the corrosponding job number
				;We have to get the job number because
				; if we try to get batch information with
				; a tty designator, it will always succeed
	GETJI%			;Get the information
	 ERJMP PTYNLI		;Couldn't get it, do not logged in string
	MOVE A,C		;Get the job number
	HRROI B,C		;Want to  put data here
	MOVEI C,.JIBAT		;Want to see if this is a batch job
	GETJI%			;Get information
	 ERJMP PTYNLI		;Couldn't get it, just do normal string
	JUMPN C,.DOBAT		;If it's not zero, then it's batch
	HRROI B,CTRLJB		;We want data as controlling job
	MOVEI C,.JICPJ		;Get the controller
	GETJI%			;Get it
	 ERJMP PTYNLI
	SKIPGE A,CTRLJB		;Get the controlling job number
	 JRST PTYNLI		;If it's -1 (how?) then do TTYINI
	HRROI B,CTRLUS		;Put information here
	MOVEI C,.JIUNO		;Get the controlling job's user
	GETJI%			;Get it
	 ERJMP PTYNLI
	MOVE A,PTR		;Get back our pointer
	TXZ FL,GL%ALL-GL%PTY	;Clear all types but PTY
	TXZE FL,GL%TST		;Do we want to do a test?
	 TXNE FL,GL%PTY		;Yes, do we want a PTY?
	  SKPA			;If we win, go ahead
	   RETSKP		;Otherwise go back now
	TXO FL,GL%TST!GL%PTY	;Say we're on a PTY
	TXNN FL,GL%DES		;Only description?
	IFSKP.
	  MOVEI B,[ASCIZ \PTY\] ;Get our description
	  JRST .DOSTR		;Return that
	ENDIF.
	TXNN FL,GL%LOC		;Do we want TTYLOC?
	IFSKP.
	  MOVEI B,"["		;Begin the starter
	  IDPB B,A		;Drop it on our pointer
	  MOVE B,CTRLJB		;Get the controlling job
	  MOVEI C,^D10		;Radix decimal
	  NOUT%			;Add it
	   ERJMP .+1
	  MOVEI B," "		;Separate with a space
	  IDPB B,A		;Drop it in
	  MOVE B,CTRLUS		;Get the controlling user
	  DIRST%		;Add it
	   ERJMP .+1
	  MOVEI B,"]"		;Close off the header
	  IDPB B,A		;Drop it in
	  MOVEI B," "		;And separate with another space
	  IDPB B,A
	  CALLRET ADDLOC	;Now add the TTYLOC and go back
	ENDIF.
	MOVE B,[POINT 7,[ASCIZ \Job \]] ;Start off this other header
	CALL CPYSTR
	MOVE B,CTRLJB		;Get the controlling job number
	MOVEI C,^D10		;Radix decimal
	NOUT%			;Add it
	 ERJMP .+1
	MOVEI B,","		;Separate for user name
	IDPB B,A
	MOVEI B," "
	IDPB B,A
	MOVE B,CTRLUS		;Get the user number of our controller
	DIRST%			;Add it
	 ERJMP .+1
	MOVEI B,","		;Delimit for jobname
	IDPB B,A
	MOVEI B," "
	IDPB B,A
	MOVEM A,PTR		;Save away the pointer
	MOVE A,CTRLJB		;Get the controlling job number
	HRROI B,C		;Get data in C
	MOVEI C,.JIPNM		;Want the program name
	GETJI%			;Get it
	 ERJMP .+1
	MOVE A,PTR		;Get the pointer back
	DO.
	  SETZ B,		;Zero the receiving ac
	  LSHC B,6		;Get a char
	  ADDI B," "		;Convert from sixbit to ascii
	  IDPB B,A		;Drop it on our string
	  JUMPN C,TOP.		;Loop until we have all the chars
	ENDDO.
	RETSKP			;Now go back +2

PTYNLI:	MOVE A,PTR		;Get back our pointer
	TXNN FL,GL%DES		;Only description?
	IFSKP.
	  MOVEI B,[ASCIZ \PTY\] ;Get our description
	  JRST .DOSTR		;Return that
	ENDIF.
	TXZ FL,GL%ALL-GL%PTY	;Clear all but PTY
	TXZE FL,GL%TST		;Do we want to apply a test?
	 TXNE FL,GL%PTY		;Yes, do we want PTYs?
	  SKPA			;Yes, go ahead
	   RETSKP		;No, don't do it
	TXO FL,GL%TST!GL%PTY	;Say we have a PTY
	MOVE B,[POINT 7,[ASCIZ \Pseudo terminal\]]
	CALL CPYSTR		;Do it
	RETSKP			;Now go back +2

.DOBAT:	MOVE A,PTR		;Get back the pointer
	TXZ FL,GL%ALL-GL%BAT	;Clear all but Batch
	TXZE FL,GL%TST		;Do we want to test?
	 TXNE FL,GL%BAT		;Yes, do we want batch jobs?
	  SKPA			;Yes, go ahead
	   RETSKP		;No, go back now
	TXO FL,GL%TST!GL%USD!GL%BAT ;Say this is a batch job
	TXNN FL,GL%DES		;Only description?
	IFSKP.
	  MOVEI B,[ASCIZ \Batch\] ;Get our description
	  JRST .DOSTR		;Return that
	ENDIF.
	TXNE FL,GL%LOC		;Are we doing TTYLOC?
	IFSKP.
	  MOVE B,[POINT 7,[ASCIZ \Batch job\]] ;No, just say it's batch
	  CALL CPYSTR
	  RETSKP		;Go back +2
	ENDIF.
	MOVE B,[POINT 7,[ASCIZ \Batch: \]] ;Otherwise, set up line
	CALL CPYSTR		;Add this line to our location
	TXO FL,GL%BAT		;Say we were a batch job
	CALLRET ADDLOC		;Add our regular TTYLOC location now
	ENDSV.

.DOPNV:	STKVAR <PTR,NVTLOC,HAVTIP>
	SETZM HAVTIP		;Say we don't have a tip now
	TXZ FL,GL%ALL-GL%ETH	;Clear all but Ether
	TXZE FL,GL%TST		;Do we want to test?
	 TXNE FL,GL%ETH		;Yes, do we want ethernet?
	  SKPA			;If here, then go ahead and do string
	   RETSKP		;Else go back now
	MOVEM A,PTR		;Save our pointer
	TXO FL,GL%TST!GL%ETH	;Flag we are an ethernet location
	MOVE A,TTYNUM		;Get the terminal number
	SUB A,PNVMIN		;Make an offset into ethernet ttys
	HRLZS A			;Get that number in the left half
	HRR A,.NVTPU		;Want to get our TTYPUP word
	GETAB%			;Get it
	 ERJMP PNVNLI		;If an error assume it's not logged in
	JUMPG A,ETHHNG		;If it's inactive and hung, say so
	JUMPE A,PNVNLI		;If it's inactive but not hung, say so
	MOVSS A
	HRR A,.PUPFP		;Want to get the foreign port address
	GETAB%
	 ERJMP PNVNLI		;Just say not logged in if couldn't get it
	JUMPE A,PNVNLI		;Again, want to make sure we're still there
	TXO FL,GL%USD		;Flag this tty is in use
	SUB A,PUPBUF		;Get offset from start of pup free storage
	MOVEM A,D		;Save this away
	MOVSI A,1(A)		;Make table index in left half
	HRR A,.PUPBU
	GETAB%			;Get data from free storage
	 ERJMP ETHHNG		;If we failed, say it's hung
	MOVEM A,NVTLOC		;Save for later
	HRROI A,THISNM		;This is the name we're looking at
	MOVE B,NVTLOC
	CALL $PUPNS		;Translate host address into string
	 JRST ETHHNG		;???
	HRROI A,THISNM		;Now remove the relative domain
	CALL $RMREL
	DO.
	  MOVE C,A		;Current "last byte"
	  ILDB B,A		;Find end of string
	  JUMPN B,TOP.		;Not there yet...
	ENDDO.
	MOVE B,THISNM		;Get the first chars of our name
	TLZ B,201004		;Uppercase first three letters
	CAML B,[ASCIZ \TIP-\]	;Is it within range to be a TIP?
	 CAML B,[ASCIZ \TIP.\]
	 IFSKP.
	   HRLZI A,2(D)		;To make table index in left half for port
	   HRR A,.PUPBU		;Table number in right
	   GETAB%		;Get that word from pup free buffer space
	 ANNJE.
	   MOVEI B,77		;Want rightmost six bits
	   AND B,A		;Isolate them in B
	   MOVEI A,"#"		;Want to show a tip port
	   IDPB A,C		;Drop it in 
	   MOVE A,C		;Get back the pointer
	   MOVEI C,^D8		;Radix octal
	   NOUT%		;Do it
	    ERJMP .+1
	   MOVEM A,C		;Put back the pointer
	   SETOM HAVTIP		;Flag this is a tip
	 ELSE.
	   SETZ B,		;Flag we don't have a tip in another fashion
	 ENDIF.
	MOVE A,C		;Restore our pointer
	SETZ C,			;Get a null
	IDPB C,A		;Drop it in
	MOVE A,PTR		;Get the pointer back
	IFXE. FL,GL%LOC		;Are we not doing TTYLOC?
	  SKIPE USENET		;Are we using the network ttyini?
	  IFSKP.		;No...
	    CALL CHKDEF		;Check default
	     RETSKP		;We got one, go back
	  ELSE.
	    MOVE C,NVTLOC	;Get net,,host
	    CALL CHKBIN		;Check the bin file
	     RETSKP		;Got something, go back
	  ENDIF.
	ENDIF.
	TXNN FL,GL%LOC!GL%DES	;Do we not want TTYLOC or only description
	 TXNN FL,GL%PRE		;And do we want the prefix?
	 IFSKP.
	   MOVE B,[POINT 7,[ASCIZ \Pup: \]] ;Prepend our prefix
	   CALL CPYSTR		;Do the copy
	   TXZ FL,GL%TIP	;Force "Tip-"
	 ENDIF.
	SKIPN HAVTIP		;Do we have a tip?
	IFSKP.
	  TXNN FL,GL%TIP	;Do we want to suppress "Tip-"?
	ANSKP.
	  MOVE B,[POINT 7,THISNM,27] ;Yes, suppress it
	ELSE.
	  MOVE B,[POINT 7,THISNM] ;Display the whole thing
	ENDIF.
	TXZ FL,GL%TIP		;We won't use this flag any more
	TXNN FL,GL%DES		;Only description?
	 TXNN FL,GL%LOC		;Using TTYLOC?
	IFNSK.
	  CALL CPYSTR		;Drop it in
	  RETSKP		;No, go back now
	ENDIF.
	SETZM THISNM+3		;Limit hostname to 15 chars if TTYLOC
	CALL CPYSTR		;Drop it in
	MOVEI B,":"		;Start the delimiting
	IDPB B,A		;Add the colon
	MOVEI B," "		;And the space
	IDPB B,A		;Do it
	CALLRET ADDLOC		;Now add the locationa

PNVNLI:	MOVE A,PTR		;Get the pointer back
	MOVE B,[POINT 7,[ASCIZ \Ethernet NVT\]] ;Say it's an ether tty
	CALL CPYSTR		;Put it in our string
	TXZ FL,GL%TIP		;Don't need this flag any more
	RETSKP

ETHHNG:	MOVE A,PTR		;Get the pointer back
	MOVE B,[POINT 7,[ASCIZ \Hung Ethernet NVT\]] ;Yes, say so
	CALL CPYSTR		;Drop it in
	RETSKP			;And go back
	ENDSV.

.DOTVT:	STKVAR <PTR,HSTNUM,SAVSTS,TACPRT,SAVPTR>
	TXZ FL,GL%ALL-GL%INT	;Clear all but Internet
	TXZE FL,GL%TST		;Do we want to apply a test?
	 TXNE FL,GL%INT		;Yes, do we want internet?
	  SKPA			;If here, yes, go ahead
	   RETSKP		;Otherwise go back now
	TXO FL,GL%TST!GL%INT	;Flag we're coming from the internet
	MOVEM A,PTR		;Save our pointer
	MOVE A,TTYNUM		;Get the terminal number
	TXO A,TCP%TV		;Argument is a TVT
	MOVEM A,SAVSTS		;Save in case need port number
	HRROI B,7		;Want host number (should have a symbol!)
	HRROI C,HSTNUM
	STAT%			;Get it
	 ERJMP TVTNLI		;Couldn't, so not logged in
	TXO FL,GL%USD		;Say this is in use
	HRROI A,THISNM		;Get pointer to our destination
	MOVE B,HSTNUM		;Get back the host
	CALL $GTHNS		;Get host name
	 JRST TVTNLI
	HRROI A,THISNM		;Remove the relative domain
	CALL $RMREL
	DO.
	  MOVEM A,SAVPTR	;Save possible end pointer
	  ILDB B,A		;Find end of string
	  JUMPN B,TOP.		;Not there yet...
	ENDDO.
	MOVX A,.GTHHN		;Get status of host
	MOVE C,HSTNUM
	GTHST%			;** temporary **
	IFJER.
	  SETZ D,		;Failed, tough
	ENDIF.
	MOVE A,SAVPTR		;Get host pointer back
	ANDI D,HS%STY		;Get system type
	CAIE D,.HSTIP		;Is it a tip?
	 CAIN D,.HSTAC		;Is it a tip?
	IFNSK.
	  MOVEI B,"#"		;Get a host delimiter
	  IDPB B,A		;Drop it on our string
	  MOVEM A,SAVPTR	;Save away pointer
	  MOVE A,SAVSTS		;Get back AC
	  HRROI B,11		;Location for port number
	  HRROI C,TACPRT	;Where to put the port number
	  STAT%			;Do it
	  IFJER.
	    SETZM TACPRT	;If couldn't get it, assume 0
	  ENDIF.
	  MOVE A,SAVPTR		;Get back the pointer
	  MOVE B,TACPRT		;Get the port
	  LSH B,-<^D8>		;Isolate the port number
	  MOVEI C,^D8		;Radix octal
	  NOUT%			;Output it
	   ERJMP .+1
	ENDIF.
	SETZ B,			;Get a null
	IDPB B,A		;Drop it in
	MOVE A,PTR		;Get the pointer back
	TXNE FL,GL%LOC		;Do we have a TTYLOC?
	IFSKP.			;No...
	  CALL CHKDEF		;Check to see if we have any defaults
	   RETSKP		;Yes, go back now
	ENDIF.
	MOVE B,[POINT 7,THISNM]	;Get the current name
	TXNN FL,GL%DES		;Only description?
	 TXNN FL,GL%LOC		;Using TTYLOC?
	IFNSK.
	  CALL CPYSTR		;Drop it in
	  RETSKP		;No, go back now
	ENDIF.
	SETZM THISNM+3		;Limit hostname to 15 chars if TTYLOC
	CALL CPYSTR
	MOVEI B,":"		;Delimit the host name
	IDPB B,A
	MOVEI B," "		;With ": "
	IDPB B,A
	CALLRET ADDLOC		;Now add the TTYLOC location

TVTNLI:	MOVE A,PTR		;Get back original pointer
	MOVE B,[POINT 7,[ASCIZ \Internet NVT\]] ;Say we're internet
	CALL CPYSTR		;Drop it in
	RETSKP			;Go back +2
	ENDSV.

.DORMT:	TXZ FL,GL%ALL-GL%DIA	;Clear all but dialin
	TXZE FL,GL%TST		;Do we want to test?
	 TXNE FL,GL%DIA		;Yes, are we dialin?
	  SKPA			;Yes, go ahead
	   RETSKP		;If not, just go back now
	TXO FL,GL%TST!GL%DIA	;Say we're on a dialin
	TXNN FL,GL%DES		;Only description?
	IFSKP.
	  MOVEI B,[ASCIZ \Dialup\] ;Get our description
	  JRST .DOSTR		;Return that
	ENDIF.
	TXNN FL,GL%LOC		;Do we want to use TTYLOC?
	 CALLRET .DOTIN		;No, don't do it
	MOVE B,[POINT 7,[ASCIZ \Dialup: \]] ;Say this is a dialup
	CALL CPYSTR		;Add it to our string
	CALLRET ADDLOC		;Add our location to this and return

.DOHWR:	TXZ FL,GL%ALL-GL%HWR	;Clear all but hardwired
	TXZE FL,GL%TST		;Do we want to test?
	 TXNE FL,GL%HWR		;Yes, are we hardwired?
	  SKPA			;Yes, go ahead
	   RETSKP		;If not, just go back now
	TXO FL,GL%TST!GL%HWR	;Say we're on a dialin
	TXNN FL,GL%DES		;Only description?
	IFSKP.
	  MOVEI B,[ASCIZ \Local\] ;Get our description
	  JRST .DOSTR		;Return that
	ENDIF.
	TXNN FL,GL%LOC		;Do we want to use TTYLOC?
	 CALLRET .DOTIN		;No, don't use it
	MOVE B,[POINT 7,[ASCIZ \Local: \]] ;Say this is a hardwired tty
	CALL CPYSTR		;Add it to our string
	CALLRET ADDLOC		;Add our location to this and return

.DOSTR:	HRLI B,(<POINT 7,0>)	;Make this a byte pointer
	CALL CPYSTR		;Say this is our string
	RETSKP			;And go back

.DOTIN:	SKIPE USENET		;Are we using NET-BIN?
	IFSKP.			;No...
	  MOVEI D,B%MAX		;Multiplyer for old TTYINI
	ELSE.
	  MOVE D,BLKSIZ+TTNPG0	;Get how large each block is
	ENDIF.
	SKIPL TTIJFN		;Do we have a JFN for TTYINI?
	 CAMLE TTYNUM,TTILOC	;.GT. the largest tty TTYINI knows?
	  RETSKP		;Yes, go back now
	MOVE B,TTYNUM		;Get the terminal number
	IMUL B,D		;Multiply by the length
	SKIPE USENET		;Using net-bin?
	 ADDI B,TTYBLK		;Yes, offset for terminal data
	ADDI B,B%ADDR+TTILOC	;Point to the address
	MOVE C,(B)		;Get the first word
	CAMN C,[-1]		;Is it a -1?
	 RETSKP			;Yes, don't do it
	HRLI B,(<POINT 7,0>)	;Make it a byte pointer
	CALL CPYSTR		;Add the string
	RETSKP			;And go back +2

ADDLOC:	MOVE B,[POINT 7,LOCBUF]	;Get the name we got from TTYLOC
	CALL CPYSTR		;Tack that on
	RETSKP			;And go back +2 (we're done!)
	ENDAV.

;Check to see if we have a default
;Takes A/ pointer to destination
;      THISNM/ name of host
;Returns +1 - Yes, location and default string copied to destination
;	 +2 - no default or GL%DES set
CHKDEF:	TXNE FL,GL%DES		;Do we not want location strings at all?
	 RETSKP			;Go back now
	STKVAR <PTR>
	MOVEM A,PTR		;Save our pointer
	MOVEI A,TLCTAB		;Table of our defaults
	HRROI B,THISNM		;Pointer to what we're looking for
	TBLUK%			;Look for it
	TXNE B,TL%EXM		;Was it an exact match?
	IFSKP.
	  MOVE A,PTR		;No, get back the pointer
	  RETSKP		;And go back +1
	ENDIF.
	MOVEM A,D		;Save away this pointer
	MOVE A,PTR		;Restore the pointer
	MOVE B,THISNM		;Get the first chars of our name
	TLZ B,201004		;Uppercase first three letters
	CAML B,[ASCIZ \TIP-\]	;Is it within range to be a TIP?
	 CAML B,[ASCIZ \TIP.\]
	 IFSKP.
	   TXNN FL,GL%TIP	;Do we want to suppress it?
	 ANSKP.
	   MOVE B,[POINT 7,THISNM,27] ;Yes, do so
	   SETZM THISNM+4	;OK, this is an extra char...
	 ELSE.
	   MOVE B,[POINT 7,THISNM] ;Pointer to the current host
	   SETZM THISNM+3	;Truncate
	 ENDIF.
	TXZ FL,GL%TIP		;Clear flag we won't use any more
	CALL CPYSTR		;Move it
	MOVEI B,":"		;Delimit it
	IDPB B,A
	MOVEI B," "
	IDPB B,A
	HRR B,(D)		;Get pointer to location string
	HRLI B,(<POINT 7,0>)	;Make it a byte pointer
	CALLRET CPYSTR		;Copy it and go back +1

;CHKBIN - Check the net-bin file for defaults
;Takes A/ Pointer to destination
;      B/ Port number if tip
;      C/ net,,host number
;Returns +1 - success, location copied
;	 +2 - failure, no location in bin file
CHKBIN:	CAMN C,LOCHST		;Are we going back to ourselves?
	 RETSKP			;Don't let 'em do it!
	SAVEAC <B,C>
	STKVAR <HOST,PORT,PTR>
	MOVEM B,PORT		;Save the port number
	MOVEM C,HOST		;And the host
	MOVEM A,PTR		;And the destination pointer
	HLRZ A,HOST		;Get the net number
	CALL MAPNET		;Get it
	 JRST NOTBIN		;Failed, go back
	HRRZ A,HOST		;Get the host number
	CALL MAPHST		;Map it in
	 JRST NOTBIN		;Failed, go back
	MOVE A,PTR		;Get back the pointer
	MOVE B,PORT		;Get the port number
	CAMLE B,TTNHST+NUMTTY	;Is it greater than the largest tty number?
	 RETSKP			;Yes, we don't have it
	IMUL B,TTNPG0+BLKSIZ	;Get how large each block is
	ADD B,[POINT 7,TTYBLK+B%ADDR+TTNHST] ;Make byte pointer to location
	MOVE C,(B)		;Get the first word
	CAMN C,[-1]		;No string there?
	 RETSKP			;Go back +2
	JRST CPYSTR		;Otherwise blt the string

NOTBIN:	MOVE A,PTR		;Restore the pointer
	RETSKP			;And go back +2
	ENDSV.

;INIGET - Initialize GETLOC
;Returns +1 - failure, pointer to error in A
;	 +2 - success

INIGET::SAVEAC <B,C>
	STKVAR <PTR,<TMPBUF,^D10>>
	MOVEM A,PTR		;Save the string pointer
	HRROI A,TMPBUF		;Don't care about local name
	SETO B,			;Want local Ethernet address
	CALL $PUPNS		;Get it
	 SETO B,		;Failed - note no Ethernet
	MOVEM B,LOCHST		;Save local host/no net flag
	MOVE A,[SIXBIT \TTYJOB\] ;Want to see how many terminals we have
	SYSGT%			;Get the information
	IFJER.
	  ERRRET <Couldn't find how many terminals on system>
	ENDIF.
	HLREM B,NMTTYS		;Save how many ttys we have
	MOVNS NMTTYS		;Make it a positive number
	MOVE A,[SIXBIT \PTYPAR\] ;Want to get information about PTYs
	SYSGT%			;Get it
	IFNJE.
	  HRRZM A,PTYMIN	;First PTY
	  HLRZS A		;Number of PTYs
	  ADD A,PTYMIN		;Add minimum pty
	  MOVEM A,PTYMAX	;Save max pty + 1
	ELSE.
	  SETOM PTYMIN		;Say we don't have PTYs (what?)
	  SETOM PTYMAX
	ENDIF.
	MOVX A,TCP%NT		;Get TVT functions
	STAT%			;Get how many we have
	IFNJE.
	  HRRZM B,TVTMIN	;Set first TVT
	  HLROM B,C		;-Number of TVTs
	  SUB B,C		;1+last TVT number
	  HRRZM B,TVTMAX	;Save it
	ELSE.
	  SETOM TVTMIN		;Don't have any TVTs
	  SETOM TVTMAX
	ENDIF.
	MOVE A,[SIXBIT \PUPPAR\] ;Want Ether parameters
	SYSGT%			;Get it
	IFNJE.
	ANDN. B			;If no such table, ignore
	  HRRZM A,PNVMIN	;Save TTY # of 1st Pup NVT
	  HLREM A,D
	  SUBI A,1(D)
	  HRRZM A,PNVMAX	;And last Pup NVT+1
	  HRRZ A,B		;Get GETAB table number
	  HRLI A,1		;Next item in table
	  GETAB%		;Get it
	ANNJE.
	  MOVEM A,PUPBUF	;Address of Pup free storage in monitor
	  MOVE A,[SIXBIT \NVTPUP\] ;Get table number of these tables
	  SYSGT%
	ANNJE.
	  HRRZM B,.NVTPU
	  MOVE A,[SIXBIT \PUPFPT\]
	  SYSGT%
	ANNJE.
	  HRRZM B,.PUPFP
	  MOVE A,[SIXBIT \PUPBUF\]
	  SYSGT%
	ANNJE.
	  MOVEM B,.PUPBU
	ELSE.
	  SETOM PNVMIN		;No ethernet here
	  SETOM PNVMAX
	ENDIF.
	MOVE A,PTR		;Get back pointer to destination
	SETOM GETINI		;Say we've been initialized (we hope)
	CALLRET GETFIL		;Get our files and return
	ENDSV.

;GETFIL - Get our files

GETFIL:	SAVEAC <B,C,D>
	STKVAR <PTR>
	MOVEM A,PTR		;Save our pointer
	CALL GETTTL		;Get TTYLOC.BIN
	CALL GETTTI		;Get TTYINI.BIN
	IFNSK.
	  CALL GETTTC		;If not there, get TTYINI.CMD
	   RET			;We had an error, so go back now
	ENDIF.
	SKIPE USENET		;Are we using net-bin?
	IFSKP.			;Yes...
	  CALL GETTLC		;Get TTYLOC.CMD
	   RET			;Had an error, so go back now
	ENDIF.
	MOVE A,PTR		;Get back the pointer
	RETSKP			;And go back
	ENDSV.

GETTTL:	MOVEI D,TTLJFN		;Where we'll put the JFN
	MOVX A,GJ%SHT!GJ%OLD	;Old file, short form
	HRROI B,TTLNAM		;Name of the file
	GTJFN%			;Get it
	 ERJMP NOFIL		;Didn't win, so say we don't have TTYLOC
	MOVEM A,TTLJFN		;Save away the JFN
	MOVX B,OF%RD!OF%THW	;Thawed read acces
	OPENF%			;Try to open it
	 ERJMP NOOPN		;Couldn't open it
	SIZEF%			;Get how large the file is
	 ERJMP NOSIZ		;Couldn't get the size of it
	CAIG C,TTLMAX		;Is it too big for us?
	MOVEM C,D		;Save this away
	IFSKP.
	  WMSG <TTYLOC.BIN file too large> ;Warn that it's too big for us
	  JRST NOSIZ		;And then say we don't have TTYLOC
	ENDIF.
	HRLZ A,TTLJFN		;Get the JFN, 0 in right half
	MOVEI B,TTLLOC/1000	;Get where to map it
	HRLI B,.FHSLF		;Process in left half
	TXO C,PM%RD!PM%CNT	;Multiple page read access
	PMAP%			;Do it
	LSH D,9			;Make number of pages into number of words
	IDIVI D,.TDLEN		;Find how many entries we have
	MOVEM D,MAXTLE		;Save as the maximum TTYLOC entry
	RET			;Now go back

GETTTI:	SKIPGE LOCHST		;Have a local Ethernet host #?
	 JRST OLDTTI		;No, can't use this functionality
	MOVX A,GJ%SHT!GJ%OLD	;Old file, short form
	HRROI B,TTNNAM		;Name of the NET-BIN file
	GTJFN%			;Get it
	 ERJMP OLDTTI		;Didn't work, use old ttyini
	MOVEM A,TTIJFN		;We win, have it
	SETOM USENET		;Assume we're going to use it now
	MOVX B,OF%RD		;Read access
	OPENF%			;Do it
	IFJER.
	  MOVE A,TTIJFN		;Get the jfn back
	  RLJFN%		;Release it
	   ERJMP .+1		;Ignore any errors
	  JRST OLDTTI		;Use old ttyini
	ENDIF.
	HRLZS A			;Get JFN in left half, map in page 0
	MOVE B,[.FHSLF,,TTNPG0/1000] ;Where to put it
	MOVX C,PM%RD		;Want read access
	PMAP%			;Get it
	SETZM CURHST		;We don't have a current net/host
	SETZM HSTLEN		;We don't know how long host pages are
	MOVE B,LOCHST		;And host number
	DO.
	  HLRZ A,B		;Get network number
	  CALL MAPNET		;Map in the network
	   JRST OLDTTI		;If it didn't work, use the old ttyini
	  MOVE B,TTNNET(B)	;Get page number of local host
	  JUMPL B,OLDTTI	;If it didn't work, use the old TTYINI
	  TLNE B,-1		;Is this an indirection?
	   LOOP.		;Yes, follow the pointer
	ENDDO.
	HRL A,TTIJFN		;Get the JFN
	HRR A,B			;And the page number we wish to map
	MOVE B,[.FHSLF,,<TTILOC/1000>]
	MOVX C,PM%RD		;Want read access
	PMAP%			;Get it
	MOVE C,TTILOC		;Get how many TTYs we must handle
	IMUL C,TTNPG0+BLKSIZ	;Multiply by how big each block is
	ADDI C,TTYBLK		;Add for header
	LSH C,-<^D9>		;Make it a number of pages-1
	CAIGE C,TTIMAX		;Is it too large?
	IFSKP.
	  SETO A,		;Get ready to unmap
	  SETZ C,
	  PMAP%			;Do it
	  JRST OLDTTI		;Try the old ttyini
	ENDIF.
	AOS A			;Want to read from the next page
	AOS B			;Start mapping rest of TTYINI at next page
	TXO C,PM%RD+PM%CNT	;This time multiple page read access
	PMAP%			;Get it
	RETSKP			;We win big, go ahead with everything else

OLDTTI:	SETZM USENET		;We aren't using network ttyini
	MOVEI D,TTIJFN
	MOVX A,GJ%SHT!GJ%OLD	;Old file, short form
	HRROI B,TTINAM		;Name of the file
	GTJFN%			;Get it
	 ERJMP NOFIL		;Say we don't have TTYINI
	MOVEM A,TTIJFN		;Save away the JFN
	MOVX B,OF%RD		;Read access
	OPENF%			;Try to open it
	 ERJMP NOOPN
	SIZEF%			;Get how large the file is
	 ERJMP NOSIZ
	CAIG C,TTIMAX		;Is it too big for us?
	IFSKP.
	  WMSG <TTYINI.BIN file too large> ;Warn about the size
	  JRST NOSIZ		;And say we don't have TTYINI.BIN
	ENDIF.
	HRLZ A,TTIJFN		;Get the JFN, 0 in right half
	MOVEI B,TTILOC/1000	;Get where to map it
	HRLI B,.FHSLF		;Process in left half
	TXO C,PM%RD!PM%CNT	;Multiple page read access
	PMAP%			;Do it
	RETSKP			;Now go back successfully

GETTTC:	MOVEI D,TTIJFN		;Where we'll put the JFN
	AOS (P)			;Assume a skip return
	MOVX A,GJ%SHT!GJ%OLD	;Try for .CMD, old file, short form
	HRROI B,TTCNAM		;Name of the file
	GTJFN%			;Get it
	 ERJMP NOFIL		;Say we don't have TTYINI.CMD
	MOVEM A,TTIJFN		;Save away the JFN
	MOVX B,OF%RD		;Read acces
	OPENF%			;Try to open it
	 ERJMP NOOPN
	SIZEF%			;Get how large the file is
	 ERJMP NOSIZ
	SOS (P)			;No longer want to assume skip return
	CAIG C,TTCMAX		;Is it too big for us?
	IFSKP.
	  WMSG <TTYINI.CMD too large>
	  JRST NOSIZ
	ENDIF.
	HRLZ A,TTIJFN		;Get the JFN, 0 in right half
	MOVEI B,TTCLOC		;Get where to map it
	LSH B,-<^D9>		;Make it a page number
	HRLI B,.FHSLF		;Process in left half
	TXO C,PM%RD!PM%CNT	;Multiple page read access
	PMAP%			;Do it
	CALL MAPTTI		;Map TTYINI.CMD into something like the .BIN
	 RET			;Failed, go back now
	SETO A,			;Want to unmap
	PMAP%			;So do it
	RETSKP			;And return successfully

;GETTLC - Map in TTYLOC.CMD

GETTLC:	MOVEI D,TLCJFN		;Where we're gonna store the JFN
	AOS (P)			;Assume a skip return
	MOVX A,GJ%SHT!GJ%OLD	;Try for TTYLOC.CMD, short form, old file
	HRROI B,TLCNAM		;Name of the file
	GTJFN%			;Try to get it
	 ERJMP NOFIL		;We don't have it
	MOVEM A,TLCJFN		;Save away the JFN
	MOVX B,OF%RD		;Want read access
	OPENF%			;Try to get it
	 ERJMP NOOPN		;Couldn't open it
	SIZEF%			;Try to get the size of it
	 ERJMP NOSIZ		;Couldn't get the size
	SOS (P)			;No longer assume a skip return
	CAIG C,TLCMAX		;Is it too big for us?
	IFSKP.
	  WMSG <TTYLOC.CMD too large>
	  JRST NOSIZ		;Just as if we couldn't get the size
	ENDIF.
	HRLZ A,TLCJFN		;Get the JFN, 0 in right half
	MOVEI B,TLCLOC/1000	;Get where we want to map it
	HRLI B,.FHSLF		;Process in left half
	TXO C,PM%RD!PM%CNT	;Multiple page read access
	PMAP%			;Do it
	CALL BLDDEF		;Build default TTYLOC locations
	 RET			;If we had an error, propagate it
	SETO A,			;Want to unmap
	PMAP%			;Do it
	RETSKP			;And go back

NOSIZ:	MOVE A,(D)		;Get the JFN for the file
	CLOSF%			;Close it down
	 ERJMP .+1		;Ignore any errors
	JRST NOFIL		;Now close it up
NOOPN:	MOVE A,(D)		;Get the JFN
	RLJFN%			;Release it
	 ERJMP .+1		;Ignore any errors
NOFIL:	SETZM (D)		;Now zero our JFN
	RET			;And go back +1

;Format of TTYINI.CMD file is *not* the same as LOTS/TTYINI.  It is like
;Score's TTYINI.CMD, which has the form
; tty# type-designator   !location
;
;Note that GETLOC will not fill in locations for terminals which are
; Ether, Internet, or PTY, since they are not used anyway

MAPTTI:	ACVAR <TTYCMD>
	SAVEAC <B,C,D>
	SETOM TTILOC		;We have no largest terminal number yet
	MOVE TTYCMD,[POINT 7,TTCLOC] ;Pointer to .CMD file
	DO.
	  ILDB A,TTYCMD		;Get the first char on the line
	  CAIE A,.CHTAB		;Is it a tab?
	   CAIN A," "		;Or a space?
	    LOOP.		;Yes, ignore and go to next char
	  CAIE A,";"		;Beginning of a comment?
	  IFSKP.
	    CALL FLSHLI		;Yes, flush this line
	    LOOP.		;Go to next liney
	  ENDIF.
	  JUMPE A,ENDLP.	;If it was a null, we're done
	  CALL PRSLIN		;Parse this line
	   RET			;Detected an error, abort
	  LOOP.			;Go for another
	ENDDO.
	RETSKP

FLSHLI:	DO.
	  CAIN A,.CHLFD		;Did we hit a line feed?
	   RET			;|Yes, go out
	  JUMPE A,R		;If just null, say end of file
	  ILDB A,TTYCMD		;Get the next char
	  LOOP.			;And test it
	ENDDO.

PRSLIN:	CAIL A,"0"		;Is it in the range of an octal digit?
	 CAILE A,"8"
	 IFNSK.			;No, return an error
	   CAIE A,"*"		;A default entry?
	   IFSKP.
	     CALL FLSHLI	;Flush the rest of the line
	     RETSKP		;Go back +2
	   ENDIF.
	   ERRRET <Improper format for TTYINI.CMD>
	 ENDIF.
	SETZ B,			;Zero our sum
	DO.
	  CAIL A,"0"		;Is it an octal digit?
	   CAILE A,"8"
	    EXIT.		;No, go out
	  IMULI B,^D8		;Shift over one digit
	  ADDI B,-"0"(A)	;Add the char
	  ILDB A,TTYCMD		;Get the next char
	  LOOP.			;And try to understand it
	ENDDO.
	CAIL B,.TTDES		;Is it obviously not a terminal?
	IFSKP.
	  BOUND B,PTY		;Is this a PTY?
	ANNSK.
	  BOUND B,TVT		;Check for Internet
	ANNSK.
	  BOUND B,PNV		;And Ethernet
	ANNSK.
	ELSE.
	  CALL FLSHLI		;Yes, flush the rest of the line
	  RETSKP		;And go back winningly
	ENDIF.
	CALL SETTNO		;Set TTYINI for the terminal number
	 RET			;Propagated error return
	DO.
	  CAIN A,"!"		;Is this the beginning of the string?
	   EXIT.		;Yes, go out
	  CAIE A,.CHCRT		;Is it a CR?
	  IFSKP.
	    IBP TTYCMD		;Yes, flush past the LF
	    RETSKP		;And say we parsed this one okay
	  ENDIF.
	  ILDB A,TTYCMD		;Otherwise get another character
	  LOOP.			;And use that one
	ENDDO.
	MOVEI B,B%STRL*5-1	;Maximum number of chars we can have
	DO.
	  ILDB A,TTYCMD		;Get a char
	  JUMPE A,ENDLP.	;Go out on null
	  CAIN A,.CHCRT		;Or a carriage return
	   EXIT.
	  IDPB A,C		;Drop it on our destination string
	  SOJG B,TOP.		;Get more if we have room
	  CALL FLSHLI		;Flush the rest of the line
	  SETZ A,		;Make sure we don't increment past crlf
	ENDDO.
	SETZ B,			;Get a null
	IDPB B,C		;And drop it in
	CAIN A,.CHCRT		;Did we stop because of a CR?
	 IBP TTYCMD		;Yes, increment past the LF
	RETSKP			;And go back +2

;Takes B/ Terminal number
;Returns C/ Pointer to destination

SETTNO:	CAIG B,MAXTTY		;Is this terminal number too large?
	IFSKP.			;Yes, return an error
	  ERRRET <Terminal number in TTYINI.CMD too large>
	ENDIF.
	MOVEM B,C		;Get our terminal number
	IMULI C,B%MAX		;Multiply by the size of each entry
	ADD C,[POINT 7,B%ADDR+TTILOC] ;Make a byte pointer to that location
	CAMG B,TTILOC		;Is it larger than the largest tty we know?
	 RETSKP			;No, go back now
	HRRZM C,D		;If it is, set up this location in B
	SUB B,TTILOC		;Set up how many we have to initialize
	ADDM B,TTILOC		;Save away new maximum tty number we know
	DO.
	  SETOM (D)		;Set this line to have no location
	  SUBI D,B%MAX		;Point to next block down
	  SOJG B,TOP.		;Loop through all we need to
	ENDDO.
	RETSKP			;Go back when we're done
	ENDAV.

;BLDDEF - Build default strings from TTYLOC.CMD
;Returns +1 - failure
;	 +2 - success

BLDDEF:	ACVAR <TLCCMD>
	SAVEAC <B,C>
	MOVE TLCCMD,[POINT 7,TLCLOC] ;Pointer to our file
	SETOM OVRFLW		;Say we don't have an overflow
	MOVEI A,MAXTLD		;Maximum number of names we can handle
	MOVEM A,TLCTAB		;Save it away for our TBLUK% table
	MOVEI A,TLCFRS		;Pointer into our host name entries
	MOVEM A,TLCFRP		;Save it away
	DO.
	  ILDB A,TLCCMD		;Get a char
	  CAIE A,";"		;A comment?
	  IFSKP.		;Yes...
	    CALL FLSHLC		;Flush the rest of the line
	    LOOP.		;And go for the next line
	  ENDIF.
	  CAIE A,.CHCRT		;A CR?
	   CAIN A,.CHLFD	;Or a LF?
	    LOOP.		;Ignore it, go to next char
	  CAIE A," "		;A space?
	   CAIN A,.CHTAB	;Or a tab?
	    LOOP.		;Same fate
	  JUMPE A,RSKP		;If a null, we're done
	  CALL ADDLIN		;Otherwise add a line
	   RET			;If it failed, go back +1
	  LOOP.			;Otherwise get another line
	ENDDO.

FLSHLC:	DO.
	  CAIN A,.CHLFD		;Did we get a line feed?
	   RET			;Yes, go out now
	  JUMPE A,R		;Go out if it's a null
	  ILDB A,TLCCMD		;Get a byte
	  LOOP.			;And try that one
	ENDDO.

ADDLIN:	MOVE B,TLCFRP		;Get the pointer to name storage
	CAIL B,TLCFRP		;Did we overflow our free storage for that?
	 JRST OFLOW		;Yes, say so
	HRLZM B,D		;Save pointer to host name
	HRLI B,(<POINT 7,0>)	;Make it a byte pointer
	DO.
	  CAIN A,":"		;Is it the delimiting colon?
	   EXIT.		;Yes, go out
	  JUMPE A,NOHOST	;If end of file, we didn't get a host name
	  CAIN A,.CHCRT		;Same if it's a CR
	   JRST NOHOST
	  IDPB A,B		;Otherwise drop it on our name
	  ILDB A,TLCCMD		;Get the next byte
	  LOOP.			;And process it
	ENDDO.
	SETZ A,			;Get a null
	IDPB A,B		;Drop it on our string
	MOVEM B,C		;Copy the byte pointer elsewhere, too
	IBP B			;Now increment to our next location will be
	HRRZS B			;Now isolate the right halves
	HRRZS C
	CAMN B,C		;Is the null the last char on that word?
	 AOS B			;No, go to the next word
	MOVEM B,TLCFRP		;Save it away just in case...
	CAIL B,TLCFRP		;Did we run out of free space?
	 JRST OFLOW		;Yes, say we ran out of free space
	HRRM B,D		;Save away where the definition will be
	HRLI B,(<POINT 7,0>)	;Make this a byte pointer
	DO.			;Flush until we have something
	  ILDB A,TLCCMD		;Get the char
	  CAIE A,.CHTAB		;A tab?
	   CAIN A," "		;Or a space?
	    LOOP.		;One of the two, get the next char
	ENDDO.
	DO.
	  JUMPE A,ENDLP.	;Go out on end of file
	  CAIE A,.CHCRT		;Carriage return?
	  IFSKP.		;Yes...
	    IBP TLCCMD		;Bump up the byte pointer past the LF
	    EXIT.		;And go out
	  ENDIF.
	  IDPB A,B		;Otherwise drop it in our string
	  ILDB A,TLCCMD		;Get the next char
	  LOOP.			;And try it out
	ENDDO.
	SETZ A,			;Get a null
	IDPB A,B		;Drop it on our string
	MOVEM B,C		;Copy the byte pointer elsewhere, too
	IBP B			;Now increment to our next location will be
	HRRZS B			;Now isolate the right halves
	HRRZS C
	CAMN B,C		;Is the null the last char on that word?
	 AOS B			;No, go to the next word
	MOVEM B,TLCFRP		;Save it away just in case...
	CAIL B,TLCFRP		;Did we run out of free space?
	 JRST OFLOW		;Yes, say we ran out of free space
	MOVEI A,TLCTAB		;Get a pointer to our table
	MOVE B,D		;Get the entry we want to make
	TBADD%			;Add it in
	IFJER.			;If we had an error
	  MOVEI A,.FHSLF	;Want the latest error
	  GETER%		;Try to get it
	  CAMN B,[.FHSLF,,TADDX2] ;Was that entry already there?
	ANSKP.			;Yes, don't bother
	  AOSE OVRFLW		;Otherwise, was an overflow
	   RETSKP		;Already did it, so don't worry
	  WMSG <Overflowed default TTYLOC location table
>
	  RETSKP		;Otherwise give the warning and return
	ENDIF.
	RETSKP			;If here then we parsed winningly

OFLOW:	AOSE OVRFLW		;Did we have an overflow before?
	 RETSKP			;Yes, go back now
	MOVE A,TLCFRP		;Get the free pointer
	CAIG A,TLCFRP		;Did we really go over?
	IFSKP.			;Yes...
	  ERRRET <Storeage for TTYLOC default names overflowed>
	ENDIF.
	WMSG <Storage for TTYLOC default names overflowed>
	RETSKP			;But don't give an error
	ENDAV.

NOHOST:	ERRRET <Couldn't find end of host name>

;GTTLOC - Get our TTYLOC location
;Takes B/ Terminal number

GTTLOC:	SAVEAC <A,B,C,D>
	SKIPGE TTLJFN		;Do we have TTYLOC?
	 JRST USETTI		;No, use TTYINI
	CAML B,MAXTLE		;Can we have a TTYLOC entry for this one?
	 JRST USETTI		;No, use TTYINI
	MOVEI A,.TTDES(B)	;Get terminal designator in A
	IMULI B,.TDLEN		;Multiply terminal number by block length
	MOVEI D,TTLLOC(B)	;Get location for entry in D
	SKIPE .TDLKD(D)		;Is this entry locked?
	 JRST USETTI		;Yes, use TTYINI
	HRROI B,C		;Put results in C
	MOVEI C,.JIJNO		;Say we're going to want the job number
	GETJI%			;See if the job numbers match
	 ERJMP USETTI		;Some sort of error, hopefully no such job
	LOAD A,TL%JOB,.TDWHO(D) ;Get the job number of that entry
	CAME A,C		;Do they match?
	 JRST USETTI
	HRROI B,C		;Yes, want user number now (job # in A)
	MOVEI C,.JIUNO
	GETJI%			;Get it
	 ERJMP USETTI
	LOAD A,TL%USR,.TDWHO(D) ;Get the user number
	HRRZS C			;Isolate the right half
	CAME A,C		;Do they match?
	 JRST USETTI		;If not, don't use it
	MOVE A,[POINT 7,LOCBUF] ;Pointer to where we want to store the name
	MOVEI B,.TDLOC(D)	;Get location that has the string in B
	HRLI B,(<POINT 7,0>)	;Make it a byte pointer
	CALL CPYSTR		;Copy it
	SETZ B,			;Get a null
	IDPB B,A		;Drop it on the end
	MOVE A,[POINT 7,LOCBUF] ;Get the pointer again
	ILDB A,A		;Get the first char
	JUMPE A,USETTI		;If it's a null, then don't use TTYLOC
	RET			;Go back

USETTI:	TXZ FL,GL%LOC		;Flag not to use TTYLOC
	RET			;And go back

;MAPNET - Map in a network
;Takes A/ Network number
;Returns +1 - no such network
;	 +2 - success

MAPNET:	SAVEAC <B,C>
	HLRZ B,CURHST		;See if we match the current host
	CAMN A,B		;Do they match?
	 RETSKP			;Yes, go back +2
	HRLZM A,CURHST		;Save this as new network, clear host
	SETO A,			;To unmap
	MOVE B,[.FHSLF,,TTNNET/1000] ;Want to unmap net page
	SETZ C,
	PMAP%			;Do it
	HLRZ A,CURHST		;Get the network again that we want
	MOVE A,TTNPG0+NETADR(A) ;Get what page number this net is on
	IFL. A			;If it doesn't exist
	  SETZM CURHST		;Say we don't have this host
	  RET			;And go back +1
	ENDIF.
	HRL A,TTIJFN		;Otherwise get the JFN for the bin file
	MOVE B,[.FHSLF,,TTNNET/1000] ;Map into network page
	MOVX C,PM%RD		;Want read access
	PMAP%			;Map it in
	RETSKP			;And go back +2

;MAPHST - Map in a host given the network
;Takes A/ Host number
;Returns +1 - no such host
;	 +2 - success

MAPHST:	SAVEAC <B,C,D>
	HRRZ B,CURHST		;Get our current host number
	CAMN A,B		;Do they match?
	 RETSKP			;Yes, go back now
	MOVEM A,D		;Save the host number
	SETO A,			;Want to unmap
	MOVE B,[.FHSLF,,TTNHST/1000] ;Want to unmap from the host area
	MOVE C,HSTLEN		;How many pages
	TXO C,PM%CNT		;Multiple pages
	PMAP%			;Do it
	HLLZS CURHST		;Since we unmapped make sure no current host
	MOVE A,D		;Get back the host number
	DO.
	  MOVE D,TTNNET(D)	;Get this host number
	  JUMPL D,R		;If no such host, go back +1
	  TLNN D,-1		;Is this a pointer?
	   EXIT.		;No, go out
	  HLRZ A,D		;It's a pointer, get the new host
	  CALL MAPHST		;Try to map it
	   RET			;Failed, go back +1
	  HRRZ A,D		;Copy back the host number
	  LOOP.			;And try this one
	ENDDO.
	HRRM A,CURHST		;Save the current host away
	MOVE A,D		;Get the page number in A
	HRL A,TTIJFN		;Get the JFN for the bin file
	MOVE B,[.FHSLF,,TTNHST/1000] ;Map into the host page
	MOVX C,PM%RD		;Read access
	PMAP%			;Do it
	MOVE C,TTNHST+NUMTTY	;Find out how many terminals
	IMUL C,TTNPG0+BLKSIZ	;Make it how many words
	ADDI C,TTYBLK		;Account for header data
	LSH C,-<^D9>		;Make it a number of pages
	CAIGE C,MAXHSL		;Too many pages?
	IFSKP.			;Yep...
	  ERRRET <Host data too large for buffer>
	ENDIF.
	MOVEM C,HSTLEN		;Save as how long
	AOS HSTLEN		;Make it number of pages
	IFN. C			;If we have anything to map
	  AOS A			;Want to point to next page to map in
	  MOVE B,[.FHSLF,,<TTNHST/1000>+1] ;Continuation of map
	  TXO C,PM%RD+PM%CNT	;Multiple page
	  PMAP%			;Do it
	ENDIF.
	RETSKP			;Go back winningly

;CPYSTR - Copy a string to a destination without copying null
;Takes A/ Byte pointer to destination
;      B/ Byte pointer to source

CPYSTR:	SAVEAC <C>
	DO.
	  ILDB C,B		;Get a byte
	  JUMPE C,R		;Go back on a null
	  IDPB C,A		;If non-null, drop it
	  LOOP.			;And get another char
	ENDDO.

.ENDPS

END
