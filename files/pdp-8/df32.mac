TITLE	DF32 SIMULATION FOR THE PDP8 SIMULATOR	VERSION #2	SEPT. 1 '69
	SUBTTL	DAVE MCCLURE JULY 1969

	IFE DDF32,<PASS2
	END>


EXTERNAL	ERROR,TIME,NTIME,CORE,SIXOUT
ENTRY	DDATA,DCDATA,DCMA,DMAR,DMAW,DCEA,DSAC,DEAL,DEAC,DFSE,DFSC,DMAC,DMA,DFIELD

	WC=7750
	CA=7751
	IFE PACK,<
	EXTERNAL	FETPNT
WCPOINT:	POINT	12,CORE+2515,23
CAPOINT:	POINT	12,CORE+2515,35>

;DEVICE DATA BLOCK
DDATA:	^D259
	Z
	XWD	DACTIV,0	;NO FLAGS FOR TIME CONTROL TO SET
	Z

;FILE DATA BLOCK
DCDATA:	XWD	0,100!D		;DUMP MODE, NONSTANDARD BIT ON
	SIXBIT	/DSK/
	XWD	DISKO,DISKI
	Z
	DENTR
	EXP	0,0,0,0,0

DWLOCK:	IFE <DDF32-1>,<XWD -4,-4>	;BITS IN LEFT DEFINE EXISTENCE
	IFE <DDF32-2>,<XWD -16,-16>
	IFE <DDF32-3>,<XWD -64,-64>	;BITS IN RIGHT DEFINE WRITE LOCK
	IFE <DDF32-4>,<XWD -256,-256>

DMA:	0			;BITS 19 & 20 SELECT A UNIT
				;BITS 21-24 SELECT A TRACK
				;BITS 25-35 SELECT A WORD
DFIELD:	0			;MEMORY FIELD FOR DATA TRANSFERS

;<6601>	CLEAR DISK MEMORY ADDRESS REGISTER, & DISK FLAGS
DCMA:	MOVEI	AC0,370000
	ANDM	AC0,DMA
	TRZ	FLAGS,DPER!DCFLG!DEFLG	;CLEAR FLAGS
	POPJ	PDP,

;<6603>	LOAD DISK MEMORY ADDRESS REGISTER FROM THE AC,CLEAR AC AND READ
DMAR:	EXCH	CFSTAT,DCDATA+CFSTAT
	TLZ	CFSTAT,FOUTB	;SET INPUT BEING DONE
	MOVE	AC0,[XWD 400000,RBREAK]	;ADDRESS OF ROUTINE FOR DATA BREAK
	JRST	TIMEC

;<6605>	LOAD DISK MEMORY ADDRESS REGISTER AND WRITE
DMAW:	EXCH	CFSTAT,DCDATA+CFSTAT
	TLO	CFSTAT,FOUTB	;SET OUTPUT BEING DONE
	MOVE	AC0,[XWD 400000,WBREAK]
	JRST	TIMEC

;ROUTINE TO HANDLE COMMON PARTS OF DMAR AND DMAW
TIMEC:	MOVEM	AC0,DDATA+3
	MOVE	AC0,AC		;LOAD AC
	ANDI	AC,10000	;CLA
	ANDI	AC0,7777	;REMOVE LINK FROM WORKING COPY
	MOVE	AC1,DMA		;LOAD THE DISK MEMORY ADDRESS
	ANDI	AC1,370000	;REMOVE LOW ORDER 12 BITS IF PRESENT
	IOR	AC0,AC1		;NEW DISK MEMORY ADDRESS
	MOVEM	AC0,DMA
	TRZ	FLAGS,DPER!DEFLG!DCFLG	;CLEAR FLAGS
	PUSHJ	PDP,OPEN
	TRNE	FLAGS,DEFLG	;ADDRESS ILEGAL
	JRST	TEXIT		;YES!
	TLO	FLAGS,DACTIVE	;SET DISK ACTIVE
	PUSHJ	PDP,BTCALC
	MOVE	AC1,TIME
	ADDI	AC1,100		;FUDGE FACTOR SO DON'T TRY TOO SOON
	CAMG	AC0,AC1		;THIS REVOLUTION?
	ADDI	AC0,^D133333	;NEXT
	MOVEM	AC0,DDATA+1	;TIME FOR NEXT DATA BREAK
	CAMGE	AC0,NTIME	;NEXT FLAG?
	MOVEM	AC0,NTIME	;YES
	TLNN	CFSTAT,FOUTB	;IF READING SKIP TO TEXIT

	JRST	TEXIT		;YES
	IFE PDP8S,<MOVEI	AC0,^D216>
	IFN PDP8S,<MOVEI	AC0,^D18>
	ADDM	AC0,TIME	;ADD TIME FOR THIS DATA BREAK
	IFN PACK,<
	AOS	AC0,CORE+WC
	AOS	AC1,CORE+CA
	TRNE	AC1,770000	;OVERFLOW?
	SETZM	CORE+CA		;YES
	IOR	AC1,DFIELD	;ADD FIELD TO ADDRESS
	MOVE	MB,CORE(AC1)	;LOAD DATA>
	IFE PACK,<
	LDB	AC0,WCPOINT
	AOS	AC0
	DPB	AC0,WCPOINT
	LDB	AC1,CAPOINT
	AOS	AC1
	DPB	AC1,CAPOINT
	ANDI	AC1,7777
	IOR	AC1,DFIELD
	IDIVI	AC1,3
	LDB	MB,FETPNT(AC2)>
	IDPB	MB,DISKO+1
	TRNE	AC0,10000	;WRITING SINGLE WORD?
	PUSHJ	PDP,WBL		;YES
TEXIT:	EXCH	CFSTAT,DCDATA+CFSTAT	;RESTORE CFSTAT
	POPJ	PDP,		;RETURN TO TIME CONTROL IN PDP8

;CLEAR THE DISK EXTENDED ADDRESS AND MEMORY ADDRESS EXTENSION REGISTER.
DCEA:	SETZM	DMA		;<6611>
	POPJ	PDP,

;SKIP THE NEXT INSTRUCTION IF THE ADDRES CONFIRMED FLAG IS A 1.(CLEAR AC)
DSAC:	ANDI	AC,10000	;<6612> SKIP ON ADDRES CONFIRMED FLAG
DSAC1:	TLNN	FLAGS,DACTIVE	;READING OR WRITING?
	POPJ	PDP,		;DISK NOT TRANSFERRING SO NEVER SKIP
	MOVE	AC0,TIME
	ADDI	AC0,^D64	;TIME BEFORE BREAK WHEN FLAG IS SET
	CAMG	AC0,DDATA+1	;TO SOON?
	POPJ	PDP,		;YES
	AOS	PC		;FLAG SET SO SKIP
	POPJ	PDP,

;CLEAR THE DISK EXTENDED ADDRESS AND MEMORY ADDRESS REGISTER.
;THEN LOAD THE DISK EXTENDED ADDRESS AND MEMORY ADDRES REGISTERS WITH THE
;TRACK ADDRESS DATA HELD IN THE ACCUMULATOR.
DEAL:	MOVE	AC0,AC		;<6615>
	ANDI	AC0,70		;LEAVE ONLY THE CORE FIELD
	LSH	AC0,^D9		;POSITION AS AN ADD FIELD
	MOVEM	AC0,DFIELD	;SAVE THE FIELD
	MOVE	AC0,AC
	ANDI	AC0,3700
	CAIL	AC0,DDF32*1000
	TRO	FLAGS,DEFLG	;ILLEGAL ADDRESS
	LSH	AC0,^D6		;RIGHT JUSTIFY
	MOVEM	AC0,DMA
	POPJ	PDP,

;CLEAR THE ACCULULATOR, THEN LOAD THE CONTENTS OF THE DISK EXTENDED ADDRESS
;REGISTER INTO THE AC, AND 4 FLAGS FOR PROGRAMMER EVALUATION.
;SKIP IF ADDRESS CONFIRMED FLAG IS SET
DEAC:	ANDI	AC,10000	;<6616> CLA
	MOVE	AC0,DMA
	LSH	AC0,-^D6	;RIGHT JUSTIFY
	ANDI	AC0,3700
	IOR	AC,AC0		;LOAD THE AC
	MOVE	AC0,DFIELD	;LOAD THE CORE FIELD
	LSH	AC0,-^D9
	IOR	AC,AC0		;OR IN THE CORE FIELD
	MOVE	AC0,TIME
	ADD	AC0,RUNTIME
	IDIVI	AC0,^D133333
	CAIL	AC1,^D132533
	TRO	AC,4000		;PHOTO SYNC BIT
	MOVE	AC0,DWLOCK
	LDB	AC1,[POINT 3,DMA,21]	;SHIFT COUNTER FOR MASK
	MOVEI	AC2,1
	LSH	AC2,(AC1)
	TLNE	AC0,(AC2)
	TRO	AC,2		;SET NONEXISTENT DISK BIT
	JRST	DSAC1

DFSE:	TRNN	FLAGS,DEFLG	;WRITE LOCK OR NONEXISTENT CONDITION?
	AOS	PC		;<6621>
	POPJ	PDP,

;SKIP THE NEXT INSTRUCTION IF THE COMPLETION FLAG IS 1(TRANSFER COMPLETE)
DFSC:	TRNE	FLAGS,DCFLG	;<6622>
	AOS	PC		;SKIP
	POPJ	PDP,

DMAC:	MOVE	AC0,DMA		;<6626>
	ANDI	AC0,7777
	ANDI	AC,10000	;CLA
	IOR	AC,AC0
	POPJ	PDP,

;OPEN THE FILE IF NOT ALREADY OPEN, IF DOESN'T EXIST CREATE A FILE
OPEN:	TLOE	CFSTAT,ENTRB	;ENTER ALREADY BEEN DONE?
	JRST	BLOCK		;YES SO JUST DO I-O
	MOVE	AC0,DCDATA+1	;LOAD THE DEVICE LOGICAL NAME
	CALLI	AC0,4		;GET DEVICE CHARACTERISTICS
	MOVEM	AC0,DCDATA+CDCHAR
	TLNN	AC0,DVDSK
	JRST	NTDSK
OPEN1:	OPEN	1,DCDATA
	PUSHJ	PDP,ERROR
	PUSHJ	PDP,LOOK	;DO LOOKUPS IF DISK
	IN	1,
	JRST	.+2
	PUSHJ	PDP,ERROR
	OUT	1,		;ESTABLISH OUTPUT BUFFERS
	JRST	BLOCK
	PUSHJ	PDP,ERROR

BLOCK:	TLNE	CFSTAT,FOUTB	;OUTPUT?
	JRST	BLOCKO		;YES OUTPUT

	PUSHJ	PDP,BLCKI
	MOVEM	AC2,DISKI+1
	MOVEM	AC3,DISKI+2
	AOS	DISKI+2
	POPJ	PDP,

;READ A BLOCK(DETERMINED FROM DMA) AS FIRST STEP OF READ OR WRITE.
BLCKI:	MOVE	AC0,DMA		;LOAD DISK MEMORY ADDRESS
	IDIVI	AC0,600		;CALCULATE BLOCK NUMBER
	MOVEM	AC0,BLOCKN
BLCKI1:	AOS	AC0,BLOCKN
	CAILE	AC0,256*DDF32
	JRST	NEXD		;READ OR WRITE OUT OF BOUNDS
	USETI	1,@BLOCKN#	;INDICATE INPUT BLOCK NUMBER
	IN	1,IOLST		;GET BLOCK
	JRST	.+2		;OK SO SKIP
	PUSHJ	PDP,ERROR
	MOVE	AC2,[POINT 12,DATA]	;BYTE POINTER FOR THE BUFFER
	MOVEI	AC3,600		;BYTE COUNT FOR ENTIRE BUFFER
	TLNE	FLAGS,DACTIVE
	JRST	SECOND		;NO FIDDLING WITH POINTERS
	SOJL	AC1,POP
	IBP	AC2
	SOJA	AC3,.-2
POP:	POPJ	PDP,

SECOND:	MOVEM	AC2,DISKI+1
	MOVEM	AC3,DISKI+2
	MOVEM	AC2,DISKO+1
	MOVEM	AC3,DISKO+2
	POPJ	PDP,

BWRITE:	USETO	1,@BLOCKN
	OUT	1,IOLST
	JRST	BLOCKO
	PUSHJ	PDP,ERROR
BLOCKO:	PUSHJ	PDP,BLCKI	;FIRST GET THE PRESENT COPY OF THE BLOCK
	MOVEM	AC2,DISKO+1
	MOVEM	AC3,DISKO+2
	POPJ	PDP,

NEXD:	TLZ	FLAGS,DACTIVE	;KILL TRANSFER
	TRO	FLAGS,DEFLG	;NOTE ERROR
	POPJ	PDP,

;TRYING TO USE A DISK FILE, BUT ONE DOESN'T EXIST YET SO MAKE ONE OF PROPER LENGTH
CREATE:	RELEASE	1,
	MOVE	AC4,DCDATA
	MOVEI	AC0,I		;IMAGE MODE
	MOVEM	DCDATA		;SET TO MODE STANDARD
	MOVSI	AC0,<-^D256*DDF32>-1
	OPEN	1,DCDATA	;REOPEN FILE
	PUSHJ	PDP,ERROR
	MOVEM	AC4,DCDATA	;RESTORE ORIGINAL DCDATA CONTENTS
	ENTER	1,DENTR		;DO ENTER SO WE CAN WRITE FILE
	PUSHJ	PDP,ERROR	;FAILURE?
	MOVEI	AC1,0		;BIT PATTERN TO LOAD IN OUTPUT FILE
C0:	SOSG	DISKO+2		;MORE ROOM IN THE BUFFER?
	JRST	C2		;GET ANOTHER BUFFER TO FILL
C1:	IDPB	AC1,DISKO+1
	AOJA	AC1,C0		;CHANGE DATA TO WRITE
C2:	OUTPUT	1,
	AOBJN	AC0,C1
	RELEASE	1,		;CLOSE FILE
	JRST	OPEN1		;NOW REOPEN WITH CREATED FILE

;CALCULATE TIME FOR A DATA BREAK FOR THE CURRENT DMA ON THIS REVOLUTION
;CALL	PUSHJ	PDP,BTCALC	TIME RETURNED IN AC0
BTCALC:	MOVE	AC0,TIME
	IDIVI	AC0,^D133333
	IMULI	AC0,^D133333
	MOVE	AC1,DMA
	TRNN	AC1,1000
	ADDI	AC0,^D65	;FUDGE FACTOR
	TRNN	AC1,2000	;ADDRES FOR 2xxx OR 3xxx
	ADDI	AC0,^D130
	ANDI	AC1,777
	IMULI	AC1,^D259
	ADD	AC0,AC1
	POPJ	PDP,

WBREAK:	IFN PDP8S,<MOVEI	AC0,^D18>
	IFE PDP8S,<MOVEI	AC0,^D216>
	ADDM	AC0,TIME
	AOS	AC2,DMA
	TRNN	AC2,7
	SOS	DDATA+1		;TIME DELAY FUDGE
	AOS	AC2		;WILL NEXT WORD FOLLOW THE
	TRNN	AC2,777		;REFLECTIVE STRIP
	PUSHJ	PDP,DELAY	;YES
	SOSG	DISKO+2		;MORE SPACE IN BUFFER
	PUSHJ	PDP,BWRITE	;NO
	IFN PACK,<
	AOS	AC0,CORE+WC
	TRNE	AC0,770000	;CARRY OUT OF MS BIT?
	SETZM	CORE+WC		;YES SO ZERO WORD COUNT
	AOS	AC1,CA+CORE	;LOAD CURRENT ADDRESS
	TRZE	AC1,770000	;SPILL OUT OF 12 BITS?
	SETZM	CORE+CA		;YES
	IOR	AC1,DFIELD
	MOVE	MB,CORE(AC1)	;GET DATA TO WRITE>
	IFE PACK,<
	LDB	AC0,WCPOINT
	AOS	AC0
	DPB	AC0,WCPOINT
	LDB	AC1,CAPOINT
	ANDI	AC1,7777
	IOR	AC1,DFIELD
	IDIVI	AC1,3
	LDB	MB,FETPNT(AC2)
	MOVE	AC1,AC2>
	IDPB	MB,DISKO+1	;WRITE TO BUFFER
	TRNN	AC0,10000	;OVERFLOW, IE 0?
	POPJ	PDP,
WBL:	MOVEI	AC1,LASTWB	;ONE MORE INTERRUPT
	MOVEM	AC1,DDATA+3
	IFN PACK,<SETZM	CORE+WC>
	USETO	1,@BLOCKN
	OUT	1,IOLST		;WRITE
	POPJ	PDP,
	PUSHJ	PDP,ERROR

LASTWB:	TRO	FLAGS,DCFLG	;SET WRITE COMPLETED
	POPJ	PDP,


RBREAK:	IFN PDP8S,<MOVEI	AC0,^D18>
	IFE PDP8S,<MOVEI	AC0,^D216>
	ADDM	AC0,TIME
	AOS	AC2,DMA
	TRNN	AC2,7
	SOS	DDATA+1		;ADD FUDGE FACTOR TO TIME
	TRNN	AC2,777
	PUSHJ	PDP,DELAY	;REFLECTIVE STRIP PAUSE
	SOSG	DISKI+2		;MORE DATA IN BUFFER?
	PUSHJ	PDP,BLCKI1
	ILDB	MB,DISKI+1	;READ WORD
	IFN PACK,<
	AOS	AC0,CORE+WC
	TRNE	AC0,770000	;OVERFLOW?
	SETZM	CORE+WC
	AOS	AC1,CORE+CA
	TRZE	AC1,770000	;TOO LARGE?
	SETZM	CORE+CA		;YES
	IOR	AC1,DFIELD
	MOVEM	MB,CORE(AC1)	;WRITE MEMORY>
	IFE PACK,<
	LDB	AC0,WCPOINT
	AOS	AC0
	DPB	AC0,WCPOINT
	LDB	AC1,CAPOINT
	AOS	AC1
	DPB	AC1,CAPOINT
	ANDI	AC1,7777
	IOR	AC1,DFIELD
	IDIVI	AC1,3
	DPB	MB,FETPNT(AC2)>
	TRNN	AC0,770000
	POPJ	PDP,		;STILL MORE TO WRITE
	TLZ	FLAGS,DACTIV
	TRO	FLAGS,DCFLG
	POPJ	PDP,
DELAY:	PUSHJ	PDP,BTCALC	;DELAY FOR REFLECTIVE STRIP
	ADDI	AC0,^D133333
	MOVEM	AC0,DDATA+1
	POPJ	PDP,

DISKI:	BLOCK	3		;INPUT HEADER
DISKO:	BLOCK	3		;OUTPUT HEADER
DENTR:	SIXBIT	/DF32/
	SIXBIT	/FIL/
	BLOCK	2

LOOK:	MOVE	AC0,DCDATA+CDCHAR
	TLNN	AC0,DVDSK	;DISK?
	POPJ	PDP,		;NO SO MUST BE DECTAPE, DONE
	LOOKUP	1,DENTR		;TRY TO EXECUTE A LOOKUP
	JRST	CREATE
	ENTER	1,DENTR
	PUSHJ	PDP,ERROR
	POPJ	PDP,

NTDSK:	TLNN	AC0,DVDEC	;DECTAPE?
	PUSHJ	PDP,ERROR
	OUTSTR	[ASCIZ /

MAY I DESTROY THE PDP-10 FILE STRUCTURE ON /]
	MOVE	AC1,DCDATA+1
	PUSHJ	PDP,SIXOUT
	OUTSTR	[ASCIZ	/ (Y or N) /]
	INCHRW	AC0
	CAIE	AC0,131		;"Y"?
	PUSHJ	PDP,ERROR
	OUTSTR	[ASCIZ /YES

/]
	JRST	OPEN1		;DECTAPE AND I WARNED HIM SO CONTINUE

IOLST:	IOWD	200,DATA
	Z

DATA:	BLOCK	200		;BUFFER AREA FOR DUMP MODE IO

	END
 