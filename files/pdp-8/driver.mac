	TITLE	DRIVER FOR THE PDP8 SIMULATOR	VERSION #2	SEPT. 1 '69
	SUBTTL	DAVE MCCLURE	JULY/9/69

EXTERNAL	DOOR,INI,S,C,L,DP,E,SS,.JBDDT,STARTT,IF,IBR
EXTERNAL	FETCHY,STOREY,PRINT,FCLOSE,SR,IFSW,DFSW,DFF,EXIT

IFE INLINE,<EXTERNAL CORE
IFE PACK,<EXTERNAL FETPNT>>

GO:	MOVEI	AC0,GO1
	MOVEM	AC0,DOOR		;SET RETURN ADDRESS
	JRST	INI		;INITIALIZE LOTS OF STUFF
GO1:	SIZE=<MEMSIZ-^D4096>/^D4096
	IFE SIZE, <OUTSTR [ASCIZ /You have a 4K simulated PDP/]
	RIMADR=7756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have aN 8K simulated PDP/]
	RIMADR=117756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 12K simulated PDP/]
	RIMADR=227756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 16K simulated PDP/]
	RIMADR=33756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 20K simulated PDP/]
	RIMADR=447756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 24K simulated PDP/]
	RIMADR=557756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 28K simulated PDP/]
	RIMADR=667756>
	SIZE=SIZE-1
	IFE SIZE,<OUTSTR [ASCIZ /You have a 32K simulated PDP/]
	RIMADR=777756>
	PURGE	SIZE
	IFE PDP8,<OUTSTR [ASCIZ /-8/]>
	IFE PDP8I,<OUTSTR [ASCIZ /8I/]>
	IFE PDP8S,<OUTSTR [ASCIZ /8S/]>
	IFE PDP8L,<OUTSTR [ASCIZ /8L/]>
	IFE INLINE,<OUTSTR [ASCIZ /(inline version)/]>
	IFN INLINE,<OUTSTR [ASCIZ /(subroutine version)/]>
	IFE PACK,<OUTSTR [ASCIZ / with a packed memory.

/]>
	IFN PACK,<OUTSTR [ASCIZ / with an unpacked memory.

/]>
	IFE ESTOP,<OUTSTR [ASCIZ /stop on illegal instructions
/]>
	IFN ESTOP,<OUTSTR [ASCIZ /noop illegal instructions
/]>
	IFE <DDF32-1>,<OUTSTR [ASCIZ /1 DF32 disk
/]>
	IFE <DDF32-2>,<OUTSTR [ASCIZ /2 DF32 disks
/]>
	IFE <DDF32-3>,<OUTSTR [ASCIZ /3 DF32 disks
/]>
	IFE <DDF32-4>,<OUTSTR [ASCIZ /4 DF32 disks
/]>
	IFE DRM08,<OUTSTR [ASCIZ /RM08
/]>
	IFE DCS680,<OUTSTR [ASCIZ /680/
/]>
	IFE PLOTER,<OUTSTR [ASCIZ /PLOTTER
/]>
	MOVEI	AC0,GO3
	MOVEM	AC0,DOOR		;SET RETURN ADDRESS

ENTRY	OPR,DRDATA,ALPHA,SIXOUT

;GET A COMMAND - DECODE IT AND DISPATCH TO PROPER ROUTINES
OPR:	CLRBFI			;DELETE TYPE AHEAD
	SETOM	AC0		;LOAD -1
	GETLIN	AC0		;GET CHARACTERISTIC OF THIS LINE
	TLZ	AC0,6		;SET TO FULL DUPLEX NORMAL MODE
	SETLIN	AC0		;EFFECT CHANGES
	OUTSTR	[ASCIZ /
*/]
	SETZM	LASTC#		;ENABLE COMMAND INPUT
	PUSHJ	PDP,SIXIN	;GET A COMMAND
	HLRZS	AC1		;REDUCE TO AT MOST 3 CHARACTERS
COM:	MOVSI	AC3,CLIST-ENDC	;ESTABLISH COUNTER
	HLRZ	AC4,CLIST(AC3)	;LOAD COMMAND TO COMPARE
	CAIE	AC1,(AC4)	;ARE THEY THE SAME?
	AOBJN	AC3,.-2		;N0 - TRY ANOTHER?
	MOVEI	AC3,(AC3)	;ZERO LEFT HALF OF AC3
	HRRZ	AC0,CLIST(AC3)	;LOAD DISPATCH ADDRESS
	CAIGE	AC3,LL		;IS THIS A CONSOL COMMAND?
	JRST	LEAVE		;YES SO CLEAN UP AREA BEFORE LEAVING
	JRST	(AC0)

;PUT NEXT CHARACTER IN AC2	IF ALPHABETIC SKIP RETURN
;				IF NOT ALPHABETIC NONSKIP RETURN
;TO CALL PUSHJ	PDP,ALPHA
ALPHA:	MOVE	AC2,LASTC
	CAIE	AC2,12		;WAS IT A LINE FEED
	INCHWL	AC2		;NO SO ITS OK TO READ ANOTHER
	MOVEM	AC2,LASTC	;NOTE LAST CHARACTER
	CAIL	AC2,101
	AOS	(PDP)
	CAILE	AC2,132
	SOS	(PDP)
	POPJ	PDP,

	MOVE	AC2,LASTC	;NOTE LAST CHARACTER
	CAIE	AC2,12		;WAS IT A LINE FEED?
	INCHWL	AC2		;NO SO GET NEXT CHARACTER
	MOVEM	AC2,LASTC	;REMEMBER WHAT WAS LAST CHARACTER
NUMER:	CAIL	AC2,60		;LESS THAN ASCII 0?
	AOS	(PDP)		;NO SO PERHAPS A SKIP
	CAILE	AC2,67		;LESS THAN ASCII 7?
	SOS	(PDP)		;NO SO CHANGE SKIP TO NONSKIP
	POPJ	PDP,

;GET AN OCTAL NUMBER FROM TTY, LOAD IN AC1 AND RETURN
;IF AN ERROR OCCURES (8 OR 9) "EH!"
OCTAL:	SETZ	AC1,
	MOVEI	AC3,^D11	;LOAD COUNTER FOR # OF DIGITS
OCT1:	PUSHJ	PDP,NUMER-4	;GET NUMBER
	JRST	OCT2		;NONNUMERIC
	ROT	AC2,-3		;LEFT JUSTIFY
	ROTC	AC1,3		;SAVE JUST ACQUIRED LSD
	SOJGE	AC3,OCT1	;CAN WE ACCEPT MORE?
	JRST	EH		;NO
OCT2:	CAIE	AC2,70		;ASCII "8"
	CAIN	AC2,71		;ASCII "9"
	JRST	EH		;YES
	CAIN	AC2,32(AC3)	;LEADING BLANK?
	JRST	OCT1		;YES
	POPJ	PDP,		;LEAVE

DDT:	HRRZ	AC0,.JBDDT	;LOAD EXIT WITH DDT START
	JUMPE	AC0,EH		;IF NO DDT THEM MOAN

LEAVE:	PUSHJ	PDP,ALPHA	;GET NEXT CHARACTER
	CAIE	AC2,12		;WAS IT A LINE FEED
	JRST	.-2		;NO
	JRST	(AC0)		;END OF LINE SO DISPATCH

RIM:	MOVEI	AC1,RIMADR	;LOAD ADDRES OF RIM LOADER
	JRST	ST+1

BIN:	MOVEI	AC1,MEMSIZ-1	;LOAD STARTING ADDRESS OF BINARY LOADER
	MOVEI	AC0,3777	;TELL LOADER TO USE HIGH SPEED READER
	MOVEM	AC0,SR
	JRST	ST+1		;START THE BINARY LOADER

EXTERNAL RDATA,PDATA,KDATA,TDATA
ZIP:	OUTSTR	[ASCIZ /READER/]
	MOVE	AC2,RDATA	;LOAD THE READER TIME CONSTANT
	PUSHJ	PDP,ZIP1
	MOVEM	AC1,RDATA	;STORE NEW TIME CONSTANT
	OUTSTR	[ASCIZ /PUNCH/]
	MOVE	AC2,PDATA
	PUSHJ	PDP,ZIP1
	MOVEM	AC1,PDATA
	OUTSTR	[ASCIZ /KEYBOARD/]
	MOVE	AC2,KDATA
	PUSHJ	PDP,ZIP1
	MOVEM	AC1,KDATA
	OUTSTR	[ASCIZ /TELEPRINTER/]
	MOVE	AC2,TDATA
	PUSHJ	PDP,ZIP1
	MOVEM	AC1,TDATA
	IFE PLOTER,<
	OUTSTR	[ASCIZ /PLOTTER/]
	MOVE	AC2,PLDATA
	PUSHJ	PDP,ZIP1
	MOVEM	AC1,PLDATA>
	JRST	REOPR		;GET ANOTHER CONSOLE COMMAND
ZIP1:	OUTSTR	[ASCIZ / speed was /]
	MOVE	AC1,[^D4000000]	;LOAD 4,000,000 QUARTER MICROSEC.
	IDIV	AC1,AC2		;GET CPS
	MOVEI	AC2,^D12	;LOAD DIGIT COUNTER
	SOJE	AC2,EH		;ARE THERE ANY DIGITS LEFT
	LSH	AC1,3		;SHIFT OFF MOST SIGNIFICANT ZERO
	TLNN	AC1,700000	;LEADING DIGIT A ZERO?
	JRST	.-3
	PUSHJ	PDP,OCTP+2	;TYPE TIME CONSTANT
	OUTSTR	[ASCIZ /cps, change to /]
	SETZM	LASTC		;ENABLE INPUT
	PUSHJ	PDP,OCTAL	;GET A NEW TIME CONSTANT
	CAIG	AC1,		;IS THE NUMBER 0 OR NEGATIVE?
	JRST	OCT3		;YES SO SKIP OUT
	MOVE	AC2,[^D4000000]	;LOAD 1 SECOND
	IDIV	AC2,AC1		;GET TIME CONSTANT
	MOVE	AC1,AC2		;PUT AC2 WHERE LEAVING WON'T KILL IT
	CAIG	AC1,		;ISCONSTANT 0 OR NEGATIVE
OCT3:	AOS	(PDP)		;YES
	POP	PDP,AC0
	JRST	LEAVE


;TYPE OUT FILE NAMES AND MODIFY IF REQUESTED
EXTERNAL	RCDATA,PCDATA,PRCDAT
FIL:	OUTSTR	[ASCIZ /READER/]
	MOVEI	FDB,RCDATA	;LOAD FDB WITH READER DATA BLOCK ADD
	JSP	AC0,FILE	;WORK WITH IT
	OUTSTR	[ASCIZ /PUNCH/]
	MOVEI	FDB,PCDATA	;LOAD FDB WITH PUNCH DATA BLOCK ADD
	JSP	AC0,FILE	;MASSAGE IT
	OUTSTR	[ASCIZ /PRINTER/]
	MOVEI	FDB,PRCDATA
	JSP	AC0,FILE
	IFE PLOTER,<EXTERNAL PLCDAT,PLDATA
	OUTSTR [ASCIZ /PLOTTER/]
	MOVEI	FDB,PLCDAT
	JSP	AC0,FILE>
	IFN DDF32,<EXTERNAL DCDATA
	OUTSTR [ASCIZ /DF32/]
	MOVEI	FDB,DCDATA
	JSP	AC0,FILE>
	JRST	REOPR		;RETURN TO COMMAND LEVEL
;TYPE	DEV:FILE.EXT	AND REQUEST MODIFICATIONS
;CALL:	LOAD FDB	JSP AC0,FILE
FILE:	OUTCHR	[11]		;TAB
	MOVE	AC1,CDNAM(FDB)	;LOAD DEVICE NAME
	PUSHJ	PDP,SIXOUT	;TYPE IT
	OUTCHR	[72]		;":"
	MOVE	AC1,@CDIR(FDB)	;FILE NAME
	PUSHJ	PDP,SIXOUT	;TYPE IT
	MOVE	AC1,CDIR(FDB)	;LOAD ADDRESS OF ENTER BLOCK
	HLLZ	AC1,1(AC1)	;GET FILE EXTENSION
	OUTCHR	[56]		;"."
	PUSHJ	PDP,SIXOUT	;TYPE IT
	OUTSTR	[ASCIZ / modify this with /]
	SETZM	LASTC		;ENABLE INPUT
	PUSHJ	PDP,SIXIN	;GET DEVICE NAME
	PUSH	PDP,AC1		;SAVE INPUT WORD FOR CLOSING TEST
	CAIE	AC2,72		;":"?
	JRST	FNME		;NO TRY FOR A FILE NAME INSTEAD
	MOVEM	AC1,CDNAM(FDB)	;SAVE DEVICE NAME
	PUSHJ	PDP,SIXIN	;GET FILE EXTENSION
FNME:	CAIE	AC1,0		;FILE NAME?
	MOVEM	AC1,@CDIR(FDB)	;YES SO SAVE
	PUSHJ	PDP,SIXIN	;GET EXTENSION
	MOVE	AC2,CDIR(FDB)	;ADDRESS OF ENTER BLOCK
	CAIE	AC1,0		;FILE EXTENSION HERE?
	HLLZM	AC1,1(AC2)	;YES SO SAVE IT
	POP	PDP,AC2
	CAME	AC1,AC2		;DEVICE NAME AND EXTENSION SAME?
	JSP	SRR,FCLOSE	;NO - SOMETHING CHANGED,CLOSE
	JRST	LEAVE

;TYPE SIXBIT CONTENTS OF AC1, UP TO 6 CHARS, STOP ON A BLANK
;DOESN'T USE AC0
;CALL		LOAD AC1	PUSHJ PDP,SIXOUT
SIXOUT:	MOVE	AC2,[POINT 6,AC1]	;BYTE POINTER TO GET CHARS
	MOVEI	AC4,6		;WATCH FOR MAX COUNT
	ILDB	AC3,AC2		;GET NEXT CHAR
	JUMPE	AC3,POP	;EXIT ON BLANK
	ADDI	AC3,40		;CONVERT TO ASCII
	OUTCHR	AC3		;TYPE
	SOJG	AC4,.-4
POP:	POPJ	PDP,



;PUT NEXT ALPHABETIC WORD FROM TTY IN AC1 AS LEFT JUSTIFIED SIXBIT.
;IF WORD IS MORE THAN SIX CHARACTERS SLUFF OFF TRAILING EXCESS.
;LEAVE THE DELIMITER IN AC2 AND LASTC.
SIXIN:	MOVEI	AC3,6		;LOAD A COUNTER FOR NUMBER OF CHARACTERS
	PUSHJ	PDP,ALPHA	;GET NEXT ALPHA CHAR
	JRST	.+2		;NOT ALPHA PERHAPS DIGIT?
	JRST	.+3		;ALPHABETIC SO CONTINUE
	PUSHJ	PDP,NUMER	;TEST FOR NUMERIC
	JRST	S2		;NOT NUMMERIC EITHER
	SUBI	AC2,40		;CONVERT TO SIXBIT
	ROT	AC2,-6		;LEFT JUSTIFY CHAR IN AC2
	LSHC	AC1,6		;PUT NEW CHAR IN AC1
	SOJG	AC3,SIXIN+1	;GET NEXT CHAR AND CONTINUE
	PUSHJ	PDP,ALPHA	;TOO MANY CHARACTERS!
	JRST	.+2		;FINALLY A DELIMITER
	JRST	.-2		;STILL MORE TO SLUFF
S2:	CAIN	AC2,32(AC3)	;PERHAPS A LEADING BLANK?
	JRST	SIXIN		;PROBABLY SO TRY AGAIN
	CAIN	AC3,		;IS SIXBIT WORD LEFT JUSTIFIED
	POPJ	PDP,		;AC1 FULLY JUSTIFIED SO RETURN
	LSH	AC1,6		;SHIFT ONE MORE POSITION
	SOJA	AC3,.-3		;MODIFY CHAR COUNT AND PROCEED


SW:	PUSHJ	PDP,OCTAL	;GET AN OCTAL NUMBER IN AC1
	MOVE	AC0,AC1
	ANDI	AC0,7777	;REDUCE TO 12 BITS
	MOVEM	AC0,SR		;LOAD SWITCH REGISTER
	PUSH	PDP,AC1
	ANDI	AC1,70000	;MASK OUT SR AND DFF
	MOVEM	AC1,IFSW	;STORE IFSW
	POP	PDP,AC1
	ANDI	AC1,700000	;MASK OUT IF AND SR
	LSH	AC1,-3		;POSITION
	MOVEM	AC1,DFSW	;STORE DFSW
	JRST	REOPR		;GET ANOTHER COMMAND AND CONTINUE

ST:	PUSHJ	PDP,OCTAL	;GET AN OCTAL NUMBER
	MOVE	PC,AC1		;LOAD PC
	ANDI	PC,7777		;REMOVE DFF AND IF IF PRESENT
	PUSH	PDP,AC1		;SAVE AC1
	ANDI	AC1,70000	;MASK OFF PC AND DFF
	MOVEM	AC1,IF		;AND SAVE IF
	MOVEM	AC1,IBR		;AND SAVE IBR
	POP	PDP,AC1		;RESTORE AC1
	ANDI	AC1,700000	;MASK OFF IF AND PC
	LSH	AC1,-3		;POSITION FOR DFF
	MOVEM	AC1,DFF		;AND SAVE DFF
	MOVEI	AC0,S		;PREPARE TO LEAVE
	JRST	LEAVE

DDD:	PUSHJ	PDP,PCSAVE	;SAVE PC
	PUSHJ	PDP,OCTAL	;GET FIRST ADDRESS
	ANDI	AC1,77777	;REMOVE DFF IF PRESENT
	MOVE	PC,AC1		;LOAD PC
	TRZ	PC,770000	;AND MASK OFF IF
	TRZ	AC1,707777	;MASK OFF DFF AND PC
	MOVEM	AC1,IF		;AND STORE IF
D1:	PUSHJ	PDP,OCTAL	;GET A DATA WORD
	CAIN	AC3,^D11		;WERE ANY DIGITS PICKED UP?
	JRST	PCREST		;NO SO RESTORE PC AND EXIT
	CAIN	AC2,72		;LAST CHAR A":"?
	JRST	DDD+2		;YES WE PICKED UP AN ADDRESS
	MOVE	MB,AC1		;SO LOAD MEMORY BUFFER
	ANDI	MB,7777		;AND MASK OFF EXTRA BITS
	MOVE	MA,PC		;LOAD ADDRESS FOR THE DATA
	PUSHJ	PDP,STOREY
	AOS	PC		;INCREMENT MEMORY ADDRESS
	TRZ	PC,10000	;TEST FOR PC CARRYOUT
	JRST	D1		;GET ANOTHER DATA WORD

;PRINT WORD(12 BITS) IN AC0
PWORD:	PUSH	PDP,AC0		;PRESERVE AC0
	MOVE	AC1,AC4		;LOAD WORD NUMBER
	IDIVI	AC1,30
	SKIPN	AC2		;DIVISIBLE BY 30?
	PUSHJ	PDP,LINEN	;YES SO A NEW LINE
	MOVEI	AC1,40		;LOAD A BLANK
	ANDI	AC2,7		;LEAVE RESIDUE MODULO 8
	JUMPN	AC2,.+3		;DIVISIBLE BY 8?
	PUSHJ	PDP,PRINT
	PUSHJ	PDP,PRINT
	PUSHJ	PDP,PRINT
	POP	PDP,AC0		;RESTORE AC0
PWRD:	ROT	AC0,-^D12	;LEFT JUSTIFY
	MOVEI	AC2,4		;DIGIT COUNTER
	HRRI	AC1,6
	ROTC	AC0,3		;SHIFT IN MSD AND CONVERT TO ASCII
	PUSHJ	PDP,PRINT
	SOJG	AC2,.-3
	POPJ	PDP,

CARRET:	MOVEI	AC1,15		;CARRIAGE RETURN
	PUSHJ	PDP,PRINT
	MOVEI	AC1,12		;LINE FEED
	PUSHJ	PDP,PRINT
	POPJ	PDP,		;RETURN

LINEN:	PUSHJ	PDP,CARRET	;CARRIAGE RETURN LINE FEED
	TRNN	AC4,37		;EXTRA CARRIAGE RETURN FOR LEGIBILITY?
	PUSHJ	PDP,CARRET	;YES
	SKIPE	AC1,IF
	ORI	AC1,600000	;CONVERT TO ASCII NUMBER
	IORI	AC1,400000	;CONVERT TO ASCII OR BLANK
	LSH	AC1,-^D12	;RIGHT JUSTIFY
	PUSHJ	PDP,PRINT
	MOVE	AC0,AC4
	PUSHJ	PDP,PWRD	;PRINT LSD'S OF ADDRESS
	MOVE	AC0,AC4
	IDIVI	AC0,30
	MOVE	AC0,AC1		;SAVE REMAINDER
	IMULI	AC0,5		;CALCULATE NUMBER OF WORDS TO SKIP
	IDIVI	AC1,10		;DIVIDE BY 8
	LSH	AC2,1		;MULTIPLY QUOTIENT BY 2
	ADD	AC0,AC2		;ADD 2SPACE/ GROUP OF 8WORDS SKIPED
	MOVEI	AC1,40
	SOJL	AC0,.+3
	PUSHJ	PDP,PRINT
	JRST	.-2
	POPJ	PDP,

PCSAVE:	MOVE	AC0,PC		;LOAD PC
	OR	AC0,IF		;SAVE THE INSTRUCTION FIELD
	ROT	AC0,-3
	OR	AC0,DFF		;SAVE DFF ALSO
	ROT	AC0,-^D12	;SHIFT DFF TO LS BITS
	MOVEM	AC0,REM		;SAVE PC
	POPJ	PDP,

IFN DDF32,<
;READ THE FIRST BLOCK OF THE DISK INTO THE TOP PAGE OF CORE
BOOT:	SETZM	IF
	MOVSI	AC4,-7
LOAD0:	HLR	MA,LOADL(AC4)
	HRR	MB,LOADL(AC4)
	PUSHJ	PDP,STOREY
	AOBJN	AC4,LOAD0
	MOVEI	AC1,200		;STARTING ADDRESS
	JRST	ST+1

LOADL:	XWD	200,6603
	XWD	201,6622
	XWD	202,5201
	XWD	203,5604
	XWD	204,7600
	XWD	7750,7576
	XWD	7751,7576>

DUMP:	MOVE	AC0,FLAGS	;LOAD FLAGS TO PRINT
	MOVEI	AC2,6		;6 DIGITS PER HALF WORD
	PUSHJ	PDP,PWRD+2
	MOVEI	AC2,6
	PUSHJ	PDP,PWRD+2
	MOVEI	AC1,11		;TAB
	PUSHJ	PDP,PRINT
	MOVE	AC0,DFF		;LOAD THE DATA FIELD
	LSH	AC0,3
	IORI	AC0,IF		;ADD INSTRUCTION FIELD
	OR	AC0,PC		;ADD PC
	MOVEI	AC2,6
	PUSHJ	PDP,PWRD+2
	MOVEI	AC1,11		;TAB
	PUSHJ	PDP,PRINT
	MOVE	AC0,AC		;LOAD THE AC AND LINK
	MOVEI	AC2,5
	PUSHJ	PDP,PWRD+2
	PUSHJ	PDP,CARRET
	SETZM	AC4
	PUSHJ	PDP,PCSAVE
DMP3:	PUSHJ	PDP,DASHC
	JRST	DMP1		;NOT INPUT NUMBERS
	PUSHJ	PDP,CARRET
DMP2:	AOS	AC1,AC4		;INCREMENT ADDRESS
	IDIVI	AC1,30		;DIVISIBLE BY 30?
	CAIE	AC1,0
	PUSHJ	PDP,LINEN	;YES SO START A NEW LINE
	SOS	AC4		;CORRECT AC4
	PUSHJ	PDP,GET		;GET FIRST NUMBER
DMP0:	MOVE	AC0,MB
	PUSHJ	PDP,PWORD	;TYPE THIS LOCATION
	CAML	AC4,DASH	;UNFINISHED N-M?
	JRST	DMP3		;NO
	PUSHJ	PDP,GET
	JRST	DMP0
DMP1:	JUMPE	AC4,DALL
	MOVEI	FDB,PRCDAT
	JSP	SRR,FCLOSE	;DUMP BUFFERS
PCREST:	PUSHJ	PDP,REST1
	JRST	REOPR
REST1:	MOVE	AC0,REM
	DPB	AC0,[POINT 3,DFF,23]	;RESTORE DFF
	ROT	AC0,3
	DPB	AC0,[POINT 3,IF,23]	;RESTORE IF
	HLRZ	PC,AC0		;RESTORE PC
	LSH	PC,-6
	POPJ	PDP,

DALL:	SETOM	AC4
	MOVEI	AC0,MEMSIZ-1
	MOVEM	AC0,DASH
	JRST	DMP2

DASHC:	SETZM	DASH#
	PUSHJ	PDP,OCTAL
	CAIN	AC3,^D11		;ANY DIGITS PRESENTED?
	POPJ	PDP,		;NO SO SIMPLE POP RETURN
	ANDI	AC1,77777	;REDUCE TO 5OCTAL DIGITS
	SOS	AC1
	MOVEM	AC1,AC4		;SET LOCATION TO EXAMINE OR DUMP
	ANDI	AC1,70000	;LEAVE ONLY IF
	MOVEM	AC1,IF		;LOAD IF
	CAIE	AC2,55		;"-" AS IN N-M
	JRST	SPOP		;NO
	PUSHJ	PDP,OCTAL
	ANDI	AC1,77777	;BE SURE WE HAVE ONLY 5 OCTAL DIGITS
	CAIL	AC1,MEMSIZ	;TOO LARGE?
	MOVEI	AC1,MEMSIZ-1	;YES SO SET TO MAX CORE
	MOVEM	AC1,DASH	;SAVE N FROM M-N
SPOP:	AOS	(PDP)
	POPJ	PDP,

GET:	AOS	AC4		;INCREMENT CURRENT ADDRESS
	LDB	MA,[POINT 12,AC4,35]	;LOAD 4 LSD'S IN MA
	LDB	AC1,[POINT 3,AC4,23]	;LOAD IF
	LSH	AC1,^D12
	MOVEM	AC1,IF
	PUSHJ	PDP,FETCHY	;GET CORE LOCATION
	POPJ	PDP,		;DONE SO EXIT

EX:	PUSHJ	PDP,PCSAVE
	PUSHJ	PDP,DASHC
	JRST	PCREST		;NOTHING TENDERED SO EXIT
	PUSHJ	PDP,GET		;GET CONTENTS OF LOCATION
	SKIPE	AC1,IF		;IS IF 0?
	IORI	AC1,200000	;CONVERT TO A ASCII NUMBER
	IORI	AC1,400000	;CONVERT TO ASCII
	LSH	AC1,-^D12	;RIGHT JUSTIFY THE CHARACTER
	OUTCHR	AC1		;PRINT A BLANK OR A NUMBER
	MOVE	AC1,AC4		;LOAD THE CURRENT ADDRESS
	PUSHJ	PDP,OCTP	;TYPE 4 LSD'S
	MOVE	AC1,MB		;LOAD MEMORY CONTENTS TO TYPE
	PUSHJ	PDP,REG		;TYPE THEM
	CAML	AC4,DASH	;UNFINISHED N-M?
	JRST	EX+1		;NO
	JRST	EX+3		;YES

P:	PUSHJ	PDP,OCTAL	;GET AN OCTAL NUMBER
	PUSH	PDP,AC1
	MOVE	PC,AC1		;LOAD PC
	ANDI	PC,7777		;MASK OUT DF AND IF
	ANDI	AC1,70000	;MASK TO LEAVE IF
	MOVEM	AC1,IF		;LOAD IF
	MOVEM	AC1,IBR		;LOAD INSTRUCTION BRANCH REGISTER
	POP	PDP,AC1
	ANDI	AC1,700000	;MASK OUT IF AND SR
	LSH	AC1,-3		;POSITION
	MOVEM	AC1,DFF
	JRST	REOPR

;RETURN HERE WHENEVER LEAVING THE PDP8
;DIAGNOS CAUSE OF EXIT AND ANNOUNCE SAME OR SOURCE OF EXIT
GO3:	OUTSTR	[ASCIZ	/

/]
	HLLI	AC0,		;CLEAR STATUS FLAGS FROM SAVED PC
	MOVSI	AC1,ELIST-ENDL	;COUNTER AND INDEX
DIA:	HLRZ	AC2,ELIST(AC1)
	CAIE	AC0,(AC2)	;ERROR SOURCE?
DIA2:	AOBJN	AC1,DIA		;NO
	MOVE	AC2,ELIST(AC1)
	OUTSTR	(AC2)		;PRINT DIAGNOSTIC
	JRST	@DLIST(AC1)	;DISPATCH TO SPECIAL ROUTINE

LIST0:	OUTSTR	[ASCIZ /	SOURCE /]
	LSHC	AC0,-^D15	;PUT ERROR SOURCE ADDRES IN AC1
	MOVEI	AC2,5		;COUNTER
	PUSHJ	PDP,OCTP+2

LIST:	OUTSTR	[ASCIZ /
FLAGS	/]
	MOVE	AC1,FLAGS	;LOAD THE FLAGS IN AC1
	PUSHJ	PDP,WORDP	;TYPE IT
	OUTSTR	[ASCIZ /
PC  /]
	MOVE	AC1,DFF		;LOAD DATA FIELD
	LSH	AC1,^D17	;POSITION DFF FOR TYPING
	TLO	AC1,301000	;CONVERT TO ASCII
	OUTSTR	AC1
	MOVE	AC1,IF		;LOAD INSTRUCTION FIELD IN AC1
	LSH	AC1,-^D12	;POSITION FOR TYPING
	ORI	AC1,60		;CONVERT TO ASCII
	OUTCHR	AC1
	MOVE	AC1,PC
	PUSHJ	PDP,REG
	OUTSTR	[ASCIZ /AC    /]
	TRNE	AC,10000	;IS LINK 1
	OUTCHR	[61]		;YES
	MOVE	AC1,AC
	PUSHJ	PDP,REG
	OUTSTR	[ASCIZ /MA/]
	MOVE	AC1,MA
	PUSHJ	PDP,REG
	OUTSTR	[ASCIZ /MB/]
	MOVE	AC1,MB
	PUSHJ	PDP,REG
	IFN DDF32,<EXTERNAL DMA
	OUTSTR	[ASCIZ /DMA   /]
	HRLZ	AC1,DMA
	MOVEI	AC2,6
	PUSHJ	PDP,OCTP+2
	OUTSTR	[ASCIZ /
/]>
	OUTSTR	[ASCIZ /MQ/]
	MOVE	AC1,MQ
	PUSHJ	PDP,REG
	OUTSTR	[ASCIZ /IR/]
	MOVE	AC1,IR
	PUSHJ	PDP,REG
	OUTSTR	[ASCIZ /SR  /]
	MOVE	AC1,DFSW	;LOAD DATA FIELD SWITCHES
	LSH	AC1,^D17	;POSITION FOR CONVERSION TO ASCII
	TLO	AC1,301000	;AND ADDITION OF A BLANK
	OUTSTR	AC1
	MOVE	AC1,IFSW	;LOAD INSTRUCTION SWITCHES
	LSH	AC1,-^D12	;POSITION
	ORI	AC1,60		;CONVERT TO ASCII
	OUTCHR	AC1
	MOVE	AC1,SR
	PUSHJ	PDP,REG
	SKIPN	TIME		;WAS THE MACHINE RUNNING?
	JRST	OPR
	PUSHJ	PDP,TIM		;TYPE RUNNING TIME

RUNT:	OUTSTR	[ASCIZ /RUNNING TIME /]
	SETZB	AC0,AC3
	CALLI	AC0,27		;GET RUNNING TIME FOR JOB
	SUB	AC0,STARTT	;EXTRACT TIME FOR PREVIOUS JOB STEPS
	MOVEI	AC2,9		;LOAD COUNTER
	IDIVI	AC0,^D10	;FIND LSD
	OR	AC3,AC1		;SAVE LSD
	ROT	AC3,-4		;PRESERVE LSD
	SOJG	AC2,.-3		;MORE DIGITS?
	MOVEI	AC1,9		;LOAD COUNTER
	TLNE	AC3,740000	;IS MSD NONZERO?
	JRST	.+5		;YES
	LSH	AC3,4		;NO SO REMOVE MSD
	SOS	AC1		;AND FORGET IT
	CAIE	AC1,4		;CAN MORE BE FORGOTTEN?
	JRST	.-5		;YES
	MOVEI	AC2,3		;PREPARE TO RECEIVE DECIMEL DIGIT
	ROTC	AC2,4		;SHIFT IN DIGIT AND CONVER TO ASCII
	OUTCHR	AC2		;TYPE IT
	CAIN	AC1,4		;READY FOR A "."
	OUTCHR	[56]
	CAIN	AC1,7		;READY FOR A ","
	OUTCHR	[54]
	SOJG	AC1,.-7		;DONE?
	OUTSTR	[ASCIZ / SECONDS

/]

	JRST	OPR

TIM:	OUTSTR	[ASCIZ /
	SIMULATED RUNTIME   /]
	MOVE	AC0,TIME	;LOAD TIME
	IDIVI	AC0,4		;CONVERT TO MICROSECONDS
	MOVEM	AC1,REM#	;SAVE FRACTIONAL MICROSECONDS
	MOVEI	AC2,9		;LOAD COUNTER
	SETZ	AC3,		;CONVERT TO DECIMEL
	IDIVI	AC0,^D10	;FIND LEAST SIGNIFICANT DIGIT
	OR	AC3,AC1		;SAVE LSD
	ROT	AC3,-4		;PRESERVE LAST DIGIT ENTERED
	SOJG	AC2,.-3		;DONE?
	MOVEI	AC1,9		;LOAD COUNTER
	TLNE	AC3,740000	;LEADING DIGIT 0
	JRST	.+7		;NO
	LSH	AC3,4		;THEN GET RID OF IT
	SOS	AC1		;AND FORGET IT
	TLNE	AC3,740000	;NEXT DIGIT 0?
	JRST	.+3		;NO
	LSH	AC3,4		;DESTROY
	SOS	AC1		;AND FORGET
	MOVEI	AC2,3		;READY TO ROTATE IN ASCII
	ROTC	AC2,4		;PUT MSD IN AC2
	OUTCHR	AC2		;TYPE
	CAIN	AC1,7		;NEED "."
	OUTCHR	[56]		;YES
	CAIN	AC1,4		;PERHAPS A ","
	OUTCHR	[54]		;YES
	SOJG	AC1,.-7		;DONE?
	MOVE	AC1,REM		;RESTORE FRACTIONAL MICROSECONDS
	CAIN	AC1,1
	OUTSTR	[ASCIZ /,25/]
	CAIN	AC1,2
	OUTSTR	[ASCIZ /,5/]
	CAIN	AC1,3
	OUTSTR	[ASCIZ /,75/]
	OUTSTR	[ASCIZ / SECONDS

/]				;YES
	POPJ	PDP,

REG:	OUTCHR	[11]		;TAB
	PUSHJ	PDP,OCTP
	OUTSTR	[ASCIZ /
/]
	POPJ	PDP,

OCTP:	ROT	AC1,^D24	;LEFT JUSTIFY REGISTER
	MOVEI	AC2,4		;COUNTER
	MOVEI	AC0,6		;SET UP AC0 TO ROTATE IN ASCII OCTAL DIGIT
	ROTC	AC0,3		;PUT MSD IN AC0
	OUTCHR	AC0		;TYPE
	SOJG	AC2,.-3		;DONE?
	POPJ	PDP,		;SO RETURN

EXTERNAL	TIME,IOINI,TC,NTIME,NXIOT,EAE,OPR2
;LIST OF ERROR SOURCES AND MESSAGES TO TYPE
DEFINE	EXWD (A,B) <
	XWD	A,B
	EXTERNAL A>
ELIST:	IFE ESTOP,<
	EXTERNAL	INSFET
	XWD	INSFET+2,[ASCIZ	/CYCLING IN MEMORY/]
	XWD	EAE+1,[ASCIZ /EAE INSTRUCTION/]
	XWD	NXIOT+1,[ASCIZ /UNRECOGNIZABLE IOT/]
	EXWD	OPR2,[ASCIZ /ROTATE BOTH RIGHT AND LEFT?/]>
	EXWD	EFLG3,[ASCIZ /EFLG3/]
	EXWD	EFLG4,[ASCIZ /EFLG4/]
	EXWD	EFLG5,[ASCIZ /EFLG5/]
	EXWD	EFLG6,[ASCIZ /EFLG6/]
	EXWD	EFLG7,[ASCIZ /EFLG7/]
	EXWD	EFLG8,[ASCIZ /END OF FILE ON PTR/]
	IFE DRM08,<EXWD	EFLG9,[ASCIZ /DISK/]
	EXWD	DMOUT0,[ASCIZ /DMOUT0/]
	EXWD	EFLG10,[ASCIZ /EFLG10 DSIK/]>
	EXWD	TIME,[ASCIZ /EXIT/]
	EXWD	IOINI,[ASCIZ /IOINI/]
	EXWD	TC,[ASCIZ /PDP8 HALTED/]
ENDL:	XWD	,[ASCIZ /UNRECOGNIZABLE EXIT/]

	IFE ESTOP,<
IOT:	OUTCHR	[11]		;TAB
	MOVE	AC1,MB		;LOAD FOR TYPING
	PUSHJ	PDP,OCTP	;TYPE
	OUTSTR	[ASCIZ /	PC /]
	MOVE	AC1,PC
	OR	AC1,IF		;ADD INSTRUCTION FIELD
	ROT	AC1,-^D15	;LEFT JUSTIFY
	SUBI	AC1,1		;CALCULATE CORRECT PC
	MOVEI	AC2,5		;COUNT
	PUSHJ	PDP,OCTP+2	;TYPE
	OUTSTR	[ASCIZ	/
/]				;CR&LF
	POP	PDP,AC0		;CLEAR OUT PD LIST
	JRST	OPR		;GET ORDERS>

DLIST:	IFE ESTOP,<EXP	OPR,IOT,IOT,OPR>
	EXP	ECF,ECD,ECD,ECF,ECD
	EXP	OPR
	IFE DRM08,<ECF,ECD,OPR>
	EXP	OPR,OPR,OPR,LIST0

ECF:	OUTSTR	[ASCIZ /	CFSTAT /]
	JRST	.+2		;SKIP

ECD:	OUTSTR	[ASCIZ /	CDSTAT /]
	MOVE	AC1,AC3
	PUSHJ	PDP,WORDP
	JRST	OPR

WORDP:	MOVEI	AC2,6		;LOAD COUNTER
	PUSHJ	PDP,OCTP+2	;TYPE LEFT HALF
	OUTCHR	[40]		;SEPERATE HALFWORDS
	MOVEI	AC2,6		;COUNTER FOR THE RIGHT HALF
	JRST	OCTP+2	;TYPE RIGHT HALF


INT:	SETZ	AC0,
	PUSHJ	PDP,OCTAL
	CAIE	AC2,46		;"&"
	JRST	.+3
	MOVE	AC0,TIME
	JRST	INT+1		;NOW GET A NUMEBER TO ADD
	LSH	AC1,2		;MULTIPLY BY 4
	ADD	AC0,AC1
	MOVEM	AC0,DRDATA+1	;SET TIME TO INTERRUPT
	CAMGE	AC0,NTIME
	MOVEM	AC0,NTIME
	JRST	REOPR
INT1:	POP	PDP,AC0
	HRLOI	AC0,377777
	MOVEM	AC0,DRDATA+1	;REPAIR TIME TO INTERRUPT NEXT
	TLO	FLAGS,RUN	;REPAIR RUN FLAG
	OUTSTR	[ASCIZ /

BREAK POINT/]
	SETZM	RUNTIM
	JRST	LIST
DRDATA:	4*^D1000000
	377777777777		;SET TO MAXIMUM TIME
	XWD	RUN,
	INT1

EH:	OUTSTR	[ASCIZ /EH?
/]				;ERROR SO COMPLAIN
REOPR:	MOVEI	AC0,OPR		;GET ANOTHER COMMAND AFTER
	JRST	LEAVE		;WIPING CURRENT LINE



	DEFINE	DISPATCH	(X)<	<SIXBIT	/X/>!<X>>
CLIST:	DISPATCH	BIN
	DISPATCH	C
	DISPATCH	DDT
	DISPATCH	E
	<SIXBIT /DIS/>!<LIST>
	DISPATCH	DP
	<SIXBIT /EXI/>!<EXIT>
	DISPATCH	FIL
	DISPATCH	L
	DISPATCH	RIM
	DISPATCH	S
	DISPATCH	SS
	DISPATCH	ZIP

	LL=.-CLIST

	<SIXBIT /D/>!<DDD>
	<SIXBIT /DUM/>!<DUMP>
	DISPATCH	EX
	DISPATCH	INT
	IFN DDF32,<<SIXBIT /BOO/>!<BOOT>>
	<SIXBIT	/PC/>!<P>
	DISPATCH	ST
	<SIXBIT /SR/>!<SW>
ENDC:	EXP	EH		;ENTRY FOR ERRORS

	END	GO
    