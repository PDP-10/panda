	TITLE	PAL10	V141	26-AUG-68
	SUBTTLE NONREENTRANT VERSION
;	R.C. BOWERING  -  TRADITIONAL PRODUCTS
;	SHARABLE VERSION B.G. DUERR/RCC

;	THIS MODIFICATION MADE TO KEEP DEC-10/20 COMPATIBILITY
;	AS OF 19 JUNE 80 FOR DECUS BY PAUL ROBINSON, WESLEYAN UNIV.
;	EXTERNAL	JOBREL,	JOBFF,	JOBDDT,	JOBSYM
	EXTERNAL	.JBREL, .JBFF, .JBDDT, .JBSYM

	INTERNAL	JOBVER,JOBCOR


	JOBVER=137
	JOBCOR=133
	IFNDEF SHARE,<SHARE=0>		;1 FOR SHARE = REENTRANT VERSION
	IF2,<IFN SHARE,<	SUBTTLE REENTRANT VERSION>>

	IFN SHARE,<HISEG>

	PALVER=141

	LOC JOBVER
	EXP PALVER		;PROGRAM VERSION #
	RELOC

TITLE:	SIXBIT/PAL10/
SUBTTL:	SIXBIT/V141/
	IFE SHARE,<
	DEFINE XX (A1,A2,A3)<
A1:	BLOCK A2
>
	LOC JOBCOR
	EXP 7777
	RELOC
>
	IFN SHARE,<
	ZZ=140
	DEFINE XX (A1,A2,A3)<
	A1=ZZ
	ZZ=ZZ+A2
>
>
;BITS FOR GETCHR STATUS AND IO STATUS CALLS:

	TTYDEV=	000010		;1-DEVICE IS A TTY
	DTADEV=	000100		;1-DEVICE IS A DTA
	PTRDEV=	000200		;1-DEVICE IS A PTR
	LPTDEV=	040000		;1-DEVICE IS A LPT
	CDRDEV=	100000		;1-DEVICE IS A CDR

	IODATA= 200000		;1-IO DATA ERROR
	IODEV=  100000		;1-IO PARITY ERROR
	IOWRLK= 400000		;1-IO WRITE LOCK ERROR
	IOBKTL=	040000		;1-IO BLOCK TOO LARGE
	IOEOF=	020000		;1-END OF FILE ON IO DEVICE

	%00=	0
	%01=	1
	%02=	2
	%03=	3
	%04=	4
	%05=	5
	%06=	6
	%07=	7
	%10=	10
	%11=	11
	%12=	12
	%13=	13
	%14=	14
	%15=	15
	%16=	16
	%17=	17

OPDEF	RESET	[CALLI	 0]
OPDEF	DEVCHR	[CALLI	 4]
OPDEF	CORE	[CALLI	11]
OPDEF	UTPCLR	[CALLI	13]
OPDEF	DATE	[CALLI	14]
OPDEF	MSTIME	[CALLI	23]
OPDEF	RUNTIM	[CALLI	27]
OPDEF	ZBINK	[CLOSE BIN,]

	CRFSYM=1
	CRFMAC=5
	CRFOPC=3
	CRSYMD=2
	CRFMAD=6
	CRFPFX=177
	CRFSOL=102
	CRFEOL=103
	;COMPILER AND EXEC FLAGS

	;FLAGS SET BY EXEC, USED BY COMPILER (LEFT HALF OF AC F OR %16)

	LSTBIT=	001		; 1-SUPRESS LISTING OUTPUT
	BINBIT=	002		; 1-SUPRESS BINARY OUTPUT
	CSWBIT=	004		; 1-SUPRESS CROSS REFERENCE
	MSWBIT=	020		; 1-SUPRESS MACRO LISTING
	NSWBIT=	040		; 1-SUPRESS ERRORS ON TTY
	TTYBIT=	200		; 1-LISTING IS ON TTY
	XLBIT=	001000		; 1-XLIST IS IN PROGRESS
	NOPBIT=	002000		; 1-NOPUNC IN EFFECT
	DSWBIT=	004000		; 1-/D SET
	NSRBIT=	010000		; 1-NEW SOURCE FILE
	XSWBIT=	020000		; 1-SUPPRESS BIT MAP LISTING


	PALXSW=	0
	PAL3SW=	1
	PAL8SW=	2
	PALDSW=	3
	PALSSW=	4


	SBX=	1B<PALXSW>
	SB3=	1B<PAL3SW>
	SB8=	1B<PAL8SW>
	SBD=	1B<PALDSW>
	SBS=	1B<PALSSW>
	;VARIABLE PARAMETERS

	IFNDEF	PAGSIZ,
<
	PAGSIZ=	^D54		;NUMBER OF LINES ON A PAGE
>

	IFNDEF	NUMBUF,
<
	NUMBUF=	2		;NUMBER OF BUFFERS PER DEVICE
>

	CORINC=	2000		;CORE INCREMENT

	IFNDEF	SPL,
<
	SPL=	4		;SYMBOLS PER LINE
>

	IFNDEF	SPLTTY,
<
	SPLTTY=	3
>

	IFNDEF	CPL,
<
	CPL=	^D120		;CHARACTERS PER LINE
>

	IFNDEF	TTLLEN,
<
	TTLLEN=	^D60		;TITLE BUFFER LENGTH
>

	PDPLEN=	40		;PUSH-DOWN STACK LENGTH




	;FLAGS SET AND USED ONLY BY THE EXEC

	ARWBIT=	1		;1-LEFT ARROW SEEN
	EXTBIT=	2		;1-EXPLICIT EXTENSION SEEN
	SWTBIT=	4		;1-ENTER SWITCH MODE
	INFOBIT=10		;1-VALID INFORMATION SEEN
	ENDBIT=	400		;1-END OF ALL INPUT FILES
	SLSHBIT=1000		;1-SWITCH MODE ENTERED WITH A </>
	HDRSAV=	2000		;HDRBIT SAVE FOR LITERAL DUMP
	NULBIT=	10000		;1-NON-NULL COMMAND STRING
	HDRBIT=	40000
	SEQBIT=	100000
	FSCBIT=	200000		;1-NOT FIRST SRC INIT

	TTO=	0		;DEVICE CHANNELS
	BIN=	1
	LST=	2
	SRC=	3
	TTI=	4

	TAB=	11
	FF=	14
	SPACE=	40
	HASH=	47		;HASH MARK FOR GENERATED LINKS

	RUBOUT=	177


	P1F=	400000		;%15 LEFT
	XLFLG=	2
	SRCFLG=	4
	LINFLG=	10
	IFDFLG=	20
	NEGFLG=	40
	LITFLG=	100		;1-LITERALS PERMITTED
	CODFLG=	200		;1-CODE STORED IN THIS FIELD
	CSYBIT=	400		;1 MEANS CREF OUTPUT BLK IN PROCESS

	OPDEF	JUMP1	[JUMPL	%15,	]
	OPDEF	JUMP2	[JUMPGE	%15,	]


PAL:	RESET			;RESET ALL I/O
	MOVNI	%17,PDPLEN	;SET PUSHDOWN POINTER
	HRLS	%17
	HRRI	%17,PDPBUF-1
	IFN SHARE,<
	MOVEI	%00,EZCOR+1	;INITIALIZE LOW SEGMENT
	MOVEM	%00,.JBFF
	MOVEI	%00,3777	;SET FOR 2K
>
	IFE SHARE,<
	MOVEI	%00,7777	;SET FOR 4K
	SKIPN	.JBDDT		;UNLESS DDT IS LOADED
	CAMN	%00,.JBREL
	CAIA
>
	PUSHJ	%17,PANIC1
	MOVE	%00,[XWD BZCOR,BZCOR+1]
	SETZB	%01,BZCOR
	BLT	%00,EZCOR-1
	RUNTIM	%01,
	MOVEM	%01,RUNTIM
	DATE	%00,
	MOVEM	%00,DATE	;SAVE DATE
	MSTIME	%00,
	MOVEM	%00,MSTIME	;  AND TIME
	MOVSI	%16,BINBIT!LSTBIT!CSWBIT
	HRRI	%16,HDRBIT
	MOVSI	%15,P1F		;SET FOR PASS1

	MOVE	%00,[INIT TTI,1]
	MOVSI	%01,(SIXBIT /TTY/)
	MOVEI	%02,TTIBUF
	PUSHJ	%17,INISET	;INITIALIZE TTY FOR INPUT
	INBUF	TTI,1		;GIVE IT AN INPUT BUFFER
	MOVE	%00,[INIT TTO,1]
	MOVSI	%02,TTOBUF
	MOVSI	%03,(AOS 0(%17));SET FOR LOGICAL ASSIGNMENT TEST
;[decus]remove ps from list
;	MOVEI	%10,4
;	MOVE	%01,[SIXBIT /TTY   P3    P8    PD    PS    /](%10)
	MOVEI	%10,3
	MOVE	%01,[SIXBIT /TTY   P3    P8    PD    /](%10)
	PUSHJ	%17,%00		;TEST
	CAIA
	SOJA	%10,.-3		;NO, TRY NEXT ITEM
	MOVEM	%10,MODSW	;OK, SET MODE
	OUTBUF	TTO,4
	MOVEI	%02,"*"		;TYPE AN ASTERISK AT THE USER
	PUSHJ	%17,TTYDMP	;...
	OUTPUT	TTO,		;REALLY OUTPUT IT
	INPUT	TTI,		;GET A COMMAND STRING
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETBIN	;INITIALIZE THE BINARY FILE
	MOVSI	%01,(SIXBIT /DSK/)
	TRNN	%16,ARWBIT	;GO ON TO SOURCE IF _ HAS BEEN SEEN
	PUSHJ	%17,GETLST	;INITIALIZE THE LISTING FILE

	MOVE	%05,.JBFF
	MOVEM	%05,JOBFFI	;SAVE START OF SRC BUFFER
	MOVE	%05,TTIPNT
	MOVEM	%05,TTISAV	;SAVE TTI POINTER
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETSRC	;INITIALIZE THE SOURCE FILE
	MOVEI	%05,204		;COMPUTE MAX BUFFER SIZE
	IMUL	%05,INBCNT
	ADD	%05,JOBFFI
	TRNN	%16,ENDBIT	;MULTI-FILE?
	MOVEM	%05,.JBFF	;  YES, SAVE LARGEST BUFFER SIZE

	MOVE	%05,.JBFF
	ADDI	%05,1
	HRRZM	%05,CORBOT	;CORE BOTTOM
	MOVE	%05,.JBREL
	SKIPE	.JBDDT		;DDT LOADED?
	MOVE	%05,.JBSYM	;  YES, DON'T CLOBBER SYMBOLS
	SUBI	%05,1
	HRRZM	%05,CORTOP	;CORE TOP

	PUSHJ	%17,ACSAVE	;SAVE EXEC AC'S
	MOVE	%12,MODSW	;SET MODE SWITCH
	PUSHJ	%17,PASS1	;PROCESS PASS1

	TLZ	%15,P1F		;SET FOR PASS 2
	TRZ	%16,ENDBIT
	PUSHJ	%17,ACSAVE	;GET EXEC AC'S
	MOVE	%05,TTISAV
	MOVEM	%05,TTIPNT	;RESTORE INPUT COMMANDS
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETSRC	;GET A SOURCE FILE
	PUSHJ	%17,ACSAVE	;SAVE EXEC AC'S
	PUSHJ	%17,PASS2	;PROCESS PASS 2
	PUSHJ	%17,LSTCR	;SKIP ONE LINE
	PUSHJ	%17,ACSAVE	;SWAP AC'S
	TLZ	%16,NSWBIT	;BE SURE TO TYPE FINAL MESSAGE
	PUSHJ	%17,ERRCR	;SKIP A LINE
	MOVEI	%02,"?"		;ASSUME ERROR
	SKIPE	%11,ERRCNT	;TEST ERRORS, LOAD %11
	PUSHJ	%17,ERROUT
	MOVEI	%10,[ASCIZ / ERRORS DETECTED: 5/]
	PUSHJ	%17,LSTMSG
	PUSHJ	%17,ERR2CR
	SETZ	%11,
	MOVE	%11,LINKS	;OUTPUT LINKS GENERATED
	MOVEI	%10,[ASCIZ / LINKS GENERATED: 5/]
	PUSHJ	%17,LSTMSG
	PUSHJ	%17,ERR2CR
	SETZ	%11,
	RUNTIM	%11,		;GET RUNTIM
	SUB	%11,RUNTIM	;DEDUCT STARTING TIME
	IDIVI	%11,^D1000	;CONVERT TO SECONDS
	ADDI	%11,1		;ROUND HIGH
	MOVEI	%10,[ASCIZ / RUN-TIME:  5 SECONDS/]
	PUSHJ	%17,LSTMSG
	PUSHJ	%17,ERR2CR
	HRRZ	%11,.JBREL	;GET TOP OF COR
	ASH	%11,-^D10	;CONVERT TO "K"
	ADDI	%11,1		;BE HONEST ABOUT IT
	MOVEI	%10,[ASCIZ / 5K CORE USED/]
	PUSHJ	%17,LSTMSG	;LIST MESSAGE
	PUSHJ	%17,ERR2CR
	JRST	EXIT		;CLOSE OUT
;INITIALIZE A BINARY FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE, AND
;AN OPTIONAL FILE NAME EXTENSION, THE DEVICE IS INITIALIZED IN
;BINARY MODE ON CHANNEL ONE, WITH EITHER ONE OR TWO BUFFERS.

GETBIN:	MOVSI	%13,(Z BIN,)	;SET SWITCH AC
	PUSHJ	%17,GETCHR	;GET A DEVICE NAME AND FILE NAME
	POPJ	%17,		;NULL FILE EXIT
	MOVE	%00,%01		;GET AN EXTRA COPY OF THE DEVICE
	DEVCHR	%00,		;TEST ITS CHARACTERISTICS
	TLNE	%00,TTYDEV!PTRDEV!LPTDEV!CDRDEV
	JRST	ERRTB		;ILLEGAL FOR BINARY
	MOVE	%00,[INIT BIN,10]	;INIT IMAGE MODE
	MOVSI	%02,BINBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE BINARY DEVICE
	OUTBUF	BIN,NUMBUF
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	TRZN	%16,EXTBIT	;WAS THERE AN EXTENSION
	MOVSI	%14,(SIXBIT /BIN/)	;SAVE EXTENSION IN LOOKUP BLOCK
	HLLZM	%14,XE1
	ENTER	BIN,XE		;ENTER FILE NAME IN DIRECTORY
	JRST	ERRNR		;DIRECTORY FULL
	TLZ	%16,BINBIT	;INDICATE GOOD BINARY FILE
	POPJ	%17,		;EXIT
;INITIALIZE A LISTING FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILENAME EXTENSION, THE DEVICE IS INITIALIZED IN
;ASCII LINE MODE ON CHANNEL 2, IF THE DEVICE IS A TTY, THE
;TTYLST FLAG IS SET TO 1, AND THE INBUF/OUTBUF INDEX IS INCREMENTED.

GETLST:	MOVSI	%13,(Z LST,)	;SET SWITCH AC
	SETZM	XE
	PUSHJ	%17,GETCHR	;GET A DEVICE AND FILE NAME
	TLNN	%16,CSWBIT
	CAIA
	POPJ	%17,
	TLNE	%16,CSWBIT
	JRST	GETLS2		;NORMAL
	MOVSI	%04,(SIXBIT /CRF/)
	SKIPE	XE
	JRST	GETLS1
	MOVE	%03,[SIXBIT /CREF/]
	MOVEM	%03,XE
GETLS1:	TRON	%16,EXTBIT
	MOVE	%14,%04
GETLS2:	MOVE	%00,[INIT LST,1]
	MOVSI	%02,LSTBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE LISTING FILE
	MOVE	%00,%01
	DEVCHR	%00,		;GET DEVICE CHARACTERISTICS
	TLNE	%00,TTYDEV	;IS IT A TTY?
	TLO	%16,TTYBIT	;SET FLAG
	OUTBUF	LST,NUMBUF
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	TRZN	%16,EXTBIT	;WAS THERE AN EXTENSION?
	MOVSI	%14,(SIXBIT /LST/)	;NO
	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	ENTER	LST,XE		;ENTER FILE NAME IN DIR.
	JRST	ERRNR		;DIRECTORY FULL
	TLZ	%16,LSTBIT	;INDICATE A GOOD LISTING FILE
	POPJ	%17,		;EXIT
;INITIALIZE A SOURCE FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILE NAME EXTENSION. THE DEVICE IS INITIALIZED
;IN ASCII LINE MODE ON CHANNEL 3, AND THE FILE NAME ASSOCIATED
;WITH THE SOURCE FILE IS USED AS THE TITLE ON THE LISTING.

GETSRC:	TLO	%16,NSRBIT	;FLAG NEW SOURCE FILE
	MOVSI	%13,(Z SRC,)	;SET SWITCH AC
	SETZM	XE
	PUSHJ	%17,GETCHR	;GET A DEVICE NAME AND FILE NAME
	JRST	ERRSE		;COMMAND ERROR IF A NULL
	TROE	%16,FSCBIT	;FIRST TIME THROUGH?
	JRST	SRC1		;  NO
	MOVEI	%05,NUMBUF		; SET UP BUFFERING SCHEME
	MOVEM	%05,INBCNT	;SAVE THE NUMBER
SRC1:	MOVE	%00,[INIT SRC,1]
	MOVEI	%02,SRCBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE SOURCE DEVICE
	MOVE	%05,JOBFFI
	MOVEM	%05,.JBFF	;SET TO TOP OF INPUT BUFFER
	INBUF	SRC,@INBCNT
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	TRZE	%16,EXTBIT	;WAS AN EXPLICIT EXTENSION SEEN?
	JRST	SRC3A		;YES, LOOK FOR IT
	MOVSI	%14,(SIXBIT /PAL/)
	HLLZM	%14,XE1		;NO, TRY .SRC FIRST
	LOOKUP	SRC,XE
	TDZA	%14,%14		;NOT FOUND, TRY BLANK
	POPJ	%17,		;FOUND
SRC3A:	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	HLLZM	%14,EXTSAV	;SAVE EXTENSION FOR HEADER
	LOOKUP	SRC,XE		;LOOKUP FILE NAME
	JRST	ERRCF		;FILE NOT FOUND
	POPJ	%17,		;EXIT
;EXEC COMMAND STRING DISPATCHING
;THIS ROUTINE PICKS UP CHARACTERS FROM THE EXEC TTY BUFFER AND
;DISPATCHES TO THE PROPER ROUTINE DEPENDING ON THE TYPE OF
;CHARACTER. A TABLE OF BYTES AND BYTE POINTERS ALLOWS EACH CHARAC-
;TER IN THE ASCII SET TO BE TREATED INDIVIDUALLY.


GETCHR:	SETZ	%14,		;CLEAR SYMBOL WORD
	MOVE	%06,[POINT 6,%14]


GETCMN:	PUSHJ	%17,GETTTI	;GET NEXT CHARACTER
	CAIN	%05,"["		;PROJECT-PROGRAMMER PAIR?
	JRST	LFTBRA		;YES
	CAIGE	%10,4		;MODIFY CODE IF .GE. 4
	TRNN	%16,SWTBIT	;MODIFY IF SWITCH IS ON
	ADDI	%10,4		;CHANGE DISPATCH BY ADDING 4
	HRRZ	%02,DSPTCH(%10)	;LOAD RIGHT HALF DISPATCH
	CAIL	%10,10		;SKIP IF CORRECT
	HLRZ	%02,DSPTCH-10(%10);OTHERWISE, GET LEFT HALF DSPTCH
	JRST	@%02		;GO TO CORRECT ROUTINE

GETTTI:	ILDB	%05,TTIPNT	;GET A CHARACTER FROM TTY BUFFER
	MOVE	%10,%05		;ANOTHER COPY OF IT IN AC %10
	IDIVI	%10,8		;TRANSLATE TO 4-BIT CODE
	LDB	%10,TABLE(%11)	;USE PROPER BYTE POINTER
	CAIN	%10,4		;IS IT A NULL?
	JRST	GETTTI		;YES, TRY AGAIN
	POPJ	%17,		;NO, EXIT

;COMMAND DISPATCH TABLE AND BYTE POINTERS
DSPTCH:	XWD	GETCMN,	ERRBS	;IGNORED CHAR, BAD CHAR(SWITCH)
	XWD	SWTCH,	SWTCHA	;<(>, LETTER(SWITCH MODE)
	XWD	COLON,	ERRBS	;<:>, NUMBER(SWITCH MODE)
	XWD	PERIOD,	SWTCHE	;<.>,<)>ESCAPE SWITCH MODE
	XWD	LFTARW,	ERRIC	;<_> OR <=>, BAD CHAR (NORMAL MODE)
	XWD	COMMA,	STORE	;<,>,ALPHABETICH CHAR (NORMAL)
	XWD	CARRTN,	STORE	;<CR>,NUMERIC CHAR (NORMAL)
	XWD	SLASH,	ERRIC	;</>, <)> ILLEGAL ESCAPE


TABLE:	POINT	4, BITE(%10), 3
	POINT	4, BITE(%10), 7
	POINT	4, BITE(%10), 11
	POINT	4, BITE(%10), 15
	POINT	4, BITE(%10), 19
	POINT	4, BITE(%10), 23
	POINT	4, BITE(%10), 27
	POINT	4, BITE(%10), 31
;BYTE TABLE FOR DISPATCHING
;CLASSIFICATION BYTE CODES


;	BYTE	DISP	CLASSIFICATION


;	00	00	ILLEGAL CHARACTER, SWITCH MODE
;	01	01	ALPHABETIC CHARACTER, SWITCH MODE
;	02	02	NUMERIC CHARACTER, SWTICH MODE
;	03	03	SWITCH MODE ESCAPE, SWITCH MODE


;	00	04	ILLEGAL CHARACTER, NORMAL MODE
;	01	05	ALPHABETIC CHARACTER, NORMAL MODE
;	02	06	NUMERIC CHARACTER, NORMAL MODE
;	03	07	SWITCH MODE ESCAPE, NORMAL MODE


;	04	10	IGNORED CHARACTER
;	05	11	ENTER SWITCH MODE WITH A <(>
;	06	12	DEVICE DELIMITER, <:>
;	07	13	FILE EXTENSION DELIMITER, <.>
;	10	14	OUTPUT SPEC. DELIMITER, <_> OR <=>
;	11	15	FILE DELIMITER, <,>
;	12	16	COMMAND TERMINATOR, <CR>
;	13	17	ENTER SWITCH MODE WITH </>


;BYTE TABLE:


BITE:
	BYTE	(4)	 4,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  , 4,12, 4, 4,12,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,12,  ,  ,  ,  ,  

	BYTE	(4)	11,  , 4,  ,  ,  ,  ,  
	BYTE	(4)	 5, 3,  ,  ,11,  , 7,13 
	BYTE	(4)	 2, 2, 2, 2, 2, 2, 2, 2
	BYTE	(4)	 2, 2, 6,  ,  ,10,  ,  

	BYTE	(4)	  , 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1,  ,  ,  ,  ,10

	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,12,  , 4
;LEFT ARROW PROCESSOR
LFTARW:	TRO	%16,ARWBIT	;SET APPROPIATE FLAGS
	TRNN	%16,EXTBIT	;IS THIS A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, ITS A FILE NAME
	TRZE	%16,INFOBIT	;IS THIS A NULL FILE?
CPOPJ1:	AOS	(%17)		;GOOD EXIT
CPOPJ:	POPJ	%17,		;...

;PERIOD PROCESSOR
PERIOD:	TRO	%16,EXTBIT	;SET FLAG FOR EXPLICIT EXTENSION
	MOVEM	%14,XE		;SAVE THE FILE NAME
	JRST	GETCHR		;RE-ENTER THE GETCHR ROUTINE

;COLON PROCESSOR
COLON:	MOVE	%01,%14		;SET UP NEW DEVICE NAME
	JRST	GETCHR		;RETURN FOR MORE COMMAND

;COMMA PROCESSOR
COMMA:	TRZN	%16,INFOBIT	;IS THIS A NULL FILE?
	TRNE	%16,ARWBIT	;ONLY LOOK FOR THEM IF NO _
	SKIPA			;NOT A NULL FILE
	POPJ	%17,		;NULL FILE, EXIT
COMMA1:	TRNN	%16,EXTBIT	;DO WE HAVE A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, IT WAS A FILE NAME
	JRST	CPOPJ1		;GOOD EXIT

;CARRIAGE RETURN PROCESSOR
CARRTN:	TRNN	%16,NULBIT	;IS THIS JUST A RANDOM CR?
	JRST	PAL		;YES, RESTART COMPLETELY
	TRO	%16,ENDBIT	;IS THIS A NORMAL MODE COMMAND?
	TRNN	%16,ARWBIT	;YES, HAS A LEFT ARROW BEEN SEEN?
	JRST	ERRSE		;NO, SYNTAX ERROR
	JRST	COMMA1		;YES, TREAT IT LIKE A COMMA
;THE FOLLOWING TWO ROUTINES HANDLE ALPHANUMERIC CHARACTERS
;FOUND IN THE COMMAND STRING. IN NORMAL MODE, THE CHARACTER
;IS DEPOSITED TO FORM A SIXBIT SYMBOL. IN SWITCH MODE, THE
;PROPER INSTRUCTION IS EXECUTED WITH THE AID OF A DISPATCH
;TABLE. THEN, IF SWITCH MODE WAS ENTERED WITH A SLASH, THE
;EXEC EXITS FROM SWITCH MODE.


STORE:	TRO	%16,INFOBIT+NULBIT;TURN ON BITS FOR CR ROUTINE
	SUBI	%05,40		;CONVERT SIXBIT TO ASCII
	TLNE	%06,770000	;DON'T STORE IF NO ROOM FOR CHAR
	IDPB	%05,%06		;PLOP THE CHARACTER INTO AC %14
	JRST	GETCMN		;RETURN

SWTCHA:	MOVEI	%11,-"A"(%05)
	MOVE	%10,[POINT 4,BYTAB]
	IBP	%10
	SOJGE	%11,.-1
	LDB	%11,%10
	JUMPE	%11,ERRBS
	CAIG	%11,SWTABA-SWTAB;THIS SWITCH LEGAL FOR INPUT?
	TRNN	%16,ARWBIT	;  NO, ERROR IF "_" SEEN
	XCT	SWTAB-1(%11)
	JRST	ERRBS
	TRZE	%16,SLSHBIT	;CALLED BY A SLASH?
	TRZ	%16,SWTBIT	;YES, EXIT FROM SWITCH MODE
	JRST	GETCMN		;NO, RETURN FOR MORE CHARACTERS


;THE FOLLOWING THREE ROUTINES HANDLE THE CONTROL CHARACTERS
;IN THE COMMAND STRING WHICH CAUSE THE EXEC TO ENTER INTO AND
;EXIT FROM SWITCH MODE. THERE ARE TWO TYPES OF SWITCH MODE,
;DEPENDING ON WHETHER IT IS ENTERED WITH A </> OR A <(>.


SLASH:	TRO	%16,SLSHBIT	;TURN ON THE SPECIAL SWITCH MODE
SWTCH:	TROA	%16,SWTBIT	;TURN ON NORMAL SWITCH MODE
SWTCHE:	TRZ	%16,SWTBIT	;TURN OFF THE NORMAL SWITCH MODE
	JRST	GETCMN		;RETURN FOR MORE CHARACTERS
;DISPATCH TABLE FOR SWITCHES


	DEFINE	SETSW	(LETTER, INSTRUCTION) <
	INSTRUCTION
	Y=<"LETTER"-"A">-^D9*<X=<"LETTER"-"A">/^D9>
	SETCOD	\X,Y>

	DEFINE	SETCOD	(X,Y)
	<BYTAB'X=BYTAB'X!<.-SWTAB>B<4*Y+3>>

BYTAB0=	0
BYTAB1=	0
BYTAB2=	0

SWTAB:

	SETSW	P,<PUSHJ %17,SETPSW>

	SETSW	C,<TLZA  %16,CSWBIT>

	SETSW	Z,<TDOE  %13, [UTPCLR  ]>

SWTABA:
	SETSW	A,<TDOE  %13, [MTAPE 16]>
	SETSW	B,<TDOE  %13, [MTAPE 17]>
	SETSW	T,<TDOE  %13, [MTAPE 10]>
	SETSW	W,<TDOE  %13, [MTAPE  1]>

	SETSW	M,<TLOA  %16,MSWBIT>

	SETSW	N,<TLOA  %16,NSWBIT>

	SETSW	D,<TLOA  %16,DSWBIT>

	SETSW	X,<TLOA  %16,XSWBIT>

BYTAB:	+BYTAB0
	+BYTAB1
	+BYTAB2

IF2,	<PURGE	X,	Y,	BYTAB0,	BYTAB1,	BYTAB2	>
SETPSW:				;TEST SPECIAL PAL SWITCH
	PUSHJ	%17,GETTTI	;GET THE NEXT CHARACTER
	SETZ	%10,		;RESET COUNT
	MOVE	%11,[POINT 7,[ASCIZ /X38DS/],]
	ILDB	%02,%11		;GET A CHARACTER
	JUMPE	%02,CPOPJ	;EXIT IF END
	CAME	%02,%05		;HAVE WE A MATCH?
	AOJA	%10,.-3		;  NO, TRY AGAIN
	MOVEM	%10,MODSW	;  YES, SET MODE
	AOS	0(%17)		;OK, SET SKIP-RETURN
	POPJ	%17,		;EXIT


LFTBRA:	SETZM	XE3		;CLEAR NUMBER
LFTBR1:	HRLZS	XE3		;COMMA, MOVE TO LEFT HALF
LFTBR2:	PUSHJ	%17,GETTTI	;GET NEXT CHAR
	CAIN	%05,"]"		;TERMINAL?
	JRST	GETCMN		;YES, EXIT
	CAIN	%05,","		;SEPARATOR?
	JRST	LFTBR1		;YES
	CAIL	%05,"0"		;TEST FOR OCTAL NUMBER
	CAILE	%05,"7"
	JRST	ERRIC		;IMPROPER CHARACTER
	HRRZ	%10,XE3		;OK, GET PREVIOUS VALUE
	IMULI	%10,8
	ADDI	%10,-"0"(%05)	;ACCUMULATE NEW NUMBER
	HRRM	%10,XE3
	JRST	LFTBR2
LSTCR:	TDZA	%02,%02
LSTTAB:	MOVEI	%02,11
LSTOUT:	TLNE	%16,LSTBIT	;LISTING REQUESTED?
	POPJ	%17,		;  NO, EXIT
	TRZE	%16,HDRBIT
	PUSHJ	%17,HEADER
	JUMPN	%02,LSTDMP

	MOVEI	%02,15		;CARRIAGE RETURN
	PUSHJ	%17,LSTDMP
	MOVEI	%02,12		;LINE FEED
	PUSHJ	%17,LSTDMP
	TLNE	%16,TTYBIT	;LISTING TO TTY?
	PUSHJ	%17,LIST1	;YES, DUMP THE LINE
	SOSG	LINCNT
	TRO	%16,HDRBIT
	POPJ	%17,

LSTDMP:	SOSG	LSTCNT		;DECREMENT ITEM COUNT
	PUSHJ	%17,LIST1	;EMPTY ENTIRE BUFFER
	IDPB	%02,LSTPNT	;STORE THE CHARACTER
	POPJ	%17,		;EXIT


LIST1:	OUTPUT	LST,		;EMPTY A BUFFER
LSTTST:	STATO	LST,IODATA!IODEV!IOWRLK	;CHECK FOR ERRORS
	POPJ	%17,		;NO, EXIT
	MOVEI	%10,[ASCIZ /LISTING OUTPUT ERROR/]
	JRST	ERROR		;TYPE MESSAGE
;ROUTINES FOR OUTPUT ON THE ERROR FILE
;THE FOLLOWING CONVENTIONS ARE OBSERVED FOR OUTPUT ON THE ERROR
;FILE:	1. IF THERE IS A LISTING DEVICE, THE ERROR IS ALWAYS
;	   OUTPUT ON THE LISTING DEVICE
;	2. IF THERE IS NO LISTING DEVICE, THE ERROR WILL BE
;	   TYPED ON THE CONSOLE TTY, AND THE ROUTINE EXITS
;	3. AFTER THE CHARACTER HAS BEEN OUTPUT ON THE LISTING
;	   FILE, THE CHARACTER WILL ALSO BE OUTPUT ON THE TTY
;	   UNLESS ONE OF THE FOLLOWING CONDITIONS EXISTS:
;	   A. THE USER HAS REQUESTED THAT ERRORS BE SUPPRESSED
;	   B. THE LISTING FILE IS ITSELF A TTY.
;	4. IF CERTAINS CONDITIONS OCCUR,THE MESSAGE  "SOURCE
;		ERROR(S) IN FILEXXX " WILL BE TYPED OUT BEFORE
;		THE ERROR CHARACTER IS OUTPUT. THESE CONDITIONS 
;		ARE:
;		A. THE COMPILATION IS IN STANDARD MODE (I.E. ,
;		 ONE OF MANY COMPILATIONS FROM THE SAME 
;		COMMAND STRING).
;	B. THE INPUT IS NOT ON THE TTY
;	. THE USER HAS NOT REQUESTED SUPPRESSION 
;	       OF ERRORS WITH AN N SWITCH
;	D. THE MESSAGE HAS NOT BEEN TYPED BEFORE
;ROUTINES ERROUT AND ERRMES ARE CALLED IN A MANNER SIMILAR TO
;LSTOUT AND LSTMES


ERR2CR:	PUSHJ	%17,ERRCR
ERRCR:	TDZA	%02,%02
ERRSP:	MOVEI	%02," "
ERROUT:	HRLM	%02,0(%17)	;SAVE VIRGIN CHARACTER
	PUSHJ	%17,LSTOUT	;TRY THE LISTING FILE
	TLNE	%16,NSWBIT!TTYBIT	;CHAR TO TTY ALSO?
	POPJ	%17,		;NO, JUST EXIT
	HLRZ	%02,0(%17)	;YES, RESTORE CHARACTER
	JRST	TTYOUT		;TYPE AND EXIT
;ROUTINE HEADER DEPOSITS THE LINE FEED IN THE LISTING FILE
;BUFFER AND THEN CHECKS TO SEE IF A FORM FEED IS NECESSARY.
;IF SO, THE ACCUMULATORS ARE SAVED, THE PAGE COUNTER IS
;INCREMENTED, A FORM FEED IS ISSUED, AND A HEADER IS PRINTED.
;THE HEADER CONSISTS OF THE PROGRAM TITLE, FOUND IN THE
;TTLBUF BUFFER,  THE DATE, TIME, AND PAGE NUMBER


HEADER:	PUSHJ	%17,ACSAVE	;YES, SAVE THE ACCUMULATORS
	PUSH	%17,%16		;SAVE CURRENT FLAGS
	TLO	%16,NSWBIT	;DON'T OUTPUT TO TTY
	MOVEI	%02,14		;GET A FORM FEED
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	MOVEI	%10,PAGSIZ+3	;RESET LINE COUNTER REGISTER
	MOVEM	%10,LINCNT	;...
	SKIPA	%10,[POINT 7,TTLBUF,]
	PUSHJ	%17,LSTDMP	;LIST TITLE
	ILDB	%02,%10		;GET NEXT CHAR
	JUMPN	%02,.-2		;TEST FOR END
	PUSHJ	%17,LSTTAB
	MOVE	%00,TITLE
	PUSHJ	%17,LSTSIX
	MOVE	%10,[POINT 7,[ASCIZ / 38DS/],]
	MOVE	%02,AC12	;GET MODE TYPE
	ILDB	%11,%10		;FETCH A CHARACTER
	SOJGE	%02,.-1		;TEST FOR PROPER CHARACTER
	MOVEI	%02,"/"
	CAIE	%11," "		;DON'T LIST IF "PALX"
	PUSHJ	%17,LSTDMP
	MOVE	%02,%11
	PUSHJ	%17,LSTDMP	;GOT IT, LIST IT
	PUSHJ	%17,LSTTAB
	MOVE	%00,SUBTTL	;PRINT VERSION NO.
	PUSHJ	%17,LSTSIX
	PUSHJ	%17,LSTTAB

;THE FOLLOWING SECTION PRINTS THE DATE, WHICH IS FOUND IN
;REGISTER XDATE IN THE FORM
;	((Y-1964)*12 + (M-1))*31 + (D-1)
	MOVE	%10,DATE	;GET THE DATE IN %10
	IDIVI	%10,^D31	;DIVIDE BY 31 DECIMIAL
	ADDI	%11,1
	PUSHJ	%17,DNC		;OUTPUT DAY
	IDIVI	%10,^D12	;DIVIDE BY 12 DECIMAL
	MOVE	%00,MONTH(%11)
	PUSHJ	%17,LSTSIX	;OUTPUT THE MONTH, (M-1) IS IN %12
	MOVEI	%11,^D64(%10)	;GET THE YEAR
	PUSHJ	%17,DNC		;TYPE IT
	PUSHJ	%17,LSTTAB	;OUTPUT TAB
;THE FOLLOWING SECTION OF CODE PRINTS THE TIME, WHICH IS
;PICKED UP FROM THE MONITOR AS THE NUMBER OF MILLISECONDS
;SINCE MIDNIGHT. THE FORMAT OF THE TIME PRINTOUT IS HH:MM
	MOVE	%11,MSTIME	;GET THE CURRENT TIME
	IDIVI	%11,^D60*^D1000	;NUMBER OF MIN. SINCE MIDNITE
	IDIVI	%11,^D60	;NUMBER OF HOURS
	PUSH	%17,%12		;SAVE MINUTES
	PUSHJ	%17,DNC		;OUTPUT THE HOURS
	MOVEI	%02,":"		;OUTPUT A COLON AFTER THE HOURS
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	POP	%17,%11		;PUT MINUTES IN OUTPUT AC
	MOVEI	%02,"0"		;GET AN ASCII ZERO
	CAIG	%11,^D9		;IS IT A ONE-DIGIT NUMBER?
	PUSHJ	%17,LSTDMP	;YES, OUTPUT A ZERO
	PUSHJ	%17,DNC		;OUTPUT THE MINUTES


;THE FINAL SECTION OF CODING PICKS UP THE WORD "PAGE " AND
;STORES IT IN THE PROPER PLACE IN THE TITLE BUFFER.
	PUSHJ	%17,LSTTAB
	MOVE	%00,[SIXBIT /PAGE/]
	PUSHJ	%17,LSTSIX	;PRINT "PAGE"
	MOVEI	%02," "
	PUSHJ	%17,LSTDMP	;SPACE
	MOVE	%11,PAGNUM	;GET PAGE NUMBER
	PUSHJ	%17,DNC		;CONVERT TO DECIMAL AND PRINT
	MOVEI	%10,[ASCIZ //]	;ASSUME NO EXTENSION
	AOSE	%11,PAGEXT	;INCREMENT, PICK UP, AND TEST
	MOVEI	%10,[ASCIZ /-5/]
	PUSHJ	%17,LSTMSG	;LIST IT
	PUSHJ	%17,ERR2CR
	POP	%17,%16		;RESTORE FLAGS
	JRST	ACSAVE		;RESTORE F4 REGS AND EXIT
DNC:	IDIVI	%11,^D10	;RECURSIVE SUBROUTINE
	HRLM	%12,0(%17)	;SAVE REMAINDER ON PUSHDOWN LIST
	SKIPE	%11		;ALL DONE?
	PUSHJ	%17,DNC		;NO, CALL DNC AGAIN
	HLRZ	%02,0(%17)	;RETRIEVE NUMBER FROM PD LIST
	ADDI	%02,"0"		;MAKE IT ASCII
	JRST	ERROUT		;GET NEXT NUMBER OR EXIT

LSTSIX:	MOVSI	%06,(POINT 6,%00,)
LSTSI1:	ILDB	%02,%06
	JUMPE	%02,CPOPJ
	ADDI	%02," "
	PUSHJ	%17,ERROUT
	TLNE	%06,770000
	JRST	LSTSI1
	POPJ	%17,

MONTH:	SIXBIT	/-JAN-/
	SIXBIT	/-FEB-/
	SIXBIT	/-MAR-/
	SIXBIT	/-APR-/
	SIXBIT	/-MAY-/
	SIXBIT	/-JUN-/
	SIXBIT	/-JUL-/
	SIXBIT	/-AUG-/
	SIXBIT	/-SEP-/
	SIXBIT	/-OCT-/
	SIXBIT	/-NOV-/
	SIXBIT	/-DEC-/
;BASIC TELTYPE OUTPUT ROUTINES
;THESE ROUTINES EXIST FOR THE USE OF THE EXEC ONLY, BUT THEIR
;CALLING SEQUENCES ARE THE SAME AS THOSE FOR LSTOUT, LSTMES,
;CONOUT, CONMES, ERROUT, AND ERRMES


TTYOUT:	JUMPN	%02,TTYDMP
TTYCR:	MOVEI	%02,15
	PUSHJ	%17,TTYDMP
	MOVEI	%02,12
TTYDMP:	SOSG	TTOCNT		;IS THE BUFFER EMPTY?
	OUTPUT	TTO,		;YES, GO EMPTY IT
	IDPB	%02,TTOPNT	;STORE THE CHARACTER
	CAIN	%02,12		;WAS IT A LINE FEED?
	OUTPUT	TTO,		;YES, OUTPUT THE LINE
	POPJ	%17,		;EXIT

INISET:	MOVE	%03,[JRST ERRNA];ERROR EXIT FOR INIT
	MOVSI	%04,(POPJ %17,)
	JRST	%00
;ROUTINE TO INPUT CHARACTERS FROM THE SOURCE DEVICE
;ROUTINE CHAR INPUTS CHARACTERS ON CHANNEL 3 UNTIL AN END OF
;FILE CONDITION IS MET. IT THEN CHECKS A FLAG TO SEE IF ANY 
;MORE INPUT FILES NEED TO BE INITIALIZED. IF SO, IT RELEASES
;THE OLD INPUT FILE AND INITIALIZES A NEW ONE, AND CONTINUES 
;TO DO INPUT ON THIS FILE.
;WHEN THE LAST END OF FILE IS REACHED, THE EXEC PLACES AN
;S2 CHARACTER AND A CARRIAGE RETURN IN THE BUFFER


CHARB:	MOVEM	%14,SEQNUM	;SAVE SEQUENCE NUMBER
	AOS	SRCPNT		;INCREMENT POINTER PAST WORD
	MOVNI	%14,5		;GET -5
	ADDM	%14,SRCCNT	;SUBTRACT 5 FROM WORD COUNT
	TRO	%16,SEQBIT
CHAR:	SOSGE	SRCCNT		;DECREMENT ITEM COUNT
	JRST	CHAR4		;GET ANOTHER BUFFER IF NECESSARY
	IBP	SRCPNT		;INCREMENT THE BYTE POINTER
	MOVE	%14,@SRCPNT	;PICK UP AN ENTIRE WORD FROM BUFFER
	TRZE	%14,1		;IS THE SEQUENCE NUMBER BIT ON?
	JRST	CHARB		;YES, SKIP AROUND IT
	LDB	%14,SRCPNT	;NO, PICK UP A GOOD CHARACTER
	CAIE	%14,FF		;FORM FEED?
	POPJ	%17,		;  NO, EXIT
	AOS	PAGNUM		;YES, INCREMENT PAGE
	SETOM	PAGEXT		;INITIALIZE EXTENSION
	TRO	%16,HDRBIT
	POPJ	%17,

CHAR4:	INPUT	SRC,		;CALL MONITIOR FOR A BUFFER
	STATZ	SRC, IODATA+IODEV+IOBKTL
	JRST	ERRID		;INPUT TRANSMISSION ERROR
	STATO	SRC, IOEOF	;WAS AN END OF FILE REACHED?
	JRST	CHAR		;GET NEXT CHAR
	CLOSE	SRC,
	TRNN	%16,ENDBIT	;CRR SEEN BY COMMAND SCANNER?
	JRST	CHAR5		;  NO, MUST BE ANOTHER FILE
	JRST	ERRND		;ERROR IF NO "$"

CHAR5:	PUSHJ	%17,ACSAVE	;GET EXEC AC'S
	PUSHJ	%17,GETSRC	;GET THE NEXT SOURCE FILE
	TRO	%16,HDRBIT	;START NEW FILE
	PUSHJ	%17,ACSAVE	;SAVE EXEC AC'S AND RETURN
	JRST	CHAR
;ROUTINES TO SAVE AND RESTORE THE COMPILER ACCUMULATORS
ACSAVE:				;SWAP AC'S
	EXCH	%00,AC00
	EXCH	%01,AC01
	EXCH	%02,AC02
	EXCH	%03,AC03
	EXCH	%04,AC04
	EXCH	%05,AC05
	EXCH	%06,AC06
	EXCH	%07,AC07
	EXCH	%10,AC10
	EXCH	%11,AC11
	EXCH	%12,AC12
	EXCH	%13,AC13
	EXCH	%14,AC14
	POPJ	%17,
;ROUTINE TO OUTPUT RELOCATABLE BINARY


BINOUT:	TLNE	%16,BINBIT!NOPBIT	;BINARY REQUESTED?
	POPJ	%17,		;  NO, EXIT
	SOSG	BINCNT
	PUSHJ	%17,BINDMP
	IDPB	%02,BINPNT
	POPJ	%17,

BINDMP:	OUTPUT	BIN,
BINTST:	STATO	BIN,IODATA!IODEV!IOWRLK
	POPJ	%17,
	MOVEI	%10,[ASCIZ /BINARY OUTPUT ERROR/]
	JRST	ERROR		;TYPE ERROR MESSAGE
;CALLS TO THE EXEC FOR MORE CORE


;PANIC HAS THE FOLLOWING CALLING SEQUENCE
;	PUSHJ	%17,PANIC	
;	RETURN 1		;NO MORE CORE
;	RETURN 2		;MORE CORE
;THE EXEC CALL THE TIME-SHARING MONITOR FOR MORE
; CORE BY LOADING AC %10 ,WHICH IS USED AS A SCRATCH AC, WITH 
; THE HIGHEST DESIRED RELATIVE ADDRESS,I.E.;%13(.JBREL)+2000,AND
; THEN EXECUTING A CALL %10,CORE. IF UNCUCCESSFUL, THE ROUTINE
; EXITS TO RETURN 1 ABOVE.
;IF SUCCESSFUL, THE MONITOR WILL UPDATE .JBREL IN THE JOB
;DATA AREA. THE EXEC THEN UPDATES THE LEFT HALT OF ROLMEM
;SO THAT THE COMPILER CAN MOVE ITS TABLES HIGHER IN CORE.


PANIC:	HRRZ	%00,.JBREL	;GET PRESENT ROLMEM
	ADDI	%00,CORINC	;ADD 1K OF CORE TO IT
PANIC1:	CORE	%00,		;ASK FOR MORE CORE
	JRST	ERRNC		;NO MORE CORE AVAILABLE
	POPJ	%17,
ERRCF:	MOVEI	%10,[ASCIZ /CANNOT FIND 234/]
	JRST	ERROR

ERRID:	MOVEI	%10,[ASCIZ /INPUT DATA ERROR 234/]
	SKIPA	%01,AC01

ERRBS:	MOVEI	%10,[ASCIZ /1 IS A BAD SWITCH/]
	JRST	ERROR

ERRIC:	MOVEI	%10,[ASCIZ /1 IS AN ILLEGAL CHARACTER/]
	JRST	ERROR

ERRNA:	MOVEI	%10,[ASCIZ /2 IS NOT AVAILABLE/]
	JRST	ERROR

ERRNR:	MOVEI	%10,[ASCIZ /NO ROOM FOR 234/]
	JRST	ERROR

ERRSE:	MOVEI	%10,[ASCIZ /SYNTAX ERROR IN COMMAND STRING/]
	JRST	ERROR

ERRNC:	MOVEI	%10,[ASCIZ /INSUFFICIENT CORE/]
	JRST	ERROR

ERRND:	MOVEI	%10,[ASCIZ /NO "$" SEEN/]
	JRST	ERROR

ERRTF:	MOVEI	%10,[ASCIZ /TOO MANY INPUT FILES/]
	JRST	ERROR

ERRTB:	MOVEI	%10,[ASCIZ /2 ILLEGAL FOR BINARY OUTPUT/]
	JRST	ERROR
ERROR:	MOVE	%16,[XWD LSTBIT!BINBIT,ENDBIT]
	PUSHJ	%17,ERRCR
	MOVEI	%02,"?"
	PUSHJ	%17,ERROUT
	PUSHJ	%17,ERRSP	;TYPE SPACE
	PUSHJ	%17,LSTMSG
	PUSHJ	%17,ERR2CR
	JRST	EXIT

LSTMSG:	TLOA	%10,(POINT 7,,)	;SET BYTE POINTER AND SKIP
LSTMS4:	PUSHJ	%17,ERROUT	;TYPE CHARACTER
LSTMS5:	ILDB	%02,%10		;GET CHARACTER
	JUMPE	%02,CPOPJ	;TEST FOR END
	CAIL	%02,"1"		;TEST FOR SWITCH
	CAILE	%02,"5"
	JRST	LSTMS4		;NO, TYPE THE CHARACTER
	PUSHJ	%17,@[EXP ERR1,ERR2,ERR3,ERR4,DNC]-"1"(%02)
	JRST	LSTMS5		;GET NEXT CHARACTER

ERR1:	MOVE	%02,%05		;GET IMPROPER CHARACTER
	JRST	TTYDMP		;DUMP IT

ERR2:	MOVE	%00,%01		;GET DEVICE NAME
	PUSHJ	%17,LSTSIX	;TYPE IT
	MOVEI	%02,":"
	JRST	TTYDMP		;TYPE ":"

ERR3:	MOVE	%00,XE		;GET FILE NAME
	JRST	LSTSIX		;TYPE IT

ERR4:	HLLZ	%00,XE1		;GET EXTENSION
	JUMPE	%00,CPOPJ	;EXIT IF NULL
	MOVEI	%02,"."
	PUSHJ	%17,TTYDMP	;TYPE "."
	JRST	LSTSIX
EXIT:	CLOSE	SRC,		;CLOSE THE SOURCE DEVICE
	CLOSE	LST,		;CLOSE THE LISTING FILE
	CLOSE	BIN,		;CLOSE THE BINARY FILE
	TLON	%16,LSTBIT	;WAS THERE A LISTING FILE?
	PUSHJ	%17,LSTTST	;YES, TEST FOR FINAL ERROR
	TLON	%16,BINBIT	;IS THERE A BINARY FILE?
	PUSHJ	%17,BINTST	;YES, TEST FOR FINAL ERROR
	TRNN	%16,ENDBIT	;END OF COMMAND STRING?
	JRST	ERRTF		;  NO, MARK ERROR
	CLOSE	TTO,		;BE SURE MESSAGES ARE COMPLETE
	JRST	PAL		;GET A NEW COMMAND STRING
;RH OF %15 FLAG BITS

ERRC=	400000		;ILLEGAL CHARACTER (IC)
ERRD=	200000		;ILLEGAL REDEFINITION (ID)
ERRI=	100000		;ILLEGAL INDIRECT (II)
ERRL=	040000		;LITERAL ERROR (PE)
ERRN=	020000		;NUMERIC ERROR
ERRO=	010000		;ILLEGAL OP-CODE
ERRP=	004000		;PHASE ERROR (ID)
ERRQ=	002000		;QUESTIONABLE FORMAT ERROR
ERRT=	001000		;ILLEGAL TEXT CHARACTER
ERRU=	000400		;UNDEFINED SYMBOL (US)
ERRZ=	000200		;PAGE ZERO EXCEEDED (ZE)
ERRM=	000100		;MACRO ERROR
ERRG=	000040		; LINK GENERATED

;LH OF VALUE CELL FOR SYMBOL

LBLFLG=	001000
MDLFLG=	002000		;MULTIPLY DEFINED LABEL FLAG
DEFFLG=	004000		;DEFINED FLAG

;RH OF VALUE CELL OF SYMBOL TABLE ENTRY

CHAN7=	010000
CHAN8=	020000
CHAN78=	030000
PASS1:
	MOVSI	%02,BSYMT-EBSYMT	;SET FOR FULL TABLE
	PUSHJ	%17,INIPAS
	PUSHJ	%17,SYTI
	MOVEI	%02,TERMCV+TJLP	;TEST FOR LITERALS
	LDB	%02,CNVTBL(%12)
	CAIN	%02,TJLP	;WAS "(" MAPPED?
	TLO	%15,LITFLG	;  NO, ALLOW LITERALS
	PUSHJ	%17,LINE
	POPJ	%17,


PASS2:
	PUSHJ	%17,LEADER
	PUSHJ	%17,INIPAS
	MOVEI	%10,CHAN7+200
	PUSHJ	%17,BINWRD
	PUSHJ	%17,LINE
	PUSHJ	%17,DCLIT	;DUMP CURRENT LITERALS
	PUSHJ	%17,DZLIT	;DUMP PAGE ZERO LITERALS
	TLZ	%16,NOPBIT	;REENABLE BINARY FOR CHECKSUM AND TRAILER
	MOVE	%10,CHKSUM
	TRZ	%10,CHAN78	;ONLY 12 BITS
	PUSHJ	%17,BINWRD
	PUSHJ	%17,LEADER
	ZBINK			;KEEP THE OPERATOR HAPPY
	PUSHJ	%17,BITDMP	;LIST BIT MAP
	TLNN	%16,LSTBIT!MSWBIT	;LISTING?
	PUSHJ	%17,SYMTB	;  YES, OUTPUT THE SYMBOL TABLE
	POPJ	%17,


INIPAS:
	PUSHJ	%17,OCTAL	;SET OCTAL RADIX
	MOVEI	%05,200
	SETZM	CHKSUM
	SETZM	SEQNUM
	SETZM	LVLCNT
	MOVEI	%00,1
	MOVEM	%00,PAGNUM	;INITIALIZE PAGE NUMBER
	SETOM	PAGEXT		;  AND EXTENSION
	MOVE	%00,CORBOT
	MOVEM	%00,MACTOP
	SETZM	MACPNT
	SETZM	ARGPNT
	TLZ	%15,SRCFLG
	POPJ	%17,
LINE:				;PROCESS ONE LINE
	PUSHJ	%17,GETLIN	;GET A SOURCE LINE

LINE1:	SETZM	EQUIV
	JUMPE	%14,LINE4	;BRANCH IF END OF LINE
	SKIPE	DBLPNT		;ANY DUBL OR FLTG IN PROGRESS?
	JRST	DBLENT		;  YES, GO PROCESS
	PUSHJ	%17,STMNT	;PROCESS ONE STATEMENT

LINE2:	LDB	%02,C1PNTR	;CONVERT USING COLUMN 1
	XCT	LINEJT(%02)	;EXECUTE TABLE
LINE3:	ILDB	%14,%13		;NOT TERMINATOR
	JRST	LINE2		;  GO LOOK FOR IT


LINE4:	PUSHJ	%17,ENDL	;NORMAL TERMINATION
LINE5:	JUMPE	%14,LINE	;RECYCLE IF CR
	SKIPN	LVLCNT		;NO, ARE WE IN A CONDITIONAL?
	JRST	LINE		;  NO
	ILDB	%14,%13		;YES, GET THE NEXT CHARACTER
	CAIN	%14,">"		;TEST FOR RIGHT ANGLE BRACKET
	SOS	LVLCNT		;  YES, DECREMENT IT
	JRST	LINE5		;TEST FOR END OR MORE

LINE6:	PUSHJ	%17,ENDL	;SEMI-COLON, LIST LINE
	ILDB	%14,%13		;MOVE PAST SEMI
	TLO	%15,SRCFLG	;DON'T LIST CONTINUATION
	JRST 	LINE1		;CONTINUE WITH THIS LINE

LINE7:	SOSL	LVLCNT		;DECREMENT LEVEL COUNT AND TEST
	JRST	LINE3		;OK, TEST FOR ANOTHER
	SETZM	LVLCNT		;UNDERFLOW, RESET TO ZERO
	TRO	%15,ERRQ	;FLAG ERROR
	JRST	LINE3		;TRY AGAIN


LINEJT:				;LINE JUMP TABLE
	PHASE	0
	TRO	%15,ERRQ	; INVALID TERMINATOR
LNSP:	JFCL			; TAB OR SPACE
LNCR:	JRST	LINE4		; CR OR /
LNSC:	JRST	LINE6		; ;
LNDO:	JRST	ENDL		; $
LNLA:	TRO	%15,ERRQ	; <
LNRA:	JRST	LINE7		; >
	DEPHASE
GETLIN:				;GET THE NEXT SOURCE LINE
	MOVEI	%06,CPL		;TEST FOR OVERFLOW
	SKIPA	%13,LINPNT	;SET POINTER AND SKIP
GETLI1:	TRO	%15,ERRC	;ILLEGAL CHARACTER
GETLI2:	SKIPE	MACPNT		;IN A MACRO?
	JRST	GETMAC		;  YES
	PUSHJ	%17,CHAR	;GET AN INPUT CHARACTER
GETLI4:	LDB	%02,C7PNTR	;SET INDEX
	XCT	GLTBL(%02)
GETLI5:	SOJL	%06,GETLI2	;DON'T STORE IF TOO MANY
GETLI6:	IDPB	%14,%13		;STORE IN BUFFER
	JUMPN	%14,GETLI2	;RECYCLE IF NOT END
	LDB	%14,[POINT 7,LINBUF,6]
	JUMPE	%14,GETLI7
	MOVE	%13,[XWD LINBUF,TTLBUF]
	TLZE	%16,NSRBIT	;NEW SOURCE SEEN?
	BLT	%13,TTLEND-1	;  YES, SET IT UP
GETLI7:	PUSHJ	%17,CREFQ	;CREF OUTPUT WANTED?
	JRST	GETLI8		;NO
	TLON	%15,CSYBIT	;YES. STARTED ALREADY?
	PUSHJ	%17,CRFBGN	;NO. START IT NOW
GETLI8:	MOVE	%13,LINPNT	;SET FOR READ
	ILDB	%14,%13		;RETURN FIRST CHAR
	POPJ	%17,		;EXIT

CRFBGN:	MOVEI	%02,CRFPFX	;START CREF BLOCK
	PUSHJ	%17,LSTOUT	;OUTPUT ON LISTING
	MOVEI	%02,CRFSOL	;START OF LINE CHARACTER
	JRST	LSTOUT		;OUTPUT AND POPJ TO GETLIN

CREFQ:	JUMP1	CPOPJ		;NO OUTPUT ON PASS 1
	TLNN	%16,CSWBIT!LSTBIT	;CREF BEEN ASKED FOR?
	AOS	0(%17)		;YES. SKIP RETURN
	POPJ	%17,0

GLTBL:				;GET LINE TABLE
	PHASE	0
	JRST	GETLI1		;ILLEGAL
QJNU:	JRST	GETLI2		;NULL
QJCR:	TDZA	%14,%14		;CARRIAGE RETURN
QJTB:	JFCL
QJSP:	JFCL
QJPC:	JFCL
	DEPHASE
GETMAC:				;GET A MACRO CHARACTER
	SKIPE	ARGPNT		;PROCESSING AN ARGUMENT?
	JRST	GETMA3		;  YES
	ILDB	%14,MACPNT	;  NO, GET THE NEXT CHARACTER
	JUMPE	%14,GETLI6	;BRANCH IF END OF LINE
	CAIE	%14,RUBOUT	;RUBOUT FLAG?
	JRST	GETLI5		;  NO, RETURN
	ILDB	%14,MACPNT	;  YES, GET THE NEXT ITEM
	JUMPE	%14,GETMA4	;IF NULL, WE ARE DONE
	MOVE	%02,ARGTMP	;NO, IT IS AN ARGUMENT
	MOVEM	%02,ARGPNT	;SET ARG PNTR
GETMA1:	SOJE	%14,GETMA3	;TEST FOR PROPER ARG
GETMA2:	ILDB	%02,ARGPNT	;NOT PROPER ARG, MOVE TO IT
	CAIE	%02,RUBOUT	;ARGUMENT END?
	JRST	GETMA2		;  NO
	JRST	GETMA1		;  YES, TEST FOR END

GETMA3:	ILDB	%14,ARGPNT	;ARGUMENT, GET NEXT CHARACTER
	CAIE	%14,RUBOUT	;END FLAG?
	JRST	GETLI4		;  NO, RETURN
	SETZM	ARGPNT		;  YES, ZERO POINTER
	JRST	GETMAC		;RETURN TO MAIN STREAM

GETMA4:	SETZM	MACPNT		;END OF MACRO, CLEAR POINTER
	SETZM	ARGPNT		;  AND ARG POINTER
	MOVE	%02,ARGTMP
	HRRZM	%02,MACTOP	;RECOVER SPACE
	JRST	GETLI6		;RETURN
ENDL:				;END OF LINE PROCESSOR
	JUMP1	ENDL11		;BRANCH IF PASS 1

	SKIPGE	VALUE		;IF NO CODE
	TLNE	%16,XSWBIT	;  OR BIT MAP SUPPRESSED,
	JRST	ENDL2		;  BYPASS FOLLOWING
	MOVE	%01,%05
	IDIVI	%01,^D36
	MOVNS	%02
	MOVSI	%03,(1B0)
	ROT	%03,0(%02)
	ORM	%03,BITBUF(%01)
	TLO	%15,CODFLG
	LDB	%02,[POINT 5,%05,28]
	AOS	PAGBUF(%02)	;FLAG PAGE AS USED

ENDL2:	MOVEI	%01,CPOPJ	;DISPATCH ADR IF NO LISTING
	TLNE	%16,XLBIT	;DONT LIST IF XLIST TRUE
	JRST	ENDL2A		;XLIST
	TLZN	%15,CSYBIT	;CREF BLOCK STARTED?
	JRST	ENDL2B		;NO. DONT END IT THEN.
	MOVEI	%02,CRFPFX	;PREFIX CHARACTER
	PUSHJ	%17,LSTDMP	;OUTPUT THE CHAR TO LISTING
	MOVEI	%02,CRFEOL	;END OF LINE CODE
	PUSHJ	%17,LSTDMP	;OUTPUT IT TOO
ENDL2B:	MOVEI	%01,LSTOUT	;DISPATCH ADR FOR LISTING
ENDL2A:	SKIPL	VALUE		;ANY CODE TO BE STORED?
	JRST	ENDL4		;  NO
	TRNE	%05,7600	;  YES, ARE WE ON PAGE ZERO?
	JRST	ENDL3		;  NO
	SKIPE	ZLTBUF(%05)	;  YES, TEST FOR IN USE
	TROA	%15,ERRZ	;  YES, FLAG ERROR
	HLRZM	%17,ZLTBUF(%05)	;  NO, FLAG AS USED
	JRST	ENDL4
ENDL3:	LDB	%02,[POINT 5,%05,28]	;GET PAGE
	SKIPE	CLHBUF(%02)	;TEST FOR LITERAL OVERLAP
	CAMGE	%05,CLHBUF(%02)
	CAIA
	TRO	%15,ERRL	;OVERLAP, FLAG ERROR
ENDL4:	TRNN	%15,-1		;ANY ERRORS?
	JRST	ENDL6		;  NO
	MOVEI	%00,7402	;SET "HLT" INSTRUCTION
	TRNE	%15,ERRU!ERRI	;UNDEFINED ERROR?
	HRRM	%00,VALUE	;  YES, SUBSTITUTE FOR INSTRUCTION, IF ANY
	MOVE	%00,XE		;GET FILE NAME
	TLNN	%16,NSWBIT
	CAMN	%00,XESAVE
	JRST	ENDL4C
	JUMPE	%00,ENDL4C
	MOVEM	%00,XESAVE
	MOVSI	%01,(POINT 6,%00,)
ENDL4A:	ILDB	%02,%01
	JUMPE	%02,ENDL4B
	ADDI	%02,40
	PUSHJ	%17,TTYOUT
	TLNE	%01,770000
	JRST	ENDL4A
ENDL4B:	MOVEI	%02,":"
	PUSHJ	%17,TTYOUT
	PUSHJ	%17,TTYCR
ENDL4C:	HRLZ	%00,%15		;PUT FLAGS IN AC0 LEFT
	TLNE	%00,-1-ERRG
	AOS	ERRCNT
	MOVE	%01,MODSW
	TRNE	%15,ERRG
	PUSHJ	%17, @HASHTB(%01)		; PROCESS THE "G" ERROR
	TLNE	%00,-1-ERRQ-ERRC;ANY ERRORS OTHER THAN Q OR C?
	TLZ	%00,ERRQ	;  YES, FLUSH Q
	MOVE	%01,[POINT 7,[ASCII /CDILNOPQTUZMG/],]
ENDL5:	ILDB	%02,%01		;FETCH CHARACTER
	TLNE	%00,400000	;THIS CHARACTER
	PUSHJ	%17,ERROUT	;  YES
	LSH	%00,1
	JUMPN	%00,ENDL5	;TEST FOR END
	MOVEI	%01,ERROUT	;END, SET TO ERROR-LIST
ENDL6:	MOVE	%02,LINPNT	;TEST FOR NO MORE LISTING
	ILDB	%02,%02
	TDO	%02,VALUE
	TDO	%02,EQUIV
	TDO	%02,SEQNUM
	JUMPE	%02,ENDL10	;BRANCH IF NOTHING TO LIST
	MOVEI	%02,TAB
	PUSHJ	%17,0(%01)	;LIST A TAB
	REPEAT	2,		<
	MOVEI	%02,SPACE
	PUSHJ	%17,0(%01)	>
	MOVE	%10,%05		;ASSUME BINARY
	SKIPE	VALUE		;TRUE?
	PUSHJ	%17,LSTOCT	;  YES
	MOVEI	%02,TAB
	PUSHJ	%17,0(%01)
	SKIPL	%10,VALUE
	SKIPE	%10,EQUIV	;ANYTHING TO BE LISTED?
	PUSHJ	%17,LSTOCT	;  YES
	TRNN	%15,ERRG
	JRST	ENDL6A
	MOVEI	%02,HASH		; OUTPUT A HASH MARK
	PUSHJ	%17, 0(%01)
ENDL6A:	TLZE	%15,SRCFLG	;SHOULD WE BYPASS SOURCE?
	JRST	ENDL10		;  YES
	TRNN	%16,SEQBIT	;ANY SEQUENCE NUMBERS ENCOUNTERED?
	JRST	ENDL8		;  NO
	MOVEI	%02,TAB
	PUSHJ	%17,0(%01)	;OUTPUT A TAB
	MOVE	%00,[POINT 7,SEQNUM,]
ENDL7:	ILDB	%02,%00		;GET A CHARACTER
	JUMPE	%02,ENDL8	;BYPASS IF NULL
	PUSHJ	%17,0(%01)	;OUTPUT THE NUMBER
	TLNE	%00,760000	;END OF WORD?
	JRST	ENDL7		;  NO, TRY FOR MORE
ENDL8:	MOVEI	%02,TAB
	PUSHJ	%17,0(%01)
	SKIPA	%03,LINPNT	;GET SET TO PRINT LINE
ENDL9:	PUSHJ	%17,0(%01)	;LIST A CHARACTER
	ILDB	%02,%03		;GET ANOTHER CHARACTER
	JUMPN	%02,ENDL9	;TEST FOR END
ENDL10:	SETZB	%02,SEQNUM
	PUSHJ	%17,0(%01)	;END,LIST CR/LF
	TLZE	%15,XLFLG	;XLIST ENCOUNTERED?
	TLC	%16,XLBIT	;  YES, TOGGLE BIT
ENDL11:	SKIPL	%10,VALUE	;ANY OCTAL?
	JRST	ENDL12		;  NO
	TRZ	%10,CHAN78	;  YES, CLEAR ANY HIGH BITS
	PUSHJ	%17,BINWRD	;  AND DUMP THE BINARY
	ADDI	%05,1
	ANDI	%05,007777
ENDL12:	SETZM	VALUE
	TRZ	%15,-1
	TLZ	%15,SRCFLG!LINFLG
	POPJ	%17,

; "G" ERROR SWITCH PROCESSOR
HASHTB:	GERR02	;PAL10
	GERR01	;PALX
	GERR01	;PAL3
	GERR01	;PAL8
	GERR03	;PALD
	GERR01	;PALS

GERR03:	TLZA	%00, ERRG		; JUST DO IT NO ERROR NO FLAG
GERR01:	AOS	ERRCNT		;COUNT AS AN ERROR
	AOS	LINKS		; COUNT AS A LINK ALSO
	TRZ	%15,ERRG
	POPJ	%17,

GERR02:	AOS	LINKS		; COUNT AS A LINK ONLY
	TLZ	%00,ERRG		; DO NOT OUTPUT AS ERROR
	POPJ	%17,

STMNT0:	ILDB	%14,%13
STMNT:				;STATEMENT PROCESSOR
	LDB	%02,C2PNTR	;CONVERT USING COLUMN 2
STMNT1:	ADDI	%02,STMNCV	;SET CONVERSION TABLE ADDRESS
	LDB	%02,CNVTBL(%12)	;SET FOR PROPER MODE
	XCT	STMNJT(%02)	;EXECUTE TABLE
	 POPJ	%17,		;NO CODE
	HRROM	%10,VALUE	;STORE AND MARK CODE
	POPJ	%17,		;EXIT


STMNCV:				;STATEMENT CONVERSION TABLE
	PHASE	0
	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
STSP:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
STAL:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
STAS:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
STLA:	BYTE	(4)	  . ,  0 ,  0 ,  0 ,  0 ,  0 
STSC:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
	DEPHASE


STMNJT:				;STATEMENT JUMP TABLE
	PHASE	0
	PUSHJ	%17,EXPR	; NOTHING SPECIAL
STSP:	JRST	STMNT0		; TAB OR SPACE
STAL:	JRST	STMNAL		; ALPHABETIC
STAS:	JRST	STMNAS		; *
STLA:	JRST	XTEXT		; <
STSC:	TRO	%15,ERRQ	; ;
	DEPHASE
STMNAL:				;ALPHABETIC
	MOVE	%10,%13		;SAVE CHARACTER POINTER
	PUSHJ	%17,GETSYM	;ACCUMULATE A SYMBOL
	LDB	%02,C3PNTR	;CONVERT USING COLUMN 3
	XCT	STALJT(%02)	;EXECUTE TABLE
	 SETZ	%01,
	LDB	%02,[POINT 9,%01,17]	;GET OP TYPE POINTERS
	XCT	STOPJT(%02)	;TEST FOR PSEUDO-OPS
	MOVE	%13,%10		;NOT PSEUDO-OP
	LDB	%14,%13		;REPLACE CHARACTER
	JRST	STMNT1		;FALL THROUGH TO EXPRESSION


STALJT:
	PHASE	0
	PUSHJ	%17,SRCH	;GET SYMBOLIC QUANTITY
SACM:	JRST	LABEL		; ,
SAEQ:	JRST	ASGMT		; =
	DEPHASE


STOPJT:
	PHASE	0
	SETZ	%02,
PSOP:	JRST	PSCREF
MROP:	SETZ	%02,
MCOP:	SETZ	%02,
MAOP:	JRST	MACREF
	DEPHASE

MACREF:	PUSHJ	%17,CRFOUT	;REFERENCE THE MACRO NAME
	JRST	CALLM		;AND GO DO IT.
PSCREF:	PUSHJ	%17,CRFOUT	;REFERENCE THE PSEUDO
	JRST	0(%01)		;AND DISMISS TO ROUTINE
LABEL:				;LABEL PROCESSOR
	PUSHJ	%17,SRCH	;SEARCH SYMBOL TABLE
	 JRST	LABEL1		;NOT FOUND
	TLNN	%01,MDLFLG	;FOUND, MULTIPLY DEFINED?
	CAIE	%05,0(%01)	;  NO, OUT OF PHASE?
	TROA	%15,ERRP	;  YES, FLAG PHASE ERROR
	JRST	LABEL2		;TO STATEMENT PROCESSOR AFTER CREF
	TLZ	%01,DEFFLG	;CLEAR POSSIBLE UNDEFINED FLAG
	TLOA	%01,MDLFLG	;FLAG AND SKIP

LABEL1:	MOVE	%01,%05		;PUT CURRENT LOCATION IN %01
	TLO	%01,LBLFLG	;SET LABEL FLAG
	PUSHJ	%17,INSRT	;INSERT IN THE SYMBOL TABLE
LABEL2:	PUSHJ	%17,CRFOUT
	MOVEI	%02,CRSYMD	;FLAG AS A DEFINITION
	PUSHJ	%17,LISTCQ	;OUTPUT TO CREF
	JRST	STMNT0



ASGMT:				;ASSIGNMENT PROCESSOR
	PUSH	%17,%00		;STACK SYMBOL
	PUSHJ	%17,EXPR0	;EVALUATE EXPRESSION
	 TRO	%15,ERRU	;ERROR IF NULL
	ANDI	%10,7777	;JUST 12 BITS OF VALUE, CLR LH
	HRROM	%10,EQUIV
	POP	%17,%00		;FETCH SYMBOL
	TRNE	%15, ERRU	; TEST FOR SYMBOL UNDEFINED AT THIS POINT
	TLO	%10, DEFFLG	; SET DEFFLG IF EXPRESSION NOT DEFINED
	PUSHJ	%17,SRCH	;SEARCH TABLE
	 JRST	ASGMT1		;  NOT THERE, INSERT IT
	LDB	%02,[POINT 9,%01,17]
	XCT	ASGTBL(%02)	;DISPATCH ON SYMBOL TYPE
	JRST	ASGMT3
ASGMT1:	HRRZ	%01,%10		;GET VALUE
	TLNE	%10, DEFFLG	; MOVE DEFFLG TO SYMBOL TO BE INSERTED
	TLO	%01, DEFFLG
	PUSHJ	%17,CRFOUT
	MOVEI	%02,CRSYMD	;FLAG AS A DEFINITION
	PUSHJ	%17,LISTCQ	;OUTPUT TO CREF
	JRST	INSRT

ASGMT2:	JUMP1	ASGMT1		;JUST INSERT IF PASS 1
	CAIE	%10,0(%01)	;  NO, TEST FOR CHANGE
ASGMT3:	TRO	%15,ERRD	;ERROR, FLAG IT
	POPJ	%17,		;EXIT
ASGTBL:
	PHASE	0
	TLNE	%01,LBLFLG
PSOP:	JRST	ASGMT3
MROP:	JRST	ASGMT2
MCOP:	JRST	ASGMT2
MAOP:	JRST	ASGMT3
	DEPHASE

STMNAS:				; *
	PUSHJ	%17,EXPR0	;EVALUATE THE EXPRESSION
	 MOVEI	%10,770000(%05)	;NULL, FORCE ERROR
	PUSH	%17,%10
	XOR	%10,%05		;COMPARE CURRENT WITH NEW
	TRNE	%10,7600	;SKIP IF NOT LEAVING PAGE
	PUSHJ	%17,DCLIT	;DUMP CURRENT PAGE LITERALS
	POP	%17,%10
	JRST	OUTLOC		;DON'T TEST FOR SEQUENCE BREAK
EXPR0:	ILDB	%14,%13		;FETCH NEXT CHARACTER
EXPR:				;EXPRESSION PROCESSOR
	TRZ	%15, ERRU	; CLEAR ERROR FLAG BEFORE EVALUATING THE EXPRESSION
	PUSHJ	%17,TERM	;SEEK THE FIRST TERM
	 POPJ	%17,		;  NOT FOUND, EXIT NORMAL
	  JRST	EXPR1		;  NUMERIC
	PUSHJ	%17,SRCH	;SYMBOLIC, SEARCH THE TABLE
	TROA	%15,ERRU	;  NOT FOUND, ERROR
	PUSHJ	%17,CRFOUT	;FOUND. OUTPUT TO CREF.
	TLNE	%01,DEFFLG	;UNDEFINED?
	TRO	%15,ERRU	;  YES, FLAG ERROR
	HRRZ	%10,%01		;PUT VALUE IN %10
EXPR1:	LDB	%02,[POINT 9,%01,17]	;GET TYPE
	XCT	EXO1JT(%02)	;EXECUTE TABLE
	AOS	0(%17)		;RETURN +1
	POPJ	%17,



EXO1JT:
	PHASE	0
	PUSHJ	%17,EXPR3	; USER DEFINED SYMBOL
PSOP:	PUSHJ	%17,EXPRPS	; PSEUDO-OP
MROP:	PUSHJ	%17,EXPMR	; MEMORY-REFERENCE OP
MCOP:	PUSHJ	%17,EXPR3	; MICRO-INSTRUCTION
MAOP:	PUSHJ	%17,EXPRPS
	DEPHASE
EXPR2:	ILDB	%14,%13		;FETCH NEXT CHARACTER
EXPR3:	LDB	%02,C4PNTR	;CONVERT USING COLUMN 4
	ADDI	%02,EXPRCV	;POINT TO EXPRCV ENTRY
	LDB	%02,CNVTBL(%12)	;GET PROPER CONVERSION BYTE
	XCT	EXPRJT(%02)	;EXECUTE TABLE
	ILDB	%14,%13		;BYPASS OPERATOR
	PUSH	%17,%06		;STACK INSTRUCTION
	PUSH	%17,%10		;SAVE CURRENT VALUE
	PUSHJ	%17,TERM	;GET THE NEXT TERM
	 TRO	%15,ERRQ	;NULL, ERROR
	  JRST	EXPR4		;NUMERIC
	PUSHJ	%17,SRCH	;SYMBOLIC, SRCH FOR IT
	 TROA	%15,ERRU	;NOT IN TABLE
	PUSHJ	%17,CRFOUT	;OUTPUT TO CREF.
	TLNE	%01,DEFFLG	;UNDEFINED?
	TRO	%15,ERRU	;  YES, FLAG ERROR
	HRRZ	%10,%01		;TRANSFER VALUE TO %10
EXPR4:	LDB	%02,[POINT 9,%01,17]	;GET OP-TYPE
	XCT	EXO2JT(%02)	;EXECUTE TABLE
	POP	%17,%00	;FETCH PREVIOUS VALUE
	POP	%17,%02		;  AND OPERATION
	XCT	%02		;EXECUTE OPERATION
	JRST	EXPR3		;TEST FOR MORE OPS


EXPRCV:				;EXPRESSION CONVERSION TABLE
	PHASE	0
	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
EXSP:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
EXPL:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
EXMI:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
EXOR:	BYTE	(4)	EXC1,  0 ,  . ,  . ,  . ,  . 
EXAN:	BYTE	(4)	  . ,  0 ,  . ,  . ,  . ,  . 
EXMU:	BYTE	(4)	  . ,  0 ,  0 ,  0 ,  0 ,  . 
EXTE:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
	DEPHASE


EXPRJT:				;EXPRESSION JUMP TABLE
	PHASE	0
	POPJ	%17,
EXSP:	JRST	EXPR2			; SPACE OR TAB
EXPL:	MOVE	%06,[ADDM %00,%10]	; +
EXMI:	MOVE	%06,[SUBM %00,%10]	; -
EXOR:	MOVE	%06,[ORM  %00,%10]	; !
EXAN:	MOVE	%06,[ANDM %00,%10]	; &
EXMU:	MOVE	%06,[IMULM %00,%10]	; ^
EXTE:	SKIPA	%06,[ORM  %00,%10]	; SPACE USED AS OPERATOR

EXC1:	PUSHJ	%17,EXPRHW		; !
	DEPHASE

EXPRHW:	LSH	%10,6			;HALF-WORD OPERATION
	MOVE	%06,[ORM  %00,%10]
	POPJ	%17,


EXO2JT:
	PHASE	0
	JFCL			; USER-DEFINED SYMBOL
PSOP:	PUSHJ	%17,EXPRPS	; PSEUDO-OP
MROP:	PUSHJ	%17,EXPMR	; MEMORY REFERENCE
MCOP:	JFCL			; MICRO-INSTRUCTION
MAOP:	PUSHJ	%17,EXPRPS
	DEPHASE


EXPRPS:	SETZ	%10,
	TRO	%15,ERRO
	POPJ	%17,
EXPMR:				;MEMORY REFERENCE INSTRUCTION
	SKIPA	%03,%13		;SAVE CHARACTER POINTER AND SKIP
EXPMR1:	ILDB	%14,%13		;GET NEXT CHARACTER
	LDB	%02,C5PNTR	;CONVERT USING COLUMN 5
	XCT	EXPMT1(%02)
	ILDB	%14,%13		;GET NEXT CHARACTER
	LDB	%02,ANPNTR	;TEST FOR TERMINATOR
	XCT	EXPMT2(%02)
	TRO	%15,ERRI	;BAD REFERENCE
	JRST	EXPMR		;TEST FOR ANOTHER


EXPMT1:
	PHASE	0
	JRST	EXPMR3
MRSP:	JRST	EXPMR1		; TAB, SPACE
MRCI:	MOVEI	%01,0400	; I
MRCZ:	MOVEI	%01,0000	; Z
	DEPHASE


EXPMT2:
	PHASE	0
	TROE	%10,0(%01)
.TAB:	TROE	%10,0(%01)	; TAB, SPACE
.ALP:	JRST	EXPMR3		; ALPHABETIC
.NUM:	JRST	EXPMR3		; NUMERIC
	DEPHASE
EXPMR3:
	MOVE	%13,%03		;RESTORE CHARCTER POINTER
	LDB	%14,%13		;  AND CHARACTER
	PUSH	%17,%10		;STACK VALUE
	PUSHJ	%17,EXPR	;EVALUATE EXPRESSION
	 SKIPE	LITLVL		;NULL ADDRESS, ERROR IF NOT IN LITERAL
	CAIA			;  OK
	TRO	%15,ERRU	;  NULL, NOT IN LITERAL
	ANDI	%10,7777	;BEWARE OF OVERFLOW
	CAIGE	%10,200		;PAGE ZERO?
	JRST	EXPMR5		;  YES, SKIP TEST
	MOVE	%03,%05		;NO, USE %03 FOR SCRATCH
	TRZ	%03,0177	;ZERO LOW BITS
	TDC	%10,%03		;TEST FOR CURRENT PAGE
	TRNN	%10,7600
	JRST	EXPMR4		;YES
	TRO 	%15,ERRG		; SET LINK GENERATED ERROR
	TDC	%10,%03		;NO, RESTORE VALUE
	PUSHJ	%17,PILIT	;BUILD A LITERAL
	ANDI	%10,0177	;WE KNOW THAT IT IS THE CURRENT PAGE
	TRO	%10,0400	;SET INDIRECT BIT
	TDNE	%10,0(%17)	;BIT ALREADY SET?
	TRO	%15,ERRI	;  YES, FLAG ERROR
EXPMR4:	TRO	%10,0200	;SET PAGE BIT
EXPMR5:	ORM	%10,0(%17)	;MERGE INTO INSTRUCTION
	POP	%17,%10		;RESTORE VALUE
	POPJ	%17,		;EXIT
				;PUSHJ	%17,TERM
				; 	NULL
				; 	NUMERIC
				; 	SYMBOLIC

TERM0:	ILDB	%14,%13
TERM:
	SETZB	%10,%01		;RETURN VALUE IN %10
	LDB	%02,C6PNTR	;CONVERT USING COLUMN 6
	ADDI	%02,TERMCV	;POINT TO CONVERSION TABLE
	LDB	%02,CNVTBL(%12)	;CONVERT TO PROPER MODE
	CAIL	%02,TJNM	;NUMERIC TYPE?
	AOS	0(%17)		;  YES, RETURN +1
	CAIL	%02,TJAL	;ALPHABETIC?
	AOS	0(%17)		;  YES, RETURN +2
	XCT	TERMJT(%02)	;EXECUTE TABLE

TERMCV:				;TERM CONVERSION TABLE
	PHASE	0
	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
TJSP:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 

TJNM:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
TJUO:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
TJPE:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
TJQT:	BYTE	(4)	  . ,  0 ,  . ,  . ,  . ,  . 
TJLP:	BYTE	(4)	  . ,  0 ,  . ,  . ,  . ,  . 
TJLB:	BYTE	(4)	  . ,  0 ,  . ,  . ,  . ,  . 

TJAL:	BYTE	(4)	  . ,  . ,  . ,  . ,  . ,  . 
	DEPHASE


TERMJT:				;TERM JUMP TABLE
	PHASE	0
	POPJ	%17,		; NO OPERATION
TJSP:	JRST	TERM0		; SPACE OR TAB

TJNM:	JRST	TERMNM		; NUMERIC
TJUO:	POPJ	%17,		; +, -
TJPE:	JRST	TERMPE		; .
TJQT:	JRST	TERMQT		; "
TJLP:	JRST	PCLIT		; (
TJLB:	JRST	PZLIT		; [

TJAL:	JRST	GETSYM		; ALPHABETIC
	DEPHASETERMNM:				;NUMERIC TERM
	MOVEI	%02,-"0"(%14)	;GET ABSOLUTE VALUE
	CAML	%02,RADIX	;TEST WITHIN CURRENT RADIX BOUNDS
	TRO	%15,ERRN	;  NO, FLAG ERROR
	IMUL	%10,RADIX	;MULTIPLY BY RADIX
	ADD	%10,%02		;ADD IN CURRENT CHAR
	ILDB	%14,%13		;GET NEXT CHARCTER
	LDB	%02,ANPNTR	;TEST FOR NUMERIC
	XCT	NTERMT(%02)	;EXECUTE TABLE
	TRO	%15,ERRN	;OVERFLOW ERROR, FLAG IT
	POPJ	%17,

NTERMT:				;NUMERIC TERM TABLE
	PHASE	0
	CAILE	%10,7777
.TAB:	CAILE	%10,7777	;TAB, SPACE
.ALP:	CAILE	%10,7777
.NUM:	JRST	TERMNM
	DEPHASE


TERMPE:				;  .
	MOVE	%10,%05		;SET VALUE TO CURRENT LOCATION
	ILDB	%14,%13		;GET NEXT CHARACTER
	POPJ	%17,		;EXIT


TERMQT:				;  "
	ILDB	%14,%13		;GET THE NEXT CHARACTER
	LDB	%02,C7PNTR	;CONVERT USING COLUMN 7
	XCT	QJTABL(%02)	;TEST VALIDITY
	ILDB	%14,%13		;OK, GET NEXT CHARACTER
	POPJ	%17,		;EXIT


QJTABL:
	PHASE	0
	TROA	%15,ERRT	; INVALID QUOTE CHARACTER
QJNU:	TROA	%15,ERRT
QJCR:	TROA	%15,ERRT
QJTB:	MOVEI	%10,200(%14)	; TAB
QJSP:	MOVEI	%10,200(%14)	; SPACE
QJPC:	MOVEI	%10,200(%14)	; PRINTING CHARACTER
	DEPHASE
PCLIT:				;PROCESS CURRENT LITERALS
	AOS	LITLVL		;INCREMENT LIT LEVEL COUNT
	PUSHJ	%17,EXPR0	;EVALUATE THE EXPRESSION
	 TRO	%15,ERRL	;ERROR IF NULL
	SOSA	LITLVL		;DECREMENT LEVEL COUNT AND SKIP
PCLIT1:	ILDB	%14,%13		;GET THE NEXT CHARACTER
	LDB	%02,C9PNTR	;CONVERT USING COLUMN 9
	XCT	PCLJT(%02)	;TEST FOR )
PILIT:	TLNN	%15,LITFLG	;LITERALS ALLOWED?
	TROA	%15,ERRI	;  NO, FLAG ILLEGAL INDIRECT
	TLNE	%15,P1F		;PASS 1?
	POPJ	%17,		;  YES, EXIT
	LDB	%01,[POINT 5,%05,28]	;GET PAGE NUMBER
	JUMPE	%01,PCZLIT	;BRANCH IF PAGE 0
	ANDI	%10,007777	;MASK VALUE
	SKIPN	%07,CLHBUF(%01)	;ANY LITS THIS PAGE?
	JRST	PCLIT3		;  NO, INITIALIZE
	MOVEI	%07,177		;MAKE ADDRESS RELATIVE
PCLIT2:	SKIPN	%02,CLTBUF(%07)	;TEST FOR VALUE (NON-ZERO)
	JRST	PCLIT4		;  NO
	CAIN	%10,0(%02)	;  YES, DO THEY COMPARE?
	JRST	PCLIT5		;  YES, THIS IS THE ONE
	SOJGE	%07,PCLIT2	;TEST FOR END
	SETZ	%07,		;END ,ERROR
	TRO	%15,ERRL
	JRST	PCLIT5

PCLIT3:	MOVEI	%07,177		;INITIALIZE
PCLIT4:	HRROM	%10,CLTBUF(%07)	;STORE AND FLAG CURRENT LITERAL
	DPB	%01,[POINT 5,%07,28]	;SET PAGE
	MOVEM	%07,CLHBUF(%01)	;SET HEADER BUFFER
	MOVE	%10,%07
	JRST	LITCRF

PCLIT5:	DPB	%01,[POINT 5,%07,28]
	MOVE	%10,%07		;SET RESULT IN %10
	JRST	LITCRF		;EXIT THROUGH CREF


PCLJT:				;PROCESS CURRENT LITERALS JUMP TABLE
	PHASE	0
	JFCL
LTSP:	JRST	PCLIT1		; SPACE, TAB
LTRP:	ILDB	%14,%13		; )
LTRB:	JFCL			; ]
	DEPHASE
DCLIT:				;DUMP CURRENT LITERALS
	TLNN	%15,P1F		;PASS 1?
	TRNN	%05,7600	;  OR PAGE ZERO?
	POPJ	%17,		;  YES, EXIT
	MOVSI	%07,-200	;INIT INDEX
	SKIPN	CLTBUF(%07)	;SEARCH FOR START
	AOBJN	%07,.-1
	JUMPGE	%07,CPOPJ	;EXIT IF NONE
	TRZE	%16,HDRBIT	;FORM FEED SEEN?
	TRO	%16,HDRSAV	;  YES, CLEAR BUT REMEMBER
	MOVEI	%10,-1(%07)	;GET CURRENT LOCATION MINUS ONE
	LDB	%01,[POINT 5,%05,28]
	DPB	%01,[POINT 5,%10,28]	;SET PAGE
	SETZM	CLHBUF(%01)	;CLEAR FOR OUTPUT
	PUSH	%17,%10		;STACK NEW VALUE
	PUSH	%17,%01		;  AND INDEX
DCLIT1:	SKIPN	%10,CLTBUF(%07)	;VALUE STORED HERE (NON-ZERO)?
	JRST	DCLIT2		;  NO
	SETZM	CLTBUF(%07)	;ZERO
	MOVEM	%10,VALUE	;SET FOR ENDL
	MOVE	%10,%05		;GET LOCATION COUNTER
	ANDI	%10,007600	;MASK CURRENT PAGE BITS
	TRO	%10,0(%07)	;SET ADDRESS BITS
	PUSHJ	%17,LITCRF	;CREF IT
	MOVEI	%02,CRSYMD
	PUSHJ	%17,LISTCQ	;FLAG AS DEFINING OCCURENCE
	PUSHJ	%17,SETLOC	;CHECK FOR SEQUENCE BREAK
	SETZM	EQUIV
	TLO	%15,SRCFLG	;DON'T LIST SOURCE LINE
	PUSHJ	%17,ENDL	;PRINT
DCLIT2:	AOBJN	%07,DCLIT1	;TEST FOR END
	POP	%17,%01		;RETRIEVE INDEX
	POP	%17,CLHBUF(%01)	;SET NEW VALUE
	TRZE	%16,HDRSAV	;WAS THERE A FORM FEED?
	TRO	%16,HDRBIT	;  YES, RESTORE IT
	POPJ	%17,		;EXIT
PZLIT:				;PROCESS PAGE ZERO LITERALS
	AOS	LITLVL		;INCREMENT LIT LEVEL COUNT
	PUSHJ	%17,EXPR0	;EVALUATE THE EXPRESSION
	 TRO	%15,ERRL	;ERROR IF NULL
	SOSA	LITLVL		;DECREMENT LEVEL COUNT AND SKIP
PZLIT1:	ILDB	%14,%13		;GET THE NEXT CHARACTER
	LDB	%02,C9PNTR	;CONVERT USING COLUMN 9
	XCT	PZLJT(%02)	;TEST FOR ]
	JUMP1	CPOPJ		;EXIT IF PASS 1
PCZLIT:	ANDI	%10,007777	;MASK VALUE
	MOVEI	%07,177		;POINT TO END OF BUFFER
PZLIT2:	SKIPE	%02,ZLTBUF(%07)	;IF LOCATION AVAILABLE
	CAIN	%10,0(%02)	;OR WE HAVE A MATCH
	JRST	PZLIT3		;WE ARE ALMOST THRU
	CAIE	%07,0		;NO. MORE ROOM ON THIS PAGE?
	SOJA	%07,PZLIT2	;YES. DECREMENT ADR AND TRY AGAIN
	TROA	%15,ERRL	;NO ROOM. FLAG ERR AND DON'T STORE
PZLIT3:	HRROM	%10,ZLTBUF(%07)	;  YES, STORE IT
	MOVEI	%10,0(%07)	;SUBSTITUTE

LITCRF:				;CREF FOR LITERALS
	TLNN	%15,LITFLG	;LITERALS ALLOWED?
	TRO	%15,ERRL	;  NO, FLAG ERROR
	MOVE	%01,%10		;GET VALUE
	LSHC	%00,^D24+3	;CONVERT TO SIXBIT
	REPEAT	3,	<
	LSH	%00,3
	LSHC	%00,3	>

	ADD	%00,[SIXBIT /.L0000/]	;FORM SYMBOL
	JRST	CRFOUT		;EXIT THROUGH CREF


PZLJT:				;PROCESS PAGE ZERO LITERALS JUMP TABLE
	PHASE	0
	JFCL
LTSP:	JRST	PZLIT1		; SPACE, TAB
LTRP:	JFCL			; )
LTRB:	ILDB	%14,%13		; ]
	DEPHASE
DZLIT:				;DUMP PAGE ZERO LITERALS
	JUMP1	CPOPJ		;EXIT IF PASS 1
	MOVSI	%07,-200	;INIT INDEX
DZLIT1:	SETZ	%10,
	EXCH	%10,ZLTBUF(%07)	;ZERO FOR NEXT FIELD
	JUMPGE	%10,DZLIT2	;VALUE STORED HERE (NON-ZERO)?
	MOVEM	%10,VALUE	;SET FOR ENDL
	MOVEI	%10,0(%07)	;PUT VALUE IN %10
	PUSHJ	%17,LITCRF	;CREF IT
	MOVEI	%02,CRSYMD
	PUSHJ	%17,LISTCQ	;FLAG AS DEFINING OCCURENCE
	PUSHJ	%17,SETLOC	;TEST FOR SEQUENCE BREAK
	SETZM	EQUIV
	TLO	%15,SRCFLG	;DON'T LIST SOURCE LINE
	PUSHJ	%17,ENDL	;PRINT
DZLIT2:	AOBJN	%07,DZLIT1	;TEST FOR END
	MOVSI	%07,-40
	SETZM	CLHBUF(%07)	;ZERO IN EVENT OF "FIELD"
	AOBJN	%07,.-1
	POPJ	%17,
TSTSYM:				;TEST FOR SYMBOL
	LDB	%02,ANPNTR
	XCT	TSTTBL(%02)
	JRST	TSTSYM		;TAB, TRY AGAIN
	JRST	GETSYM		;OK


TSTTBL:				;TEST SYMBOL TABLE
	PHASE	0
	POPJ	%17,
.TAB:	ILDB	%14,%13
.ALP:	AOSA	0(%17)
.NUM:	POPJ	%17,
	DEPHASE


GETSYM:
	SETZ	%00,		;CLEAR AC
	MOVSI	%02,(POINT 6,%00,)	;SET BYTE POINTER
GETSY1:	SUBI	%14,40		;CONVERT TO SIXBIT
	TLNE	%02,770000	;ROOM TO STORE?
	IDPB	%14,%02		;  YES
	ILDB	%14,%13		;GET NEXT CHARACTER
	LDB	%03,ANPNTR	;TEST ALPHA/NUMERIC
	XCT	GSJTBL(%03)	;EXECUTE TABLE


GSJTBL:				;GETSYM JUMP TABLE
	PHASE	0
	POPJ	%17,		; NULL
.TAB:	POPJ	%17,		; TAB OR SPACE
.ALP:	JRST	GETSY1		; ALPHABETIC
.NUM:	JRST	GETSY1		; NUMERIC
	DEPHASE
OCTAL:
	MOVEI	%10,^D8
	CAIA
DECIMA:
	MOVEI	%10,^D10
	MOVEM	%10,RADIX
	POPJ	%17,


PAGE:
	PUSHJ	%17,DCLIT	;TEST FOR LITERALS
	PUSHJ	%17,EXPR
	 JRST	PAGE1
	TRZE	%10,7400	;WITHIN BOUNDS?
	TRO	%15,ERRP	;  NO, FLAG ERROR
	LSH	%10,7
	JRST	OUTLOC		;DON'T TEST FOR SEQUENCE BREAK

PAGE1:				;"PAGE" WITH NO ARGUMENT
	MOVE	%10,%05		;GET CURRENT LOCATION
	TRZE	%10,000177	;CLEAR ADDRESS FIELD, WAS IT ZERO?
	ADDI	%10,000200	;  NO, MOVE TO NEXT PAGE
	JRST	OUTLOC		;DON'T TEST FOR SEQUENCE BREAK


FIELD:				;"FIELD" PSEUDO-OP PROCESSOR
	PUSHJ	%17,DCLIT	;DUMP CURRENT LITERALS
	PUSHJ	%17,DZLIT	;  AND PAGE ZERO LITERALS
	PUSHJ	%17,EXPR	;COMPUTE EXPRESSION
	 CAIA			;NULL, ERROR
	TRZE	%10,777770	;OVERFLOW?
	TRO	%15,ERRQ	;  YES, MARK IT
	HRROM	%10,EQUIV	;LIST THE VALUE
	JUMP1	CPOPJ		;EXIT IF PASS 1
	LSH	%10,3		;MOVE BITS INTO PROPER SLOT
	MOVEI	%02,CHAN78_-6(%10)	;SET CHANNEL BITS
	PUSHJ	%17,BINOUT	;OUTPUT, BYPASSING CHECK-SUM
	JRST	BITDMP		;DUMP BIT TABLE AND EXIT


XLIST:				;"XLIST" PSEUDO-OP PROCESSOR
	TLNN	%15,P1F		;BYPASS IF PASS 1
	TLO	%15,XLFLG	;SET FLAG
	POPJ	%17,		;EXIT


NOPUNC:	TLNN	%15,P1F		;"NOPUNC" PSEUDO-OP
	TLOA	%16,NOPBIT
ENPUNC:	TLZ	%16,NOPBIT	;"ENPUNC" PSEUDO-OP
	POPJ	%17,
DTORG:				;"DTORG" PSEUDO-OP
	PUSHJ	%17,DCLIT	;DUMP CURRENT PAGE LITERALS
	PUSHJ	%17,DZLIT	;DUMP PAGE ZERO LITERALS
	PUSHJ	%17,EXPR	;EVALUATE THE EXPRESSION
	 JFCL			;NULL
	HRROM	%10,EQUIV	;LIST THE VALUE
	TLNN	%16,DSWBIT	;/D SET?
	POPJ	%17,		;  NO, EXIT
	TRO	%10,CHAN78	;YES, SET CHANNELS 7 AND 8
	JRST	BINWRD		;DUMP AND EXIT


ZBLOCK:				;"ZBLOCK" PSEUDO-OP
	PUSHJ	%17,EXPR	;EVALUATE THE EXPRESSION
	 TRO	%15,ERRQ	;NULL, FLAG ERROR
	ANDI	%10,7777	;MASK VALUE
	TRZE	%10,4000	;OVERFLOW?
	TRO	%15,ERRQ	;  YES, FLAG ERROR
	MOVEM	%10,ZBLTMP	;SAVE THE COUNT
ZBLOC1:	SOSGE	ZBLTMP		;TEST FOR END
	POPJ	%17,		;  OK, EXIT
	HRROS	VALUE		;DUMP A ZERO
	PUSHJ	%17,ENDL	;LIST THE LINE
	TLO	%15,LINFLG	;DON'T LIST NEXT LINE
	JRST	ZBLOC1		;TRY AGAIN


FIXMR0:	ILDB	%14,%13
FIXMRI:				;"FIXMRI" PSEUDO-OP
	LDB	%02,ANPNTR
	XCT	FIXTBL(%02)	;TAKE PROPER ACTION
	CAIE	%14,"="		;PROPER TERMINATION?
	JRST	EXPRPS		;  NO, ERROR
	PUSHJ	%17,EXPR0	;  YES, COMPUTE EXPRESSION
	 TRO	%15,ERRU	;NULL, ERROR
	PUSHJ	%17,SRCH	;SEARCH THE SYMBOL TABLE
	 JFCL
	MOVE	%01,%10		;SET VALUE
	HRLI	%01,MROP	;FLAG AS MEMORY REFERENCE INSTRUCTION
	JRST	INSRT		;INSERT AND EXIT

FIXTBL:				;FIXMRI TABLE
	PHASE	0
	JRST	EXPRPS		; ERROR
.TAB:	JRST	FIXMR0		; SPACE OR TAB
.ALP:	PUSHJ	%17,GETSYM	; ALPHABETIC
.NUM:	JRST	EXPRPS		; NUMERIC
	DEPHASE
EXPUNG:				;"EXPUNGE" PSEUDO-OP
	JUMP2	CPOPJ		;EXIT IF PASS 2
	MOVSI	%02,BSYMT-EEXOPS;  YES, SET FOR ONLY PSEUDO-OPS
	JRST	SYTI		;RE-INIT TABLE AND EXIT


FIXTAB:				;"FIXTAB" PSEUDO-OP
	JUMP2	CPOPJ		;EXIT IF PASS 2
	MOVE	%07,SYTBOT	;SET INDEX
	ADDI	%07,2
FIXTA1:	PUSHJ	%17,GETSTE	;GET NEXT NON-SPECIAL SYMBOL
	 POPJ	%17,		;END, EXIT
	MOVSI	%02,MCOP	;NON-SPECIAL, CONSIDER IT A PSEUDO-OP
	ORM	%02,0(%07)	;FLAG SYMBOL
	JRST	FIXTA1		;TRY AGAIN
TEXT0:	ILDB	%14,%13
TEXT:				;"TEXT" PSEUDO-OP PROCESSOR
	LDB	%02,C7PNTR	;CONVERT USING COLUMN 7
	XCT	TEXTB1(%02)	;TEST FOR DELIMITER
TEXT1:	ILDB	%14,%13		;FOUND, GET NEXT CHARACTER
	LDB	%02,C7PNTR	;CONVERT USING COLUMN 7
	XCT	TEXTB2(%02)	;TEST FOR END
	JRST	TEXT4		;FOUND
	ANDI	%14,77		;VALID CHARACTER, TRIM
	SKIPE	VALUE		;SECOND HALF?
	JRST	TEXT2		;  YES
	LSH	%14,6		;  NO, MOVE INTO LEFT POSITION
	HRROM	%14,VALUE	;STORE IT
	JRST	TEXT1		;TRY AGAIN

TEXT2:	ORM	%14,VALUE	;SECOND HALF, MERGE WITH FIRST
	PUSHJ	%17,ENDL	;PRINT THE LINE
	TLO	%15,SRCFLG	;DON'T LIST FOLLOWING LINES
	JRST	TEXT1		;GET THE NEXT CHARACTER

TEXT3:	TROA	%15,ERRT	;ERROR, MARK AND SKIP
TEXT4:	ILDB	%14,%13		;NORMAL TERMINATION, MOVE TO NEXT CHAR
	HRROS	VALUE		;MAKE SURE BINARY IS COUNTED
	POPJ	%17,		;EXIT


TEXTB1:				;TEXT TABLE 1
	PHASE	0
	JRST	TEXT3		; INVALID CHARACTER
QJNU:	JRST	TEXT3
QJCR:	JRST	TEXT3
QJTB:	JRST	TEXT0		; TAB
QJSP:	JRST	TEXT0		; SPACE
QJPC:	MOVEM	%14,TXTEND	; PRINTING CHARACTER
	DEPHASE

TEXTB2:				;TEXT TABLE 2
	PHASE	0
	JRST	TEXT3
QJNU:	JRST	TEXT3
QJCR:	JRST	TEXT3
QJTB:	JRST	TEXT3
QJSP:	CAMN	%14,TXTEND
QJPC:	CAMN	%14,TXTEND
	DEPHASE
XTEXT:				; "<" PALX GLICH
	ILDB	%14,%13		;MOVE PAST OPENING BRACKET
	TLNE	%16,DSWBIT	;/D SET?
	ILDB	%14,%13		;  YES, FORGET FIRST CHAR
XTEXT1:	JUMPE	%14,XTEXT4	;BRANCH IF CR
	CAIN	%14,">"
	JRST	XTEXT5		;BRANCH IF CLOSING BRACKET
	CAIL	%14,"A"		;ALPHABETIC?
	CAILE	%14,"Z"
	TRO	%15,ERRT	;  NO, FLAG ERROR
	ANDI	%14,77		;MASK TO TRIMMED ASCII
	MOVE	%00,%14		;SAVE IN %00
	ILDB	%14,%13		;GET THE NEXT CHARACTER
	CAIE	%14,"-"
	JRST	XTEXT2		;BRANCH IF NOT MINUS
	TRO	%00,40		;FLAG
	ILDB	%14,%13		;MOVE PAST MINUS
XTEXT2:	SKIPE	VALUE		;FIRST HALF?
	JRST	XTEXT3		;  NO
	LSH	%00,6		;  YES, MOVE VALUE THERE
	HRROM	%00,VALUE	;STORE
	JRST	XTEXT1		;TRY THE NEXT CHARACTER

XTEXT3:	ORM	%00,VALUE	;SECOND HALF, MERGE
	PUSHJ	%17,ENDL	;DUMP THE LINE
	TLO	%15,SRCFLG	;DON'T PRINT SOURCE MORE THAN ONCE
	JRST	XTEXT1		;GET NEXT CHAR

XTEXT4:	PUSH	%17,VALUE	;CR, SAVE VALUE
	SETZM	VALUE
	TLZN	%15,SRCFLG	;HAVE WE LISTED THE SOURCE?
	PUSHJ	%17,ENDL	;  NO, DO SO
	PUSHJ	%17,GETLIN	;GET THE NEXT SOURCE LINE
	TLNE	%16,DSWBIT	;/D SET?
	ILDB	%14,%13		;  YES, BYPASS FIRST CHAR
	POP	%17,VALUE	;REPLACE VALUE
	SETZ	%00,		;TREAT CR AS NULL
	JRST	XTEXT2

XTEXT5:	ILDB	%14,%13		;">", MOVE PAST IT
	MOVEI	%00,0077	;ASSUME NEW CODE WORD
	SKIPN	VALUE		;GOOD GUESS?
	JRST	XTEXT6		;YES
	PUSHJ	%17,ENDL	;  NO, LIST CURRENT WORD
	TLO	%15,SRCFLG
	MOVEI	%00,7777	;FINISH WITH 7777
XTEXT6:	HRROM	%00,VALUE	;SET FINAL VALUE
	POPJ	%17,		;EXIT
DBLENT:				;DOUBLE ENTRY
	MOVEM	%13,DBLSAV	;SAVE IN EVENT OF FAILURE
	PUSHJ	%17,@DBLPNT	;GO TO APPROPRIATE ROUTINE
	TRZN	%15,ERRN	;VALUE FOUND?
	JRST	LINE2		;  YES, FINISH UP
	SETZM	DBLPNT		;  NO, RESET POINTER
	MOVE	%13,DBLSAV	;RESTORE CHARACTER POINTER
	LDB	%14,%13		;  AND CHARACTER
	JRST	LINE1		;TRY FOR NORMAL LINE


DUBL:				;"DUBL" PSEUDO-OP
	PUSHJ	%17,DBL0	;GO PROCESS
	 JRST	DBLERR		;ERROR
	TLZE	%15,NEGFLG	;UNARY MINUS FOUND?
	MOVNS	%10		;  YES
	MOVEI	%00,DUBL
DUBLX:	MOVEM	%00,DBLPNT	;SET POINTER FOR NEXT LINE
	LDB	%00,[POINT 12,%10,23]
	HRROM	%00,VALUE	;SET FIRST WORD
	HRROS	%10
	PUSH	%17,%10		;SAVE SECOND HALF
	PUSHJ	%17,ENDL	;LIST FIRST HALF
	POP	%17,VALUE	;SET SECOND HALF
	TLO	%15,SRCFLG	;DON'T LIST SOURCE ARAIN
	POPJ	%17,		;EXIT
FLTG:				;"FLTG" PSEUDO-OP
	PUSHJ	%17,DBL0	;PROCESS DOUBLE PRECISION
	 CAIN	%14,"."		;  NON-NUMERIC, IS IT DECIMAL POINT?
	SKIPA	%03,%15		;OK, SAVE NEGFLG
	JRST	DBLERR		;ERROR, EXIT
	HRRZ	%06,%01		;SAVE INTEGER DIGITS
	CAIE	%14,"."		;DECIMAL POINT?
	JRST	FLTG1		;  NO
	ILDB	%14,%13		;  YES, GET NEXT CHARACTER
	PUSHJ	%17,DBL		;PROCESS DOUBLE
	 JFCL
FLTG1:	HLRZS	%01		;GET DIGITS USED
	SUB	%06,%01		;DECREMENT FACTOR
	CAIE	%14,"E"		;EXPONENT?
	JRST	FLTG2		;  NO
	ILDB	%14,%13		;  YES, PASS OVER IT
	MOVE	%07,%10		;SAVE VALUE TO DATE
	PUSHJ	%17,DBL0	;COMPUTE EXPONENT
	 JRST	DBLERR		;  ERROR, EXIT
	TLZE	%15,NEGFLG	;UNARY MINUS SEEN?
	MOVNS	%10		;YES
	ADD	%06,%10		;UPDATE FACTOR
	MOVE	%10,%07		;RESTORE VALUE
FLTG2:	SETZ	%00,
	JUMPE	%10,FLTG7	;BRANCH IF ZERO
	TROA	%00,^D35	;SET INITIAL EXPONENT
FLTG3:	ASH	%10,1		;SHIFT LEFT
	TLNN	%10,200000	;NORMALIZED?
	SOJA	%00,FLTG3	;  NO, ADJUST EXPONENT AND LOOP
	JUMPL	%06,FLTG5	;BRANCH IF NEGATIVE
FLTG4:	SOJL	%06,FLTG6	;TEST FOR END
	MOVEM	%10,%02		;COMPUTE N/4
	ASH	%02,-2
	ADD	%10,%02		;ADD IT IN
	ADDI	%00,3		;MULTIPLY BY 8 (8*(N+N/4) = 10N)
	CAIGE	%10,0		;ARE WE IMPOSING ON SIGN BIT?
	PUSHJ	%17,SCALML	;  YES, SCALE RIGHT
	JRST	FLTG4		;LOOP

FLTG5:	CAML	%10,[^D10B4]	;OK FOR DIVIDE?
	PUSHJ	%17,SCALML	;  NO, SCALE DOWN
	DIV	%10,[^D10B4]	;DIVIDE BY TEN
	SUBI	%00,4		;COMPENSATE FOR [^D10B4] SCALING
	AOJL	%06,FLTG5	;TEST FOR END
FLTG6:	ADDI	%10,4000 	;ADD ROUNDING CONSTANT
	CAIGE	%10,0		;OVERFLOW?
	PUSHJ	%17,SCALML	;  YES, SCALE RIGHT
	ASHC	%10,-^D12
	TLZE	%03,NEGFLG	;UNARY MINUS SEEN?
	MOVNS	%10		;  YES, NEGATE FRACTION
FLTG7:	PUSH	%17,%10		;SAVE FRACTION
	HRROM	%00,VALUE	;SET EXPONENT
	PUSHJ	%17,ENDL	;DUMP IT
	POP	%17,%10		;RETRIEVE FRACTION
	TLO	%15,SRCFLG	;SUPPRESS SOURCE LITING
	MOVEI	%00,FLTG	;SET FLAG FOR RETURN
	JRST	DUBLX		;EXIT THROUGH DUBL


SCALML:				;SCALE ML
	LSH	%10,-1		;SCALE RIGHT
	AOJA	%00,CPOPJ	;INCREMENT EXPONENT AND EXIT
DBL0:				;DOUBLE PRECISION SUBROUTINE
	SETZB	%10,%01
DBL:				;NON-INITIALIZING ENTRY POINT
	TLZA	%15,NEGFLG	;RESET NEGATE FLAG AND SKIP
DBL1:	ILDB	%14,%13		;GET NEXT CHARACTER
	LDB	%02,ANPNTR	;GET CHARACTERISTICS
	XCT	DBLTBL(%02)	;EXECUTE TABLE
	TLCA	%15,NEGFLG	;  "-", TOGGLE FLAG AND SKIP
	CAIN	%14,"+"		;  NO, UNARY PLUS?
	JRST	DBL1		;  YES, GET NEXT CHARACTER
	POPJ	%17,

DBL2:	TLNE	%10,760000	;POSSIBLE OVERFLOW?
	AOJA	%01,DBL3	;  YES
	IMULI	%10,^D10	;USE DECIMAL RADIX
	ADDI	%10,-"0"(%14)	;ADD IN THIS NUMBER
	AOBJP	%01,.+1
DBL3:	ILDB	%14,%13		;GET NEXT CHARACTER
	CAIL	%14,"0"		;IS IT A NUMBER
	CAILE	%14,"9"
	JRST	CPOPJ1		;FINISHED, SKIP-RETURN
	JRST	DBL2		;  YES, ADD IT IN


DBLTBL:
	PHASE	0
	CAIN	%14,"-"
.TAB:	JRST	DBL1
.ALP:	POPJ	%17,
.NUM:	JRST	DBL2
	DEPHASE


DBLERR:	TRO	%15,ERRN	;FLAG NUMERIC ERROR
	POPJ	%17,		;  AND QUIT
IFDEF:	TLO	%15,IFDFLG	;"IFDEF" PSEUDO-OP
IFNDEF:				;"IFNDEF" PSEUDO-OP
	PUSHJ	%17,TSTSYM	;TRY FOR SYMBOL
	 TROA	%15,ERRQ	;  NOT SYMBOL, ERROR AND NOT FOUND
	PUSHJ	%17,SRCH	;SYMBOL, LOOK IT UP
	TLCA	%15,IFDFLG	;  NOT FOUND, TOGGLE FLAG
	PUSHJ	%17,CRFOUT	;OUTPUT TO CREF
	TLZN	%15,IFDFLG	;FLAG TRUE?
	JRST	UNSCON		;  NO
	JRST	SATCON		;  YES


IFZERO:				;"IFZERO" PSEUDO-OP
	PUSHJ	%17,EXPR	;EVALUATE THE EXPRESSION
	 TRO	%15,ERRQ	;NULL, ERROR
	TRNE	%10,7777	;ZERO?
	JRST	UNSCON		;  NO, UNSATISFIED
	JRST	SATCON		;  YES, SATISIFIED

IFNZRO:				;"IFNZRO" PSEUDO-OP
	PUSHJ	%17,EXPR	;EVALUATE THE EXPRESSION
	 TRO	%15,ERRQ	;NULL, ERROR
	TRNN	%10,7777	;ZERO?
	JRST	UNSCON		;  YES, UNSATISFIED
	JRST	SATCON		;  NO, SATISIFIED
SATCON:	AOSA	LVLCNT		;FOUND, BUMP CONDITIONAL LEVEL COUNT
SATCO1:	ILDB	%14,%13		;GET NEXT CHARACTER
	LDB	%02,C1PNTR	;CONVERT USING COLUMN 1
	XCT	SATJTB(%02)	;LOOK FOR "<"
	TRO	%15,ERRQ	;INVALID, FLAG ERROR
	POPJ	%17,		;EXIT


SATJTB:				;SATCON JUMP TABLE
	PHASE	0
	SOS	LVLCNT		; INVALID
LNSP:	JRST	SATCO1		; SPACE, TAB
LNCR:	SOS	LVLCNT		; CR, /
LNSC:	SOS	LVLCNT		; ;
LNDO:	SOS	LVLCNT		; $
LNLA:	JRST	STMNT0		; <
LNRA:	SOS	LVLCNT		; >
	DEPHASE


UNSCON:				;UNSATISFIED CONDITIONAL
	TDZA	%07,%07		;INIT LOCAL LEVEL COUNT
UNSCO1:	ILDB	%14,%13		;GET NEXT CHARACTER
UNSCO2:	LDB	%02,C1PNTR	;CONVERT USING COLUMN 1
	XCT	UNSJTB(%02)	;PERFORM PROPER ACTION
	CAIE	%07,0		; ">", WAS "<" SEEN?
	TROA	%15,ERRQ	;  NO, FLAG ERROR
	ILDB	%14,%13		;  YES, GET NEXT CHARACTER
	POPJ	%17,		;EXIT

UNSCO3:	JUMPN	%14,UNSCO1	;BRANCH ON NON-CR
	PUSHJ	%17,ENDL	;END OF LINE, LIST IT
	PUSHJ	%17,GETLIN	;GET ANOTHER LINE
	JRST	UNSCO2		;TRY AGAIN



UNSJTB:				;UNSATISFIED CONDITIONAL JUMP TABLE
	PHASE	0
	JRST	UNSCO1
LNSP:	JRST	UNSCO1		; SPACE, TAB
LNCR:	JRST	UNSCO3		; CR, /
LNSC:	JRST	UNSCO1		; ;
LNDO:	JRST	UNSCO1		; $
LNLA:	AOJA	%07,UNSCO1	; <
LNRA:	SOJG	%07,UNSCO1	; >
	DEPHASE
DEFINE:				;"DEFINE" PSEUDO-OP
	SKIPE	MACPNT		;NESTED?
	JRST	MACERR		;  YES, ERROR
	PUSHJ	%17,TSTSYM	;  NO, GET ITS NAME
	 JRST	MACERR		;NON-SYMBOLIC, ERROR
	PUSHJ	%17,SRCH	;SEARCH SYMBOL TABLE
	 JFCL
	MOVE	%01,MACTOP	;GET CURRENT TOP OF MACRO STORAGE
	HRLI	%01,MAOP	;DEFINE AS MACRO
	PUSHJ	%17,INSRT	;INSERT IN TABLE
	HRLI	%01,(POINT 7,,)	;SET BYTE POINTER
	MOVEM	%01,MACTMP	;SET START FOR STORAGE
	MOVEM	%17,MACPDP	;SAVE CURRENT PUSH-DOWN STACK
	PUSHJ	%17,CREFQ	;CREF WANTED?
	JRST	DEFIN0		;DONT OUTPUT TO CREF
	MOVEI	%02,CRFMAD	;MACRO DEFINITION FLAG
	PUSHJ	%17,CRFOU0	;OUTPUT SYMBOL TO CREF
DEFIN0:	SETZ	%07,		;INIT ARG COUNT
DEFIN1:	PUSHJ	%17,TSTSYM	;FETCH DUMMY ARGUMENTS
	 JRST	DEFIN2		;  END OF STRING
	PUSH	%17,%00		;STACK NAME
	AOJA	%07,DEFIN1	;TRY FOR ANOTHER

DEFIN2:	MOVE	%14,%07		;GET ARG COUNT
	PUSHJ	%17,WCIMT	;WRITE IN MACRO TREE
	LDB	%14,%13		;RESTORE LAST CHARACTER
	TDOA	%07,[-1]	;INIT LEVEL COUNTER AND SKIP
DEFIN3:	ILDB	%14,%13		;GET NEXT CHARACTER
DEFIN4:	CAIN	%14,"<"
	AOJE	%07,DEFIN3	;BUMP, FORGET IF OPENING BRACKET
	CAIN	%14,">"
	SOJL	%07,DEFIN8	;BRANCH IF END
	LDB	%02,ANPNTR	;TEST CHARACTERISTICS OF CHAR
	XCT	DEFTBL(%02)
	MOVE	%06,%13		;ALPHABETIC, SAVE POINTER
	PUSHJ	%17,GETSYM	;ACCUMULATE SYMBOL
	MOVE	%02,MACPDP	;POINT TO START OF ARG STORAGE
DEFIN5:	CAML	%02,%17		;FINISHED?
	JRST	DEFIN6		;  YES
	CAME	%00,1(%02)	;  NO, TEST FOR MATCH
	AOBJN	%02,DEFIN5	;  NO, TRY AGAIN
	SUB	%02,MACPDP	;COMPUTE ARG NUMBER
	MOVEI	%14,1(%02)	;PLACE IN %14
	PUSHJ	%17,WTIMT	;WRITE WITH FLAG
	LDB	%14,%13		;RETRIEVE LAST CHARACTER
	JRST	DEFIN4
DEFIN6:	MOVE	%13,%06		;NOT ARG, POINT TO BEGINNING
	LDB	%14,%13		;RESTORE CHARACTER
	LDB	%02,ANPNTR
	XCT	DEFTB2(%02)	;FLUSH CHARACTERS IF NOT FOUND
	ILDB	%14,%13		;TRY AGAIN
	JRST	.-3


DEFTB2:
	PHASE	0
	JRST	DEFIN4
.TAB:	JRST	DEFIN4
.ALP:	PUSHJ	%17,WCIMT
.NUM:	PUSHJ	%17,WCIMT
	DEPHASE



DEFIN7:	SKIPL	%07		;PROCESSING YET?
	PUSHJ	%17,WCIMT	;  YES, WRITE CHARACTER IN TREE
	JUMPN	%14,DEFIN3	;BRANCH IF NOT END OF LINE
	PUSHJ	%17,ENDL	;END, LIST IT
	PUSHJ	%17,GETLIN	;GET ANOTHER
	JRST	DEFIN4		;RECYCLE

DEFIN8:	AOSE	%07		;">", IS IT MATCHING?
	TRO	%15,ERRM	;  NO, ERROR
	SETZ	%14,		;SET END FLAG
	PUSHJ	%17,WTIMT	;WRITE IN TREE
	ILDB	%14,%13		;BYPASS ">"
	MOVE	%17,MACPDP	;RESTORE PD PNTR
	AOS	%02,MACTMP
	HRRZM	%02,MACTOP	;SET NEW TOP
	POPJ	%17,


DEFTBL:
	PHASE	0
	JRST	DEFIN7
.TAB:	JRST	DEFIN7
.ALP:	JUMPL	%07,DEFIN7
.NUM:	JRST	DEFIN7
	DEPHASE
CALLM:				;MACRO CALL PROCESSOR
	SKIPE	MACPNT		;ARE WE NESTED?
	JRST	MACERR		;  YES, ERROR
	HRLI	%01,(POINT 7,,)	;  NO, SET BYTE POINTER
	MOVEM	%01,MACPNT	;SET MACRO BYTE POINTER
	MOVE	%02,MACTOP
	HRLI	%02,(POINT 7,,)
	MOVEM	%02,ARGTMP	;SET ARG POINTER
	MOVEM	%02,MACTMP	;SET FOR STORAGE
	ILDB	%06,MACPNT	;GET ARGUMENT COUNT
CALLM1:	JUMPE	%06,CALLM4	;BRANCH IF NO MORE ARGS
	ILDB	%14,%13		;GET NEXT CHARACTER
CALLM2:	JUMPE	%14,CALLM4	;TEST FOR CR
	CAIN	%14,"/"		;INTO COMMENT FIELD?
	JRST	CALLM4		;  YES, GET OUT
	CAIN	%14,","		;END OF ARG?
	JRST	CALLM3		;  YES
	PUSHJ	%17,WCIMT	;  NO, WRITE CHARACTER IN TREE
	JRST	CALLM1		;GET NEXT CHARACTER

CALLM3:	IBP	%13		;INCREMENT BYTE POINTER
CALLM4:	MOVEI	%14,RUBOUT	;SET FLAG CHARACTER
	PUSHJ	%17,WCIMT	;WRITE IN TREE
	LDB	%14,%13		;RECOVER LAST CHARACTER
	SOJG	%06,CALLM2	;RECYCLE IF NOT END
	AOS	%02,MACTMP
	HRRZM	%02,MACTOP	;SET NEW TOP
	POPJ	%17,		;EXIT
WTIMT:				;WRITE TWO CHARACTERS IN MACRO TREE
	PUSH	%17,%14		;SAVE FIRST CHARACTER
	MOVEI	%14,RUBOUT
	PUSHJ	%17,WCIMT	;WRITE RUBOUT
	POP	%17,%14		;RESTORE CHARACTER
	JRST	WCIMT


WCIMT:					;WRITE CHAR IN MACRO TREE
	HRRZ	%02,MACTMP
	ADDI	%02,4
	CAML	%02,SYTBOT	;OVERFLOW?
	PUSHJ	%17,GETCOR	;  YES
	IDPB	%14,MACTMP	;DEPOSIT CHARACTER
	POPJ	%17,


MACERR:
	TRO	%15,ERRM
	POPJ	%17,
LSTOCT:
	MOVE	%03,[POINT 3,%10,23]
LSTOC1:	ILDB	%02,%03
	ADDI	%02,"0"
	PUSHJ	%17,0(%01)
	TLNE	%03,770000
	JRST	LSTOC1
	POPJ	%17,

SETLOC:				;TEST FOR SEQUENCE BREAK
	HRROM	%10,EQUIV	;LIST NEW LOCATION
	CAIN	%05,0(%10)	;IS THERE A SEQUENCE BREAK?
	POPJ	%17,		;  NO, EXIT
OUTLOC:	HRROM	%10,EQUIV
	TRZE	%10,770000	;EXPRESSION OVERFLOW?
	TRO	%15,ERRQ	;  YES, FLAG ERROR
	HRRZ	%05,%10
	TRO	%10,CHAN7	;SET CHANNEL BITS AND OUTPUT

BINWRD:
	LDB	%02,[POINT 8,%10,29]
	PUSHJ	%17,BINCHR
	LDB	%02,[POINT 6,%10,35]

BINCHR:
	TLNN	%16,BINBIT!NOPBIT
	TLNE	%15,P1F
	POPJ	%17,
	ADDM	%02,CHKSUM
	JRST	BINOUT


LEADER:
	MOVEI	%03,120
	MOVEI	%02,CHAN8_-6
	PUSHJ	%17,BINOUT
	SOJG	%03,.-1
	POPJ	%17,


LINPNT:	POINT	7,LINBUF,
;	SYMBOL TABLE ROUTINES

SYTI:				;INITIALIZE THE SYMBOL TABLE
	MOVE	%06,CORTOP	;GET TOP OF CORE
	MOVEM	%06,SYTTOP	;SAVE TOP LOCATION
	SUBI	%06,4		;COMPUTE INITIAL BOTTOM
	MOVEM	%06,SYTBOT	;STORE IT
	MOVEI	%00,2		;INITIALIZE WITH TWO DUMMY SYMBOLS
	MOVEM	%00,0(%06)
	MOVSI	%00, (1B0)
	MOVEM	%00,1(%06)	;SET LOW BUMPER
	SETZM	    2(%06)
	SETCAM	%00,3(%06)	;SET HIGH BUMPER
	SETZM	    4(%06)
	PUSHJ	%17,SRCHI	;INITIALIZE THE SEARCH ROUTINES
SYTI1:	MOVE	%00,BSYMT(%02)	;GET MNEMONIC
	AOBJN	%02,.+1
	MOVE	%01,BSYMT(%02)	;GET VALUE
	LSH	%01,0(%12)	;SHIFT MODE BIT INTO POSITION
	JUMPGE	%01,SYTI2	;BRANCH IF NOT SET
	MOVE	%01,BSYMT(%02)	;GET VALUE
	TLZ	%01,777000	;MASK OUT BITS
	PUSHJ	%17,SRCH	;SEARCH THE SYMBOL TABLE
	 PUSHJ	%17,INSRT	;INSERT MNEMONIC AND VALUE
SYTI2:	AOBJN	%02,SYTI1	;TEST FOR END
	POPJ	%17,		;EXIT
SRCH:				;SEARCH THE SYMBOL TABLE
	MOVE	%07,SRCHS	;GET STARTING ADDRESS
	MOVE	%06,SRCHD	;  AND DELTA

SRCH1:	CAMGE	%00,-1(%07)	;ON OR ABOVE?
	JRST	SRCH2		;  NO, MOVE DOWN
	CAMG	%00,-1(%07)	;ABOVE?
	JRST	SRCH3		;  NO, POINTING TO IT
	ADD	%07,%06		;  YES, MOVE UP
	CAIA
SRCH2:	SUB	%07,%06
	ASH	%06,-1		;HALVE DELTA
	CAMG	%07,SYTTOP	;WITHIN BOUNDS?
	JUMPN	%06,SRCH1	;  YES, RECYCLE IF NOT DONE
	JUMPN	%06,SRCH2	;  NO, MOVE DOWN IF NOT THROUGH
	SOJA	%07,CPOPJ	;NOT FOUND, EXIT

SRCH3:	MOVE	%01,0(%07)	;FOUND, FETCH VALUE
	AOS	0(%17)		;SKIP-RETURN
	POPJ	%17,0		;RETURN
INSRT:				;INSERT IN SYMBOL TABLE
	CAMN	%00,-1(%07)	;ALREADY IN TABLE?
	JRST	UPDATE		;  YES, JUST REPLACE VALUE
INSRT1:	MOVE	%06,SYTBOT	;  NO, GET BOTTOM OF TABLE
	SUBI	%06,2		;PREPARE TO MOVE DOWN TWO LOCATIONS
	CAMLE	%06,MACTOP	;HAVE WE ROOM?
	JRST	INSRT2		;  YES
	PUSHJ	%17,GETCOR	;  NO, GET AND MOVE CORE
	ADDI	%07,CORINC
	JRST	INSRT1		;TRY AGAIN

INSRT2:	MOVEM	%06,SYTBOT	;SET NEW BOTTOM
	HRLI	%06,2(%06)	;COMPUTE BLT
	BLT	%06,-2(%07)
	AOS	@SYTBOT		;INCREMENT SYMBOL COUNT
	MOVEM	%00,-1(%07)	;STORE VALUE
UPDATE:	MOVEM	%01, 0(%07)	;STORE MNEMONIC
	JRST	SRCHI		;RE-COMPUTE OFFSET


GETCOR:				;GET MORE CORE
	PUSH	%17,%00		;SAVE REGS
	PUSH	%17,%01
	HRRO	%01,.JBREL	;GET CURRENT TOP
	PUSHJ	%17,PANIC	;ASK EXEC FOR MORE CORE
	MOVN	%00,SYTBOT	;GET -BOTTOM
	ADDI	%00,1(%01)	;COMPUTE DIFFERENCE +1
	POP	%01,CORINC(%01)	;POP UP
	SOJG	%00,.-1		;TEST FOR END
	MOVEI	%01,CORINC
	ADDM	%01,SYTBOT	;UPDATE POINTERS
	ADDM	%01,.JBSYM
	ADDM	%01,SYTTOP
	PUSHJ	%17,SRCHI	;UPDATE SEARCH OFFSET
	POP	%17,%01
	POP	%17,%00
	POPJ	%17,		;EXIT
RESYM:				;REMOVE A SYMBOL FROM THE TABLE
	SUBI	%07,2
RESYM1:	MOVE	%06,0(%07)	;GET MNEMONIC VALUE
	MOVEM	%06,2(%07)	;MOVE UP TWO SLOTS
	CAME	%07,SYTBOT	;END?
	SOJA	%07,RESYM1	;  NO
	ADDI	%07,2		;  YES, COMPUTE NEW BOTTOM
	MOVEM	%07,SYTBOT
	SOS	@SYTBOT		;REDUCE SYMBOL COUNT
	JRST	SRCHI		;COMPUTE NEW OFFSET AND EXIT
SRCHI:				;INITIALIZE THE SYMBOL TABLE OFFSET
	SETZ	%06,
	FAD	%06,@SYTBOT	;COMPUTE BINARY POWER
	LSH	%06,-33		;RIGHT-JUSTIFY
	MOVEI	%03,1_11	;SET A BIT
	LSH	%03,-<400-<33-11>+1>(%06)	;MOVE IT INTO POSITION
	MOVEM	%03,SRCHD	;SAVE AS DELTA
	ASH	%03,1		;MULTIPLY BY TWO
	ADD	%03,SYTBOT	;COMPUTE HALF-WAY MARK
	MOVEM	%03,SRCHS
	POPJ	%17,
SYMTB:				;LIST THE SYMBOL TABLE
	MOVE	%07,SYTBOT	;GET START OF SYMBOL TABLE
	ADDI	%07,2		;MOVE PAST GARBAGE

SYMTB1:	TRO	%16,HDRBIT	;FLAG NEW PAGE
	MOVEI	%03,PAGSIZ-2	;SET LINE COUNT

SYMTB2:	SKIPL	-1(%07)		;END REACHED?
	POPJ	%17,		;  YES, EXIT
	MOVE	%06,%07		;SAVE CURRENT POINTER
	MOVEI	%04,SPL		;SET "SYMBOLS PER LINE"
	TLNE	%16,TTYBIT	;TTY?
	MOVEI	%04,SPLTTY	;  YES, REDUCE
	SETZ	%05,

SYMTB3:	PUSHJ	%17,GETSTE	;GET THE NEXT SYMBOL TABLE ENTRY
	 JRST	SYMTB4		;FINIS
	SOJG	%05,SYMTB3	;TEST FOR ITEMS TO SKIP
	PUSHJ	%17,LSTSTE	;LIST SYMBOL TABLE ENTRY
	MOVEI	%05,PAGSIZ-2
	SOJG	%04,SYMTB3	;TEST FOR MORE ITEMS ON LINE

SYMTB4:	PUSHJ	%17,LSTCR	;END OF LINE, LIST CR/LF
	SOJLE	%03,SYMTB1	;BRANCH IF END OF PAGE
	MOVE	%07,%06		;RETRIEVE POINTER
	PUSHJ	%17,GETSTE	;MOVE ONE PAST
	 POPJ	%17,		;END, EXIT
	JRST	SYMTB2		;OK, PROCESS ANOTHER
GETSTE:				;GET SYMBOL TABLE ENTRY
	ADDI	%07,2		;MOVE UP TWO
	SKIPL	-1(%07)		;TEST FOR END
	POPJ	%17,		;  YES, EXIT
	LDB	%02,[POINT 9,0(%07),17]	;GET SYMBOL TYPE
	JUMPN	%02,GETSTE	;BYPASS IF OP
	AOS	0(%17)		;OK, PERFORM SKIP-RETURN
	POPJ	%17,

LSTSTE:				;LIST SYMBOL TABLE ENTRY
	PUSHJ	%17,LSTTAB	;LEAD OFF WITH TAB
	HRLOI	%01,(POINT 6,0(%07),)	;SIXBIT POINTER TO SYMBOL
LSTST1:	ILDB	%02,%01		;GET A CHARACTER
	JUMPE	%02,LSTST2	;DON'T LIST TRAILING BLANKS
	ADDI	%02,40		;CONVERT TO ASCII
	PUSHJ	%17,LSTOUT	;LIST CHARACTER
	TLNE	%01,770000	;ANY MORE CHARACTERS?
	JRST	LSTST1		;  YES
LSTST2:	PUSHJ	%17,LSTTAB
	MOVSI	%01,(POINT 3,0(%07),23)	;SET OCTAL POINTER
LSTST3:	ILDB	%02,%01		;GET OCTAL CHARACTER
	ADDI	%02,"0"		;CONVERT TO ASCII
	PUSHJ	%17,LSTOUT	;LIST IT
	TLNE	%01,770000	;ANY MORE BYTES?
	JRST	LSTST3		;  YES
	JRST	LSTTAB		;OUTPUT A TAB AND EXIT
BITDMP:				;DUMP THE BIT TABLE
	TLZE	%15,CODFLG	;NO CODE STORED?
	TLNE	%16,XSWBIT!LSTBIT	;BIT MAP LISTING SUPPRESSED?
	JRST	BITDM4		;  YES, JUST INITIALIZE
	SETZ	%10,
BITDM1:	TRNN	%10,3777
	TRO	%16,HDRBIT
	TRNN	%10,0777
	PUSHJ	%17,LSTCR
	TRNN	%10,0177
	PUSHJ	%17,LSTCR
	TRNE	%10,0077
	JRST	BITDM2
	PUSHJ	%17,LSTCR
	MOVEI	%01,LSTOUT
	PUSHJ	%17,LSTOCT
BITDM2:	LDB	%02,[POINT 5,%10,28]
	SKIPN	PAGBUF(%02)	;ANY CODE ON THIS PAGE?
	JRST	BITDM3		;  NO, DON'T LIST
	MOVEI	%02,SPACE
	TRNN	%10,0007
	PUSHJ	%17,LSTOUT
	TRNN	%10,0007
	PUSHJ	%17,LSTOUT
	MOVE	%01,%10
	IDIVI	%01,^D36
	MOVE	%01,BITBUF(%01)
	ROT	%01,0(%02)
	MOVEI	%02,"0"
	TLNE	%01,(1B0)
	MOVEI	%02,"1"
	PUSHJ	%17,LSTOUT
BITDM3:	CAIGE	%10,7777
	AOJA	%10,BITDM1
	TRO	%16,HDRBIT
BITDM4:	SETZM	BITBUF
	MOVE	%01,[XWD BITBUF,BITBUF+1]
	BLT	%01,BITEND	;ZERO BIT MAP STORAGE AREA
	POPJ	%17,
CRFOUT:				;OUTPUT WORD TO CREF
	PUSHJ	%17,CREFQ	;CREF WANTED?
	POPJ	%17,		;NO  EXIT
	LDB	%02,[POINT 9,%01,17]	;GET SYMBOL TYPE BITS
	XCT	CRFTBL(%02)	;GET PROPER FLAG
CRFOU0:	PUSHJ	%17,LISTCQ	;LIST IT
	MOVEI	%03,6		;HAVE TO COUNT THE CHARACTERS
	MOVEI	%02,0		;NONE SO FAR
	TRNE	%00,77		;CHARACTER HERE?
	ADDI	%02,1		;YES. COUNT IT
	ROT	%00,6		;CHECK ANOTHER CH
	SOJG	%03,.-3		;COUNT 6 CHARS
	PUSHJ	%17,LSTDMP	;OUTPUT THE COUNT FROM AC2
	MOVSI	%03,(POINT 6,%00,)
CRFOU1:	ILDB	%02,%03		;GET A SIXBIT CHARACTER
	JUMPE	%02,CRFOU2	;BRANCH IF END
	ADDI	%02,40		;CONVERT TO ASCII
	PUSHJ	%17,LSTDMP	;LIST IT
	TLNE	%03,770000	;END OF WORD?
	JRST	CRFOU1		;  NO, GET ANOTHER
CRFOU2:	POPJ	%17,0		;EXIT

CRFTBL:				;CREF TABLE
	PHASE	0
	MOVEI	%02,CRFSYM
PSOP:	MOVEI	%02,CRFOPC
MROP:	MOVEI	%02,CRFOPC
MCOP:	MOVEI	%02,CRFOPC
MAOP:	MOVEI	%02,CRFMAC
	DEPHASE

LISTCQ:	PUSHJ	%17,CREFQ	;CREF WANTED NOW?
	POPJ	%17,0		;NO. RETURN
	PUSH	%17,%02		;SAVE CHARACTER
	TLON	%15,CSYBIT	;BLOCK BEGUN?
	PUSHJ	%17,CRFBGN	;NO. START IT
	POP	%17,%02		;RETRIEVE CHARACTER
	JRST	LSTDMP		;TYPE CHAR AND RETURN
BSYMT:				;BASIC SYMBOL TABLE

				;PSEUDO-OPERATORS

SIXBIT	/ZBLOCK/
		<SBX!            SBS> + <PSOP>B17 + ZBLOCK

SIXBIT	/DECIMA/
		<SBX!SB3!SB8!SBD!SBS> + <PSOP>B17 + DECIMA

SIXBIT	/DEFINE/
		<SBX!    SB8        > + <PSOP>B17 + DEFINE

SIXBIT	/DTORG/
		<SBX                > + <PSOP>B17 + DTORG

SIXBIT	/DUBL/
		<SBX!    SB8        > + <PSOP>B17 + DUBL

SIXBIT	/ENPUNC/
		<SBX!            SBS> + <PSOP>B17 + ENPUNC

SIXBIT	/EXPUNG/
		<SBX!SB3!SB8!SBD!SBS> + <PSOP>B17 + EXPUNG

SIXBIT	/FIELD/
		<SBX!SB3!SB8!SBD!SBS> + <PSOP>B17 + FIELD

SIXBIT	/FIXMRI/
		<SBX!SB3            > + <PSOP>B17 + FIXMRI

SIXBIT	/FIXTAB/
		<SBX!SB3!SB8!SBD!SBS> + <PSOP>B17 + FIXTAB

SIXBIT	/FLTG/
		<SBX!    SB8        > + <PSOP>B17 + FLTG

SIXBIT	/IFDEF/
		<SBX!            SBS> + <PSOP>B17 + IFDEF

SIXBIT	/IFNDEF/
		<SBX!            SBS> + <PSOP>B17 + IFNDEF

SIXBIT	/IFNZRO/
		<SBX!            SBS> + <PSOP>B17 + IFNZRO

SIXBIT	/IFZERO/
		<SBX!            SBS> + <PSOP>B17 + IFZERO

SIXBIT	/NOPUNC/
		<SBX!            SBS> + <PSOP>B17 + NOPUNC

SIXBIT	/OCTAL/
		<SBX!SB3!SB8!SBD!SBS> + <PSOP>B17 + OCTAL

SIXBIT	/PAGE/
		<SBX!    SB8!SBD!SBS> + <PSOP>B17 + PAGE

SIXBIT	/PAUSE/
		<SBX!SB3!    SBD!SBS> + <PSOP>B17 + CPOPJ

SIXBIT	/TEXT/
		<SBX!    SB8!SBD!SBS> + <PSOP>B17 + TEXT

SIXBIT	/XLIST/
		<SBX!        SBD!SBS> + <PSOP>B17 + XLIST
				;MEMORY REFERENCE INSTRUCTIONS

SIXBIT	/AND/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 0000

SIXBIT	/TAD/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 1000

SIXBIT	/ISZ/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 2000

SIXBIT	/DCA/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 3000

SIXBIT	/JMS/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 4000

SIXBIT	/JMP/
		<SBX!SB3!SB8!SBD!SBS> + <MROP>B17 + 5000


EEXOPS:
				;GROUP 1 OPERATE MICROINSTRUCTIONS

SIXBIT	/OPR/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7000

SIXBIT	/NOP/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7000

SIXBIT	/IAC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7001

SIXBIT	/RAL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7004

SIXBIT	/RTL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7006

SIXBIT	/RAR/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7010

SIXBIT	/RTR/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7012

SIXBIT	/CML/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7020

SIXBIT	/CMA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7040

SIXBIT	/CLL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7100

SIXBIT	/CLA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7200
				;GROUP 2 OPERATE MICROINSTRUCTIONS

SIXBIT	/HLT/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7402

SIXBIT	/OSR/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7404

SIXBIT	/SKP/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7410

SIXBIT	/SNL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7420

SIXBIT	/SZL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7430

SIXBIT	/SZA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7440

SIXBIT	/SNA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7450

SIXBIT	/SMA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7500

SIXBIT	/SPA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7510
				;COMBINED OPERATE MICROINSTRUCTIONS


SIXBIT	/CIA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7041

SIXBIT	/STL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7120

SIXBIT	/GLK/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7204

SIXBIT	/STA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7240

SIXBIT	/LAS/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 7604
				;IOT MICROINSTRUCTIONS

;PROCESSOR IOTS

SIXBIT	/IOT/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6000

SIXBIT	/ION/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6001

SIXBIT	/IOF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6002


;KEYBOARD/READER

SIXBIT	/KSF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6031

SIXBIT	/KCC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6032

SIXBIT	/KRS/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6034

SIXBIT	/KRB/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6036


;TELEPRINTER/PUNCH

SIXBIT	/TSF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6041

SIXBIT	/TCF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6042

SIXBIT	/TPC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6044

SIXBIT	/TLS/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6046
;HIGH-SPEED READER (TYPE PC02)

SIXBIT	/RSF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6011

SIXBIT	/RRB/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6012

SIXBIT	/RFC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6014


;HIGH-SPEED PUNCH (TYPE PC03)

SIXBIT	/PSF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6021

SIXBIT	/PCF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6022

SIXBIT	/PPC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6024

SIXBIT	/PLS/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6026
;DISK FILE AND CONTROL (TYPE DF32)

SIXBIT	/DCMA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6601

SIXBIT	/DMAR/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6603

SIXBIT	/DMAW/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6605

SIXBIT	/DCEA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6611

SIXBIT	/DSAC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6612

SIXBIT	/DEAL/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6615

SIXBIT	/DEAC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6616

SIXBIT	/DFSE/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6621

SIXBIT	/DFSC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6622

SIXBIT	/DMAC/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6626
;DECTAPE TRANSPORT (TYPE TU55) AND CONTROL (TYPE TC01)

SIXBIT	/DTRA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6761

SIXBIT	/DTCA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6762

SIXBIT	/DTXA/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6764

SIXBIT	/DTSF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6771

SIXBIT	/DTRB/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6772

SIXBIT	/DTLB/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6774


;MEMORY EXTENSION CONTROL (TYPE 183)


SIXBIT	/CDF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6201

SIXBIT	/CIF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6202

SIXBIT	/RDF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6214

SIXBIT	/RIF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6224

SIXBIT	/RMF/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6244

SIXBIT	/RIB/
		<SBX!SB3!SB8!SBD!SBS> + <MCOP>B17 + 6234
;PALX CODES


SIXBIT	/MMLS/
		<SBX                    > + <MCOP>B17 + 6751

SIXBIT	/MMLM/
		<SBX                    > + <MCOP>B17 + 6752

SIXBIT	/MMLF/
		<SBX                    > + <MCOP>B17 + 6754

SIXBIT	/MMMF/
		<SBX                    > + <MCOP>B17 + 6756

SIXBIT	/MMMM/
		<SBX                    > + <MCOP>B17 + 6757

SIXBIT	/MMSF/
		<SBX                    > + <MCOP>B17 + 6761

SIXBIT	/MMCC/
		<SBX                    > + <MCOP>B17 + 6762

SIXBIT	/MMML/
		<SBX                    > + <MCOP>B17 + 6766

SIXBIT	/MMSC/
		<SBX                    > + <MCOP>B17 + 6771

SIXBIT	/MMCF/
		<SBX                    > + <MCOP>B17 + 6772

SIXBIT	/MMRS/
		<SBX                    > + <MCOP>B17 + 6774


SIXBIT	/SKPNA/
		<SBX                    > + <MCOP>B17 + 6311

SIXBIT	/RSC/
		<SBX                    > + <MCOP>B17 + 6312

SIXBIT	/PSC/
		<SBX                    > + <MCOP>B17 + 6314



EBSYMT:				;END OF BASIC SYMBOL TABLE
CNVTBL:				;MODE CONVERSION TABLE
	POINT	4,0(%02),3
	POINT	4,0(%02),7
	POINT	4,0(%02),11
	POINT	4,0(%02),15
	POINT	4,0(%02),19
	POINT	4,0(%02),23


C1PNTR:	POINT	4,CHJTBL(%14), 3
C2PNTR:	POINT	4,CHJTBL(%14), 7
C3PNTR:	POINT	4,CHJTBL(%14),11
C4PNTR:	POINT	4,CHJTBL(%14),15
C5PNTR:	POINT	4,CHJTBL(%14),19
C6PNTR:	POINT	4,CHJTBL(%14),23
C7PNTR:	POINT	4,CHJTBL(%14),27
C8PNTR:	POINT	4,CHJTBL(%14),31
C9PNTR:	POINT	4,CHJTBL(%14),35

ANPNTR=	C8PNTR
CHJTBL:				;CHARACTER JUMP TABLE

BYTE	(4)	LNCR,    ,    ,    ,    ,    ,QJNU,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	LNSP,STSP,    ,EXSP,MRSP,TJSP,QJTB,.TAB,LTSP	; TAB
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	; LF
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	; FF
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJCR,    ,    	; CR
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	; EOF
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	LNSP,STSP,    ,EXSP,MRSP,TJSP,QJSP,.TAB,LTSP	; SPACE
BYTE	(4)	    ,    ,    ,EXOR,    ,    ,QJPC,    ,    	; !
BYTE	(4)	    ,    ,    ,EXTE,    ,TJQT,QJPC,    ,    	; "
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; #
BYTE	(4)	LNDO,    ,    ,    ,    ,    ,QJPC,    ,    	; $
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; %
BYTE	(4)	    ,    ,    ,EXAN,    ,    ,QJPC,    ,    	; &
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; '

BYTE	(4)	    ,    ,    ,EXTE,    ,TJLP,QJPC,    ,    	; (
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,LTRP	; )
BYTE	(4)	    ,STAS,    ,    ,    ,    ,QJPC,    ,    	; *
BYTE	(4)	    ,    ,    ,EXPL,    ,TJUO,QJPC,    ,    	; +
BYTE	(4)	    ,    ,SACM,    ,    ,    ,QJPC,    ,    	; ,
BYTE	(4)	    ,    ,    ,EXMI,    ,TJUO,QJPC,    ,    	; -
BYTE	(4)	    ,    ,    ,EXTE,    ,TJPE,QJPC,    ,    	; .
BYTE	(4)	LNCR,    ,    ,    ,    ,    ,QJPC,    ,    	; /

BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 0
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 1
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 2
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 3
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 4
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 5
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 6
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 7

BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 8
BYTE	(4)	    ,    ,    ,EXTE,    ,TJNM,QJPC,.NUM,    	; 9
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; :
BYTE	(4)	LNSC,STSC,    ,    ,    ,    ,QJPC,    ,    	; ;
BYTE	(4)	LNLA,STLA,    ,    ,    ,    ,QJPC,    ,    	; <
BYTE	(4)	    ,    ,SAEQ,    ,    ,    ,QJPC,    ,    	; =
BYTE	(4)	LNRA,    ,    ,    ,    ,    ,QJPC,    ,    	; >
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ?
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; @
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; A
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; B
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; C
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; D
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; E
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; F
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; G

BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; H
BYTE	(4)	    ,STAL,    ,EXTE,MRCI,TJAL,QJPC,.ALP,    	; I
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; J
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; K
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; L
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; M
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; N
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; O

BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; P
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; Q
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; R
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; S
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; T
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; U
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; V
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; W

BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; X
BYTE	(4)	    ,STAL,    ,EXTE,    ,TJAL,QJPC,.ALP,    	; Y
BYTE	(4)	    ,STAL,    ,EXTE,MRCZ,TJAL,QJPC,.ALP,    	; Z
BYTE	(4)	    ,    ,    ,    ,    ,TJLB,QJPC,    ,    	; [
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; \
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,LTRB	; ]
BYTE	(4)	    ,    ,    ,EXMU,    ,    ,QJPC,    ,    	; ^
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; _
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	;
XX SYTTOP,1,POINTER TO TOP OF SYMBOL TABLE
XX SYTBOT,1,POINTER TO BOTTOM OF SYMBOL TABLE

XX SRCHD,1,SEARCH DELTA
XX SRCHS,1,SEARCH HALF-WAY POINT

XX RADIX,1
XX VALUE,1
XX EQUIV,1
XX CHKSUM,1
XX LVLCNT,1,CONDITIONAL LEVEL COUNT

XX MACPNT,1
XX MACTMP,1
XX MACPDP,1
XX ARGPNT,1
XX ARGTMP,1

XX MACTOP,1

XX DBLPNT,1
XX DBLSAV,1

XX TXTEND,1,USED BY "TEXT" PSEUDO-OP

XX RUNTIM,1,RUN TIME

XX LINBUF,CPL/5+1,SOURCE LINE BUFFER

XX TTLBUF,TTLLEN/5,TITLE BUFFER
XX TTLEND,1

XX CLTBUF,200,CURRENT LITERAL BUFFER

XX ZLTBUF,200,PAGE ZERO LITERAL BUFFER

XX CLHBUF,40,CURRENT LITERAL HEADER BUFFER
XX SEQNUM,1

XX PDPBUF,PDPLEN

XX AC00,1,AC EXCHANGE BLOCK
XX AC01,1
XX AC02,1
XX AC03,1
XX AC04,1
XX AC05,1
XX AC06,1
XX AC07,1
XX AC10,1
XX AC11,1
XX AC12,1
XX AC13,1
XX AC14,1

XX DATE,1
XX MSTIME,1
XX PAGNUM,1,PAGE NUMBER
XX PAGEXT,1,PAGE EXTENSION
XX ERRCNT,1,ERROR COUNT
XX LINKS,1, LINKS GENERATED
XX EXTSAV,1,FILNAM EXTENSION FOR HEADER (EXEC)
XX MODSW,1
XX JOBFFI,1,.JBFF SAVE
XX TTISAV,1,TTI POINTER SAVE
XX INBCNT,1
XX XESAVE,1

XX XE,1,EXEC LOOKUP BLOCK
XX XE1,1
XX XE2,1
XX XE3,1

XX TTIBUF,1
XX TTIPNT,1
XX TTICNT,1

XX TTOBUF,1
XX TTOPNT,1
XX TTOCNT,1

XX BINBUF,1
XX BINPNT,1
XX BINCNT,1

XX LSTBUF,1
XX LSTPNT,1
XX LSTCNT,1

XX SRCBUF,1
XX SRCPNT,1
XX SRCCNT,1

XX LINCNT,1,EXEC LINE COUNTER

XX CORTOP,1,CORE TOP
XX CORBOT,1,CORE BOTTOM

XX BITBUF,10000/^D36+1,BIT MAP BUFFER
XX PAGBUF,^D32,PAGE BUFFER FOR BIT MAP

XX LITLVL,1,LIT LEVEL COUNT
	BITEND=LITLVL-1
	ZBLTMP=TXTEND
	BZCOR=SYTTOP
	EZCOR=LITLVL+1
	XLIST ;DONT LIST LITERALS
LIT
	LIST  ;JUST LITERALS ABOVE
	END	PAL		;....PAL
