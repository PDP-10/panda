(FILECREATED "23-Sep-82 12:13:07" <KS.SOURCES>TTYIN..23 747424Q

     changes to:  CAPABILITY?

     previous date: "17-Sep-82 18:39:10" <KS.SOURCES>TTYIN..22)


(* Copyright (c) 1982 Teknowledge, Inc.)

(PRETTYCOMPRINT TTYINCOMS)

(RPAQQ TTYINCOMS [(E (RESETSAVE (RADIX 10Q)))
		  (FNS * TTYINFNS)
		  (FNS * TTDISPLAYFNS)
		  (COMS (* Support functions. These are all macros or for debugging)
			(FNS * TTSUPPORTFNS))
		  (COMS (* Auxiliary fns. These are outside the TTYIN block, and are provided to aid 
			   the outside world in special interfaces to TTYIN)
			(FNS * TTEXTRAFNS))
		  (DECLARE: DOEVAL@COMPILE DONTCOPY (COMS * TTCOMPILETIME))
		  (VARS (TTYINBUFFER))
		  (INITVARS ?ACTIVATEFLG EDITPREFIXCHAR EMACSFLG SHOWPARENFLG TTYINBSFLG 
			    TTYINCOMPLETEFLG TTYINMAILFLG TTYINUSERFN TYPEAHEADFLG (null "")
			    (DEFAULTPROMPT "** ")
			    (TTYJUSTLENGTH 110Q)
			    (TTYPAGELENGTH 30Q))
		  (P (MOVD? 'NILL 'GUESTUSER?)
		     (MOVD? 'FIXSPELL 'FIXSPELL!!)
		     (MOVD? 'HELPSYS 'XHELPSYS)
		     (PUTDQ? SPRINTT [LAMBDA (X)
					     (PRIN1 X])
		     (ECHOCONTROL 10Q 'REAL))
		  (ADDVARS (TTYINREADMACROS)
			   (TTYINRESPONSES)
			   (DISPLAYTYPES)
			   (LISPXCOMS (STOP . OK))
			   (BREAKRESETFORMS (TTECHOMODE T))
			   (RESETFORMS (TTECHOMODE T)))
		  (COMS (* Heath stuff)
			(FNS TTHEATHKEYPAD TTCONCEPTKEYPAD SETKEYPAD ENABLE.CONCEPT.KEYPAD 
			     SETHEATHKEYPAD SETCONCEPTKEYPAD MODIFY.KEYPAD UNCHARCODE DUMPHEATHKEYPAD 
			     DUMPCONCEPTKEYPAD)
			(ARRAY HEATHKEYFUNCTIONS HEATH.SYMBOL.TO.CHAR CONCEPTPFUNCTIONS 
			       CONCEPTKFUNCTIONS CONCEPT.SYMBOL.TO.CHAR)
			(INITVARS USEHEATHKEYPAD USECONCEPTKEYPAD TTYINKEYPADPREFIX 
				  TTYINKEYPADPREFIX2)
			(VARS (TTYINBACKUP))
			(DECLARE: EVAL@COMPILE DONTCOPY (MACROS KEYPADPREFIXP)
				  (GLOBALVARS CONCEPTPFUNCTIONS CONCEPTKFUNCTIONS HEATHKEYFUNCTIONS 
					      HEATH.SYMBOL.TO.CHAR CONCEPT.SYMBOL.TO.CHAR 
					      USEHEATHKEYPAD USECONCEPTKEYPAD TTYINKEYPADPREFIX 
					      TTYINKEYPADPREFIX2)))
		  (ALISTS (BAKTRACELST USEREXEC *PROG*LAM))
		  (LISPXMACROS TV BUF)
		  (USERMACROS ED BUF)
		  (ADVISE LISPXFIX)
		  (PROP VARTYPE TTYINREADMACROS)
		  [DECLARE: DONTEVAL@LOAD (P (CHANGENAME 'LISPXREADP 'PEEKC 'TTYINPEEKC)
					     (CHANGENAME 'READLINE 'PEEKC 'TTYINPEEKC)
					     (CHANGENAME 'LISPXBLOCK 'PEEKC 'TTYINPEEKC)
					     (AND (GETD 'COMPSETREAD)
						  (CHANGENAME 'COMPSETREAD 'PEEKC 'TTYINPEEKC))
					     (CHANGENAME 'EDITBLOCK 'LISPXREADP 'TTYINREADP)
					     (SETREADFN))
			    [VARS (PROMPTCHARFORMS (/NCONC1 PROMPTCHARFORMS '(TTYINREADPREP]
			    (ADDVARS (AFTERSYSOUTFORMS (SETREADFN]
		  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
			    (ADDVARS (NLAMA TTBOUT TTBOUTN)
				     (NLAML CHARMACRO? TTED !SETQ ! CAPABILITY?)
				     (LAMA])

(RPAQQ TTYINFNS (TTYIN ADDCHAR ADDCHARS.INSERTING ADDNAKEDCHAR ADDSILENTCHAR ADDTAB ADJUSTLINE 
		       ADJUSTLINE.AND.RESTORE AT.END.OF.SCREEN AT.END.OF.TEXT AUTOCR? 
		       BACKWARD.DELETE.TO BACKSKREAD BINARY.MODE BREAKLINE BUFLEN BUFTAILP 
		       CHECK.MARGIN CLEAR.LINE? COMPLETEWORD CREATE.LINE DELETE.TO.END DELETELINE 
		       DELETETO DELETETO1 DO.EXTEND.COMMAND DO?CMD DOTABS ECHOFILE EDITCHAR 
		       EDITCOLUMN ENDELETE ENDREAD? FIND.LINE FINDBREAK FINDMATCH FIRSTWORD FIXWORD 
		       FORWARD.DELETE.TO GIVEHELP GIVEHELP1 GIVEHELP2 GO.TO GO.TO.ADDRESSING 
		       GO.TO.FREELINE INIT.CURSOR INSERT.CHAR.IN.BUF INSERTCONS INSERTLINE KILL.LINES 
		       KILLSEGMENT LASTLINE LOADBUF LOADBUFFROMFILE MODE.CHANGE? MOVE.BACK.TO 
		       MOVE.FORWARD.TO MOVE.TO.LINE MOVE.TO.NEXT.LINE MOVE.TO.START.OF.WORD 
		       MOVE.TO.WHEREVER NEWLINE NEXTCHAR NEXTCONS NEXTLINE NEXTQUOTE NEXTWORD 
		       NTH.COLUMN.OF NTH.RELATIVE.COLUMN.OF NTHCHARCODE OVERFLOW? OVERFLOWLINE? 
		       PREVLINE PREVWORD PROPERTAILP READFROMBUF RENUMBER.LINES RESTORE.CURSOR 
		       RESTOREBUF RESTOREMOD RETYPE RUBOUT SAVE.CURSOR SCANBACK SCANFORWARD 
		       SCRATCHCONS SETLASTC SETTAIL? SHOW.MATCHING.PAREN SKIP/ZAP SLEEP SPACE/PARENP 
		       START.OF.PARAGRAPH? STRIPBLANKS TENEXCOMPLETE THISWORD TTBIN TTCRLF 
		       TTCRLF.ACCOUNT TTGETFILE TTNLEFT TTNTH TTPRIN1 TTPROMPTCHAR TTRATOM TTREAD 
		       TTREADLIST TTSKIPSEPR TTSKREAD TTYINSTRING TYPE.BUFFER U/L-CASE UNREADBUF))
(DEFINEQ

(TTYIN
  [LAMBDA (PROMPT SPLST HELP OPTIONS FILE TABS UNREADBUF)                       (* bvm: " 5-Jun-82 15:05")

          (* * TTYIN is a general input function. See TTYIN.DOC for details on the arguments
	  and use of this fn. TTYIN was designed and implemented by Bill van Melle at 
	  Stanford.)



          (* * Some implementation notes: The bulk of the code here is oriented toward smart
	  use on display terminals, specifically the datamedia. If on a dm, TTYIN puts the 
	  terminal in binary mode so it can read the 200q bit supplied by the EDIT key.
	  Most of the cursor-moving commands from TVEDIT are available or slightly modified,
	  and a few extra are supplied as well.)



          (* The text being typed in is represented as a list of character codes, with a 
	  data structure on top of it which partitions it by line. Thus, you can view the 
	  text as one string, or broken into lines, depending on the function desired.
	  BUFFER is the pointer to the start of the buffer, ENDBUFFER points one past the 
	  end. TTYIN saves up cons cells between calls and reuses them;
	  ENDBUFFER points to this list of free cells. TTYINBUFFER is the master record, 
	  which keeps assorted global information about where the cursor is, and saves some 
	  state info from one call to the next, enabling the restore previous buffer 
	  command. See BUFFIELDS for documentation of its fields; the fields are accessed by
	  the ! construct for efficiency. One of the fields points to the LINE records which
	  describe the two-dimensional structure of the input. Each record points to the 
	  region of the buffer containing the text for one line, and has fields indicating 
	  the first and last columns, and a pointer to the next line record.
	  ARROW always points to the current LINE record -
	  CURSOR points to where in the buffer the cursor appears. -
	  This representation is not terribly space-efficient for large buffers, but it is 
	  easily manipulated, and fast. If there is a particularly long input, there will be
	  many cons cells tied up in TTYINBUFFER, so a good thing to do when trying to free 
	  up space is reset TTYINBUFFER to NIL to force its regeneration from scratch.)


    (PROG (X VALUE BUFFER ENDBUFFER CURSOR ARROW DELETING INSERTING EDITBIT DONTCOMPLETE AUTOFILL NOVALUE NOFIXSPELL 
	     STRING REPEAT COMMAND READING LISPXREADING DIRECTORY/FILE LASTCHARACTER (RAISE T)
	     (INITPOS (POSITION T))
	     (FIRSTIME T)
	     (LISPXREADFN 'READ)
	     (OLDREADFN LISPXREADFN)
	     (TYPEAHEAD TYPEAHEADFLG))                                          (* Rebind LISPXREADFN so if a 
								      break happens while we're still 
								      here, it can't smash buffer)
          [COND
	    ((SETQ VALUE (OR (CAR NIL)
			     (CDR NIL)))
	      (PRIN2 (COND
		       ((CAR NIL)
			 'CAR)
		       (T 'CDR))
		     T)
	      (PRIN1 " of NIL was smashed with " T)
	      (PRINT (SETQ CAR/CDRNIL VALUE)
		     T)
	      (SETQ VALUE (FRPLNODE NIL NIL NIL]
          [OR (ARRAYP TTYINBUFFER)
	      (SETQ TTYINBUFFER (create TTYINBUFFER
					FIRSTLINE _(create LINE
							   START _(OR (LISTP TTYINBUFFER)
								      (CONS))
							   ROW _ 0]
          (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
          (!SETQ EDITABLE (CAPABILITY? EDIT))
          [!SETQ SPLST (SETQ SPLST (AND SPLST (OR (LISTP SPLST)
						  (CONS SPLST]
          (!SETQ HELP HELP)
          (!SETQ FIX (!SETQ SPLSTFLG NIL))
          (for OP inlist OPTIONS do (SELECTQ OP
					     ((NOFIXSPELL MUSTAPPROVE CRCOMPLETE)
					       (SETQ NOFIXSPELL (SETQ DONTCOMPLETE OP)))
					     (NOVALUE (SETQ NOVALUE OP))
					     (STRING (SETQ STRING OP))
					     (COMMAND (SETQ COMMAND OP))
					     (REPEAT (SETQ REPEAT OP))
					     (NORAISE (SETQ RAISE))
					     (TEXT (SETQ REPEAT (SETQ NOVALUE (SETQ AUTOFILL OP)))
						   (SETQ RAISE))
					     (FIX (!SETQ FIX OP))
					     (READ (SETQ READING (SETQ AUTOFILL OP)))
					     (LISPXREAD [SETQ TYPEAHEAD (SETQ LISPXREADING (SETQ READING (SETQ AUTOFILL 
								OP]
							(SETQ RAISE))
					     (EVALQT                            (* like LISPXREAD, but with 
								      added proviso about checking for
								      EVALQT right-bracket hacks)
						     [SETQ TYPEAHEAD (SETQ LISPXREADING (SETQ READING (SETQ AUTOFILL OP]
						     (SETQ RAISE))
					     ((FILE DIRECTORY USER)
					       (SETQ DIRECTORY/FILE OP))
					     (TYPEAHEAD (SETQ TYPEAHEAD OP))
					     NIL))
          [COND
	    ((EQ PROMPT T)
	      (!SETQ PROMPT1 (!SETQ PROMPT2)))
	    (T [COND
		 ((NOT PROMPT)
		   (SETQ PROMPT DEFAULTPROMPT))
		 [(LISTP PROMPT)
		   (COND
		     ((NLISTP (CDR PROMPT))                                     (* User has already supplied us 
								      with a dotted pair of prompts)
		       (!SETQ PROMPT1 (CAR PROMPT))
		       (!SETQ PROMPT2 (CDR PROMPT)))
		     (T (SETQ PROMPT (SUBSTRING PROMPT 2 -2]
		 ((AND (NOT (STRINGP PROMPT))
		       (NOT (LITATOM PROMPT)))
		   (SETQ PROMPT (MKSTRING PROMPT]
	       (COND
		 ((NLISTP PROMPT)                                               (* Now create 2 prompts out of 
								      one)
		   (!SETQ PROMPT1 PROMPT)
		   (!SETQ PROMPT2 (COND
			    ((AND LISPXREADING (LITATOM PROMPT))
			      NIL)
			    ((AND (OR REPEAT LISPXREADING)
				  (SLESSP (NCHARS PROMPT)
					  14Q))                                 (* Okay to use this short prompt
								      as a secondary prompt)
			      PROMPT)
			    (T '...]
          (COND
	    ((NOT SPLST)
	      (SETQ DONTCOMPLETE T)))
          (COND
	    (READING (SETQ REPEAT)))
          (COND
	    ((AND TTYINMAILFLG (NEQ READING 'EVALQT)
		  (SLESSP INITPOS 5))
	      (MAILWATCH)))
          (replace TTYMODE of TTYINBUFFER with (JS RFMOD 100Q NIL NIL 2))
          (COND
	    ((SGREATERP (SETQ X (@S (LOGAND (LRSH (fetch TTYMODE of TTYINBUFFER)
						  22Q)
					    177Q)))
			50Q)                                                    (* If length is reasonable, use 
								      it)
	      (SETQ TTYLINELENGTH X)))
          (COND
	    ((SGREATERP (SETQ X (@S (LOGAND (LRSH (fetch TTYMODE of TTYINBUFFER)
						  31Q)
					    177Q)))
			12Q)
	      (SETQ TTYPAGELENGTH X)))
          (COND
	    ((NOT TYPEAHEAD)
	      (JS CFIBF 100Q)))
      LP  [SETQ VALUE
	    (NLSETQ
	      (PROG (CHAR MATCHED RESULT STARTOFWORD WORD X TMP DRIBFL)
		    (!SETQ LASTAIL)
		RESTART
		    (BINARY.MODE FIRSTIME)                                      (* Set terminal in binary mode 
								      if it isn't already;
								      always do it on subsequent 
								      iterations, since it means an 
								      error happened)
		    [COND
		      ((AND FIRSTIME (EQ OLDREADFN 'TTYINREAD)
			    (EQ TYPEAHEADFLG 'ALWAYS)
			    DISPLAYTERMFLG)                                     (* Means we want to stay in 
								      funny mode; don't repeatedly 
								      enter and leave it.
								      This allows binary typeahead.)
			(replace TTYMODE of TTYINBUFFER with (LOGAND (fetch TTYMODE of TTYINBUFFER)
								     (XWD -1 777477Q)]
		PROMPT0
		    (SETQ ARROW (! FIRSTLINE))
		    [replace END of ARROW with (SETQ CURSOR (SETQ BUFFER (SETQ ENDBUFFER (fetch START of ARROW]
		    (COND
		      ((SETQ X (fetch NEXTLINE of ARROW))                       (* Return old line records to 
								      cons pool)
			(replace NEXTLINE of ARROW with NIL)
			(KILL.LINES X)))
		    (SETQ INSERTING (SETQ DELETING (SETQ RESULT NIL)))
		    (COND
		      (FIRSTIME (SETQ FIRSTIME))
		      (T                                                        (* Space over to where we 
								      started)
			 (TTBOUTN INITPOS SPACE)))
		PROMPT1
		    (INIT.CURSOR INITPOS)
		    (TTPROMPTCHAR ARROW)
		    (replace FIRSTCOL of ARROW with (replace LASTCOL of ARROW with (! CURSORCOL)))
		    [COND
		      ([OR (NLISTP TABS)
			   (NOT (SMALLP (CAR TABS]
			(SETQ TABS))
		      ((NOT (SGREATERP (SSUB1 (CAR TABS))
				       (! CURSORCOL)))                          (* Caller specified first 
								      tabstop as the position of the 
								      first char; we don't treat that 
								      as a tabstop, so peel it off)
			(SETQ TABS (CDR TABS]
		    [COND
		      (UNREADBUF                                                (* something to preload buffer 
								      with)
				 (COND
				   ((FIXP UNREADBUF)
				     (SETQ CHAR UNREADBUF)                      (* interpret number as character
								      code of something to type ahead,
								      usually altmode)
				     (SETQ UNREADBUF NIL)
				     (GO SELECTCHAR))
				   (T (LOADBUF (PROG1 UNREADBUF (SETQ UNREADBUF NIL]
		CHAR(AND CHAR (!SETQ LASTCHAR CHAR))
		    (SETQ CHAR (TTBIN))
		SELECTCHAR
		    [COND
		      ((AND (NOT EDITBIT)
			    (NOT (! EDITABLE)))
			(SETQ EDITBIT (COND
			    ((EQ CHAR EDITPREFIXCHAR)                           (* This is how to do Escape 
								      prefix on non-edit terminals)
			      (SETQ CHAR (TTBIN))
			      T]
		    [COND
		      ([AND (SETQ X (FASSOC (COND
					      (EDITBIT (SLOGOR CHAR 200Q))
					      (T CHAR))
					    TTYINREADMACROS))
			    (OR [NLISTP (SETQ X (CDR (SETQ TMP X]
				(AND (COND
				       ((EQ (CAR X)
					    T)
					 (EMPTY.BUFFER))
				       ((LISTP (CAR X))
					 (EVAL (CAR X)))
				       (T                                       (* Old style macros that worked 
								      only at start of buffer)
					  (SETQ X TMP)
					  (EMPTY.BUFFER)))
				     (OR (NLISTP (SETQ X (CDR X)))
					 (SETQ X (EVAL X]

          (* Simple read macros: if you type the char on a blank line, and the macro returns
	  something, use it as the value of the READ (or whatever))


			(COND
			  [(FIXP X)                                             (* Special: means pretend this CHARACTER
										code was typed)
			    (SELECTQ X
				     (0                                         (* No action)
					(GO CHAR))
				     (-1                                        (* Means refresh line, `cause 
								      terminal control was taken away)
					 (GO PROMPT1))
				     (PROGN [COND
					      ((ZEROP (SETQ CHAR (SLOGAND X 177Q)))
                                                                                (* another way to get edit 
								      prefix)
						(SETQ CHAR (TTBIN]
					    (SETQ EDITBIT (NOT (ZEROP (SLOGAND X 200Q]
			  ((EMPTY.BUFFER)                                       (* For now I'm not handling 
								      funnyu results in the middle)
			    (SETQ RESULT (OR (LISTP X)
					     (LIST X)))
			    (GO DOCRLF]
		    (COND
		      (EDITBIT (SETQ INSERTING)                                 (* Edit bit on any command stops
								      insert mode)
			       (COND
				 ((NOT (SETQ CHAR (EDITCHAR CHAR)))
				   (GO CHAR)))                                  (* Fall thru if edit char gave 
								      us something to chomp on)
			       ))
		    [SELECTQ CHAR
			     [(1 177Q 10Q)                                      (* ^A or DELETE or backspace)
			       (COND
				 ((AT.START.OF.BUF)
				   (BEEP))
				 [(AT.END.OF.LINE)
				   (COND
				     [(AT.START.OF.LINE)                        (* empty line: need to delete to
								      previous line)
				       (PROG [(DODELETE (OVERFLOWLINE? (SETQ X (PREVLINE ARROW 1]
					     (DELETELINE ARROW)                 (* get rid of this line)
					     (MOVE.TO.LINE X (fetch END of X))
                                                                                (* go to end of previous line)
					     (COND
					       (DODELETE                        (* We were on overflow line, so 
								      have to delete the last char, 
								      too)
							 (DELETETO (TTNLEFT CURSOR 1)))
					       ((NOT (CAPABILITY? MOVEMENT))
						 (RETYPE ARROW]
				     (T (DELETETO (TTNLEFT CURSOR 1]
				 ((INSERTING)
				   (RUBOUT))
				 (T                                             (* DELETE inside line is like 
								      <edit>DELETE.)
				    (EDITCHAR 177Q]
			     [(21Q 30Q 25Q)                                     (* ^Q or ^X delete line;
										^U on tops20)
			       (COND
				 ((EMPTY.BUFFER)
				   (BEEP))
				 [(EMPTY.LINE)                                  (* Empty line: delete previous 
								      line if at end)
				   (COND
				     ((AT.END.OF.BUF)
				       (MOVE.TO.LINE (PREVLINE ARROW 1))
				       (COND
					 ((NOT DISPLAYTERMFLG)
					   (TTBOUT _ CR LF)))
				       (DELETE.TO.END))
				     (T (BEEP]
				 (T (SETQ INSERTING)
				    (SETTAIL? T)
				    (COND
				      ((NOT DISPLAYTERMFLG)
					(TTBOUT # #)                            (* On non-display just print ## 
								      and return to initial position)
					[replace END of ARROW with (SETQ CURSOR (SETQ ENDBUFFER (fetch START of ARROW]
					(replace LASTCOL of ARROW with (fetch FIRSTCOL of ARROW))
					(RETYPE ARROW))
				      ((AT.END.OF.LINE)                         (* kill back to start of line.
								      This can work on glass tty, too,
								      whereas next clause doesn't)
					(DELETETO (fetch START of ARROW)))
				      (T                                        (* We're inside line, so go back to 
										start and then zap whole line)
					 (MOVE.BACK.TO (fetch START of ARROW))
					 (FORWARD.DELETE.TO (fetch END of ARROW]
			     [22Q                                               (* ^R retype)
				  [RETYPE (COND
					    ((OR (ON.FIRST.LINE)
						 (NOT (EMPTY.LINE)))
					      ARROW)
					    (T                                  (* If sitting on empty line, 
								      refresh the previous line)
					       (PREVLINE ARROW 1]
				  (COND
				    ((EQ (SETQ CHAR (TTBIN))
					 22Q)                                   (* two ^R's means retype whole 
								      buffer)
				      (OR DISPLAYTERMFLG (TTCRLF))              (* set off full retype by double
								      line)
				      (RETYPE (! FIRSTLINE)
					      T))
				    (T (GO SELECTCHAR]
			     [27Q                                               (* ^W delete last word)
				  (COND
				    ((NOT (AT.END.OF.LINE))                     (* Somewhere inside line, so do 
								      this as fancy edit command)
				      (EDITCHAR 27Q))
				    ((EMPTY.LINE)
				      (BEEP))
				    (T (DELETETO (PREVWORD CURSOR]
			     [33Q                                               (* altmode)
				  (COND
				    (SPLST                                      (* try to complete from spelling
								      list)
					   (OR (COMPLETEWORD)
					       (BEEP)))
				    ((TENEXCOMPLETE CHAR DIRECTORY/FILE)        (* altmode indicated 
								      file/directory completion, done 
								      in TENEXCOMPLETE)
				      NIL)
				    ((AND TTYINCOMPLETEFLG LISPXREADING (COND
					    ((SETQ STARTOFWORD (THISWORD))
					      (SETQ MATCHED (FINDMATCH USERWORDS STARTOFWORD)))
					    ((AND (NEQ TTYINCOMPLETEFLG 0)
						  (NOT (EMPTY.BUFFER)))         (* naked altmode stands for 
								      LASTWORD. Don't do this on empty
								      buffer, so as not to interfere 
								      with P.A.'s $ command)
					      (SETQ MATCHED (CCONS LASTWORD))
					      LASTWORD)))                       (* special option -- do altmode 
								      completion on USERWORDS, a list 
								      of fns/vars referenced recently)
				      (SETQ CHAR 433Q)                          (* Kludge used by ? routine 
								      below)
				      (OR (COMPLETEWORD NIL NIL MATCHED (OR STARTOFWORD CURSOR))
					  (BEEP)))
				    (T                                          (* no special significance)
				       (ADDNAKEDCHAR 33Q]
			     [6                                                 (* ^F: try file recognition)
				(COND
				  ((TENEXCOMPLETE CHAR 'FILE))
				  (READING (ADDNAKEDCHAR CHAR))
				  (T (BEEP]
			     ((52Q 42Q)                                         (* star or quote)
			       (ADDCHAR CHAR)
			       (DOTABS TABS))
			     (11Q                                               (* tab)
				  (OR DONTCOMPLETE (COMPLETEWORD T))
				  (OR (DOTABS TABS)
				      (ADDTAB)))
			     ((40Q 50Q 54Q 133Q)                                (* break or sepr: space, lp, 
								      comma, left bracket;
								      try to complete what we have)
			       (OR DONTCOMPLETE (COMPLETEWORD T))
			       (OR (AND (EQ CHAR 40Q)
					(AUTOCR?))
				   (ADDCHAR CHAR)))
			     [(51Q 135Q)                                        (* Right paren/bracket.
								      See if it terminates read)
			       (OR DONTCOMPLETE (COMPLETEWORD T))
			       (SETQ STARTOFWORD CURSOR)
			       (ADDCHAR CHAR)
			       (COND
				 (READING (COND
					    ((ENDREAD?)
					      (GO DOCRLF))
					    ((AND SHOWPARENFLG (CAPABILITY? CURSOR)
						  (NOT (TYPEAHEAD?)))           (* prime conditions for hack to 
								      show which paren it matched)
					      (SHOW.MATCHING.PAREN STARTOFWORD]
			     [77Q                                               (* handle ? -
								      supplies alternate completions)
				  (COND
				    [[NOT (AND ?ACTIVATEFLG (OR SPLST (EQ (! LASTCHAR)
									  433Q))
					       (AT.END.OF.BUF)
					       (SETQ STARTOFWORD (THISWORD))
					       [NOT (FMEMB (CAR (NLEFT STARTOFWORD 1 ENDBUFFER))
							   '(77Q 45Q]
					       (NOT (PROGN (FRPLACA ENDBUFFER 77Q)
							   (FINDMATCH SPLST STARTOFWORD (CDR ENDBUFFER]

          (* Cases where ? is not acted on: ?ACTIVATEFLG not set; no spelling list;
	  line is a comment; no word is in progress; previous char is also a ? 
	  (allows ?? etc.) or %%; or ? is a valid completion)


				      (SETQ STARTOFWORD CURSOR)
				      (ADDCHAR CHAR)
				      (COND
					((AND READING (AT.END.OF.LINE)
					      (NEQ STARTOFWORD BUFFER))         (* could be start of ? or ?=, so
								      check)
					  (COND
					    [(EQ (SETQ CHAR (TTBIN))
						 15Q)
					      (COND
						((DO?CMD '?)                    (* restore buffer after help is 
								      given, and now delete the ?)
						  (RUBOUT)
						  (SAVE.CURSOR)
						  (GO RETYPEBUFFER))
						(T (GO SELECTCHAR]
					    ((NEQ CHAR 75Q)
					      (GO SELECTCHAR))
					    (T (ADDCHAR CHAR)                   (* print the =)
					       (COND
						 [(AND (EQ (SETQ CHAR (TTBIN))
							   15Q)
						       (DO?CMD '?=))
						   (COND
						     ((CAPABILITY? MOVEMENT)
						       (RESTORE.CURSOR)
						       (BACKWARD.DELETE.TO STARTOFWORD))
						     (T (BACKWARD.DELETE.TO STARTOFWORD)
                                                                                (* Delete BEFORE retyping, since
								      we can't erase ?= as above)
							(RETYPE ARROW]
						 (T (GO SELECTCHAR]
				    ((NOT (SETQ MATCHED (FINDMATCH (OR SPLST USERWORDS)
								   STARTOFWORD)))
				      (BEEP)                                    (* No match. Ring the bell, but 
								      accept the ? as is)
				      (ADDCHAR CHAR))
				    ((COMPLETEWORD NIL T MATCHED STARTOFWORD)   (* there was a unique 
								      completion)
				      )
				    (T (SAVE.CURSOR)
				       (GO.TO.FREELINE T)
				       (TTPRIN1 "one of ")
				       [do (TTPRIN1 (INPART (CAR MATCHED)))
					   (COND
					     ((SETQ MATCHED (FINDMATCH (CDR MATCHED)
								       STARTOFWORD))
					       (TTPRIN1 ", "))
					     (T (RETURN]
				       (COND
					 (DISPLAYTERMFLG (RESTORE.CURSOR))
					 (T (RETYPE ARROW]
			     [12Q                                               (* linefeed: restore buffer's previous 
										contents)
				  (COND
				    ((NOT (AT.END.OF.BUF))                      (* internally means same as 
								      <edit>lf)
				      (SETQ INSERTING)
				      (EDITCHAR 12Q))
				    (T (RESTOREBUF]
			     [15Q                                               (* cr to terminate line)
				  [COND
				    ((AND (NOT EDITBIT)
					  (INSERTING)
					  (NOT (AT.END.OF.TEXT CURSOR)))
				      (COND
					([OR REPEAT (AND READING (NOT (TTSKREAD BUFFER CURSOR]
                                                                                (* Insert a <cr> and continue 
								      reading)
					  (BREAKLINE 37Q)
					  (GO CHAR))
					(T                                      (* <cr> typed here would terminate, so 
										unread what's left)
					   (UNREADBUF)
					   (SETQ INSERTING]
				  (COND
				    [(NOT (AT.END.OF.BUF))
				      (COND
					((ON.LAST.LINE)
					  (SETQ CURSOR ENDBUFFER))
					((AND READING (NOT (! PROMPT2))
					      (AT.END.OF.TEXT (fetch END of ARROW)))
                                                                                (* Really the same condition as 
								      previous clause: there are lines
								      after this one, but they're 
								      blank, so it looks like we're on
								      the last line)
					  (MOVE.FORWARD.TO (fetch END of ARROW))
                                                                                (* have to make the extra stuff 
								      go away so the finishing 
								      routines are happy)
					  (DELETE.TO.END))
					(T (EDITCHAR 15Q)                       (* CR on other than last line 
								      just means go down one)
					   (GO CHAR]
				    ((AND (EQ (CAR BUFFER)
					      102Q)
					  (EQ (CADR BUFFER)
					      114Q)
					  (EQ (CDDR BUFFER)
					      ENDBUFFER)
					  DISPLAYTERMFLG)                       (* BL command)
				      (ERASE.SCREEN)
				      (GO PROMPT0))
				    ((OR (NOT DONTCOMPLETE)
					 (EQ DONTCOMPLETE 'CRCOMPLETE))
				      (COMPLETEWORD T)))
				  (COND
				    ((COND
					(READING (TTSKREAD BUFFER))
					[REPEAT (AND (ON.FIRST.LINE)
						     (OR (EQ (CAR BUFFER)
							     73Q)
							 (AND COMMAND (EQ (NEXTWORD (FIRSTWORD BUFFER))
									  ENDBUFFER]
					(T T))                                  (* Terminating conditions: no 
								      REPEAT, or first line is a 
								      comment or has a single command 
								      on it)
				      (SETQ CTRLVFLG (SETQ RESULT))
				      (SETQ CHAR 37Q)                           (* Lisp likes to treat cr as 
								      (choke) EOL)
				      (GO DOCRLF))
				    (T (NEWLINE 37Q]
			     [26Q                                               (* ^V)
				  (COND
				    [READING                                    (* Means enter control char)
					     (ADDNAKEDCHAR (SETQ CHAR (SELECTQ (SETQ CHAR (TTBIN))
									       ((177Q 77Q)
                                                                                (* DELETE is ^?)
										 177Q)
									       (SLOGAND CHAR 37Q]
				    ((AND (EQ REPEAT 'TEXT)
					  (AT.END.OF.BUF))                      (* terminate multiline input and
								      sets special flag)
				      (SETQ CTRLVFLG T)
				      (TTBOUT ^ V)
				      (GO DOCRLF))
				    (T (BEEP]
			     [32Q                                               (* ^Z terminates multiline input)
				  (COND
				    ((AND REPEAT (AT.END.OF.BUF))
				      (TTBOUT ^ Z)
				      (SETQ CTRLVFLG)
				      (GO DOCRLF))
				    (T (BEEP]
			     [31Q                                               (* ^Y invokes user exec)
				  (COND
				    ((AND READING (NOT EDITBIT)
					  (NOT (EMPTY.BUFFER)))                 (* let ^Y read macro work 
								      instead)
				      (ADDNAKEDCHAR CHAR))
				    ((GUESTUSER?)
				      (BEEP))
				    (T (SETTAIL?)
				       (SAVE.CURSOR)
				       (GO.TO.FREELINE T)
				       (COND
					 ((SETQ DRIBFL (DRIBBLEFILE))           (* Make typescript 
								      understandable)
					   (AND (! PROMPT1)
						(PRIN1 (! PROMPT1)
						       DRIBFL))
					   (PRINT '^Y DRIBFL)))
				       (PRIN1 "lisp:
" T)
				       (COND
					 (TTYINMAILFLG (MWNOTE)))
				       (RESTOREMOD)
				       (RESETVARS ((TTYINBUFFER (CDR ENDBUFFER))
						   (LISPXREADFN OLDREADFN))     (* Rebind TTYINBUFFER so any 
								      internal TTYINs don't clobber 
								      buffer, but allow to reuse any 
								      conses that aren't busy)
					          (USEREXEC '__))
				       (GO RETYPEBUFFER]
			     ((0 37Q)                                           (* ignore NULL and HOLD)
			       )
			     (3                                                 (* ^C: we shouldn't be reading this)
				(SAVE.CURSOR)
				(TTBOUT ^ C CR LF)
				(LOGOUT)
				(GO RETYPEBUFFER))
			     (COND
			       [(SGREATERP CHAR 40Q)                            (* not a control char)
				 (ADDCHAR (COND
					    (RAISE (U-CASECODE CHAR))
					    (T CHAR]
			       (READING (ADDNAKEDCHAR CHAR))
			       (T                                               (* object to control chars)
				  (BEEP]
		    (GO CHAR)
		RETYPEBUFFER
		    (SETQ INSERTING)
		    (RETYPE (! FIRSTLINE)
			    T T)
		    (GO CHAR)
		DOCRLF

          (* * Come here when it is time to terminate line)


		    (SETQ LASTCHARACTER CHAR)                                   (* Save this for funny tops20 
								      check at end)
		    (SETLASTC CHAR)                                             (* tell lisp what last char typed was)
		    (TTCRLF)
		    (CLEAR.LINE? T)
		    (COND
		      ((SETQ DRIBFL (DRIBBLEFILE))                              (* print answer on typescript 
								      file)
			(ECHOFILE DRIBFL T)))
		    (for X inlist FILE do (ECHOFILE X))
		    (COND
		      ((EMPTY.BUFFER)                                           (* blank line. RESULT is NIL 
								      unless set above by a read 
								      macro)
			(RETURN RESULT))
		      ((EQ (CAR BUFFER)
			   73Q)                                                 (* comment)
			(GO PROMPT0))
		      ((AND (EQ (CDR BUFFER)
				ENDBUFFER)
			    (EQ (CAR BUFFER)
				77Q)
			    (OR HELP (AND NOVALUE REPEAT)))                     (* a bare ?)
			(GIVEHELP (OR HELP "Terminate text with control-Z."))
			(GO PROMPT0)))
		    (!SETQ OLDTAIL ENDBUFFER)                                   (* Save last buffer position for
								      posterity)
		    [COND
		      [READING (SETQ RESULT (TTREADLIST))
			       [COND
				 ((NEQ BUFFER ENDBUFFER)                        (* Line terminated with 
								      unbalanced right paren.
								      If there was only one thing on 
								      line, read the terminator as a 
								      NIL)
				   [COND
				     ((AND (EQ READING 'EVALQT)
					   [NOT (CDR (SETQ X (COND
							 ((EQ (CAR RESULT)
							      'E)               (* A hack on a hack: this is 
								      probably the editor's E command,
								      and CDR is the real input)
							   (CDR RESULT))
							 (T RESULT]
					   (NLISTP (CAR X)))
				       (SETQ RESULT (NCONC1 RESULT NIL]
				   (SETQ BUFFER (CDR BUFFER))
				   (TTSKIPSEPR)
				   (while [AND (NEQ BUFFER ENDBUFFER)
					       (FMEMB (CAR BUFFER)
						      '(51Q 135Q]
				      do (SETQ BUFFER (CDR BUFFER)))            (* skip over any extra right 
								      parens or brackets)
				   (COND
				     ((NEQ BUFFER ENDBUFFER)
				       (MOVE.TO.WHEREVER BUFFER)

          (* There was stuff after the read terminated, probably because user deleted or 
	  added a paren somewhere in the middle. Probably didn't want to throw it away, so 
	  unread it so user can see it)


				       (UNREADBUF)
				       (TTCRLF]
			       (COND
				 ((AND (EQ CHAR 37Q)
				       (NOT (CDR RESULT))
				       (LISTP (CAR RESULT)))                    (* User terminated with <cr>, 
								      but read a list. Pretend he 
								      terminated with a "]" to be 
								      consistent with lisp READ 
								      conventions)
				   (SETLASTC 135Q]
		      (T
			(SETQ ORIGBUFFER BUFFER)
			(SETQ WORD (TTRATOM))
			[COND
			  ((EQ (TTSKIPSEPR)
			       ENDBUFFER)                                       (* this was the only word in 
								      buffer)
			    (COND
			      ((SELECTQ WORD
					((? HELP)                               (* Only special if HELP 
								      provided)
					  (AND HELP (GIVEHELP HELP)))
					(CRT (JS STTYP 777777Q (COND
						   ((TENEXP)
						     13Q)
						   (T 5)))                      (* tell tenex this is Datamedia)
					     (SETBACKSPACE T)
					     (SETQ TTYLINELENGTH 120Q)
					     (TTPRIN1 'okay)
					     (SETQ DISPLAYTERMFLG T)
					     T)
					NIL)                                    (* special response handled;
								      restart now)
				(TERPRI T)
				(GO PROMPT0]
			[for RESPONSE fin TTYINRESPONSES when (AND (EQMEMB WORD (CAR RESPONSE))
								   (OR (EQ BUFFER ENDBUFFER)
								       (CADDR RESPONSE)))
			   do 

          (* Process global user option. RESPONSE is a triple (commands response-form 
	  rest-of-line-arg); if user gives one of the commands, the response form is 
	  evaluated with COMMAND set to the command and LINE set to the remainder of the 
	  line; the third component says how to compute LINE: as a STRING or as a LIST;
	  if NIL, means there should be nothing else on the line. If the response form 
	  returns the atom IGNORE, the input is not considered to be a special response and 
	  the normal computation proceeds; otherwise it is assumed the response has been 
	  processed, and we return to the original TTYIN prompt for more input.
	  Response-form may be an atom, in which case it is APPLYed to COMMAND and LINE.)


			      (COND
				((NEQ [PROG [(COMMAND WORD)
					     (BUFFER BUFFER)
					     (LINE (COND
						     ((EQ BUFFER ENDBUFFER)
						       NIL)
						     ((EQ (CADDR RESPONSE)
							  'STRING)
						       (TTYINSTRING BUFFER))
						     (T (TTREADLIST]
					    (DECLARE (SPECVARS COMMAND BUFFER LINE))
					    (RETURN (COND
						      ((LITATOM (CADR RESPONSE))
							(APPLY* (CADR RESPONSE)
								COMMAND LINE))
						      (T (EVAL (CADR RESPONSE]
				      'IGNORE)
				  (GO RESTART))
				(T 

          (* That response was ignored. We could quit the iteration now, but continue in 
	  case there is another entry with the same command. I.e. user can "redefine" 
	  special responses this way, but still let the old definition happen if the input 
	  looks wrong)

]
			(SETQ WORD (OR (FIXWORD WORD)
				       (GO PROMPT0)))
			[SETQ RESULT (COND
			    [(EQ BUFFER ENDBUFFER)
			      (COND
				(COMMAND (LIST WORD))
				(NOVALUE T)
				(STRING 

          (* Can't just MKSTRING WORD here, since in the process of making the atom we might have changed 
	  something, e.g. stripped leading zeros from a number, or changed radix)


					(TTYINSTRING ORIGBUFFER))
				(T (LIST WORD]
			    [STRING (COND
				      (COMMAND (CONS WORD (TTYINSTRING BUFFER)))
				      (T (TTYINSTRING ORIGBUFFER]
			    (NOVALUE (COND
				       (COMMAND (CONS WORD T))
				       (T T)))
			    (T (CONS WORD (while (NEQ (TTSKIPSEPR)
						      ENDBUFFER)
					     collect (SETQ WORD (TTRATOM))      (* go back for more)
						     (COND
						       (COMMAND                 (* only check first word typed)
								WORD)
						       ((FIXWORD WORD))
						       (T (GO PROMPT0]
			(PROGN                                                  (* All this nonsense is just to 
								      convince prettyprint to keep the
								      indentation down to a reasonable
								      amount)
			  (PROGN
			    (PROGN
			      (PROGN
				(PROGN
				  (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN NIL]

          (* * We have now processed the line, with the relevant value being RESULT...)


		    [COND
		      ((AND TTYINUSERFN (LISTP RESULT))
			(COND
			  ((EQ (SETQ X (APPLY* TTYINUSERFN RESULT))
			       T)                                               (* Special response has been 
								      processed; try again)
			    (GO PROMPT0))
			  (X                                                    (* this is what we should 
								      return)
			     (RETURN X]
		    (RETURN RESULT]
          (COND
	    ((NOT VALUE)                                                        (* NLSETQ aborted.
								      Try again.)
	      (COND
		(LISPXREADING                                                   (* LISPXREAD is not 
								      errorset-protected, so why 
								      should this be?)
			      (RESTOREMOD)
			      (COND
				((NEQ BUFFER ENDBUFFER)
				  (!SETQ OLDTAIL ENDBUFFER)))
			      (ERROR!)))
	      (GO LP)))
          (SETQ VALUE (CAR VALUE))
          (POSITION T 0)
          (COND
	    ([AND DISPLAYTERMFLG (OR (EQ HOSTNAME 'SUMEX-AIM)
				     (NOT (TENEXP]

          (* Need to tell system where the cursor is, since it ignored it when terminal was 
	  in binary mode. SFPOS is the inverse of RFPOS. NOTE: this jsys may not exist 
	  everywhere; sumex and tops20 sites have it. If you're elsewhere, tough;
	  lobby tenex authorities to make SFPOS an official jsys. Note that no real 
	  disasters occur if this jsys isn't executed: the worst that can happen is that 
	  tenex tries to break the next line when it doesn't need to.)


	      (JS SFPOS 777777Q 0)))
          (RESTOREMOD)
          (COND
	    ((AND (EQ LASTCHARACTER 37Q)
		  (NOT (TENEXP))
		  DISPLAYTERMFLG
		  (BIT 35Q (fetch TTYMODE of TTYINBUFFER)))

          (* * Ah, the wonders of tops20. We have now switched back to ascii mode, and the 
	  last thing the user typed while in binary mode was a <cr>.
	  If someone now tries to do a BIN, or asks if there is typeahead, the answer is 
	  that there is a <lf> available, because <cr> in ascii mode is always followed by 
	  <lf>. Little matters it that the <cr> in question happened in Binary mode.
	  Grumble. So eat up the bogus <lf> here.)


	      (ASSEMBLE NIL
		        (MOVEI 1 , 100Q)
		        (JS SIBE)                                               (* Check to make sure it really 
								      thinks there's input)
		        (SKIPA)
		        (JRST DONE)                                             (* No! Maybe a different 
								      monitor)
		        (JS BIN)                                                (* read the char waiting for us)
		        (CAIN 2 , 12Q)                                          (* make sure it really is a 
								      <lf>)
		        (JRST DONE)

          (* * eek, it wasn't. Better put it back. This should never happen, unless they 
	  change the tops20 monitor to do this right)


		        (JS BKJFN)
		        (JFCL)
		    DONE)))
          [COND
	    (CTRLUFLG                                                           (* user typed ^U to edit input)
		      (SETQ LISPXREADFN OLDREADFN)
		      (SETQ CTRLUFLG)
		      (COND
			((OR (LITATOM VALUE)
			     (GUESTUSER?))                                      (* guests may not edit)
			  )
			((LISTP VALUE)
			  (EDITE VALUE))
			(T (SETQ VALUE (CAR (EDITE (LIST VALUE)
						   '(REPACK]
          (COND
	    ((AND TTYINMAILFLG (NEQ READING 'EVALQT))                           (* Note time of last user input)
	      (MWNOTE)))
          (RETURN VALUE])

(ADDCHAR
  [LAMBDA (CHAR)                                                      (* bvm: "20-Mar-80 00:06")

          (* * Add CHAR to buffer and print it, advancing cursor position appropriately)


    (ENDELETE)
    (ADD1POS)                                                         (* Cursor advances past the 
								      character in any case)
    [COND
      ((AT.END.OF.LINE)
	(TTBOUT CHAR)
	(INSERT.CHAR.IN.BUF CHAR)
	                                                              (* i.e. inserting at end of 
								      line)
	(replace LASTCOL of ARROW with (! CURSORCOL)))
      [(INSERTING)
	(INSERTNCHARS 1 CHAR)
	(INSERT.CHAR.IN.BUF CHAR)
	                                                              (* Wedge char into the buffer, 
								      and advance the final column)
	(PROG ((OVFL (SDIFFERENCE (replace LASTCOL of ARROW with (SADD1 (fetch LASTCOL of ARROW)))
				  TTYLINELENGTH))
	       (CURCOL (! CURSORCOL)))
	      (COND
		((OR (SGREATERP OVFL 0)
		     (AND (ZEROP OVFL)
			  AUTOFILL))
		  (ADJUSTLINE.AND.RESTORE (AND AUTOFILL 1))
		  (COND
		    ((EQ CURCOL TTYLINELENGTH)
		                                                      (* We were inserting and hit the
								      right edge of the screen, 
								      putting us in column 0 of next 
								      row)
		      (MOVE.TO.NEXT.LINE]
      (T [COND
	   ((PREFIXCHAR (CAR CURSOR))
	                                                              (* Overwriting a multi-position 
								      char, so need to flush the extra
								      garbage)
	     (SELECTQ (REALBITS (CAR CURSOR))
		      ((11Q 40Q)
			                                              (* tab or pseudo-tab: change the
								      padding spaces to ordinary 
								      spaces)
			(KILLSEGMENT CURSOR (CDR CURSOR))
			                                              (* flush the tab itself, leaving
								      only its spaces)
			(for BUF_CURSOR by (CDR BUF) while (EQ (CAR BUF)
							       440Q)
			   do (FRPLACA BUF 40Q)))
		      (PROGN                                          (* Delete all but one of the 
								      printing chars)
			     (FORWARD.DELETE.TO (NLEFT CURSOR 1 (NEXTCHAR CURSOR]
	 (TTBOUT CHAR)
	 (FRPLACA CURSOR CHAR)
	 (SETQ CURSOR (CDR CURSOR]
    (OVERFLOW? 0)
    NIL])

(ADDCHARS.INSERTING
  [LAMBDA (N CHAR)                                                    (* bvm: "24-Feb-80 20:29")

          (* * Inserts CHAR N times. Works independent of setting of INSERTING)


    [COND
      ((NEQ N 1)
	                                                              (* if near end of line, break if
								      this would overflow it)
	(OVERFLOW? (SSUB1 N]
    (COND
      ((AT.END.OF.LINE)
	(TTBOUTN N CHAR))
      (T (INSERTNCHARS N CHAR)))
    (FRPTQ N (PROGN (ADD1POS)
		    (INSERT.CHAR.IN.BUF CHAR)))

          (* * Now clean up any resulting overflow. Could have done this character by 
	  character in ADDCHAR, but if N gt 1 that can be slow.)


    (COND
      ((SGREATERP (replace LASTCOL of ARROW with (SPLUS (fetch LASTCOL of ARROW)
							N))
		  TTYLINELENGTH)
	(ADJUSTLINE.AND.RESTORE))
      (T (OVERFLOW? 0)))
    NIL])

(ADDNAKEDCHAR
  [LAMBDA (CHAR NOAUTOFILL)                                                     (* bvm: "24-Apr-82 14:48")

          (* * Adds CHAR with no special processing, e.g. most control chars 
	  (except cr and lf, which I can't figure out yet) go thru ok.)


    (COND
      ((AND (SGREATERP CHAR 40Q)
	    (NEQ CHAR 177Q))
	(ADDCHAR CHAR))
      (T (SELECTQ CHAR
		  [15Q                                                          (* CR can be attempted if at 
								      end)
		       (COND
			 ((AT.END.OF.BUF)
			   (NEWLINE 37Q))
			 (T (BREAKLINE 37Q]
		  (40Q (OR (AND (NOT NOAUTOFILL)
				(AUTOCR?))
			   (ADDCHAR 40Q)))
		  (33Q (INSERT.CHAR.IN.BUF 233Q)                                (* Altmode will echo as $)
		       (ADDCHAR 444Q))
		  (11Q (ADDTAB))
		  (PROGN (OVERFLOW? 1)
			 (INSERT.CHAR.IN.BUF (SLOGOR CHAR 200Q))                (* Insert naked char with prefix
								      bit)
			 (ADDCHAR 536Q)                                         (* That's ^ plus 400Q)
			 (ADDCHARS.INSERTING 1 (COND
					       ((EQ CHAR 177Q)                  (* DELETE is represented as ^?)
						 477Q)
					       (T (SLOGOR CHAR 500Q])

(ADDSILENTCHAR
  [LAMBDA (CHAR)                                                      (* edited: " 2-Mar-80 23:32")

          (* Like ADDCHAR, but doesn't echo the char, assuming that echoing has already been
	  done. Assumes we are at end of line so we don't have to do any messiness)


    (COND
      [(SLESSP CHAR 40Q)
	                                                              (* bleah. do a control char.
								      The line is probably screwed up,
								      but at least let ^R do the right
								      thing)
	(INSERT.CHAR.IN.BUF (SLOGOR CHAR 200Q))
	                                                              (* Prefix bit on)
	(COND
	  ((EQ CHAR 33Q)
	    (INSERT.CHAR.IN.BUF 444Q)
	                                                              (* padded "$"))
	  (T (INSERT.CHAR.IN.BUF 536Q)
	                                                              (* padded ^)
	     (INSERT.CHAR.IN.BUF (SLOGOR CHAR 500Q))
	                                                              (* controlified letter)
	     (ADD1POS]
      (T (INSERT.CHAR.IN.BUF CHAR)))
    (ADD1POS)
    (COND
      ((NOT (SLESSP (replace LASTCOL of ARROW with (! CURSORCOL))
		    TTYLINELENGTH))
	(NEWLINE)))
    NIL])

(ADDTAB
  [LAMBDA NIL                                                         (* bvm: "24-Feb-80 20:29")
    (COND
      ((AND (NOT (AT.END.OF.BUF))
	    (NOT INSERTING)
	    (EQ (CAR CURSOR)
		211Q))
	                                                              (* We're on a tab.
								      Unless we're explicitly 
								      inserting, just move cursor over
								      it)
	(MOVE.FORWARD.TO (NEXTCHAR CURSOR)))
      (T (OVERFLOW? 10Q)
	 

          (* Represent <tab> in buffer as a tab with 200Q bit on, followed by the 
	  appropriate number of spaces, each with 400Q bit on. Tab is always self-inserting,
	  i.e. it never overwrites anything (except itself, as above))


	 (INSERT.CHAR.IN.BUF 211Q)
	                                                              (* the actual tab)
	 (ADDCHARS.INSERTING (SDIFFERENCE 10Q (SLOGAND (SDIFFERENCE (! CURSORCOL)
								    (fetch FIRSTCOL of ARROW))
						       7))
			     440Q])

(ADJUSTLINE
  [LAMBDA (JUSTIFYING LINE)                                           (* bvm: " 8-Mar-80 17:16")

          (* Handles patching up lines that are too long or short. Assures that the current 
	  line, ARROW, is correct with regard to overflows. If JUSTIFYING is true, it is a 
	  number specifying how many lines to "justify", by which we mean moving text around
	  so that each line has as many words as possible for the linelength, but does not 
	  overflow. We don't do anything very fancy with that, like take care of deleting 
	  extra spaces.)


    (PROG (#CHARS BREAK LASTCOL NEWENDLINE NEXTLINE OLDENDLINE OVFL START USECR ROW)
          (OR LINE (SETQ LINE ARROW))
          (SETQ ROW (fetch ROW of LINE))
      LP  (SETQ NEXTLINE (fetch NEXTLINE of LINE))
          (SETQ OVFL (OVERFLOWLINE? LINE))
          (SETQ #CHARS (SDIFFERENCE TTYLINELENGTH (fetch LASTCOL of LINE)))
          (SETQ USECR (SETQ BREAK NIL))
          (SETQ START (fetch START of LINE))
          [COND
	    ((SLESSP #CHARS 0)
	                                                              (* Too much on line;
								      need to break it somewhere, 
								      preferably at a space if 
								      permissible. If justifying, try 
								      to break at the appropriate 
								      length)
	      (COND
		([OR (AND JUSTIFYING (SLESSP (SPLUS (fetch FIRSTCOL of LINE)
						    TTYJUSTLENGTH)
					     TTYLINELENGTH)
			  (SETQ BREAK (FINDBREAK START (NTH.RELATIVE.COLUMN.OF LINE TTYJUSTLENGTH)
						 T)))
		     (PROGN (SETQ NEWENDLINE (NTH.COLUMN.OF LINE TTYLINELENGTH))
			    (AND (OR JUSTIFYING AUTOFILL)
				 (SETQ BREAK (FINDBREAK START NEWENDLINE T]
		  (SETQ USECR T))
		(T (SETQ BREAK NEWENDLINE)))
	      (GO DOBREAK))
	    [(AND OVFL (NEQ #CHARS 0))
	      

          (* Line is too short, but is an overflow line, so text MUST be moved to fill the 
	  gap; alternatively, if we are justifying, we could break the line sooner)


	      (SETQ NEWENDLINE (NTH.RELATIVE.COLUMN.OF NEXTLINE #CHARS))
	                                                              (* Where the line should end, 
								      based on linelength)
	      (COND
		([OR (EQ (fetch END of LINE)
			 NEWENDLINE)
		     (AND (OR AUTOFILL JUSTIFYING)
			  (SETQ BREAK (FINDBREAK (fetch END of LINE)
						 NEWENDLINE JUSTIFYING))
			  (SETQ NEWENDLINE BREAK))
		     (NOT JUSTIFYING)
		     (NOT (SETQ BREAK (FINDBREAK START (fetch END of LINE)
						 T]
		  (GO DOJOIN))
		(T (SETQ USECR T)
		   (GO DOBREAK]
	    ((NOT JUSTIFYING)
	      (RETURN))
	    [(OR OVFL (SGREATERP (SDIFFERENCE (fetch LASTCOL of LINE)
					      (fetch FIRSTCOL of LINE))
				 TTYJUSTLENGTH))
	                                                              (* line is longer than we'd 
								      like)
	      (COND
		((SETQ BREAK (FINDBREAK START (NTH.RELATIVE.COLUMN.OF LINE TTYJUSTLENGTH)
					T))
		  (SETQ USECR T)
		  (GO DOBREAK]
	    ((AND (NOT (EMPTY.LINE LINE))
		  (NOT (START.OF.PARAGRAPH? NEXTLINE)))
	                                                              (* Don't move up text from next 
								      line if it is blank or starts 
								      with tab -- treat those as 
								      paragraph breaks)
	      (COND
		((OR (EQ [SETQ BREAK (NTH.RELATIVE.COLUMN.OF
			     NEXTLINE
			     (SSUB1 (SMIN (SDIFFERENCE (SPLUS TTYJUSTLENGTH (fetch FIRSTCOL
									       of LINE))
						       (fetch LASTCOL of LINE))
					  #CHARS]
			 (fetch END of NEXTLINE))
		     (SETQ BREAK (FINDBREAK (fetch START of NEXTLINE)
					    BREAK T)))
		  (SETQ NEWENDLINE BREAK)
		                                                      (* At least one more word from 
								      next line will fit up here)
		  (GO DOJOIN))
		(T                                                    (* No text movement, but if 
								      there was a real <cr>, make it 
								      pseudo now)
		   (FRPLACA (fetch END of LINE)
			    1040Q]
          (SETQ LINE NEXTLINE)
          (GO BOTTOM)
      DOJOIN

          (* * Move text from next line up to this one. NEWENDLINE is where line should end 
	  when done. BREAK=NEWENDLINE if this new end line is a pseudo-cr break)


          [COND
	    ((EQ (SETQ OLDENDLINE (fetch END of LINE))
		 NEWENDLINE)
	      (SETQ #CHARS 0))
	    (T (GO.TO (fetch LASTCOL of LINE)
		      ROW)
	       (SETQ #CHARS (BUFLEN OLDENDLINE NEWENDLINE))
	                                                              (* # chars to delete from next 
								      line)
	       [COND
		 ((NOT OVFL)
		                                                      (* Joining toa non-overflow 
								      line: turn its cr into a space)
		   (FRPLACA OLDENDLINE 40Q)
		   (while (AND (NEQ (CDR OLDENDLINE)
				    NEWENDLINE)
			       (EQ (CADR OLDENDLINE)
				   40Q))
		      do                                              (* strip leading spaces from 
								      next line)
			 (KILLSEGMENT OLDENDLINE (CDR OLDENDLINE)))
		   (COND
		     ((EQ (CAR (NLEFT (fetch START of LINE)
				      1 OLDENDLINE))
			  56Q)
		                                                      (* LINE ends in period, so space
								      twice)
		       (FRPLACA (INSERTCONS OLDENDLINE)
				40Q]
	       (TYPE.BUFFER OLDENDLINE NEWENDLINE)
	       (replace END of LINE with NEWENDLINE)
	       (replace LASTCOL of LINE with (! CURSORCOL]
          (GO.TO 'LINE NEXTLINE)
          (replace START of NEXTLINE with (COND
					    (BREAK (FRPLACA BREAK 1040Q)
						                      (* Turn BREAK's space into a 
								      pseudo-cr, if anyone cares)
						   (COND
						     (OVFL (ADD1VAR #CHARS)
							              (* will delete space also)))
						   (CDR NEWENDLINE))
					    (T NEWENDLINE)))
          (COND
	    ((EQ (fetch END of NEXTLINE)
		 NEWENDLINE)
	      (DELETELINE NEXTLINE T)
	                                                              (* Nothing left here, so kill 
								      it)
	      [COND
		(JUSTIFYING                                           (* maybe we can move from next 
								      line, too)
			    (COND
			      ((NOT (ZEROP (SUB1VAR JUSTIFYING)))
				(GO LP))
			      (T (RETURN]
	      (SETQ LINE (fetch NEXTLINE of LINE)))
	    (T (DELNCHARS #CHARS (fetch START of NEXTLINE)
			  (fetch END of NEXTLINE))
	       (replace LASTCOL of NEXTLINE with (SDIFFERENCE (fetch LASTCOL of NEXTLINE)
							      #CHARS))
	       (SETQ LINE NEXTLINE)))
          (GO BOTTOM)
      DOBREAK

          (* Break line at BREAK, moving excess down to next line or a new line.
	  USECR is true if break is a cr break; otherwise we are breaking a too-long line at
	  the right margin)


          [replace LASTCOL of LINE with (SETQ LASTCOL (SPLUS (BUFLEN (fetch START of LINE)
								     BREAK)
							     (fetch FIRSTCOL of LINE]
                                                                      (* Column where break will 
								      occur)
          [SETQ #CHARS (BUFLEN BREAK (SETQ OLDENDLINE (fetch END of LINE]
                                                                      (* length of segment being 
								      moved)
          (COND
	    ((NEQ LASTCOL TTYLINELENGTH)
	      (GO.TO LASTCOL ROW)
	                                                              (* Go wipe out what was there.
								      Don't need to do this if the 
								      break is right at the margin)
	      (ERASE.TO.END.OF.LINE)))
          (replace END of LINE with BREAK)
          [COND
	    (USECR (FRPLACA BREAK 1040Q)
		                                                      (* Turn break space into 
								      pseudo-cr. Of course, that means
								      we have counted one char too 
								      many above...)
		   (SUB1VAR #CHARS)
		   (SETQ BREAK (CDR BREAK]
          (COND
	    [[AND NEXTLINE (OR OVFL (AND (OR JUSTIFYING
					     (AND (EQ (CAR OLDENDLINE)
						      1040Q)
						  (SLESSP (SPLUS (fetch LASTCOL of NEXTLINE)
								 #CHARS)
							  TTYLINELENGTH)))
					 (NOT (START.OF.PARAGRAPH? NEXTLINE]
	      

          (* Insert the text on the next line, rather than starting new line, if justifying,
	  overflow (forced), or the text will fit, i.e. not cause anything to be bumped off 
	  the next line)


	      (GO.TO 'LINE (SETQ LINE NEXTLINE))
	      (COND
		((NOT OVFL)
		                                                      (* Turn the terminating <cr> 
								      into ordinary space;
								      this space also needs to be 
								      inserted and counted, of course)
		  (ADD1VAR #CHARS)
		  (SETQ OLDENDLINE (CDR (FRPLACA OLDENDLINE 40Q]
	    (T (SETQ LINE (INSERTLINE LINE))
	       (replace END of LINE with OLDENDLINE)))
          (replace START of LINE with BREAK)
          (INSERT.TEXT BREAK OLDENDLINE (fetch END of LINE))
          (replace LASTCOL of LINE with (SPLUS (fetch LASTCOL of LINE)
					       #CHARS))
      BOTTOM
          (COND
	    (LINE (ADD1VAR ROW)
		  (COND
		    ((AND JUSTIFYING (ZEROP (SUB1VAR JUSTIFYING)))
		      (SETQ JUSTIFYING NIL)))
		  (GO LP])

(ADJUSTLINE.AND.RESTORE
  [LAMBDA (JUSTIFYING)                                                (* bvm: " 8-Mar-80 02:26")
    (SAVE.CURSOR)
    (ADJUSTLINE JUSTIFYING)
    (COND
      ((IGREATERP (! HOMECOL)
		  (fetch LASTCOL of ARROW))
	                                                              (* Oops, cursor must have moved)
	(MOVE.TO.WHEREVER CURSOR))
      (T (RESTORE.CURSOR])

(AT.END.OF.SCREEN
  [LAMBDA NIL                                                         (* bvm: "27-Aug-78 23:36")
    (OR (AT.END.OF.LINE)
	(EQ (! CURSORCOL)
	    (SSUB1 TTYLINELENGTH])

(AT.END.OF.TEXT
  [LAMBDA (BUF)                                                       (* bvm: "24-Jun-79 01:38")

          (* Checks that this is the last printing char in buffer. Fancier than just 
	  checking that BUF = ENDBUFFER, since that would mess up if user deletes a line and
	  decides to terminate on previous line)


    (for X_BUF by (CDR X) until (EQ X ENDBUFFER) always (SPACEP (CAR X])

(AUTOCR?
  [LAMBDA NIL                                                         (* bvm: "10-Jul-79 20:54")
                                                                      (* Terminates line if near edge 
								      of screen and in autofill mode)
    (COND
      ((AND AUTOFILL (SGREATERP (SPLUS (! CURSORCOL)
				       12Q)
				TTYLINELENGTH))
	(COND
	  ((AT.END.OF.LINE)
	    (NEWLINE 1040Q))
	  (T (BREAKLINE 1040Q)))
	T])

(BACKWARD.DELETE.TO
  [LAMBDA (BUF)                                                       (* bvm: " 3-Jul-78 11:45")
    (FORWARD.DELETE.TO (PROG1 CURSOR (MOVE.BACK.TO BUF])

(BACKSKREAD
  [LAMBDA (BUF NOTIFQUOTED)                                           (* bvm: " 8-Aug-80 00:45")

          (* Returns buffer position of start of list containing cursor position BUF, or 
	  start of buffer. If NOTIFQUOTED is true, then returns NIL if the paren/bracket at 
	  BUF is quoted with the escape char or is inside a string. Strategy: start at 
	  beginning of buffer and TTSKREAD forward (much easier); if read ends at BUF, we 
	  win; if ends before BUF, then resume reading there (we skipped an internal list); 
	  otherwise if read did not end, BUF must be inside a list, so scan ahead for start 
	  of an inner list, and repeat)


    (PROG ((B BUFFER)
	   (INNERMOSTLIST BUFFER)
	   BRACKETFLG X)
      LP  (COND
	    ((EQ B BUF)
	                                                              (* No list in buffer at all)
	      (RETURN INNERMOSTLIST)))
          (SELECTQ (CAR B)
		   [(50Q 133Q)
		                                                      (* open paren or bracket.
								      Try scanning this new internal 
								      list)
		     (COND
		       ((EQ (SETQ X (TTSKREAD (CDR B)
					      BUF))
			    BUF)
			 (RETURN (OR BRACKETFLG B)))
		       (X                                             (* Skip over internal list just 
								      scanned)
			  (SETQ B X))
		       (T                                             (* The TTSKREAD failed, so BUF 
								      must be at least this deeply 
								      nested. Save pointer here in 
								      case we abort inside a string or
								      such)
			  (SETQ INNERMOSTLIST B)
			  (COND
			    ((AND (EQ (CAR B)
				      133Q)
				  (EQ (CAR BUF)
				      135Q))
			                                              (* Brackets may match;
								      save position of this open 
								      bracket. Otherwise we'll return 
								      the innermost list, rather than 
								      the start of the bracket 
								      expression)
			      (SETQ BRACKETFLG B]
		   [45Q                                               (* %  to quote the next char)
			(COND
			  ((EQ (CDR B)
			       BUF)
			                                              (* The char at BUF is quoted.
								      This is why TTSKREAD failed 
								      here. Just return the list we're
								      now inside)
			    (RETURN (AND (NOT NOTIFQUOTED)
					 INNERMOSTLIST)))
			  (T                                          (* skip over escape char)
			     (SETQ B (CDR B]
		   [42Q                                               (* double-quote)
			(COND
			  ((NOT (SETQ B (NEXTQUOTE (CDR B)
						   BUF)))
			                                              (* Termination analogous to 
								      previous case)
			    (RETURN (AND (NOT NOTIFQUOTED)
					 INNERMOSTLIST]
		   NIL)
          (SETQ B (CDR B))
          (GO LP])

(BINARY.MODE
  [LAMBDA (ONLYIFCHANGED)                                             (* bvm: "23-Feb-80 22:45")

          (* * Put terminal in binary mode so we can get all 10Q bits and output funny chars
	  at will. Actually, only do this for dm's; other terminals stay in ascii mode, but 
	  with echomode shut off. If ONLYIFCHANGED is true, we do nothing if terminal is 
	  already in correct mode, according to modeword read when we started.)


    [COND
      ((OR (NOT ONLYIFCHANGED)
	   (MODE.CHANGE?))
	(JS SFMOD 100Q (COND
	      (DISPLAYTERMFLG                                         (* Turn off bits 28-29 to get 
								      binary mode)
			      (LOGAND (fetch TTYMODE of TTYINBUFFER)
				      777477Q))
	      (T                                                      (* These bits: wake up on 
								      anything, ascii mode)
		 170100Q)))]
    NIL])

(BREAKLINE
  [LAMBDA (USECR STAY)                                                (* bvm: " 3-Aug-80 22:01")

          (* * Break current line at CURSOR position, inserting a suitable <cr> if USECR is 
	  given. If STAY is true, CURSOR does not move; otherwise cursor moves to first 
	  position of new line.)


    (PROG ((OLDLINE ARROW)
	   (OLDEND (fetch END of ARROW)))
          [COND
	    (USECR                                                    (* flush leading spaces from the
								      segment following the cursor)
		   (bind NEXTWORD_CURSOR while (AND (NEQ NEXTWORD OLDEND)
						    (EQ (CAR NEXTWORD)
							40Q))
		      do (SETQ NEXTWORD (NEXTCHAR NEXTWORD)) finally (COND
								       ((NEQ CURSOR NEXTWORD)
									 (KILLSEGMENT CURSOR NEXTWORD]
          (replace END of ARROW with CURSOR)                          (* terminate current line at 
								      CURSOR position)
          (replace LASTCOL of ARROW with (! CURSORCOL))
          (ERASE.TO.END.OF.LINE)
          (COND
	    (STAY (SAVE.CURSOR)))
          (SETQ ARROW (INSERTLINE ARROW USECR))
          (COND
	    ((NOT STAY)
	      (SAVE.CURSOR)))
          (replace END of ARROW with OLDEND)
          [COND
	    [(EQ CURSOR OLDEND)
	                                                              (* cr was inserted at end of 
								      line. Maybe this never happens)
	      (replace END of ARROW with (SETQ CURSOR (CDR OLDEND]
	    (T (TYPE.BUFFER (SETQ CURSOR (fetch START of ARROW))
			    OLDEND)
	                                                              (* Restore to screen what we 
								      erased above)
	       (replace LASTCOL of ARROW with (! CURSORCOL))
	       (COND
		 ((OVERFLOWLINE? ARROW)
		                                                      (* the previous line overflowed,
								      but when we inserted a cr we 
								      added more space on the line, so
								      go fix it up)
		   (ADJUSTLINE]
          (COND
	    [STAY                                                     (* Oh well, undo what we did to 
								      poor CURSOR)
		  (SETQ CURSOR (fetch END of (SETQ ARROW OLDLINE]
	    (T                                                        (* else strip the blanks from 
								      the line we just left)
	       (STRIPBLANKS OLDLINE)))
          (RESTORE.CURSOR])

(BUFLEN
  [LAMBDA (START END)                                                 (* bvm: "25-Jul-78 23:07")

          (* * Returns number of print positions in buffer from START to END)


    (PROG ((N 0))
      LP  (COND
	    ((EQ START END)
	      (RETURN N)))
          (COND
	    ((NOT (PREFIXCHAR (CAR START)))
	      (ADD1VAR N)))
          (SETQ START (CDR START))
          (GO LP])

(BUFTAILP
  [LAMBDA (TAIL START END)                                            (* bvm: " 2-Aug-78 21:38")
    (while (AND START (NEQ START END)) do (COND
					    ((EQ TAIL START)
					      (RETURN TAIL)))
					  (SETQ START (CDR START])

(CHECK.MARGIN
  [LAMBDA (BUF LINE)                                                  (* bvm: "20-Nov-78 23:59")

          (* * If BUF is the pseudo-cr at the end of this LINE, then back it up one, since 
	  you can't let the cursor sit on it)


    (COND
      ((AND (EQ (fetch END of LINE)
		BUF)
	    (OR (EQ (fetch LASTCOL of LINE)
		    TTYLINELENGTH)
		(EQ (fetch START of (fetch NEXTLINE of LINE))
		    BUF)))
	(TTNLEFT BUF 1 (fetch START of LINE)))
      (T BUF])

(CLEAR.LINE?
  [LAMBDA (ALL)                                                                 (* bvm: "24-Apr-82 14:54")
    (COND
      ((CAPABILITY? ERASE.TO.END)
	(COND
	  (ALL (ERASE.TO.END.OF.PAGE))
	  (T (ERASE.TO.END.OF.LINE])

(COMPLETEWORD
  [LAMBDA (CAUTIOUS MUST.BE.UNIQUE FIRSTMATCH FIRSTCHAR)              (* bvm: " 6-Sep-80 23:11")

          (* Tries to complete the current word from members of SPLST.
	  Does nothing if no word in progress, or this is a comment line.
	  Returns true if some completion done. If CAUTIOUS, only complete if can do so 
	  uniquely and caller permits fixspell; if MUST.BE.UNIQUE set, only do unique 
	  completion. FIRSTMATCH, if supplied, is the first match in SPLST, and FIRSTCHAR 
	  the start of the current word being worked on)


    (PROG (TAIL FIRSTMATCHCHARS SUFFIXCHARS LASTCHAR NEXTCHAR I WORD (UNIQUE T))
          (RETURN (COND
		    ([AND [OR FIRSTCHAR (SETQ FIRSTCHAR (COND
				  ((AT.START.OF.BUF)
				                                      (* Empty buffer. Allow altmode 
								      completion on one-word splst 
								      here)
				    (AND (NOT CAUTIOUS)
					 BUFFER))
				  (T (THISWORD]
			  (OR FIRSTMATCH (SETQ FIRSTMATCH (FINDMATCH (! SPLST)
								     FIRSTCHAR]
		      

          (* Completion may be possible. (CAR MATCH) is the first match in SPLST;
	  FIRSTCHAR is buffer tail where current word starts; NEXTCHAR is the relative 
	  position of cursor in current word, i.e. #chars in word + 1;
	  LASTCHAR is the last char position in common among all words which match.
	  Now run through all other possible matches with the current word, reducing 
	  LASTCHAR to indicate the largest segment in common.)


		      (SETQ NEXTCHAR (SADD1 (BUFLEN FIRSTCHAR CURSOR)))
		      [SETQ LASTCHAR (NCHARS (SETQ FIRSTMATCH (INPART (CAR (SETQ TAIL FIRSTMATCH]
		      (COND
			((OR CAUTIOUS (EQ (SSUB1 NEXTCHAR)
					  LASTCHAR))
			  

          (* The latter case happens if the current word is exactly MATCH.
	  In this case, if there are any other matches they are with words containing MATCH 
	  as initial substring, and thus no further completion is possible)


			  (SETQ MUST.BE.UNIQUE T)))
		      (SETQ SUFFIXCHARS (FNTH (SETQ FIRSTMATCHCHARS (DCHCON FIRSTMATCH CHCONLST1))
					      NEXTCHAR))
		      

          (* unpack FIRSTMATCH for faster tests below. CHCONLST1 is Dwim's scratch list.
	  If user often uses very long words, may want to lengthen this list to reduce cons 
	  usage.)


		      (while (SETQ TAIL (FINDMATCH (CDR TAIL)
						   FIRSTCHAR CURSOR))
			 do (COND
			      (MUST.BE.UNIQUE (RETURN)))
			    (SETQ UNIQUE)
			    (SETQ WORD (INPART (CAR TAIL)))
			    [COND
			      ((find old I from NEXTCHAR to LASTCHAR as REFERENCE in SUFFIXCHARS
				  suchthat (NEQ (NTHCHARCODE WORD I)
						REFERENCE))
				(COND
				  ((EQ I NEXTCHAR)
				                                      (* No characters in common, so 
								      give up)
				    (RETURN))
				  (T                                  (* reset LASTCHAR to last common
								      character)
				     (SETQ LASTCHAR (SSUB1 I]
			 finally 

          (* * chars from NEXTCHAR to LASTCHAR are uniquely determined by prefix so far)


				 (ENDELETE)
				 [PROG (RETYPEIT (BUF FIRSTCHAR))
				       (SETQ I 1)
				   LP1 

          (* * Scan old part of string (part user has typed already) to make sure case is 
	  correct)


				       (COND
					 [(EQ I NEXTCHAR)
					                              (* Done with first part now.
								      Before we go on, retype anything
								      that needed it)
					   (COND
					     ((AND RETYPEIT DISPLAYTERMFLG)
					                              (* If we're capable of 
								      backspacing, go back and right 
								      over input with correct case)
					       (GO.TO (IDIFFERENCE (! CURSORCOL)
								   (BUFLEN RETYPEIT CURSOR)))
					       (TYPE.BUFFER RETYPEIT CURSOR)))
					   (COND
					     ((IGREATERP I LASTCHAR)
					                              (* Happens when entire word is 
								      complete as stands)
					       (RETURN]
					 (T [COND
					      ((NEQ (CAR FIRSTMATCHCHARS)
						    (CAR BUF))
						                      (* Case mismatch, want to fix)
						(FRPLACA BUF (CAR FIRSTMATCHCHARS))
						(OR RETYPEIT (SETQ RETYPEIT BUF]
					    (SETQ FIRSTMATCHCHARS (CDR FIRSTMATCHCHARS))
					    (SETQ BUF (CDR BUF))
					    (ADD1VAR I)
					    (GO LP1)))
				   LP2                                (* Now do second half, the 
								      completion part: add new chars 
								      from NEXTCHAR thru LASTCHAR)
				       (ADDCHAR (CAR FIRSTMATCHCHARS))
				       (COND
					 ((NEQ I LASTCHAR)
					   (SETQ FIRSTMATCHCHARS (CDR FIRSTMATCHCHARS))
					   (ADD1VAR I)
					   (GO LP2]
				 [COND
				   ((AND UNIQUE (NOT CAUTIOUS))
				                                      (* word is unique, so delimit as
								      well)
				     (ADDCHAR 40Q)
				     (COND
				       ((AND (! SPLSTFLG)
					     (NEQ NEXTCHAR 1))
					 

          (* Spelling list maintenance: user completed on this word, so move to front of 
	  spelling list. Don't do it in the trivial case of filling in the entire word 
	  uniquely (as when doing LASTWORD))


					 (MOVETOP FIRSTMATCH (OR (! SPLST)
								 USERWORDS]
				 (RETURN (OR (AND UNIQUE FIRSTMATCH)
					     T])

(CREATE.LINE
  [LAMBDA (START END COL1 LASTCOL ROW NEXT)                           (* bvm: "29-Aug-78 12:13")
    (FRPLNODE (SCRATCHCONS)
	      START
	      (FRPLNODE (SCRATCHCONS)
			END
			(FRPLNODE (SCRATCHCONS)
				  COL1
				  (FRPLNODE (SCRATCHCONS)
					    LASTCOL
					    (FRPLNODE (SCRATCHCONS)
						      ROW NEXT])

(DELETE.TO.END
  [LAMBDA NIL                                                         (* bvm: "20-Mar-80 01:06")

          (* * Kills buffer from CURSOR onward)


    (SETTAIL? T)
    (COND
      (DISPLAYTERMFLG (ERASE.TO.END.OF.PAGE)))
    (COND
      ((fetch NEXTLINE of ARROW)
	                                                              (* There are lines after this, 
								      so return them to garbage heap)
	(KILL.LINES (fetch NEXTLINE of ARROW))
	(replace NEXTLINE of ARROW with NIL)))
    (replace END of ARROW with (SETQ ENDBUFFER CURSOR))
    (replace LASTCOL of ARROW with (! CURSORCOL])

(DELETELINE
  [LAMBDA (LINE EMPTYLINE?)                                           (* bvm: "20-Mar-80 01:04")

          (* Deletes this LINE from buffer and screen; assumes cursor is currently 
	  positioned somewhere on the line. EMPTYLINE? is true on calls from ADJUSTLINE 
	  where the line is naked and hence no text in the buffer needs to be killed.)


    (PROG ((NEXTLINE (fetch NEXTLINE of LINE))
	   OLDSTART NEWSTART PREVLINE)
          [COND
	    ((AND (EQ LINE ARROW)
		  (ON.FIRST.LINE))
	      (COND
		((NOT NEXTLINE)
		                                                      (* Can't delete the only line)
		  (RETURN (BEEP)))
		((NEQ (! PROMPT1)
		      (! PROMPT2))
		                                                      (* tricky to delete first line, 
								      since the correct prompt should 
								      be displayed)
		  (MOVE.BACK.TO BUFFER)
		  (RETURN (FORWARD.DELETE.TO (fetch END of ARROW]
          (COND
	    (DISPLAYTERMFLG (DO.DELETE.LINES 1)))
          (RENUMBER.LINES NEXTLINE (fetch ROW of LINE))
          (replace NEXTLINE of (SETQ PREVLINE (PREVLINE LINE 1)) with NEXTLINE)
          [COND
	    ((NOT NEXTLINE)
	                                                              (* deleting last line: need to 
								      worry about ENDBUFFER and such)
	      (SETQ ENDBUFFER (fetch END of PREVLINE)))
	    (T (replace NEXTLINE of LINE with NIL)
	                                                              (* in preparation for KILL.LINES
								      below)
	       (COND
		 ((NOT EMPTYLINE?)
		   (KILLSEGMENT (SETQ OLDSTART (fetch START of LINE))
				(SETQ NEWSTART (fetch START of NEXTLINE)))
		                                                      (* flush anything on the line.
								      PREVLINE pointers remain valid)
		   (COND
		     ((EQ (fetch END of NEXTLINE)
			  NEWSTART)
		       (replace END of NEXTLINE with OLDSTART)))
		   (replace START of NEXTLINE with OLDSTART]
          (KILL.LINES LINE)                                           (* return to heap)
          (COND
	    ((EQ ARROW LINE)
	                                                              (* if this is our home position,
								      adjust appropriately)
	      (SETQ ARROW (SETQ LINE (OR NEXTLINE PREVLINE)))
	      (SETQ CURSOR (fetch START of LINE))
	      (GO.TO 'LINE LINE])

(DELETETO
  [LAMBDA (TAIL)                                                      (* bvm: " 3-Aug-80 17:13")
    (SETTAIL?)
    (COND
      ((OR (NEQ CURSOR ENDBUFFER)
	   (CAPABILITY? CURSOR))
	(BACKWARD.DELETE.TO TAIL))
      (T [COND
	   [(NOT DISPLAYTERMFLG)
	     (COND
	       ((NOT DELETING)
		                                                      (* prefix deletions with 
								      backslash)
		 (COND
		   ((NOT TTYINBSFLG)
		                                                      (* unless we are going to 
								      physically backspace)
		     (TTBOUT \)))
		 (SETQ DELETING 0)))
	     (DELETETO1 TAIL)
	     (COND
	       ((EQ TAIL BUFFER)
		 (ENDELETE]
	   (T (PROG ((N (BUFLEN TAIL ENDBUFFER)))                     (* need to kill the previous N 
								      chars)
		    (COND
		      ((CAPABILITY? ERASE.TO.END T)
			                                              (* Ah, all we need do is go back
								      N and erase to end)
			(DO.BACK N)
			(ERASE.TO.END.OF.LINE))
		      (T                                              (* laborious technique for glass
								      ttys: go back and wipe out each 
								      char one at a time)
			 (FRPTQ N (PROGN (DO.BACK 1)                  (* back up)
					 (TTBOUT SPACE)               (* overwrite with space)
					 (DO.BACK 1)                  (* and back up again)
					 ]
	 (replace END of ARROW with (SETQ CURSOR (SETQ ENDBUFFER TAIL])

(DELETETO1
  [LAMBDA (TAIL)                                                      (* bvm: " 3-Aug-80 17:13")

          (* * on non-DMs: delete chars until we reach TAIL; since we echo deleted chars in 
	  reverse order, this is most easily done recursively)


    [COND
      ((NEQ (CDR TAIL)
	    ENDBUFFER)
	(DELETETO1 (CDR TAIL]
    [COND
      ((NOT (PREFIXCHAR (CAR TAIL)))
	(SELECTQ TTYINBSFLG
		 (NIL (TTBOUT (CAR TAIL)))
		 (LF 

          (* physically backspace, crossing out character. LF means we will do a LF when 
	  ENDELETE happens. If we don't LF, then best not to cross out chars)


		     (TTBOUT BS \ BS)
		     (ADD1VAR DELETING))
		 (TTBOUT BS]                                          (* echo deleted char)
    (!SETQ CURSORCOL (SSUB1 (! CURSORCOL])

(DO.EXTEND.COMMAND
  [LAMBDA NIL                                                                   (* bvm: "24-Apr-82 15:11")
    (PROG (FILE)
          (SAVE.CURSOR)
      LP  (GO.TO.FREELINE)
          (TTPRIN1 "Command: ")
          (SELCHARQ (TTBIN)
		    [(I i)
		      (TTPRIN1 "Insert file: ")
		      (COND
			((SETQ FILE (TTGETFILE 'OLD))
			  (RESETLST [RESETSAVE (SETQ FILE (OPENFILE FILE 'INPUT))
					       '(PROGN (CLOSEF OLDVALUE]
				    (GO.TO.FREELINE T)
				    (MOVE.TO.WHEREVER CURSOR)
				    (LOADBUFFROMFILE FILE 0 (GETEOFPTR FILE)))
			  (RETURN]
		    [(W w)
		      (TTPRIN1 "Write buffer to file: ")
		      (COND
			((SETQ FILE (TTGETFILE 'NEW))
			  (RESETLST [RESETSAVE (SETQ FILE (OPENFILE FILE 'OUTPUT))
					       '(PROGN (CLOSEF OLDVALUE]
				    (ECHOFILE FILE))
			  (GO.TO.FREELINE)
			  (TTPRIN1 FILE)
			  (MOVE.TO.WHEREVER CURSOR)
			  (RETURN]
		    (? (TTCRLF)
		       (TTPRIN1 "Choices are Insert file, Write to file.  (DEL to do nothing)")
		       (RESTORE.CURSOR)
		       (GO LP))
		    ((DEL Q ^Q ^U)
		      (GO.TO.FREELINE T)
		      (RESTORE.CURSOR)
		      (RETURN))
		    NIL)
          (BEEP)
          (GO LP])

(DO?CMD
  [LAMBDA (CMD)                                                                 (* bvm: "24-Apr-82 14:56")

          (* * Handles "read macros" ? and ?=. CMD is one of those. Returns NIL if thinks it
	  isn't. Saves current cursor location for later restoration)


    (PROG ((BUFFER BUFFER)
	   (START (BACKSKREAD CURSOR))
	   FN ARGS)
          [COND
	    ([NOT (FMEMB (CAR START)
			 '(50Q 133Q]                                            (* Not inside a list now, so not
								      applicable)
	      (RETURN))
	    ((AND (EQ (SCANFORWARD (CAR START)
				   BUFFER)
		      START)
		  (PROGN                                                        (* START is the first paren in 
								      buffer, so check and see if 
								      there's an atom before it)
			 (SETQ FN (TTRATOM))
			 [COND
			   ((OR (EQ FN 'E)
				(AND (EQ (! PROMPT1)
					 '*)
				     (FMEMB FN EDITCOMSL)))                     (* What looks like a fn in apply
								      format is really a command, 
								      either E or an editor command)
			     (SETQ FN (TTRATOM]
			 (EQ (TTSKIPSEPR)
			     START)))                                           (* This is first list on line, 
								      preceded by FN in evalqt format)
	      )
	    (T (SETQ BUFFER (CDR START))                                        (* EVAL form: read fn)
	       (COND
		 ((EQ (SETQ FN (TTRATOM))
		      CMD)                                                      (* Hasn't typed the fn name yet!)
		   (RETURN]
          (SAVE.CURSOR)
          (COND
	    ((XNLSETQ [COND
			((NOT (LITATOM FN))
			  (BEEP))
			((EQ CMD '?)
			  (TERPRI T)
			  (XHELPSYS FN)
			  (TAB 0 0 T))
			(T (GO.TO.FREELINE T)
			   (SETQ ARGS (SMARTARGLIST FN))
			   (TTPRIN1 FN)                                         (* Print just the args so we can
								      do it ourselves simply and keep 
								      track of where we are)
			   (TTPRIN1 '%[)
			   [COND
			     ((NOT ARGS))
			     ((NLISTP ARGS)
			       (TTPRIN1 ARGS)
			       (TTPRIN1 '...))
			     (T (for X on ARGS do (TTPRIN1 (CAR X))
						  (AND (CDR X)
						       (TTPRIN1 ',]
			   (TTPRIN1 '%]]
		      NOBREAK))
	    ((EQ CMD '?=)                                                       (* error occurred, probably 
								      undefined fn, putting the cursor
								      down further)
	      (TTCRLF.ACCOUNT)))
          (RETURN T])

(DOTABS
  [LAMBDA (TABS)                                                      (* bvm: "24-Feb-80 20:29")
                                                                      (* Tab to next tabstop in TABS, 
								      if any. Represent pseudotabs as 
								      prefix chars 240Q.
								      Return T if anything done)
    (AND TABS (AT.END.OF.BUF)
	 (for TB in TABS bind SPACES when (AND (SMALLP TB)
					       (SGREATERP (SETQ SPACES (SDIFFERENCE TB (! CURSORCOL)))
							  0))
	    do (OVERFLOW? SPACES)
	       (INSERT.CHAR.IN.BUF 240Q)                              (* Stick in a pseudo-tab)
	       (FRPTQ SPACES (ADDCHAR 440Q))                          (* Echo as spaces)
	       (RETURN T])

(ECHOFILE
  [LAMBDA (FILE DRIBBLING)                                            (* bvm: "23-Jun-79 20:56")

          (* * Echos input to FILE. If DRIBBLING is true, the prompts are also echoed)


    (for (JFN _(VAG (OPNJFN FILE)))
	 (LINE _(! FIRSTLINE))
	 FIRSTIME_T
	 X END do (COND
		    ([AND DRIBBLING (SETQ X (COND
			      (FIRSTIME (SETQ FIRSTIME NIL)
					(! PROMPT1))
			      (T (! PROMPT2]
		      (PRIN1 X FILE)))
		  (SETQ END (fetch END of LINE))
		  (SETQ X (fetch START of LINE))
		  (until (EQ X END) do [COND
					 ((EQ (CAR X)
					      240Q)
					                              (* pseudo-tab kludge: instead of
								      printing the "real" character, 
								      ignore it and print only its 
								      padding spaces)
					   (SETQ X (CDR X]
				       (JS BOUT (LOC JFN)
					   (LOC (CAR X)))
				       (SETQ X (NEXTCHAR X)))
		  (SETQ LINE (fetch NEXTLINE of LINE))
		  (COND
		    ((OR DRIBBLING (NEQ (fetch START of LINE)
					END))
		                                                      (* Don't terpri on overflow 
								      line, since user didn't;
								      except always do it to 
								      dribblefile, since that's what's
								      on the screen)
		      (TERPRI FILE)))
       repeatwhile (AND LINE (OR (EQ END ENDBUFFER)
				 (NEQ (fetch START of LINE)
				      ENDBUFFER)))
       comment                                                        (* Second clause avoids echoing 
								      the terminating empty line, 
								      except when it is an empty 
								      overflow line)])

(EDITCHAR
  [LAMBDA (CHAR EDITARG)                                                        (* bvm: "24-Apr-82 15:11")

          (* * Handles the various edit commands, which mostly move the cursor around in the
	  buffer, or kill pieces of it. CHAR is the character stripped of its editbit.
	  EDITARG is the argument, if any (not set by type-in, but by program asking for a 
	  particular edit function). If this routine returns something, it means process it 
	  like ordinary character (this is how we can invoke non-editbit routines))


    (PROG (EDITMINUS L X)
          [COND
	    ((NOT EDITARG)
	      (SETQ EDITARG 1))
	    ((MINUSP EDITARG)
	      (SETQ EDITMINUS T)
	      (SETQ EDITARG (SABS EDITARG]
      LP  [SELCHARQ (SETQ CHAR (U-CASECODE CHAR))
		    [CR 

          (* <edit>CR on empty buffer means get back last buffer; in the middle of a buffer it is the same as 
	  normal CR, but also ends insert mode)


			(COND
			  ((EMPTY.BUFFER)
			    (RESTOREBUF))
			  ((ON.LAST.LINE)
			    (RETURN CHAR))
			  (T (MOVE.TO.LINE (NEXTLINE ARROW EDITARG]
		    [(SPACE >)                                                  (* space or > moves right)
		      (COND
			(EDITMINUS (SETQ CHAR 177Q)                             (* backward space is delete)
				   (GO NOMINUS))
			((AT.END.OF.BUF)
			  (BEEP))
			((AT.END.OF.SCREEN)
			  (MOVE.TO.NEXT.LINE))
			(T (MOVE.FORWARD.TO (TTNTH CURSOR EDITARG]
		    [(RUBOUT <)                                                 (* delete or < backs up)
		      (COND
			(EDITMINUS (SETQ CHAR 40Q)                              (* backward delete is space)
				   (GO NOMINUS))
			((AT.START.OF.BUF)
			  (BEEP))
			((AT.START.OF.LINE)
			  (MOVE.TO.LINE (SETQ X (PREVLINE ARROW 1))
					(fetch END of X)))
			(T (MOVE.BACK.TO (TTNLEFT CURSOR EDITARG]
		    [%(                                                         (* lp backs up one word)
			(COND
			  (EDITMINUS (SETQ CHAR 51Q)
				     (GO NOMINUS))
			  (T (MOVE.BACK.TO (PREVWORD CURSOR EDITARG]
		    [%)                                                         (* rp moves ahead one word)
			(COND
			  (EDITMINUS (SETQ CHAR 50Q)
				     (GO NOMINUS))
			  ((AT.END.OF.SCREEN)
			    (BEEP))
			  (T (MOVE.FORWARD.TO (NEXTWORD CURSOR EDITARG]
		    (TAB                                                        (* tab: go to end of line)
			 (MOVE.TO.LINE (SETQ X (NEXTLINE ARROW (SUB1VAR EDITARG)))
				       (fetch END of X)))
		    [FF                                                         (* FF go to start of line)
			(MOVE.TO.LINE (PREVLINE ARROW (SUB1VAR EDITARG]
		    ({                                                          (* { goes to start of buffer, 
								      like infinite FF)
		       (MOVE.TO.LINE (! FIRSTLINE)))
		    (}                                                          (* } goes to end of buffer, like
								      infinite TAB)
		       (MOVE.TO.LINE (SETQ X (LASTLINE))
				     (fetch END of X)))
		    [LF                                                         (* LF moves down)
			(COND
			  (EDITMINUS (SETQ CHAR 136Q)
				     (GO NOMINUS))
			  [(ON.LAST.LINE)
			    (COND
			      ((EMPTY.BUFFER)                                   (* Treat this the same as 
								      regular linefeed, i.e. restore 
								      buffer)
				(RETURN 12Q))
			      (T (BEEP]
			  (T (MOVE.TO.LINE (SETQ X (NEXTLINE ARROW EDITARG))
					   (NTH.COLUMN.OF X (EDITCOLUMN]
		    [^                                                          (* ^ moves up)
		       (COND
			 (EDITMINUS (SETQ CHAR 12Q)
				    (GO NOMINUS))
			 ((ON.FIRST.LINE)
			   (BEEP))
			 (T (MOVE.TO.LINE (SETQ X (PREVLINE ARROW (SMIN (SPLUS (! LOC.ROW.0)
									       (! CURSORROW))
									EDITARG)))
					  (NTH.COLUMN.OF X (EDITCOLUMN]
		    [K                                                          (* K kills one char)
		       (COND
			 ((AT.END.OF.LINE)
			   (BEEP))
			 (T (FORWARD.DELETE.TO (TTNTH CURSOR EDITARG]
		    [I                                                          (* I inserts)
		       [COND
			 ((NEQ EDITARG 1750Q)

          (* $$I inserts line on any terminal; on EDIT-key terminals, we also allow TV's 
	  silly method of saying $I<cr>, so have to peek at the next char)


			   (COND
			     ((NOT (CAPABILITY? EDIT))                          (* Can't type edit chars, so can't type 
										<edit>return)
			       (OR (AT.END.OF.LINE)
				   (SETQ INSERTING T))
			       (RETURN))
			     ((NOT (PROGN (SETQ CHAR (TTBIN))
					  EDITBIT))                             (* Next char has editbit off,  |
						just return it as something to |
						insert)
			       (OR (AT.END.OF.LINE)
				   (SETQ INSERTING T))
			       (RETURN CHAR))
			     ((NEQ CHAR 15Q)                                    (* editbit shuts off insert 
								      mode)
			       (SETQ EDITARG 1)
			       (GO NOMINUS]                                     (* I<cr> means insert blank line IN 
										FRONT OF this line and stay on it)
		       (COND
			 ((ON.FIRST.LINE)                                       (* Difficult to insert line in 
								      front of first, so use plan b)
			   (MOVE.BACK.TO BUFFER)
			   (BREAKLINE 37Q)
			   (MOVE.TO.LINE (! FIRSTLINE)))
			 (T (GO.TO NIL (SSUB1 (! CURSORROW)))                   (* Since INSERTLINE thinks 
								      you're on the previous line)
			    (INSERTLINE (PREVLINE ARROW 1)
					37Q)
			    (SETQ CURSOR (fetch START of (SETQ ARROW (PREVLINE ARROW 1]
		    ((S Z B)                                                    (* S, Z, B various skip or zap 
								      commands)
		      (SKIP/ZAP CHAR (TTBIN)
				EDITARG EDITMINUS))
		    [A                                                          (* Again or Repeat repeats last 
								      S or Z)
		       (COND
			 ((! LASTSKIP)
			   (SKIP/ZAP (! LASTSKIP)
				     (! LASTSKIPCHAR)
				     EDITARG EDITMINUS))
			 (T (BEEP]
		    (L                                                          (* L lowercase word)
		       (U/L-CASE EDITARG))
		    (U                                                          (* U uppercase word)
		       (U/L-CASE EDITARG T))
		    (C                                                          (* C capitalize word)
		       (U/L-CASE EDITARG 1))
		    [G                                                          (* G grabs a copy of Nth 
								      previous line)
		       (COND
			 ((OR (ON.FIRST.LINE)
			      (NOT (AT.END.OF.LINE))
			      (EQ (SETQ X (NTH.COLUMN.OF (SETQ L (PREVLINE ARROW EDITARG))
							 (! CURSORCOL)))
				  (fetch END of L)))                            (* nothing to copy)
			   (BEEP))
			 (T (READFROMBUF X (fetch END of L)
					 T]
		    [%]                                                         (* "]" Move to end of current 
										expression)
			(COND
			  ((AT.END.OF.BUF)
			    (BEEP))
			  (T (MOVE.TO.WHEREVER (OR (TTSKREAD (NEXTCHAR CURSOR))
						   ENDBUFFER]
		    [%[                                                         (* "[" Move to start of current list 
										expression)
			(COND
			  ((AT.START.OF.BUF)
			    (BEEP))
			  (T (MOVE.TO.WHEREVER (BACKSKREAD CURSOR]
		    [^W                                                         (* ^W delete current word)
			(COND
			  ((EMPTY.LINE)                                         (* empty buffer)
			    (BEEP))
			  ((OR INSERTING EMACSFLG)                              (* Don't want to delete whole word, just
										what's before the cursor)
			    (BACKWARD.DELETE.TO (PREVWORD CURSOR EDITARG)))
			  (T [SETQ X (OR (AT.END.OF.LINE)
					 (NOT (FMEMB (CAR CURSOR)
						     '(50Q 51Q 133Q 135Q]

          (* X is true if not sitting on a paren, in which case we want to treat parens as 
	  spaces; if on a paren, then allow below to delete parens as well)


			     (MOVE.TO.START.OF.WORD)
			     (FORWARD.DELETE.TO (NEXTWORD CURSOR EDITARG X]
		    (^Y                                                         (* ^Y gets userexec)
			(COND
			  ((AND (EQ EDITARG 1750Q)
				(NEQ CURSOR ENDBUFFER))
			    (UNREADBUF)                                         (* Stuff what's ahead of cursor 
								      into input buffer)
			    ))
			(SETQ EDITBIT T)
			(RETURN CHAR))
		    [(^Q ^U)                                                    (* ^Q, or ^U for tops20 folk)
		      (COND
			((EQ EDITARG 1750Q)
			  (DELETE.TO.END))
			(T (DELETELINE ARROW]
		    [D                                                          (* D)
		       (COND
			 [EMACSFLG                                              (* EMACS interpretation is 
								      delete to end of word)
				   (COND
				     ((AT.END.OF.LINE)
				       (BEEP))
				     (T (COND
					  ((AND (NEQ (SETQ X (NEXTWORD CURSOR EDITARG T))
						     (fetch END of ARROW))
						(NOT (AT.START.OF.LINE))
						[NOT (SPACE/PARENP (CAR (TTNLEFT CURSOR 1]
						[SPACEP (CAR (SETQ L (TTNLEFT X 1 CURSOR]
						(NEQ L CURSOR))

          (* Don't want to delete all the way to start of new word, since we'd like a little space in between.
	  Simulating EMACS would probably be easier if we just made NEXTWORD stop at the intervening spaces 
	  rather than at the end)


					    (SETQ X L)))
					(FORWARD.DELETE.TO X]
			 (T                                                     (* D is TVEDIT's delete command 
								      -- convert it to appropriate 
								      cmd)
			    (SELECTQ (TTBIN)
				     (15Q (SETQ CHAR 21Q)
					  (GO LP))
				     (177Q (SETQ CHAR 27Q)
					   (GO LP))
				     (BEEP]
		    [F                                                          (* F: accept tvedit's $$F to finish)
		       (COND
			 [(EQ EDITARG 1750Q)
			   (MOVE.TO.WHEREVER ENDBUFFER)
			   (COND
			     ((NEQ CURSOR ENDBUFFER)                            (* This is because the cursor 
								      mover refuses to put me in 
								      column 120Q of a line, due to 
								      certain anomalies)
			       (!SETQ CURSORCOL (SPLUS (! CURSORCOL)
						       (BUFLEN CURSOR ENDBUFFER)))
			       (SETQ CURSOR ENDBUFFER)
			       (OVERFLOW? 0)))
			   (RETURN (COND
				     (REPEAT                                    (* End with ^Z)
					     32Q)
				     (READING                                   (* End read with "]"; of course,
								      this doesn't always "finish", 
								      but it's simple enough to 
								      remember what this is)
					      135Q)
				     (T 15Q]
			 (T (BEEP]
		    (J                                                          (* J: Justify/fill line)
		       (ADJUSTLINE.AND.RESTORE EDITARG))
		    (-                                                          (* minus sign negates arg)
		       (SETQ EDITARG 0)
		       (SETQ EDITMINUS T)
		       (GO DONUMBERS))
		    (ESCAPE                                                     (* ESCAPE may modify next 
								      command)
			    (COND
			      ((AND (EQ EDITARG 1750Q)
				    (EQ EDITPREFIXCHAR 33Q))                    (* 3 escapes in a row is the way to type
										a regular Escape when Escape is the edit
										prefix. Better ways might be 
										forthcoming)
				(RETURN 33Q)))
			    (SETQ EDITARG 1750Q)                                (* 1750Q is an adequate infinity for 
										these purposes)
			    (SETQ EDITMINUS)
			    (SETQ CHAR (TTBIN))
			    (GO LP))
		    [(N ^R)                                                     (* N or ^R: refresh n lines, or 
								      whole buffer for $N)
		      (COND
			((EQ EDITARG 1750Q)
			  (RETYPE (! FIRSTLINE)
				  T))
			(EDITMINUS (RETYPE (PREVLINE ARROW EDITARG)
					   ARROW))
			(T (RETYPE ARROW (NEXTLINE ARROW EDITARG]
		    [T                                                          (* T -- transpose chars.
								      If at end of line, do preceding 
								      two, else do the ones before and
								      after the cursor.)
		       [SETQ L (TTNLEFT CURSOR (SETQ X (COND
					    ((AT.END.OF.LINE)
					      2)
					    (T 1]                               (* L is start of swap)
		       (COND
			 ((OR (EQ L CURSOR)
			      (PREFIXCHAR (CAR L))
			      (AND (EQ X 2)
				   (EQ (CDR L)
				       CURSOR))
			      (PREFIXCHAR (CADR L)))                            (* Complain if not enough chars 
								      to swap, or one of them is a 
								      funny multiple char 
								      (I'm lazy))
			   (BEEP))
			 (T [FRPLACA L (PROG1 (CADR L)
					      (FRPLACA (CDR L)
						       (CAR L]                  (* Do the swap in the buffer)
			    (GO.TO (SDIFFERENCE (! CURSORCOL)
						X))                             (* And now back up and fix the 
								      display)
			    (TYPE.BUFFER L (CDDR L))
			    (COND
			      ((EQ X 1)                                         (* Were between two chars, so 
								      get back there)
				(DO.BACK 1)
				(!SETQ CURSORCOL (SSUB1 (! CURSORCOL]
		    (O                                                          (* O -- Open line, i.e. insert 
								      <cr> but stay here)
		       (BREAKLINE 37Q T))
		    [_                                                          (* _ Special hack: says to add the word 
										before the cursor to USERWORDS, so I can
										use altmode completion on it)
		       (COND
			 [(AND TTYINCOMPLETEFLG (SETQ X (THISWORD))
			       [SETQ X (PROG ((BUFFER X))
					     (RETURN (TTRATOM]
			       (LITATOM X))
			   (COND
			     ((ZEROP EDITARG)                                   (* Means to remove! I don't know
								      if there's an "official" way to 
								      do this)
			       (DREMOVE X USERWORDS))
			     (T (ADDSPELL X 0]
			 (T (BEEP]
		    (NULL                                                       (* Edit-null = edit-prefix)
			  (SETQ CHAR (TTBIN))
			  (GO LP))
		    (X                                                          (* Extend commands)
		       (ERSETQ (DO.EXTEND.COMMAND)))
		    (COND
		      ((SETQ CHAR (EDITNUMBERP CHAR))
			(SETQ EDITARG CHAR)
			(GO DONUMBERS))
		      (T (BEEP]
          (!SETQ LASTCHAR CHAR)
          (RETURN)
      NOMINUS
          (SETQ EDITMINUS)
          (GO LP)
      DONUMBERS

          (* * scanning a numeric arg. EDITARG is its magnitude; EDITMINUS set if negative.
	  <edit>escape is treated as 1000, which is probably big enough.
	  Doesn't matter if any of the next chars has edit bit on, since once we start a 
	  number, any other digits must be part of it, since numbers aren't themselves 
	  commands)


          (COND
	    ([SETQ X (EDITNUMBERP (SETQ CHAR (TTBIN]
	      [SETQ EDITARG (COND
		  ((SGREATERP EDITARG 144Q)                                     (* Limit numeric args to 1750Q 
								      so small number stuff works)
		    1750Q)
		  (T (SPLUS (ITIMES (@S EDITARG)
				    12Q)
			    X]
	      (GO DONUMBERS)))
          (COND
	    ((AND EDITMINUS (ZEROP EDITARG))                                    (* Happens if we get a "-" 
								      followed by no number)
	      (SETQ EDITARG 1)))
          (GO LP])

(EDITCOLUMN
  [LAMBDA NIL                                                         (* bvm: "24-Jun-79 01:58")

          (* If last edit command moved up/down, then return the same column we were using 
	  then; else use current cursor column, and record it as the "goal" column for any 
	  future such commands)


    (COND
      ((FMEMB (! LASTCHAR)
	      '(12Q 136Q))
	(! HOMECOL))
      (T (!SETQ HOMECOL (! CURSORCOL])

(ENDELETE
  [LAMBDA NIL                                                         (* bvm: " 3-Aug-80 17:14")
    (COND
      (DELETING (SELECTQ TTYINBSFLG
			 (NIL (TTBOUT \))
			 [LF (COND
			       ((SGREATERP DELETING 1)
				                                      (* if more than one char x'd 
								      out, lf to new line)
				 (TTBOUT LF]
			 NIL)
		(SETQ DELETING NIL])

(ENDREAD?
  [LAMBDA NIL                                                         (* bvm: "24-Feb-80 21:54")

          (* Return true if the paren/bracket just typed terminates the input.
	  It does if the right paren (or even one earlier in buffer) is in excess, i.e 
	  unbalanced, or just balances and this is the only list on the line, or we are 
	  doing a LISPX input and the input is in EVALQT form, with no space after the first
	  atom)


    (PROG (X)
          (RETURN
	    (AND
	      (AT.END.OF.TEXT CURSOR)
	      (SETQ X (TTSKREAD BUFFER))
	      (OR
		(NEQ X ENDBUFFER)
		(AND
		  [SELECTQ
		    (CAR (SETQ X (FIRSTWORD BUFFER)))
		    ((50Q 133Q)
		                                                      (* OK, line started with 
								      paren/bracket)
		      T)
		    (AND
		      (EQ READING 'EVALQT)
		      (NEQ (! PROMPT1)
			   '*)
		      (while (NEQ X ENDBUFFER)
			 do                                           (* Skip over this first atom, to
								      see if input is in EVALQT form.
								      Prompt check is so we don't do 
								      this in the editor)
			    (SELECTQ (REALBITS (CAR X))
				     ((40Q 11Q 32Q 42Q)
				                                      (* Space, etc: probably wants 
								      more on line)
				       (RETURN NIL))
				     [(50Q 133Q)
				                                      (* Open paren/bracket: looks 
								      good)
				       (RETURN
					 (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN (PROGN 
                                                                      (* Prettyprint sucks again!)
											  T]
				     (45Q                             (* Skip over % )
					  (SETQ X (CDR X)))
				     NIL)
			    (SETQ X (CDR X]
		  (EQ (CDR (TTSKREAD (CDR X)))
		      CURSOR])

(FIND.LINE
  [LAMBDA (BUF)                                                       (* bvm: "24-Feb-80 00:29")

          (* * Returns the buffer LINE on which BUF, a cursor position, occurs)


    (for (LINE _(! FIRSTLINE)) do (COND
				    ([BUFTAILP BUF (fetch START of LINE)
					       (COND
						 ((OVERFLOWLINE? LINE)
						   (fetch END of LINE))
						 (T (CDR (fetch END of LINE]
				      (RETURN LINE)))
				  (OR (SETQ LINE (fetch NEXTLINE of LINE))
				      (SHOULDNT])

(FINDBREAK
  [LAMBDA (START END USELAST)                                         (* bvm: "25-Aug-78 23:21")

          (* * Locates a place between START and END where line can be broken.
	  If USELAST is true, returns last such place, else first)


    (while (NEQ START END) do [COND
				((EQ (CAR START)
				     40Q)
				  (COND
				    (USELAST (SETQ $$VAL START))
				    (T (RETURN START]
			      (SETQ START (NEXTCHAR START])

(FINDMATCH
  [LAMBDA (WORDS START BUFTAIL)                                       (* bvm: " 6-Sep-80 15:06")

          (* Find the first word in spelling list WORDS which matches the characters in the 
	  buffer from START to BUFTAIL (or current cursor position), and return the 
	  corresponding tail of WORDS)


    (OR BUFTAIL (SETQ BUFTAIL CURSOR))

          (* * find TAIL on WORDS suchthat (for I from 1 as CHAR in START always CHAR = 
	  (NTHCHAR (CAR TAIL) I)))


    (for TAIL on WORDS do (ASSEMBLE NIL
				    (CQ (CAR TAIL))
				    (CQ2 SPELLSTR1)                   (* Check for special spelling 
								      list markers)
				    (CAMN 1 , 2)
				    (JRST SPELLMARKER)
				    (CQ2 SPELLSTR2)
				    (CAMN 1 , 2)
				    (JRST SPELLMARKER)
				    (CQ (INPART (AC)))
				    (STN 'STPTT)
				    (JRST OK)                         (* String pointer is ok)
				    (STE 'ATOMT)
				    (JRST ITERATE:)                   (* Not atom or string;
								      can't handle)
				    (CQ (fetch PNAME of (AC)))
				OK  (FASTCALL UPATM)                  (* Get byte pointer for word in 
								      ac3, length in ac4)
				    (CQ START)
				    (CQ2 BUFTAIL)
				    (JRST TST)
				LP  (ILDB 5 , 3)                      (* get next char of WORD)
				    (HRRZ 6 , 0 (1))
				    (SUBI 6 , ASZ)                    (* and char from buffer)
				    (CAMN 6 , 5)
				    (JRST EQCHAR)                     (* ... chars match)
				    (TRC 5 , 40Q)
				    (CAME 6 , 5)                      (* Compare against inverted 
								      case)
				    (JRST ITERATE:)                   (* ... failed)
				    (IORI 5 , 40Q)

          (* cheap match for "inverted case" succeeded, but now check to make sure it was 
	  actually a letter. Didn't do this earlier, because the cheap test almost always 
	  fails anyway.)


				    (CAIL 5 , (CHCON1 "a"))
				    (CAILE 5 , (CHCON1 "z"))
				    (JRST ITERATE:)                   (* ... match failed after all, 
								      so move along)
				EQCHAR                                (* at this point, char in word 
								      and char in buf match)
				    (CDR1)
				TST (CAMN 1 , 2)                      (* End of buffer yet?)
				    (JRST SUCCESS:)                   (* ... yes, match succeeds)
				    (SOJGE 4 , LP)
				    (JRST ITERATE:)                   (* ... word is too short)
				SUCCESS:
				    (CQ (RETURN TAIL))
				SPELLMARKER                           (* Come here when we noticed a 
								      spelling marker; means this is a
								      lisp-style spelling list)
				    (CQ (!SETQ SPLSTFLG (AC)))
				ITERATE:])

(FIRSTWORD
  [LAMBDA (BUF END)                                                   (* bvm: "27-Jul-78 01:16")

          (* * Returns position of first word, i.e. non-space, in BUF before END)


    (OR END (SETQ END ENDBUFFER))
    (while (AND (NEQ BUF END)
		(SPACEP (CAR BUF)))
       do (SETQ BUF (CDR BUF)))
    BUF])

(FIXWORD
  [LAMBDA (WORD)                                                      (* bvm: " 6-Sep-80 12:55")

          (* * Returns WORD, possibly corrected, according to the spelling list, if any.
	  Returns NIL if FIX was specified and the word fails.)


    (PROG (X (SPLST (! SPLST)))
          (RETURN (COND
		    ((OR (NULL SPLST)
			 (FMEMB WORD '(%( %) %[ %] %" ,))
			 (FMEMB WORD SPLST))
		      WORD)
		    ((AND WORD (SETQ X (FASSOC WORD SPLST)))
		                                                      (* Is synonym. FASSOC assumes 
								      car of atom is NIL)
		      (CDR X))
		    ([AND SPLST (LITATOM WORD)
			  (NEQ NOFIXSPELL 'NOFIXSPELL)
			  (SETQ X (FIXSPELL WORD 106Q SPLST (AND NOFIXSPELL T)
					    NIL NIL NIL (NOT (! SPLSTFLG]
		                                                      (* respelled okay)
		      X)
		    ((! FIX)
		      (TTPRIN1 WORD)
		      (TTPRIN1 '?)
		      (COND
			((! HELP)
			  (GIVEHELP (! HELP)))
			(T (TTPRIN1 "  please try again.")))
		      (TERPRI T)
		      NIL)
		    (T WORD])

(FORWARD.DELETE.TO
  [LAMBDA (BUFTAIL)                                                   (* bvm: "24-Feb-80 03:23")

          (* * Delete from CURSOR to BUFTAIL. Cursor does not move)


    [COND
      ((EQ BUFTAIL CURSOR)
	                                                              (* Nothing to do))
      ((EQ BUFTAIL ENDBUFFER)
	                                                              (* deleting to end is simple)
	(ERASE.TO.END.OF.LINE)
	(replace END of ARROW with (SETQ ENDBUFFER CURSOR))
	(replace LASTCOL of ARROW with (! CURSORCOL)))
      (T (PROG ((#DELETED (BUFLEN CURSOR BUFTAIL))
		L)
	       (COND
		 ((EQ BUFTAIL (fetch END of ARROW))
		                                                      (* End pointer is about to 
								      disappear into free list, so 
								      move it back here)
		   (replace END of ARROW with CURSOR)
		   [COND
		     ((EQ (fetch START of (SETQ L (fetch NEXTLINE of ARROW)))
			  BUFTAIL)
		       (replace START of L with CURSOR)
		       (COND
			 ((EQ (fetch END of L)
			      BUFTAIL)
			   (replace END of L with CURSOR]
		   (ERASE.TO.END.OF.LINE))
		 (T (DELNCHARS #DELETED BUFTAIL (fetch END of ARROW)
			       T)))
	       (KILLSEGMENT CURSOR BUFTAIL)
	       (replace LASTCOL of ARROW with (SDIFFERENCE (fetch LASTCOL of ARROW)
							   #DELETED))
	       (COND
		 ((OVERFLOWLINE? ARROW)
		   (ADJUSTLINE.AND.RESTORE]
    CURSOR])

(GIVEHELP
  [LAMBDA (HELPKEY)                                                   (* bvm: " 8-Aug-80 00:11")
    (RESETLST (PROG ((CTRLO! CTRLO!))
		    (RESETSAVE (OUTPUT T))
		    (COND
		      ((AND (NOT CTRLO!)
			    (FGETD 'CTRLO!))
			                                              (* Enable ^O interrupt unless 
								      already done)
			(RESETSAVE (INTERRUPTCHAR 17Q '(CTRLO!)
						  T))
			(SETQ CTRLO! T)))
		    (TERPRI)
		    (COND
		      ((EQ HELPKEY T)
			(GIVEHELP1))
		      [(LISTP HELPKEY)
			(COND
			  ((EQ (CAR HELPKEY)
			       T)
			                                              (* List SPLST first, then 
								      subsequent blurb)
			    (GIVEHELP1 T)
			    (PRIN1 '% )
			    (GIVEHELP2 (CDR HELPKEY)
				       T))
			  ((EQ (CDR HELPKEY)
			       T)
			                                              (* Similar, but blurb first)
			    (GIVEHELP2 (CAR HELPKEY)
				       T)
			    [COND
			      ((NOT (ZEROP (POSITION)))
				(PRIN1 '% ]
			    (GIVEHELP1 T T))
			  (T (GIVEHELP2 HELPKEY]
		      (T (GIVEHELP2 HELPKEY)))
		    (COND
		      ((NOT (ZEROP (POSITION)))
			(TERPRI)))
		    (TERPRI)
		    (RETURN T])

(GIVEHELP1
  [LAMBDA (NO.OTHER NO.INTRO)                                         (* bvm: " 7-Aug-80 23:44")
    (COND
      ((! SPLST)
	(OR NO.INTRO (PRIN1 "Please select from among "))
	(for X on (! SPLST) unless (OR (EQ X SPELLSTR1)
				       (EQ X SPELLSTR2))
	   do (PRIN1 (INPART (CAR X)))
	      (AND (CDR X)
		   (PRIN1 ", ")))
	(COND
	  ((NOT NO.OTHER)
	    (OR (! FIX)
		(PRIN1 ", or other"))
	    (TERPRI])

(GIVEHELP2
  [LAMBDA (HELPKEY MIXED)                                             (* bvm: " 8-Aug-80 00:14")
    (COND
      [[OR (LITATOM HELPKEY)
	   (AND (STRINGP HELPKEY)
		(NOT (STRPOS '%  HELPKEY]
	                                                              (* Atom or spaceless string is a
								      hashfile key)
	(COND
	  ((NOT (DISPLAYHELP HELPKEY))
	    (OR MIXED (PRIN1 "Sorry, no help available."]
      (T (SPRINTT HELPKEY (COND
		    (MIXED                                            (* no extra space)
			   0)
		    (T 4))
		  4 0])

(GO.TO
  [LAMBDA (COL ROW)                                                   (* bvm: "26-Feb-80 01:32")

          (* * Moves cursor to indicated row/col. ROW arg may be omitted if the movement is 
	  on the same row. If COL=LINE then ROW is interpreted as a LINE record, and 
	  destination is the start of that line)


    [PROG ((FROMROW (! CURSORROW))
	   (FROMCOL (! CURSORCOL)))
          (COND
	    ((EQ COL 'LINE)
	      (SETQ COL (fetch FIRSTCOL of ROW))
	      (SETQ ROW (fetch ROW of ROW)))
	    ((NOT COL)
	      (SETQ COL FROMCOL))
	    ((NOT ROW)
	      (SETQ ROW FROMROW)))
          (COND
	    ((EQ FROMCOL TTYLINELENGTH)
	      (SETQ FROMCOL 0)
	      

          (* Cursor is logically at the end of the line, but on a dm, an auto crlf has 
	  occurred, so cursor is really at start of next line)


	      (TTBOUT CR LF)
	                                                              (* This is supposed to work 
								      (i.e. autocr means a crlf now is
								      ignored), but what if something 
								      was sent between then and now?)
	      (ADD1VAR FROMROW)))
          (COND
	    ((EQ COL TTYLINELENGTH)
	                                                              (* This shouldn't happen, but it
								      can if there is a line that 
								      fills the screen line but ends 
								      in a cr)
	      (SETQ COL 0)
	      (ADD1VAR ROW)))
          [COND
	    ((NOT DISPLAYTERMFLG)
	                                                              (* Can't actually move cursor)
	      (RETURN))
	    ((AND (CAPABILITY? CURSOR T)
		  (COND
		    ((EQ ROW FROMROW)
		      (SGREATERP (SABS (SDIFFERENCE COL FROMCOL))
				 1))
		    ((EQ COL FROMCOL)
		      (SGREATERP (SABS (SDIFFERENCE ROW FROMROW))
				 1))
		    (T T)))
	                                                              (* If moving very far, use 
								      cursor addressing)
	      (RETURN (GO.TO.ADDRESSING COL ROW)))
	    ((SLESSP FROMCOL COL)
	                                                              (* Only way to move forward is 
								      one position at a time)
	      (DO.FORWARD (SDIFFERENCE COL FROMCOL)))
	    ((SLESSP (SPLUS COL 2)
		     (SDIFFERENCE FROMCOL COL))
	      

          (* Moving backward to a position which is closer to left margin than to the 
	  current position, so do it by a CR first. Note: this assumes that moving backward 
	  and moving forward are equally expensive; probably terminal-dependent)


	      (COND
		((SLESSP FROMROW ROW)
		                                                      (* Already above where we are 
								      going, so CR will take us down 1
								      row as well as putting us in col
								      0)
		  (ADD1VAR FROMROW))
		(T (DO.UP 1)))
	      (TTBOUT CR LF)
	      

          (* actually, CR alone suffices, except that if the next char we output is a LF, it
	  will be ignored, so do the LF anyway to avoid confusion. Besides, some clowns 
	  tried to simulate a datamedia and forgot this not very desirable feature, and thus
	  we will be able to work on those terminals, too)


	      (DO.FORWARD COL))
	    (T (DO.BACK (SDIFFERENCE FROMCOL COL]
          (COND
	    ((EQ FROMROW ROW)
	                                                              (* No row adjustment))
	    ((SGREATERP FROMROW ROW)
	      (DO.UP (SDIFFERENCE FROMROW ROW)))
	    (T (DO.DOWN (SDIFFERENCE ROW FROMROW]
    (!SETQ CURSORROW ROW)
    (!SETQ CURSORCOL COL])

(GO.TO.ADDRESSING
  [LAMBDA (COL ROW)                                                   (* bvm: "23-Feb-80 23:31")
                                                                      (* Regardless of where we are 
								      now, go to logical position 
								      COL,ROW using cursor addressing)
    (PROG ((ABSROW (SPLUS (! LOC.ROW.0)
			  ROW)))
          (SET.CURSOR COL (COND
			((SLESSP ABSROW 0)
			                                              (* trying to go beyond top of 
								      screen; ideally we should 
								      scroll, but for now just forbid 
								      it)
			  (SETQ ROW (SDIFFERENCE ROW ABSROW))
			  0)
			((NOT (SLESSP ABSROW TTYPAGELENGTH))
			                                              (* This shouldn't happen at all 
								      until we can scroll!)
			  (SETQ ROW (SPLUS (SDIFFERENCE ROW ABSROW)
					   TTYPAGELENGTH -1))
			  (SSUB1 TTYPAGELENGTH))
			(T ABSROW)))
          (!SETQ CURSORROW ROW)
          (!SETQ CURSORCOL COL])

(GO.TO.FREELINE
  [LAMBDA (ALL)                                                                 (* bvm: "24-Apr-82 14:54")

          (* * Moves cursor to the first free line after the buffer, and clears it)


    (GO.TO NIL (fetch ROW of (LASTLINE)))                                       (* Put the cursor on the last 
								      row of buffer)
    (TTCRLF)                                                                    (* And down one more)
    (CLEAR.LINE? ALL])

(INIT.CURSOR
  [LAMBDA (COL)                                                       (* bvm: "23-Feb-80 23:35")

          (* * Initializes cursor accounting, assuming/forcing the cursor to be in column 
	  COL of the bottom row of the screen)


    (!SETQ LOC.ROW.0 (SSUB1 TTYPAGELENGTH))
    [COND
      ((CAPABILITY? CURSOR)
	                                                              (* We may want to use cursor 
								      addressing, and since we can't 
								      read the initial cursor address,
								      FORCE it to be where we think it
								      is)
	(SET.CURSOR COL (SSUB1 TTYPAGELENGTH]
    (!SETQ CURSORROW 0)
    (!SETQ CURSORCOL COL])

(INSERT.CHAR.IN.BUF
  [LAMBDA (CHAR)                                                      (* bvm: " 4-Aug-78 11:59")

          (* * Inserts CHAR in buffer at CURSOR and advances CURSOR appropriately)


    (INSERTCONS CURSOR)
    (FRPLACA CURSOR CHAR)
    [COND
      ((AT.END.OF.LINE)
	(replace END of ARROW with (CDR CURSOR]
    (SETQ CURSOR (CDR CURSOR])

(INSERTCONS
  [LAMBDA (BUF)                                                       (* bvm: " 4-Aug-78 10:20")

          (* * Effectively does (ATTACH garbage BUF), but reuses from the garbage heap)


    (COND
      ((EQ BUF ENDBUFFER)
	                                                              (* Already at end, just push 
								      pointer)
	(SETQ ENDBUFFER (NEXTCONS ENDBUFFER)))
      (T (FRPLACD BUF (FRPLNODE2 (SCRATCHCONS)
				 BUF])

(INSERTLINE
  [LAMBDA (OLDLINE USECR)                                             (* bvm: "24-Feb-80 22:33")

          (* Inserts a new line between OLDLINE and the next line, whose START is the END of
	  LINE; caller must fill in END if line is non-empty (defaults to start); USECR, if 
	  supplied, is the <cr> char to end the previous line with)


    (PROG ((OLDEND (fetch END of OLDLINE))
	   (ROW (SADD1 (fetch ROW of OLDLINE)))
	   X NEWLINE)
          [COND
	    (USECR (INSERTCONS OLDEND)
		   (FRPLACA OLDEND USECR)
		   (SETQ OLDEND (CDR OLDEND]
          (TTCRLF)
          (COND
	    ((NEQ OLDEND ENDBUFFER)
	                                                              (* Not last line, so insert a 
								      line on screen.)
	      (DO.INSERT.LINE 1)))
          (TTPROMPTCHAR)
          [replace NEXTLINE of OLDLINE with (SETQ NEWLINE (CREATE.LINE OLDEND OLDEND (SETQ X
									 (! CURSORCOL))
								       X ROW
								       (fetch NEXTLINE of OLDLINE]
          (RENUMBER.LINES NEWLINE ROW)
          (RETURN NEWLINE])

(KILL.LINES
  [LAMBDA (FIRSTLINE)                                                 (* bvm: "20-Mar-80 01:02")

          (* * Returns line records from FIRSTLINE onward to the heap)


    (FRPLACD (FLAST ENDBUFFER)
	     FIRSTLINE)
    (PROG NIL
      LP  (COND
	    (FIRSTLINE (SETQ FIRSTLINE (CDR (FRPLACA FIRSTLINE 0)))
		                                                      (* Remove some of the 
								      circularity in the buffer)
		       (GO LP])

(KILLSEGMENT
  [LAMBDA (START END)                                                 (* bvm: " 3-Aug-80 21:19")

          (* * Removes segment from START up to, but not including END.
	  When done, START contains the contents of former cell END.
	  I.e. any pointer to START is still valid; any pointer to END should be reset to 
	  START.)


    (COND
      ((EQ END ENDBUFFER)
	(SETQ ENDBUFFER START))
      (T (!SETQ OLDTAIL (!SETQ LASTAIL))
	                                                              (* kill last buffer markers, as 
								      they may be trashed)
	 (FRPLNODE START (CAR END)
		   (PROG1 (CDR END)
			  (FRPLACD END (CDR ENDBUFFER))               (* Cell at END will point to 
								      free list)
			  (FRPLACD ENDBUFFER (CDR START))             (* And this segment now is start
								      of free list)
			  ])

(LASTLINE
  [LAMBDA NIL                                                         (* bvm: "23-Feb-80 23:13")

          (* * Returns last LINE record in buffer)


    (PROG ((LINE (! FIRSTLINE))
	   L)
      LP  (COND
	    ((SETQ L (fetch NEXTLINE of LINE))
	      (SETQ LINE L)
	      (GO LP)))
          (RETURN LINE])

(LOADBUF
  [LAMBDA (BUF)                                                                 (* bvm: "24-Apr-82 14:10")

          (* BUF is a list, a la READBUF, which is loaded into our character buffer, using 
	  DCHCON to convert the s-expressions therein to char codes.
	  If we are READING, then uses PRIN2 pnames, i.e. includes escape chars and such 
	  stuff. Alternatively, BUF may be a string, in which case its contents are also 
	  loaded into the buffer, a la BKSYSBUF, and the setting of READING is irrelevant)


    (COND
      ((EQ (CAR (LISTP BUF))
	   HISTSTR1)                                                            (* read from file.
								      BUF is (<histstr1> 
								      (file start . end)))
	(SETQ BUF (CADR BUF))
	(LOADBUFFROMFILE (CAR BUF)
			 (CADR BUF)
			 (CDDR BUF)))
      (T (PROG (START END)
	       [COND
		 ((AND (LISTP BUF)
		       (SETQ START (FMEMB HISTSTR0 BUF)))                       (* HISTSTR0 is a marker used by 
								      lispx to denote end of line)
		   (FRPLACD (NLEFT BUF 1 START]
	       (SETQ START (DCHCON BUF (CDR ENDBUFFER)
				   (AND (LISTP BUF)
					READING)
				   T))                                          (* Use our own buffer as a 
								      scratchlist for DCHCON as long 
								      as it's lying around anyway.)
	       [COND
		 ((LISTP BUF)                                                   (* Remove the surrounding parens
								      from the outer list)
		   (SETQ END (NLEFT (SETQ START (CDR START))
				    1]

          (* now detach the result from our buffer to avoid conflict of interest.
	  If DCHCON found our scratchlist inadequate, START will not be a tail of ENDBUFFER 
	  so the NLEFT below comes out NIL, which is also fine)


	       (FRPLACD (NLEFT ENDBUFFER 1 START))                              (* Now unread the CHCON list.)
	       (READFROMBUF START END])

(LOADBUFFROMFILE
  [LAMBDA (FILE START END)                                                      (* bvm: "24-Apr-82 14:10")
    (SETFILEPTR FILE START)
    (bind CHAR LASTCHAR (JFN _(VAG (OPNJFN FILE)))
	  (#CHARS _(IDIFFERENCE END START)) while (IGREATERP #CHARS 0)
       do (SETN #CHARS (SUB1 #CHARS))
	  [COND
	    ((NEQ (SETQ CHAR (BIN (LOC JFN)))
		  15Q)
	      (ADDNAKEDCHAR CHAR T))
	    (T                                                                  (* eat up the lf after the cr)
	       (BIN (LOC JFN))
	       (COND
		 ((NOT (IGREATERP (SETN #CHARS (SUB1 #CHARS))
				  0))                                           (* ignore final cr)
		   (RETURN))
		 (T (ADDNAKEDCHAR CHAR]
	  (SETQ LASTCHAR CHAR])

(MODE.CHANGE?
  [LAMBDA NIL                                                         (* bvm: "19-Mar-80 21:45")

          (* * True if the tty mode that was in effect before we were entered is different 
	  from our desired mode, viz. binary for displays, and echo-off etc for 
	  non-displays)


    (NOT (COND
	   (DISPLAYTERMFLG (ZEROP (LOGAND (fetch TTYMODE of TTYINBUFFER)
					  300Q)))
	   (T (IEQP (LOGAND (fetch TTYMODE of TTYINBUFFER)
			    176300Q)
		    170100Q])

(MOVE.BACK.TO
  [LAMBDA (BUFTAIL)                                                   (* bvm: "17-Aug-78 00:12")
    (GO.TO (SDIFFERENCE (! CURSORCOL)
			(BUFLEN BUFTAIL CURSOR)))
    (SETQ CURSOR BUFTAIL])

(MOVE.FORWARD.TO
  [LAMBDA (BUFTAIL)                                                   (* bvm: "17-Aug-78 00:13")
    [GO.TO (SPLUS (! CURSORCOL)
		  (BUFLEN CURSOR (SETQ BUFTAIL (CHECK.MARGIN BUFTAIL ARROW]
    (SETQ CURSOR BUFTAIL])

(MOVE.TO.LINE
  [LAMBDA (NEWLINE BUFTAIL)                                           (* bvm: "17-Aug-78 00:13")

          (* * Moves to indicated line at indicate buffer position (default is START), 
	  resetting ARROW etc appropriately.)


    (PROG ((RELATIVE.POSITION 0))
          [COND
	    [BUFTAIL (SETQ RELATIVE.POSITION (BUFLEN (fetch START of NEWLINE)
						     (SETQ BUFTAIL (CHECK.MARGIN BUFTAIL NEWLINE]
	    (T (SETQ BUFTAIL (fetch START of NEWLINE]
          (GO.TO (SPLUS (fetch FIRSTCOL of NEWLINE)
			RELATIVE.POSITION)
		 (fetch ROW of NEWLINE))
          (SETQ CURSOR BUFTAIL)
          (RETURN (SETQ ARROW NEWLINE])

(MOVE.TO.NEXT.LINE
  [LAMBDA NIL                                                         (* bvm: "16-Aug-78 23:42")
    (GO.TO 'LINE (SETQ ARROW (fetch NEXTLINE of ARROW)))
    (SETQ CURSOR (fetch START of ARROW])

(MOVE.TO.START.OF.WORD
  [LAMBDA NIL                                                         (* bvm: " 9-Oct-78 09:57")
    [COND
      ([OR (AT.END.OF.LINE)
	   (NOT (FMEMB (CAR CURSOR)
		       '(50Q 133Q]
	

          (* Do nothing if sitting under an open paren/bracket, since otherwise the PREVWORD
	  below will go to the previous word, rather than selecting the "word" which begins 
	  with the paren; in all other cases the PREVWORD will do the right thing: if under 
	  the word, goes to its start (ignoring parens), or if under a space goes to the 
	  start of the word before the space)


	(MOVE.BACK.TO (PREVWORD (NEXTCHAR CURSOR]
    NIL])

(MOVE.TO.WHEREVER
  [LAMBDA (BUF)                                                       (* bvm: "24-Feb-80 00:28")

          (* * Moves to BUF, wherever it may be.)


    (MOVE.TO.LINE (FIND.LINE BUF)
		  BUF])

(NEWLINE
  [LAMBDA (USECR)                                                     (* bvm: " 3-Aug-80 21:09")

          (* * Handles moving to new line. USECR, if set, is the <cr> character that should 
	  terminate current line)


    (STRIPBLANKS ARROW)
    (SETQ CURSOR (fetch START of (SETQ ARROW (INSERTLINE ARROW USECR])

(NEXTCHAR
  [LAMBDA (BUF)                                                       (* bvm: "25-Aug-78 22:57")

          (* Returns next true tail of BUF. Chars that take up more than one element of buf 
	  are represented as <real char with 200Q bit on> followed by the chars in the print
	  representation, each with the 400Q bit on. Since NEXTCHAR is called from lots of 
	  places and wants to look like CDR, it is hand-coded here.)


    (ASSEMBLE NIL
	      (CQ BUF)
	      (MOVE 2 , 0 (1))                                        (* (CAR BUF))
	      (CDR1)
	      (TRNN 2 , 200Q)                                         (* Is prefix bit on?)
	      (JRST EXIT)
	      (VAR (HRRZ 3 , ENDBUFFER))
	  LP                                                          (* Skip over pad chars, which 
								      have 400Q bit set)
	      (MOVE 2 , 0 (1))
	      (TRNN 2 , 400Q)
	      (JRST EXIT)
	      (CAIN 3 , 0 (1))                                        (* Is it ENDBUFFER yet?)
	      (JRST EXIT)

          (* Yes. Need to test this because it is possible that there are pad chars left in 
	  the buffer that just happen to be contiguous with a multichar at the end of the 
	  current buffer)


	      (CDR1)
	      (JRST LP)
	  EXIT])

(NEXTCONS
  [LAMBDA (BUF)                                                       (* bvm: "25-Jul-78 22:54")

          (* * Returns cdr of BUF, tacking on a new cons if the cdr was NIL)


    (OR (CDR BUF)
	(CDR (FRPLACD BUF (CONS])

(NEXTLINE
  [LAMBDA (LINE N)                                                    (* bvm: " 4-Aug-78 18:18")
    (bind L while (AND (NOT (ZEROP N))
		       (SETQ L (fetch NEXTLINE of LINE)))
       do (SETQ LINE L)
	  (SUB1VAR N)
       finally (RETURN LINE])

(NEXTQUOTE
  [LAMBDA (BUF END)                                                   (* bvm: " 9-Oct-78 23:51")

          (* * Searches BUF until END for a closing double-quote)


    (while (NEQ BUF END) do (SELECTQ (CAR BUF)
				     (42Q (RETURN BUF))
				     [45Q                             (* "%%" quotes next char)
					  (COND
					    ((EQ (SETQ BUF (CDR BUF))
						 END)
					      (RETURN]
				     NIL)
			    (SETQ BUF (CDR BUF])

(NEXTWORD
  [LAMBDA (BUFTAIL N BACKUPFLG)                                       (* bvm: "28-Aug-78 00:33")

          (* * Return start of Nth word after BUFTAIL, or end of line if none.
	  BACKUPFLG means if you cross a paren getting to the Nth word, return the paren 
	  rather than the word (used for smart word-delete))


    (PROG ((END (fetch END of ARROW)))
          (COND
	    ((EQ BUFTAIL END)
	      (RETURN END)))
          (SETQ BUFTAIL (CDR BUFTAIL))
      LP  [COND
	    ((EQ BUFTAIL END)
	      (RETURN END))
	    ((SPACE/PARENP (CAR BUFTAIL))
	                                                              (* Found a space.
								      Now scan for first non-space, 
								      and return there)
	      [COND
		(BACKUPFLG (SETQ BUFTAIL (SETQ BACKUPFLG (FIRSTWORD BUFTAIL END]
	      (while (AND (NEQ BUFTAIL END)
			  (SPACE/PARENP (CAR BUFTAIL)))
		 do (SETQ BUFTAIL (CDR BUFTAIL)))
	      (COND
		((OR (NOT N)
		     (ZEROP (SUB1VAR N))
		     (EQ BUFTAIL END))
		  (RETURN (OR BACKUPFLG BUFTAIL]
          (SETQ BUFTAIL (CDR BUFTAIL))
          (GO LP])

(NTH.COLUMN.OF
  [LAMBDA (LINE N)                                                    (* bvm: "17-Aug-78 00:13")

          (* * Returns buffer tail of LINE record which best approximates the Nth printing 
	  column of that line)


    (NTH.RELATIVE.COLUMN.OF LINE (SDIFFERENCE N (fetch FIRSTCOL of LINE])

(NTH.RELATIVE.COLUMN.OF
  [LAMBDA (LINE N)                                                    (* bvm: "17-Aug-78 00:13")

          (* Returns buffer tail in LINE which represents the Nth printing character on the 
	  line. Returns start or end of buffer if out of range. If the nth char is a pad 
	  char, returns the start of the pad char sequence)


    (COND
      ((NOT (SGREATERP N 0))
	(fetch START of LINE))
      (T (for (BUF _(fetch START of LINE))
	      (END _(fetch END of LINE)) by (CDR BUF) until (ZEROP N) comment 
                                                                      (* eat it, prettyprint)
	    do (COND
		 ((EQ BUF END)
		                                                      (* Ran off the end, so quit)
		   (RETURN END))
		 ((PREFIXCHAR (CAR BUF))
		                                                      (* Does not print, but this is a
								      safe place to return)
		   (SETQ $$VAL BUF))
		 (T (SUB1VAR N)))
	    finally (RETURN (COND
			      ((PADCHAR (CAR BUF))
				                                      (* Can't return in the middle of
								      a multichar, so go back to its 
								      prefixchar)
				$$VAL)
			      (T BUF])

(NTHCHARCODE
  [LAMBDA (STR N)                                                     (* bvm: " 7-Sep-80 00:08")

          (* * Return (CHCON1 (NTHCHAR STR N)), but fast)


    (ASSEMBLE NIL
	      (CQ (VAG (FIX N)))
	      (PUSHN)                                                 (* Save N for later)
	      (CQ STR)
	      (STN 'STPTT)
	      (JRST GOTNAME)                                          (* STR is a string)
	      (STE 'ATOMT)
	      (JRST PUNT)                                             (* Let someone else worry if not
								      atom or string!)
	      (CQ (fetch PNAME of (AC)))                              (* Get atom's Pname)
	  GOTNAME
	      (FASTCALL UPATM)                                        (* Get byte pointer in ac3, 
								      length in ac4)
	      (NREF (MOVE 1 , 0))                                     (* Get N back)
	      (SKIPGE 1)
	      (ADDI 1 , 1 (4))                                        (* Negative N -> length+1-N)
	      (JUMPLE 1 , PUNT)                                       (* out of range)
	      (CAMLE 1 , 4)
	      (JRST PUNT)                                             (* out of range on other end)
	      (SUBI 1 , 1)                                            (* start counting at zero)
	      (IDIVI 1 , 5)                                           (* number of words to skip in 1,
								      number of bytes in 2)
	      (ADDI 3 , 0 (1))                                        (* bump byte pointer by words)
	      (SKIPA)
	  LP  (IBP 3)                                                 (* bump byte pointer by 
								      remaining chars)
	      (SOJGE 2 , LP)
	      (ILDB 1 , 3)                                            (* Finally here, so load up 
								      byte)
	      (ADDI 1 , ASZ)                                          (* Box it fast)
	      (JRST DONE)
	  PUNT(CQ (CHCON1 (NTHCHAR STR N)))
	  DONE(POPNN 1])

(OVERFLOW?
  [LAMBDA (N)                                                         (* bvm: "24-Feb-80 02:20")
                                                                      (* If typing N more chars would 
								      cause this line to overflow, 
								      starts new line (or simply goes 
								      to next line when N=0))
    (COND
      ((NOT (SLESSP (SPLUS (! CURSORCOL)
			   N)
		    TTYLINELENGTH))
	(COND
	  [(AT.END.OF.LINE)
	    (PROG ((OLDLINE ARROW))
	          (NEWLINE)
	          (COND
		    ((AND AUTOFILL DISPLAYTERMFLG)
		                                                      (* Hit the margin in the middle 
								      of a word. Try to move that word
								      intact to the new line)
		      (ADJUSTLINE 1 OLDLINE)
		      (GO.TO (fetch LASTCOL of ARROW)
			     (fetch ROW of ARROW]
	  ((ZEROP N)
	    (MOVE.TO.NEXT.LINE))
	  (T (BREAKLINE])

(OVERFLOWLINE?
  [LAMBDA (LINE)                                                      (* bvm: " 4-Aug-78 18:18")

          (* * True if LINE overflows into next line, rather than ending in a cr)


    (EQ (fetch END of LINE)
	(fetch START of (fetch NEXTLINE of LINE])

(PREVLINE
  [LAMBDA (LINE N)                                                    (* bvm: "10-Aug-78 08:19")

          (* * Backs up N lines in buffer before LINE, as far as start of buffer.
	  i.e. an NLEFT on line records.)


    (PROG ((X (! FIRSTLINE))
	   (L (! FIRSTLINE)))
      LP                                                              (* Advance X by N chars)
          (COND
	    ((ZEROP N)
	      (GO LP1))
	    ((OR (EQ X LINE)
		 (NULL X))
	                                                              (* The NULL case should never 
								      happen, but better be safe)
	      (RETURN L)))
          (SETQ X (fetch NEXTLINE of X))
          (SUB1VAR N)
          (GO LP)
      LP1                                                             (* Now advance X and L in 
								      parallel until X reaches LINE, 
								      at which point L is N before it)
          (COND
	    ((OR (EQ X LINE)
		 (NULL X))
	      (RETURN L)))
          (SETQ X (fetch NEXTLINE of X))
          (SETQ L (fetch NEXTLINE of L))
          (GO LP1])

(PREVWORD
  [LAMBDA (BUF N)                                                     (* bvm: "25-Aug-78 22:26")
    (for (X _(fetch START of ARROW))
	 (START _(fetch START of ARROW))
	 NEW_T
	 #HITS_0 by (NEXTCHAR X) until (EQ X BUF) comment 

          (* * Return start of the Nth word in line before BUF, or beginning of line if no 
	  such word)


       do (COND
	    ((SPACE/PARENP (CAR X))
	                                                              (* Space between words)
	      (SETQ NEW T))
	    (NEW (SETQ $$VAL X)
		                                                      (* Start of new word)
		 (SETQ NEW NIL)
		 (ADD1VAR #HITS)))
       finally (RETURN (COND
			 ((OR (NOT N)
			      (EQ N 1)
			      (ZEROP #HITS))
			   (OR $$VAL START))
			 ((SLESSP (SETQ N (SDIFFERENCE #HITS N))
				  0)
			                                              (* N was greater than #words in 
								      buffer)
			   START)
			 ((ZEROP N)
			   (FIRSTWORD START))
			 (T (NEXTWORD (FIRSTWORD START)
				      N])

(PROPERTAILP
  [LAMBDA (X Y)                                                       (* bvm: " 4-Aug-78 12:03")

          (* * true if X is a PROPER tail of Y)


    (AND X (NEQ X Y)
	 (BUFTAILP X Y])

(READFROMBUF
  [LAMBDA (START END COPYFLG)                                         (* bvm: "11-Jul-79 00:55")

          (* Unreads the chars in the buffer from START to END. The cells are returned to 
	  the free pool as they are used to reduce the storage demands on large unreads.
	  Multichar sequences in buffer are unread as just their "real" characters)


    (until (EQ START END) do [COND
			       ((NOT (PADCHAR (CAR START)))
				                                      (* Don't include pad chars)
				 (COND
				   [(NEQ (CAR START)
					 37Q)
				     (ADDNAKEDCHAR (REALBITS (CAR START]
				   ((NEQ (CDR START)
					 END)
				                                      (* eol. Start new line.
								      Ignore it if this is a 
								      terminating eol)
				     (NEWLINE 37Q]
			     (SETQ START (PROG1 (CDR START)
						(OR COPYFLG (FRPLACD ENDBUFFER
								     (FRPLACD START (CDR ENDBUFFER])

(RENUMBER.LINES
  [LAMBDA (LINE ROW)                                                  (* bvm: " 4-Aug-78 18:18")

          (* * Renumbers lines from LINE onward, giving LINE the value ROW)


    (while LINE do (replace ROW of LINE with ROW)
		   (ADD1VAR ROW)
		   (SETQ LINE (fetch NEXTLINE of LINE])

(RESTORE.CURSOR
  [LAMBDA NIL                                                         (* bvm: "16-Aug-78 23:44")
    (COND
      (DISPLAYTERMFLG (GO.TO (! HOMECOL)
			     (! HOMEROW])

(RESTOREBUF
  [LAMBDA NIL                                                         (* bvm: "25-Aug-78 23:02")

          (* recover previous buffer, which extends to either our current LASTAIL, if user 
	  has done deletions on this line, or previous LASTAIL, stored in the front of the 
	  buffer)


    (PROG (TAIL)
          (COND
	    ((SETQ TAIL (OR (PROPERTAILP (! LASTAIL)
					 ENDBUFFER)
			    (PROPERTAILP (! OLDTAIL)
					 ENDBUFFER)))
	      (ENDELETE)
	      (READFROMBUF [CONS (CAR ENDBUFFER)
				 (PROG1 (CDR ENDBUFFER)               (* now detach buffer from here 
								      to TAIL to avoid conflict)
					(FRPLNODE ENDBUFFER 0 (CDR TAIL]
			   TAIL)
	      (!SETQ LASTAIL ENDBUFFER)
	      (!SETQ OLDTAIL))
	    (T                                                        (* Can't find where buffer 
								      ended; perhaps we have written 
								      past it)
	       (BEEP])

(RESTOREMOD
  [LAMBDA NIL                                                         (* bvm: "23-Feb-80 22:47")

          (* * Restores original TTYMODE, i.e. the value of SFMOD when TTYIN started, unless
	  we never actually changed it)


    (AND (MODE.CHANGE?)
	 (JS SFMOD 100Q (fetch TTYMODE of TTYINBUFFER))])

(RETYPE
  [LAMBDA (LINE LASTLINE FROM.HERE)                                   (* bvm: " 8-Mar-80 02:03")

          (* Refreshes buffer starting with LINE for one line, or going to LASTLINE, where 
	  LASTLINE=T means end of buffer. Moves cursor to start of LINE 
	  (based on where we think we might be now) unless FROM.HERE is set.
	  FROM.HERE is set when retyping whole buffer with the current cursor position 
	  defined as 0,0; in this case, the cursor is restored on completion to wherever it 
	  was last saved, rather than its current position)


    (PROG (L (ROW (fetch ROW of LINE)))
          (SETQ DELETING)
          (BINARY.MODE)
          [COND
	    (FROM.HERE (INIT.CURSOR 0))
	    (T (SAVE.CURSOR)
	       (COND
		 [DISPLAYTERMFLG                                      (* position cursor at start of 
								      line)
				 (CANCEL.MODES)
				                                      (* in case an funny terminal 
								      setting occurred, say because of
								      noise)
				 (COND
				   ((CAPABILITY? CURSOR T)
				     (GO.TO.ADDRESSING 0 ROW))
				   (T (DO.UP 1)
				                                      (* Goto start of line by going 
								      up a line and doing a crlf)
				      (TTBOUT CR LF)
				      (!SETQ CURSORCOL 0]
		 (T (TTCRLF]
          (COND
	    ((ZEROP ROW)
	                                                              (* First line might be indented)
	      (TTBOUTN (!SETQ CURSORCOL INITPOS)
		       SPACE)))
      LP  (TTPROMPTCHAR LINE)
          (TYPE.BUFFER (fetch START of LINE)
		       (fetch END of LINE))
          (COND
	    ((AND LASTLINE (SETQ L (fetch NEXTLINE of LINE))
		  (NEQ L LASTLINE))
	      (SETQ LINE L)
	      (TTCRLF)
	      (ADD1VAR ROW)
	      (GO LP)))
          (COND
	    ((EQ LASTLINE T)
	                                                              (* kill any text that might be 
								      below bottom line)
	      (ERASE.TO.END.OF.PAGE)))
          (RESTORE.CURSOR])

(RUBOUT
  [LAMBDA NIL                                                         (* bvm: "24-Feb-80 22:41")

          (* * Delete the previous character -- this is the interpretation of DELETE while 
	  inserting)


    (COND
      ((AT.START.OF.LINE)
	(BEEP))
      (T (BACKWARD.DELETE.TO (TTNLEFT CURSOR 1])

(SAVE.CURSOR
  [LAMBDA NIL                                                         (* bvm: "16-Aug-78 23:56")
    (!SETQ HOMEROW (! CURSORROW))
    (!SETQ HOMECOL (! CURSORCOL])

(SCANBACK
  [LAMBDA (CHAR BUF N START)                                          (* bvm: "19-Mar-80 22:14")

          (* * Searches back for Nth previous occurrence of CHAR in buffer before BUF, 
	  returning NIL if there are no occurrences. Scan terminates at START, default is 
	  start of line; default N is 1; if there are fewer than N occurrences, returns the 
	  earliest one it can)


    (for [X _(OR START (SETQ START (fetch START of ARROW]
	 #HITS_0 by (NEXTCHAR X) until (EQ X BUF) do (COND
						       ((EQ (U-CASECODE (REALBITS (CAR X)))
							    CHAR)
							 (SETQ $$VAL X)
							 (ADD1VAR #HITS)))
       finally (RETURN (COND
			 ((OR (NOT N)
			      (EQ N 1)
			      (ZEROP #HITS)
			      (EQ #HITS 1))
			   $$VAL)
			 (T                                           (* There are #HITS occurrences 
								      of CHAR, and we want the Nth 
								      from the end)
			    (SCANFORWARD CHAR START (SADD1 (SMAX (SDIFFERENCE #HITS N)
								 0))
					 BUF])

(SCANFORWARD
  [LAMBDA (CHAR BUF N END)                                            (* bvm: "19-Mar-80 22:08")

          (* * Finds Nth occurrence of CHAR in BUF before END. Default END is end of current
	  line; default N is 1; CHAR should be uppercase if a letter)


    (OR N (SETQ N 1))
    (OR END (SETQ END (fetch END of ARROW)))
    (while (NEQ BUF END) do [COND
			      ((EQ (U-CASECODE (REALBITS (CAR BUF)))
				   CHAR)
				(COND
				  ((ZEROP (SUB1VAR N))
				    (RETURN BUF))
				  (T (SETQ $$VAL BUF]
			    (SETQ BUF (NEXTCHAR BUF])

(SCRATCHCONS
  [LAMBDA NIL                                                         (* bvm: "10-Aug-78 08:20")

          (* * Returns a garbage cons from the heap at the end of the buffer, or a fresh 
	  cons if none available)


    (!SETQ OLDTAIL (!SETQ LASTAIL))                                   (* Wipe out last buffer ptrs, as
								      this may trash them)
    (PROG1 (OR (CDR ENDBUFFER)
	       (CONS))
	   (FRPLACD ENDBUFFER (CDDR ENDBUFFER])

(SETLASTC
  [LAMBDA (CHAR)                                                      (* bvm: " 1-Aug-78 09:36")

          (* * Sets value of LASTC for the terminal. Stolen from SKREAD)


    (ASSEMBLE NIL
	      (MOVE 1 , KT)
	      (FASTCALL IFSET)
	      (CQ CHAR)
	      (SUBI 1 , ASZ)
	      (HRLM 1 , FILEA (10Q])

(SETTAIL?
  [LAMBDA (EVEN.IF.NOT.THERE)                                         (* bvm: "12-Aug-78 15:56")

          (* If ENDBUFFER is farther than we've been before, save this position on LASTAIL.
	  If EVEN.IF.NOT.THERE is set, do this even if cursor is not currently at the end)


    (COND
      ([AND (NOT DELETING)
	    (NOT (EMPTY.BUFFER))
	    (OR EVEN.IF.NOT.THERE (EQ CURSOR ENDBUFFER))
	    (OR (NOT (! LASTAIL))
		(BUFTAILP ENDBUFFER (! LASTAIL]
	(!SETQ LASTAIL ENDBUFFER])

(SHOW.MATCHING.PAREN
  [LAMBDA (BUF)                                                       (* bvm: " 3-Mar-80 22:28")

          (* * Indicates parenthesis nesting by briefly moving the cursor to the paren that 
	  matches the paren at BUF, if that position is still on the screen.
	  The cursor stays there for SHOWPARENFLG seconds, or until there is input from the 
	  user. Assumes terminal has cursor addressability)


    (PROG ((MATCHING (BACKSKREAD BUF T))
	   LINE ROW COL)                                              (* MATCHING is the buffer 
								      position that matches BUF, or 
								      NIL if this paren was quoted 
								      somehow.)
          (OR MATCHING (RETURN))
          (SETQ LINE (FIND.LINE MATCHING))                            (* The buffer LINE on which it 
								      appears)
          (COND
	    ((SLESSP (SPLUS (SETQ ROW (fetch ROW of LINE))
			    (! LOC.ROW.0))
		     0)
	                                                              (* Not on screen, so forget it)
	      (RETURN)))
          (SETQ COL (SPLUS (BUFLEN (fetch START of LINE)
				   MATCHING)
			   (fetch FIRSTCOL of LINE)))                 (* The absolute column position)
          (COND
	    ((TYPEAHEAD?)
	      

          (* After all this computation, there is now input waiting, so don't do anything.
	  Didn't do this earlier, since the SIBE itself takes time, and is likely to fail 
	  when done immediately after reading the closing paren)


	      (RETURN)))
          (SAVE.CURSOR)
          (GO.TO.ADDRESSING COL ROW)                                  (* Go to absolute coordinates of
								      matching paren)
          (SLEEP (OR (FIXP SHOWPARENFLG)
		     1))                                              (* Wait a while to let user see 
								      it)
          (RESTORE.CURSOR)                                            (* Put cursor back where it 
								      belongs)
      ])

(SKIP/ZAP
  [LAMBDA (CMD CHAR N MINUS)                                          (* bvm: "19-Mar-80 22:30")

          (* Performs <edit>S or <edit>Z, i.e. skip or zap to character.
	  CMD is S, Z, B, or -Z (latter two are backward versions of the first two); CHAR is
	  the target character, N is a repeat arg and MINUS is its sign.
	  Last such operation is saved on LASTSKIP so that <edit>A can repeat it)


    (SETQ CHAR (U-CASECODE CHAR))                                     (* Ignore case differences)
    [COND
      (MINUS                                                          (* invert command)
	     (SETQ CMD (SELECTQ CMD
				(123Q 102Q)
				(102Q 123Q)
				(132Q -132Q)
				(-132Q 132Q)
				(SHOULDNT]
    (COND
      ([SETQ N (SELECTQ CMD
			(102Q (SCANBACK CHAR CURSOR N))
			(-132Q (SCANBACK CHAR (TTNLEFT CURSOR 1)
					 N))
			(AND (NOT (AT.END.OF.LINE))
			     (SCANFORWARD CHAR (NEXTCHAR CURSOR)
					  N]
	(SELECTQ CMD
		 (123Q                                                (* S)
		       (MOVE.FORWARD.TO N))
		 (132Q                                                (* Z)
		       (FORWARD.DELETE.TO N))
		 (102Q                                                (* B)
		       (MOVE.BACK.TO N))
		 [-132Q                                               (* -Z)
			(FORWARD.DELETE.TO (PROG1 (COND
						    ((AT.END.OF.LINE)
						      CURSOR)
						    (T (NEXTCHAR CURSOR)))
						  (MOVE.BACK.TO (NEXTCHAR N]
		 (SHOULDNT)))
      (T (BEEP)))
    (!SETQ LASTSKIP CMD)
    (!SETQ LASTSKIPCHAR CHAR])

(SLEEP
  [LAMBDA (SECONDS)                                                   (* bvm: "24-Feb-80 00:25")

          (* * Program sleeps for indicated number of seconds. Returns sooner if input 
	  becomes available. Assumes no input waiting right now.)


    (ASSEMBLE NIL
	      (E (CNEXP '(ITIMES SECONDS 1750Q)
			'FIXT))                                       (* Number of msecs to sleep for)
	      (PUSHN 1)
	  LP  (HRREI 1 , -144Q)
	      (NREF (ADDM 1 , 0))                                     (* decrement our timer)
	      (MOVEI 1 , 144Q)
	      (JS DISMS)                                              (* nap for 144Q msecs at a time)
	      (NREF (SKIPG 0))                                        (* time up?)
	      (JRST EXIT)                                             (* quit now if so)
	      (MOVEI 1 , 100Q)                                        (* primary input)
	      (JS SIBE)                                               (* See if anything's waiting)
	      (SKIPA)                                                 (* No skip -> yes, input)
	      (JRST LP)                                               (* Skip -> no, go sleep some 
								      more)
	  EXIT(POPNN 1])

(SPACE/PARENP
  [LAMBDA (X)                                                         (* bvm: "25-Aug-78 22:24")
    (SELECTQ (REALBITS X)
	     ((40Q 11Q 37Q 50Q 51Q 133Q 135Q)
	       T)
	     NIL])

(START.OF.PARAGRAPH?
  [LAMBDA (LINE)                                                      (* bvm: " 8-Mar-80 02:41")
    (OR (EQ (fetch END of LINE)
	    (SETQ LINE (fetch START of LINE)))
	(EQ (CAR LINE)
	    211Q])

(STRIPBLANKS
  [LAMBDA (LINE)                                                      (* bvm: " 3-Aug-80 22:06")

          (* * Removes trailing blanks from LINE. This involves no display hacking, just 
	  moving internal pointers. If LINE = ARROW, it is assumed that the caller will fix 
	  CURSOR)


    (bind (END _(fetch END of LINE))
	  (START _(fetch START of LINE))
	  (ORIGEND _(fetch END of LINE))
	  X while (AND (NEQ END START)
		       (EQ (CAR (SETQ X (TTNLEFT END 1 START)))
			   40Q))
       do (SETQ END X)                                                (* Back up END to the blank we 
								      found)
       finally (COND
		 ((NEQ END ORIGEND)
		                                                      (* Yes, we stripped some 
								      trailing blanks, so shrink the 
								      line a little.)
		   (replace LASTCOL of LINE with (SDIFFERENCE (fetch LASTCOL of LINE)
							      (BUFLEN END ORIGEND)))
		   (KILLSEGMENT END ORIGEND)
		   (replace END of LINE with END])

(TENEXCOMPLETE
  [LAMBDA (ACTIVATIONCHAR MODE)                                       (* bvm: "19-Mar-80 21:57")

          (* Tries altmode or ^F completion on the current word. ACTIVATIONCHAR is either 
	  altmode or ^F; MODE is one of FILE, DIRECTORY or NIL, meaning do GTJFN, STDIR, or 
	  whatever is appropriate (currently if MODE=NIL we only do something if the current
	  word starts with a <); returns true if we did something about it, NIL otherwise)


    (AND (AT.END.OF.LINE)
	 (NEQ (CAR (TTNLEFT CURSOR 1))
	      45Q)
	 (PROG ((START (THISWORD))
		X ENDWITH)                                            (* Simplifying assumptions: must
								      be at end of line, and 
								      activation char not quoted by a 
								      %%.)
	       (COND
		 ((NOT START)
		   (RETURN)))
	       [COND
		 ((NULL MODE)
		   (COND
		     [(AND (EQ (CAR START)
			       74Q)
			   (EQ ACTIVATIONCHAR 33Q)
			   (NEQ (CDR START)
				CURSOR))
		                                                      (* If word starts with <, assume
								      is some sort of file spec.)
		       (SETQ MODE (COND
			   ((SCANFORWARD 76Q START 1 CURSOR)
			                                              (* there's also a > in word, so 
								      it's probably a filename)
			     'FILE)
			   (T 'DIRECTORY]
		     (T (RETURN]
	       (COND
		 ([AND (EQ MODE 'FILE)
		       (AND (TENEXP)
			    (NEQ HOSTNAME 'SUMEX-AIM]
		                                                      (* We rely on the extended long 
								      gtjfn, which provides for 
								      typescript. It exists at Sumex 
								      and on Tops20 only.)
		   (RETURN)))
	       (COND
		 [(AND (NEQ MODE 'FILE)
		       (EQ (CAR START)
			   74Q))
		   (COND
		     ((OR (TENEXP)
			  (EQ MODE 'USER))
		       

          (* Tenex STDIR and Tops20 RCUSR don't want to see the "<", so skip over it for 
	  now, and arrange to supply the matching ">" at the end)


		       (SETQ START (CDR START))
		                                                      (* skip over the <)
		       (SETQ ENDWITH 76Q]
		 ((AND (EQ MODE 'DIRECTORY)
		       (NOT (TENEXP))
		       (NEQ (CAR START)
			    74Q))
		                                                      (* Tops20 RCDIR insists that all
								      dirs start with < , so let's 
								      comply)
		   (SETQ START (CONS 74Q START))
		   (SETQ ENDWITH -1))
		 ((AND (EQ ACTIVATIONCHAR 6)
		       (EQ (CAR (SETQ X (TTNLEFT CURSOR 1 START)))
			   233Q))
		                                                      (* Word ends in altmode: strip 
								      it off, and call it the 
								      activation char)
		   (BACKWARD.DELETE.TO X)
		   (SETQ ACTIVATIONCHAR 33Q)))
	       (RETURN (ASSEMBLE NIL
			         (CQ (OR (STRINGP MACSCRATCHSTRING)
					 (GO FAIL)))                  (* We will use MACSRATCHSTRING 
								      as a string buffer for the 
								      jsyses that need it)
			         (FASTCALL UPATM)                     (* gets byte pointer in 3, 
								      length in 4)
			         (MOVE 6 , 3)                         (* Save initial byte pointer for
								      later)
			         (VAR (HRRZ 5 , START))
			         (CQ2 CURSOR)                         (* Start and end tails in buffer
								      to get partial string)
			     LP  (HRRZ 1 , 0 (5))
			         (TRNE 1 , 600Q)
			         (JRST FAIL)                          (* Sorry, I'm too lazy to handle
								      funny chars)
			         (IDPB 1 , 3)                         (* Stuff in string.
								      Notice I didn't unbox it, since 
								      I only care about low 7 bits)
			         (SOJLE 4 , FAIL)                     (* Avoid overflowing string)
			         (CDR2 5)
			         (CAME 5 , 2)
			         (JRST LP)
			         (CQ MODE)
			         (CAMN 1 , ' FILE)
			         (JRST DO.GTJFN)

          (* * Doing directory recognition. Use STDIR jsys on TENEX, or RCDIR/RCUSR on 
	  tops20. They take a string, and update it with rest of directory name)


			         (MOVE 2 , 6)                         (* Start of string pointer)
			         (PUSH CP , 3)                        (* save ending pointer so we can
								      copy the part that the jsys 
								      fills in)
			         (SETZ 1 ,)
			         (IDPB 1 , 3)                         (* Finish string with null)
			         (SKIPE KL20FLG)
			         (JRST KLDIR)                         (* different jsys for tops20...)
			         (HRLZI 1 , 400000Q)                  (* Flag: do recognition)
			         (JS STDIR)
			         (JRST DIR.F)
			         (JRST AMBIGUOUS)
			     FULLDIR
			         (FASTCALL FILLDIR)                   (* fill in missing chars)
			         (CQ ENDWITH)
			         (CAME 1 , KNIL)
			         (CAIN 1 , ASZ -1)
			         (JRST DIR.T)                         (* Dir started with <, so finish
								      with the >)
			         (CQ (ADDCHAR (AC)))
			         (JRST DIR.T)
			     AMBIGUOUS                                (* More than one possible 
								      completion, so ring the bell.
								      STDIR does not do partial 
								      completion)
			         (CQ (BEEP))
			         (JRST DIR.T)
			     KLDIR                                    (* On TOPS20: use RCDIR instead 
								      of STDIR, or if caller asked for
								      USER recognition, do RCUSR)
			         (HRLZI 1 , 10Q)                      (* flag: do recognition)
			         (VAR (HRRZ 4 , MODE))
			         (CAME 4 , ' DIRECTORY)
			         (JRST KLUSER)                        (* wants user recog)
			         (JS RCDIR)
			         (SKIPA)
			     KLUSER
			         (JS RCUSR)                           (* RCDIR/RCUSR don't skip, but 
								      indicate success/failure in 
								      flags. Check the three cases 
								      now)
			         (TLZE 1 , 40000Q)                    (* Failure bit)
			         (JRST DIR.F)
			         (TLZN 1 , 20000Q)
			         (JRST FULLDIR)                       (* Successful, completed to end)

          (* * At this point we have ambiguity, but the jsys may have partially completed 
	  the name, so have to fill that much in)


			         (FASTCALL FILLDIR)
			         (JRST AMBIGUOUS)
			     FILLDIR

          (* * Subroutine to copy to our buffer the chars that STDIR et al have added to the
	  string we gave it. String pointer is on top of CP, now "-1(CP)" due to the 
	  subroutine call)


			         (ILDB 1 , -1 (CP))                   (* pick up a char)
			         (SKIPN 1)
			         (RET)                                (* Return when we hit the null)
			         (CAIE 1 , 76Q)
			         (JRST FILLDIR.ADD)                   (* Check to see whether we 
								      should include the terminating 
								      >)
			         (CQ2 ENDWITH)
			         (CAIN 2 , -1 ASZ)                    (* -1 means strip off ending 
								      broket)
			         (RET)
			     FILLDIR.ADD
			         (ADDI 1 , ASZ)                       (* box)
			         (CQ (ADDCHAR (AC)))                  (* add to buffer)
			         (JRST FILLDIR)

          (* * Now exits for DIRECTORY part)


			     DIR.T
			         (SKIPA 1 , KT)
			     DIR.F
			         (MOVE 1 , KNIL)
			         (SUB CP , BHC 1)                     (* Flush the extra pointer we 
								      stuck on stack)
			         (JRST DONE)
			     DO.GTJFN

          (* * Want to do FILE recognition, so use GTJFN. This is harder, because it will 
	  involve terminal interaction that we can't directly control.
	  Fortunately, sumex gtjfn permits a peek. Anyway, first terminate the string with 
	  the activation character.)


			         (CQ ACTIVATIONCHAR)
			         (IDPB 1 , 3)
			         (SETZ 1 ,)
			         (IDPB 1 , 3)
			         (SUBI 4 , 2)
			         (PUSHNN (= 100004000000Q)
					 (= 100000101Q)
					 (= 0)
					 (= 0)
					 (= 0)
					 (= 0)
					 (= 0)
					 (= 0)
					 (= 0)
					 (= 2)
					 (3)
					 (4))

          (* Set up gtjfn table on number stack. Word 0 gives flags 
	  (old file, extended table) and version (0), word 1 gives injfn,,outjfn, word 12Q 
	  is length of extended table, word 13Q is string pointer to the typescript buffer 
	  (we use rest of MACSCRATCHSTRING), word 14Q its length.)


			         (PUSH CP , 3)

          (* Save initial typescript pointer here, since the one in the table will be 
	  updated. Save it here instead of in table so that GC can see it)


			         (PUSH CP , 6)                        (* save starting string pointer)
			         (SKIPN KL20FLG)
			         (JRST TTYOK)                         (* On tops20, have to reset 
								      terminal mode to ascii to make 
								      this work)
			         (CQ (JS SFMOD 100Q (LOGOR (fetch TTYMODE of TTYINBUFFER)
							   4100Q)))
			     TTYOK
			         (POP CP , 2)                         (* get back starting string 
								      pointer)
			         (MOVEI 1 , -14Q (CP))                (* address the table.
								      Have to do it directly, since 
								      NREF will complain that I 
								      haven't put that much on CP)
			         (JS GTJFN)
			         (MOVE 1 , KNIL)
			         [CQ (PROG1 (AC)
					    (COND
					      ((NOT (TENEXP))
						                      (* need to restore state)
						(BINARY.MODE]
			         (CAMN 1 , KNIL)                      (* wait til now to test for 
								      success)
			         (JRST FAILBIG)
			     SUCCEED:

          (* We now have a "typecript buffer" of chars which were typed or filled in on the 
	  screen during the gtjfn, and we have to tell our buffer about it.
	  The initial part of the typescript probably matches the partial string we fed to 
	  gtjfn above; however, it is possible for user to delete back over that string, so 
	  it does not suffice to just look at the rest of the chars: need to copy the whole 
	  string. This means overwrite, ordinarily with the same chars, the buffer from 
	  START to CURSOR, and then silently add the rest of the filename, updating the 
	  cursor position according to what we are assuming appeared on user's screen during
	  the gtjfn. NOTE: this typescript feature exists only in TOPS20 gtjfn and SUMEX's 
	  adaptation of it, so can't rely on this everywhere. On systems lacking this 
	  feature, the filename will appear to be null)


			         (JS RLJFN)                           (* first RLJFN the result of 
								      gtjfn, since all we really 
								      wanted was the chars, not the 
								      jfn)
			         (JFCL)
			         (VAR (HRRZ 3 , START))
			         (VAR (HRRZ 4 , CURSOR))
			     LP2 (ILDB 1 , 0 (CP))                    (* get a char)
			         (JUMPE 1 , SHORT)                    (* End of string already!)
			         (ADDI 1 , ASZ)                       (* Box)
			         (HRRM 1 , 0 (3))                     (* Stick in buffer)
			         (CDR2 3)
			         (CAME 3 , 4)
			         (JRST LP2)                           (* We have now accounted for all
								      the chars typed before the 
								      gtjfn. Now keep going...)
			     LP3 (ILDB 1 , 0 (CP))
			         (JUMPE 1 , HALFDONE)
			         (CAIL 1 , 40Q)
			         (JRST ADDSILENT)                     (* non-printing char probably 
								      terminates gtjfn -- tops20 
								      leaves the terminator in the 
								      typescript. But watch out for ^V
								      or other funniness)
			         (CAIE 1 , 33Q)
			         (CAIN 1 , 6)
			         (JRST DONE.GTJFN)                    (* Escape and ^F terminate, no 
								      further action needed)
			         (CAIN 1 , 15Q)
			         (JRST DIDCRLF.20)                    (* terminated with crlf requires
								      special care)
			     ADDSILENT
			         (ADDI 1 , ASZ)
			         (CQ (ADDSILENTCHAR (AC)))            (* Add char to buf without 
								      echoing, since char was echoed 
								      during gtjfn)
			         (JRST LP3)
			     SHORT

          (* Come here when typescript was shorter than the string we fed to GTJFN to begin 
	  with, presumably the result of user deleting back over the original string.
	  Bleah. I'm just going to pad with spaces)


			         (CAMN 3 , 4)
			         (JRST HALFDONE)
			         (MOVEI 1 , 40Q ASZ)                  (* space)
			         (HRRM 1 , 0 (3))
			         (CQ (TTBOUT SPACE))                  (* I assume this will not 
								      disturb 3 and 4)
			         (CDR2 3)
			         (JRST SHORT)
			     HALFDONE
			         (SKIPE KL20FLG)
			         (JRST DONE.GTJFN)                    (* Done now on tops20, since 
								      gtjfn left the terminator in the
								      typescript buf)
			         (MOVEI 1 , 100Q)
			         (JS BKJFN)                           (* Want to find out what char 
								      terminated the filename)
			         (JFCL)
			         (JS BIN)
			         (CAIE 2 , 33Q)
			         (CAIN 2 , 6)
			         (JRST DONE.GTJFN)                    (* ... ended with altmode or ^F,
								      nothing left to do)
			         (CAIN 2 , 37Q)
			         (JRST DIDCRLF)                       (* ... with crlf)
			         (MOVEI 1 , ASZ (2))
			         (CQ (ADDSILENTCHAR (AC)))            (* account for terminating char)
			         (JRST DONE.GTJFN)
			     DIDCRLF.20                               (* Can't BKJFN, because the crlf
								      was actually two characters.
								      STI them instead)
			         (MOVEI 1 , 100Q)
			         (MOVEI 2 , 15Q)
			         (JS STI)
			         (JRST GO.UP)
			     DIDCRLF

          (* Easiest thing here is just unread it, since there is no direct access to the 
	  <cr> routines. Should work to just BKJFN it; on Tenex, TTBIN will read a 37Q, and 
	  convert it back to 15Q)


			         (JS BKJFN)
			         (JFCL)
			     GO.UP
			         (CQ (AND DISPLAYTERMFLG (DO.UP 1)))
                                                                      (* Since rest of ttyin still 
								      thinks we are on previous line)
			         (JRST DONE.GTJFN)
			     FAILBIG
			         (CQ (PROGN (TTBOUT SPACE ?)          (* indicate failure of gtjfn)
					    (DISMISS 1750Q)
					    (RETYPE ARROW)))
			     DONE.GTJFN
			         (SUB CP , BHC 1)                     (* Throw away that strptr)
			         (POPNN 14Q)                          (* flush gtjfn table)
			         (SKIPA 1 , KT)
			     FAIL(MOVE 1 , KNIL)
			     DONE])

(THISWORD
  [LAMBDA NIL                                                         (* bvm: "11-Jun-79 02:11")

          (* Used by word-completion routines. Returns position in buffer of the start of 
	  the current word, or NIL if no word is in progress, or COMMAND is true and this is
	  not the first word, or the line is a comment)


    (COND
      ((AND (NOT (AT.START.OF.LINE))
	    (NEQ (CAR (fetch START of ARROW))
		 73Q))
	(for (X _(fetch START of ARROW)) by (CDR X) until (EQ X CURSOR) bind NEW_T comment 
                                                                      (* NEW is true after we scan a 
								      break character)
	   do [SELECTQ (REALBITS (CAR X))
		       ((40Q 11Q)
			                                              (* mark that we've seen this 
								      space)
			 (SETQ NEW T))
		       ((50Q 51Q 54Q 133Q 135Q 42Q)
			                                              (* these are break characters)
			 (SETQ NEW T)
			 (SETQ $$VAL X))
		       (COND
			 (NEW                                         (* This is the start of a new 
								      word; note it)
			      (COND
				((AND $$VAL COMMAND)
				                                      (* Means this is second word)
				  (RETURN)))
			      (SETQ $$VAL X)
			      (SETQ NEW NIL]
	   finally (RETURN (COND
			     ((AND (NOT NEW)
				   (OR (NOT READING)
				       [NOT (FMEMB (CAR $$VAL)
						   '(47Q 42Q]
				       (NEQ (SETQ $$VAL (CDR $$VAL))
					    CURSOR)))
			       

          (* Start of word seen, and not yet ended. Check for starting ' or %" in a list 
	  input, since those probably don't start this word, i.e. atom)


			       $$VAL])

(TTBIN
  [LAMBDA NIL                                                         (* bvm: "12-Sep-82 15:15")

          (* * Read the next char from terminal, return its character code.
	  Sets EDITBIT true or false according to state of the edit bit 
	  (200Q).)


    (PROG ((EDITABLE (! EDITABLE))
	   CH)
      RESTART
          [COND
	    (TTYINBACKUP                                              (* Buffer for keeping multi-char
								      keypad stuff)
			 (RETURN (PROG1 (SLOGAND (CAR TTYINBACKUP)
						 177Q)
					[SETQ EDITBIT (NOT (ZEROP (SLOGAND (CAR TTYINBACKUP)
									   200Q]
					(SETQ TTYINBACKUP (CDR TTYINBACKUP]
          (SETQ CH (ASSEMBLE NIL
			     (MOVEI 1 , 100Q)
			     (JS BIN)                                 (* BIN, result in 2)
			     (MOVEI 1 , ASZ (2))                      (* box it)
			     (VAR (HRRZ 3 , EDITABLE))                (* can read edit bit)
			     (TRZN 1 , 200Q)                          (* turn off edit bit, skip if 
								      on)
			     (MOVE 3 , KNIL)
			     (VAR (HRRM 3 , EDITBIT))                 (* EDITBIT gets set if bit was 
								      on and terminal allows it.
								      Bit can be on if terminal sends 
								      parity, remember)
			     (CAME 3 , KNIL)
			     (JRST EXIT)                              (* Done now if edit bit was on)
			     (CAIN 1 , 15Q ASZ)                       (* Was it a cr?)
			     (JRST EATLF)
			     (CAIN 1 , 37Q ASZ)                       (* Was it funny EOL char?)
			     (SKIPE KL20FLG)                          (* no problem on tops20)
			     (JRST EXIT)                              (* no)
			     (JRST READCR)                            (* Yes, typed ahead <cr> on 
								      Tenex looks like this.
								      I assume <hold> is never read;
								      this is the case on Sumex 
								      anyway)
			 EATLF

          (* Following a CR, eat the LF if there is one. This happens on TOPS20, except when
	  in binary mode. Once had a problem with this over net connections, but I think 
	  that went away.)


			     (SKIPN KL20FLG)                          (* which system are we on?)
			     (JRST EXIT)                              (* Tenex is ok: cr must be 
								      naked, or we would have read an 
								      eol instead)
			     (CQ2 DISPLAYTERMFLG)
			     (CAME 2 , KNIL)                          (* are we in binary mode?)
			     (JRST EXIT)                              (* yes, cr is naked)
			     (MOVEI 1 , 100Q)
			     (JS BIN)                                 (* BIN)
			 READCR
			     (MOVEI 1 , ASZ 15Q)                      (* cr)
			 EXIT))
          (COND
	    ((KEYPADPREFIXP CH)
	      (SETQ TTYINBACKUP (TTYINKEYPAD CH))
	      (GO RESTART)))
          (RETURN CH])

(TTCRLF
  [LAMBDA NIL                                                         (* bvm: " 2-Jan-79 22:14")

          (* * Prints a crlf, updating cursor appropriately)


    (TTBOUT CR LF)
    (TTCRLF.ACCOUNT])

(TTCRLF.ACCOUNT
  [LAMBDA NIL                                                         (* bvm: "24-Feb-80 20:50")
    (!SETQ CURSORROW (SADD1 (! CURSORROW)))
    [COND
      ((EQ (SPLUS (! LOC.ROW.0)
		  (! CURSORROW))
	   TTYPAGELENGTH)
	                                                              (* This crlf glitched the 
								      screen, so row 0 has moved up 
								      one)
	(!SETQ LOC.ROW.0 (SSUB1 (! LOC.ROW.0]
    (!SETQ CURSORCOL 0])

(TTGETFILE
  [LAMBDA (FLAGS)                                                               (* bvm: "24-Apr-82 14:47")
    (PROG (JFN)
          (OR (TENEXP)
	      (JS SFMOD 100Q (LOGOR (fetch TTYMODE of TTYINBUFFER)
				    4100Q)))                                    (* Tops20 needs terminal in ascii mode)
          (RETURN (PROG1 (ASSEMBLE NIL
			           [CQ (VAG (FIX (SELECTQ FLAGS
							  (OLD 160003Q)
							  (NEW 660003Q)
							  FLAGS]
			           (HRLZ 1 , 1)
			           (SKIPA 2 , * 1)
			           (XWD 100Q 101Q)
			           (JS GTJFN)
			           (JRST FAIL)
			           (MOVEI 1 , ASZ (1))
			           (CQ (PROG1 (JFNS (SETQ JFN (AC)))
					      (RLJFN JFN)))
			           (JRST EXIT)
			       FAIL(MOVE 1 , KNIL)
			       EXIT)
			 (COND
			   ((JS BKJFN 100Q NIL NIL T)
			     (SELCHARQ (JS BIN 100Q NIL NIL 2)
				       ((LF CR TENEXEOL)                        (* Terminated in cr, so we are down a 
										line)
					 (TTCRLF.ACCOUNT))
				       NIL)))
			 (OR (TENEXP)
			     (BINARY.MODE])

(TTNLEFT
  [LAMBDA (BUF N START)                                               (* bvm: "27-Jul-78 00:47")

          (* * Backs up N real characters in this line before BUF as far as START, default 
	  being the current start of the line. Assumes BUF is a tail of line and N is small)


    (OR START (SETQ START (fetch START of ARROW)))
    (PROG ((X START)
	   (B START))
      LP                                                              (* Advance X by N chars)
          (COND
	    ((ZEROP N)
	      (GO LP1))
	    ((OR (EQ X BUF)
		 (NULL X))
	                                                              (* The NULL case should never 
								      happen, but better be safe)
	      (RETURN B)))
          (SETQ X (NEXTCHAR X))
          (SUB1VAR N)
          (GO LP)
      LP1                                                             (* Now advance X and B in 
								      parallel until X reaches BUF, at
								      which point B is N before it)
          (COND
	    ((OR (EQ X BUF)
		 (NULL X))
	      (RETURN B)))
          (SETQ X (NEXTCHAR X))
          (SETQ B (NEXTCHAR B))
          (GO LP1])

(TTNTH
  [LAMBDA (BUF N)                                                     (* bvm: "12-Aug-78 16:00")

          (* * Advances N real characters in BUF as far as the end of the line)


    (bind (END _(fetch END of ARROW)) while (AND (NOT (ZEROP N))
						 (NEQ BUF END))
       do (SETQ BUF (NEXTCHAR BUF))
	  (SUB1VAR N)
       finally (RETURN BUF])

(TTPRIN1
  [LAMBDA (STR)                                                       (* bvm: "23-Jun-79 20:42")

          (* * PRIN1 of STR, atom or string, directly to the terminal, bypassing any dribble
	  file)


    (ASSEMBLE NIL
	      (CQ STR)
	      (STN 'STPTT)
	      (JRST UP)
	      (STN 'ATOMT)
	      (JRST LOADPNAME)
	      (CQ (MKSTRING (AC)))                                    (* Non atom/string needs to be 
								      converted. I hope this doesn't 
								      happen too much, but it could if
								      there are numbers on the SPLST)
	      (JRST UP)
	  LOADPNAME
	      (CQ (fetch PNAME of (AC)))
	  UP  (FASTCALL UPATM)                                        (* gets length in 4, bytepointer
								      in 3, leaves 1 and 2 untouched)
	      (CQ (! CURSORCOL))                                      (* current position)
	      (ADDI 1 , 0 (4))                                        (* position after printing, 
								      still boxed)
	      (CQ2 TTYLINELENGTH)
	      (CAMGE 1 , 2)
	      (JRST FITS)
	      (PUSH CP , 3)                                           (* save byteptr)
	      (PUSHN 4)                                               (* and length)
	      (CQ (TTCRLF))                                           (* start new line)
	      (POPN 4)
	      (POP CP , 3)
	      (MOVEI 1 , ASZ (4))                                     (* revised position)
	  FITS(CQ (!SETQ CURSORCOL (AC)))
	  LP  (ILDB 1 , 3)
	      (JS PBOUT)
	      (SOJG 4 , LP])

(TTPROMPTCHAR
  [LAMBDA (LINE)                                                      (* bvm: "24-Feb-80 02:17")

          (* * Prints the prompt for indicated LINE)


    (CLEAR.LINE?)
    (COND
      ([SETQ LINE (COND
	    ((EQ LINE (! FIRSTLINE))
	      (! PROMPT1))
	    (T (! PROMPT2]
	(TTPRIN1 LINE])

(TTRATOM
  [LAMBDA NIL                                                         (* bvm: "14-May-79 23:54")

          (* * Reads next atom from BUFFER, advancing it suitably)


    (COND
      ((EQ (TTSKIPSEPR)
	   ENDBUFFER)
	null)
      (T (PROG ((PACKBUF ENDBUFFER)
		PREVBUF CH)                                           (* PACKBUF is where we will 
								      build up the chars of the atom)
	   LP  (COND
		 ((EQ BUFFER ENDBUFFER)
		   (GO DONE)))
	       (SELECTQ (SETQ CH (REALBITS (CAR BUFFER)))
			[(50Q 51Q 133Q 135Q 42Q 54Q)
			                                              (* Break chars: parens, 
								      brackets, quote)
			  (COND
			    ((AND (EQ CH 54Q)
				  READING)
			                                              (* Comma does not break a read))
			    [(EQ PACKBUF ENDBUFFER)
			                                              (* No atom read yet, so the 
								      break char is it)
			      (RETURN (PROG1 (FCHARACTER CH)
					     (SETQ BUFFER (CDR BUFFER]
			    (T (GO DONE]
			((40Q 11Q 37Q)
			                                              (* separators terminate scan)
			  (GO DONE))
			[45Q                                          (* escape to quote next char)
			     (COND
			       ((OR READING (AND (NEQ (CDR BUFFER)
						      ENDBUFFER)
						 (EQ (CADR BUFFER)
						     77Q)))
				 (SETQ BUFFER (CDR BUFFER]
			NIL)
	       (FRPLACA PACKBUF (CAR BUFFER))
	       (SETQ PACKBUF (NEXTCONS (SETQ PREVBUF PACKBUF)))
	       (SETQ BUFFER (NEXTCHAR BUFFER))
	       (GO LP)
	   DONE(RETURN (COND
			 ((EQ PACKBUF (CDR ENDBUFFER))
			   (FCHARACTER (CAR ENDBUFFER)))
			 (T (TTPACK ENDBUFFER PACKBUF])

(TTREAD
  [LAMBDA NIL                                                         (* bvm: "19-Mar-79 23:53")

          (* Reads starting at BUFFER, advancing BUFFER past what is read.
	  If unmatched paren/bracket encountered, leaves it. Returns the distinguished value
	  null, a null string, if there is nothing to read)


    (PROG (X)
          (TTSKIPSEPR)
          (RETURN (COND
		    ((NEQ BUFFER ENDBUFFER)
		      (SELECTQ (REALBITS (CAR BUFFER))
			       [(50Q 133Q)
				                                      (* lp, left bracket)
				 (TTREADLIST (PROG1 (CAR BUFFER)
						    (SETQ BUFFER (CDR BUFFER]
			       ((51Q 135Q)
				                                      (* rp, right bracket)
				 null)
			       [42Q                                   (* double quote: find matching 
								      quote)
				    (SETQ X (OR (NEXTQUOTE (SETQ BUFFER (CDR BUFFER))
							   ENDBUFFER)
						ENDBUFFER))
				    (PROG1 (TTYINSTRING BUFFER X)
					   (SETQ BUFFER (CDR X]
			       [47Q                                   (* single quote)
				    (SETQ BUFFER (CDR BUFFER))
				    (COND
				      ((AND (NOT (SPACEP (CAR BUFFER)))
					    (NEQ (SETQ X (TTREAD))
						 null))
					(SELECTQ X
						 (S ''S)
						 (s ''s)
						 (LIST 'QUOTE X)))
				      (T                              (* The quote was followed by 
								      "space", right paren/bracket, or
								      end of line)
					 (QUOTE ']
			       [31Q                                   (* ^Y evaluates next thing in 
								      input)
				    (SETQ BUFFER (NEXTCHAR BUFFER))
				    (COND
				      ((NEQ (SETQ X (TTREAD))
					    null)
					(STKEVAL 'TTYIN X))
				      (T ']
			       (TTRATOM)))
		    (T null])

(TTREADLIST
  [LAMBDA (OPENCHAR)                                                  (* bvm: "14-May-79 21:27")

          (* * Read a list of elements. OPENCHAR is the character that started the list 
	  (paren or bracket) or NIL if none.)


    (PROG (RESULT TAIL X)
      LP  (COND
	    ((EQ (TTSKIPSEPR)
		 ENDBUFFER)
	      (RETURN RESULT)))
      LP2 (SELECTQ (CAR BUFFER)
		   (51Q                                               (* right paren terminates list;
								      eat it up to match open paren)
			[COND
			  (OPENCHAR (SETQ BUFFER (CDR BUFFER]
			(RETURN RESULT))
		   (135Q                                              (* right bracket.
								      Only eat it if started with 
								      bracket)
			 [COND
			   ((EQ OPENCHAR 133Q)
			     (SETQ BUFFER (CDR BUFFER]
			 (RETURN RESULT))
		   [56Q                                               (* dot. if isolated and followed
								      by one element, denotes dotted 
								      cdr)
			(COND
			  ((AND RESULT OPENCHAR (NEQ (CDR BUFFER)
						     ENDBUFFER)
				(SPACEP (CADR BUFFER)))
			    (SETQ BUFFER (CDDR BUFFER))
			                                              (* Looks good so far;
								      skip over dot)
			    (COND
			      ((EQ (SETQ X (TTREAD))
				   null)
				                                      (* nothing there)
				(SETQ X '%.)
				(GO ADDELT))
			      ([AND (NEQ (TTSKIPSEPR)
					 ENDBUFFER)
				    (FMEMB (CAR BUFFER)
					   '(51Q 135Q]
				                                      (* terminated correctly on 
								      closing paren. do it)
				(FRPLACD TAIL X)
				(GO LP2))
			      (T                                      (* There's more there, so treat 
								      the dot as ordinary atom)
				 [FRPLACD TAIL (SETQ TAIL (CONS '%.]
				 (GO ADDELT]
		   NIL)
          (SETQ X (TTREAD))                                           (* scan next element)
      ADDELT
          (SETQ X (CONS X))                                           (* Now tack onto end of RESULT, 
								      doing open NCONC1 here)
          (COND
	    (RESULT (FRPLACD TAIL X))
	    (T (SETQ RESULT X)))
          (SETQ TAIL X)
          (GO LP])

(TTSKIPSEPR
  [LAMBDA NIL                                                         (* bvm: "29-Jul-78 02:32")

          (* * Skip BUFFER over any separator chars, returning new value)


    (while (AND (NEQ BUFFER ENDBUFFER)
		(SPACEP (CAR BUFFER)))
       do (SETQ BUFFER (CDR BUFFER)))
    BUFFER])

(TTSKREAD
  [LAMBDA (BUF END)                                                   (* bvm: "21-Sep-78 00:31")
    (OR END (SETQ END ENDBUFFER))
    (bind X while (NEQ BUF END) comment 

          (* * Simulates READLINE starting at BUF, returning tail of BUF where the read 
	  would terminate, or NIL if the read does not terminate before END 
	  (default ENDBUFFER))


       do (SELECTQ (CAR BUF)
		   [(50Q 133Q)
		                                                      (* open paren/bracket)
		     (SETQ X (CAR BUF))
		     (COND
		       ((OR (NOT (SETQ BUF (TTSKREAD (CDR BUF)
						     END)))
			    (EQ BUF END))
			                                              (* paren/bracket not closed)
			 (RETURN))
		       ((AND (EQ (CAR BUF)
				 135Q)
			     (NEQ X 133Q))
			                                              (* left paren terminated by 
								      right bracket)
			 (RETURN BUF]
		   ((51Q 135Q)
		                                                      (* closing paren/bracket)
		     (RETURN BUF))
		   [42Q (COND
			  ((NOT (SETQ BUF (NEXTQUOTE (CDR BUF)
						     END)))
			    (RETURN]
		   [45Q                                               (* %  skip over without looking)
			(COND
			  ((EQ (SETQ BUF (CDR BUF))
			       END)
			    (RETURN]
		   NIL)
	  (SETQ BUF (CDR BUF))
       finally (RETURN BUF])

(TTYINSTRING
  [LAMBDA (BUF TAIL)                                                  (* bvm: "19-Mar-79 23:53")

          (* * Returns a string consisting of the "real" chars in buffer from BUF to TAIL or
	  end of buffer. If BUF = TAIL returns a null string)


    (OR TAIL (SETQ TAIL ENDBUFFER))
    (for X_BUF by (NEXTCHAR X) until (EQ X TAIL) comment 

          (* we use the internal string routines for speed: copy each of the "real" chars 
	  into a string in string space; when done, construct string pointer to it.
	  Since all the code below is inline, except for the block call to NEXTCHAR, nobody 
	  will disturb the string as we build it. Wish I could do this for TTRATOM too, but 
	  the internal atom maker is not accessible to mere mortals.)


       first (ASSEMBLE NIL                                            (* Init the string maker)
		       (FASTCALL MKSTRS))
       do [COND
	    ((AND READING (EQ (CAR X)
			      45Q))
	                                                              (* %  to quote next char)
	      (SETQ X (CDR X]
	  (ASSEMBLE NIL
		    (CQ (REALBITS (CAR X)))
		    (SUBI 1 , ASZ)                                    (* Unbox the character)
		    (FASTCALL MKSTR1)                                 (* Call internal routine to 
								      append to string)
		)
       finally (RETURN (ASSEMBLE NIL
			         (MOVE 1 , UNP1)                      (* Internal pointer to string 
								      we've been building)
			         (FASTCALL MKSP])

(TYPE.BUFFER
  [LAMBDA (START END)                                                 (* bvm: "12-Aug-78 17:22")

          (* * Types buffer from START to END, returning number of chars typed.
	  Assumes no CR's)


    (bind $$VAL_0 while (NEQ START END) do (COND
					     ((NOT (PREFIXCHAR (CAR START)))
					       (TTBOUT (CAR START))
					       (ADD1POS)
					       (ADD1VAR $$VAL)))
					   (SETQ START (CDR START])

(U/L-CASE
  [LAMBDA (N CAPFLG)                                                  (* bvm: "24-Feb-80 21:40")

          (* * UPPER or lower-case N words. CAPFLG=T for uppercase; CAPFLG=1 for just 
	  capitalization)


    (COND
      ((AND (EQ N 1750Q)
	    (AT.END.OF.LINE))
	

          (* $U or $L at end of line means do it to the whole line. This handles the common 
	  situation where you have typed several words in the wrong case and want to fix 
	  them without backing up to the beginning)


	(MOVE.BACK.TO (fetch START of ARROW)))
      (T (MOVE.TO.START.OF.WORD)))                                    (* Go to start of current word)
    (bind (NEXTWD _(CHECK.MARGIN (NEXTWORD CURSOR N)))
	  BUF_CURSOR
	  CHAR until (EQ BUF NEXTWD) do [COND
					  ((AND [NOT (PREFIXCHAR (SETQ CHAR (CAR BUF]
						(SGREATERP CHAR 100Q))
					    (FRPLACA BUF (COND
						       (CAPFLG (COND
								 ((EQ CAPFLG 1)
								      (* only raise first char of 
								      word)
								   (SETQ CAPFLG NIL)))
							       (U-CASECODE CHAR))
						       (T (L-CASECODE CHAR]
					(SETQ BUF (NEXTCHAR BUF))
       finally (TYPE.BUFFER CURSOR (SETQ CURSOR BUF])

(UNREADBUF
  [LAMBDA NIL                                                         (* bvm: "23-Jun-79 20:41")

          (* * Takes contents of buffer from CURSOR onward and "unreads" it, i.e. erases it 
	  and simulates terminal input, a la BKSYSBUF)


    [for X_CURSOR by (NEXTCHAR X) until (EQ X ENDBUFFER)
       do (JS STI 100Q [COND
		((EQ (CAR X)
		     37Q)
		  15Q)
		(T (LOC (REALBITS (CAR X])]
    (DELETE.TO.END])
)

(RPAQQ TTDISPLAYFNS (&DISPLAYCOMMENT CAPABILITY? BEEP CANCEL.MODES DELNCHARS DO.BACK DO.DELETE.LINES 
				     DO.DOWN DO.FORWARD DO.HOME DO.INSERT.LINE DO.UP ERASE.SCREEN 
				     ERASE.TO.END.OF.LINE ERASE.TO.END.OF.PAGE INSERT.TEXT 
				     INSERTNCHARS INSERTSPACES.DM SET.CURSOR))
(DEFINEQ

(&DISPLAYCOMMENT
  [LAMBDA NIL                                                         (* bvm: " 8-Mar-80 16:37")

          (* The display-dependent functions follow. These are the functions to change to 
	  add new terminal types. You'll probably also want to change DISPLAYTERMP to 
	  include the new type, or at least set DISPLAYTYPES correctly.
	  The types that TTYIN currently knows about, together with their internal codes 
	  (the value of DISPLAYTERMFLG) are -
	  1: Datamedia -- can do anything asked in this package -
	  2: Heath -- can display anything, but has no edit key -
	  0: glass tty -- any terminal capable of at least backspacing and overprinting, so 
	  that the sequence BS, SPACE, BS will delete a character.)



          (* * The main body of TTYIN relies only on certain primitive operations, encoded 
	  according to terminal type in the functions that follow. It uses the function 
	  CAPABILITY? to decide whether the terminal can perform a function it is 
	  considering)



          (* * The functions included herein assume you are running no faster than 
	  2400-baud. Some functions need considerably more padding at 9600-baud, although if
	  you're on tops20 in page mode the Heath will send ^S and ^Q to survive anyway.
	  The main thing that taxes the Heath is ADJUSTLINE trying to justify several lines 
	  at once. DM has biggest problem with Insert Line)


    ])

(CAPABILITY?
  [NLAMBDA (TYPE ON.DISPLAY.FLG)                                      (* bvm: "29-Aug-82 21:50")

          (* * true if terminal has the indicated capability. This is a compiler macro that 
	  tests for appropriate values of DISPLAYTERMFLG; if ON.DISPLAY.FLG is true, the 
	  macro may assume that DISPLAYTERMFLG is already non-NIL. TYPE may be -
	  ERASE.TO.END -- terminal can erase to end of line -
	  CURSOR -- terminal has addressable cursor -
	  MOVEMENT -- terminal permits cursor to move freely about page 
	  (up, down, left, right); CURSOR is assumed to imply MOVEMENT -
	  EDIT -- terminal can send EDIT bit (200Q) -
	  I/D.CHAR -- terminal has insert/delete character ability -
	  -
	  This package currently assumes that if the terminal can "edit", i.e. get into the 
	  edit-character routines, then it has ERASE.TO.END, as well as insert/delete line, 
	  and preferably CURSOR as well. For just "glass tty" operation, existence of 
	  ERASE.TO.END and CURSOR are the only relevant things; they may optimize large 
	  deletes (^Q and ^W). Minimal display requirement is physical backspace;
	  otherwise DISPLAYTERMFLG must be NIL.)


    (SELECTQ DISPLAYTERMFLG
	     (1                                                       (* Dm has everything)
		T)
	     ((2 3)                                                   (* Heath, Concept can do 
								      anything but EDIT)
	       (NEQ TYPE 'EDIT))
	     NIL])

(BEEP
  [LAMBDA NIL                                                         (* bvm: "24-Jun-78 22:12")
    (TTBOUT BELL])

(CANCEL.MODES
  [LAMBDA NIL                                                         (* bvm: " 3-Mar-80 22:43")

          (* * Used by RETYPE when ^R refreshes line/screen: cancel any funny modes we might
	  have gotten into by virtue of line noise)


    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT CANCEL ROLL))
	     (2                                                       (* not really available on a 
								      Heath, but CANCEL will at least 
								      abort a partial Escape command)
		(TTBOUT CANCEL))
	     NIL])

(DELNCHARS
  [LAMBDA (#CHARS START END RESTORE)                                  (* bvm: "29-Aug-82 22:03")

          (* * Deletes N chars starting at cursor position. If supplied, START thru END is 
	  the buffer representing the rest of the line. If RESTORE is true, we expect the 
	  cursor to be home when finished, otherwise we don't care. This is so DELNCHARS can
	  have the option of retyping the line instead of killing chars)


    (PROG [(LENGTH (AND START (BUFLEN START END]
          (COND
	    ((SELECTQ DISPLAYTERMFLG
		      (1 (COND
			   ((OR (NOT LENGTH)
				(SGREATERP (SPLUS LENGTH (COND
						    (RESTORE 1)
						    (T -2)))
					   #CHARS))

          (* easier to kill than retype. The cond above takes into account the fact that 
	  RESTORE requires an addressing operation, which takes another 3 chars;
	  that cancels the 3 extra chars we do here. The 1 is the ERASE.TO.END code we send)


			     (TTBOUT INSERT/DELETE)
			     (TTBOUTN #CHARS DELCH)
			     (TTBOUT CANCEL ROLL)
			     T)))
		      ((2 3)                                          (* Heath, Concept: each deleted 
								      char counts 2, erase to end 
								      counts 2, and addressing counts 
								      4)
			(COND
			  ((OR (NOT LENGTH)
			       (SGREATERP (SPLUS LENGTH (COND
						   (RESTORE 6)
						   (T 2)))
					  (SPLUS #CHARS #CHARS)))
			    (COND
			      ((EQ DISPLAYTERMFLG 2)
				(TTBOUTN #CHARS ESC N))
			      (T (TTBOUTN #CHARS ESC ^Q)))
			    T)))
		      NIL))
	    (T (ERASE.TO.END.OF.LINE)
	       (SETQ LENGTH (TYPE.BUFFER START END))
	       (COND
		 (RESTORE (GO.TO (SDIFFERENCE (! CURSORCOL)
					      LENGTH])

(DO.BACK
  [LAMBDA (#CHARS)                                                    (* bvm: "24-Feb-80 00:09")
    (TTBOUTN #CHARS BS])

(DO.DELETE.LINES
  [LAMBDA (#LINES)                                                    (* bvm: "12-Sep-82 15:25")
    (SELECTQ DISPLAYTERMFLG
	     (1                                                       (* DM)
		(TTBOUT INSERT/DELETE)
		(TTBOUTN #LINES DELETE.LINE)
		(TTBOUT CANCEL ROLL))
	     (2                                                       (* Heath)
		(TTBOUTN #LINES ESC M)                                (* DL on Heath leaves cursor at 
								      start of line, so...)
		(!SETQ CURSORCOL 0))
	     (3                                                       (* Concept)
		(TTBOUTN #LINES ESC ^B))
	     NIL])

(DO.DOWN
  [LAMBDA (#LINES)                                                    (* bvm: " 4-Mar-80 00:25")
                                                                      (* LF works on all terminals I 
								      know about)
    (TTBOUTN #LINES LF])

(DO.FORWARD
  [LAMBDA (#CHARS)                                                    (* bvm: "29-Aug-82 22:12")
    (SELECTQ DISPLAYTERMFLG
	     (1                                                       (* dm)
		(TTBOUTN #CHARS FORWARD))
	     (2                                                       (* Heath)
		(TTBOUTN #CHARS ESC C))
	     (3                                                       (* Concept)
		(TTBOUTN #CHARS ESC =))
	     NIL])

(DO.HOME
  [LAMBDA NIL                                                         (* bvm: "29-Aug-82 22:13")
    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT HOME))
	     (2 (TTBOUT ESC H))
	     (3 (TTBOUT ESC ?))
	     NIL])

(DO.INSERT.LINE
  [LAMBDA NIL                                                         (* bvm: "12-Sep-82 15:25")

          (* * Inserts a new line on screen in front of current cursor row.
	  The trickiness here is that unless there are some blank lines at the bottom of the
	  screen, we actually have to scroll upwards before we can insert downwards, lest we
	  lose the bottom line. Leaves cursor at start of new blank line.)


    [GO.TO.ADDRESSING 0 (PROG1 (! CURSORROW)
			       (COND
				 ((EQ (IPLUS (! LOC.ROW.0)
					     (fetch ROW of (LASTLINE))
					     1)
				      TTYPAGELENGTH)                  (* Bottom line is occupied, 
								      glitch upward first)
				   (DO.HOME)
				   (DO.DELETE.LINES 1)
				   (!SETQ LOC.ROW.0 (SSUB1 (! LOC.ROW.0)))
                                                                      (* Top line of buffer has moved 
								      up one)
				   ]
    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT INSERT/DELETE)
		(TTBOUT INSERT.LINE 0 0)                              (* Include nulls for padding 
								      since insertline is a slow 
								      function on dm's)
		(TTBOUT CANCEL ROLL))
	     (2                                                       (* Inserting a line is much 
								      easier on Heath)
		(TTBOUT ESC L)                                        (* and cursor is now in first 
								      col)
		(!SETQ CURSORCOL 0))
	     (3                                                       (* Concept)
		(TTBOUT ESC ^R))
	     NIL])

(DO.UP
  [LAMBDA (#LINES)                                                    (* bvm: "29-Aug-82 22:15")
    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUTN #LINES UP))
	     (2 (TTBOUTN #LINES ESC A))
	     (3 (TTBOUTN #LINES ESC ;))
	     NIL])

(ERASE.SCREEN
  [LAMBDA NIL                                                         (* bvm: "29-Aug-82 22:17")
    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT CANCEL ERASE ROLL))
	     (2 (TTBOUT ESC E))
	     (3 (TTBOUT ^L))
	     NIL])

(ERASE.TO.END.OF.LINE
  [LAMBDA NIL                                                         (* bvm: "29-Aug-82 22:17")
    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT ERASE.TO.END))
	     (2 (TTBOUT ESC K))
	     (3 (TTBOUT ESC ^S))
	     NIL])

(ERASE.TO.END.OF.PAGE
  [LAMBDA NIL                                                         (* bvm: "29-Aug-82 22:18")

          (* * Erases from current cursor position to end of page.)


    (SELECTQ DISPLAYTERMFLG
	     [1 (ERASE.TO.END.OF.LINE)
		(PROG [(N (SDIFFERENCE TTYPAGELENGTH (SPLUS (! LOC.ROW.0)
							    (! CURSORROW)
							    1]        (* Not on last line, so have to 
								      erase the lines below us)
		      (COND
			((NOT (ZEROP N))
			  (TTBOUT DOWN INSERT/DELETE)
			  (TTBOUTN N DELETE.LINE)
			  (TTBOUT CANCEL ROLL UP]
	     (2                                                       (* much simpler on Heath)
		(TTBOUT ESC J))
	     (3                                                       (* Concept)
		(TTBOUT ESC ^C))
	     NIL])

(INSERT.TEXT
  [LAMBDA (START END ENDOFLINE)                                       (* bvm: "29-Aug-82 22:21")

          (* * Inserts on screen the contents of buffer from START to END.
	  Text from END to ENDOFLINE is the remainder of the line, in case it's more 
	  economical to just retype the line than do the insertion)


    (PROG (#CHARS)
          (COND
	    ((OR (EQ END ENDOFLINE)
		 (SGREATERP (SETQ #CHARS (BUFLEN START END))
			    (BUFLEN END ENDOFLINE)))
	      (TYPE.BUFFER START ENDOFLINE))
	    (T (SELECTQ DISPLAYTERMFLG
			(1                                            (* On DM, make space, then type 
								      text)
			   (INSERTSPACES.DM #CHARS)
			   (TYPE.BUFFER START END))
			(2 

          (* On Heath, go into "Insert character mode", type text, then leave mode.
	  This may need to be padded; for now I am doing so crudely 
	  (TTBOUTN #CHARS 0))


			   (TTBOUT ESC @)
			   (TYPE.BUFFER START END)
			   (TTBOUT ESC O))
			(3                                            (* Concept similar to Heath)
			   (TTBOUT ESC ^P)
			   (TYPE.BUFFER START END)
			   (TTBOUT ESC ^@))
			NIL])

(INSERTNCHARS
  [LAMBDA (N CHAR)                                                    (* bvm: "29-Aug-82 22:22")

          (* * Inserts N copies of CHAR in front of existing text)


    (SELECTQ DISPLAYTERMFLG
	     (1 (INSERTSPACES.DM N)
		(TTBOUTN N CHAR))
	     (2 (TTBOUT ESC @)
		(TTBOUTN N CHAR)
		(TTBOUT ESC O))
	     (3 (TTBOUT ESC ^P)
		(TTBOUTN N CHAR)
		(TTBOUT ESC ^@))
	     NIL])

(INSERTSPACES.DM
  [LAMBDA (N)                                                         (* bvm: "16-Aug-78 23:36")

          (* * Inserts N spaces on screen, leaving cursor ready to print atop the first)


    (TTBOUT INSERT/DELETE)
    (TTBOUTN N FORWARD)
    (TTBOUT CANCEL ROLL])

(SET.CURSOR
  [LAMBDA (COL ROW)                                                   (* bvm: "29-Aug-82 22:23")

          (* * Sets cursor to absolute screen position COL,ROW)


    (SELECTQ DISPLAYTERMFLG
	     (1 (TTBOUT ADDR (SLOGXOR COL 140Q)
			(SLOGXOR ROW 140Q)))
	     (2 (TTBOUT ESC Y (SPLUS ROW 40Q)
			(SPLUS COL 40Q)))
	     (3 (TTBOUT ESC a (SPLUS ROW 40Q)
			(SPLUS COL 40Q)))
	     NIL])
)



(* Support functions. These are all macros or for debugging)


(RPAQQ TTSUPPORTFNS (! !SETQ ADD1POS BIN EDITNUMBERP INPART INSERTING L-CASECODE TENEXP TTBOUT 
		       TTBOUTN TYPEAHEAD? U-CASECODE PR! PRALL PRBUF PRLINE))
(DEFINEQ

(!
  [NLAMBDA ($TAG)                                                     (* bvm: "24-Feb-80 00:00")

          (* Fetches a field from TTYINBUFFER arrayrecord. I.e. this could have been written
	  as (fetch $TAG of TTYINBUFFER), but the TTYINBUFFER is superfluous, since all !'s 
	  reference it. I prefer to think of ! as a pseudo-variable reference, which avoids 
	  the need for bunches of specvars to do the same job)


    (SETQ $TAG (BUFFIELDINFO $TAG))                                   (* Returns a list 
								      (offset HRRZ/HLRZ ! description)
)
    (PROG [(CELL (VAG (IPLUS (LOC TTYINBUFFER)
			     (CAR $TAG]
          (RETURN (COND
		    ((EQ (CADR $TAG)
			 'HRRZ)
		      (CAR CELL))
		    (T (CDR CELL])

(!SETQ
  [NLAMBDA ($TAG $VALUE)                                              (* bvm: "23-Feb-80 23:59")
                                                                      (* Like ! but sets a field)
    (SETQ $TAG (BUFFIELDINFO $TAG))                                   (* Returns a list 
								      (offset HRRZ/HLRZ ! description)
)
    (PROG [(CELL (VAG (IPLUS (LOC TTYINBUFFER)
			     (CAR $TAG]
          (SETQ $VALUE (EVAL $VALUE 'INTERNAL))
          (COND
	    ((EQ (CADR $TAG)
		 'HRRZ)
	      (FRPLACA CELL $VALUE))
	    (T (FRPLACD CELL $VALUE)))
          (RETURN $VALUE])

(ADD1POS
  [LAMBDA NIL                                                         (* bvm: "17-Aug-78 00:13")
    (!SETQ CURSORCOL (SADD1 (! CURSORCOL])

(BIN
  [LAMBDA (JFN)                                                       (* bvm: "23-Jun-79 20:39")
    (JS BIN JFN NIL NIL 2)])

(EDITNUMBERP
  [LAMBDA (CHAR)                                                      (* bvm: "17-Aug-78 00:13")
    (AND [NOT (MINUSP (SETQ CHAR (SDIFFERENCE CHAR (CONSTANT (CHCON1 0]
	 (NOT (SGREATERP CHAR 11Q))
	 CHAR])

(INPART
  [LAMBDA (X)                                                         (* bvm: " 3-Jul-78 12:27")

          (* Given a "word" from the spelling list, returns that which would be input to 
	  TTYIN, i.e. if a dotted synonym pair, its CAR, else the word itself)


    (COND
      ((LISTP X)
	(CAR X))
      (T X])

(INSERTING
  [LAMBDA NIL                                                         (* bvm: "23-Jun-79 22:49")

          (* * True if explicitly in INSERT mode, or if we are in EMACS mode, where most 
	  characters self-insert)


    (OR INSERTING EMACSFLG])

(L-CASECODE
  [LAMBDA (CHAR)                                                      (* bvm: "17-Aug-78 00:13")
    (COND
      ([AND [NOT (SLESSP CHAR (CONSTANT (CHCON1 'A]
	    (NOT (SGREATERP CHAR (CONSTANT (CHCON1 'Z]
	(LOGOR CHAR 40Q))
      (T CHAR])

(TENEXP
  [LAMBDA NIL                                                         (* bvm: "23-Jun-79 21:12")
    (EQ (SYSTEMTYPE)
	'TENEX])

(TTBOUT
  [NLAMBDA CHARS                                                      (* bvm: "29-Aug-82 22:07")

          (* Prints one or more characters to the terminal. Arguments may be: a number, an 
	  atom on DMCHARCODES, or a single character; any other arg is simply evaluated)


    (for $CH in CHARS do (JS PBOUT (COND
			       ((FIXP $CH)
				 $CH)
			       ((CDR (FASSOC $CH DMCHARCODES)))
			       ((EQ (NCHARS $CH)
				    1)
				 (CHCON1 $CH))
			       ((AND (EQ (NCHARS $CH)
					 2)
				     (EQ (NTHCHARCODE $CH 1)
					 (CHARCODE ^)))
				 (LOGAND 37Q (NTHCHARCODE $CH 2)))
			       (T (EVAL $CH))))
			 (COND
			   ((FIXP TTCLOCK)                            (* Slows down transmission rate 
								      for debugging)
			     (DISMISS TTCLOCK])

(TTBOUTN
  [NLAMBDA $NCHARS                                                    (* bvm: " 4-Mar-80 01:35")
    (FRPTQ (EVAL (CAR $NCHARS))
	   (APPLY 'TTBOUT (CDR $NCHARS])

(TYPEAHEAD?
  [LAMBDA NIL                                                         (* bvm: "26-Feb-80 02:10")
    (NOT (JS SIBE 100Q NIL NIL T)])

(U-CASECODE
  [LAMBDA (CHAR)                                                      (* bvm: "17-Aug-78 00:13")
    (COND
      ([AND [NOT (SLESSP CHAR (CONSTANT (CHCON1 'a]
	    (NOT (SGREATERP CHAR (CONSTANT (CHCON1 'z]
	(LOGAND CHAR 137Q))
      (T CHAR])

(PR!
  [LAMBDA NIL                                                         (* bvm: "17-Aug-78 01:23")
    (for X in BUFFIELDS do (SPACES 2)
			   (PRIN1 (SETQ X (CAR X)))
			   (PRIN1 ": ")
			   (COND
			     ((NLISTP (SETQ X (APPLY* '! X)))
			       (PRINT X))
			     ((SMALLP (CAR X))
			       (PRBUF X))
			     ((LISTP (CAR X))
			       (PRLINE X))
			     (T (PRINT X)))
       when (IGREATERP (CADR X)
		       2])

(PRALL
  [LAMBDA NIL                                                         (* bvm: "10-Aug-78 08:21")
    (for (LINE _(! FIRSTLINE)) by (fetch NEXTLINE of LINE) while LINE do (PRLINE LINE)
									 (TERPRI])

(PRBUF
  [LAMBDA (BUF END N)                                                 (* bvm: "17-Aug-78 00:13")
    [OR N (SETQ N (COND
	    (END 122Q)
	    (T 17Q]
    (PRIN1 '{)
    (for I from 1 to N while (AND BUF (NEQ BUF END)) bind X do [COND
								 ((NOT (SMALLP (CAR BUF)))
								   (RETURN (PRINT 'garbage]
							       [COND
								 ((PREFIXCHAR (CAR BUF))
								   (PRIN1 (QUOTE ')))
								 ((PADCHAR (CAR BUF))
								   (PRIN1 '%"]
							       [COND
								 ((SLESSP (SETQ X
									    (REALBITS (CAR BUF)))
									  40Q)
								   (PRIN1 '^)
								   (SETQ X (LOGOR X 100Q]
							       (PRIN1 (FCHARACTER X))
							       (SETQ BUF (CDR BUF))
       finally [COND
		 ((AND BUF (NEQ BUF END))
		   (PRIN1 '--]
	       (PRIN1 '})
	       (TERPRI])

(PRLINE
  [LAMBDA (LINE)                                                      (* bvm: "18-Aug-78 01:23")
    (PROG ((POS (POSITION T)))
          (COND
	    ((NOT LINE)
	      (SETQ LINE ARROW)
	      (PRIN1 "(defaulting)
")))
          (TAB POS T)
          [PRIN1 (COND
		   ((EQ LINE (EVALV 'ARROW))
		     '_)
		   (T '% ]
          (PRIN1 "Start: ")
          (PRBUF (fetch START of LINE)
		 (fetch END of LINE))
          (TAB POS T)
          (PRIN1 " End: ")
          (PRBUF (fetch END of LINE))
          (TAB POS T)
          (PRIN1 " First, last: ")
          (PRIN2 (fetch FIRSTCOL of LINE))
          (PRIN1 ", ")
          (PRINT (fetch LASTCOL of LINE))
          (TAB POS T)
          (PRIN1 " Row: ")
          (PRINT (fetch ROW of LINE))
          (COND
	    ((NEQ (fetch END of LINE)
		  (OR (LISTP (EVALV 'ENDBUFFER))
		      (! OLDTAIL)))
	      (TAB POS T)
	      (PRIN1 " Nextline: ")
	      (PRBUF (fetch START of (fetch NEXTLINE of LINE))
		     NIL 10Q])
)



(* Auxiliary fns. These are outside the TTYIN block, and are provided to aid the outside world in 
special interfaces to TTYIN)


(RPAQQ TTEXTRAFNS (SETREADFN TTYINPEEKC TTYINREADP TTYINREADPREP TTYINREAD DISPLAYTERMP TTECHOMODE 
			     TTED CHARMACRO?))
(DEFINEQ

(SETREADFN
  [LAMBDA (FLG)                                                       (* bvm: "17-Sep-82 10:39")
    (SETQ DISPLAYTERMFLG)                                             (* So DISPLAYTERMP's Heath 
								      initialization is forced)
    [COND
      ((AND (SMALLP FLG)
	    (IGEQ FLG 0)
	    (ILEQ FLG 3))                                             (* Set to this terminal type)
	(/PUTASSOC (JS GTTYP 100Q NIL NIL 2)
		   FLG
		   (OR DISPLAYTYPES (/SETATOMVAL 'DISPLAYTYPES (CONS -1 NIL]
    (/SETATOMVAL 'LISPXREADFN (COND
		   ((AND (OR (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
			     FLG TTYINBSFLG)
			 (FGETD 'TTYINREAD))
		     'TTYINREAD)
		   (T 'READ])

(TTYINPEEKC
  [LAMBDA (FILE)                                                      (* bvm: " 3-Aug-78 15:28")

          (* Replaces PEEKC in some lispx fns; returns NIL if we are TTYIN reading.
	  The PEEKC gets called when READP is true, mainly to see if there is a naked cr in 
	  the buffer. We don't leave any there, so the answer is no.
	  If we let the PEEKC happen, the peek is done in non-binary mode and screws things 
	  up.)


    (COND
      ((OR (NEQ LISPXREADFN 'TTYINREAD)
	   (NEQ FILE T))
	(PEEKC FILE])

(TTYINREADP
  [LAMBDA (FLG)                                                       (* edited: " 4-Mar-80 23:09")

          (* * Intended to replace LISPXREADP. Does the right thing when READBUF has just a 
	  <cr> in it)


    (COND
      ((AND READBUF (EQ (CAR READBUF)
			HISTSTR0)
	    (NOT FLG))
	                                                              (* just a <cr> waiting)
	NIL)
      (T (LISPXREADP FLG])

(TTYINREADPREP
  [LAMBDA NIL                                                         (* bvm: " 3-Aug-80 21:34")
                                                                      (* Prepare for reading with 
								      TTYINREAD by turning off LISP's 
								      ID char; TTYINREAD will handle 
								      it itself)
    (AND (EQ LISPXREADFN 'TTYINREAD)
	 (SETQ ID])

(TTYINREAD
  [LAMBDA NIL                                                         (* bvm: "24-Feb-80 21:55")
    (PROG (X)
          [COND
	    ([AND (SETQ X (TTYIN LISPXID NIL NIL 'EVALQT))
		  (OR (CDR X)
		      (NLISTP (CAR X]
	      

          (* Can only return the first thing on the line, so "unread" the rest, if there is 
	  any. If there is only a single atom on the line, then the HISTSTR0 we stuff here 
	  will make READLINE happy so it doesn't try to PEEKC and READC the lone <cr> that 
	  it thinks READ left there)


	      (SETQ READBUF (NCONC1 (CDR X)
				    HISTSTR0]
          (RETURN (CAR X])

(DISPLAYTERMP
  [LAMBDA NIL                                                         (* bvm: "30-Aug-82 22:39")

          (* * True if user's terminal is a display. The value returned is a code indicating
	  which kind.)


    (PROG [(TYPE (@S (JS GTTYP 777777Q NIL NIL 2)]
          [SETQ TYPE (COND
	      (DISPLAYTYPES                                           (* An alist of type associated 
								      with internal ttyin code;
								      overrides the table below)
			    (CDR (FASSOC TYPE DISPLAYTYPES)))
	      ((TENEXP)
		(SELECTQ TYPE
			 (13Q                                         (* datamedia)
			      1)
			 (22Q                                         (* Heath)
			      2)
			 ((11Q 14Q 20Q 21Q)                           (* Glass ttys)
			   0)
			 NIL))
	      (T 

          (* different table for tops20 to account for different type numbers in local use 
	  here. Too bad systems can't get together and agree on a universal set of codes)


		 (SELECTQ TYPE
			  (5                                          (* dm)
			     1)
			  ((26Q 31Q)                                  (* Heath, old and new 
								      assignments)
			    2)
			  ((6 7 17Q 23Q)                              (* glass ttys)
			    0)
			  NIL]
          [COND
	    [(AND (EQ TYPE 2)
		  USEHEATHKEYPAD)
	      (COND
		((NEQ TYPE DISPLAYTERMFLG)                            (* Set up to use keypad.
								      Only do this first time that we 
								      notice we are a HEATH)
		  (SETQ TTYINKEYPADPREFIX2 (SETQ TTYINKEYPADPREFIX (CHARCODE ESCAPE)))
		  (JS SFMOD 100Q (PROG1 (JS RFMOD 100Q NIL NIL 2)     (* Turn on alternate keypad, 
								      turn off shifted keypad)
					(JS SFMOD 100Q 0)             (* Set binary mode)
					(TTBOUT ESC u ESC =)))
		  (MOVD 'TTHEATHKEYPAD 'TTYINKEYPAD]
	    [(AND (EQ TYPE 3)
		  USECONCEPTKEYPAD)
	      (COND
		((NEQ TYPE DISPLAYTERMFLG)
		  (SETQ TTYINKEYPADPREFIX (CHARCODE ^\))
		  (SETQ TTYINKEYPADPREFIX2 (CHARCODE ESCAPE))
		  (ENABLE.CONCEPT.KEYPAD)
		  (MOVD 'TTCONCEPTKEYPAD 'TTYINKEYPAD]
	    (T (SETQ TTYINKEYPADPREFIX2 (SETQ TTYINKEYPADPREFIX]
          (RETURN TYPE])

(TTECHOMODE
  [LAMBDA (FLG)                                                       (* bvm: "10-Jul-79 21:01")

          (* This goes on BREAKRESETFORMS and RESETFORMS to make sure echoing is on.
	  It does nothing if we're using TTYIN to read, though, since the echomode is then 
	  irrelevant)


    (IF LISPXREADFN ='TTYINREAD
	THEN T
      ELSE (ECHOMODE FLG])

(TTED
  [NLAMBDA (FN C)
    (DECLARE (USEDFREE COM))                                          (* bvm: "24-Feb-80 21:35")

          (* Does the ED macro, returning a com to execute if there is any change to be 
	  made. Can also be used for other types of editor escapes if FN is supplied.
	  FN{exprlist,com} is called to edit a list of expressions. C is com)


    (PROG ((EXPR (##))
	   (TOP (## ^))
	   UP NEW N)
          (SETQ COM (OR C 'ED))
          [COND
	    ((NEQ TOP EXPR)
	                                                              (* would generate error if at 
								      top)
	      (SETQ UP (## UP]                                        (* in case of error, will print 
								      ED ?, instead of some long edit 
								      macro body)
          [COND
	    ((NEQ UP EXPR)
	                                                              (* If current expression is not 
								      a tail, pretend it is a list of 
								      one expression)
	      (SETQ EXPR (LIST (COND
				 ((AND (EQ (CAR (LISTP EXPR))
					   COMMENTFLG)
				       (LISTP (CADR EXPR))
				       (FIXP (CADDR EXPR)))
				                                      (* EXPR is a comment pointer, so
								      get the real comment to edit)
				   (GETCOMMENT EXPR))
				 (T EXPR]
          (RETURN (COND
		    ([NOT (SETQ NEW (COND
			      (FN (APPLY* FN EXPR C))
			      (T (TTYIN "** " NIL NIL 'LISPXREAD NIL NIL EXPR]
		                                                      (* Replace with nothing?)
		      (ERROR!))
		    ((EQUAL NEW EXPR)
		      (PRIN1 "(not changed)
" T)
		      NIL)
		    [(OR (EQ EXPR UP)
			 (EQ (CAR EXPR)
			     TOP))
		                                                      (* Current expression is the top
								      or a tail; can't use simple : 
								      command.)
		      (CONS 'REPLACE (CONS '(1 TO)
					   (CONS 'WITH (COND
						   ((OR (EQ UP EXPR)
							(CDR NEW))
						     

          (* Second case only happens if replacing the top-level expression with more than 
	  one expression. That is really an error, but this way we at least avoid losing 
	  data)


						     NEW)
						   (T (CAR NEW]
		    ([AND (LISTP (CAR NEW))
			  (NOT (CDR NEW))
			  (SETQ N (MEMB (CAR EXPR)
					(SETQ UP (## 0]
		      

          (* replacing an element with a list: if we did a : command, the editor would then 
	  be positioned at a tail, and even if we did a (1 --) there would still be a tail 
	  in the edit chain. Better way to do this is thus to go up a level and do the 
	  appropriate (n --) command and come back down. I wish the editor had a command to 
	  do this.)


		      (LIST 'COMSQ 0 (CONS [SETQ N (for $$VAL_1 while (NEQ N UP) do (ADD1VAR $$VAL)
										    (SETQ UP
										      (CDR UP]
					   NEW)
			    N))
		    (T 

          (* Simple replacement of one element. We could be fancier and leave the current 
	  expression being the one just typed, but that seems like a lot of bother)


		       (CONS ': NEW])

(CHARMACRO?
  [NLAMBDA (MACRO)
    (DECLARE (USEDFREE READING LISPXID))                              (* bvm: "24-Feb-80 22:00")

          (* * For use in a TTYINREADMACRO. If we are reading inside the editor, clear the 
	  output buffer and return MACRO)


    (COND
      ((AND (EQ READING 'EVALQT)
	    (EQ LISPXID '*))
	(COND
	  ((NOT (JS SOBE 101Q NIL NIL T))
	                                                              (* Output active.
								      Flush it)
	    (JS CFOBF 101Q)
	    (SELECTQ DISPLAYTERMFLG
		     (1                                               (* Positions cursor at lower 
								      left of screen. This is 
								      essential if the CFOBF we just 
								      did interrupted a cursor 
								      addressing operation)
			(TTBOUT ADDR 140Q 167Q))
		     NIL)))
	(COND
	  ((LISTP MACRO)
	                                                              (* a list of edit commands;
								      we'd better copy)
	    (APPEND MACRO))
	  (T MACRO])
)
(DECLARE: DOEVAL@COMPILE DONTCOPY 

(RPAQQ TTCOMPILETIME [(BLOCKS * TTYINBLOCKS)
	(MACROS * TTYINMACROS)
	(PROP (OPD ACS)
	      BUFLOAD BUFSTORE)
	(RECORDS ATOM LINE TTYINBUFFER)
	(VARS (TTCLOCK)
	      (CHANGESARRAY)
	      BUFFIELDS DMCHARCODES TTSUPPORTFNS)
	(FILES (SYSLOAD)
	       SARITH CJSYS)
	(INITVARS (PACSFLG T)
		  (NOBLOCKSFLG T))
	[P (* PACSFLG means to use the internal lisp atom packer, rather than a closed call to PACKC; 
	      the internal packer does not exist in pre-1979 or so lisps. NOBLOCKSFLG is ordinarily 
	      bound in BCOMPL, but we set top-level value here in case macros want them. TTSUPPORTFNS 
	      is saved above so the compiler can get at its value for the UNION down below.)
	   (PUTDQ? BUFFIELDINFO (LAMBDA (FIELD)
					(OR (CDR (FASSOC FIELD BUFFIELDS))
					    (SHOULDNT]
	(ADDVARS (DONTCOMPILEFNS &DISPLAYCOMMENT))
	(DECLARE: DONTEVAL@COMPILE
		  (TEMPLATES ! !SETQ AT.END.OF.BUF AT.END.OF.LINE AT.START.OF.BUF AT.START.OF.LINE 
			     EMPTY.BUFFER EMPTY.LINE INSERTING ON.FIRST.LINE ON.LAST.LINE PADCHAR 
			     PREFIXCHAR REALBITS SPACEP TTBOUT TTBOUTN)
		  (P (RADIX 10Q)
		     (CHANGENAME 'EDITFBLOCK 'GETBLOCKDEC 'NILL)
		     (* So EDITF doesn't knock itself out trying to load the "rest of the block" !))
		  (LISPXMACROS _ _B)
		  DONTEVAL@LOAD EVAL@COMPILEWHEN (NOT NOBLOCKSFLG)
		  (VARS (DONTCOMPILEFNS (UNION (UNION TTYINMACROS TTSUPPORTFNS)
					       DONTCOMPILEFNS)))
		  (P (RESETLST (RESETSAVE NIL (LIST 'MINFS (MINFS 27000Q 'FIXP)
						    'FIXP))
			       (RECLAIM 'FIXP))
		     (* Reserve some space)
		     (SETSBSIZE 70Q])

(RPAQQ TTYINBLOCKS ((TTYIN (GLOBALVARS ?ACTIVATEFLG CAR/CDRNIL CTRLVFLG DEFAULTPROMPT EDITCOMSL 
				       EDITPREFIXCHAR EMACSFLG LASTWORD SHOWPARENFLG SPELLSTR1 
				       SPELLSTR2 TTYINBUFFER TTYINCOMPLETEFLG TTYINMAILFLG 
				       TTYINREADMACROS TTYINRESPONSES TTYINUSERFN TTYJUSTLENGTH 
				       TTYPAGELENGTH TYPEAHEADFLG USERWORDS null TTYINBSFLG)
			   (LOCALFREEVARS ARROW AUTOFILL BUFFER COMMAND CURSOR DELETING EDITBIT 
					  ENDBUFFER INITPOS INSERTING NOFIXSPELL READING REPEAT)
			   (SPECVARS CTRLO!)
			   (LINKFNS . T)
			   (NOLINKFNS DISPLAYHELP DISPLAYTERMP EDITE ERROR! FIXSPELL!! GRIPE 
				      GUESTUSER? MAILWATCH MWNOTE SETBACKSPACE SHOULDNT SMARTARGLIST 
				      SPRINTT STKEVAL STRPOS USEREXEC XHELPSYS TTYINKEYPAD)
			   (BLKLIBRARY NLEFT)
			   TTYIN TTBIN TTCRLF TTCRLF.ACCOUNT SCANFORWARD TTNLEFT TTNTH TTPRIN1 
			   TTPROMPTCHAR TTRATOM TTREAD TTREADLIST TTSKIPSEPR TTSKREAD TTYINSTRING 
			   ADDCHAR ADDNAKEDCHAR AUTOCR? BACKWARD.DELETE.TO BEEP BINARY.MODE BUFTAILP 
			   CLEAR.LINE? CREATE.LINE DELETE.TO.END DELETETO DELETETO1 DELNCHARS 
			   ECHOFILE ENDELETE ENDREAD? AT.END.OF.TEXT FIRSTWORD FIXWORD 
			   FORWARD.DELETE.TO GO.TO GO.TO.ADDRESSING GO.TO.FREELINE INIT.CURSOR 
			   INSERT.CHAR.IN.BUF ADDCHARS.INSERTING INSERTCONS RUBOUT INSERTSPACES.DM 
			   KILL.LINES KILLSEGMENT MOVE.BACK.TO MOVE.FORWARD.TO MOVE.TO.NEXT.LINE 
			   NEWLINE NEXTCHAR NEXTCONS OVERFLOW? PROPERTAILP RESTORE.CURSOR RESTOREMOD 
			   SAVE.CURSOR SCRATCHCONS SETLASTC SETTAIL? SPACE/PARENP EDITCHAR 
			   ADDSILENTCHAR ADDTAB AT.END.OF.SCREEN SCANBACK BACKSKREAD BREAKLINE BUFLEN 
			   CHECK.MARGIN COMPLETEWORD FINDMATCH NTHCHARCODE DELETELINE DO?CMD DOTABS 
			   EDITCOLUMN FIND.LINE FINDBREAK ADJUSTLINE START.OF.PARAGRAPH? 
			   ADJUSTLINE.AND.RESTORE GIVEHELP GIVEHELP1 GIVEHELP2 INSERTLINE LASTLINE 
			   LOADBUF MODE.CHANGE? MOVE.TO.LINE MOVE.TO.START.OF.WORD MOVE.TO.WHEREVER 
			   NEXTLINE NEXTQUOTE NEXTWORD NTH.COLUMN.OF NTH.RELATIVE.COLUMN.OF 
			   OVERFLOWLINE? PREVLINE PREVWORD READFROMBUF RENUMBER.LINES RESTOREBUF 
			   RETYPE SHOW.MATCHING.PAREN SKIP/ZAP SLEEP STRIPBLANKS TENEXCOMPLETE 
			   THISWORD TYPE.BUFFER U/L-CASE UNREADBUF CANCEL.MODES DO.BACK 
			   DO.DELETE.LINES DO.DOWN DO.FORWARD DO.HOME DO.INSERT.LINE DO.UP 
			   ERASE.SCREEN ERASE.TO.END.OF.LINE ERASE.TO.END.OF.PAGE INSERT.TEXT 
			   INSERTNCHARS SET.CURSOR TTGETFILE LOADBUFFROMFILE DO.EXTEND.COMMAND)
	(NIL TTYINREAD (LOCALVARS . T)
	     (GLOBALVARS LISPXID)
	     (LINKFNS TTYIN))
	(NIL DISPLAYTERMP SETREADFN TTECHOMODE TTED TTYINPEEKC TTYINREADP TTYINREADPREP CHARMACRO?
	     (LOCALVARS . T)
	     (GLOBALVARS DISPLAYTYPES LISPXID LISPXREADFN))))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
(BLOCK: TTYIN
	(GLOBALVARS ?ACTIVATEFLG CAR/CDRNIL CTRLVFLG DEFAULTPROMPT EDITCOMSL EDITPREFIXCHAR EMACSFLG 
		    LASTWORD SHOWPARENFLG SPELLSTR1 SPELLSTR2 TTYINBUFFER TTYINCOMPLETEFLG 
		    TTYINMAILFLG TTYINREADMACROS TTYINRESPONSES TTYINUSERFN TTYJUSTLENGTH 
		    TTYPAGELENGTH TYPEAHEADFLG USERWORDS null TTYINBSFLG)
	(LOCALFREEVARS ARROW AUTOFILL BUFFER COMMAND CURSOR DELETING EDITBIT ENDBUFFER INITPOS 
		       INSERTING NOFIXSPELL READING REPEAT)
	(SPECVARS CTRLO!)
	(LINKFNS . T)
	(NOLINKFNS DISPLAYHELP DISPLAYTERMP EDITE ERROR! FIXSPELL!! GRIPE GUESTUSER? MAILWATCH MWNOTE 
		   SETBACKSPACE SHOULDNT SMARTARGLIST SPRINTT STKEVAL STRPOS USEREXEC XHELPSYS 
		   TTYINKEYPAD)
	(BLKLIBRARY NLEFT)
	TTYIN TTBIN TTCRLF TTCRLF.ACCOUNT SCANFORWARD TTNLEFT TTNTH TTPRIN1 TTPROMPTCHAR TTRATOM 
	TTREAD TTREADLIST TTSKIPSEPR TTSKREAD TTYINSTRING ADDCHAR ADDNAKEDCHAR AUTOCR? 
	BACKWARD.DELETE.TO BEEP BINARY.MODE BUFTAILP CLEAR.LINE? CREATE.LINE DELETE.TO.END DELETETO 
	DELETETO1 DELNCHARS ECHOFILE ENDELETE ENDREAD? AT.END.OF.TEXT FIRSTWORD FIXWORD 
	FORWARD.DELETE.TO GO.TO GO.TO.ADDRESSING GO.TO.FREELINE INIT.CURSOR INSERT.CHAR.IN.BUF 
	ADDCHARS.INSERTING INSERTCONS RUBOUT INSERTSPACES.DM KILL.LINES KILLSEGMENT MOVE.BACK.TO 
	MOVE.FORWARD.TO MOVE.TO.NEXT.LINE NEWLINE NEXTCHAR NEXTCONS OVERFLOW? PROPERTAILP 
	RESTORE.CURSOR RESTOREMOD SAVE.CURSOR SCRATCHCONS SETLASTC SETTAIL? SPACE/PARENP EDITCHAR 
	ADDSILENTCHAR ADDTAB AT.END.OF.SCREEN SCANBACK BACKSKREAD BREAKLINE BUFLEN CHECK.MARGIN 
	COMPLETEWORD FINDMATCH NTHCHARCODE DELETELINE DO?CMD DOTABS EDITCOLUMN FIND.LINE FINDBREAK 
	ADJUSTLINE START.OF.PARAGRAPH? ADJUSTLINE.AND.RESTORE GIVEHELP GIVEHELP1 GIVEHELP2 INSERTLINE 
	LASTLINE LOADBUF MODE.CHANGE? MOVE.TO.LINE MOVE.TO.START.OF.WORD MOVE.TO.WHEREVER NEXTLINE 
	NEXTQUOTE NEXTWORD NTH.COLUMN.OF NTH.RELATIVE.COLUMN.OF OVERFLOWLINE? PREVLINE PREVWORD 
	READFROMBUF RENUMBER.LINES RESTOREBUF RETYPE SHOW.MATCHING.PAREN SKIP/ZAP SLEEP STRIPBLANKS 
	TENEXCOMPLETE THISWORD TYPE.BUFFER U/L-CASE UNREADBUF CANCEL.MODES DO.BACK DO.DELETE.LINES 
	DO.DOWN DO.FORWARD DO.HOME DO.INSERT.LINE DO.UP ERASE.SCREEN ERASE.TO.END.OF.LINE 
	ERASE.TO.END.OF.PAGE INSERT.TEXT INSERTNCHARS SET.CURSOR TTGETFILE LOADBUFFROMFILE 
	DO.EXTEND.COMMAND)
(BLOCK: NIL TTYINREAD (LOCALVARS . T)
	(GLOBALVARS LISPXID)
	(LINKFNS TTYIN))
(BLOCK: NIL DISPLAYTERMP SETREADFN TTECHOMODE TTED TTYINPEEKC TTYINREADP TTYINREADPREP CHARMACRO?
	(LOCALVARS . T)
	(GLOBALVARS DISPLAYTYPES LISPXID LISPXREADFN))
]

(RPAQQ TTYINMACROS (! !SETQ ADD1POS AT.END.OF.BUF AT.END.OF.LINE AT.START.OF.BUF AT.START.OF.LINE BIN 
		      CAPABILITY? EDITNUMBERP EMPTY.BUFFER EMPTY.LINE INPART INSERTING L-CASECODE 
		      ON.FIRST.LINE ON.LAST.LINE PADCHAR PREFIXCHAR REALBITS SPACEP TENEXP TTBOUT 
		      TTBOUTN TTPACK TYPEAHEAD? U-CASECODE))
(DECLARE: EVAL@COMPILE 

(PUTPROPS ! MACRO (X (SETQ X (BUFFIELDINFO (CAR X)))
		     (CEXP2 'TTYINBUFFER)
		     (STORIN (LIST 'BUFLOAD (CAR X)
				   (CADR X)))
		     'INSTRUCTIONS))

(PUTPROPS !SETQ MACRO (X (CEXP (CADR X))
			 (SETQ X (BUFFIELDINFO (CAR X)))
			 (CEXP2 'TTYINBUFFER)
			 [STORIN (LIST 'BUFSTORE (CAR X)
				       (SELECTQ (CADR X)
						(HRRZ 'HRRM)
						(HLRZ 'HRLM)
						(SHOULDNT]
			 'INSTRUCTIONS))

(PUTPROPS ADD1POS MACRO [NIL (ASSEMBLE NIL
				       (CQ2 TTYINBUFFER)
				       (AOS 1 , 3 (2])

(PUTPROPS AT.END.OF.BUF MACRO (NIL (EQ CURSOR ENDBUFFER)))

(PUTPROPS AT.END.OF.LINE MACRO (NIL (EQ (fetch END of ARROW)
					CURSOR)))

(PUTPROPS AT.START.OF.BUF MACRO (NIL (EQ CURSOR BUFFER)))

(PUTPROPS AT.START.OF.LINE MACRO (NIL (EQ (fetch START of ARROW)
					  CURSOR)))

(PUTPROPS BIN 10MACRO ((JFN)
		       (JS BIN JFN NIL NIL 2)))

(PUTPROPS BIN MACRO [(JFN)
		     (ASSEMBLE NIL
			       (E (CNEXP 'JFN 'FIXT))
			       (JS BIN)
			       (MOVEI 1 , ASZ (2])

(PUTPROPS CAPABILITY? MACRO [X (COND
				 (NOBLOCKSFLG                         (* Make closed call to 
								      CAPABILITY? to let us easier 
								      debug new terminal types)
					      'IGNOREMACRO)
				 ((EQ (CAR X)
				      'EDIT)
				   '(EQ DISPLAYTERMFLG 1))
				 ((CADR X)                            (* Know we are on a display)
				   '(NEQ DISPLAYTERMFLG 0))
				 (T '(SELECTQ DISPLAYTERMFLG
					      ((1 2 3)
						T)
					      NIL])

(PUTPROPS EDITNUMBERP MACRO ((X)
			     (ASSEMBLE NIL
				       (CQ X)
				       (SUBI 1 , (CHCON1 0))
				       (CAIL 1 , ASZ 0)
				       (CAILE 1 , ASZ 11Q)
				       (MOVE 1 , KNIL))))

(PUTPROPS EMPTY.BUFFER MACRO (NIL (EQ BUFFER ENDBUFFER)))

(PUTPROPS EMPTY.LINE MACRO [X (SUBST (OR (CAR X)
					 'ARROW)
				     'ARROW
				     '(EQ (fetch START of ARROW)
					  (fetch END of ARROW])

(PUTPROPS INPART MACRO ((X)
			(ASSEMBLE NIL
			          (CQ X)
			          (STN 'LISTT)
			          (CAR1))))

(PUTPROPS INSERTING MACRO (NIL (OR INSERTING EMACSFLG)))

(PUTPROPS L-CASECODE MACRO ((X)
			    (ASSEMBLE NIL
				      (CQ X)
				      (CAIGE 1 , ASZ 101Q)
				      (JRST * 3)
				      (CAIG 1 , ASZ 132Q)
				      (ADDI 1 , 40Q))))

(PUTPROPS ON.FIRST.LINE MACRO (NIL (EQ (! FIRSTLINE)
				       ARROW)))

(PUTPROPS ON.LAST.LINE MACRO (NIL (EQ (fetch END of ARROW)
				      ENDBUFFER)))

(PUTPROPS PADCHAR MACRO ((CHAR)
			 (TESTBITS 400Q (@S CHAR))))

(PUTPROPS PREFIXCHAR MACRO ((CHAR)
			    (TESTBITS 200Q (@S CHAR))))

(PUTPROPS REALBITS MACRO ((X)
			  (SLOGAND X 177Q)))

(PUTPROPS SPACEP MACRO [(CHAR)
			(FMEMB (REALBITS CHAR)
			       '(40Q 11Q 37Q])

(PUTPROPS TENEXP MACRO (X (PRED2 'SKIPE 'SKIPN '(KL20FLG))
			  (SETQ PCF)
			  'INSTRUCTIONS))

(PUTPROPS TTBOUT MACRO [X (CONS 'ASSEMBLE
				(CONS NIL (for ARG in X bind N
					     join
					      (LIST (COND
						      ([SETQ N
							  (OR (FIXP ARG)
							      (CDR (ASSOC ARG DMCHARCODES))
							      (AND (EQ (NCHARS ARG)
								       1)
								   (CHCON1 ARG))
							      (AND (EQ (NCHARS ARG)
								       2)
								   (EQ (NTHCHARCODE ARG 1)
								       (CHARCODE ^))
								   (LOGAND 37Q (NTHCHARCODE ARG 2]
							(LIST 'MOVEI 1 ', N))
						      (T 

          (* Can't figure it out at compiletime, so just eval it. Assumes is a small number 
	  so we don't have to unbox it when printing its low seven bits)


							 (LIST 'CQ ARG)))
						    '(JS PBOUT)])

(PUTPROPS TTBOUTN MACRO ((N . CHARS)
			 (ASSEMBLE NIL
			           (E (CNEXP '(SUNBOX N)
					     'FIXT))                  (* Do SUNBOX for cheap unbox if 
								      needed)
			           (JUMPE 1 , NOBOUT)
			           (MOVE 3 , 1)
			       LP  (CQ (TTBOUT . CHARS))
			           (SOJG 3 , LP)
			       NOBOUT)))

(PUTPROPS TTPACK MACRO [X (SUBPAIR '(START END)
				   X
				   (COND
				     [(AND PACSFLG (GETP 'PACS 'COREVAL))
                                                                      (* Use speedy packer.
								      Earlier systems don't have this 
								      coreval, so have to do slow call
								      to PACKC)
				       '(ASSEMBLE NIL
					          (CQ START)
					          (CQ2 END)
					          (MOVE 3 , 1)
					          (MOVE 4 , 2)
					          (FASTCALL PACS)     (* init atom maker)
					      LP  (CAMN 3 , 4)
					          (JRST DONE)
					          (HRRZ 1 , 0 (3))    (* get byte)
					          (SUBI 1 , ASZ)      (* unbox it)
					          (FASTCALL PAC)      (* Give it to packer)
					          (CDR2 3)
					          (JRST LP)
					      DONE(FASTCALL MKATM]
				     (T '(PROGN (FRPLACD PREVBUF)
						(PROG1 (PACKC ENDBUFFER)
						       (FRPLACD PREVBUF PACKBUF])

(PUTPROPS TYPEAHEAD? MACRO (NIL (NOT (JS SIBE 100Q NIL NIL T))))

(PUTPROPS U-CASECODE MACRO ((X)
			    (ASSEMBLE NIL
				      (CQ X)
				      (CAIGE 1 , ASZ 141Q)
				      (JRST * 3)
				      (CAIG 1 , ASZ 172Q)
				      (SUBI 1 , 40Q))))
)

(PUTPROPS BUFLOAD OPD ((OFFSET OP)
		       (OP 1 , OFFSET (2))))

(PUTPROPS BUFSTORE OPD ((OFFSET OP)
			(OP 1 , OFFSET (2))))

(PUTPROPS BUFLOAD ACS C1)

(PUTPROPS BUFSTORE ACS NOEFF)
[DECLARE: EVAL@COMPILE 

(BLOCKRECORD ATOM (NIL NIL NIL NIL PNAME NIL))

(RECORD LINE (START END FIRSTCOL LASTCOL ROW . NEXTLINE))

(BLOCKRECORD TTYINBUFFER ((NIL INTEGER)
			  (NIL INTEGER)
			  (TTYMODE INTEGER)
			  CURSORROW CURSORCOL HOMEROW HOMECOL PROMPT1 PROMPT2 FIRSTLINE OLDTAIL 
			  LASTAIL FIX LASTSKIP LASTSKIPCHAR SPLST HELP LOC.ROW.0 LASTCHAR SPLSTFLG 
			  EDITABLE)
			 TTYINBUFFER _(ARRAY 12Q 1))
]

(RPAQQ TTCLOCK NIL)

(RPAQQ CHANGESARRAY NIL)

(RPAQQ BUFFIELDS ((TTYMODE 2 -- Full integer value of SFMOD. Not accessible by !)
	(CURSORROW 3 HLRZ Current row of cursor, updated for any movement)
	(CURSORCOL 3 HRRZ Ditto for column)
	(HOMEROW 4 HLRZ Place to save row when we run off to do other things)
	(HOMECOL 4 HRRZ and column. Also use this for "target column" for edit commands)
	(PROMPT1 5 HLRZ Prompt for first line of input, NIL if none)
	(PROMPT2 5 HRRZ ... for subsequent lines)
	(FIRSTLINE 6 HLRZ First LINE record of the buffer. Its START is BUFFER)
	(LASTAIL 6 HRRZ Farthest tail of buffer that the user has typed to; used for restoring it on 
		 <lf> command)
	(OLDTAIL 7 HLRZ Tail of buffer where previous non-empty input ended)
	(FIX 7 HRRZ True if responses must be on SPLST)
	(LASTSKIP 10Q HLRZ Last skip command issued (S, B or Z))
	(LASTSKIPCHAR 10Q HRRZ its target char)
	(SPLST 11Q HLRZ SPLST, stored here so it needn't be a specvar)
	(HELP 11Q HRRZ ditto)
	(LOC.ROW.0 12Q HLRZ Absolute screen location of the first row, possibly negative if we have 
		   more than a screenful)
	(LASTCHAR 12Q HRRZ Character typed before this one)
	(SPLSTFLG 13Q HLRZ True if SPLST is a lisp-style spelling list (contains SPELLSTR1))
	(EDITABLE 13Q HRRZ True if terminal can transmit edit bit)))

(RPAQQ DMCHARCODES ((HOME . 2)
		    (BELL . 7)
		    (DELCH . 10Q)
		    (BS . 10Q)
		    (DOWN . 12Q)
		    (INSERT.LINE . 12Q)
		    (LF . 12Q)
		    (ADDR . 14Q)
		    (CR . 15Q)
		    (BLINKON . 16Q)
		    (INSERT/DELETE . 20Q)
		    (DLE . 20Q)
		    (ERASE.TO.END . 27Q)
		    (CANCEL . 30Q)
		    (UP . 32Q)
		    (DELETE.LINE . 32Q)
		    (ESC . 33Q)
		    (FORWARD . 34Q)
		    (ROLL . 35Q)
		    (ERASE . 36Q)
		    (CLEAR . 36Q)
		    (US . 37Q)
		    (SPACE . 40Q)))

(RPAQQ TTSUPPORTFNS (! !SETQ ADD1POS BIN EDITNUMBERP INPART INSERTING L-CASECODE TENEXP TTBOUT 
		       TTBOUTN TYPEAHEAD? U-CASECODE PR! PRALL PRBUF PRLINE))
(FILESLOAD (SYSLOAD)
	   SARITH CJSYS)
(AND (EQ (EVALV 'PACSFLG)
	 'NOBIND)
     (RPAQ PACSFLG T))
(AND (EQ (EVALV 'NOBLOCKSFLG)
	 'NOBIND)
     (RPAQ NOBLOCKSFLG T))
(* PACSFLG means to use the internal lisp atom packer, rather than a closed call to PACKC; the 
   internal packer does not exist in pre-1979 or so lisps. NOBLOCKSFLG is ordinarily bound in BCOMPL, 
   but we set top-level value here in case macros want them. TTSUPPORTFNS is saved above so the 
   compiler can get at its value for the UNION down below.)
[PUTDQ? BUFFIELDINFO (LAMBDA (FIELD)
			     (OR (CDR (FASSOC FIELD BUFFIELDS))
				 (SHOULDNT]

(ADDTOVAR DONTCOMPILEFNS &DISPLAYCOMMENT)
(DECLARE: DONTEVAL@COMPILE 
(SETTEMPLATE '! '(FETCH))
(SETTEMPLATE '!SETQ '(REPLACE EVAL))
(SETTEMPLATE 'AT.END.OF.BUF 'MACRO)
(SETTEMPLATE 'AT.END.OF.LINE 'MACRO)
(SETTEMPLATE 'AT.START.OF.BUF 'MACRO)
(SETTEMPLATE 'AT.START.OF.LINE 'MACRO)
(SETTEMPLATE 'EMPTY.BUFFER 'MACRO)
(SETTEMPLATE 'EMPTY.LINE 'MACRO)
(SETTEMPLATE 'INSERTING 'MACRO)
(SETTEMPLATE 'ON.FIRST.LINE 'MACRO)
(SETTEMPLATE 'ON.LAST.LINE 'MACRO)
(SETTEMPLATE 'PADCHAR 'MACRO)
(SETTEMPLATE 'PREFIXCHAR 'MACRO)
(SETTEMPLATE 'REALBITS 'MACRO)
(SETTEMPLATE 'SPACEP 'MACRO)
[SETTEMPLATE 'TTBOUT '(.. (IF [OR (LISTP EXPR)
				  (AND (NTHCHAR EXPR 2)
				       (NOT (ASSOC EXPR DMCHARCODES]
			      EVAL NIL]
[SETTEMPLATE 'TTBOUTN '(MACRO (X . Y)
			      (FRPTQ X (TTBOUT . Y]

(RADIX 10Q)
(CHANGENAME 'EDITFBLOCK 'GETBLOCKDEC 'NILL)
(* So EDITF doesn't knock itself out trying to load the "rest of the block" !)

DONTEVAL@LOAD EVAL@COMPILEWHEN (NOT NOBLOCKSFLG) 

(RPAQ DONTCOMPILEFNS (UNION (UNION TTYINMACROS TTSUPPORTFNS)
			    DONTCOMPILEFNS))

(RESETLST (RESETSAVE NIL (LIST 'MINFS (MINFS 27000Q 'FIXP)
			       'FIXP))
	  (RECLAIM 'FIXP))
(* Reserve some space)
(SETSBSIZE 70Q)
)
)

(RPAQQ TTYINBUFFER NIL)
(AND (EQ (EVALV '?ACTIVATEFLG)
	 'NOBIND)
     (RPAQ ?ACTIVATEFLG NIL))
(AND (EQ (EVALV 'EDITPREFIXCHAR)
	 'NOBIND)
     (RPAQ EDITPREFIXCHAR NIL))
(AND (EQ (EVALV 'EMACSFLG)
	 'NOBIND)
     (RPAQ EMACSFLG NIL))
(AND (EQ (EVALV 'SHOWPARENFLG)
	 'NOBIND)
     (RPAQ SHOWPARENFLG NIL))
(AND (EQ (EVALV 'TTYINBSFLG)
	 'NOBIND)
     (RPAQ TTYINBSFLG NIL))
(AND (EQ (EVALV 'TTYINCOMPLETEFLG)
	 'NOBIND)
     (RPAQ TTYINCOMPLETEFLG NIL))
(AND (EQ (EVALV 'TTYINMAILFLG)
	 'NOBIND)
     (RPAQ TTYINMAILFLG NIL))
(AND (EQ (EVALV 'TTYINUSERFN)
	 'NOBIND)
     (RPAQ TTYINUSERFN NIL))
(AND (EQ (EVALV 'TYPEAHEADFLG)
	 'NOBIND)
     (RPAQ TYPEAHEADFLG NIL))
(AND (EQ (EVALV 'null)
	 'NOBIND)
     (RPAQ null ""))
(AND (EQ (EVALV 'DEFAULTPROMPT)
	 'NOBIND)
     (RPAQ DEFAULTPROMPT "** "))
(AND (EQ (EVALV 'TTYJUSTLENGTH)
	 'NOBIND)
     (RPAQ TTYJUSTLENGTH 110Q))
(AND (EQ (EVALV 'TTYPAGELENGTH)
	 'NOBIND)
     (RPAQ TTYPAGELENGTH 30Q))
(MOVD? 'NILL 'GUESTUSER?)
(MOVD? 'FIXSPELL 'FIXSPELL!!)
(MOVD? 'HELPSYS 'XHELPSYS)
(PUTDQ? SPRINTT [LAMBDA (X)
			(PRIN1 X])
(ECHOCONTROL 10Q 'REAL)

(ADDTOVAR TTYINREADMACROS )

(ADDTOVAR TTYINRESPONSES )

(ADDTOVAR DISPLAYTYPES )

(ADDTOVAR LISPXCOMS (STOP . OK))

(ADDTOVAR BREAKRESETFORMS (TTECHOMODE T))

(ADDTOVAR RESETFORMS (TTECHOMODE T))



(* Heath stuff)

(DEFINEQ

(TTHEATHKEYPAD
  [LAMBDA NIL                                                         (* bvm: " 3-Apr-82 22:38")
                                                                      (* Interprets keypad, returning an 
										"equivalent" list of character codes)
    (PROG ((CH (BIN 100Q)))
          [COND
	    ((EQ CH (CHARCODE ?))                                     (* It's one of the 3-char 
								      sequences)
	      (SETQ CH (BIN 100Q))
	      (COND
		((EQ CH (CHARCODE M))                                 (* This is the only ambiguity between 
										good Heaths and bad ones that drop the 
										?. Turn this into another character that
										isn't used)
		  (SETQ CH (CHARCODE F]
          (RETURN (OR (AND (NOT (SLESSP (SETQ CH (SDIFFERENCE CH (CHARCODE @)))
					0))
			   [NOT (SGREATERP CH (CONSTANT (IDIFFERENCE (CHARCODE y)
								     (CHARCODE @]
			   (ASSEMBLE NIL                              (* (FELTA HEATHKEYFUNCTIONS 
								      CH+1))
				     (CQ HEATHKEYFUNCTIONS)
				     (CQ2 CH)
				     (SUBI 2 , ASZ)                   (* Unbox CH)
				     (ADDI 1 , 0 (2))                 (* Address into array)
				     (HRRZ 1 , 2 (1))                 (* Fetch value out, accounting for 
										two-word header offset)
				 ))
		      (PROGN (TTBOUT BELL)
			     NIL])

(TTCONCEPTKEYPAD
  [LAMBDA (PREFIXCHAR)                                                (* bvm: "17-Sep-82 10:38")
                                                                      (* Interprets keypad, returning an 
										"equivalent" list of character codes)
    (PROG ((CH (BIN 100Q)))
          (RETURN (OR [COND
			[(EQ PREFIXCHAR (CHARCODE ESCAPE))
			  (COND
			    ([AND (NOT (SLESSP (SETQ CH (SDIFFERENCE CH (CHARCODE +)))
					       0))
				  (NOT (SGREATERP CH (CONSTANT (IDIFFERENCE (CHARCODE })
									    (CHARCODE +]
			      (ASSEMBLE NIL                           (* (FELTA CONCEPTKFUNCTIONS 
								      CH+1))
				        (CQ CONCEPTKFUNCTIONS)
				        (CQ2 CH)
				        (SUBI 2 , ASZ)                (* Unbox CH)
				        (ADDI 1 , 0 (2))              (* Address into array)
				        (HRRZ 1 , 2 (1))              (* Fetch value out, accounting 
								      for two-word header offset)
				    ]
			(T (COND
			     ([AND (NOT (SLESSP (SETQ CH (SDIFFERENCE CH (CHARCODE SPACE)))
						0))
				   (NOT (SGREATERP CH (CONSTANT (IDIFFERENCE (CHARCODE F)
									     (CHARCODE SPACE]
			       (BIN 100Q)                             (* Gobble the closing CR)
			       (ASSEMBLE NIL                          (* (FELTA CONCEPTPFUNCTIONS 
								      CH+1))
				         (CQ CONCEPTPFUNCTIONS)
				         (CQ2 CH)
				         (SUBI 2 , ASZ)               (* Unbox CH)
				         (ADDI 1 , 0 (2))             (* Address into array)
				         (HRRZ 1 , 2 (1))             (* Fetch value out, accounting 
								      for two-word header offset)
				     ]
		      (PROGN (TTBOUT BELL)
			     NIL])

(SETKEYPAD
  [LAMBDA (CODEKEY INPUT)                                             (* bvm: "30-Aug-82 22:43")

          (* Sets what a Heath keypad key will be interpreted as. CODEKEY is an integer from 0 to 30 as 
	  follows: 0-9: unshifted keypad digits; 10: period; 11-19 shifted keypad digits 
	  (can't shift zero) 20: ENTER (can't shift this, either) 21-29 the nine keys across the top 
	  (f1-f5, ERASE, blue, red, gray) 30: Shift-ERASE. -
	  INPUT is a list of character codes, with the 200q bit designating "edit". 200q itself 
	  (edit-null) is taken to be edit-prefix. -
	  Returns old setting of this key)


    (COND
      ((EQ (SETQ DISPLAYTERMFLG (DISPLAYTERMP))
	   2)
	(SETHEATHKEYPAD CODEKEY INPUT))
      ((EQ DISPLAYTERMFLG 3)
	(SETCONCEPTKEYPAD CODEKEY INPUT))
      (T (ERROR "No keypad for this terminal" CODEKEY])

(ENABLE.CONCEPT.KEYPAD
  [LAMBDA NIL                                                         (* bvm: "17-Sep-82 18:05")
    (JS SFMOD 100Q (PROG1 (JS RFMOD 100Q NIL NIL 2)                   (* Set binary mode)
			  (JS SFMOD 100Q 0)
			  (TTBOUT ESC "4" SPACE "0" SPACE)            (* Set funny function keys to 
								      transmit)
			  (TTBOUT ESC "4" SPACE "1" SPACE)
			  (TTBOUT ESC "4" SPACE "2" SPACE)
			  (TTBOUT ESC "4" SPACE "3" SPACE)
			  (TTBOUT ESC "4" SPACE "4" SPACE)
			  (TTBOUT ESC "4" SPACE SPACE SPACE)
			  (TTBOUT ESC "4" SPACE ! SPACE)
			  (TTBOUT ESC "4" SPACE %" SPACE)
			  (TTBOUT ESC "4" SPACE # SPACE)
			  (TTBOUT ESC "4" SPACE $ SPACE)
			  (TTBOUT ESC X)                              (* set keypad to transmit)
			  (TTBOUT ESC SPACE x SPACE ! !)              (* But set MultCode and RESET to
								      execute)
			  (TTBOUT ESC SPACE x ! %" !)))])

(SETHEATHKEYPAD
  [LAMBDA (CODEKEY INPUT)                                             (* bvm: "30-Aug-82 22:43")
    (COND
      [(LISTP CODEKEY)
	(for PAIR in CODEKEY do (SETHEATHKEYPAD (CAR PAIR)
						(CDR PAIR]
      (T (PROG [(INDEX (COND
			 ((OR (ILESSP CODEKEY 0)
			      (IGREATERP CODEKEY 36Q))
			   (ERROR "Invalid heath key code" CODEKEY))
			 (T (ELT HEATH.SYMBOL.TO.CHAR (ADD1 CODEKEY]
                                                                      (* the array tells us which key "code" 
										generates which character, offset by 
										same offset as HEATHKEYFUNCTIONS)
	       [SETQ INPUT (for X in INPUT collect (OR (SMALLP X)
						       (APPLY* (FUNCTION CHARCODE)
							       X]
	       (RETURN (PROG1 (ELT HEATHKEYFUNCTIONS INDEX)
			      (SETA HEATHKEYFUNCTIONS INDEX INPUT])

(SETCONCEPTKEYPAD
  [LAMBDA (CODEKEY INPUT)                                             (* bvm: "12-Sep-82 14:50")
    (COND
      [(LISTP CODEKEY)
	(for PAIR in CODEKEY do (SETCONCEPTKEYPAD (CAR PAIR)
						  (CDR PAIR]
      (T (PROG [[INDEX (COND
			 ((AND (IGEQ CODEKEY 1)
			       (ILEQ CODEKEY 77Q)
			       (ELT CONCEPT.SYMBOL.TO.CHAR CODEKEY)))
			 (T (ERROR "Invalid Concept key code" CODEKEY]
		(ARR (COND
		       ((ILESSP CODEKEY 50Q)
			 CONCEPTPFUNCTIONS)
		       (T CONCEPTKFUNCTIONS]                          (* First 47Q are the function 
								      keys, prefix ^\, rest are keypad
								      keys, prefix ESC)
                                                                      (* the array tells us which key "code" 
										generates which character, offset by 
										same offset as HEATHKEYFUNCTIONS)
	       [SETQ INPUT (for X in INPUT collect (OR (SMALLP X)
						       (APPLY* (FUNCTION CHARCODE)
							       X]
	       (RETURN (PROG1 (ELT ARR INDEX)
			      (SETA ARR INDEX INPUT])

(MODIFY.KEYPAD
  [LAMBDA (TYPE)                                                      (* bvm: "17-Sep-82 18:28")
    (RESETLST (PROG (CH VALUE INDEX OLDTTBL ARR LOWESTKEY)
		    (SELECTQ [OR (FIXP TYPE)
				 (SETQ TYPE (SETQ DISPLAYTERMFLG (DISPLAYTERMP]
			     (2 (printout T "(Heath keypad)" T)
				(SETQ LOWESTKEY (CHARCODE @))
				(SETQ ARR HEATHKEYFUNCTIONS))
			     (3 (printout T "(Concept keypads)" T))
			     (ERROR "Not Heath or Concept terminal"))
		    [RESETSAVE (SETQ OLDTTBL (SETTERMTABLE ASKUSERTTBL))
			       '(PROGN (SETTERMTABLE OLDVALUE]
		TOP (TERPRI)
		    (printout T "Type key or <return> to quit: ")
		LP  (SETQ CH (BIN 100Q))
		    (SELCHARQ CH
			      ((CR TENEXEOL)
				(JS CFIBF 100Q)                       (* To flush any lingering LF)
				(TERPRI T)
				(RETURN))
			      [ESCAPE                                 (* Good, continue)
				      (SETQ CH (BIN 100Q))
				      (COND
					((EQ TYPE 3)                  (* Concept)
					  (SETQ ARR CONCEPTKFUNCTIONS)
					  (SETQ LOWESTKEY (CHARCODE +)))
					(T (COND
					     ((EQ CH (CHARCODE ?))    (* It's one of the 3-char 
								      sequences)
					       (SETQ CH (BIN 100Q))
					       (COND
						 ((EQ CH (CHARCODE M))
                                                                      (* This is the only ambiguity between 
										good Heaths and bad ones that drop the 
										?. Turn this into another character that
										isn't used)
						   (SETQ CH (CHARCODE F]
			      (^\                                     (* Concept prefix)
				  (COND
				    ((NEQ TYPE 3)
				      (BEEP)
				      (GO LP)))
				  (SETQ ARR CONCEPTPFUNCTIONS)
				  (SETQ LOWESTKEY (CHARCODE SPACE))
				  (SETQ CH (BIN 100Q))
				  (BIN 100Q))
			      (PROGN (BEEP)
				     (GO LP)))
		    (COND
		      ((OR (SLESSP (SETQ INDEX (SADD1 (SDIFFERENCE CH LOWESTKEY)))
				   1)
			   (SGREATERP INDEX (ARRAYSIZE ARR)))
			(BEEP)
			(GO LP)))
		    (printout T T "Current setting: " (SETQ VALUE (ELT ARR INDEX)))
		    [COND
		      (VALUE (printout T " = " (MAPCAR VALUE (FUNCTION UNCHARCODE]
		    (TERPRI T)
		    (SETTERMTABLE OLDTTBL)
		    (SETQ VALUE (TTYIN "New setting (<cr> to leave alone): " NIL 

"Enter one or more character codes that this key should send
when struck.  Instead of codes, you may refer to characters symbolically,
using # to designate Edit-, e.g.: #ESCAPE K means Edit-escape K"
				       'READ))
		    [COND
		      (VALUE [COND
			       ([AND (NOT (CDR VALUE))
				     (OR (LISTP (CAR VALUE))
					 (NULL (CAR VALUE]
				 (SETQ VALUE (CAR VALUE]
			     (ERSETQ (SETA ARR INDEX
					   (for X in VALUE
					      collect (OR (SMALLP X)
							  (AND (NLISTP X)
							       (APPLY* (FUNCTION CHARCODE)
								       X))
							  (ERROR "Bad key spec" X T]
		    (SETTERMTABLE ASKUSERTTBL)
		    (GO TOP])

(UNCHARCODE
  [LAMBDA (CODE MKATOM)                                                         (* bvm: " 4-Apr-82 10:29")
    (COND
      ((LISTP CODE)
	(for X in CODE collect (UNCHARCODE X MKATOM)))
      (CODE (PROG ((SUBCODE (LOGAND CODE 177Q)))
	          [COND
		    ((IGREATERP CODE 377Q)
		      (ERRORX (LIST 33Q CODE]
	          [SETQ SUBCODE (COND
		      ((EQ SUBCODE 177Q)
			'RUBOUT)
		      ((IGREATERP SUBCODE (CHARCODE SPACE))
			(CHARACTER SUBCODE))
		      (T (SELCHARQ SUBCODE
				   (NULL 'NULL)
				   (TAB 'TAB)
				   (LF 'LF)
				   (CR 'CR)
				   (SPACE 'SPACE)
				   (ESCAPE 'ESCAPE)
				   (FF 'FF)
				   (CONCAT "^" (CHARACTER (LOGOR SUBCODE (CHARCODE @]
	          [COND
		    ((IGREATERP CODE 177Q)
		      (SETQ SUBCODE (CONCAT '# SUBCODE]
	          (RETURN (COND
			    (MKATOM (MKATOM SUBCODE))
			    (T SUBCODE])

(DUMPHEATHKEYPAD
  [LAMBDA NIL                                                         (* bvm: "12-Sep-82 13:58")
                                                                      (* Writes a loadable expression that 
										will set HEATHKEYFUNCTIONS to its 
										current state)
    (PRIN1 "(SETHEATHKEYPAD (QUOTE (")
    (TERPRI)
    [for I from 1 to 37Q do (PRINT (CONS (SUB1 I)
					 (UNCHARCODE (ELT HEATHKEYFUNCTIONS
							  (ELT HEATH.SYMBOL.TO.CHAR I))
						     T]
    (PRIN1 ")))
")
    NIL])

(DUMPCONCEPTKEYPAD
  [LAMBDA NIL                                                         (* bvm: "12-Sep-82 14:47")
                                                                      (* Writes a loadable expression that 
										will set HEATHKEYFUNCTIONS to its 
										current state)
    (PRIN1 "(SETCONCEPTKEYPAD (QUOTE (")
    (TERPRI)
    [for I from 1 to 47Q bind INDEX when (SETQ INDEX (ELT CONCEPT.SYMBOL.TO.CHAR I))
       do (PRINT (CONS I (UNCHARCODE (ELT CONCEPTPFUNCTIONS INDEX)
				     T]
    [for I from 50Q to 77Q bind INDEX when (SETQ INDEX (ELT CONCEPT.SYMBOL.TO.CHAR I))
       do (PRINT (CONS I (UNCHARCODE (ELT CONCEPTKFUNCTIONS INDEX)
				     T]
    (PRIN1 ")))
")
    NIL])
)
(SETQ HEATHKEYFUNCTIONS (READARRAY 72Q 0))
((255Q 332Q)
(265Q 336Q)
(265Q 212Q)
(251Q)
(250Q)
(307Q)
(233Q 240Q)
NIL
(333Q)
NIL
(233Q 313Q)
NIL
(27Q)
(304Q)
(332Q)
NIL
(34Q)
(35Q)
(36Q)
(200Q)
(17Q)
(301Q)
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
(33Q)
NIL
(233Q 377Q)
(177Q)
(212Q)
(313Q)
(377Q)
(335Q)
(240Q)
(302Q)
(336Q)
(323Q)
NIL
)(SETQ HEATH.SYMBOL.TO.CHAR (READARRAY 37Q 0))
(61Q
62Q
63Q
64Q
65Q
66Q
67Q
70Q
71Q
72Q
57Q
15Q
3
16Q
5
11Q
4
1
2
17Q
7
24Q
25Q
26Q
27Q
30Q
13Q
21Q
22Q
23Q
6
NIL
)(SETQ CONCEPTPFUNCTIONS (READARRAY 46Q 0))
((33Q)
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
(255Q 332Q)
(332Q)
(27Q)
(304Q)
(200Q)
(313Q)
(333Q)
(335Q)
NIL
NIL
NIL
(35Q)
NIL
NIL
NIL
NIL
(302Q)
(323Q)
(250Q)
(251Q)
(233Q)
(33Q)
(200Q)
NIL
NIL
NIL
NIL
)(SETQ CONCEPTKFUNCTIONS (READARRAY 122Q 0))
(NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
(336Q)
(212Q)
(240Q)
(377Q)
(214Q)
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
(375Q)
NIL
(373Q)
(211Q)
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
NIL
)(SETQ CONCEPT.SYMBOL.TO.CHAR (READARRAY 77Q 0))
(26Q
27Q
30Q
31Q
32Q
33Q
34Q
35Q
36Q
37Q
40Q
41Q
42Q
43Q
21Q
22Q
23Q
24Q
25Q
NIL
6
7
10Q
11Q
12Q
13Q
14Q
15Q
16Q
17Q
20Q
44Q
45Q
46Q
1
2
3
4
5
NIL
1
121Q
3
21Q
66Q
24Q
25Q
23Q
61Q
22Q
63Q
NIL
NIL
122Q
4
21Q
66Q
24Q
25Q
23Q
62Q
22Q
65Q
NIL
)(AND (EQ (EVALV 'USEHEATHKEYPAD)
	  'NOBIND)
      (RPAQ USEHEATHKEYPAD NIL))
(AND (EQ (EVALV 'USECONCEPTKEYPAD)
	 'NOBIND)
     (RPAQ USECONCEPTKEYPAD NIL))
(AND (EQ (EVALV 'TTYINKEYPADPREFIX)
	 'NOBIND)
     (RPAQ TTYINKEYPADPREFIX NIL))
(AND (EQ (EVALV 'TTYINKEYPADPREFIX2)
	 'NOBIND)
     (RPAQ TTYINKEYPADPREFIX2 NIL))

(RPAQQ TTYINBACKUP NIL)
(DECLARE: EVAL@COMPILE DONTCOPY 
(DECLARE: EVAL@COMPILE 

(PUTPROPS KEYPADPREFIXP MACRO ((CH)
			       (OR (EQ CH TTYINKEYPADPREFIX)
				   (EQ CH TTYINKEYPADPREFIX2))))
)

(DECLARE: DOEVAL@COMPILE DONTCOPY

(ADDTOVAR GLOBALVARS CONCEPTPFUNCTIONS CONCEPTKFUNCTIONS HEATHKEYFUNCTIONS HEATH.SYMBOL.TO.CHAR 
	  CONCEPT.SYMBOL.TO.CHAR USEHEATHKEYPAD USECONCEPTKEYPAD TTYINKEYPADPREFIX TTYINKEYPADPREFIX2)
)
)

(ADDTOVAR BAKTRACELST (USEREXEC **TTYIN** ERRORSET TTYIN)
		      (*PROG*LAM (NIL EVALA *ENV*)
				 (**TTYIN** ERRORSET TTYIN)))

(ADDTOVAR LISPXHISTORYMACROS [BUF NIL (TTYIN LISPXID NIL NIL 'EVALQT NIL NIL
					     (LIST (COND (LISPXLINE (VALUOF LISPXLINE))
							 (T (CADDR (CAAR LISPXHISTORY])

(ADDTOVAR LISPXMACROS (TV (APPLY* 'EDITV (CAR LISPXLINE)
				  'ED)))

(ADDTOVAR USERMACROS (BUF NIL (E [LISPXUNREAD (TTYIN '* NIL NIL 'LISPXREAD NIL NIL
						     (LIST 'E (##]
				 T))
		     (ED NIL (COMS (TTED))))

(ADDTOVAR EDITCOMSA ED BUF)

(PUTPROPS LISPXFIX READVICE [NIL (BEFORE NIL (COND ((AND (EQ LISPXREADFN 'TTYINREAD)
							 (NOT COMS)
							 (ILESSP (COUNT INPUT)
								 62Q))
						    (RETURN (TTYIN LISPXID NIL NIL 'EVALQT NIL NIL 
								   INPUT])
(READVISE LISPXFIX)

(PUTPROPS TTYINREADMACROS VARTYPE ALIST)
(DECLARE: DONTEVAL@LOAD 
(CHANGENAME 'LISPXREADP 'PEEKC 'TTYINPEEKC)
(CHANGENAME 'READLINE 'PEEKC 'TTYINPEEKC)
(CHANGENAME 'LISPXBLOCK 'PEEKC 'TTYINPEEKC)
(AND (GETD 'COMPSETREAD)
     (CHANGENAME 'COMPSETREAD 'PEEKC 'TTYINPEEKC))
(CHANGENAME 'EDITBLOCK 'LISPXREADP 'TTYINREADP)
(SETREADFN)


(RPAQ PROMPTCHARFORMS (/NCONC1 PROMPTCHARFORMS '(TTYINREADPREP)))


(ADDTOVAR AFTERSYSOUTFORMS (SETREADFN))
)
(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA TTBOUT TTBOUTN)

(ADDTOVAR NLAML CHARMACRO? TTED !SETQ ! CAPABILITY?)

(ADDTOVAR LAMA )
)
(PRETTYCOMPRINT TTYINCOMS)

(RPAQQ TTYINCOMS [(E (RESETSAVE (RADIX 10Q)))
		  (FNS * TTYINFNS)
		  (FNS * TTDISPLAYFNS)
		  (COMS (* Support functions. These are all macros or for debugging)
			(FNS * TTSUPPORTFNS))
		  (COMS (* Auxiliary fns. These are outside the TTYIN block, and are provided to aid 
			   the outside world in special interfaces to TTYIN)
			(FNS * TTEXTRAFNS))
		  (DECLARE: DOEVAL@COMPILE DONTCOPY (COMS * TTCOMPILETIME))
		  (VARS (TTYINBUFFER))
		  (INITVARS ?ACTIVATEFLG EDITPREFIXCHAR EMACSFLG SHOWPARENFLG TTYINBSFLG 
			    TTYINCOMPLETEFLG TTYINMAILFLG TTYINUSERFN TYPEAHEADFLG (null "")
			    (DEFAULTPROMPT "** ")
			    (TTYJUSTLENGTH 110Q)
			    (TTYPAGELENGTH 30Q))
		  (P (MOVD? 'NILL 'GUESTUSER?)
		     (MOVD? 'FIXSPELL 'FIXSPELL!!)
		     (MOVD? 'HELPSYS 'XHELPSYS)
		     (PUTDQ? SPRINTT [LAMBDA (X)
					     (PRIN1 X])
		     (ECHOCONTROL 10Q 'REAL))
		  (ADDVARS (TTYINREADMACROS)
			   (TTYINRESPONSES)
			   (DISPLAYTYPES)
			   (LISPXCOMS (STOP . OK))
			   (BREAKRESETFORMS (TTECHOMODE T))
			   (RESETFORMS (TTECHOMODE T)))
		  (COMS (* Heath stuff)
			(FNS TTHEATHKEYPAD TTCONCEPTKEYPAD SETKEYPAD ENABLE.CONCEPT.KEYPAD 
			     SETHEATHKEYPAD SETCONCEPTKEYPAD MODIFY.KEYPAD UNCHARCODE DUMPHEATHKEYPAD 
			     DUMPCONCEPTKEYPAD)
			(ARRAY HEATHKEYFUNCTIONS HEATH.SYMBOL.TO.CHAR CONCEPTPFUNCTIONS 
			       CONCEPTKFUNCTIONS CONCEPT.SYMBOL.TO.CHAR)
			(INITVARS USEHEATHKEYPAD USECONCEPTKEYPAD TTYINKEYPADPREFIX 
				  TTYINKEYPADPREFIX2)
			(VARS (TTYINBACKUP))
			(DECLARE: EVAL@COMPILE DONTCOPY (MACROS KEYPADPREFIXP)
				  (GLOBALVARS CONCEPTPFUNCTIONS CONCEPTKFUNCTIONS HEATHKEYFUNCTIONS 
					      HEATH.SYMBOL.TO.CHAR CONCEPT.SYMBOL.TO.CHAR 
					      USEHEATHKEYPAD USECONCEPTKEYPAD TTYINKEYPADPREFIX 
					      TTYINKEYPADPREFIX2)))
		  (ALISTS (BAKTRACELST USEREXEC *PROG*LAM))
		  (LISPXMACROS TV BUF)
		  (USERMACROS ED BUF)
		  (ADVISE LISPXFIX)
		  (PROP VARTYPE TTYINREADMACROS)
		  [DECLARE: DONTEVAL@LOAD (P (CHANGENAME 'LISPXREADP 'PEEKC 'TTYINPEEKC)
					     (CHANGENAME 'READLINE 'PEEKC 'TTYINPEEKC)
					     (CHANGENAME 'LISPXBLOCK 'PEEKC 'TTYINPEEKC)
					     (AND (GETD 'COMPSETREAD)
						  (CHANGENAME 'COMPSETREAD 'PEEKC 'TTYINPEEKC))
					     (CHANGENAME 'EDITBLOCK 'LISPXREADP 'TTYINREADP)
					     (SETREADFN))
			    [VARS (PROMPTCHARFORMS (/NCONC1 PROMPTCHARFORMS '(TTYINREADPREP]
			    (ADDVARS (AFTERSYSOUTFORMS (SETREADFN]
		  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
			    (ADDVARS (NLAMA TTBOUTN TTBOUT)
				     (NLAML CHARMACRO? TTED !SETQ ! CAPABILITY?)
				     (LAMA])
(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA TTBOUTN TTBOUT)

(ADDTOVAR NLAML CHARMACRO? TTED !SETQ ! CAPABILITY?)

(ADDTOVAR LAMA )
)
(DECLARE: DONTCOPY
  (FILEMAP (NIL (10425Q 546073Q (TTYIN 10441Q . 115530Q) (ADDCHAR 115534Q . 122165Q) (ADDCHARS.INSERTING
 122171Q . 123764Q) (ADDNAKEDCHAR 123770Q . 126225Q) (ADDSILENTCHAR 126231Q . 130566Q) (ADDTAB 130572Q
 . 132503Q) (ADJUSTLINE 132507Q . 154471Q) (ADJUSTLINE.AND.RESTORE 154475Q . 155311Q) (
AT.END.OF.SCREEN 155315Q . 155613Q) (AT.END.OF.TEXT 155617Q . 156451Q) (AUTOCR? 156455Q . 157353Q) (
BACKWARD.DELETE.TO 157357Q . 157636Q) (BACKSKREAD 157642Q . 165356Q) (BINARY.MODE 165362Q . 167154Q) (
BREAKLINE 167160Q . 173664Q) (BUFLEN 173670Q . 174512Q) (BUFTAILP 174516Q . 175102Q) (CHECK.MARGIN 
175106Q . 176054Q) (CLEAR.LINE? 176060Q . 176436Q) (COMPLETEWORD 176442Q . 210620Q) (CREATE.LINE 
210624Q . 211350Q) (DELETE.TO.END 211354Q . 212532Q) (DELETELINE 212536Q . 217244Q) (DELETETO 217250Q 
. 222127Q) (DELETETO1 222133Q . 223567Q) (DO.EXTEND.COMMAND 223573Q . 226062Q) (DO?CMD 226066Q . 
232702Q) (DOTABS 232706Q . 234230Q) (ECHOFILE 234234Q . 237342Q) (EDITCHAR 237346Q . 275221Q) (
EDITCOLUMN 275225Q . 276110Q) (ENDELETE 276114Q . 276720Q) (ENDREAD? 276724Q . 302351Q) (FIND.LINE 
302355Q . 303335Q) (FINDBREAK 303341Q . 304240Q) (FINDMATCH 304244Q . 311411Q) (FIRSTWORD 311415Q . 
312127Q) (FIXWORD 312133Q . 314217Q) (FORWARD.DELETE.TO 314223Q . 317070Q) (GIVEHELP 317074Q . 321351Q
) (GIVEHELP1 321355Q . 322234Q) (GIVEHELP2 322240Q . 323331Q) (GO.TO 323335Q . 332271Q) (
GO.TO.ADDRESSING 332275Q . 334257Q) (GO.TO.FREELINE 334263Q . 335226Q) (INIT.CURSOR 335232Q . 336505Q)
 (INSERT.CHAR.IN.BUF 336511Q . 337272Q) (INSERTCONS 337276Q . 340213Q) (INSERTLINE 340217Q . 342302Q) 
(KILL.LINES 342306Q . 343236Q) (KILLSEGMENT 343242Q . 345005Q) (LASTLINE 345011Q . 345523Q) (LOADBUF 
345527Q . 351320Q) (LOADBUFFROMFILE 351324Q . 352664Q) (MODE.CHANGE? 352670Q . 353641Q) (MOVE.BACK.TO 
353645Q . 354165Q) (MOVE.FORWARD.TO 354171Q . 354547Q) (MOVE.TO.LINE 354553Q . 355770Q) (
MOVE.TO.NEXT.LINE 355774Q . 356324Q) (MOVE.TO.START.OF.WORD 356330Q . 357564Q) (MOVE.TO.WHEREVER 
357570Q . 360122Q) (NEWLINE 360126Q . 360641Q) (NEXTCHAR 360645Q . 363232Q) (NEXTCONS 363236Q . 363614Q
) (NEXTLINE 363620Q . 364230Q) (NEXTQUOTE 364234Q . 365143Q) (NEXTWORD 365147Q . 367274Q) (
NTH.COLUMN.OF 367300Q . 367767Q) (NTH.RELATIVE.COLUMN.OF 367773Q . 372273Q) (NTHCHARCODE 372277Q . 
376120Q) (OVERFLOW? 376124Q . 377742Q) (OVERFLOWLINE? 377746Q . 400370Q) (PREVLINE 400374Q . 402473Q) 
(PREVWORD 402477Q . 404523Q) (PROPERTAILP 404527Q . 405045Q) (READFROMBUF 405051Q . 406721Q) (
RENUMBER.LINES 406725Q . 407413Q) (RESTORE.CURSOR 407417Q . 407713Q) (RESTOREBUF 407717Q . 411560Q) (
RESTOREMOD 411564Q . 412264Q) (RETYPE 412270Q . 416236Q) (RUBOUT 416242Q . 416737Q) (SAVE.CURSOR 
416743Q . 417227Q) (SCANBACK 417233Q . 421215Q) (SCANFORWARD 421221Q . 422305Q) (SCRATCHCONS 422311Q .
 423233Q) (SETLASTC 423237Q . 423744Q) (SETTAIL? 423750Q . 424734Q) (SHOW.MATCHING.PAREN 424740Q . 
430622Q) (SKIP/ZAP 430626Q . 433661Q) (SLEEP 433665Q . 436166Q) (SPACE/PARENP 436172Q . 436505Q) (
START.OF.PARAGRAPH? 436511Q . 437047Q) (STRIPBLANKS 437053Q . 441051Q) (TENEXCOMPLETE 441055Q . 475704Q
) (THISWORD 475710Q . 501154Q) (TTBIN 501160Q . 506543Q) (TTCRLF 506547Q . 507077Q) (TTCRLF.ACCOUNT 
507103Q . 510024Q) (TTGETFILE 510030Q . 512111Q) (TTNLEFT 512115Q . 514315Q) (TTNTH 514321Q . 515074Q)
 (TTPRIN1 515100Q . 520067Q) (TTPROMPTCHAR 520073Q . 520570Q) (TTRATOM 520574Q . 524035Q) (TTREAD 
524041Q . 527363Q) (TTREADLIST 527367Q . 533626Q) (TTSKIPSEPR 533632Q . 534317Q) (TTSKREAD 534323Q . 
537057Q) (TTYINSTRING 537063Q . 542043Q) (TYPE.BUFFER 542047Q . 542730Q) (U/L-CASE 542734Q . 545177Q) 
(UNREADBUF 545203Q . 546070Q)) (546543Q 576713Q (&DISPLAYCOMMENT 546557Q . 551415Q) (CAPABILITY? 
551421Q . 554313Q) (BEEP 554317Q . 554512Q) (CANCEL.MODES 554516Q . 555552Q) (DELNCHARS 555556Q . 
561026Q) (DO.BACK 561032Q . 561236Q) (DO.DELETE.LINES 561242Q . 562441Q) (DO.DOWN 562445Q . 563053Q) (
DO.FORWARD 563057Q . 563766Q) (DO.HOME 563772Q . 564333Q) (DO.INSERT.LINE 564337Q . 567343Q) (DO.UP 
567347Q . 567734Q) (ERASE.SCREEN 567740Q . 570320Q) (ERASE.TO.END.OF.LINE 570324Q . 570713Q) (
ERASE.TO.END.OF.PAGE 570717Q . 572342Q) (INSERT.TEXT 572346Q . 574545Q) (INSERTNCHARS 574551Q . 575401Q
) (INSERTSPACES.DM 575405Q . 576047Q) (SET.CURSOR 576053Q . 576710Q)) (577267Q 614435Q (! 577303Q . 
600653Q) (!SETQ 600657Q . 602013Q) (ADD1POS 602017Q . 602245Q) (BIN 602251Q . 602455Q) (EDITNUMBERP 
602461Q . 603020Q) (INPART 603024Q . 603535Q) (INSERTING 603541Q . 604150Q) (L-CASECODE 604154Q . 
604557Q) (TENEXP 604563Q . 604775Q) (TTBOUT 605001Q . 606425Q) (TTBOUTN 606431Q . 606707Q) (TYPEAHEAD?
 606713Q . 607135Q) (U-CASECODE 607141Q . 607546Q) (PR! 607552Q . 610441Q) (PRALL 610445Q . 610772Q) (
PRBUF 610776Q . 612437Q) (PRLINE 612443Q . 614432Q)) (615053Q 637317Q (SETREADFN 615067Q . 616347Q) (
TTYINPEEKC 616353Q . 617400Q) (TTYINREADP 617404Q . 620264Q) (TTYINREADPREP 620270Q . 621071Q) (
TTYINREAD 621075Q . 622265Q) (DISPLAYTERMP 622271Q . 626510Q) (TTECHOMODE 626514Q . 627301Q) (TTED 
627305Q . 635314Q) (CHARMACRO? 635320Q . 637314Q)) (703070Q 732070Q (TTHEATHKEYPAD 703104Q . 705606Q) 
(TTCONCEPTKEYPAD 705612Q . 711041Q) (SETKEYPAD 711045Q . 712573Q) (ENABLE.CONCEPT.KEYPAD 712577Q . 
714414Q) (SETHEATHKEYPAD 714420Q . 716126Q) (SETCONCEPTKEYPAD 716132Q . 720166Q) (MODIFY.KEYPAD 720172Q
. 725733Q) (UNCHARCODE 725737Q . 727513Q) (DUMPHEATHKEYPAD 727517Q . 730540Q) (DUMPCONCEPTKEYPAD 
730544Q . 732065Q)))))
STOP
 