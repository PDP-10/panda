	TITLE	OPGNTA - CODE GENERATION TABLES FOR FORTRAN-10
	SUBTTL	S. MURPHY/SRM/HPW/DCE/RDH/TFV/RVM/AHM/CDM/TJK/MEM

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972, 1987
;ALL RIGHTS RESERVED.
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

; AUTHOR: S. MURPHY

	INTERN	OPGNTV
	OPGNTV= BYTE (3)0(9)11(6)0(18)4557 	;Version Date:	9-Dec-86

	SUBTTL	Revision History

Comment \

***** Revision History *****

113	-----	-----	ADD GENERATORS FOR DABS IN LINE
114	-----	-----	ADD GENERATORS FOR EXPONENTATION IN LINE
115	-----	-----	TREAT "NEG-SAME-IMMED" (UNDER OPGETA,OPGETI)
			THE SAME AS "NEG-IMMED"
116	-----	-----	ADD GENERATORS FOR EXPONEN TO MEMORY IN LINE
117	-----	-----	REMOVE GENERATORS FOR SQUARE,CUBE,P4 (THEY
			ARE NOW PART OF "EXPCIOP")
118	-----	-----	ADD GENERATORS FOR IN LINE DP EXPONEN AND
			FOR IN LINE EXPONEN OF AN IMMEDIATE LOOP INDEX
119	264	15974	FIX KI COMPLEX DIVIDE TO MEMORY, (JNT)

***** Begin Version 5A *****

120	611	23662	MULTIPLY OF COMPLEX CONSTANT BY POWER OF TWO
			PLUS 1 IS NOT IMPLEMENTED., (DCE)

***** Begin Version 5B *****

121	677	25573	ADD TABLES FOR PARAMETER CHECKING., (DCE)

***** Begin Version 6 *****

122	750	TFV	1-Jan-80	------
	Remove Debug:Parameter switch (edit 677)

123	761	TFV	1-Mar-80	-----
	Rework tables to handle /GFLOATING
	Remove all KA ops

127	1135	RVM	15-Oct-81
	Make conversion from DOUBLE PRECISION to COMPLEX do rounding.

***** Begin Version 7 *****

124	1206	DCE	20-Mar-81	-----
	Add code template for jumping around potential zero trip loop (DOZJMP).

125	1251	CKS	7-Aug-81
	Add OPCHIX, index calculation for character arrays

126	1266	TFV	5-Oct-81	------
	Add INTERN OPIND2, OPGST2 for fetching, storing a two word character
	descriptor.

128	1401	AHM	2-Oct-81	------
	Change MOVEI  16, to  XMOVEI  16, in  many places  for  extended
	addessing support.   Change  subprogram  prologue  and  epilogue
	slightly as well.  Remove support for ADJ. calls, since they are
	no longer used.

129	1417	RVM	10-Nov-81
	The wrong code template was used for conversion from LOGICAL to
	GFLOATING and from CONTROL to GFLOATING.  The template RLGF was
	used, and thus the compiler would generate code to convert REAL
	(9 bit exponent) to GFLOATING (12 bit exponent) and scramble
	bits.  The correct template is RLDP.

130	1431	CKS	15-Dec-81
	Add code templates for substring operations.

131	1471	RVM	5-Feb-82
	Add code templates for calling FOROTS to do internal file I/O.

1474	TFV	15-Mar-82
	Add an entry point OPGLD2 for loading a descriptor into a
	register using GA2KI.

1533	TFV	17-May-82
	Add entries OPGMRK and OPGUNW to generate calls to CHMRK. and CHUNW.	

1567	CDM	24-Jun-82
	Add code for inline functions CHAR, ICHAR, LEN.

***** End Revision History *****

***** Begin Version 10 *****

2201	TFV	30-Mar-83
	Add patterns  for  calling INQF.  (INQUIRE  by file)  and  INQU.
	(INQUIRE by unit).

2244	CDM	28-Jan-84
	Eliminate AOBJN  DO  loop  register indexes  into  large  arrays
	(arrays in  .LARG.)   during  code  generation.   Create  a  new
	STORECLS node,  STRHAOBJN to  copy the  right hand  half of  the
	AOBJN register into another  register.  Otherwise, the  negative
	left half of  the AOBJN register  will appear to  be an  invalid
	section number.  This is  to catch the  cases that the  skeleton
	optimizer (edit 2243) can not.
	Create OPMOVI to point to a MOVEI instruction.

2313	TJK	21-Feb-84
	Rewrite CGRETURN.   This  routine  had a  number  of  problems
	including inefficiency  within the  routine itself,  incorrect
	code produced for  alternate returns  using array  references,
	and pessimal code  produced for some  cases.  Added a  routine
	header.  Removed macro  MOV1GEN.  Commented  out code  pattern
	MOVRET.  Added entry point for code pattern OPGZER.

***** End V10 Development *****
***** End Revision History *****
***** Begin Version 11 *****

4502	MEM	22-Jan-85
	Add code pattern for DELETE statement.

4503	MEM	22-Jan-85
	Add code pattern for REWRITE statement.

4504	MEM	22-Jan-85
	Add code pattern for UNLOCK statement.

4517	MEM	4-Oct-85
	Add new patterns for LDB and DPB for single character relationals
	and assignments.

4522	MEM	5-Nov-85
	Add pattern for IDPB using two non-consecutive registers.
	
4557	MEM	9-DEC-86
	Change ICHAR entry in OPGILF table so that instead of 
	generating ICEing the compiler, we just don't generate any
	code.

ENDV11

\


	SUBTTL	CODE GENERATORS

;[761]	Get definitions of GFAD, GFSB, GFMP, GFDV

	SEARCH GFOPDF		;[761] OPDEFs for GFLOATING instructions

	HISEG

	INTERN	OPGETI		; Get arg into a reg
	INTERN	OPGLD2		;[1474] Fetch a two word descriptor
	INTERN	OPMOVI		;[2244] Create MOVEI instruction
	INTERN	OPGSET		; Initialization of logical values
	INTERN	OPGZER		;[2313] Zero a register
	INTERN	OPGEX		; In-line exponentation 
	INTERN	OPGEXS		; 	to self
	INTERN	OPGEXM		; 	to memory
	INTERN	OPGXG		;[761] GFLOATING in-line exponentation 
	INTERN	OPGXGS		;[761] 	to self
	INTERN	OPGXGM		;[761] 	to memory
	INTERN	OPGXPI		;	from AOBJN
	INTERN	OPGARI		; Arithmetic operations
	INTERN	OPGARG		; GFLOATING arithmetic operations
	INTERN	OPGTCI		; Type conversions
	INTERN	OPGTCG		;[761] GFLOATING type conversions
	INTERN	OPGSTI		; Store a value
	INTERN	OPGST2		;[1266] Store a two word formal argument
	INTERN	OPGASI		; Assignment statement
	INTERN	OPGASR		; Special case for assignment of right half
				; of AOBJN word
	INTERN	OPASIN		; ASSIGN statement
	INTERN	OPGBOO		; Boolean operations
	INTERN	OPGREL		; Relationals
	INTERN	OPGN1I		; Negate when in REGFORCOMP
	INTERN	OPGN2I		; Negate when not in REGFORCOMP
	INTERN	OPGSPI		; P2MUL, P2DIV, P2PL1MUL
	INTERN	OPGSPG		;[761] GFLOATING P2MUL, P2DIV, P2PL1MUL
	INTERN	OPP21I		; Multiply immediate by power of two plus one
	INTERN	OPGSPM		; P2MUL, P2DIV, P2PL1MUL to memory
	INTERN	OPGILF		; In-line functions when in REGFORCOMP
	INTERN	OPGDBF		; DABS in-line when in REGFORCOMP
	INTERN	OPGILI		; In-line functions when ARG1 is in REGFORCOMP,
				; ARG2 is immediate	
	INTERN	OPGIL1		; In-line functions when not in REGFORCOMP
				; (ABS and SIGN)
	INTERN	OPGDB1		; DABS in-line when not in REGFORCOMP
	INTERN	OPGSTC		; STORECLS node
	INTERN	OPGSTD		; Double precision STORECLS node
	INTERN	OPGVTS		; Transfer of control on a given value of a
				; given variable
	INTERN	OPGALT		; Transfer of control to one label if a given
				; variable is true and to another if it is
				; false
	INTERN	DOZJMP		;[1206]
	INTERN	DOSTI
	INTERN	DOSTC		; Store the control word
	INTERN	OPGDOS
	INTERN	OPGDOE
	INTERN	OPGAIF		; Arithmetic IF statements in which the value
				; must be computed and tested
	INTERN	OPGCGO		; Computed GOTO
	INTERN	OPGCGI		; Computed GOTO when the variable is in the
				; right half of a register containing DO loop
				; control
	INTERN 	OPGIIN
	INTERN	OPGMVL
	INTERN	OPINDI		; Fetch a one or two word formal argument
	INTERN	OPIND2		;[1266] Fetch a two word formal argument
	INTERN	DVALU
	INTERN	POPRET
;[2313]	INTERN	MOVRET		; Move RETURN expression to AC 1 (obsolete)
	INTERN	OPINSI
	INTERN	CRETN
	INTERN	CALLER
	INTERN	OPGSFN
;[1401]	INTERN	OPGADJ		; Generate FOROTS call to ADJ. (obsolete)
	INTERN	OPGCHM		;[1533]	to CHMRK.
	INTERN	OPGCHU		;[1533]	to CHUNW.
	INTERN	OPGCLO		;	to CLOS.
	INTERN	OPGDEC		;	to DEC.
	INTERN  OPGDEL		;[4502]	to DELTR.
	INTERN	OPGENC		;	to ENC.
	INTERN	OPGEXI		;	to EXIT.
	INTERN	OPGFIN		; 	to FIN.
	INTERN	OPGFND		;	to FIND.
	INTERN	OPGIFI		;[1471]	to IFI.
	INTERN	OPGIFO		;[1471]	to IFO.
	INTERN	OPGIN		;	to IN.
	INTERN	OPGINF		;[2201]	to INQF. - INQUIRE by file
	INTERN	OPGINU		;[2201]	to INQU. - INQUIRE by unit
	INTERN	OPGIOL		;	to IOLST.
	INTERN	OPGMTO		;	to MTOP.
	INTERN	OPGNLI		;	to NLI.
	INTERN	OPGNLO		;	to NLO.
	INTERN	OPGOPE		;	to OPEN.
	INTERN	OPGOUT		;	to OUT.
	INTERN	OPGPAU		;	to PAUS.
	INTERN	OPGRES		;	to RESET.
	INTERN	OPGRWF		;[4503]	to REWRF.
	INTERN	OPGRWU		;[4503]	to REWRU.
	INTERN	OPGRTB		;	to RTB.
	INTERN	OPGSTP		;	to STOP.
	INTERN	OPGULC		;[4504]	to UNLOC.
	INTERN	OPGWTB		;	to WTB.
	INTERN	OPGPPR		; Pop registers for register restore for sfn
	INTERN	OPGPHR		; Push register for register save for sfn
	INTERN	OPCHIX		; Character array indexing
	INTERN	OPGST1		; Store second word of character descriptor
	INTERN	OPSSEP		; Substring epilog
	INTERN  OPADJB		;[4517] ADJBP for substring/char array
	INTERN	OPDPB2		;[4517] DPB for 1-char assignment
	INTERN	OPDPB3		;[4517] DPB for 1-char assignment
	INTERN	OPDPB4		;[4522] IDPB for 1-char assignment
	INTERN	OPLDB2		;[4517] LDB for ICHAR
	INTERN	OPLDB3		;[4517] LDB for ICHAR

;
;DEFINE THE CODE GENERATION TABLES AND DISPATCH TABLE
;
;ELEMENTS IN THE DISPATCH TABLE ARE AOBJN PTRS TO THE PIECE OF CODE 
; TO BE GENERATED OR EITHER OF THE FLAGS
;	ILG -  FOR ILLEGAL ENTRY (EG THE ENTRY FOR A1SAMEFLG AND 
;		A1IMMEDFLG BOTH SET
;	IGN - FOR NO CODE NEED BE GENERATED FOR THIS NODE
;
	IGN=0
	ILG=1
;
;DEFINE CODE GENERATORS FOR EACH OPERATION
;EACH WORD OF CODE TO BE GENERATED IS REPRESENTED BY A 2 WD ENTRY
;	L.H. OF WD 0 - SPECIFIES WHETHER TO ADD A SPECIFIED "REG FOR
;			COMP" INTO THE REG FIELD OF THE PATTERN WD
;	R.H. OF WD 0 - SPECIFIES WHERE TO GET THE "MEMREF" FIELD (BITS
;		13-36) OF THE INSTRUCTION FROM
;	WD 1 - PATTERN FOR INSTRUCTION TO BE GENERATED
;
;DEFINE POSSIBLE VALS FOR LEFT AND  RIGHT HALVES OF WD 0
	FRPTN=0			;FROM PATTERN WD
	FRRFC=1			;FROM "REGFORCOMP"
	IMFN=2			;USE THE IMPLICIT-FN-NAME PTED TO BY TREEPTR
	WD1IMF=3		;USE THE IMPLICIT-FN NAME POINTED TO
				; BY THE RH OF THE PATTERN WD
	RGIMFN=4		;USE THE IMPLICIT FN NAME POINTED TO BY
				; THE RH OF THE PATTERN WD INDEXED BY
				; THE "REGFORCOMP" (IE DIFFERENT
				; LIBRARY ROUTINES ARE CALLED DEPENDING
				; ON WHICH REG THE ARG IS IN)
	A1CNST=5		;ARG1 IMMED CNST
	A2CNST=6		;ARG2 IMMED CNST
	A1CNNG=7		;USE NEG OF IMMED CNST ARG1
	A2CNNG=10		;USE NEG OF IMMED CNST ARG2
	PTRA2=11			;USE ARG2PTR FIELD OF PARENT
	NGPTR2=12		;USE THE NEGATIVE OF THE ARG2PTR FIELD OF
				; PARENT
	P2PTR2=13		;USE 2**(VAL OF ARG2PTR)-1 (USED FOR
				; P2DIV)
	A1LAB=14		;USE THE LABEL INDICATED BY A1LABEL
	A2LAB=15		;USE THE LABEL INDICATEC BY A2LABEL
	A3LAB=16		;USE THE LABEL INDICATED BY A3LABEL
	FROMC1=17		;USE THE CONTENTS OF THE GLOBAL C1H, 
				; THIS ADDRESS FIELD WILL HAVE NO
				; SYMBOLIC REPRESENTATION
	PARTMP=20		;USE THE TMP INDICATED BY THE TARGET
				; OF PARENT (IGNORE INDIRECT AND INDEX
				; BITS IN THE TARGET)
	FROMA1=21		;USE TARGET FIELD OF ARG1
	FROMA2=22		;USE TARGET FIELD OF ARG2
	FROMPA=23		;USE TARGET FIELD OF PARENT (TREEPTR)

;DISPATCH TABLE FOR 'GET ARG INTO A REG' - 
;TO GENERATE CODE FOR THE KI10
				
OPGETI:	-1,,GA			;NO FLAGS, SINGLE PREC
	-1,,GA
OPGLD2:	-1,,GA2KI		;NO FLAGS, DOUBLEPREC, 
	-1,,GA2KI		;NO FLAGS, COMPLEX
OPMOVI:	-1,,GAIMI		;[2244] IMMED - INTEGER
	-1,,GAIMRL		;IMMED - REAL
	-2,,GAIM2		;IMMED, DOUBL-PREC - RARELY GENERATED
	-2,,GAIM2		;IMMED COMPLEX
	IGN			;IGNORE (ARG SAMEFLG SET)
	IGN
	IGN
	IGN
	IGN			;ARG SAME AND ARG IMMED FLAGS WILL BOTH BE
				; SET WHEN A REGCONTENTS WHICH IS LOOP CTL VAR
				; IS AN ARG UNDER A RELATIONAL (IGNORE)
	IGN
	IGN
	IGN
	-1,,GANG		;NEG OF ARG
	-1,,GANG
	-1,,GANG2I		;NEG OF DOUBLE-WD ARG - 
	-2,,GNGCM		;NEG OF COMPLEX ARG
	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2
	-1,,GANGSM		;NEG OF VAL ALREADY IN DESIRED REG
	-1,,GANGSM
	-1,,GNGS2I		;NEG OF DOUBLE-WD ARG ALREADY IN DESIRED
				; REG
	-2,,GNGSCM		;NEG OF COMPLEX ARG ALREADY IN DESIRED 
				; REG

	;SAME-IMMED NEGATED - TREAT AS IMMED NEGATED (IGNORE
	; THE "SAMEFLG") - OCCURS WHEN BB ALLOCATOR HAS FOUND
	; AN IMMED CNST THAT WAS LEFT IN A REG AND THEN
	; LATER A NEGFLG WAS MOVED OVER THAT CNST IN CGETVAL

	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2

	-1,,GANT		;NOT OF ARG 
	-1,,GANT
	-2,,GANT2		;NOT OF DOUBLE-WD ARG 
	-2,,GANT2
	-1,,GNTIMI		;NOT OF IMMED CNST - INTEGER
	ILG			;NOT OF IMMED CNST - REAL
	ILG			;NOT OF IMMED, DOUBLE-WD
	ILG	
	-1,,GANTSM		;NOT OF VAL ALREADY IN THE DESIRED REG
	-1,,GANTSM
	-2,,GNTS2		;NOT OF DOUBLE-WD ARG - 
	-2,,GNTS2

;NOTE THAT ALL "GETA1OPIX" VALS ABOVE THIS PT ARE ILLEGAL
; (INVOLVING EITHER BOTH NEG AND NOT OR SAME AND IMMED)


;DEFINE CODE GENERATORS FOR GETTING ARG1 INTO A REG


GA=.				;GET ARG INTO REG
	FRRFC,,FROMA1
	MOVE	0,0

GA2KI=.				;DOUBLE-PREC KI
	FRRFC,,FROMA1
	DMOVE	0,0

;GET IMMED ARGS

GAIMI=.				;IMMED - INTEGER
	FRRFC,,A1CNST
	MOVEI	0,0

GAIMRL=.			;IMMED - REAL
GAIM2=.				;IMMED DOUBLE-WD (next 2 instrs)
	FRRFC,,A1CNST
	MOVSI	0,0

	FRRFC,,FRPTN
	MOVEI	1,0

; GET NOT OF ARG

GANT=.				;GET NOT OF ARG
	FRRFC,,FROMA1
	SETCM	0,0

GANT2=.				;GET NOT OF DOUBLE-PREC ARG (next 2 instrs)
	FRRFC,,FROMA1
	SETCM	0,0

	FRRFC,,FROMA1
	SETCM	1,1

GNTIMI=.			;NOT OF AN IMMED CNST - INTEGER
	FRRFC,,A1CNST
	SETCMI	0,0

GANTSM=.			;NOT OF AN ARG ALREADY IN DESIRED REG
GNTS2=.				; NOT OF A DOUBLE-WD ARG ALREADY IN 
				; DESIRED REG (next 2 instrs)
	FRRFC,,FRPTN
	SETCA	0,0

	FRRFC,,FRPTN
	SETCA	1,0

;GET NEG ARG

GANG=.				;NEG OF ARG
GNGCM=.				;NEG OF A COMPLEX ARG (next 2 instrs)
	FRRFC,,FROMA1
	MOVN	0,0

	FRRFC,,FROMA1
	MOVN	1,1

;
	GANG2I=.		;NEG OF DOUBLE-WD ARG FOR KI10
	FRRFC,,FROMA1
	DMOVN	0,0
;
;
	GNGIMI=.		;NEG OF AN IMMED ARG - INTEGER
	FRRFC,,A1CNST
	MOVNI	0,0
;
	GNGIMR=.		;NEG OF AN IMMED ARG - REAL
	GNGIM2=.		;NEG OF AN IMMED ARG - DOUBLE-WD (next 2 instrs)
	FRRFC,,A1CNNG
	MOVSI	0,0
;
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
;
	GANGSM=.		;NEG OF ARG ALREADY IN DESIRED REG
	GNGSCM=.		;NEG OF COMPLEX ARG ALREADY IN SAME REG (next 2 instrs)
	FRRFC,,FRRFC
	MOVN	0,0
;
	FRRFC,,FRRFC
	MOVN	1,1
;
;
;
;
	GNGS2I=.		;NEG OF DOUBLE-WD ARG ALREADY IN REG 
				; FOR KI10
	FRRFC,,FRRFC
	DMOVN	0,0
;
;


;
;TABLE FOR CODE GENERATION FOR INITIALIZATION OF LOGICAL VALUES
;
OPGSET:	-1,,FLSMEM		;SET MEM LOC FALSE
OPGZER:	-1,,FLSREG		;[2313] SET REG FALSE OR ZERO (SAME THING)
	-1,,TRMEM		;SET MEM LOC TRUE
	-1,,TRREG		;SET REG TRUE
;
;	CODE GENERATORS FOR LOGICAL INIT
	FLSMEM=.
	FRPTN,,FROMPA
	SETZM	0,0
;
	FLSREG=.
	FRRFC,,FRPTN
	SETZ	0,0
;
	TRMEM=.
	FRPTN,,FROMPA
	SETOM	0,0
;
	TRREG=.
	FRRFC,,FRPTN
	SETO	0,0
;


;
;TABLE FOR CODE GENERATORS FOR EXPONENTIATION IN LINE
;
;FOR KI/KL
OPGEX:	-1,,OPGEX1		;INTEGER MULTIPLY BY MEMORY
	-1,,OPGEX2		;REAL MULTIPLY BY MEMORY
	-1,,OPGEX7		;DP MULTIIPLY BY MEMORY
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGEXS:	-1,,OPGEX3		;INTEGER MULTIPLY BY SELF
	-1,,OPGEX4		;REAL MULTIPLY BY SELF
	-1,,OPGEX8		;DP MULTIPLY BY SELF
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGEXM:	-1,,OPGEX5		;INTEGER MUL TO MEMORY
	-1,,OPGEX6		;REAL MULTIPLY TO MEMORY
	ILG			;DP IS NEVER DONE TO MEMORY
	ILG			;COMPLEX EXPONEN NOT DONE IN LINE
;
;[761] FOR GFLOATING
OPGXG:	-1,,OPGEX1		;INTEGER MULTIPLY BY MEMORY
	-1,,OPGEX2		;REAL MULTIPLY BY MEMORY
	-1,,OPGXG1		;DP MULTIIPLY BY MEMORY
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGXGS:	-1,,OPGEX3		;INTEGER MULTIPLY BY SELF
	-1,,OPGEX4		;REAL MULTIPLY BY SELF
	-1,,OPGXG2		;DP MULTIPLY BY SELF
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGXGM:	-1,,OPGEX5		;INTEGER MUL TO MEMORY
	-1,,OPGEX6		;REAL MULTIPLY TO MEMORY
	ILG			;DP IS NEVER DONE TO MEMORY
	ILG			;COMPLEX EXPONEN NOT DONE IN LINE

;
	OPGEX1=.

	FRRFC,,FROMA1
	IMUL	0,0
;
	OPGEX2=.

	FRRFC,,FROMA1
	FMPR	0,0
;
	OPGEX3=.

	FRRFC,,FRRFC
	IMUL	0,0
;
	OPGEX4=.

	FRRFC,,FRRFC
	FMPR	0,0
;
	OPGEX5=.
	FRRFC,,FROMA1
	IMULM	0,0
;
	OPGEX6=.
	FRRFC,,FROMA1
	FMPRM	0,0
;
	OPGEX7=.
	FRRFC,,FROMA1
	DFMP	0,0		;DP IS DONE IN LINE FOR KI ONLY
;
	OPGEX8=.
	FRRFC,,FRRFC
	DFMP	0,0
;
	OPGXG1=.		;[761]
	FRRFC,,FROMA1
	GFMP	0,0
;
	OPGXG2=.		;[761]
	FRRFC,,FRRFC
	GFMP	0,0
;
;
; FOR EXPONEN OF AN IMMED LOOP INDEX(IE RIGHT HALF OF AOBJN)
;
OPGXPI:	-1,,OPGEX9
;
	OPGEX9=.
	FRRFC,,A1CNST
	IMULI	0,0
;
;TABLE FOR CODE GENERATION FOR ARITH OPERATIONS
;
;FOR KI10
OPGARI:	-1,,ADFX
	-1,,ADFL
	-1,,ADDPKI
	-2,,ADCM
	-1,,SBFX
	-1,,SBFL
	-1,,SBDPKI
	-2,,SBCM
	-1,,MLFX
	-1,,MLFL
	-1,,MLDPKI
	-2,,MLCM
	-1,,DVFX
	-1,,DVFL
	-1,,DVDPKI
	-2,,DVCM
;  FOR OPERATIONS TO MEMORY
	-1,,ADFXM
	-1,,ADFLM
	-2,,ADDPMI
	-2,,ADCMM
	-1,,SBFXM
	-1,,SBFLM
	-2,,SBDPMI
	-2,,SBCMM
	-1,,MLFXM
	-1,,MLFLM
	-2,,MLDPMI
	-2,,MLCMM
	-1,,DVFXM
	-1,,DVFLM
	-2,,DVDPMI
	-2,,DVCMM
;  FOR OPERATIONS PERFORMED IMMEDIATE
	-1,,ADFXI
	-1,,ADFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,ADCMI
	-1,,SBFXI
	-1,,SBFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,SBCMI
	-1,,MLFXI
	-1,,MLFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,MLCMI
	-1,,DVFXI
	-1,,DVFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,DVCMI
;FOR OPERATIONS TO BOTH (NOTE THAT WE DESIGNATE OP TO BOTH BY SETTING
; BOTH THE "OP TO MEMORY" AND "IMMEDIATE" FLAGS)
	-1,,ADFXB	;INTEGER ADD TO BOTH
	-1,,ADFLB	;REAL ADD TO BOTH
	-2,,ADDPMI	;DP ADD TO BOTH ON KI10 SAME AS DP ADD TO MEM
	-2,,ADCMB	;COMPLEX ADD TO BOTH
	-1,,SBFXB	;INTEGER SUBTRACT TO BOTH
	-1,,SBFLB	;REAL SUBTRACTB TO BOTH
	-2,,SBDPMI	;DP SUB TO BOTH ON KI10 SAME AS DP SUB TO MEM
	-2,,SBCMB	;COMPLEX SUBTRACT TO BOTH
	-1,,MLFXB	;INTEGER MULTIPLY TO BOTH
	-1,,MLFLB	;REAL MULTIPLY TO BOTH
	-2,,MLDPMI	;DP MUL TO BOTH ON KI10 SAME AS DP MUL TO MEM
	ILG		;COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED
	-1,,DVFXB	;INTEGER DIVIDE TO BOTH
	-1,,DVFLB	;REAL DIVIDE TO BOTH
	-2,,DVDPMI	;DP DIV TO BOTH ON KI10 SAME AS DP DIV TO MEM
	ILG		;COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED
;
;[761] FOR GFLOATING
OPGARG:	-1,,ADFX
	-1,,ADFL
	-1,,ADDPGF
	-2,,ADCM
	-1,,SBFX
	-1,,SBFL
	-1,,SBDPGF
	-2,,SBCM
	-1,,MLFX
	-1,,MLFL
	-1,,MLDPGF
	-2,,MLCM
	-1,,DVFX
	-1,,DVFL
	-1,,DVDPGF
	-2,,DVCM
;  FOR OPERATIONS TO MEMORY
	-1,,ADFXM
	-1,,ADFLM
	-2,,ADDPMG
	-2,,ADCMM
	-1,,SBFXM
	-1,,SBFLM
	-2,,SBDPMG
	-2,,SBCMM
	-1,,MLFXM
	-1,,MLFLM
	-2,,MLDPMG
	-2,,MLCMM
	-1,,DVFXM
	-1,,DVFLM
	-2,,DVDPMG
	-2,,DVCMM
;  FOR OPERATIONS PERFORMED IMMEDIATE
	-1,,ADFXI
	-1,,ADFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,ADCMI
	-1,,SBFXI
	-1,,SBFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,SBCMI
	-1,,MLFXI
	-1,,MLFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,MLCMI
	-1,,DVFXI
	-1,,DVFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,DVCMI
;FOR OPERATIONS TO BOTH (NOTE THAT WE DESIGNATE OP TO BOTH BY SETTING
; BOTH THE "OP TO MEMORY" AND "IMMEDIATE" FLAGS)
	-1,,ADFXB	;INTEGER ADD TO BOTH
	-1,,ADFLB	;REAL ADD TO BOTH
	-2,,ADDPMG	;DP ADD TO BOTH ON KI10 SAME AS DP ADD TO MEM
	-2,,ADCMB	;COMPLEX ADD TO BOTH
	-1,,SBFXB	;INTEGER SUBTRACT TO BOTH
	-1,,SBFLB	;REAL SUBTRACTB TO BOTH
	-2,,SBDPMG	;DP SUB TO BOTH ON KI10 SAME AS DP SUB TO MEM
	-2,,SBCMB	;COMPLEX SUBTRACT TO BOTH
	-1,,MLFXB	;INTEGER MULTIPLY TO BOTH
	-1,,MLFLB	;REAL MULTIPLY TO BOTH
	-2,,MLDPMG	;DP MUL TO BOTH ON KI10 SAME AS DP MUL TO MEM
	ILG		;COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED
	-1,,DVFXB	;INTEGER DIVIDE TO BOTH
	-1,,DVFLB	;REAL DIVIDE TO BOTH
	-2,,DVDPMG	;DP DIV TO BOTH ON KI10 SAME AS DP DIV TO MEM
	ILG		;COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED
;
;
;DEFINE CODE GENERATORS FOR THE ARITHMETIC OPERATIONS
;
;FOR INTEGER, REAL, AND COMPLEX OPERATIONS
	ADFX=.			;ADD INTEGER
	FRRFC,,FROMA2
	ADD	0,0
;
	ADFL=.			;ADD FLOATING PT
	ADCM=.			;ADD COMPLEX (next 2 instrs)
	FRRFC,,FROMA2
	FADR	0,0
;
	FRRFC,,FROMA2
	FADR	1,1
;
;
	SBFX=.			;SUBTRACT INTEGER
	FRRFC,,FROMA2
	SUB	0,0
;
	SBFL=.			;SUBTRACT FLOATING PT
	SBCM=.			;SUBTRACT COMPLEX (next 2 instrs)
	FRRFC,,FROMA2
	FSBR	0,0
;
	FRRFC,,FROMA2
	FSBR	1,1
;
;
	MLFX=.			;MULTIPLY INTEGER
	FRRFC,,FROMA2
	IMUL	0,0
;
	MLFL=.			;MULTIPLY REAL
	FRRFC,,FROMA2
	FMPR	0,0
;
	MLCM=.			;MULTIPLY COMPLEX (next 2 instrs)
	FRPTN,,FROMA2
	XMOVEI	16,0		;[1401]
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMMLTB
;
;
	DVFX=.			;INTEGER DIVIDE
	FRRFC,,FROMA2
	IDIV	0,0
;
	DVFL=.			;REAL DIVIDE
	FRRFC,,FROMA2
	FDVR	0,0
;
	DVCM=.			;COMPLEX DIVIDE (next 2 instrs)
	FRPTN,,FROMA2
	XMOVEI	16,0		;[1401]
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMDVTB
;
;
;FOR INTEGER,REAL AND COMPLEX OPERATIONS PERFORMED TO MEMORY
	ADFXM=.			;INTEGER ADD TO MEMORY
	FRRFC,,FROMA2
	ADDM	0,0
;
	ADFLM=.			;ADD FLOATING PT TO MEMORY
	ADCMM=.			;ADD COMPLEX TO MEMORY (next 2 instrs)
	FRRFC,,FROMA2
	FADRM	0,0
;
	FRRFC,,FROMA2
	FADRM	1,1
;
;
	SBFXM=.
	FRRFC,,FROMA2
	SUBM	0,0
;
	SBFLM=.			;SUBTRACT FLOATING PT TO MEMORY
	SBCMM=.			;SUBTRACT COMPLEX TO MEMORY (next 2 instrs)
	FRRFC,,FROMA2
	FSBRM	0,0
;
	FRRFC,,FROMA2
	FSBRM	1,1
;
;
	MLFXM=.			;INTEGER MULTIPLY TO MEMORY
	FRRFC,,FROMA2
	IMULM	0,0
;
	MLFLM=.			;REAL MULTIPLY TO MEMORY
	FRRFC,,FROMA2
	FMPRM	0,0
;
	MLCMM=.			;COMPLEX MULTIPLY TO MEMORY (next 2 instrs)
	FRPTN,,FROMA2
	XMOVEI	16,0		;[1401]
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMMLMT
;
	DVFXM=.			;INTEGER DIVIDE TO MEMORY
	FRRFC,,FROMA2
	IDIVM	0,0
;
	DVFLM=.			;REAL DIVIDE TO MEMORY
	FRRFC,,FROMA2
	FDVRM	0,0
;
	DVCMM=.			;COMPLEX DIVIDE TO MEMORY (next 2 instrs)
	FRPTN,,FROMA2
	XMOVEI	16,0		;[1401]
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMDVMT
;
;
;	INTEGER,REAL AND COMPLEX OPERATIONS PERFORMED IMMEDIATE
	ADFXI=.
	FRRFC,,A2CNST
	ADDI	0,0
;
	ADFLI=.			;ADD FLOATING IMMEDIATE
	ADCMI=.			;ADD IMMED TO COMPLEX
	FRRFC,,A2CNST
	FADRI	0,0
;
	SBFXI=.
	FRRFC,,A2CNST
	SUBI	0,0
;
	SBFLI=.				;SUB FLOATING IMMED
	SBCMI=.				;SUB IMMED FROM COMPLEX
	FRRFC,,A2CNST
	FSBRI	0,0
;
	MLFXI=.			;INTEGER MULTIPLY IMMEDIATE
	FRRFC,,A2CNST
	IMULI	0,0
;
	MLFLI=.			;REAL MULTIPLY IMMEDIATE
	FRRFC,,A2CNST
	FMPRI	0,0
;
	MLCMI=.			;COMPLEX VAR MULTIPLIED BY AN IMMED CONST
	FRRFC,,A2CNST		; (next 2 instrs)
	FMPRI	0,0
;
	FRRFC,,A2CNST
	FMPRI	1,0
;
	DVFXI=.			;INTEGER DIVIDE IMMED
	FRRFC,,A2CNST
	IDIVI	0,0
;
	DVFLI=.			;REAL DIVIDE IMMED
	FRRFC,,A2CNST
	FDVRI	0,0
;
	DVCMI=.			;COMPLEX VAR DIVIDED BY AN IMMED CNST
	FRRFC,,A2CNST		; (next 2 instrs)
	FDVRI	0,0
;
	FRRFC,,A2CNST
	FDVRI	1,0
;
;
;
;
;FOR INTEGER,REAL, AND COMPLEX OPERATIONS TO BOTH
;
	ADFXB=.		;INTEGER ADD TO BOTH
	FRRFC,,FROMA2
	ADDB	0,0
;
	ADFLB=.		;REAL ADD TO BOTH
	ADCMB=.		;COMPLEX ADD TO BOTH (NEXT 2 INSTRS)
	FRRFC,,FROMA2
	FADRB	0,0
;
	FRRFC,,FROMA2
	FADRB	1,1
;
	SBFXB=.		;INTEGER SUBTRACT TO BOTH
	FRRFC,,FROMA2
	SUBB	0,0
;
	SBFLB=.		;REAL SUBTRACT TO BOTH
	SBCMB=.		;COMPLEX SUBTRACT TO BOTH (next 2 instrs)
	FRRFC,,FROMA2
	FSBRB	0,0
;
	FRRFC,,FROMA2
	FSBRB	1,1
;
	MLFXB=.		;INTEGER MULTIPLY TO BOTH
	FRRFC,,FROMA2
	IMULB	0,0
;
	MLFLB=.		;REAL MULTIPLY TO BOTH
	FRRFC,,FROMA2
	FMPRB	0,0
;
;	(COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED)
;
	DVFXB=.	;INTEGER DIVIDE TO BOTH
	FRRFC,,FROMA2
	IDIVB	0,0
;
	DVFLB=.	;REAL DIVIDE TO BOTH
	FRRFC,,FROMA2
	FDVRB	0,0
;
;	(COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED)
;
;
;
;FOR DOUBLE-PREC OPS ON KI10
;
	ADDPKI=.		; add double-prec
	ADDPMI=.		; (to memory - next 2 instrs)
	FRRFC,,FROMA2
	DFAD	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	SBDPKI=.		;SUB DOUBLE-PREC
	SBDPMI=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	DFSB	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	MLDPKI=.		;MUL DOUBLE-PREC
	MLDPMI=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	DFMP	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	DVDPKI=.		;DIV DOUBLE-PREC
	DVDPMI=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	DFDV	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;FOR GLOATING DP OPS ON KL10
;
	ADDPGF=.		; add double-prec
	ADDPMG=.		; ( to memory - next 2 instrs)
	FRRFC,,FROMA2
	GFAD	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	SBDPGF=.		;SUB DOUBLE-PREC
	SBDPMG=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	GFSB	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	MLDPGF=.		;MUL DOUBLE-PREC
	MLDPMG=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	GFMP	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	DVDPGF=.		;DIV DOUBLE-PREC
	DVDPMG=.		; (TO MEMORY - next 2 instrs)
	FRRFC,,FROMA2
	GFDV	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
;

;
;SET UP TABLES OF IMPLICIT FUNCTION NAMES
; FOR EACH OPERATION HAVE A DIFFERENT FN CORRESPONDING
; TO EACH REGISTER BETWEEN 2 AND 14
;
;	COMPLEX MULTIPLY
CMMLTB:	SIXBIT "CFM.0"
	SIXBIT "CFM.1"
	SIXBIT "CFM.2"
	SIXBIT "CFM.3"
	SIXBIT "CFM.4"
	SIXBIT "CFM.5"
	SIXBIT "CFM.6"
	SIXBIT "CFM.7"
	SIXBIT "CFM.10"
	SIXBIT "CFM.11"
	SIXBIT "CFM.12"
	SIXBIT "CFM.13"
	SIXBIT "CFM.14"
;	COMPLEX DIVIDE
CMDVTB:	SIXBIT "CFD.0"
	SIXBIT "CFD.1"
	SIXBIT "CFD.2"
	SIXBIT "CFD.3"
	SIXBIT "CFD.4"
	SIXBIT "CFD.5"
	SIXBIT "CFD.6"
	SIXBIT "CFD.7"
	SIXBIT "CFD.10"
	SIXBIT "CFD.11"
	SIXBIT "CFD.12"
	SIXBIT "CFD.13"
	SIXBIT "CFD.14"
;	COMPLEX MULTIPLY TO MEMORY
CMMLMT:	SIXBIT "CMM.0"
	SIXBIT "CMM.1"
	SIXBIT "CMM.2"
	SIXBIT "CMM.3"
	SIXBIT "CMM.4"
	SIXBIT "CMM.5"
	SIXBIT "CMM.6"
	SIXBIT "CMM.7"
	SIXBIT "CMM.10"
	SIXBIT "CMM.11"
	SIXBIT "CMM.12"
	SIXBIT "CMM.13"
	SIXBIT "CMM.14"
;	COMPLEX DIVIDE TO MEMORY
CMDVMT:	SIXBIT "CDM.0"
	SIXBIT "CDM.1"
	SIXBIT "CDM.2"
	SIXBIT "CDM.3"
	SIXBIT "CDM.4"
	SIXBIT "CDM.5"
	SIXBIT "CDM.6"
	SIXBIT "CDM.7"
	SIXBIT "CDM.10"
	SIXBIT "CDM.11"
	SIXBIT "CDM.12"
	SIXBIT "CDM.13"
	SIXBIT "CDM.14"


;
;DISPATCH TABLE FOR TYPE-CONVERSION OPERATIONS
;
;
;FOR KI10
OPGTCI:	IGN		;FROM LOGICAL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM CONTROL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM DOUBLE-OCTAL,	TO INTEG
	IGN		;			TO REAL
	IGN		;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
	IGN		;FROM LITERAL
	IGN
	IGN
	IGN
	IGN		;FROM INTEG,	TO INTEG
	-1,,INRLI	;		TO REAL
	-1,,INDP	;		TO DOUBLE-PREC
	-2,,INCMI	;		TO COMPLEX
	-1,,RLINI	;FROM REAL,	TO INTEGER
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE PREC
	-1,,RLCMP	;		TO COMPLEX
	-1,,DPIN	;FROM DOUBLE-PREC,	TO INTEGER
	-1,,DPRLI	;			TO REAL
	IGN		;			TO DOUBLE-PREC
	-2,,DPCMP	;[1135]			TO COMPLEX
	-1,,RLINI	;FROM COMPLEX,		TO INTEGER
	IGN		;			TO REAL
	-1,,CMPDP	;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
;[761] FOR GFLOATING DP
OPGTCG:	IGN		;FROM LOGICAL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;[1417]		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM CONTROL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;[1417]		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM DOUBLE-OCTAL,	TO INTEG
	IGN		;			TO REAL
	IGN		;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
	IGN		;FROM LITERAL
	IGN
	IGN
	IGN
	IGN		;FROM INTEG,	TO INTEG
	-1,,INRLI	;		TO REAL
	-1,,INGF	;		TO DOUBLE-PREC
	-2,,INCMI	;		TO COMPLEX
	-1,,RLINI	;FROM REAL,	TO INTEGER
	IGN		;		TO REAL
	-1,,RLGF	;		TO DOUBLE PREC
	-1,,RLCMP	;		TO COMPLEX
	-1,,GFIN	;FROM DOUBLE-PREC,	TO INTEGER
	-1,,GFRLI	;			TO REAL
	IGN		;			TO DOUBLE-PREC
	-2,,GFCMP	;			TO COMPLEX
	-1,,RLINI	;FROM COMPLEX,		TO INTEGER
	IGN		;			TO REAL
	-1,,CMPGF	;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
;
;CODE GENERATORS FOR TYPE CONVERSIONS
;
;
;
;
;
	INDP=.		;INTEGER TO DOUBLE-PREC
	FRPTN,,RGIMFN
	PUSHJ	17,DFLTT
;
;
;
;
	RLCMP=.		;REAL TO COMPLEX
	RLDP=.		;REAL TO DOUBLE-PREC
	CMPDP=.		;COMPLEX TO DOUBLE PREC (ACROSS ASSIGNMENT)
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
;[1135]	Make DOUBLE PRECISION to COMPLEX conversion do rounding.
	DPCMP=.		;DOUBLE PREC TO COMPLEX (ACROSS ASSIGNMENT)
	FRPTN,,RGIMFN
	PUSHJ	17,SNGLT
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
	DPIN=.		;FROM DOUBLE-PREC TO INTEGER
	FRPTN,,RGIMFN
	PUSHJ	17,IDFIXT
;
;
;
;
	DPRLI=.		;FROM DOUBLE PREC TO REAL ON KI10 (USE NEXT 1 INSTR)
	FRPTN,,RGIMFN
	PUSHJ	17,SNGLT
;
;
	INRLI=.		;FROM INTEGER TO REAL ON KI10 (NEXT 1 INSTR)
	INCMI=.		;FROM INTEGER TO COMPLEX ON KI10 (NEXT 2 INSTRS)
	FRRFC,,FRRFC
	FLTR	0,0
;
	FRRFC,,FRPTN
	SETZ	1,0
;
;
	RLINI=.		;FROM REAL TO INTEGER ON KI10
	FRRFC,,FRRFC
	FIX	0,0
;
;
;[761] FOR GFLOATING DP
	INGF=.
	FRRFC,,RGIMFN
	EXTEND	0,GFLTRT
;
;
	RLGF=.
	CMPGF=.
	FRRFC,,RGIMFN
	EXTEND	0,GDBLET
;
;
	GFIN=.
	FRRFC,,RGIMFN
	EXTEND	0,GFIXT
;
;
	GFCMP=.			; (next 2 instrs)
	GFRLI=.
	FRRFC,,RGIMFN
	EXTEND	0,GSNGLT
;
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
;
;SET UP SIXBIT FN NAMES FOR THE LIBRARY FNS USED FOR TYPE-CONVERSIONS - 
; THE OUTPUT MODULE EXPECTS
; TO BE GIVEN A PTR TO THE SIXBIT FOR A FUNCTION NAME
;
DFLTT:	SIXBIT	"DFL.0"
	SIXBIT	"DFL.1"
	SIXBIT	"DFL.2"
	SIXBIT	"DFL.3"
	SIXBIT	"DFL.4"
	SIXBIT	"DFL.5"
	SIXBIT	"DFL.6"
	SIXBIT	"DFL.7"
	SIXBIT	"DFL.10"
	SIXBIT	"DFL.11"
	SIXBIT	"DFL.12"
	SIXBIT	"DFL.13"
	SIXBIT	"DFL.14"
;
IDFIXT:	SIXBIT	"IDF.0"
	SIXBIT	"IDF.1"
	SIXBIT	"IDF.2"
	SIXBIT	"IDF.3"
	SIXBIT	"IDF.4"
	SIXBIT	"IDF.5"
	SIXBIT	"IDF.6"
	SIXBIT	"IDF.7"
	SIXBIT	"IDF.10"
	SIXBIT	"IDF.11"
	SIXBIT	"IDF.12"
	SIXBIT	"IDF.13"
	SIXBIT	"IDF.14"
SNGLT:	SIXBIT	"SNG.0"
	SIXBIT	"SNG.1"
	SIXBIT	"SNG.2"
	SIXBIT	"SNG.3"
	SIXBIT	"SNG.4"
	SIXBIT	"SNG.5"
	SIXBIT	"SNG.6"
	SIXBIT	"SNG.7"
	SIXBIT	"SNG.10"
	SIXBIT	"SNG.11"
	SIXBIT	"SNG.12"
	SIXBIT	"SNG.13"
	SIXBIT	"SNG.14"
GDBLET:	SIXBIT	"GDB.0"
	SIXBIT	"GDB.1"
	SIXBIT	"GDB.2"
	SIXBIT	"GDB.3"
	SIXBIT	"GDB.4"
	SIXBIT	"GDB.5"
	SIXBIT	"GDB.6"
	SIXBIT	"GDB.7"
	SIXBIT	"GDB.10"
	SIXBIT	"GDB.11"
	SIXBIT	"GDB.12"
	SIXBIT	"GDB.13"
	SIXBIT	"GDB.14"
GFIXT:	SIXBIT	"GFX.0"
	SIXBIT	"GFX.1"
	SIXBIT	"GFX.2"
	SIXBIT	"GFX.3"
	SIXBIT	"GFX.4"
	SIXBIT	"GFX.5"
	SIXBIT	"GFX.6"
	SIXBIT	"GFX.7"
	SIXBIT	"GFX.10"
	SIXBIT	"GFX.11"
	SIXBIT	"GFX.12"
	SIXBIT	"GFX.13"
	SIXBIT	"GFX.14"
GFLTRT:	SIXBIT	"GFL.0"
	SIXBIT	"GFL.1"
	SIXBIT	"GFL.2"
	SIXBIT	"GFL.3"
	SIXBIT	"GFL.4"
	SIXBIT	"GFL.5"
	SIXBIT	"GFL.6"
	SIXBIT	"GFL.7"
	SIXBIT	"GFL.10"
	SIXBIT	"GFL.11"
	SIXBIT	"GFL.12"
	SIXBIT	"GFL.13"
	SIXBIT	"GFL.14"
GSNGLT:	SIXBIT	"GSN.0"
	SIXBIT	"GSN.1"
	SIXBIT	"GSN.2"
	SIXBIT	"GSN.3"
	SIXBIT	"GSN.4"
	SIXBIT	"GSN.5"
	SIXBIT	"GSN.6"
	SIXBIT	"GSN.7"
	SIXBIT	"GSN.10"
	SIXBIT	"GSN.11"
	SIXBIT	"GSN.12"
	SIXBIT	"GSN.13"
	SIXBIT	"GSN.14"

;
;DISPATCH TABLE FOR STORE VALUE
;
;FOR KI10

OPGSTI:	-1,,ST
OPGST2:	-1,,ST2I

;
;CODE GENERATORS TO STORE A VAL

	ST=.
	FRRFC,,FROMPA
	MOVEM	0,0
;
;
;
	ST2I=.
	FRRFC,,FROMPA
	DMOVEM	0,0
;
;
;
;
;DISPATCH TABLE FOR "ASSIGNMENT STMNT STORE VALUE"
;
;
;FOR KI10
OPGASI:	-1,,ST
	-1,,ST
	-1,,ST2I
	-1,,ST2I
;	FOR NEG OF ARG
	-1,,STNG
	-1,,STNG
	-1,,STNG2I		;STORE NEG OF DOUBLE-PREC
	-2,,STNCPX		; NEG OF COMPLEX
;	FOR NOT OF ARG
	-1,,STNT
	-1,,STNT
	-2,,STNT2
	-2,,STNT2
; 
;WHEN STORING THE RIGHT HALF OF A REGCONTENTS WHICH WAS USED AS AN AOBJN WD
OPGASR:	-1,,STAOBJ
;
;
;CODE GENERATORS TO STORE NEG OR NOT OF A VALUE
	STNG=.
	STNCPX=.		;STORE NEG OF COMPLEX (NEXT 2 INSTRS)
	FRRFC,,FROMPA
	MOVNM	0,0
;
	FRRFC,,FROMPA
	MOVNM	1,1
;
	STNT=.			;STORE NOT OF ARG
	FRRFC,,FROMPA
	SETCAM	0,0
;
;
;
	STNG2I=.		;STORE NEG OF ARG - DOUBLE-PREC KI10
	FRRFC,,FROMPA
	DMOVNM	0,0
;
	STNT2=.			;STORE NOT OF DOUBLE-WD ARG (next 2 instrs)
	FRRFC,,FROMPA
	SETCAM	0,0
;
	FRRFC,,FROMPA
	SETCAM	1,1
;
;
;CODE GENERATOR FOR THE SPECIAL CASE OF STORING THE RIGHT HALF OF AN AOBJN WD
; (WHICH CONTAINS A LOOP INDEX)
STAOBJ:	FRRFC,,FROMPA
	HRRZM	0,0


;
;FOR ASSIGN STATEMENT
;
OPASIN:	-2,,ASSIGN
;
	ASSIGN=.		;ALWAYS USE REG 1 (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI	1,0		;[1401]
;
	FRPTN,,FROMA1
	MOVEM	1,0
;

;
;DISPATCH TABLE FOR BOOLEAN OPERATIONS
;
;	COMPUTED IN A REG
OPGBOO:	-1,,ANDRG
	-1,,ORRG
	-1,,EQVRG
	-1,,XORRG
;	COMPUTED TO MEMORY
	-1,,ANDMEM
	-1,,ORMEM
	-1,,EQVMEM
	-1,,XORMEM
;	COMPUTED IMMEDIATE
	-1,,ANDIMM
	-1,,ORIMM
	-1,,EQVIMM
	-1,,XORIMM
;	OPERATIONS TO BOTH REG AND MEMORY
	-1,,ANDBO
	-1,,ORBO
	-1,,EQVBO
	-1,,XORBO
;	OPERATIONS INCLUDING NOT OF 2ND ARG
	-1,,ANDNOT
	-1,,ORNOT
	-1,,XORRG		;EQV WITH NOT X IS SAME AS XOR X
	-1,,EQVRG		;XOR WITH NOT X = EQV WITH X
;	OPERATIONS TO MEMORY INCLUDING NOT OF 2ND ARG
	-1,,ANDNTM
	-1,,ORNTM
	-1,,XORMEM
	-1,,EQVMEM
;	COMPUTED IMMEDIATE WITH NOT OF THE 2ND ARG
	-1,,ANDNTI
	-1,,ORNTI
	-1,,XORIMM	;XOR WITH NOT OF ARG IS SAME AS EQV WITH ARG
	-1,,EQVIMM
;	OPERATIONS TO "BOTH" WITH NOT OF 2ND ARG
	-1,,ANDNTB
	-1,,ORNTB
	-1,,XORBO	;EQV WITH NOT IS SAME AS XOR
	-1,,EQVBO	;XOR WITH NOT IS SAME AS EQV
;
;
;
;DEFINE CODE GENERATORS FOR BOOLEAN OPS
;
	ANDRG=.
	FRRFC,,FROMA2
	AND	0,0
;
	ORRG=.
	FRRFC,,FROMA2
	IOR	0,0
;
	EQVRG=.
	FRRFC,,FROMA2
	EQV	0,0
;
	XORRG=.
	FRRFC,,FROMA2
	XOR	0,0
;
	ANDMEM=.
	FRRFC,,FROMA2
	ANDM	0,0
;
	ORMEM=.
	FRRFC,,FROMA2
	IORM	0,0
;
	EQVMEM=.
	FRRFC,,FROMA2
	EQVM	0,0
;
	XORMEM=.
	FRRFC,,FROMA2
	XORM	0,0
;
	ANDBO=.		;AND TO BOTH
	FRRFC,,FROMA2
	ANDB	0,0
;
	ORBO=.		;OR TO BOTH
	FRRFC,,FROMA2
	IORB	0,0
;
	EQVBO=.		;EQV TO BOTH
	FRRFC,,FROMA2
	EQVB	0,0
;
	XORBO=.
	FRRFC,,FROMA2
	XORB	0,0
;
	ANDIMM=.
	FRRFC,,A2CNST
	ANDI	0,0
;
	ORIMM=.
	FRRFC,,A2CNST
	IORI	0,0
;
	EQVIMM=.
	FRRFC,,A2CNST
	EQVI	0,0
;
	XORIMM=.
	FRRFC,,A2CNST
	XORI	0,0
;
	ANDNOT=.
	FRRFC,,FROMA2
	ANDCM	0,0
;
	ORNOT=.
	FRRFC,,FROMA2
	ORCM	0,0
;
	ANDNTM=.
	FRRFC,,FROMA2
	ANDCMM	0,0
;
	ORNTM=.
	FRRFC,,FROMA2
	ORCMM	0,0
;
	ANDNTI=.	;AND WITH NOT OF AN IMMED
	FRRFC,,A2CNST
	ANDCMI	0,0
;
	ORNTI=.		;OR WITH NOT OF AN IMMED
	FRRFC,,A2CNST
	ORCMI	0,0
;
	ANDNTB=.	;AND WITH NOT OF ARG TO BOTH
	FRRFC,,FROMA2
	ANDCMB	0,0
;
	ORNTB=.		;OR WITH NOT OF ARG TO BOTH
	FRRFC,,FROMA2
	ORCMB	0,0

;
;DISPATCH TABLE FOR RELATIONALS
;
;	WHERE ARGS ARE SINGLE-WD - AND ARG2 NOT IMMED
OPGREL:	ILG		;MODE 0 ILLEGAL
	-1,,CMSPL
	-1,,CMSPE
	-1,,CMSPLE
	ILG		;MODE 4 IS ILLEGAL
	-1,,CMSPGE
	-1,,CMSPN
	-1,,CMSPG
;	FOR ARG2 IMMED
	ILG		;MODE 0 IS ILLEGAL
	-1,,CMIML
	-1,,CMIME
	-1,,CMIMLE
	ILG		;MODE 4 IS ILLEGAL
	-1,,CMIMGE
	-1,,CMIMN
	-1,,CMIMG
;	FOR ARGS DOUBLE-WD
	ILG		;MODE 0 IS ILLEGAL
	-3,,CMDPL
	-2,,CMDPE
	-3,,CMDPLE
	ILG		;MODE 4 IS ILLEGAL
	-3,,CMDPGE
	-3,,CMDPN
	-3,,CMDPG
;	ARG2 IMMED AND DOUBLE-WD BOTH
	ILG	;MODE 0 IS ILLEGAL
	-3,,CDPIL
	-2,,CDPIE
	-3,,CDPILE
	ILG	;MODE 4 IS ILLEGAL
	-3,,CDPIGE
	-3,,CDPIN
	-3,,CDPIG
;
;
;CODE GENERATORS FOR RELATIONALS
;
;	TO COMPARE SINGLE-WD ARGS
	CMSPL=.
	FRRFC,,FROMA2
	CAML	0,0
;
	CMSPE=.
	FRRFC,,FROMA2
	CAME	0,0
;
	CMSPLE=.
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMSPGE=.
	FRRFC,,FROMA2
	CAMGE	0,0
;
	CMSPN=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	CMSPG=.
	FRRFC,,FROMA2
	CAMG	0,0
;
;	TO COMPARE WITH AN IMMED CNST SPECIFIED BY ARG2
	CMIML=.
	FRRFC,,A2CNST
	CAIL	0,0
;
	CMIME=.
	FRRFC,,A2CNST
	CAIE	0,0
;
	CMIMLE=.
	FRRFC,,A2CNST
	CAILE	0,0
;
	CMIMGE=.
	FRRFC,,A2CNST
	CAIGE	0,0
;
	CMIMN=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	CMIMG=.
	FRRFC,,A2CNST
	CAIG	0,0
;
;	TO COMPARE DOUBLE-WD ARGS
	CMDPL=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMGE	1,1
;
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMDPE=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAME	1,1
;
	CMDPLE=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMG	1,1
;
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMDPGE=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAML	1,1
;
	FRRFC,,FROMA2
	CAMGE	0,0
;
	CMDPN=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAME	1,1
;
	FRPTN,,FRPTN
	SKIPA
;
	CMDPG=.		; (next 3 instrs)
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMLE	1,1
;
	FRRFC,,FROMA2
	CAMGE	0,0
;
;
;	TO COMPARE DOUBLE-WD IMMED - THIS IS USED ONLY FOR THE CASE
;   	  OF A COMPLEX BEING COMPARED TO 0 , BUT ITS EASIER TO HAVE THE ENTRIES
;		IN THE TABLE THAN TO DIFFERENTIATE COMPLEX-IMMED FROM 
;		REAL-IMMED
	CDPIL=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIGE	1,0
;
	FRRFC,,A2CNST
	CAILE	0,0
;
	CDPIE=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIE	1,0
;
	CDPILE=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIG	1,0
;
	FRRFC,,A2CNST
	CAILE	0,0
;
	CDPIGE=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIL	1,0
;
	FRRFC,,A2CNST
	CAIGE	0,0
;
	CDPIN=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIE	1,0
;
	FRPTN,,FRPTN
	SKIPA
;
	CDPIG=.		; (next 3 instrs)
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAILE	1,0
;
	FRRFC,,A2CNST
	CAIGE	0,0
;



;
;DISPATCH TABLE FOR NEGNOT NODES
; HAVE 2 TABLES - ONE FOR THE CASE WHERE THE VAL HAS BEEN FETCHED
; INTO THE RFC BY GETA2OPIX, THE OTHER FOR THE CASE WHERE IT HAS NOT
;
;NOTE THAT MANY OF THE CODE GENERATORS REFERRED TO ARE ALSO USED FOR
; THE 'OPGETI' ENTRIES AND MAY BE FOUND IN THAT PART OF THE
; LISTING (APPROX LOCS 160-205)
; ALSO, SOME OF THE CODE GENERATORS FOR OPS 'TO MEMORY' ARE ALSO
; USED FOR THE 'OPGASI' ENTRIES AND MAY BE FOUND WITH THEM
; (APPROX LOCS 1244-1263)
;
;IF VAL IS ALREADY IN RFC
;
; KI10
OPGN1I:	-1,,GANGSM		;NEG OF INTEGER
	-1,,GANGSM		; REAL
	-1,,GNGS2I		; DOUBLE-PREC
	-2,,GNGSCM		; COMPLEX
;
	-1,,GANTSM		;NOT OF INTEGER
	-1,,GANTSM		; REAL
	-2,,GNTS2		; DOUBLE-PREC
	-2,,GNTS2		; COMPLEX
;
;		TO MEMORY
	-1,,STNG		;NEG OF INTEGER
	-1,,STNG		; REAL
	-3,,STNG2I		; DOUBLE-PREC
	-2,,STNCPX		; COMPLEX
;
	-1,,STNT		;NOT OF INTEGER
	-1,,STNT		; REAL
	-2,,STNT2		; DOUBLE-PREC
	-2,,STNT2		; COMPLEX
;
;
;WHEN THE ARG IS NOT YET IN RFC
;
; KI10
OPGN2I:	-1,,GANG		;NEG OF INTEGER
	-1,,GANG		; REAL
	-1,,GANG2I		; DOUBLE-PREC
	-2,,GNGCM		; COMPLEX
;
	-1,,GANT		;NOT OF INTEGER
	-1,,GANT		; REAL
	-2,,GANT2		; DOUBLE-PREC
	-2,,GANT2		; COMPLEX
;
;	 TO MEMORY
	-1,,NEGM		;NEG OF INTEGER
	-1,,NEGM		; REAL
	-2,,NEG2IM		; DOUBLE-PREC
	-2,,NEGCMM		; COMPLEX
;
	-1,,NOTM		;NOT OF INTEGER
	-1,,NOTM		; REAL
	-2,,NOT2M		; DOUBLE-PREC
	-2,,NOT2M		; COMPLEX
;
;	 IMMEDIATE
	-1,,GNGIMI		;NEG OF INTEGER
	-1,,GNGIMR		;REAL
	ILG			;DOUBLE-PREC (ILLEGAL)
	-2,,GNGIM2		;COMPLEX
;
	-1,,GNTIMI		;NOT OF IMMED CNST INTEGER
	ILG			; REAL
	ILG			; DOUBLE-PREC
	ILG			; COMPLEX
;
;
;
;NOTE THAT MOST OF THE CODE GENERATORS REFERENCED ABOVE  ARE EITHER WITH
; "OPGETI" OR WITH  "OPGASI"
;THE FOLLOWING CODE GENERATORS ARE FOR NEG/NOT PERFORMED FROM MEMORY TO 
; MEMORY
;
	NEGM=.			;NEG OF INTEGER/REAL
	NEGCMM=.		;NEG OF COMPLEX (NEXT 2 INSTRS)
	FRPTN,,FROMA2
	MOVNS	0,0
;
	FRPTN,,FROMA2
	MOVNS	0,1
;
;
	NEG2IM=.		;NEG OF DOUBLE-PREC ( next 2 instrs )
	FRRFC,,FROMA2
	DMOVN	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	NOTM=.			;NOT OF INTEGER/REAL
	NOT2M=.			;NOT OF DOUBLE-PREC/COMPLEX (NEXT 2 INSTRS)
	FRPTN,,FROMA2
	SETCMM	0,0
;
	FRPTN,,FROMA2
	SETCMM	0,1
;

;
;DISPATCH TABLE FOR COMPUTATION OF P2MUL,P2DIV  AND P2PL1MUL
;
;FOR KI10
	;MULTIPLY BY POWER OF 2
OPGSPI:	-1,,P2MFX
	-1,,P2MFL
	ILG
	-2,,P2MCM
	; WHEN ARG WAS NEGATED
	-1,,P2MFX
	-1,,P2MFL
	ILG
	-2,,P2MCM
	;DIVIDE BY A POWER OF 2
	-3,,P2DFX
	-1,,P2DFL
	ILG
	-2,,P2DCM
	; WHEN ARG WAS NEGATED
	-3,,P2DFX
	-1,,P2DFL
	ILG
	-2,,P2DCM
	;FOR MULTIPLY BY POWER OF 2 PLUS 1
	-2,,P21FX
	-2,,P21FL
	ILG
	-4,,P21CM
	; WHEN ARG WAS NEGATED
	-2,,P21NFX
	-2,,P21NFL
	ILG
	-4,,P21NCM
;[761] FOR GFLOATING DP
	;MULTIPLY BY POWER OF 2
OPGSPG:	-1,,P2MFX
	-1,,P2MFL
	ILG
	-2,,P2MCM
	; WHEN ARG WAS NEGATED
	-1,,P2MFX
	-1,,P2MFL
	ILG
	-2,,P2MCM
	;DIVIDE BY A POWER OF 2
	-3,,P2DFX
	-1,,P2DFL
	ILG
	-2,,P2DCM
	; WHEN ARG WAS NEGATED
	-3,,P2DFX
	-1,,P2DFL
	ILG
	-2,,P2DCM
	;FOR MULTIPLY BY POWER OF 2 PLUS 1
	-2,,P21FX
	-2,,P21FL
	ILG
	-4,,P21CM
	; WHEN ARG WAS NEGATED
	-2,,P21NFX
	-2,,P21NFL
	ILG
	-4,,P21NCM
;
;DISPATCH TABLE FOR MULT BY A POWER OF 2 PLUS 1  WHEN "A1IMMEDFLG" WAS
; SET (THIS IS THE ONLY OPERATOR FOR WHICH IMMEDFLG IS SIGNIFICANT)
OPP21I:	-2,,P21IFX	;IMMED, FIXED POINT
	-2,,P21IFL	;IMMED, FLOATING POINT
	ILG		;IMMED DOUBLE-PREC SHOULD NEVER OCCUR
	-2,,P21ICM	;IMMED, COMPLEX
;	  (P2PL1MUL NEGATED)
	-2,,P21INX	;IMMED,NEGATED,FIXED PT
	-2,,P21INL	;IMMED,NEGATED,FLOATING PT
	ILG		;IMMED, DOUBLE-PREC IS ILLEGAL
	-2,,P21INM	;IMMED, NEGATED, COMPLEX
;
;
;
;DISPATCH TABLE FOR SPECIAL OPS DONE TO MEMORY.
;
;	P2MUL SHOULD NEVER BE DONE TO MEMORY
OPGSPM:	ILG
	ILG
	ILG
	ILG
;	(P2MUL NEGATED - SHOULD NEVER BE DONE TO MEMORY)
	ILG
	ILG
	ILG
	ILG
;	P2DIV SHOULD NEVER BE DONE TO MEMORY
	ILG
	ILG
	ILG
	ILG
;	(P2DIV NEGATED)
	ILG
	ILG
	ILG
	ILG
;	MULTIPLY BY A POWER OF 2 PLUS ONE
	-2,,P21MFX
	-2,,P21MFL
	ILG		;DOUBLE PREC OPS ARE NEVER DONE TO MEMORY
	-4,,P21MCM
;	MULTIPLY THE NEG OF A NUMBER BY A POWER OF TWO PLUS ONE
	-2,,P21MNX
	-2,,P21MNL
	ILG		;DOUBLE PREC OPS ARE NEVER DONE TO MEMORY
	-4,,P21MNC
;
;
;
;
;CODE GENERATORS FOR MULTIPLICATION BY A POWER OF 2
;
	P2MFX=.			;FIXED POINT MULTIPLY BY A POWER OF 2
	P21FX=.			;FIXED POINT MULTIPLY BY A POWER OF 2
				; PLUS 1 (USE NEXT 2 INSTRS)
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	ADD	0,0
;
;
;
	P21NFX=.		;FIXED PT MULTIPLY BY POWER OF 2 PLUS
				; 1 WHEN ARG WAS NEGATED (NEXT 2 INSTRS)
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	SUB	0,0
;
;
;
	P2MFL=.			;FLOATING MULTIPLY BY A POWER OF 2
				; (USE THE 1 NEXT INSTR)
	P21FL=.			;FLOATING POINT MULTIPLY BY A POWER OF 2
				; PLUS 1 (USE NEXT 2 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FADR	0,0
;
;
	P21NFL=.		;FLOATING PT MULTIPLY BY POWER OF 2 PLUS
				; ONE WHEN ARG WAS NEGATED (NEXT 2 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FSBR	0,0
;
;
;
;
;
	P2MCM=.			;MULTIPLY A COMPLEX BY POWER OF 2
				; (USE NEXT 2 INSTRS)
	P21CM=.			;MULTIPLY A COMPLEX BY A POWER OF 2 PLUS
				; 1 (USE NEXT 4 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FADR	0,0
;
	FRRFC,,FROMA1
	FADR	1,1
;
;
	P21NCM=.		;COMPLEX MULTIPLIED BY POWER OF 2 PLUS 1
				; WHEN ARG WAS NEGATED (next 4 instrs)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FSBR	0,0
;
	FRRFC,,FROMA1
	FSBR	1,1
;
;
	P2DFX=.			;FIXED PT DIVIDE BY A POWER OF 2
				; (USE NEXT 3 INSTRS)
	FRPTN,,FRRFC
	SKIPGE	0
;
	FRRFC,,P2PTR2
	ADDI	0,0
;
	FRRFC,,NGPTR2
	ASH	0
;
;
	P2DFL=.			;FLOATING PT DIVIDE BY A POWER OF 2
	P2DDPI=.		;DOUBLE-PREC DIVIDE BY A POWER OF 2
				; ON THE KI10
	FRRFC,,NGPTR2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
;
	P2DCM=.			;COMPLEX DIVIDE  BY A POWER OF 2 
				; (USE THE NEXT 2 INSTRS)
	FRRFC,,NGPTR2
	FSC	0,0
;
	FRRFC,,NGPTR2
	FSC	1,0
;
;
;
	P2MDPI=.		;DOUBLE-PREC MULTIPLY BY A POWER OF 2 FOR
				; THE KI10 (USE THE 2 NEXT INSTR)
	P21DPI=.		;DOUBLE-PREC MULTIPLY BY A POWER OF 2 PLUS 
				; 1 FOR KI10 (USE NEXT 3 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
	FRRFC,,FROMA1
	DFAD	0,0
;
;
	P21NDI=.		;DOUBLE-PREC MULTP BY POWER OF 2 PLUS 1
				; ON KI10 WHEN ARG WAS NEGATED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
	FRRFC,,FROMA1
	DFSB	0,0
;
;
;
;CODE GENERATORS FOR MULTIPLY OF AN IMMED MODE ITEM BY A POWER OF 2 PLUS 1
;
	P21IFX=.	;FIXED PT IMMED CNST MULTIPLIED BY A POWER OF
			; 2 PLUS 1 (next 2 instrs)
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,A1CNST
	ADDI	0,0
;
;
	P21IFL=.	;FLOATING PT IMMED MULTIPLIED BY POWER OF 2 PLUS 1
	FRRFC,,PTRA2	; (next 2 instrs)
	FSC	0,0
;
	FRRFC,,A1CNST
	FADRI	0,0
	P21ICM=.	;COMPLEX IMMED, MULTIPLIED BY POWER OF 2 PLUS 1
	FRRFC,,PTRA2	;(next 2 instrs)
	FSC	0,0
;
	FRRFC,,A1CNST
	FADRI	0,0
;
;
	P21INX=.	;FIXED PT IMMED, NEGATED AND MULTIPLIED
	FRRFC,,PTRA2	; (next 2 instrs)
	ASH	0,0
;
	FRRFC,,A1CNST
	SUBI	0,0
;
;
	P21INL=.	;FLOATING PT IMMED NEGATED AND MULTIPLIED
	FRRFC,,PTRA2	; (next 2 instrs)
	FSC	0,0
;
	FRRFC,,A1CNST
	FSBRI	0,0
;
	P21INM=.	;COMPLEX NEGATED MULTIPLIED BY
			;POWER OF TWO PLUS 1 (next 2 instrs)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,A1CNST
	FSBRI	0,0
;
;
;CODE GENERATORS FOR MULT BY A POWER OF 2 PLUS 1 DONE TO MEMORY
;
	P21MFX=.	;MULTIPLY FIXED PT BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2	; (next 2 instrs)
	ASH	0,0
;
	FRRFC,,FROMA1
	ADDM	0,0
;
	P21MNX=.	;MULTIPLY A FIXED PT WHICH IS NEGATED BY A POWER OF
			; 2 PLUS 1 LEAVING RESULT IN MEMORY (next 2 instrs)
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	SUBM	0,0
;
;
	P21MFL=.	;MULTIPLY FLOATING PT BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2	; (next 2 instrs)
	FSC	0,0
;
	FRRFC,,FROMA1
	FADRM	0,0
;
	P21MNL=.	;MULTIPLY A FLOATING PT WHICH IS NEGATED BY A POWER OF
			; 2 PLUS 1 LEAVING RESULT IN MEMORY (next 2 instrs)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FSBRM	0,0
;
;
	P21MCM=.	;MULTIPLY A COMPLEX BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2	; (next 4 instrs)
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FADRM	0,0
;
	FRRFC,,FROMA1
	FADRM	1,1
;
	P21MNC=.	;MULTIPLY A NEGATED COMPLEX BY A POWEROF 2 PLUS
			; ONE TO MEMORY (next 4 instrs)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FSBRM	0,0
;
	FRRFC,,FROMA1
	FSBRM	1,1
;


;
;TABLES FOR FUNCTIONS FOR WHICH CODE IS GENERATED IN LINE (ABS,SIGN,
; DIM,MOD,MAX,MIN)
;
;
; When the val for ARG1 is already in the reg for computation
;
OPGILF:	-1,,ABS
	ILG		;RESERVE THIS SLOT FOR IABS IN A LATER RELEASE
			; (NEED TO BE ABLE TO GENERATE LABELS TO HANDLE)
	-3,,SIGN
	-3,,DIM
	-2,,MOD		;IN RELEASE 1, MOD MUST MOVE THE VAL FROM REG+1 TO REG
	-2,,MAX
	-2,,MIN
	-2,,CHAR	;[1567] CHAR
	ILG		;[1567] LEN
	0		;[4557] ICHAR

OPGDBF:	-2,,IDABS		;DABS WHEN ARG IN REGFORCOMP ON KI
;
;FOR DIM,MOD,MAX,MIN WHEN ARG2 IS IMMEDIATE
OPGILI:	ILG			;SHOULD NEVER SEE ABS WITH A2IMMED
	ILG			;SHOULD NEVER SEE IABS WITH A2IMMED
	ILG			;SHOULD NEVER SEE SIGN WITH A2IMMED
	-3,,DIMI
	-2,,MODI
	-2,,MAXI
	-2,,MINI
	ILG			;[1567] CHAR
	ILG			;[1567] LEN
	ILG			;[1567] ICHAR

; For ABS, IABS, SIGN, LEN, CHAR, or ICHAR - when the val is not yet in
; REGFORCOMP
OPGIL1:	-1,,ABS1
	ILG			;IABS NOT HANDLED IN RELEASE 1
	-3,,SIGN1
	ILG			;[1567] DIM
	ILG			;[1567] MOD
	ILG			;[1567] MAX
	ILG			;[1567] MIN
	-3,,CHAR1		;[1567] CHAR
	-1,,LEN1		;[1567] LEN
	-2,,ICHAR1		;[4517] ICHAR

OPGDB1:	-3,,IDABS1		;DABS WHEN VAL NOT IN REGFORCOMP ON KI

OPDPB2:	-1,,CHAR2		; [4517] these four are used for single 
OPDPB3:	-1,,CHAR3		; [4517] character assignments
OPDPB4:	-1,,CHAR4		; [4522]

OPLDB2:	-1,,ICHAR2		;[4517] ICHAR
OPLDB3:	-1,,ICHAR3		;[4517] ICHAR
;
;CODE GENERATORS FOR IN LINE FNS
	ABS=.			;FOR ABS, USE NEXT 1 INSTR
	SIGN=.			;FOR SIGN, USE NEXT 3 INSTRS
	FRRFC,,FRRFC
	MOVM	0,0
;
	FRPTN,,FROMA2
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	MOVNS	0,0
;
;
	DIM=.			;FOR DIM, USE NEXT 3 INSTRS
	FRRFC,,FROMA2
	CAMG	0,0
;
	FRRFC,,FRRFC
	TDZA	0,0
;
	FRRFC,,FROMA2
	FSBR	0,0
;
;
	MOD=.			;FOR MOD, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	IDIV	0,0
;
	FRRFC,,FRRFC
	MOVE	0,1
;
;
	MAX=.			;FOR MAX, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	CAMGE	0,0
;
	FRRFC,,FROMA2
	MOVE	0,0
;
;
	MIN=.			;FOR MIN, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	CAMLE	0,0
;
	FRRFC,,FROMA2
	MOVE	0,0
;
;
	DIMI=.			;DIM FOR ARG2 IMMED CNST
	FRRFC,,A2CNST
	CAIG	0,0
;
	FRRFC,,FRRFC
	TDZA	0,0
;
	FRRFC,,A2CNST
	FSBRI	0,0
;
;
	MODI=.			;MOD WITH ARG2 IMMED (NEXT 2 INSTRS)
	FRRFC,,A2CNST
	IDIVI	0,0
;
	FRRFC,,FRRFC
	MOVE	0,1
;
;
	MAXI=.			;MAX WITH ARG2 IMMED
	FRRFC,,A2CNST
	CAIGE	0,0
;
	FRRFC,,A2CNST
	MOVEI	0,0
;
;
	MINI=.			;MIN WITH ARG2 IMMED
	FRRFC,,A2CNST
	CAILE	0,0
;
	FRRFC,,A2CNST
	MOVEI	0,0
;
;
	ABS1=.			; ABS when arg is not in reg (1 inst)
	SIGN1=.			; SIGN when arg is not in reg (3 instrs)
	FRRFC,,FROMA1
	MOVM	0,0
;
	FRPTN,,FROMA2
	SKIPGE	0
;
	FRRFC,,FRRFC
	MOVNS	0,0
;
;
	LEN1=.			;[1567] For LEN, use next intruction
	FRRFC,,FROMA1		;[1567]
	MOVE	0,1		;[1567] Character desc + 1 has the length
;
;
;	For CHAR, we make  a copy of the  Byte pointer because we  don't
;	want to change  the original  one with  the IDPB  which must  be
;	done.
;
	CHAR1=.			;[1567] For CHAR, use next 3 instructions
	FRRFC,,FROMA1		;[1567]
	MOVE	0,0		;[1567] Get numeric argument in register
;
	CHAR=.			;[1567] For CHAR, use next 2 instructions
	FRRFC,,FROMA2		;[1567]
	MOVE	1,0		;[1567] Copy destination BP for result
;
	FRRFC,,FRRFC		;[1567]
	IDPB	0,1		;[1567] Deposit into result BP
;
	CHAR2=.			;[4517] For CHAR (1-char assignment)
	FRRFC,,FROMA1
	DPB	0,0
;
	CHAR3=.			;[4517] For CHAR (1-char assignment)
	FRRFC,,FROMC1
	DPB	0,0
;
	CHAR4=.			;[4522] For CHAR (1-char assignment)
	FRRFC,,FROMC1
	IDPB	0,0
;
;
;	Make a copy of the arg's BP (because it gets incremented),  then
;	get the return value for the function.
;
	ICHAR1=.		;[1567] For ICHAR, use next 2 instructions
	FRRFC,,FROMA1		;[1567]
	MOVE	0,0		;[1567] Copy arg's BP
;
	FRRFC,,FRRFC		;[1567]
	ILDB	0,0		;[1567] Get result from copied BP
;
	ICHAR2=.
	FRRFC,,FROMA1		;[4517] The following are also used for
	LDB	0,0		;[4517] ICHAR however they do not increment BP

;
	ICHAR3=.		;[4517] 
	FRRFC,,FRRFC		;[4517]
	LDB	0,0		;[4517]
;
;
; FOR DABS IN LINE
;
	IDABS=.			; FOR DABS WHEN ARG IN REGFORCOMP
				; ON KI (next 2 instrs)

	FRPTN,,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DMOVN	0,0
;
;
;
;
	IDABS1=.		;FOR DABS WHEN ARG NOT IN
				;REGFORCOMP ON KI (next 3 instrs)
	FRRFC,,FROMA1
	DMOVE	0,0
;
	FRPTN,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DMOVN	0,0
;

;
;TABLES FOR GENERATION OF CODE FOR A "STORECLS" NODE (IE A NODE WHICH
;SPECIFIES THAT SOME VAL IS TO BE STORED IN A TEMPORARY)
;
;
;DISPATCH TABLE
OPGSTC:	-2,,STARVL		;STORE VAL OF AN ARRAY ELEMENT
	-1,,STRRFC		; STORE VAL OF AN ARRAY ELEM WHEN ITS ALREADY
				; IN THE "REG-FOR-COMP"
	-2,,STARAD		;STORE PTR TO AN ARRAY ELEM
	-1,,STRRFC		; STORE PTR TO AN ARRAY ELEM WHEN THAT
				; PTR IS ALREADY IN A REG
;    FOR STORING THE VALUE OF AN ELEMENT IN A DOUBLE-WD ARRAY
OPGSTD:	-2,,STDI		;TO STORE DOUBLE-WD ON KI10
	-1,,STDIS		; DOUBLE-WD, KI10, WHEN VAL IS ALREADY IN 
				; REG-FOR-COMP
;
;
;
;
;CODE GENERATORS
;
	STARVL=.		;TO STORE THE CONTENTS OF AN ARRAY ELEM
	FRRFC,,FROMA2		; (next 2 instrs)
	MOVE	0,0
;
	STRRFC=.		; (TO STORE A VAL ALREADY IN REGFORCOMP)
	FRRFC,,PARTMP
	MOVEM	0,0
;
;
	STARAD=.		;TO STORE A PTR TO AN ARRAY ELEM
	FRRFC,,FROMA2		; (next 2 instrs)
	XMOVEI	0,0		;[1401]
;
	FRRFC,,PARTMP
	MOVEM	0,0
;
;
;    CODE GENERATORS FOR STORING DOUBLE-WD VALS
	STDI=.			; (next 2 instrs)
	FRRFC,,FROMA2
	DMOVE	0,0
;
	STDIS=.		; KI10 WHEN VAL ALREADY IN REG
	FRRFC,,PARTMP
	DMOVEM	0,0
;
;



;
;DISPATCH TABLES FOR GENERATION OF INSTRUCTIONS FOR TRANSFERS OF CONTROL
;
;
;DISPATCH TABLE  FOR TRANSFER OF CONTROL WHEN A SPECIFIED
; VARIABLE HAS THE SPECIFIED VALUE TRUE OR FALSE
OPGVTS:		-2,,TSTMFL		;TRANSFER ON A MEMLOC FALSE
		-1,,TSTRFL		;TRANSFER ON A REG CONTENTS FALSE
		-2,,TSTMTR		;TRANSFER ON A MEMLOC TRUE
		-1,,TSTRTR		;TRANSFER ON A REG TRUE
;
;DISPATCH TABLE FOR TRANSFER TO THE LABEL INDICATED BY A1NODE IF
;  A SPECIFIED VARIABLE IS TRUE, TO THE LABEL INDICATED BY A2NODE IF
; IT IS FALSE
OPGALT:		-3,,ALTMEM		;TRANSFER DEPENDS ON A VAL IN MEM
		-2,,ALTREG		; ON A VAL IN A REG
;
;CODE GENERATORS FOR TRANSFERS OF CONTROL
;
	TSTMFL=.		;TRANSFER ON A MEMLOC FALSE
	FRPTN,,FROMPA		; (next 2 instrs)
	SKIPL	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	TSTRFL=.		;TRANSFER ON A REG CONTENTS FALSE
	FRRFC,,A1LAB
	JUMPGE	0,0
;
	TSTMTR=.		;TRANSFER ON A MEMLOC TRU
	FRPTN,,FROMPA		; (next 2 instrs)
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	TSTRTR=.		;TRANSFER ON A REG TRUE
	FRRFC,,A1LAB
	JUMPL	0,0
;
	ALTMEM=.		;TRANSFER TO A1LAB IF MEMLOC IS TRUE,
				; TO A2LAB IF FALSE (next 3 instrs)
	FRPTN,,FROMPA
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
	FRPTN,,A2LAB
	JRST	0,0
;
	ALTREG=.		;TRANSFER TO A1LAB IF REG IS TRUE, TO
				; A2LAB IF FALSE (next 2 instrs)
	FRRFC,,A1LAB
	JUMPL	0,0
;
	FRPTN,,A2LAB
	JRST	0,0

;**;[1026], DOSTI-1, DCE, 20-Mar-81
;**;[1206], Code generator for potential zero trip jump around loop.
DOZJMP:	-1,,STZJ	;[1206]

STZJ=.			;[1206]
	FRRFC,,A1LAB	;[1206]
	JUMPGE	0,0	;[1206]

DOSTI:	-1,,DOSTH

DOSTC:	-1,,STCDO	;TO STORE THE CT WHEN IT IS IN A REG
	-1,,STCDO1	;TO STORE THE CT WHEN IT IS IN THE LEFT HALF OF
			; A REG (IN AOBJN FORM)

STCDO=.
	FRRFC,,FROMA1
	MOVEM 0,0

STCDO1=.
	FRRFC,,FROMA1
	HLREM	0,0
;


OPGDOS:	-1,,DOENS


OPGDOE:	-1,,DOEN11
	ILG
	-1,,RDOEND
	-2,,CDOEND


DOEN11=.
	FRRFC,,A1LAB
	AOBJN 0,0

DOSTH=.
	FRRFC,,FROMA1
	HRRZM 0,0

RDOEND=.
	FRRFC,,A1LAB
	AOJL 0,0

DOENS=.
	FRRFC,,FROMA1
	AOS 0,0

CDOEND=.			; (next 2 instrs)
	FRPTN,,FROMA1
	AOSGE 0

	FRPTN,,A1LAB
	JRST 0





;
;
;TABLES FOR CODE GENERATION OF CODE FOR ARITHMETIC IF STATEMENTS
;
;
;DISPATCH TABLE FOR GENERATION OF CODE FOR ARITHMETIC-IF STMNTS IN WHICH
; THE VAL OF THE EXPRESSION MUST BE ENTIRELY COMPUTED AND THEN TESTED
;
;	IF NO 2 OF THE LABELS ARE EQUAL TO EACHOTHER
OPGAIF:	-4,,AI2NN	;NONE OF THE 3 LABELS IS THE NEXT STMNT, VAL IS NOT IN REG
	-3,,AI2NNR	;NONE OF THE LABELS IS NXT, VAL IS IN A REG
	-3,,AI2NL	;LESS LABEL IS ON NEXT STMNT (VAL NOT IN REG)
	-2,,AI2NLR	;LESS LABEL IS ON NEXT STMNT (VAL IS IN A REG)
	-3,,AI2NE	;EQL LABEL IS NEXT (VAL IS NOT IN A REG)
	-2,,AI2NER	;EQL LABEL IS NEXT (VAL IS IN A REG)
	-3,,AI2NG	;GTR LABEL IS NEXT (VAL IS NOT IN A REG)
	-2,,AI2NGR	;GTR LABEL IS NEXT (VAL IS IN A REG)
;
;	IF LESS LABEL IS EQUAL TO EQL LABEL
	-3,,I2LEN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2LENR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2LEL	;LESS (AND EQL) LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2LELR	;LESS (AND EQL) LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2LEL	;EQL (AND LESS) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LELR	;EQL (AND LESS) LABEL IS NEXT (VAL IS IN REG)
	-2,,I2LEG	;GTR LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LEGR	;GTR LABEL IS NEXT (VAL IS IN REG)
;
;	IF LESS LABEL IS EQUAL TO GTR LABEL
	-3,,I2LGN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2LGNR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2LGL	;LESS (AND GTR)  LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2LGLR	;LESS (AND GTR)  LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2LGE	;EQL  LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LGER	;EQL  LABEL IS NEXT (VAL IS IN REG)
	-2,,I2LGL	;GTR (AND LESS) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LGLR	;GTR (AND LESS) LABEL IS NEXT (VAL IS IN REG)
;
;	IF GTR LABEL IS EQUAL TO EQL LABEL
	-3,,I2GEN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2GENR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2GEL	;LESS  LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2GELR	;LESS  LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2GEG	;EQL (AND GTR)  LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2GEGR	;EQL (AND GTR)  LABEL IS NEXT (VAL IS IN REG)
	-2,,I2GEG	;GTR (AND EQL) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2GEGR	;GTR (AND EQL) LABEL IS NEXT (VAL IS IN REG)
;
;
;CODE GENERATORS FOR ARITHMETIC-IF STMNTS IN WHICH THE VAL OF THE EXPRESSION
; MUST BE COMPUTED AND TESTED
;
;	IF NO 2 OF THE LABELS ARE EQUAL TO EACHOTHER
;
	AI2NN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG (next 4 instrs)
	AI2NG=.		;GTR LABEL NXT, VAL NOT IN REG (NEXT 3 INSTRS ONLY)
	FRRFC,,FROMA1
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRRFC,,A2LAB
	JUMPE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	AI2NNR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN REG (next 3 instrs)
	AI2NGR=.	;GTR LABEL NEXT, VAL IN REG (USE NEXT 2 INSTRS ONLY)
	FRRFC,,A1LAB
	JUMPL	0,0
;
	FRRFC,,A2LAB
	JUMPE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	AI2NL=.		;LESS LABEL IS NEXT, VAL NOT IN REG
	FRRFC,,FROMA1	; (next 3 instrs)
	SKIPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NLR=.	;LESS LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A2LAB	; (next 2 instrs)
	JUMPE	0,0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NE=.		;EQL LABEL IS NEXT, VAL NOT IN REG
	FRRFC,,FROMA1	; (next 3 instrs)
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NER=.	;EQL LABEL IS NEXT VAL IS IN REG
	FRRFC,,A1LAB	; (next 2 instrs)
	JUMPL	0,0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
;	IF LESS AND EQL LABELS ARE EQUAL TO EACHOTHER
;
	I2LEN=.		;NONE OF THE LABELS IS NEXT , VAL NOT IN REG (next 3 instrs)
	I2LEG=.		;GTR LABEL NEXT, VAL NOT IN REG (USE THE NEXT 2 INSTRS ONLY)
	FRPTN,,FROMA1
	SKIPG	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LENR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN A REG (next 2 instrs)
	I2LEGR=.	;GTR LABEL NEXT, VAL IN REG (USE THE NEXT INSTR ONLY)
	FRRFC,,A1LAB
	JUMPLE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LEL=.		;LESS (AND EQL) LABEL IS NEXT, VAL NOT IN REG
	FRPTN,,FROMA1
	SKIPLE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LELR=.	;LESS (AND EQL) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
;	IF GTR LABEL IS EQUAL TO EQL LABEL
;
	I2GEN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG (next 3 instrs)
	I2GEL=.		;LESS LABEL IS NEXT, VAL NOT IN REG (USE NEXT 2 INSTS ONLY)
	FRPTN,,FROMA1
	SKIPL	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GENR=.	;NONE OF THE LABELS IS NEXT,VAL IS IN REG (next 2 instrs)
	I2GELR=.	;LESS LABEL IS NEXT, VAL IS IN REG (USE NEXT INSTR ONLY)
	FRRFC,,A3LAB
	JUMPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GEG=.		;GTR (AND EQL) LABEL IS NEXT (next 2 instrs)
	FRPTN,,FROMA1
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GEGR=.	;GTR (AND EQL) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A1LAB
	JUMPL	0,0
;
;
;	IF LESS LABEL IS EQUAL TO GTR LABEL
;
	I2LGN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG (next 3 instrs)
	I2LGE=.		;EQL LABEL NEXT, VAL NOT IN REG (USE NEXT 2 INSTRS ONLY)
	FRPTN,,FROMA1
	SKIPE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGNR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN REG (next 2 instrs)
	I2LGER=.	;EQL LABEL NEXT, VAL IN REG (USE NEXT INSTR ONLY)
	FRRFC,,A1LAB
	JUMPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGL=.		;LESS (AND GTR) LABEL IS NEXT, VAL NOT IN REG
	FRPTN,,FROMA1	; (next 2 instrs)
	SKIPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGLR=.	;LESS (AND GTR) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A2LAB
	JUMPE	0,0
;

;
;FOR COMPUTED GOTO - TO TEST THE RANGE OF THE VAL COMPUTED
; ALWAYS USE REGISTER 1
OPGCGO:	-3,,CGOTS
;
	CGOTS=.		; (next 3 instrs)
	FRPTN,,FROMA1
	SKIPLE	01,0
;
	FRPTN,,FROMC1
	CAILE	01,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
;  FOR COMPUTED GOTO WHEN THE VAR IS IN THE RH OF  A REG CONTAINING
;  THE DO LOOP CONTROL
OPGCGI:	-4,,CGOITS
;
	CGOITS=.		; (next 4 instrs)
	FRPTN,,A1CNST		;GENERATE "MOVEI 1,0(LOOPREG)
	MOVEI	1,0
;
	FRPTN,,A1LAB
	JUMPLE	1,0
;
	FRPTN,,FROMC1
	CAILE	1,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
;


;FOR PROLOGUE , EPILOGUE AND SUBROUTINE RETURN

	;TO SAVE THE EPILOGUE ADDRESS

OPGIIN:	-1,,MOVIIA

OPGMVL:	-2,,MVLAB

	;MOVE INDIRECT THROUGH 16

	;FOR THE KI 10 

OPINDI:	-1,,GAI
	-1,,GAI
OPIND2:	-1,,GA2KII
	-1,,GA2KII

	;MAKE VALUES TO ADD FOR MULTIPLE RETURNS

DVALU:	-1,,DATER

	;SIMPLE RETURN

POPRET:	-1,,POPIT

;[2313]	Comment out since CGRETURN no longer uses this pattern
;
;	;MOVE THE RETURN I VALUE TO AC 1
;
;MOVRET:	-1,,MOVRTN

	;STORE INDIRECT THROUGH 16


	;FOR THE KI 10

OPINSI:	-1,,STI
	-1,,ST2II


	;FOR A RETURN I

CRETN:	-5,,LGRET

MOVIIA=.
	FRRFC,,FROMC1
	XMOVEI 0,0(16)		;[1401]

MVLAB=.			; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 1,0		;[1401] Get the right epilogue address

	FRPTN,,FROMA1
	MOVEM 1,0

GAI=.
	FRRFC,,FROMC1
	MOVE 0,0(16)


GA2KII=.
	FRRFC,,FROMC1
	DMOVE 0,(16)

DATER=.
	FRPTN,,FROMC1
	0

STI=.
	FRRFC,,FROMC1
	MOVEM 0,0(16)


ST2II=.
	FRRFC,,FROMC1
	DMOVEM 0,(16)


LGRET=.			; (next 5 instrs)
	FRPTN,,A1LAB
	JUMPLE 1,0

	FRPTN,,FROMC1
	CAILE 1,0

	FRPTN,,A1LAB
	JRST

	FRPTN,,A2LAB
	XMOVEI 1,@0(1)		;[1401] Get proper return address

	FRPTN,,FRPTN
	MOVEM 1,0(17)		;[1401] and save it for the return

POPIT=.
	FRPTN,,FRPTN

	POPJ 17,0

;[2313]	Comment out since CGRETURN no longer uses this pattern
;
;MOVRTN=.
;	FRPTN,,FROMC1
;	MOVE 1,0

	;FOR SUBROUTINE OR FUNCTION CALL


CALLER:	-2,,CALLIT
	-1,,CNOARG

OPGSFN:	-2,,CALLAB	;FOR STATEMENT FUNCTION REF

CALLIT=.		; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

CNOARG=.
	FRPTN,,FROMA1
	PUSHJ 17,0

CALLAB=.		; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,A2LAB
	PUSHJ 17,0




;	Dispatch entries for FOROTS calls

;OPGADJ:-2,,ADJOP	;[1401] This pattern doesn't get used anymore
OPGCHM:	-2,,CHMRKC	;[1533] Call CHMRK.
OPGCHU:	-2,,CHUNWC	;[1533] Call CHUNW.
OPGCLO:	-2,,CLOC
OPGDEC:	-2,,DECC
OPGDEL: -2,,DELETC	;[4502] 
OPGENC:	-2,,ENCC
OPGEXI:	-2,,EXITC
OPGFIN:	-1,,FINC
OPGFND:	-2,,FINDC
OPGIFI:	-2,,IFIC	;[1471] Internal File Input (READ)
OPGIFO:	-2,,IFOC	;[1471] Internal File Output (WRITE)
OPGIN:	-2,,INC
OPGINF:	-2,,INQFC	;[2201] INQUIRE by file
OPGINU:	-2,,INQUC	;[2201] INQUIRE by unit
OPGIOL:	-2,,IOLSTC
OPGMTO:	-2,,MTOPC
OPGNLI:	-2,,NLIC
OPGNLO:	-2,,NLOC
OPGOPE:	-2,,OPENC
OPGOUT:	-2,,OUTC
OPGPAU:	-2,,PAUSEC
OPGRES:	-3,,RESETC
OPGRWF: -2,,REWRFC	;[4503]
OPGRWU: -2,,REWRUC	;[4503]
OPGRTB:	-2,,RTBC
OPGSTP:	-2,,STOPC
OPGULC: -2,,UNLOCC	;[4504]
OPGWTB:	-2,,WTBC

;   Code generators for FOROTS calls:

;[1401] Comment out, since they don't do anything
;ADJOP=.			; (next 2 instrs)
;	FRPTN,,A1LAB
;	MOVEI 16,0
;
;	FRPTN,,WD1IMF
;	PUSHJ 17,ADJT
;

CHMRKC=.			;[1533] (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,CHMRKT

CHUNWC=.			;[1533] (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,CHUNWT

CLOC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,CLOST

DECC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,DECT

DELETC=.			; (next 2 instrs) [4502]
	FRPTN,,A1LAB		;[4502]
	XMOVEI 16,0		;[4502]
				;[4502]
	FRPTN,,WD1IMF		;[4502]
	PUSHJ 17,DELETT		;[4502]

ENCC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,ENCT

EXITC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI	16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ	17,EXITT

FINC=.				; next instruction
	FRPTN,,WD1IMF
	PUSHJ 17,FINT

FINDC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,FINDT

IFIC=.				; (next 2 instrs)
	FRPTN,,A1LAB		;[1471]
	XMOVEI 16,0		;[1471]

	FRPTN,,WD1IMF		;[1471]
	PUSHJ 17,IFIT		;[1471]

IFOC=.				; (next 2 instrs)
	FRPTN,,A1LAB		;[1471]
	XMOVEI 16,0		;[1471]

	FRPTN,,WD1IMF		;[1471]
	PUSHJ 17,IFOT		;[1471]

INC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,INT

INQFC=.				;[2201] (next 2 instrs)
	FRPTN,,A1LAB		;[2201]
	XMOVEI 16,0		;[2201]

	FRPTN,,WD1IMF		;[2201]
	PUSHJ 17,INQFT		;[2201] INQUIRE by file

INQUC=.				;[2201] (next 2 instrs)
	FRPTN,,A1LAB		;[2201]
	XMOVEI 16,0		;[2201]

	FRPTN,,WD1IMF		;[2201]
	PUSHJ 17,INQUT		;[2201] INQUIRE by unit

IOLSTC=.			; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI	16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ	17,IOLSTT

MTOPC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,MTOPT

NLIC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,NLIT

NLOC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,NLOT

OPENC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,OPENT

OUTC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,OUTT

PAUSEC=.			; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI	16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ	17,PAUSET

;TO GENERATE CODE FOR THE INITIAL CALL TO RESET.
;[AHM] OPGRES:	-5,,RESETC

RESETC=.			; (next 3 instrs)
	FRPTN,,FRPTN
	JFCL	0

	FRPTN,,WD1IMF
	JSP	16,RESETT

	FRPTN,,FRPTN
	0

REWRFC=.			; (next 2 instrs) [4503]
	FRPTN,,A1LAB		;[4503]
	XMOVEI 16,0		;[4503]
				;[4503]
	FRPTN,,WD1IMF		;[4503]
	PUSHJ 17,REWRIF		;[4503]

REWRUC=.			; (next 2 instrs) [4503]
	FRPTN,,A1LAB		;[4503]
	XMOVEI 16,0		;[4503]
				;[4503]
	FRPTN,,WD1IMF		;[4503]
	PUSHJ 17,REWRIU		;[4503]

COMMENT |
	FRPTN,,FRPTN		;[AHM] No relocation
	SETZM	42		;[AHM] Clear the ARRAYREF counter
				;[AHM]
	FRPTN,,FRPTN		;[AHM] No relocation
	SETZM	136		;[AHM] Clear the COMMON ref counter
				;[AHM]
|

RTBC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,RTBT

STOPC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI	16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ	17,STOPT

UNLOCC=.			; (next 2 instrs) [4504]
	FRPTN,,A1LAB		;[4504]
	XMOVEI 16,0		;[4504]
				;[4504]
	FRPTN,,WD1IMF		;[4504]
	PUSHJ 17,UNLOCT		;[4504]

WTBC=.				; (next 2 instrs)
	FRPTN,,A1LAB
	XMOVEI 16,0		;[1401]

	FRPTN,,WD1IMF
	PUSHJ 17,WTBT
	
;	Table of SIXBIT names for FOROTS calls:

ADJT:	SIXBIT	"ADJ."
CHMRKT:	SIXBIT	"CHMRK."
CHUNWT:	SIXBIT	"CHUNW."
CLOST:	SIXBIT	"CLOSE."
DECT:	SIXBIT	"DEC."
DELETT: SIXBIT  "DELTR."	;[4543]
ENCT:	SIXBIT	"ENC."
EXITT:	SIXBIT	"EXIT."
FINT:	SIXBIT	"FIN."
FINDT:	SIXBIT	"FIND."
IFIT:	SIXBIT	"IFI."		;[1471]
IFOT:	SIXBIT	"IFO."		;[1471]
INT:	SIXBIT	"IN."
INQFT:	SIXBIT	"INQF."		;[2201] INQUIRE by file
INQUT:	SIXBIT	"INQU."		;[2201] INQUIRE by unit
IOLSTT:	SIXBIT	"IOLST."
MTOPT:	SIXBIT	"MTOP."
NLIT:	SIXBIT	"NLI."
NLOT:	SIXBIT	"NLO."
OPENT:	SIXBIT	"OPEN."
OUTT:	SIXBIT	"OUT."
PAUSET:	SIXBIT	"PAUS."
RESETT:	SIXBIT	"RESET."
REWRIF: SIXBIT  "REWRF."	;[4503]
REWRIU: SIXBIT  "REWRU."	;[4503]
RTBT:	SIXBIT	"RTB."
STOPT:	SIXBIT	"STOP."
UNLOCT:	SIXBIT  "UNLOC."	;[4504]
WTBT:	SIXBIT	"WTB."

;
;TO GENERATE PUSH AND POP REGISTER SAVE AND RESTORES
;FOR STATEMENT FUNCTIONS
OPGPPR:	-1,,POPRG

	POPRG=.
	FRPTN,,FRRFC
	POP 17,0

OPGPHR:	-1,,PSHR

	PSHR=.
	FRPTN,,FRRFC
	PUSH 17,0


; To generate character array subscript

OPCHIX:	-4,,CHRIX

	CHRIX=.			;(next 4 instructions)
	FRRFC,,FROMA1
	ADJBP 0,0

	FRRFC,,FROMA2
	MOVEM 0,0

	FRRFC,,FROMA1
	MOVE 0,1

	FRRFC,,FROMA2
	MOVEM 0,1


; For substrings

OPGST1:	-1,,ST1			;STORE INTO LENGTH WORD OF DESCRIPTOR

	ST1=.			; (next 1 instruction)
	FRRFC,,FROMPA
	MOVEM 0,1


OPSSEP:	-2,,SSEP		;ADJBP/MOVEM, EPILOG OF SUBSTRING CALC

	SSEP=.			; (next 2 instructions)
	FRRFC,,FROMA1
	ADJBP 0,0

	FRRFC,,FROMPA
	MOVEM 0,0


OPADJB:	-1,,ADJB		;[4517] ADJBP for substring/ char array

	ADJB=.
	FRRFC,,FROMA1
	ADJBP 0,0


	END
 