
	
!COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972, 1987
!ALL RIGHTS RESERVED.
!
!THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
!ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
!INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
!COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
!OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
!TRANSFERRED.
!
!THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
!AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
!CORPORATION.
!
!DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
!SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

!AUTHOR:	*/TFV/CKS/CDM/RVM/AHM/AlB/TJK/MEM

GLOBAL BIND FIRSTV = #11^24 + 0^18 + #4527;	! Version Date:	1-Jan-86

%(

***** Begin Revision History *****

116	-----	-----	DEFINE "BOUNDS" FLAG IN FLGREG; REMOVE DEFINITION
			OF "ISPROT" FLAG FROM SYMBOL TABLE
117	-----	-----	DEFINE "IDLIBFNFLG" IN SYMBOL TABLE ENTRIES
			FOR FUNCTION NAMES
121	-----	-----	CHANGE POOLSIZE TO 600

122	-----	-----	ADD THE INEXTSGN BIT TO SYMBOL TABLE

123	-----	-----	CHANGE EQUIVALENCE LIST ENTRY SIZE TO 4, SO
			THAT EQLLIST CAN BE A FULL WORD AND NOT LOSE
			THE NUMBER OF SUBSCRIPTS IN THE LEFT HALF

124	-----	-----	ADD THE PARAMT BIT TO THE SYMBOL TABLE AND
			REMOVE THE INUSE BIT.

			REMOVE SFDUMMY AND INGLOBAL BITS.

			DEFINE THE IDPARAVAL FIELD TO CONTAIN THE
			CONSTANT TABLE POINTER FOR PARAMETER
			VARIABLES.

			ADD THE EQVISN FIELD TO THE EQUIVALENCE TABLE
			ENTRY TO HOLD THE LINE NUMBER SO THAT RELEVENT
			ERROR MESSAGES CAN BE PRINTED OUT

			ADD THE IDENTLNK FIELD TO THE SYMBOL
			TABLE ENTRY - LINKS ENTRY POINTS

125	-----	-----	PUT TOLENTRY BIT IN TO DEFINE .O VARIABLES
			THAT MOVE OUT OF THE LOOP

126	-----	-----	EXPAND THE SIZE OF THE EQUIVALENCE TABLE NODE
			SO THAT ISN CAN BE INCLUDED AND DISPLACEMENT
			CAN STILL BE A FULL WORD SINCE IT GOES NEGATIVE

***** Begin Version 5A *****

127	544	10290	FIND STATEMENT NEEDS MORE ROOM FOR ERR AND END
130	571	22378	ADD IDUSECNT DEFINITION, (DCE)

***** Begin Version 5B *****

131	636	23066	CHANGE SNDEFINED FROM A FIELD TO A FLAG BIT, (JNG)
132	674	11803	MOVE DOSTAK TO MAKE IT BIGGER, ALSO GET
			RID OF EXPTBL WHICH WENT AWAY LONG AGO., (DCE)
133	716	26409	ADD LABEL FLAG "SNRFS" - RETURN FROM SUBROUTINE, (DCE)

***** Begin Version 6 *****

134	760	TFV	1-Oct-79	------
	Add IOSTAT to I/O statement blocks and adjust statement sizes

135	761	TFV	1-Mar-80	-----
	Define GFLOAT as the /GFLOATING bit in FLAGS2

136	767	DCE	20-May-80	-----
	Move GFL flag into F2; redefine GFLOAT appropriately

137	1033	DCE	4-Dec-80	-----
	Increase size of DO node to accomodate DOZTRLABEL

***** Begin Version 6A *****

154	1150	DCE	16-Feb-82	20-17292
	Add SNASSIGNED field to label table to indicate that the label
	has occurred in an ASSIGN statement.

***** Begin Version 7 *****

140	1212	TFV	29-Apr-81	------
	Add compile time data structures for CHARACTER data.
	Add symbol table fields used for CHARACTER data.
	IDATTRIBUT is full so character*(*) is represented by a length of -1
	Add character count field for CHARACTER constants. Change offsets
	for accessing 1st, 2nd, 3rd words of literal or CHARACTER constant.
	First word of literal or CHARACTER constant is now word 4 of entry.
	LITERALENTRY has become HOLLENTRY.

141	1213	TFV	20-May-81
	Add lenstar  for  character*(*)  data. Add  CW6,  CW7,  and  CW8
	definitions.   Note  IDATTRIBUT(PARAMT)  and  IDCHLEN  are  also
	declared in LEXICA.BLI.  LEXICA will not compile if FIRST.BLI is
	required. Beware of skews.

142	1221	CKS	4-Jun-81
	Add LITC1, byte pointer to first char of LIT1.  Used to ILDB
	through chars of literal table entry.

143	1222	CKS	8-Jun-81
	Move CONST1 and CONST2 down one word so that LIT1=CONST1.  Much
	depends on LIT1=CONST1.

144	----	SRM	16-June-81
	Added comments giving octal for statement ID's

145	1227     CKS   22-Jun-81
	Add CONST2L to refer to LH of an integer constant

146	1245	TFV	3-Aug-81	------
	Move IDUSED, IDCHOS, IDDEF,  IDUSECNT from word 2  to word 8  of
	symbol table entries.  Word 2 (IDTARGET) becomes a full word for
	extended addressing.  Also define new flag bits for IDPSECT  and
	IDPSCHARS for extended addressing support.

147	1262	CKS	21-Sep-81
	New stuff for character COMMON and EQUIVALENCE.  Add EQLLOWER,
	EQLSSTRING, EQVALIGN.  Increase EQLSIZ and COMSIZ to 5.  Enlarge
	COMSIZE, EQVLIMIT, EQVADDR, EQLDISPL, IDADDR to be full words.

148	1402	CKS	22-Oct-81
	Add SNDECL, statement number is on a declaration statement and may
	not be used for anything.

149	1406	TFV	27-Oct-81	------
	Add IDGENLENFLG to IDFLG  word of symbol  table entries.  It  is
	used for .Dnnnn compile-time-constant character descriptors.  If
	it is one then both the  byte pointer and the length are  output
	to the .REL file.  Add  IDBPOFFSET to symbol table entries.   It
	is used to generate the IDCHBP  field for a .Dnnnn table  entry.
	The .Dnnnn IDADDR field points to a subnode containing either  a
	.Qnnnn variable or a scalar or array entry.  The IDCHBP field of
	the subnode  is ADJBP'd  by IDBPOFFSET  to generate  the  IDCHBP
	field for the .Dnnnn variable. The IDBPOFFSET field shares space
	with the IDENTLNK and IDCOLINK field since .Dnnnn variables  are
	neither entry points nor in common.

150	1466	CDM	1-Feb-82
	Addition of IDSFNODE, ENTLINK for argument checking processing.

151	1467	CDM	1-Feb-82
	Addition  of   IDSAVVARRIABLE,  IDSAVCOMMON   for  SAVE   statement
	processing.

152	1476	RVM	8-Feb-82
	Change the name of INEXTSGN to USERFUNCTION.

153	1501	RVM	16-Feb-82
	Add some comments on the new meanings of INEXTERN and USERFUNCTION.

1505	AHM	13-Mar-82
	Add caveats about uses of PSDATA and IDPSECT in LEXICA and make
	IDUSECNT a half word so that there is room for psect indices, etc.

1512	AHM	24-Mar-82
	Define PSABS  symbol  for calls  to  the ZSYMBOL  routine  for
	random symbols that don't get relocated.

1526	AHM	6-Apr-82
	Add warning about reordering  the PS???? symbols and  changing
	the position of IDPSCHARS.  Also,  add SNPSECT to label  table
	entries for ASSIGNed FORMAT labels.

1530	TFV	4-May-82
	Add fields IOMARK  (CW8R) and  IOLMARK (CW9L)  to I/O  statement
	nodes.  They are pointers to  the argument list for CHMRK.   and
	CHUNW.  calls.   IOLMARK  is non-zero  if  the IOLST.  call  has
	CONCTV nodes  as  arguments.   IOMARK is  non-zero  if  the  FMT
	specifier is  a  CONCTV  node  or  if  the  iolist  has  dynamic
	concatenations and END,  ERR, or  IOSTAT is  specified.  Add  an
	extra word to iolist nodes (DCSIZ, SLCSIZ, IOLCSIZ, ELCSIZ,  and
	IOLTAB) for the fields IOLMARK and IOLSTATEMENT.

1551	AHM	3-Jun-82
	Define a new  psect index called  PSOOPS with the  value 0  so
	that the  code generator  can detect  STEs that  have not  had
	their psect index set explicitly.

1567	CDM	24-Jun-82
	Add  IDFNFOLD  and  IDILFOPRCLS  for  symbol  table  and  inline
	function processing.

1573	CKS	1-Jul-82
	Add SNWHILE bit.

***** End V7 Development *****

***** End Revision History *****

***** Begin Version 10 *****

2200	TFV	11-Mar-83
	Add INQUID, INQUSIZ, INQUDATA, and IOFILE for the INQUIRE statement.

2202	CDM	7-Apr-83
	Widen  IDDATVAL, DATARPT  to a  full word,  comment out  COMADDR
	which the compiler does not use.

2205	CDM	21-Jun-83
	Added symbols for EFIW table processing.
	Removed offensive BPR and BASEPOINT macros defined to the global
	symbol BASEPTR.  All references to  the same location should  be
	made the same way!!

2207	CDM	21-Jul-83
	Add comments to  Common/Equivalence code.   Moved macros  MERIT,
	USRARGUSE, LIBARGUSE, ORFIXFLG, OMOVDCNS  from OPTMAC to  FIRST.
	They overlap IDADDR for code /OPT.  Moved IDDOTO which  overlaps
	IDSYMBOL.  It is  in poor taste  to hide overlaps  of fields  in
	another module!!

2230	CDM	1-Nov-83
	Move DO  node flags  from  TABLES to  FIRST where  they  belong.
	Remove DOFLGAUX (never used).   Add comments for statement  node
	flags where appropriate so  that the flags' existences  (defined
	in TABLES) is known.

2231	AHM	6-Nov-83
	Undo part of edit 2230.  Put DOFLGAUX field back in to DO
	statement nodes.  I forgot that it was used in DUMP.

2234	AlB	9-Nov-83
	Add fields to Common Block and Equivalence Group tables
	to enable them to handle Psects for extended addressing

2235	AlB	11-Nov-83
	Re-arrange Edit 2234 slightly. Cosmetic change.

2265	TFV	12-Jan-84
	Increase POOLSIZE to 6000 words so we can compile programs  with
	large blocks of  comment lines.  The  standard allows  unlimited
	numbers of comment lines between initial and continuation lines.

2302	TJK	2-Feb-84
	Add new flag IDCLOBB to the IDFNATTRIB field of a symbol table
	entry.  This flag is set for certain library routines  (called
	as subroutines).  It indicates that  ACs are not preserved  by
	the call.

	Have CHASGN generate calls to  CASNM.  instead of CHASN.   for
	single-source character  assignments,  and CNCAM.  instead  of
	CONCA. for character concatenation assignments.  Also have  it
	set IDCLOBB for these routines, which don't preserve ACs.

	Replace a check for CONCA. with a check for CNCAM. in  SKCALL.

	Have ALCCALL mark registers 2-15 (octal) as being clobbered if
	IDCLOBB is set.

2337	CDM	8-Apr-84
	Output EFIW references /LISTING/MACRO.

2343	RVM	18-Apr-84
	Add field definitions for the table of COMMON blocks named in
	an /EXTEND switch.

2352	CDM	1-May-84
	Make intrinsic functions  IAND, IOR, and  IEOR inline functions.   They
	are converted to  Fortran .AND.,  .OR., AND .XOR.  within the  skeleton
	optimizer.  
	Add IDILFOPERSP.

2427	AlB	17-Jul-84
	Redefine the STE fields MERIT, ORFIXFLG, OMOVDCNS, LIBARGUSE and
	USRARGUSE such that they are in word 8 instead of word 2.
	Remove STE fields IDCHOS and IDDEF, which are not now used.

	The intent of the move is to get those fields out of the left
	half of IDADDR;  the optimizer was zapping that left half and thus
	destroying the global address.

	REGSTUFF was defined in two different ways (by CLEANUP and by
	DFCLEANUP).  The definitions were taken out of those routines
	and placed here as IDCLEANA and IDCLEANB.


2443	RVM	5-Aug-84
	Define the symbolic name MAXSYM for the number of characters
	that LINK will allow in a PSECT name.   Define SYMLEN as the
	number of words needed to hold MAXSYM SIXBIT characters.

2464	AHM	9-Oct-84
	Define EFFIXEDUP as the left half of EFEXTERN.  Non-zero
	whenever the EFIW is to be fixed up by a symbol.

2473	CDM	29-Oct-84
	Add IMPLICIT NONE for the Military Standard MIL-STD-1753.

2477	AlB	16-Nov-84
	Change the source POOLSIZE to be 2000 words (10000 characters). This
	was done to decrease compilation times.

2507	CDM	20-Dec-84
	Add enhancement for IMPLICIT NONE (edit 2473) after code inpsection.
	Check more cases, and add a symbol table walk at the back 
	end to catch unreferenced variables.
	Add IDDOT, IDDOTF, IDDOTR, IDSUBROUTINE.

***** End V10 Development *****

2532	CDM	9-May-85
	Only put out type checking information for known (called)
	function names.  Subroutine and ambiguous external names
	should not have type checking information output.

***** End Revision History *****

***** Begin Version 11 *****

4500	MEM	22-Jan-85
	Add bind for IOKEY.
	
4501	MEM	22-Jan-85
	Add binds for IOSIZ, CW10R, CW10L, IOKEYID, and IOKEYREL.

4502	MEM	22-Jan-85
	Add binds for DELEID, DELESIZ, DELEDATA.

4503	MEM	22-Jan-85
	Add binds for REWRID, REWRSIZ, and REWRDATA.

4504	MEM	22-Jan-85
	Add binds for UNLCKID, UNLCKSIZ, and UNLCKDATA.

4516	CDM	2-Oct-85
	Phase I.I for VMS long symbols.  Pass Sixbit to all error message
	routines, do not pass addresses of Sixbit anymore.  In later edits
	this will pass [length,,pointer to symbol] instead of a pointer to
	this to the error message routines.
	Delete undefined error message in macro ISNOTVAR.

4517	MEM	17-Sep-85
	Add macro for IDINCR.

4520	MEM	17-Sep-85
	Add DLINK, DNSIZ, DNTAB, DNTSIZ and external DNTBL[DNTSIZ] for hashing
	.Dnnnns

4527	CDM	1-Jan-86
	VMS Long symbols phase II.  Convert all internal symbols from
	one word of Sixbit to [length,,pointer].

ENDV11

)%

!FIRST must be compiled in the order ...
!	FIRST
!	TABLES
!
!To save space and increase compilation speed, all macro definitions
!of the form "name = number$" have been changed to BIND's.


	REQUIRE IOFLG.BLI;

	REGISTER C = 3, R2 = 2, R1 = 1;
	BIND CHR = C;
!

	%(***DEFINE THE FLAGS USED BY PHASE 2 SKEL AND PHASE 3***)%
MACRO	BTTMSTFNFLG=FLGREG<BTTMSTFL>$,	!SET FOR BOTTOMOST ROUTINES


	LIBARITHFLG=FLGREG<LIBARITH>$,	! SET IN "COMPLEXITY" IF 
					! ROUTINE INCLUDES ANY ARITHOPS
					! THAT REQUIRE USE OF LIBRARY
					! FNS(EG COMPLEX MUL AND DIV)
	PEEPFLG=FLGREG<PEEPFL>$;	!SET FOR PEEPHOLE OPTIMIZER
					! SHOULD BE USED
		
	BIND DEGUG = 0;	!FOR DEBUG OPTIONS
!
	MACRO XTRAC = IF DEGUG THEN IF .DTRACE NEQ 0 THEN XCALL()$;
	BIND OPTIMIZER = 0;
	MACHOP JRST = #254,LSHC = #246,ADD=#270;
	MACHOP TTCALL = #051, CALLI = #047;
	MACHOP ASHC = #244, ADDB = #273, TLZE = #623, AOS = #350,MOVEI = #201;
!
	MACRO SIGCHAR = (DO CHAR() WHILE .C  LEQ " "; .C)$;
	MACRO OUTCHR(X) = TTCALL(1,X)$,
		INCHWL(X) = TTCALL(4,X)$,
		OUTSTR(X) = TTCALL(3,X)$;
!THE MACROS BELOW IMPLEMENT THE FOLLOWING ALGORITHM WITH 2 INSTRUCTIONS
!
!	((VREG_(.C - START OF RANGE) MOD 1^18) MOD 1^36) LEQ (END OF RANGE - START OF RANGE)
!
MACRO
	ALPHA(X) = MOVEI(VREG,-"A",X) LEQ ("Z"-"A")$,
	DIGIT(X) = MOVEI(VREG,-"0",X) LEQ 9$,
	LCALPHA(X) = MOVEI(VREG,-("A"+" "),X) LEQ ("Z"-"A")$;
!
!	THE MODULE GLOBAL CONTAINS ALL THE ARRAY DECLARATIONS AND TABLE (PLIT)
!	DEFINITIONS THAT WILL BE USED BY SUBSEQUENT ROUTINES THAT ARE
!	IN SEPARATE FILES. THE PURPOSE OF THAT FILE IS TO PROVIDE ONE 
!	PLACE WHERE ALL DECLARATIONS THAT ARE GLOBAL TO THE SCOPE OF
!	THE ENTIRE COMPILER CAN BE FOUND EASILY.
!
!
!	THE FOLLOWING MACROS AND DECLARATIONS PERTAIN TO THE TABLE MANAGEMENT
!	ROUTINE TBLSEARCH() AND ALSO THE CORE MANAGEMENT ROUTINE CORMAN().
!
!	THE FOLLOWING MACROS ARE USED TO DEFINE THE PARAMETERS FOR THE
!	STRUCTURE DECLARATIONS USED TO DEFINE THE ACCESSING ALGOITHMS
!	FOR THE DYNAMIC TABLES USED BY THE FORTRAN COMPILER.
!	THESE MACROS DEFINE FIELDS AND SUB-FIELDS IN TABLE ENTRIES.
!	FIELDS MAY BE A FULL WORD OR HALF WORD OR LESS.
!
	MACRO   FULL = 0,36$;
	MACRO	RIGHT = 0,18$;
	MACRO	LEFT = 18,18$;
	MACRO
		CLINK	= 0,0,RIGHT$,	! Current link field
		NLINK	= 1,0,RIGHT$,	! New (next) link field
%4501%		CW0	= 0,0,FULL$,	! Word 0
		CW0L	= 0,0,LEFT$,	! Left half link word
		CW0R	= 0,0,RIGHT$,	! Right half link word
		CW1	= 0,1,FULL$,	! Current first word 
		CW1L	= 0,1,LEFT$,	! Left half word 1
		CW1R	= 0,1,RIGHT$,	! Right half word 1
		CW2	= 0,2,FULL$,	! Second word
		CW2L	= 0,2,LEFT$,
		CW2R	= 0,2,RIGHT$,
		CW3	= 0,3,FULL$,	! Third word
		CW3L	= 0,3,LEFT$,
		CW3R	= 0,3,RIGHT$,
		CW4	= 0,4,FULL$,	! Fourth word
		CW4L	= 0,4,LEFT$,
		CW4R	= 0,4,RIGHT$,
		CW5	= 0,5,FULL$,	! Fifth word
		CW5L	= 0,5,LEFT$,
		CW5R	= 0,5,RIGHT$,
%1213%		CW6	= 0,6,FULL$,	! Sixth word
		CW6L	= 0,6,LEFT$,
		CW6R	= 0,6,RIGHT$,
%1213%		CW7	= 0,7,FULL$,	! Seventh word
		CW7L	= 0,7,LEFT$,
		CW7R	= 0,7,RIGHT$,
%1213%		CW8	= 0,8,FULL$,	! Eighth word
%760%		CW8L	= 0,8,LEFT$,
%760%		CW8R	= 0,8,RIGHT$,
%1530%		CW9	= 0,9,FULL$,	! Ninth word
%1530%		CW9L	= 0,9,LEFT$,
%1530%		CW9R	= 0,9,RIGHT$,
%4501%		CW10	= 0,10,FULL$,	! Tenth word
%4501%		CW10L   = 0,10,LEFT$,	
%4501%		CW10R   = 0,10,RIGHT$;

!***********************************************************************
! The structure access for a symbol table entry
!***********************************************************************

	! The following macros define the id attributes of an identifier
	! IDATTRIBUT(x), where x is one of the following:

	![1213]	IDATTRIBUT(PARAMT) is also declared in LEXICA.BLI. Beware
	![1213]	of skews.

	! If any are moved or  changed please check routines NAMDEF  and
	! REFERENCE.

MACRO	ALLOFTHEM=	18,18$,
	DEFIND	=	#576400$,! *        !101 111 110 100 000 000
				 !SEE CORRESPONDING DEFINITIONS BELOW
	NOTFUNC	=	#437400$,!    @     !100 011 111 100 000 000
	NOTVAR	=	#500000$,!       +  !101 000 000 000 000 000

	NAMNAM  =	35,1$,	! *  @  +  !NAMELIST NAME
	COMBL	=	34,1$,	! *  @  +  !COMMON BLOCK NAME
	SFN	=	33,1$,	! *     +  !STATEMENT FUNCTION NAME
	PARAMT	=	32,1$,	! *        !THIS VARIABLE IS A PARAMETER
	STORD	=	31,1$,	! *  @     !VARIABLE IS STORED INTO
	INASSI	=	30,1$,	! *  @     !IN ASSIGN STATMENT
	INNAM	=	29,1$,	! *  @     !IN NAMELIST
	FENTRYNAME=	28,1$,	! *  @     !NAME IS AN ENTRY INTO A FUNCTION OR SUBROUTINE
	INEQV	=	27,1$,	!    @     !IN EQUIVALENCE
	INCOM	=	26,1$,	!    @     !IN COMMON BLOCK
	TOLENTRY =	25, 1$,	!.O VAR IS ASSIGNED
				!OUTSIDE THE LOOP OF ITS
				!FIRST USE
	INDATA	=	24,1$,	!          !IN DATA STATEMENT
	INEXTERN =	23,1$,	! [1501] In an EXTERNAL or INTRINSIC
				! statement.  This bit allows the name
				! a routine to be passed as an argument
				! It is lit for both INTRINSIC and user
				! functions.  It is also set in the STE
				! for the dotted name of an intrinsic
				! function if it is set in the STE of
				! undotted name.
	DUMMY =		22,1$,	!	    !DUMMY PARAMETER
	!(THE BIT 21 FROM RIGHT IS USED FOR "RGCANDFLG")
	NOALLOC =	20,1$,	!DO NOT ALLOCATE  THIS VARIABLE
	INTYPE =	19,1$,	!Identifier declared in type declaration
%1476%	USERFUNCTION =	18,1$,	! Either this name has always been a
				! user function or it is an intrinsic
				! function made into a user function.
	ISDEFIND(B)=(.B[IDATTRIBUT(ALLOFTHEM)] AND DEFIND) NEQ 0$,
	ISNOTFUNC(B)=(.B[IDATTRIBUT(ALLOFTHEM)] AND NOTFUNC) NEQ 0$,
	ISNOTVAR(B)=IF (.B[IDATTRIBUT(ALLOFTHEM)] AND NOTVAR) NEQ 0
			THEN
			BEGIN
%4516%				EXTERNAL E4;
%4516%				FATLEX(.B[IDSYMBOL],SFPLIT<0,0>,E4<0,0>)
			END$;


MACRO	IDLINK	 = CLINK$,
	IDOPTIM	= CW0L$,	!FOR OPTIMIZATION
	IDDIM	= CW0L$,	!PTR TO DIMENSIONS
	IDOPER	= CW1R$,	!OPERATOR FIELD

	![1213]	IDATTRIBUT(PARAMT) is also declared in LEXICA.BLI. Beware
	![1213]	of skews.

	IDATTRIBUT(X) = 0,1,X$,
	RGCANDFLG=0,1,21,1$,	!FLAG INDICATING THAT THIS VAR COULD BE LEFT
				! IN A REG.  THIS IS USED ON 1ST PASS OF BB
				! REG ALLOC
	VARINREGFLG=RGCANDFLG$,	!FLAG INDICATING THAT THIS VAR WAS LEFT IN A
				! REG
				! THIS IS USED ON 2ND PASS OF BB REG ALLOC


![1212] Add address for CHARACTER data descriptors, use IDADDR/IDTARGET

	IDTARGET = CW2$,	!TARGET FOR ADDRESSING IN CODE GEN
%1261%	IDADDR  = CW2$,		!FOR ADDRESSING
%1212%	IDCHDESC = IDADDR$,	! Address of the CHARACTER data descriptor

	! This is the actual symbol subsets of the symbol.  Symbols are
	! stored in the [length,,pointer] format.  The length is the length
	! of the symbol in words, and the pointer points to the Sixbit
	! symbol.

	IDSYMBOL = CW3$,		!Symbol; [length,,pointer]
					! THIS IS NOT SIXBIT!!

%4527%	IDSYMLENGTH = 0,3,SYMLENGTH$,	! Symbol's length in words.
%4527%	IDSYMPOINTER = 0,3,SYMPOINTER$,	! Symbol's pointer.  This points to the
%4527%					! actual symbol in Sixbit.

%4527%	! Various character positions in the id symbol.
%4527%
%4527%	ID1ST6CHAR = 2,3,FULL$,		! First 6 characters of symbol.
%4527%					! Only use for known one word
%4527%					! symbols, such as comparing to
%4527%					! our own internal symbols with
%4527%					! dots ("ICHAR.") which no user
%4527%					! symbol could possibly look like.
%4527%	IDVERYFRST =  2,3,0,24$,	! Last 4 characters of symbol.  (used
%4527%					! in global common subexpressions.)
%4527%	IDDOT = 2,3,SYM1STCHAR$,	! First character. (Check if its a dot)
%4527%	IDDOTX = 2,3,24,12$,		! Macro to look at the first two
%4527%					! characters of a symbol name, ".x".
%4527%	IDDOTO = IDDOTX$,		! ".O" (common subexpression).
%4527%	IDDOTF = IDDOTX$,		! ".F"
%4527%	IDDOTR = IDDOTX$,		! ".R"

	IDCOMMON  = CW4L$,	!PTR TO COMMON BLOCK NAME IF IN COMMON
				! ALSO PTR TO NAMELIST ARG BLK IF NAMELIST
	IDFNATTRIB= CW4$,	!ATTRIBUTE-FIELD FOR A FUNCTION NAME (THIS
				! WORD IS USED FOR IDDATA,IDCOMMON FOR VARS)
				! THIS FIELD CONTINUES THE ATTRIBUTES OF A
				! LIBRARY FUNCTION
	!THE FOLLOWING ARE SUBFIELDS OF IDFNATTRIB FIELD:
	IDPARAVAL= CW4$,	!CONTAINS THE CONSTANT LEXEME WHICH IS THE
				!VALUE OF THE GIVEN PARAMETER VARIABLE

	IDINLINFLG=0,4,35,1$,	!FLAG FOR "THIS FN CAN BE EXPANDED IN LINE"
	IDLIBFNFLG=0,4,34,1$,	!Flag for "this is a library function or
				!subroutine"
%1567%	IDFNFOLD=0,4,33,1$,	!This function may be folded later into a
%1567%				!constant.
%2302%	IDCLOBB=0,4,32,1$,	!This flag is set for certain library
%2302%				!routines (called as subroutines).  It
%2302%				!indicates that ACs are not preserved by
%2302%				!the call.
%2532%	IDFUNCTION=0,4,31,1$,	!This FNNAME has been used in a function
%2532%				! call, its not a subroutine, or an ambiguous
%2532%				! external.
%4517%	IDINCR=0,4,31,1$,	!This flag is set for .Dnnnn character 
%4517%				!bytepointers that will be used for LDB/DPB
%4520%	DLINK = CW4R$,		!Field used to link together all .Dnnnns
	IDINLINOPR=CW4R$,	!OPERATOR TO BE USED FOR THE IN-LINE FN
				! NODE THAT CAN BE SUBSTITUTED FOR THIS FN (IF
				! THERE IS ONE)
%1567%	IDILFOPRCLS=0,4,8,5$,	!The OPRCLS field to assign for inline fn
%2352%	IDILFOPERSP=0,4,3,5$,	!The OPERSP field for the inline fn
	IDSFNLAB=CW5L$,		!LOCAL LABEL ASSIGNED TO A STATEMENT FUNCTION
%1466%	IDSFNODE = CW5R$,	!Pointer to statement function statement node
	IDENTLNK = CW5L$,	!LINK TO NEXT ENTRY POINT IF THIS IS AN
				!ENTRY POINT - 0 TERMINATES THE LIST
	IDCOLINK = CW5R$,	!LINK TO NEXT SYMBOL IN COMMON BLOCK THAT
				!THIS SYMBOL IS IN
%1406%	IDBPOFFSET = CW5$,	! Constant used to do  a compile-time ADJBP  on
				! IDCHBP for a subnode of a .Dnnnn variable  to
				! form the IDCHBP for the .Dnnnn variable.

%2202%	IDDATVAL=CW6$,		! For DATA stmnt processing:  this wd is
				! used to hold  the the current  *value*
				! of this variable if it is a loop index
				! for a data statemnt
 
![1212]	IDCHLEN is also declared in LEXICA.BLI. Beware of skews.

%1212%	IDCHLEN = CW6$,	! Character count for CHARACTER data set to -1
%1212%			! if length is *
%1212%	IDCHBP = CW7$,	! Byte pointer to CHARACTER data, not used for
%1212%			! dummy args

%1245%	IDFLG = CW8$,	! word for extra flag bits - i.e. PSECTs

![1526] If the definition  of IDPSECT or  IDPSCHARS is changed,  alter
![1526] the fields used in LEXICA in the ACMENDID macro.

%1245%	IDPSECT   = 0,8,34,2$,	! PSECT for IDADDR field
%1245%	IDPSCHARS = 0,8,32,2$,	! PSECT for actual data for character variables
				!  (right half of byte pointer)
%1406%	IDGENLENFLG = 0,8,31,1$,	! Flag for .Dnnnn variables - if set
%1406%					! then both the byte pointer and length
%1406%					! word of the character descriptor are
%1406%					! output
%1467%	IDSAVVARIABLE = 0,8,30,1$,	! Variable is in SAVE statement
%1467%	IDSAVCOMMON = 0,8,29,1$,	! Common is in SAVE statement
%2473%	IDIMPLNONE = 0,8,28,1$,		! Error message was already given
%2473%					! for IMPLICIT NONE.
%2507%	IDSUBROUTINE = 0,8,27,1$,	! Indicates that symbol is used as a
%2507%					! subroutine name

%2427%	ORFIXFLG  =  0,8,20,1$,		! Flag .O in symtab as created when .R
%2427%					! replaced in DOTORFIX
%2427%	OMOVDCNS  =  0,8,19,1$,		! Flag .O in symtab as expr moved as
%2427%					! constant (MOVDCNS in hash tbl) for
%2427%					! GLOBDEPD
%2427%	! Removed IDCHOS (bits 11-15) and IDUSED (bit 16)

%1245%	IDDEF	= 0,8,18,1$,

%1505%	IDUSECNT  = CW8R$,	!Use count for shared .I dimension offsets
%2427%	IDCLEANA  = 0,8,18,3$,	!Redefinition of ORFIXFLG, OMOVDCNS and IDDEF
%2427%				! so that they can be cleared in one stroke
%2427%				! by DFCLEANUP

%2427%	! *** Beware!! ***
%2427%	! 
%2427%	! MERIT, USRARGUSE and LIBARGUSE are overlaps of IDUSECNT.
%2427%	! 
%2427%	! *** Beware!! ***

%2427%	LIBARGUSE = 0,8,17,1$,	! Used as library function arg
%2427%	USRARGUSE = 0,8,16,1$,	! Var cannot  live  in reg  due  to  its
%2427%				! usage as  parameter  to fn  inside  IF
%2427%				! statement.
%2427%	MERIT = 0,8,0,16$,	! Field of symbol  tables entry used  to
%2427%				! compute the merit of a variable by the
%2427%				! register allocator.
%2427%	IDCLEANB = CW8R$;	! Redefinition of LIBARGUSE, USRARGUSE and
%2427%				! MERIT so that they can be cleared in one
%2427%				! stroke by CLEANUP

![1213] Define mnemonic for CHARACTER*(*) i.e. length star is IDCHLEN = -1.
%1213%	BIND	LENSTAR = -1;

![1526] Note that  the PSxxxx  symbols are  used as  indices into  the
![1526] EXTERNPSECTS UPLIT in RELBUF and the PSECTS vector in  GLOBAL.
![1526] Those tables must be reordered if the symbols change.

![1505] If the value of PSDATA is changed, alter the value used in the
![1505] ACMENDID macro in LEXICA.

BIND
%1551%	PSOOPS = 0,	! For psects that are not set by accident
%1245%	PSDATA = 1,	! Lowseg data psect
%1245%	PSCODE = 2,	! Hiseg code psect
%1245%	PSLARGE = 3,	! Large data psect (extended addressing)
%1512%	PSABS = 4;	! For things that don't get relocated

!***********************************************************************
!THE STRUCTURE ACCESS FOR CONSTANT TABLE
!
MACRO	CONLINK	 = CLINK$,
	CONOPER  = CW1R$,	!OPERATOR FIELD
	CNTOBEALCFLG= 0,1,35,1$,	!FLAG FOR "THIS CONSTANT NEEDS TO BE IN CORE"
	CONADDR = CW2R$,	!ADDR OF THIS CONSTANT
	CONST1   = CW4$,	!HIGH ORDER VALUE(CONTAINS REAL PART OR HI ORDER OF DP OR SINGLE REAL )
                                !MUST BE THE SAME AS LIT1
	CONST2	 = CW5$,	!LOW ORDER VALUE (CONTAINS INTEGER VALUE)
				!MUST BE THE SAME AS LIT2
	CONST2L	= CW5L$;	!LEFT HALF OF CONSTANT AOBJN POINTER

!***************************************************************************!
!THE STRUCTURE FOR THE LITERAL TABLE
!

MACRO	LITSIZ	 = CW0L$,	!NUMBER OF WORDS OCCUPIED BY CHARACTER
                                !STRING, INCLUDING NULL WORD AT END
	LITLINK	 = CLINK$,	!LINK TO NEXT LITERAL
	LITOPER	= CW1R$,	!OPER FIELD OF LITERAL
	LITFLGS = CW1L$,	!LITERAL FLAG FIELD
	LITEXWDFLG=0,1,34,1$,	!FLAG INDICATING THAT THIS LITERAL HAS AN EXTRA
				! WD ON THE END CONTAINING ONLY  A NULL (THIS
				! IS NECESSARY IF THE NUMBER OF CHARS FITTED
				! INTO AN EXACT NUMBER OF WDS)

	LITADDR = CW2$,		!ADDR OF LIT STRING
%1212%	LITLEN = CW3$,		! Character count for CHARACTER constant
%1212%	LIT1=CW4$,		!1ST WD OF THE LITERAL STRING (ASCII - LEFT
				! JUSTIF) MUST BE THE SAME AS CONST1
%1221%  LITC1=0,4,36,7$, 	!ILDB BYTE ADDRESS OF THE FIRST CHARACTER OF
				! THE LITERAL
%1527%	LITC2=0,4,29,7$, 	!LDB BYTE ADDRESS OF FIRST CHAR OF LITERAL
%1212%	LIT2=CW5$,		!2ND WD OF THE LITERAL STRING (WILL BE FILLED
				! WITH NULLS IF STRING IS ONLY 1 WD
				! MUST BE THE SAME AS CONST2

! Successive words of the literal will be stored in words following;

%1212%	LITWD(IX)=0,3+IX,FULL$,	!TO ACCESS THE NTH WORD OF  A LITERAL
				! (NOTE THAT THE 1ST WD IS WORD 1)
	FIRSTLIT = LITTBL[0]$;

	! Special structure to access the nth word of a literal

%1212%	STRUCTURE HOLLENTRY[CT]=
%1212%	(@.HOLLENTRY + 4 + .CT-1)<0,36>;

!**********************************************************************
!The structure access for the COMMON block name table
!**********************************************************************

MACRO
%2235%	COMPSECT = 0,0,34,2$,		!Psect for the common block
%2235%	COMLINK	 = CLINK$,		!Link to next block
	COMNAME  = CW1$,		!Block name; [length,,pointer]
					!THIS IS NOT SIXBIT!!
%4527%	COMNLEN = 0,1,SYMLENGTH$,	!Length of common name in words
%4527%	COMNPTR = 0,1,SYMPOINTER$,	!Pointer to common name in words
	COMFIRST  = CW2L$,		!First entry in block ptr
	COMLAST  = CW2R$,		!Last entry in block ptr
	NEXCOMBLK  =CW3R$,		!Ptr to next common block in sequence
					! as defined for allocation purposes
%1261%	COMSIZE	 = CW4$;		!Size of this common block in
					! characters
	

!***********************************************************************
! [2343]
! The structure access for the table of COMMON blocks named in an
! /EXTEND switch.  (Table is named ECTAB.)
!
!  These field definitions are also known in CMND20.  Beware of skews!
!
!***********************************************************************


MACRO
%2343%	ECNAME	= 0, 0, FULL $,		! Name of the COMMON block, [len,,ptr]
%4527%					! Use SYMLENGTH, SYMPOINTER to access
%4527%					! the subfields.
%2343%	ECLINK	= 0, 1, RIGHT $,	! Pointer to next entry with same hash
%2343%	ECPSECT	= 0, 1, 34, 2 $,	! PSECT of COMMON block
%2343%	ECPSE2	= 0, 1, 32, 2 $;	! Temp used by command scanner during
					! SWITCH.INI processing

!***********************************************************************
! The structure access for the EQUIVALENCE group table entry
!
! The global symbol EQVPTR points to linked Equivalence Groups which  in
! turn point  to  linked  Equivalence Lists  which  contain  the  actual
! variable id in equivalence.
!***********************************************************************

	! Equivalence Groups

MACRO	EQVINCOM  = 0,0,35,1$,	!IS GROUP IN COMMON BIT
%2235%	EQVAVAIL = 0,0,33,2$;	! Status for searching group for
				! shared id symbols.
%2235% BIND	EQVGROUP=0,	!Available for searching
%2234%		EQVCLASS=1,	!Valid class
%2234%		EQVIGNORE=2,	!Not available (Has been combined)
%2234%		EQVERROR=3;	!Error in processing
%2235% MACRO
%2234%	EQVPSECT = 0,0,31,2$,	!Psect for the group or class
%2234%	EQVSMALL = 0,0,29,1$,	!Set if the group contains .DATA. variables
%2234%	EQVLARGE = 0,0,28,1$,	!Set if the group contains .LARG. variables
%1261%	EQVALIGN = 0,0,18,3$,	!CHAR POSITION TO ALIGN GROUP ON	
	EQVLINK  = CLINK$,	!LINK TO NEXT GROUP
	EQVHEAD  = CW1L$,	!PTR TO ACTUAL HEAD OF GROUP
	EQVISN = CW1R$,		!EQUIVALENCE STATEMENT NUMBER
	EQVFIRST = CW2L$,	!PTR TO FIRST ITEM IN GROUP
	EQVLAST = CW2R$,	!PTR TO LAST LIST ENTRY IN GROUP
	EQVADDR = CW3$,		!DISPLACEMENT OF CLASS 'HEAD' FROM 0
	EQVLIMIT = CW4$;	!LIMIT VALUE OF EQUIV CLASS

	! Equivalence List

MACRO	EQLINDIC  = 0,0,35,1$,	!INDICATES SYMBOL NOT DIMENSIONED YET
%1262%	EQLSSTRING = 0,0,34,1$,	!THIS SYMBOL IS A SUBSTRING	
	EQLLINK  = CLINK$,	!LINK TO NEXT SYMBOL
	EQLID	 = CW1R$,	!PTR TO SYMBOLTABLE
	EQLDISPL  = CW2$,	!DISPLACEMENT OF THIS SYMBOL FROM GROUP HEAD
	EQLLIST = CW3$,		!PTR TO LIST OF SUBSCRIPTS (CONSTANTS)
%1262%	EQLLOWER = CW4$;	!LOWER SUBSTRING BOUND, 0 IF NONE
!
!THE STRUCTURE ACCESS FOR  ENCODED SOURCE (EXECUTABLE PROGRAM) TREE
!
MACRO	SRCID	 = 0,1,1,7$,	!ID CODE OF STATEMENT
	SRCLINK	 = CLINK$,	!LINK PTR TO NEXT STATEMENT HEADER
	SRCCMPLX=0,0,30,6$,	!NUMBER OF REGS THAT CAN BE USED TO EVAL THIS STMNT
	SRCSONNXTUSE=0,0,18,12$,	!ISN OF STMNT OR EXPRESSION LATER IN THIS BASIC BLOCK
				! WHERE THE VAR UNDER THIS STMNT WILL NEXT BE USED
	SRCISN	 = CW2L$,	!INTERNAL SEQUENCE NUMBER OF STAEMENT
	SRCFLAGS = CW1L$,	!FLAGS FOR LABEL TABLE
				!***************************************
				! Note  that  statements  use  bits  for
				! flags   not   mentioned   here.     In
				! particular, look at DO statements  and
				! arithmetic    IF    statements     and
				! expression  nodes  in  TABLES  to  see
				! which bits and uses exist.
				!***************************************
!	PAIRMODEFLG		!Flag in all stmnts indicating that 
!				! they require a reg pair
!	SAVREGFLG		!Save the reg containing the val of
!				! the var under this node for use
!				! later in this basic block
	SRCSAVREGFLG=0,1,34,1$,	!Flag used by basic block reg alloc,
				! Indicates that the reg containing the var
				! under this ASMNT or DO stmnt should be saved
!	USRFNREF		!Statement contains a user function reference.
	SRCOPER  = CW1R$,	!OPER FIELD- OPERCLS = STATEMENT
				!OPERSPC = SRCID
	SRCLBL	 = CW3L$,	!LABEL TABLE POINTER (0 IF NO LABEL)
	SRCOPT	 = CW2R$,	!PTR TO OPTIMIZATION WORDS USED BY PHAZ 2
	SRCCOMNSUB = CW2R$,		!COMMON SUBEXPRESSION HERE
	P2SDONE = 0,0,35,1$,	!USED BY OPT - INDICATES THAT P2SKEL OPTS
				! HAVE BEEN PERFORMED ON THIS STMNT (SAME BIT
				! AS 1ST BIT OF SRCCMPLX)


	%(***DEFINE A MACRO TO USE IN SPECIFYING OPERATOR FIELDS OF STATEMENT NODES-
		FOR A STMNT NODE THE OPRCLS FIELD IS IN BITS 23-27, THE SRCID IS
		IN BITS 28-34
	******)%
	STOPERC(OPCLS,OPSRCID)=
		(OPCLS^8 OR OPSRCID^1)$,


!
!THE FOLLOWING STRUCTURES ARE AN INTEGRAL PART OF THE STAEMENT HEADER
!FOR EACH KIND OF EXECUTABLE STATEMENT, ONLY THE ABOVE FIELDS
!CONTAIN INFORMATION COMMON FOR EACH STAEMENT NODE
!
!
!GO TO STATEMENT FIELDS
!
!	NOLBLLST		!USED BY OPTIMIZER ON AN ASSIGNED GOTO TO
!				! INDICATE THAT THE PROGRAMMER DID NOT SUPPLY
!				! A BRANCH LIST
	GOTOLBL	 = CW3R$,	!PTR TO LABEL TABLE
	AGOTOLBL = CW3R$,	!ASSIGNED GO TO LABEL PTR
	CGOTOLBL = CW3R$,	!COMPUTED GO TO PTR TO PSEUDO EXPRESSION NODE
	GOTOLIST = CW4R$,	!PTR TO LIST OF LABELS (OR 0) IF NO LIST
	GOTONUM = CW4L$,	!NUMBER OF LABELL INLIST
!
!IF STATEMENT FIELDS
!
	LIFEXPR  = CW3R$,	!PTR TO EXPR NODE FOR LOGICAL IF
	LIFSTATE = CW4R$,	!PTR TO STATEMENT NODE IF TRUE CONDITON
	AIFEXPR = LIFEXPR$,	!SAME  AS FOR LOGICAL IF
	AIFLESS  = CW4R$,	!LABEL PTR IF LESS
	AIFEQL  = CW4L$,	!LABEL TO GO TO IF EQUAL
	AIFGTR  = CW5R$,	!LABEL TO GO TO IF GTR
	AIFREG = 0,5,23,4$,	!REG TO HOLD THE VAL TO BE TESTED
	!BITS WITHIN THE FLAGS FIELD USED BY ARITHMETIC IF ONLY
	! (THESE BITS ARE ALL USED ELSEWHERE AS FLAGS DESCRIBING ARG2 OF AN EXPRESSION) 
	AIFLBEQV=0,EXOPWD,21,2$,	!VAL OF THIS FIELD INDICATES WHCH (IF ANY)
					! OF THE 3 LABELS ARE EQUAL TO EACHOTHER
					!(THESE BITS ARE USED IN EXPRS AS A2NEGFLG AND A2NOTFLG)
	AIFLBNXT=0,EXOPWD,19,2$,	!VAL OF THIS FIELD INDICATES WHICH (IF ANY)
					! OF THE LABELS INDICATES THE FOLLOWING STATEMENT
	AIFFLGS=0,EXOPWD,19,4$,		!THE CONCATENATION OF THE AIFLBEQV AND AIFLBNXT FIELDS
					!(THESE BITS ARE A2SAMEFLG AND A2IMMEDFLG IN EXPRS)
!
!ASSIGN STATEMENT FIELDS
!
	ASILBL  = CW3R$,	!PTR TO LABEL IN ASSIGN
	ASISYM  = CW4L$,	!PTR TO SYMBOL TABLE
	ASILINK = CW4R$,	!LINKS ASSIGN STATEMENTS
!
!DO STATEMENT FIELDS
!
	DOFLGS=CW1L$,			!FLAGS ON THIS STMNT
					! SET IN DOXPND OR BY THE OPTIMIZER
!	PAIRMODEFLG			!Flag in all stmnts indicating that 
!					! they require a reg pair
	SSIZONE=0,EXOPWD,33,1$,		! Step size one, M3 = +/- 1.
					!SET IN DOXPND OR BY OPTIMIZER
	INNERDOFLG=0,EXOPWD,32,1$,	!FLAGS INNERMOST DO STATEMENTS
%1027%	MAYBEZTRIP=0,EXOPWD,30,1$,	!POTENTIAL ZERO TRIP LOOP
	INITLIMMED=0,EXOPWD,29,1$,	!INITIAL VALUE IS IMMEDIATE
					!SET IN DOXPN OR OPTIMIZER

	! THE NEXT THREE FLAGS ARE SET BY THE OPTIMIZER AND USED IN GLOBAL 
	! REG ALLOC

	HASRTRN=0,EXOPWD,28,1$,		!THIS LOOP HAS A RETURN IN IT
	HASENT=0,EXOPWD,27,1$,		!THIS LOOP HAS AN ENTRANCE
	HASEXIT=0,EXOPWD,26,1$,		!THIS LOOP HAS EXITS

	CTLSAMEFLG=0,EXOPWD,25,1$,	!CONTROL EXPR WAS COMPUTED INTO THE REG
					! IN WHICH IT WILL BE USED
	MATRLZCTLONLY=0,EXOPWD,24,1$,	!MATERIALIZE THE CTL WORD BUT NOT THE
					! LOOP INDEX (THIS ONLY OCCURS WHEN
					! OPTIMIZING)
	IXGALLOCFLG=0,EXOPWD,23,1$,	!LP INDEX WAS ASSIGNED A REG BY THE
					! GLOBAL ALLOCATOR
	SSIZNEGFLG=0,EXOPWD,22,1$,	!STEP SIZE IS A NAGATIVE INTEGER IMMED
					! CONSTANT AND HENCE MUST BE NEGATED
					! WHEN IT IS PICKED UP (IE AT LOOP END
					! MUST DO SUBI RATHER THAN ADDI)
	SSIZIMMED=0,EXOPWD,21,1$,	!STEP SIZE IS AN IMMEDIATE CONSTANT
					! (INTEGER)#1
	CTLNEG=0,EXOPWD,20,1$,		!CTL VAL MUST BE NEGATED WHEN IT IS
					! PICKED UP (THIS IS ALWAYS SET IF CTL
					! VAL IS A CONSTANT BUT NOT FLCWD
	CTLIMMED=0,EXOPWD,19,1$,	!CTL VAL IS AN IMMED CONST
	INITLNEG=0,EXOPWD,18,1$,	!INITL VALUE MUST BE NEGATED WHEN

	DOLBL	= CW3R$,	!PTR TO DO LABEL TERMINUS ENTRY
	DOSYM	= CW4R$,	!POINTER TO DO INDEX VARIABLE
	DOM1	= CW4L$,	!POINTER TO INITIAL VALUE
	DOM2	= CW5L$,	!POINTER TO UPPER LIMIT
	DOM3	= CW5R$,	!POINTER TO STEP SIZE
	DOSSIZE = DOM3$,	!ANOTHER NAME FOR STEP SIZE
	DOPRED	= CW6L$,	!PTR TO DO STATEMENT PREDECESSOR

	!THESE FLAGS ARE NOW IN WORD 6 (NO SPARE BITS)

%2231%	DOFLGAUX=0,6,8,10$,	!Auxiliary flags field (used in DUMP)
	EXTALLOC=0,6,17,1$,	!EXTEND GLOBAL ALLOCATION TO THIS LOOP
	MATRLZIXONLY=0,6,16,1$,	!MATERIALIZE THE LOOP INDEX BUT NOT
				! THE CTL WD
	NEDSMATRLZ =0,6,15,1$,	!MATERIALIZE THE LOOP INDEX AND THE
				! CTL WD
	REALARITH=0,6,14,1$,	!DO SYMBOL IS REAL SO ALL ARITHMETIC
				! MUST BE REAL
	IVARINREG=0,6,13,1$,	!DO INDUCTION VARIABLE IS IN A REGISTER
				!SET BY OPTIMIZER
	SSIZINTMP=0,6,12,1$,	!STEP SIZE IN A TEMP
	INITLTMP=0,6,11,1$,	!INITL VALUE NEEDS COMPUTATION
	DOREMOVED=0,6,10,1$,	!OPTIMIZER HAS DELETED DO LOOP
	NOFLCWDREG=0,6,9,1$,	!If the DO index of  this  loop  is  not
				! materialized, then  AOBJN  should  not
				! be used for the loop.
	FLCWD=0,6,8,1$,		!Full word const initial value and  loop
				! control.  AOBJN  instruction  is  used
				! for DO loop.
	DOCREG=0,6,0,4$,	!DO LOOP CONTROL REG
	DOIREG=0,6,4,4$,	!DO LOOP INDUCTION VARIABLE REGISTER; 0 IS NONE

	DOLPCTL = CW7R$,	!POINTER TO CONTROL EXPRESSION
	DOCTLVAR = CW7L$,	!POINTER TO CONTROL VARIABLE
%1033%	DOZTRLABEL=CW8R$,	!PTR TO END-OF-LOOP LABEL
!
!THE STRUCTURE OF DO LOOP TREE NODES
!
	PARLVL = CW0L$,	!PTR TO PARALLEL LEVEL DO LOOP
	NEXTDO = CW0R$,	!PTR TO NEXT DEEPER NESTED DO
	PREVDO = CW1L$,	!PTR TO ENCLOSING DO LOOP
	LEVL   = CW1R$,	!NEST LEVEL OF LOOP 
	DOSRC	= CW2R$,	!PTR TO SOURCE TREE OF THE DO
	DONODESIZ = 3$,
!
!I/O STATEMENT FIELDS
!
!	TRUEISBR		! Set only on logical IF to indicate the the
!				! true branch is a branch.
	IOARGLBL = CW4L$,	! Pointer to label for statement argument list
	IOLINK	= CW4R$,	! Link I/O statements for generation of
				! argument list to IN., etc. calls
	IOUNIT	=  CW5L$,	! Pointer to UNIT
	IOVAR	= CW5L$,	! Variable for ENCODE and DECODE
	IOREPT	= CW5R$,	! For repeat factor on BACKSPACE, etc.
	IORECORD = CW5R$,	! Pointer to record for random access
	IOCNT	= CW5R$,	! Character count for ENCODE and DECODE
%4501%	IOKEYID = CW5R$,	! Pointer to the KEYID= specifier
	IOLIST	= CW6L$,	! Pointer to iolist
	IOFORM	= CW6R$,	! Pointer to format (0 if unformatted)
	IONAME	= CW6R$,	! Pointer to name list for namelist 
%2200%	IOFILE  = CW6R$,	! Pointer to FILE= for INQUIRE/OPEN/CLOSE
	IOERR	= CW7L$,	! Pointer to ERR label - don't ever multiplex
	IOEND	= CW7R$,	! Pointer to END label - don't ever multiplex
%760%	IOIOSTAT  = CW8L$,	! Pointer to IOSTAT variable
%1530%	IOMARK	= CW8R$,	! Pointer to argument list for CHMRK./CHUNW.
%1530%				! calls.  Used for dynamic concatenations
%1530%	IOLMARK = CW9L$,	! Pointer to argument list for CHMRK./CHUNW.
%1530%				! calls.  Used for dynamic concatenations
%1530%				! in iolists.
%4500%	IOKEY = CW9R$,		! Pointer to the KEY= secondary node table.
%4501%	IOKEYREL = 0,10,34,2$,	! Contains key relation indicator for indexed read
!
!FORMAT STATEMENT FIELDS
!
	FORSIZ  = CW4L$,	!SIZE OF STRING IN WORDS
	FORLINK = CLINK$,
	FOROPER = CW1R$,
	FORADDR = CW4R$,	!ADDR OF STRING (IN LOW SEG)
	FMTLINK	= CW5L$,	!LINK TO NEXT FORMAT STATEMENT
	FORSTRING = CW5R$,	!PTR TO CHARACTER STRING
!
!DATA STATEMENT NODE
!
	DATALNK = CLINK$,	!LINKS NODES TOGETHER
	DATISN = SRCISN$,		!CW2L
	DATCOUNT = CW1$,		!NUMBER OF WORDS SPECIFIED FOR INITIALIZATION
	DATITEMS = CW0L$,	!PTR LINKED LIST OF DATAITEM NODES
	DATCONS = CW2R$,	!PTR TO LINKED LIST OF CONSTANT NODE PTRS

	!Define the fields in the linked list of constants under a DATA stmnt

	!	---------------------------------	(Note that this chart
	!	! DCONST	!   CLINK	!	appears in DATAST.BLI)
	!	---------------------------------
	!	! DATARPT                       !
	!	---------------------------------

%2202%	DCONST=CW0L$,		!Ptr to constant table entry
%2202%	DATARPT=CW1$,		!Ct of number of times this constant is to be
				! stored
!
!
!NAMELIST NODE
!
	NAMLINK	=CLINK$,	!LINK TO NEXT NODE
	NAMLID	=CW2L$,		!PTR TO NAMELIST NAME
	NAMADDR	=CW2R$,		!ALLOCATED ADDRESS OF NAMELIST ARGLIST
	NAMCNT	=CW1L$,		!NUMBER OF ITEMS IN NAMLIST
	NAMLIST =CW1R$,		!PTR TO LIST OF NAMELIST NAMES
!
!OPEN STATEMENT
!
	OPSIZ=	IOCNT$,		!NUMBER OF OPEN PARAMETERS
	OPLST=	IOLIST$,	!LOCATION OF PARAMETER LIST
!
!ASSIGNMENT STATEMENT
!
	LHEXP	 = CW4R$,	!PTR TO LEFT SIDE EXPRESSION
	RHEXP	 = CW3R$,	!PTR TO RIGHT SIDE EXPR
	ASMNTREG = 0,4,23,4$,
!
!STATEMENT FUNCTION FIELDS
!
	SFNNAME	= CW3R$,
	SFNLIST = CW4R$,
	SFNEXPR	= CW4L$,
	SFNCLBREG=CW5R$,	!TO SAVE CLOBBREGS FIELD
!
!CALL STATEMENT FIELDS
!
!	LABLARGS		!SET ON A CALL STATEMENT ONLY TO INDICATE
!				! THERE ARE LABEL ARGS
	CALSYM   = CW3R$,	!PTR TO SUBROUTINE NAME SYMBOL
	CALLIST	 = CW4R$,	!PTR TO LIST OF ARGS  OR 0
	CALNUM	 = CW4L$,	!NUMBER OF ARGS IN CALL
!
!RETURN STATEMENT
!
	RETEXPR	= CW3R$,		!PARAMETER NUMBER TO RETURN THRU
!
!STOP STATEMENT
!
	STOPIDENT = CW3R$,	!STOP LOCATION IDENTIFIER
	STOPLBL=CW4L$,		!LABEL ASSOCIATED WITH THE ARGLIST TO
				! FOROTS USED FOR THIS STMNT
!
!PAUSE STATEMENT
!
	PAUSIDENT = CW3R$,	!PAUSE LOCATION IDENTIFIER
	PAUSLBL=CW4L$,		!LABEL ASSOCIATED WITH THE ARGLIST FOR FOROTS USED
				! FOR THIS STMNT
!
!REGMASK NODE (FOR GLOBAL ALLOCATION)
!
	NEWREGSET=CW3R$,
!
!ENTRY STATEMENT FIELDS (ALSO GOOD FOR SUBROUTINE AND FUNCTION DEFINITIONS)
!
!	VALINR0			!Set in ENTRY statement by global allocator
!				! to indicate function value is already in
!				! register zero.
	ENTSYM	= CW3R$,	! Ptr to entry name
	ENTLIST	= CW4R$,	! Ptr to list of args or 0
	ENTNUM	= CW4L$,	! 0 for principle entry, else non-zero
	ENTID	= CW5R$,	! Actual name for a function .
%1466%	ENTLINK	= CW5L$;	! Link to the next entry statement or 0.


!
!THE STRUCTURE ACCESS FOR STATEMENT NUMBER TABLE ENTRY
!
MACRO	
	SNLINK	 = CLINK$,	!LINK TO NEXT TABLE ENTRY
	SNNXTLAB = CW0L$,	!PTR TO INTERNAL LABEL WITH SAME ADDR FIELD
	SNOPER	= CW1R$,	!OPER FIELD FOR STATEMENT NUMBER
	SNMADELABL =0,1,35,1$,	!FLAG FOR MADE LABEL
	SNIO = 0,1,18,1$,	! LABEL HAS BEEN REFERENCED IN AN IO STATEMENT
				! OR IS A FORMAT STATEMENT LABEL
	SNEXECU = 0,1,19,1$,	! LABEL HAS BEEN REFERENCED IN AN EXECUTABLE
				! STATEMENT OR IS AN EXECUTABLE STATEMENT LABEL
%[636]%	SNDEFINED = 0,1,20,1$,	!SET IF SNADDR FIELD HAS BEEN SET UP
%[716]%	SNRFS	= 0,1,21,1$,	!SET IF LABEL IS POTENTIAL RETURN FROM
%[716]%				!A SUBROUTINE LABEL AND HENCE A PROBLEM
%1402%	SNDECL = 0,1,22,1$,	!SET IF LABEL IS ON A DECLARATION STATEMENT
%1150%	SNASSIGNED = 0,1,23,1$,	!SET IF LABEL HAS BEEN USED IN ASSIGN STATEMENT
%1526%	SNPSECT = 0,1,24,2$,	! Psect index for label's address
%1573%	SNWHILE = 0,1,26,1$,	!SET IF LABEL IS TERMINAL STMT OF A DO WHILE
	SNFLAGS = CW1L$,	!
	SNEXTND = CW2L$,	!FOR EXTENDED DO CONSTRUCTION
	SNREF	= CW2$,		!WHOLE WORD USED FOR ADDING 0NE IN TESTENTRY
	SNREFNO = CW2R$,	!NUMBER OF TIMES LABEL REFERENCED
	SNADDR = CW2R$,		!THE ABSOLUTE ADDRESS OF THIS LABEL
	SNHDR	 = CW3L$,	!PTR TO SOURCE STATEMENT TREE OF DEFINING STATEMENT
	SNUMBER	 = CW3R$,	!ACTUAL STATEMENT LABEL
	SNDOLVL	= CW4R$,	!COUNT OF NESTED DO'S REFERENCING THIS LABEL
	SNDOLNK	= CW4L$,	!PTR TO LIST OF 1 WORD POINTERS TO DO LOOPS
	SNCADDRWD = CW5$,	!WD OF ENTRY USED BY PEEPHOLER
	SN1STLAB = CW5R$,	!PTR TO 1ST LABEL THAT HAS SAME ADDR
	SNSTATUS = CW5L$;	!STATUS OF THIS LABEL:
				! 0 - UNRESOLVED
				! 1 - IN PEEPHOLE BUFFER
				! 2 - OUT OF PEEPHOLE BUFFER
				!REFERENCING THIS LABEL


MACRO	DOUBLE = .SYMTYPE GTR REAL$;	%FOR TESTING DOUBLE OR COMPLEX MODE%

!***********************************************************************
! EFIW table
!***********************************************************************

![2205] New

!   !=========================================================================!
! 0 !              EFSYMPTR              !               CLINK                !
!   !-------------------------------------------------------------------------!
! 1 !       IDATTRIBUT(ALLOFTHEM)        !              OPERATOR              !
!   !-------------------------------------------------------------------------!
! 2 !                         !I! TARGXF !              TARGADDR              !
!   !-------------------------------------------------------------------------!
! 3 !0!I!  EFX  !                             EFY                             !
! 3 !           !S!                                                           !
!   !-------------------------------------------------------------------------!
! 4 !                                EFEXTERN                                 !
! 4 !             EFFIXEDUP              !                                    !
!   !-------------------------------------------------------------------------!
! 5 !               EFREP                !             EFSIMILAR              !
!   !=========================================================================!

MACRO
	EFSYMPTR = CW0L$,	! Ptr to symbol table entry.
	! CLINK			! Link to next table entry.

	! Word 1 contains the IDATTRIBUT and OPERATOR fields of the symbol.

	! Word 2 is the  target field as in  the expression nodes.   Use
	! TARGIF, TARGXF, TARGADDR to reference.

	!* First bit of word 3 must be left zero, so that this word can
	!* be just copied into the rel file.

	EFI = 0,3,34,1$,	! I field
	EFX = 0,3,30,4$,	! X field
	EFY = 0,3,0,30$,	! Y field
%2337%	EFYSIGN = 0,3,29,1$,	! Y field's sign bit
	EFADDR = CW3$,		! Complete address
 	EFEXTERN = CW4$,	! [length,,pointer] name to do additive fixup
				! of EFY, or internal psect index to
				! relocate EFY.  Fixups are for common
				! blocks and subroutines.
%4527% 	EFEXTLEN = 0,4,SYMLENGTH$,	! Length of symbol
%4527% 	EFEXTPTR = 0,4,SYMPOINTER$,	! Pointer to SIXBIT symbol
%2464%	EFFIXEDUP = CW4L$,	! Non-zero if EFEXTERN contains a symbol name
	EFREP = CW5L$,		! Pointer to  the  representitive  table
				! entry  for  multiple  similar   nodes.
				! Always points to the top most, the one
				! actually hashed.
	EFSIMILAR = CW5R$;	! Link to next similar EFIW table entry.


	!***************************************************************
	! The following bind defines the  table numbers and entry  sizes
	! for the various tables built by the compiler. The left half of
	! the global NAME is  the entry size and  the right half is  the
	! table number that is used to identify a specific table in  the
	! calls to  the  table  search routine  (TBLSEARCH).
	!***************************************************************

BIND
%1530%	FLSIZ = 16,		! Number of entries in FREELIST used  by
				! CORMAN  and  SAVSPACE.   NUMCHARS   in
				! ACMENTLITLEX in LEXICA must be greater
				! than CHARSPERWORD * FLSIZ for literals
				! to work.
%1245%	IDSIZ	= 9,		! Symbol table entry
%2477%	POOLSIZ	= 2000,		! Size of buffer for input cards (10000 chars)
%2477%				! ***** Same declaration is in LEXAID.BLI *****
	STKSIZ  = 250,		! Size of syntax stack STK
	EXSIZ	= 4,		! Expression table entry
	SUBNODESIZ = 5,		! Substring (expression) node
	SNSIZ	= 6,		! Statement number table entry
	CONSIZ	= 6,		! Constant table entry
%1212%	LTLSIZ	= 4,		! Literal table entry - must agree with
%1212%				! definition in LEXICA 
%1261%	COMSIZ	= 5,		! Common block name table entry
	EQVSIZ	= 5,		! Equivalence group entry
%1262%	EQLSIZ	= 5,		! Equivalence list entry
	DATSIZ  = 3,		! Data table entry
	NAMSIZ	= 3,		! Namelist node entry
	SRCSIZ	= 4,		! Encoded source tree entry - header 
	ASGNSIZ	= 1,		! ASSIGNMENT part
	ASSISIZ = 1,		! ASSIGN part
	CALLSIZ	= 1,		! CALL part
	CONTSIZ = 0,		! CONTINUE part
%1033%	DOSIZ	= 5,		! DO part
	ENTSIZ	= 2,		! ENTRY part
	GOTOSIZ = 1,		! GOTO part
	AGOSIZ	= 1,		! Assigned GOTO part
	CGOSIZ	= 1,		! Computed GOTO part
	IFSIZ	= 3,		! IF part
	IFASIZ	= 2,		! Arithmetic IF part
	IFLSIZ	= 2,		! Logical IF part
	RETUSIZ = 1,		! RETURN part
	STOPSIZ = 2,		! STOP part
%4501%	IOSIZ	= 7,		! I/O statement part
%1530%	READSIZ = IOSIZ,	! READ part
%1530%	WRITSIZ = IOSIZ,	! WRITE part
%1530%	DECOSIZ	= IOSIZ,	! DECODE part
%1530%	ENCOSIZ = IOSIZ,	! ENCODE part
%760%	FINDSIZ = 5,		! FIND part
%1530%	CLOSSIZ = IOSIZ,	! CLOSE part
%4502%	DELESIZ = IOSIZ,	! DELETE part
%4503%	REWRSIZ = IOSIZ,	! REWRITE part
%4504%	UNLCKSIZ = IOSIZ,	! UNLOCK part
%760%	BACKSIZ = 5,		! BACKFILE, BACKSPACE, REWIND, SKIPFILE,
%760%				! SKIPRECORD, UNLOAD part
%760%	ENDFSIZ = 5,		! ENDFILE part
	PAUSSIZ = 2,		! PAUSE part
%1530%	OPENSIZ = IOSIZ,	! OPEN part
	FORMSIZ = 2,		! FORMAT statement part
%2200%	INQUSIZ = IOSIZ,	! INQUIRE part
	SFSIZ	= 2,		! Statement function part
%1245%	DIMSIZ	= 4,		! DIMENSION table entry (plus two words for
%1245%				! each dimension)
%1530%	DCSIZ	= 4,		! DATACALL iolist table entry
%1530%	SLCSIZ	= 4,		! SLISTCALL iolist table entry
%1530%	IOLCSIZ	= 6,		! IOLISTCALL iolist table entry
%1530%	ELCSIZ	= 6,		! E1LISTCALL and E2LISTCALL iolist table entry
%2205%	EFIWSIZ = 6,		! EFIW table entry
%4520%	DNSIZ = 0;		! .Dnnnn table entry

	! Define the tables for TBLSEARCH

BIND	IDTAB	= IDSIZ^18 + 0,		! Symbol table
	CONTAB	= CONSIZ^18 + 1,	! Constant table
	CXPTAB	= EXSIZ^18 + 2,		! Common subexpression table
	LABTAB  = SNSIZ^18 + 3,		! Label table
	COMTAB  = COMSIZ^18 + 4,	! COMMON block table
	SORTAB  = SRCSIZ^18 + 5,	! Encoded source
	DIMTAB  = DIMSIZ^18 + 6,	! Dimension table
	EXPTAB  = EXSIZ^18 + 7,		! Expression table
%1530%	IOLTAB  = DCSIZ^18 + 8,		! Iolist table (default is
%1530%					! a DATACALL node)

	! The number of words per literal table entry varies depending
	! on the size of the string

	LITTAB  =  9,			! Literal table
	LFUTAB	= 10,			! Library function id table
					! static and allocated in the
					! compiler's HISEG
	EQVTAB  = EQVSIZ^18 + 11,	! Equivalence group table
	EQLTAB  = EQLSIZ^18 + 12,	! Equivalence list table
	DATATAB = DATSIZ^18 + 13,	! Data group table
	NAMTAB	= NAMSIZ^18+ 14,	! Namelist group table
%2205%	EFIWTAB = EFIWSIZ^18 + 15,	! EFIW table
%4520%	DNTAB	= DNSIZ^18 + 16;	! .Dnnnn table 

!***********************************************************************
! Define the id for different FORTRAN statements (All statements
! have OPRCLS=STATEMENT=01110)
!***********************************************************************

	! Start of first group (regular)

BIND	ASGNID	= 000,	!ASSIGNMENT (SRCOPER=7000)
	ASSIID	= 001,	!(SRCOPER=7002)
	CALLID	= 002,	!(SRCOPER=7004)
	CONTID	= 003,	!(SRCOPER=7006)
	DOID	= 004,	!(SRCOPER=7010)
	ENTRID	= 005,	!(SRCOPER=7012)
	COMNSUB	= 006,	!(SRCOPER=7014)

	! Start of regular branching

	GOTOID	= 007,	!(SRCOPER=7016)
	AGOID	= 008,	!(SRCOPER=7020)
	CGOID	= 009,	!(SRCOPER=7022)
	IFAID	= 010,	!(SRCOPER=7024)
	IFLID	= 011,	!(SRCOPER=7026)
	RETUID	= 012,	!(7030)
	STOPID	= 013,	!(7032)

	! Start of I/O branching

	READID	= 014,	!(7034)
	WRITID	= 015,	!(7036)
	DECOID	= 016,	!(7040)
	ENCOID	= 017,	!(7042)
	REREDID	= 018,	!(7044)
	FINDID	= 019,	!(7046)
	CLOSID	= 020,	!(7050)
%4502%	DELEID	= 021,	!(7052)
%4503%	REWRID	= 022,	!(7054)
	BACKID	= 023,	!(7056)
	BKFILID	= 024,	!(7060)
	REWDID	= 025,	!(7062)
	SKFILID	= 026,	!(7064)
	SKRECID	= 027,	!(7066)
	UNLODID	= 028,	!(7070)
%4504%	UNLCKID	= 029,	!(7072)
	ENDFID	= 030,	!(7074)

	! Start of miscellaneous

	ENDID	= 031,	!(7076)
	PAUSID	= 032,	!(7100)
	OPENID	= 033,	!(7102)
	SFNID	= 034,	!(7104)
	FORMID	= 035,	!(7106)
	BLTID	= 036,	!(7110)
	REGMASK	= 037,	!(7112)
%2200%	INQUID	= 038;	!(7114) INQUIRE

	!***************************************************************
	! Define data for building  source tree entries for  statements.
	! Left half  is number  of  words for  each type  of  statement.
	! Right half is id of statement.
	!***************************************************************

BIND
	ASGNDATA	= (ASGNSIZ + SRCSIZ)^18 + ASGNID,
	SFNDATA		= (SFSIZ + SRCSIZ)^18 + SFNID,
	ASSIDATA	= (ASSISIZ + SRCSIZ)^18 + ASSIID,
	BACKDATA	= (BACKSIZ + SRCSIZ)^18 + BACKID,
	BKFILDATA	= (BACKSIZ + SRCSIZ)^18 + BKFILID,
	SKIPDATA	= (BACKSIZ + SRCSIZ)^18 + SKRECID,
	SKIPFDATA	= (BACKSIZ + SRCSIZ)^18 + SKFILID,
	REWIDATA	= (BACKSIZ + SRCSIZ)^18 + REWDID,
	UNLODATA	= (BACKSIZ + SRCSIZ)^18 + UNLODID,
	REREDATA	= (IOSIZ + SRCSIZ)^18 + REREDID,
	CALLDATA	= (CALLSIZ + SRCSIZ)^18 + CALLID,
	CONTDATA	= (CONTSIZ + SRCSIZ)^18 + CONTID,
	DECODATA	= (DECOSIZ + SRCSIZ)^18 + DECOID,
	OPENDATA	= (OPENSIZ + SRCSIZ)^18 + OPENID,
	CLOSDATA	= (CLOSSIZ + SRCSIZ)^18 + CLOSID,
	DODATA		= (DOSIZ + SRCSIZ)^18 + DOID,
	ENCODATA	= (ENCOSIZ + SRCSIZ)^18 + ENCOID,
	ENDFDATA	= (ENDFSIZ + SRCSIZ)^18 + ENDFID,
	ENTRDATA	= (ENTSIZ + SRCSIZ)^18 + ENTRID,
	FINDDATA	= (FINDSIZ + SRCSIZ)^18 + FINDID,
	READDATA	= (READSIZ + SRCSIZ)^18 + READID,
	WRITDATA	= (WRITSIZ + SRCSIZ)^18 + WRITID,
	GOTODATA	= (GOTOSIZ + SRCSIZ)^18 + GOTOID,
	AGODATA		= (AGOSIZ + SRCSIZ)^18 + AGOID,
	CGODATA		= (CGOSIZ + SRCSIZ)^18 + CGOID,
	IFADATA		= (IFASIZ + SRCSIZ)^18 + IFAID,
	IFLDATA		= (IFLSIZ + SRCSIZ)^18 + IFLID,
%4502%	DELEDATA	= (DELESIZ + SRCSIZ)^18 + DELEID,
%4503%	REWRDATA	= (REWRSIZ + SRCSIZ)^18 + REWRID,
%4504%	UNLCKDATA	= (UNLCKSIZ + SRCSIZ)^18 + UNLCKID,
	ENDDATA		= SRCSIZ^18 + ENDID,
	RETUDATA	= (RETUSIZ + SRCSIZ)^18 + RETUID,
	STOPDATA	= (STOPSIZ + SRCSIZ)^18 + STOPID,
	FORMDATA	= (FORMSIZ + SRCSIZ)^18 + FORMID,
	PAUSDATA	= (PAUSSIZ + SRCSIZ)^18 + PAUSID,
%2200%	INQUDATA	= (INQUSIZ + SRCSIZ)^18 + INQUID;

!
!	BIND	ENTRSIZ = PLIT(IDTAB,CONTAB,EXPTAB,LABTAB,COMTAB,
!				SORTAB,DIMTAB,IOLTAB,LITTAB);
!
!	THE FOLLOWING MACROS MAY BE NEEDED FOR INDEFINITE SIZE ENTRIES
!	AND FOR INDEFINITE LEVEL OF INDIRECT REFERENCE
!
	MACRO	CWD(L,N) = L,N,FULL$;
!
!	L - MEANS LEVEL OF INDIRECTION
!	N - MEANS THE N-TH WORD IN THE ENTRY
!
!
!!	THE FOLLOWING STRUCTURE DECLARATION DEFINES THE HASH TABLES
!	FOR THE SYMBOL TABLE THE CONSTANT TABLE,EXPRESSION TABLE AND
!
!
	STRUCTURE HTABLE[I] = (.HTABLE +.I)<RIGHT>;

!	DEFINE THE TABLE SIZES
	BIND	SSIZ =	79,	%SYMBOL HASH TABLE%
		CSIZ =	37,	%CONSTANTS HASH TBLE%
%[674]%		ESIZ =	1,	%EXPRESSION HASH%
		LASIZ = 37,	%STATMENT NUMBER HASH SIZE%
		NSIZ = 17,	%NAMELIST HASH SIZE%
		SOSIZ = 1,	%NO HASH TABLE FOR ENCODED SOURCE%
		DISIZ = 1,	%NO HASH TABLE FOR DIMENSIONS%
		DASIZ = 1,	%NO HASH TABLE FOR DATA STATEMENT%
		LISIZ = 1,	%LITERAL TABLE IS NOT HASHED%
%2205%		EFSIZ = 37,	! EFIW table hash size.
%2205%				! Unsure  about  the  size  needed,   we
%2205%				! suspect that  we  need less  than  the
%2205%				! regular symbol table entries.
%4520%		DNTSIZ = 37;	! .Dnnnn table hash size

![674] SET UP DOSTAK DIFFERENTLY SO THAT IT OVERLAPS INTO EHASH
![674] DURING FORTG (CODE GENERATION) - THE TOTAL SIZE OF DOSTAK
![674] WILL BE TDOSTSIZ WHICH MAY BE INCREASED BY MAKING
![674] DOSTSIZ BIGGER (HEAVEN FORBID!)
%[674]%		BIND	EHSIZ=29,	!HASH TABLE SIZE
%[674]%			DOSTSIZ=50,	!DO STACK SIZE (ADDED TO EHSIZ IN FORTG)
%[674]%			TDOSTSIZ=EHSIZ+DOSTSIZ;	!TOTAL DO STACK SIZE
	!WHICH IS THE MAXIMUM LEVEL TO WHICH DO LOOPS MAY BE NESTED
!
	EXTERNAL SYMTBL[SSIZ],CONTBL[CSIZ],EXPTBL[1],LABTBL[LASIZ],
		LITTBL[LISIZ],NAMTBL[NSIZ],SRCTBL[SOSIZ],
%4520%		DIMTBL[DISIZ],DATTBL[DASIZ],DNTBL[DNTSIZ];

	MAP	HTABLE SYMTBL: CONTBL: LABTBL: NAMTBL;


!***************************************************************************
!	The next structure defines the accessing algorithm for the
!	linked list structures that are the actual tables containing
!	symbol entries, constant entries, expression entries etc.

	STRUCTURE BASE[I,J,K,L] =

		! The parameters are defined as follows:
		!
		! I - the level of indirection
		!	0 - Contents of BASE
		!	1 - Contents of entry pointed to by BASE
%4527%		!	2 - Contents of entry pointed to by right half
%4527%		!		of Jth word of BASE
		!
		! J - The J-th word in the table entry pointed to.

		CASE .I OF SET
			(@.BASE +.J)<.K,.L>;		! 0
			(@@.BASE +.J)<.K,.L>;		! 1
%4527%  		(@(@.BASE + .J))<.K,.L>		! 2
		TES;

!******
!	MAP THE POINTERS TO THE BASE
!
	EXTERNAL BASE BASEPTR;



!THE FOLLOWING GLOBALS ARE USED FOR SEMANTICS CHECKING
!THEY CONTAIN POINTERS TO TABLE ENTRIES FOR THE LAST COMMON BLOCK
!NAME, THE LAST LITERAL, THE LAST SYMBOL ENTERED ETC.
!
	EXTERNAL DTRACE,JOBFF,JOBREL,XAREA,XCALL,XSTAK,XALTX,TYPTAB;
!
	EXTERNAL
		COMBLKPTR,	!POINTERS FOR LAST AND FIRST COMMMON BLOCKS
		LITPOINTER,	!LAST AND FIRST LITERALS
		SYMPTR,	!LAST AND FIRST SYMBOLS
		SORCPTR,	!LAST AND FIRST SOURCE ENTRIES
		LASTEXP,	!LAST EXPRESSION ENTRY
		LASTDIM,	!LAST DIMENSION ENTRY
		CONSPTR,	!LAST AND FIRST CONSTANTS
		LABLPTR,	!FIRSTAND LAST STATEMENT LABELS
		SPACEFREE;	!AMOUNT OF FREE LOWSEG SPACE
	EXTERNAL
		SRCHONLY,	!FLAG FOR TBLSEARCH FOR SEARCH ONLY MODE
		ISN,		!INTERNAL SOURCE SEQUENCE NUMBER
		IDOFSTATEMENT,	!IDENTIFICATION OF EXECUTABLE STEMENT IN TREE
		LABLOFSTATEMENT;!POINTER TO LABEL TABLE NODE FOR STMT NUMBER
				!IF CURRENT STATEMENT HAS ONE - OR 0
	EXTERNAL
		DLOOPTREE,	!PTR TO DO LOOP NEST TREE
		LASLVL0,	!PTR TO LAST LEVEL 0 NEST SEEN
		DELETPTR;	!PTR TO DELETED TABLE ENTRY FOR DELETE ROUTINE
	EXTERNAL
		SYMTYPE,	!TYPE OF CRRENT SYMBOL
		POINTER	,	!USEFUL POINTER
		LIBFUNTAB,	!DEFINES THE FUNCTION NAMES IN LIBRARY
		LIBATTRIBUTES,	!DEFINES THE LIBRARY ATTRIBURES
		ONEAFTERLIB,	!END OF THE LIB TABLE ADDRESS
		NAME,		!NAME OF THE TABLE FOR TBLSEARCH
				!AND SIZ OF ENTRY IN LEFT HALF
		EQVPTR,		!PTR TO FIRST AND LAST EQIV GROUPS
		FORMPTR,	!PTR TO FIRST AND LAST FORMAT TABLE ENTRIES
		DATASPTR,	!PTR TO LINKED LIST OF DATA STATEMENT NODES
		IOLSPTR,	!PTR TO LINKED IO STATEMENTS
		ENTRY;		!THE GLOBAL PARAMETER VECTOR FOR TBLSEARCH

!*****
	MACRO	FIRSTSRC = SORCPTR<LEFT>$,	! First source statement
		LASTSRC = SORCPTR<RIGHT>$,	! Last source statement
		IOFIRST = IOLSPTR<LEFT>$,	!POINTS TO FIRST IO STATEMENT
		IOLAST = IOLSPTR<RIGHT>$,	!POINTS TO LAST IO STATEMENT SEEN SO FAR
		DATFIRST	= DATASPTR<LEFT>$,
		DATLAST	= DATASPTR<RIGHT>,
		FIREQVGROUP = EQVPTR<LEFT>$,
		LASEQVGROUP = EQVPTR<RIGHT>$,
		LASCOMBLK = COMBLKPTR<RIGHT>$,
		FIRCOMBLK = COMBLKPTR<LEFT>$,
		DELETFIELD = CW0L$,	!IF LEFT HALF OF FIRST WORD OF ENTRY IS -1 THEN ENTRY IS DELETED
		FOUND = -1$,
		NOTFOUND = 0$,
		FLAG = FLGREG<FOUNDFLG>$;	! Flag for TBLSEARCH
						!  -1	found
						!  0	not found

	BIND
		XCONSTANT = 12,
		XSYMBOL = 8,
		XLABLL = 4,
		EXPRES = 0;

BIND
%2443%	MAXSYM = 72,		! Maximum length of a symbolic name that
%2443%				! LINK will allow in a PSECT name.
%2443%	SYMLEN = (MAXSYM+5)/6;	! Symbolic name length in words needed to
%2443%				! hold MAXSYM SIXBIT characters.

!
 