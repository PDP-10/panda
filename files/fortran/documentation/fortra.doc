


                   Fortran-20 -- Changes from V10 to V11


                               February 1987















   COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1981, 1987
   ALL RIGHTS RESERVED.

   THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE  USED  AND  COPIED
   ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH THE INCLUSION
   OF THE ABOVE COPYRIGHT  NOTICE.   THIS  SOFTWARE  OR  ANY  OTHER  COPIES
   THEREOF  MAY  NOT  BE  PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER
   PERSON.   NO  TITLE  TO  AND  OWNERSHIP  OF  THE  SOFTWARE   IS   HEREBY
   TRANSFERRED.

   THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND
   SHOULD   NOT   BE   CONSTRUED  AS  A  COMMITMENT  BY  DIGITAL  EQUIPMENT
   CORPORATION.

   DIGITAL ASSUMES NO RESPONSIBILITY FOR THE  USE  OR  RELIABILITY  OF  ITS
   SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
Fortran-20 Version 11                                           Page 2


        1.0     SUMMARY  . . . . . . . . . . . . . . . . . . . . . . 4
        1.1       Bibliography . . . . . . . . . . . . . . . . . . . 5
        1.2       Monitors . . . . . . . . . . . . . . . . . . . . . 5
        1.3       Related System Software  . . . . . . . . . . . . . 6
        2.0     NEW FEATURES . . . . . . . . . . . . . . . . . . . . 7
        2.1       Long Symbols . . . . . . . . . . . . . . . . . . . 7
        2.1.1       Usage Of New Symbols . . . . . . . . . . . . . . 7
        2.1.1.1       LINK . . . . . . . . . . . . . . . . . . . . . 7
        2.1.1.2       Program Listings . . . . . . . . . . . . . . . 7
        2.1.1.3       Fortran Command Line . . . . . . . . . . . . . 7
        2.1.1.4       Calling To Or From Other Languages . . . . . . 8
        2.1.2       Debugging With Long Symbols  . . . . . . . . . . 8
        2.1.2.1       FORDDT . . . . . . . . . . . . . . . . . . . . 8
        2.1.2.2       DDT  . . . . . . . . . . . . . . . . . . . . . 8
        2.1.2.3       Symbol Table Conflicts . . . . . . . . . . . . 8
        2.1.3       Ambiguous Constructs   . . . . . . . . . . . . . 9
        2.1.3.1       PARAMETER  . . . . . . . . . . . . . . . . . . 9
        2.1.3.2       <type> FUNCTION <long Symbol>  . . . . . . . . 9
        2.1.4       Utilities Which Do Not Support Long Symbols  . . 9
        2.1.5       Incompatibilities With Older Programs  . . . .  10
        2.2       RMS Support  . . . . . . . . . . . . . . . . . .  10
        2.2.1       Overview . . . . . . . . . . . . . . . . . . .  10
        2.2.2       Invoking RMS . . . . . . . . . . . . . . . . .  10
        2.2.2.1       Effects Of Invoking RMS  . . . . . . . . . .  11
        2.2.2.2       File Types Accessible Using RMS  . . . . . .  11
        2.2.3       RMS Specifiers In OPEN Statements  . . . . . .  12
        2.2.4       RMS Specifiers In INQUIRE Statements . . . . .  17
        2.2.5       CLOSE Specifiers And RMS . . . . . . . . . . .  18
        2.2.6       RMS Specifiers In READ Statements  . . . . . .  19
        2.2.6.1       Reading Indexed Files  . . . . . . . . . . .  19
        2.2.6.1.1       Sequential Indexed READ  . . . . . . . . .  19
        2.2.6.1.2       Keyed READ . . . . . . . . . . . . . . . .  20
        2.2.7       RMS WRITE Statements . . . . . . . . . . . . .  21
        2.2.7.1       Key Attributes . . . . . . . . . . . . . . .  21
        2.2.7.2       Writing Formatted INTEGER Keys . . . . . . .  21
        2.2.8       REWRITE Statement  . . . . . . . . . . . . . .  22
        2.2.9       DELETE Statement . . . . . . . . . . . . . . .  22
        2.2.10      UNLOCK Statement . . . . . . . . . . . . . . .  23
        2.2.11      RMS File-positioning Statements  . . . . . . .  23
        2.2.12      Network File Access  . . . . . . . . . . . . .  24
        2.2.12.1      Remote Filespecs . . . . . . . . . . . . . .  24
        2.2.12.2      Remote Links . . . . . . . . . . . . . . . .  25
        2.2.12.2.1      Reducing Network Overhead  . . . . . . . .  25
        2.2.12.2.2      Data Transfers To/from VMS . . . . . . . .  25
        2.2.12.2.2.1      VMS Fortran Segmented Recordtype Files .  26
        2.2.13      RMS Error Reporting  . . . . . . . . . . . . .  26
        2.3       Single-character Object-Code Performance . . . .  26
        2.4       Substring Support In FORDDT  . . . . . . . . . .  27
        3.0     RESTRICTIONS . . . . . . . . . . . . . . . . . . .  27
        3.1       Utilities Which Do Not Support Long Symbols  . .  27
        3.2       Numeric Data Exchange Between TOPS-20 And VMS 
                  Systems  . . . . . . . . . . . . . . . . . . . .  27
        3.3       VMS Fortran Segmented Recordtype Files . . . . .  28
        3.4       DBMS . . . . . . . . . . . . . . . . . . . . . .  28
        4.0     KNOWN BUGS AND DEFICIENCIES  . . . . . . . . . . .  28
Fortran-20 Version 11                                           Page 3


        5.0     COMPATIBILITY WITH PREVIOUS VERSIONS . . . . . . .  28
        6.0     INTERNAL CHANGES . . . . . . . . . . . . . . . . .  28


APPENDIX A      RMS ARGUMENT BLOCK FIELDS

Fortran-20 Version 11                                           Page 4


   1.0  SUMMARY

   Version 11 of  Fortran-20  is  a  development  release  of  the  Fortran
   compiler, FOROTS, FORLIB and FORDDT.  Fortran-20 version 11 is validated
   at the full level of the Fortran-77 standard.

   The major new features include

    o  Support for long symbol names up to 31 characters  in  length.   The
       dollar-sign  ($) and underscore (_) characters are allowed in symbol
       names.

    o  Support for long symbol names in FORDDT under /DEBUG.

    o  RMS interface to  allow  access  to  RMS  sequential,  relative  and
       indexed (ISAM) file organizations.

    o  Network file access which  allows  transparent  access  to  RMS  and
       non-RMS file organizations when the file resides on a remote TOPS-20
       or VMS system.

    o  Single-character object code performance enhancements.

    o  Support for character substrings in FORDDT.


   This tape contains copies of the version  11  compiler,  FOROTS  (called
   FORO11.EXE), FORLIB and FORDDT.

   Note that you must use LINK 6.0(2404) or  later  for  linking  the  .REL
   files generated by this version of Fortran.
Fortran-20 Version 11                                           Page 5


   1.1  Bibliography

   Two copies of each of the  following  manuals  are  enclosed  with  this
   release tape.

   The Fortran language  and  this  implementation  are  described  in  the
   reference manual:

        TOPS-10/20 Fortran Language Manual
          AD-N383B-T1

   The installation procedures for this tape are described in:

        TOPS-20 Fortran Installation Guide
          AA-P344C-TM


   There is also a booklet which provides quick reference information about
   Fortran-10/20:

        TOPS-10/20 Fortran Pocket Guide
          AA-P529C-TK

   The algorithms and accuracy of the math routines in FORLIB are described
   in:

        TOPS-10/20 Common Math Library Reference Manual
          AA-M400A-TK

   Similarities and differences between Fortran-10/20 and  VAX/VMS  Fortran
   are described in:

        Fortran-10/20 and VAX Fortran Compatibility Manual
          AA-Y868C-TK

   It is recommended that you also refer to

        American National Standard Programming Language FORTRAN
        (ANSI X3.9-1978)

   Copies of this standard may be obtained from:
          
           American National Standards Institute
           1430 Broadway
           New York, NY 10018




   1.2  Monitors

   This version of Fortran will run on Tops-20 releases 4.1  (KS)  and  6.1
   (KL)  or  later.   Use  of the new RMS and network features from Fortran
   requires Tops-20 release 6.1.
Fortran-20 Version 11                                           Page 6


   1.3  Related System Software

   The following system software must be used  with  Fortran-10/20  version
   11:

           LINK 6(2404) or later

   If RMS is invoked, the following  system  software  must  be  used  with
   Fortran-20 version 11:

           RMS 3(662) or later
           RMSFAL version 1
           RTL 1.1(57)

   The following system software must be used to build Fortran  version  11
   from sources:

           BLIS10 7.5(227)
           MACRO 53.2(1244)


   The following optional software may be used with Fortran-10/20 V11:

           SORT 5(536)
           DBMS V6
           DIL (Data Interchange Library)
Fortran-20 Version 11                                           Page 7


   2.0  NEW FEATURES

   2.1  Long Symbols

   Fortran-10/20 version 11 supports VMS-compatible long symbol names up to
   31  characters in length.  In addition, the characters "$" (dollar-sign)
   and "_" (underscore) are allowed in  symbol  names  anywhere  after  the
   first character of the symbol, which must be alphabetic.



   2.1.1  Usage Of New Symbols -

   All Fortran identifiers may be in the new format.

   This  includes  variable,  array,  COMMON  block,  PROGRAM,  SUBROUTINE,
   FUNCTION, PARAMETER, NAMELIST, and BLOCK DATA names.


                                     NOTE

       Long symbols should not be used with overlays,  as  the  overlay
       handler  does not support the new long-symbol .REL block format.
       There are no plans to modify the overlay handler to provide such
       support.





   2.1.1.1  LINK -

   Long symbol names require LINK 6(2404).



   2.1.1.2  Program Listings -

   Fortran listings will display the new long  symbols  where  appropriate;
   they  will  not  be  truncated.   Table  alignments have been changed to
   accommodate the longer names.



   2.1.1.3  Fortran Command Line -

   Users will be able to use the new-style symbols for COMMON  blocks  when
   using the /EXTEND:  switch.
Fortran-20 Version 11                                           Page 8


   2.1.1.4  Calling To Or From Other Languages -

   Other languages may not support long symbols.   Their  symbols  will  be
   truncated  to  6  characters.  Since the underscore (_) character is not
   representable in RADIX50 format, it will be translated, usually to  "%",
   sometimes  to  ".",  depending on the language.  Mixing program units in
   different languages can result  in  ambiguities.   A  symbol  SIN_  will
   appear  in  the  symbol  table  as  SIN. -- the same as the Fortran Math
   Library routine.



   2.1.2  Debugging With Long Symbols -



   2.1.2.1  FORDDT -

   Long symbols will be available to  the  Fortran  debugger  only  if  the
   /DEBUG switch is specified at compile time.  If the /DEBUG switch is not
   used, long symbols will in effect be truncated to 6 characters as far as
   FORDDT is concerned.



   2.1.2.2  DDT -

   The DDT symbol table output by LINK does not support long symbols, which
   are truncated to 6 characters.  Underscores in symbols are translated to
   "%".



   2.1.2.3  Symbol Table Conflicts -

   If /DEBUG is not specified when using long symbols with  FORDDT,  or  if
   DDT  is  being  used  to  debug  a program containing long symbols, some
   ambiguities may arise if the first 6 characters of a  long  symbol  name
   are not unique.  If the following Fortran fragment

        CALL FOOBAR1 (A,B)
        CALL FOOBAR2 (C,D)

   is compiled  /NODEBUG  and  debugged  with  FORDDT  or  DDT,  both  long
   subroutine  names will appear in the symbol table as "FOOBAR".  Likewise
   for

        CALL SUB (DF_EXPAND,B)

   the first subroutine argument name will appear in the symbol table as

        DF%EXP

   which may conflict with a Macro, monitor or Fortran runtime symbol.   In
   these  cases  FORDDT  will  search the symbol table and return the first
Fortran-20 Version 11                                           Page 9


   matching  symbol  found,  not  necessarily  the  long  symbol  the  user
   intended.



   2.1.3  Ambiguous Constructs -

   The following constructs are ambiguous in  both  Fortran-10/20  and  VMS
   Fortran.



   2.1.3.1  PARAMETER -

   No long variable name on the left-hand  side  of  an  assignment  should
   begin  with  the  characters  "PARAMETER".   The old style (pre-ANSI 77)
   PARAMETER statements are indistinguishable from an assignment statement.
   The PARAMETER statement

        PARAMETER I = 1

   cannot be distinguished from the assignment statement:

        PARAMETERI = 1

   because spaces have no meaning in Fortran syntax.



   2.1.3.2  <type> FUNCTION <long Symbol> -

   When given as a first statement, or directly following an END statement,
   this  must  be  a  function  declaration.   Otherwise  it  is  an  array
   declaration.  It is ambiguous, and can  only  be  disambiguated  by  its
   position in the program.

   As a result

        INTEGER FUNCTION FRED(ARG1,ARG2)

   cannot be distinguished from

        INTEGER FUNCTIONFRED(ARG1,ARG2)




   2.1.4  Utilities Which Do Not Support Long Symbols -

   In addition to the restrictions mentioned above for DDT and the  overlay
   handler, the following utilities do not support long-symbol .REL blocks,
   and should not be used with program units employing long-symbols.  There
   are no plans to modify any of these programs to remove the restriction.
Fortran-20 Version 11                                          Page 10


    o  GLOB

    o  MAKLIB

   MACRO does not support the generation of long-id  .REL  blocks  (symbols
   longer  than  6  characters  are  truncated  to 6).  Therefore it is not
   possible to call a MACRO subroutine  with  a  long  name  from  Fortran.
   There are no plans to modify MACRO to provide this support.



   2.1.5  Incompatibilities With Older Programs -

   In the past, the Fortran compiler has  ignored  (after  a  warning)  any
   symbol-name  characters  after  the  initial 6 characters, so FOOBAR and
   FOOBARBAZ appear as identical symbols.  This is  no  longer  true.   Old
   programs which depend on this old behavior will get different results.



   2.2  RMS Support

   2.2.1  Overview -

   Record Management Services  (RMS-20)  is  the  file  and  record  access
   subsystem  of the TOPS-20 operating system.  Fortran version 11 provides
   new syntax and keywords to allow access to RMS sequential, relative  and
   indexed disk file organizations.  Programs which do not choose to invoke
   the new RMS interface should see no change in behavior  in  version  11,
   and will not invoke the RMS subsystem.



   2.2.2  Invoking RMS -

   FOROTS will invoke the RMS subsystem when and only when at least one  of
   the following is true:

   1.  The new ORGANIZATION= keyword is specified in an OPEN statement with
       any value except 'UNKNOWN'.

   2.  ACCESS='KEYED' or the new KEY=  keyword  is  specified  in  an  OPEN
       statement.

   3.  The filespec given in either an OPEN  or  INQUIRE-by-file  statement
       contains  a  remote file specification (see section 2.2.12 below for
       more information on network files).

Fortran-20 Version 11                                          Page 11


   2.2.2.1  Effects Of Invoking RMS -

   FOROTS invokes RMS as a dynamic library the first time  an  RMS  service
   call  is  issued.   When so invoked, the dynamic library run-time module
   RTL.EXE is brought into the first free section of memory;   it  in  turn
   brings  XRMS.EXE  (the  main  RMS  module)  into  the next free section.
   User-written Macro  and  USEROPEN  routines  (see  below)  may  cause  a
   first-time  RMS  invocation.   They  should  place the following code in
   their programs to ensure that RMS is called compatibly with FOROTS:

        SEARCH  RMSINJ          ;RMS/dynamic library universal file

        .REQUIRE SYS:RMSZER     ;Dynamic library boot-strap files
        .REQUIRE SYS:RTLZNM
        .REQUIRE SYS:ZERBOO
        .REQUIRE SYS:DYNBOO

   All of the above files are included on this tape.



   2.2.2.2  File Types Accessible Using RMS -

   If RMS is invoked by  one  of  the  above  means,  it  will  access  the
   following two types of files:

   1.  RMS-format sequential, relative, and indexed files.  This file  type
       is  identified  in  the  user's  OPEN  statement  by  means  of  the
       ORGANIZATION= keyword (or ACCESS='KEYED' or KEY= keywords  to  imply
       an ORGANIZATION).  If any of these keywords are present, the file is
       assumed to be an RMS file.  RMS files can be local or  reside  on  a
       remote  TOPS-20  or  VMS  host (see section 2.2.12 below for more on
       using remote files).

   2.  Remote non-RMS files.  These are non-RMS stream and binary files  of
       the  kind  traditionally  read  and  written from Fortran, but which
       reside on a remote TOPS-20 node.  Any file accessible  from  Fortran
       version  10 or earlier which resides on a remote TOPS-20 system will
       be accessible as if it were a local file.  If  the  filespec  in  an
       OPEN  statement  contains  a remote filespec, but no ORGANIZATION is
       either specified or implied by ACCESS='KEYED' or KEY=, the  file  is
       assumed to be a remote non-RMS file.


                                       NOTE

           If the remote node in a file specification is a VMS  system,
           the  file  is  assumed  to  be  an  RMS  file,  even  if  no
           ORGANIZATION  is   specified   or   implied   (the   default
           ORGANIZATION='SEQUENTIAL' is assumed).



Fortran-20 Version 11                                          Page 12


   2.2.3  RMS Specifiers In OPEN Statements -

   The following new keywords and values determine whether and how RMS will
   OPEN the file.

   1.  ORGANIZATION =   The presence of this keyword  invokes  RMS,  unless
       the  user's  value  is  'UNKNOWN'.   The  values  are  'SEQUENTIAL',
       'RELATIVE',  'INDEXED'  and  'UNKNOWN'.   The   default   value   is
       'SEQUENTIAL'  for new files.  For existing files, if this keyword is
       specified, the value given must match the actual  file  organization
       or  an  error message will be displayed (or the ERR= branch is taken
       if specified).

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.  ORGANIZATION='UNKNOWN' is flagged by
       the compiler as a VMS incompatibility.

   2.  RECORDTYPE =  The value given for this keyword determines the record
       type.   The  values  are 'STREAM', 'FIXED', 'VARIABLE' or 'UNKNOWN'.
       If this keyword is absent, its value is 'UNKNOWN'  and  the  default
       when  creating a new file is 'STREAM' for non-RMS files, 'FIXED' for
       RMS relative and indexed files, and 'VARIABLE'  for  all  other  RMS
       files.   RECORDTYPE='STREAM'  for  local or remote TOPS-20 RMS files
       will be trapped with an error message or the  ERR=  branch  will  be
       taken.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   3.  RECORDSIZE =  This keyword is  used  to  specify  the  MRS  (Maximum
       Record  Size) value for RMS files.  For non-RMS files this keyword's
       meaning remains unchanged.  For RMS files:

        o  If the file contains fixed-length records, RECORDSIZE  specifies
           the size of each record.

        o  If the file is a sequential file  and  contains  variable-length
           records, RECORDSIZE is optional and specifies the maximum length
           for each record.  If no RECORDSIZE has been specified, RMS  does
           not perform maximum-length checking.

        o  As with non-RMS files, if the records are formatted, the  length
           is in bytes;  if unformatted, in words.

        o  If RECORDSIZE is not specified, the MRS value specified when the
           file was created is used.

        o  If  RECORDSIZE  is  specified  for   an   existing   file   with
           fixed-length  records or relative organization, and the value is
           different from the actual length of the  records  in  the  file,
           either  an  error  message  is  displayed  or the ERR= branch is
           taken.
Fortran-20 Version 11                                          Page 13


        o  If a program attempts to write a variable-length record that  is
           longer  than  the non-zero MRS value specified when the file was
           created, an error message is displayed, or the  ERR=  branch  is
           taken.   Writing  fixed-length  records  which exceed RECORDSIZE
           produces a run-time warning, and the record is truncated to  the
           specified size.

        o  RECORDSIZE is required when creating a new relative  or  indexed
           file, or when the RECORDTYPE is, or defaults to, FIXED.

       For local RMS files, RMS allows the following maximum  record  sizes
       for File/Record formats:

          Organization            Record format           Maximum
          ------------            -------------           -------

          Sequential              Fixed-length            262,143 bytes
          Sequential              Variable-length         262,143 bytes
          Relative                Fixed-length            262,143 bytes
          Relative                Variable-length         262,143 bytes
          Indexed                 Fixed-length              3,579 words
          Indexed                 Variable-length           3,578 words


       For remote files, the maximum size for an RMS record transfer cannot
       exceed RMS' DAP buffer size (currently set at 8192 8-bit bytes).  If
       the record  exceeds  this  limit,  a  "?Record  too  big"  error  is
       displayed or the ERR= branch is taken.

   4.  MAXREC =  For RMS files, this keyword specifies the  maximum  number
       of records permitted in a direct access file.  If it is omitted, the
       maximum number is unlimited.  If it is  specified,  RMS  returns  an
       error  when  a  record  number  greater  than the value specified is
       written to the file.  This keyword is  ignored  for  non-RMS  files.
       The MAXREC keyword has the form

        MAXREC = mr

       where mr is an integer expression.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   5.  READONLY.  For local non-RMS files, this keyword  specifies  that  a
       file is opened for read-access only:  the accessing process can read
       but not write to the file;  other accessing processes can  read  and
       write to the file.

       For RMS or remote files, this keyword has a different  meaning.   If
       the first process to access the file specifies READONLY, the file is
       open for read-only access by that process,  as  for  non-RMS  files.
       Any subsequent accessing process must specify READONLY to obtain any
       access to the file;  if READONLY is not specified by the  subsequent
       accessor,  or  if  SHARED is specified, access to the file is denied
       with a  "?File  is  locked"  error.   That  is,  the  access-sharing
Fortran-20 Version 11                                          Page 14


       capabilities  of  the  file  are  determined by the first process to
       access that file.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   6.  SHARED.  For RMS and remote files, this specifies that the  file  is
       opened  for  write  sharing, i.e.  at least one program is writing a
       file and at least one other program is either reading or writing the
       same  file.   For  write sharing to occur, all programs which access
       the file must specify SHARED;  attempts by a subsequent accessor  to
       write  a  record  which  has  already  been  locked will result in a
       "?Record locked" error, or the ERR= branch is taken.

       If neither READONLY nor SHARED is specified, the file  is  open  for
       exclusive  access;  that is, the initial accessor can read and write
       to the file, but subsequent accessors are denied  any  access  (they
       will receive a "?File is locked" error or the ERR= branch is taken).

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   7.  KEY =  This keyword specifies the keys to be used by RMS  to  access
       the records in an indexed file.  This keyword has the form:

       KEY=(<kspec> {, <kspec>})

           Where <kspec> has the form:

               <pos1> :  <pos2> [:<type>]

           and <type> is:

               INTEGER | CHARACTER


       where <pos1> is an integer  expression  specifying  the  first  byte
       position  of the key, <pos2> is an integer expression specifying the
       last byte position of the key, and <type> (optional)  specifies  the
       data  type  of  the  key.   If  no <type> is specified, CHARACTER is
       assumed.  The position  of  kspec  given  with  the  KEY=  specifier
       determines  its  key-of-reference  number, where 0 is the number for
       the primary key.

       The total length of a key cannot exceed  the  maximum-record  length
       associated  with  the  file;   if  it does, an error message will be
       displayed, or the ERR= branch taken.


                                       NOTE

           When using keys of  type  INTEGER,  RMS  requires  that  key
           length [<pos2>-<pos1>+1] equal 4.  INTEGER key lengths other
           than 4 will generate an error.
Fortran-20 Version 11                                          Page 15


       For existing RMS ISAM files, the KEY=  specifier  is  optional.   If
       given,  it is ignored during OPEN, but RMS updates the KEY XAB chain
       given by the user with key  information  from  the  file.   For  new
       RMS/ISAM files the KEY= specifier is mandatory.

       If  KEY=  is  present   without   ORGANIZATION=   being   specified,
       ORGANIZATION  defaults  to 'INDEXED'.  If ORGANIZATION= and KEY= are
       both present, ORGANIZATION must be 'INDEXED' or an error will occur,
       or the ERR= branch taken.


                                       NOTE

           See  section  2.2.7.1  for  the  default  "duplicate/change"
           attributes for primary and alternate keys.



       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   8.  USEROPEN =  This  keyword  specifies  the  name   of   an   optional
       user-supplied external function which can set various RMS parameters
       otherwise defaulted by Fortran, and perform the actual OPEN in place
       of  FOROTS.   This function is intended for use with RMS files only;
       use of a USEROPEN function with a remote non-RMS  file  may  produce
       indeterminate results.

       The user's function must perform both $OPEN and $CONNECT RMS service
       calls,  returning  AC0  non-zero on any non-recoverable failure.  If
       AC0 is returned zero, FOROTS will assume the function has succeeded,
       and  program  execution will continue.  If AC0 is returned non-zero,
       FOROTS will assume the USEROPEN function has failed, and will  issue
       an  error  (or take the ERR= branch) based on the STS and STV values
       returned by RMS to FOROTS.

       FOROTS will call the user's function with an argument  list  of  the
       following form:

                -3,,0
        xM:     IFIW TP%INT,address of unit
                IFIW TP%LBL,address of FAB
                IFIW TP%LBL,address of RAB

       See the RMS-20 Programmer's Reference Manual for more information on
       RMS argument blocks and data structures.

       See also section 2.2.2.1 above for rules governing  the  writing  of
       USEROPEN functions.

       See also Appendix A of this document for a list of the RMS  argument
       block fields set and/or read by Fortran.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.
Fortran-20 Version 11                                          Page 16


   9.  NOSPANBLOCKS.  Specifies that records are not to  cross  disk  block
       (page) boundaries.  It has no effect on non-RMS files, and no effect
       on RMS files unless the file is a new relative or sequential file.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  10.  BYTESIZE =  This keyword specifies the integer  byte  size  for  the
       file.  For existing RMS files, this value must agree with the actual
       byte size of the file.  If no BYTESIZE has  been  specified,  FOROTS
       defaults  to  7 for TOPS-20, 8 for VMS files.  Specifying a bytesize
       not equal to 8 for a non-TOPS-20 file will result in an  error.   If
       BYTESIZE  is  specified when creating a new TOPS-20 RMS indexed file
       for which CHARACTER keys are defined, the bytesize must equal 7.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  11.  DEFAULTFILE =  This keyword is allowed in place of or in addition to
       the  FILE= and NAME= keywords to specify the file specification.  If
       used without  FILE=  or  NAME=,  it  replaces  the  FILE=  or  NAME=
       keywords.  If used with FILE= or NAME=, its file specification value
       is conflated with those given in FILE= and NAME= to provide the full
       file  specification.  Since FOROTS will process DEFAULTFILE=, FILE=,
       and  NAME=  in  that  order,  filespec  fields  specified  in  NAME=
       supersede all previous corresponding fields.

       When both DEFAULTFILE= and/or FILE= and NAME= are used to provide  a
       full   file   specification,  individual  filespec  fields  must  be
       completely specified within each keyword, and must be in  the  order
       required by the TOPS-20 filespec format.  For example, the directory
       field of a file specification cannot be split  between  DEFAULTFILE=
       and FILE=.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  12.  ACCESS='KEYED'  This new value to the ACCESS keyword specifies  that
       the  file  is  an RMS indexed file opened for either random keyed or
       sequential access.  The presence of this keyword value  will  invoke
       RMS (as if ORGANIZATION='INDEXED' had been specified).

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  13.  ASSOCIATEVARIABLE = For remote  non-RMS  files,  this  keyword  will
       retain  its  present function.  For RMS files, the associatevariable
       is ignored unless ACCESS='DIRECT'.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  14.  BUFFERCOUNT = For remote non-RMS files, this keyword will retain its
       present function of specifying the number of pages in a file window.
       For RMS files, this will set the MBF (multi-buffer count)  for  RMS'
Fortran-20 Version 11                                          Page 17


       internal  buffering.   If no BUFFERCOUNT has been specified, the RMS
       default will be used.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

  15.  CARRIAGECONTROL = The  default  for  RMS  files  is  'FORTRAN'.   If
       CARRIAGECONTROL='TRANSLATED'  is  specified  for  RMS  files,  it is
       treated as 'FORTRAN'.

       Because RMS does not have "record terminators" in sequential  files,
       if  CARRIAGECONTROL='LIST' is specified in the OPEN statement, there
       is no way to specify that a particular record should  have  no  CRLF
       added to it when it is printed.  For this reason, so-called "dollar"
       format, a format used for  eliminating  the  CRLF  after  a  record,
       cannot  be  supported for RMS files for which CARRIAGECONTROL='LIST'
       was specified.

       For  files  where  CARRIAGECONTROL='FORTRAN'  is  specified,  dollar
       format  has  the effect of turning the carriage control character of
       the NEXT record into a  null  character,  thus  specifying  that  no
       horizontal  or  vertical  motion  will be done prior to printing (or
       typing) the record.

       VMS does not support the Fortran carriagecontrol attribute for files
       created  from  a  remote host with RECORDTYPE='STREAM';  VMS creates
       the file but ignores the attribute.  For all other recordtypes,  VMS
       honors   the   attribute.   Therefore,  if  RECORDTYPE='STREAM'  and
       CARRIAGECONTROL='FORTRAN' are both specified when creating a file on
       VMS, Fortran treats the RECORDTYPE as 'VARIABLE'.

  16.  MODE = For remote stream files, the arguments to  the  MODE  keyword
       retain  their  present  meaning.   Because  RMS files do not contain
       LSCWs, specifying MODE='BINARY' for an RMS file will  be  equivalent
       to specifying MODE='IMAGE'.




   2.2.4  RMS Specifiers In INQUIRE Statements -

   The following new keywords and values are available for an INQUIRE on an
   RMS-accessed file.

   1.  DEFAULTFILE =  As in OPEN, the value for this keyword is merged with
       or  replaces  FILE= in INQUIRE to specify the file specification for
       which INQUIRE information is to be returned.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   2.  KEYED =  Returns a value specifying whether the file has  been  open
       for  keyed  access -- i.e.  whether the file is indexed.  The return
       values are 'YES', 'NO', or 'UNKNOWN' (if the file is not open).
Fortran-20 Version 11                                          Page 18


       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   3.  ORGANIZATION =  Returns a value specifying the organization  of  the
       file.  The return values are 'SEQUENTIAL', 'RELATIVE', 'INDEXED', or
       'UNKNOWN' (if the file is not open, or the file is not an RMS file).

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   4.  ACCESS =  In addition to its current return values, returns  'KEYED'
       if the file is open for keyed access.

   5.  BYTESIZE =  Returns the integer bytesize of the file (or  0  if  the
       file is not open).

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   6.  RECORDTYPE = Returns a value specifying  the  recordtype  associated
       with the file.  The return values are 'STREAM','VARIABLE','FIXED' if
       the file is open, or 'UNKNOWN' if the file is not open.

       When compatibility flagging is used, this keyword is flagged by  the
       compiler as an ANSI extension.

   7.  RECL =  Retains its current function for  non-RMS  files.   For  RMS
       files,  if  the  file  is open RECL returns the maxmimum record size
       (MRS) value associated with the file in either bytes (if opened  for
       formatted  I/O) or words (unformatted).  If the file is not open, or
       no MRS value is associated with the file, returns zero.



                                     NOTE

       An  INQUIRE  on  a  remote  file  which  returns  a  full   file
       specification  will  return  the  network  attributes, including
       password.





   2.2.5  CLOSE Specifiers And RMS -

   CLOSE keyword specifiers for RMS and remote files retain  their  present
   syntax.  As before, a FILE= specification in a CLOSE will cause the file
   associated  with  the  specified  unit  to  be  renamed   to   the   new
   specification.  To reduce unnecessary network overhead, FILE= should not
   be given in  CLOSE  statements  unless  a  remote  rename  operation  is
   required.

   The behavior of DISPOSE= arguments in general remains the same  for  RMS
   and  remote  files  as  for  non-RMS and local files, with the following
Fortran-20 Version 11                                          Page 19


   execptions:

    o  DISPOSE='LIST' and 'PRINT' are not supported for TOPS-20 RMS  files.
       They are supported for VMS RMS files.

    o  DISPOSE='EXPUNGE' will delete but not expunge a local RMS file.   It
       may  also  expunge  a  remote  RMS  or non-RMS file depending on the
       capabilities of the remote system.

    o  DISPOSE='PUNCH' is not supported for RMS or remote non-RMS files.




   2.2.6  RMS Specifiers In READ Statements -

   READ statements retain their  present  syntax  for  RMS  sequential  and
   relative  files  (and  for  remote  non-RMS files).  READ statements for
   indexed files  may  be  either  sequential  or  "keyed"  (see  following
   section).

   For   RMS   relative   files    which    are    accessed    sequentially
   (ACCESS='SEQUENTIAL' in the OPEN statement), RMS reads the next existing
   record, skipping any deleted or  empty  record  cells.   Relative  files
   accessed  randomly  will return a "?Record not found" error (or take the
   ERR= branch) for deleted or non-existent records.



   2.2.6.1  Reading Indexed Files -

   Indexed  files  can  be  read  either  sequentially   or   randomly   by
   key-of-reference  and  key  value.  The access mode is determined by the
   READ statement itself, and can be switched from one mode to the other in
   successive read statements.



   2.2.6.1.1  Sequential Indexed READ -

   Indexed files may be read sequentially on any  index  defined  when  the
   file  was  created.   A sequential indexed read does not require any new
   syntax in the READ  statement.   Sequential  reads  retrieve  successive
   records  in an indexed file by ascending key value for a specific key of
   reference.  The key of reference can be established  by  a  prior  keyed
   read  (the  key of reference remains unchanged until the next keyed read
   changes it), or defaults to the primary key of reference.  A  sequential
   read  on a key of reference will return end-of-file when no records with
   a higher key value exist in that index.
Fortran-20 Version 11                                          Page 20


   2.2.6.1.2  Keyed READ -

   Keyed or random READs from an indexed file require the specification  of
   both  a  key  of reference and a key relational value (match criterion).
   Keyed READs can be formatted or  unformatted,  and  have  the  following
   syntax:

      FORMATTED:

        READ (un,fmt,key{,keyid}{,iostat}{,err}) {iolst}

      UNFORMATTED:

        READ (un,key{,keyid}{,iostat}{,err}) {iolst}

   where un, fmt, iostat, err, and iolst are defined  as  in  Fortran  READ
   statements.

   The following keyword specifies the search index to be used:

    o  KEYID = <Integer expression>  Specifies the key-of-reference  number
       for  the  key  specified.   If  no  KEYID  is  specified, the key of
       reference is not changed.  The default is the primary key  if  never
       set.   If KEYID is specified, then a key relational (see below) must
       also be specified.

   The following key relational keywords specify the match criterion to  be
   used in locating the desired record:

   1.  KEY = <Integer or Character  expression> - An  exact  match  on  the
       value is required.

   2.  KEYEQ = <Integer or Character expression> - An exact  match  on  the
       value is required.

   3.  KEYGE = <Integer or Character expression> - Returns an exact  record
       match  if a record with the requested key value can be found.  If no
       exact match is found, the record with the next higher key  value  is
       returned.

   4.  KEYGT = <Integer or Character expression> - Returns the record  with
       the next higher key value for the key of reference.


   A generic match is allowed for CHARACTER  data  type  keys.   A  generic
   match compares only a specified number of leading characters in the key.
   The length  of  the  search  key  determines  how  many  characters  are
   compared.

   If the specified match criterion in a keyed read cannot be  met  because
   no  record  provides the specified match, a "?Record not found" error is
   returned.

   When compatibility flagging is used, these specifiers are flagged by the
   compiler as ANSI extensions.
Fortran-20 Version 11                                          Page 21


   2.2.7  RMS WRITE Statements -

   The syntax of WRITE statements for RMS and remote non-RMS files  remains
   unchanged.  WRITEs to RMS files can be either formatted or unformatted.

   Records written to RMS files for  which  a  RECORDSIZE  value  has  been
   specified  cannot  be  larger  than  the size specified at file creation
   time.  Formatted records which are  shorter  are  padded  by  FOROTS  to
   RECORDSIZE with the character specified in PADCHAR before being written;
   unformatted records are padded with nulls.  Records which are larger are
   truncated with a warning.

   WRITEs to indexed files are  indistinguishable  from  normal  sequential
   WRITE  statements;   they need not (and must not) contain key-relational
   or key-of-reference data.  RMS examines the  record  being  written  and
   determines  the  position of the new record on the basis of the record's
   primary key.  New records cannot be larger than that specified  at  file
   creation time;  FOROTS pads shorter formatted records to RECORDSIZE with
   the character specified in PADCHAR.

   An indexed WRITE writes a new record;  REWRITE must be used to update an
   existing  record.   Each  new  record  in an indexed file must contain a
   complete primary  key.   Alternate  keys  may  be  partially  or  wholly
   missing.   RMS  does  not  make  an  entry  for  that  new record in the
   associated alternate indexes.



   2.2.7.1  Key Attributes -

   By default, FOROTS will create new indexed files with the "No duplicate"
   and "No change" attributes set for the primary index.  Secondary indexes
   default to duplicates and changes allowed.  Thus new records  containing
   a primary key which, when written, would produce a duplicate primary key
   in the index will cause an error message or the ERR= branch to be taken.
   Records  updated with REWRITE which result in a revised primary key will
   also produce an error.

   The default "No duplicate" attribute for primary  keys  can  be  changed
   only  in  a  USEROPEN routine.  RMS requires that primary keys cannot be
   changed.



   2.2.7.2  Writing Formatted INTEGER Keys -

   When performing a formatted WRITE to an indexed file containing  INTEGER
   key  data  types,  the  key  is  translated from internal binary form to
   external character form.  A subsequent attempt to read the record  using
   an integer key will produce unpredictable results.
Fortran-20 Version 11                                          Page 22


   2.2.8  REWRITE Statement -

   Transfers data from internal storage to the current record (that  record
   most  recently  accessed by a READ or FIND statement) of an indexed file
   or a relative file accessed sequentially.   REWRITE  statements  can  be
   formatted or unformatted:

      FORMATTED:

        REWRITE (un,fmt{,iostat}{,err}) {iolst}

      UNFORMATTED:

        REWRITE (un{,iostat}{,err}) {iolst}


   where un, fmt, iostat, err, and iolist are defined as in  Fortran  WRITE
   statements.   Note  that  WRITE  to  an indexed file always writes a new
   record.  If the primary key for the new  record  has  been  changed,  an
   error  will  result.   Records  written  with  REWRITE cannot exceed the
   length of the record they are updating, or an error will result.

   When compatibility flagging is used, this statement is  flagged  by  the
   compiler as an ANSI extension.



   2.2.9  DELETE Statement -

   Deletes records from RMS relative and indexed files.  It has the forms:

      Current-record DELETE:

        DELETE  ({UNIT=}un{,err}{,iostat})

      Direct-access DELETE:

        DELETE  ({UNIT=}un,REC=r{,err}{,iostat})

        DELETE  (un'r{,err}{,iostat})


   where un, r, err and iostat are defined as in Fortran WRITE statements.

   A current-record DELETE deletes the  last  record  from  an  indexed  or
   sequentially-accessed  relative  file sucessfully accessed by a previous
   READ or FIND statement.  The current-record DELETE is the only  form  of
   this statement permitted for indexed files.

   The direct-access DELETE is permitted only  for  direct-access  relative
   files.  It deletes the record specified by the number r.

   The DELETE statement logically removes the appropriate record  from  the
   specified  file  by  locating  the  record  and  marking it as a deleted
   record.  The position occupied by the deleted record  becomes  available
Fortran-20 Version 11                                          Page 23


   so that a new record can be written into that position.

   After a direct-access DELETE, any associate variable is set to the  next
   record number.

   The DELETE statement is illegal for RMS sequential and non-RMS files.

   When compatibility flagging is used, this statement is  flagged  by  the
   compiler as an ANSI extension.



   2.2.10  UNLOCK Statement -

   Unlocks a record in a relative or indexed file locked by a previous READ
   or FIND, without performing any other I/O operations.  It has the forms:

        UNLOCK ({unit=}un{,err}{,iostat})

        UNLOCK un

   where un, err and iostat are defined as in Fortran WRITE statements.

   If no record is locked, the operation has no effect.  This statement  is
   illegal for RMS sequential and non-RMS files.

   When compatibility flagging is used, this statement is  flagged  by  the
   compiler as an ANSI extension.



   2.2.11  RMS File-positioning Statements -

   The following file-positioning statements are available for use with RMS
   files.   Note  that  all  file-positioning  commands available for local
   non-RMS files are currently supported for remote non-RMS files.

    o  FIND -- This statement sets  the  ASSOCIATEVARIABLE  to  the  record
       number   specified   without   transferring   any   data.   For  VMS
       compatibility, a FIND for an RMS relative  file  will  position  the
       file at the record number specified, thus establishing the record as
       the current record, set the ASSOCIATEVARIABLE, and return.  The file
       on  the  specified  unit  must  be a relative file opened for direct
       access.

       This statement will continue to be flagged as an ANSI extension.

    o  REWIND - Positions an RMS sequential file,  or  a  sequential-access
       RMS  relative  file  at  its  initial  point.  As for non-RMS files,
       REWIND is illegal for files opened ACCESS='DIRECT'.

    o  ENDFILE - For RMS files,  ENDFILE  is  legal  only  for  files  with
       sequential  organization.   Its behavior for RMS sequential files is
       identical to non-RMS sequential files.
Fortran-20 Version 11                                          Page 24


    o  BACKSPACE - For RMS files, this statement repositions  a  file  with
       sequential  organization  to  the  beginning of the previous record.
       When the next I/O statement is executed, this  preceding  record  is
       available  for  processing.  This statement is illegal for RMS files
       opened with  ACCESS='APPEND',  or  with  ORGANIZATION='RELATIVE'  or
       'INDEXED'.


                                       NOTE

           If record/RFA caching is in effect (FORPRM parameter  CACHSZ
           is  non-zero -- the  default),  FOROTS  optimizes  BACKSPACE
           requests by searching a cache of  recently-accessed  records
           to  locate the target record's RFA.  If caching is disabled,
           or the cache does not contain  the  target  record  pointer,
           FOROTS  rewinds  the  file to its initial point and performs
           n-1 successive reads.



    o  SKIPRECORD - For both RMS and non-RMS files, this statement  retains
       its  present  function  of skipping the record immediately following
       the current (last accessed) record.  It is illegal for direct-access
       files.

       SKIPRECORD is permitted  for  RMS  indexed  files.   It  performs  a
       sequential  READ  on  the  current  index  as established by a prior
       indexed READ, or the primary index if never set.




   2.2.12  Network File Access -

   Fortran-20 V11.0 supports remote file access  to  the  following  remote
   operating/file systems:

   1.  Other TOPS-20 systems running RMS-20 V3.0 and RMSFAL version 1.

   2.  Remote VMS systems running RMS-32 Version 4.4 or later.


   Note that a remote TOPS-20 system must be running the RMSFAL distributed
   with RMS V3.0.



   2.2.12.1  Remote Filespecs -

   A remote filespec is a filespec  containing  a  node  name  and  network
   access information, in the following format:

     node::dev:<dir>file.ext{.gen;USERID:uid;PASSWORD:pswd;ACCOUNT:act}

Fortran-20 Version 11                                          Page 25


   There must be no spaces or tabs  in  a  remote  filespec.   The  network
   access   attributes  USERID,  PASSWORD,  and  ACCOUNT  may  be  optional
   depending on the default access privileges of the remote system or  file
   being  accessed.   If  network  access  attributes  are given, they must
   include both the USERID and PASSWORD.  DEVICE may be optional  depending
   on  the  defaults  in effect at the remote host.  For all remote access,
   RMS uses the default protection of the remote  system  when  creating  a
   file:  PROTECTION= is ignored.


                                     NOTE

       Logical names defined at the local host will not be expanded  or
       interpreted  by  Fortran/RMS  before  transmission to the remote
       host.





   2.2.12.2  Remote Links -

   A remote network link is established each  time  an  OPEN  statement  or
   INQUIRE-by-file  for  a remote file is performed.  The link remains open
   until the file is  closed  or  the  INQUIRE  statement  completes.   The
   maximum number of simultaneous open links available to a user process is
   a site-dependent monitor parameter.



   2.2.12.2.1  Reducing Network Overhead -

   A substantial part of the overhead associated with  remote  file  access
   consists  in  establishing  the  remote link.  Since a READ, READ, WRITE
   sequence for a file opened for read access will cause  FOROTS  to  close
   and  reopen  the  file  for  read/write  access, network overhead can be
   reduced by ensuring that remote files to be written to are  opened  with
   an  ACCESS  specifying  both  read  and  write  access.   Likewise, file
   specifications in CLOSE statements for remote files, which cause  FOROTS
   to  establish  a  link  for  a  network  rename operation, should not be
   routinely used unless a full remote rename is required.



   2.2.12.2.2  Data Transfers To/from VMS -

   FOROTS/RMS supports transparent data transfers to and from  VMS  systems
   for  all  formatted  data,  and for unformatted character data.  Numeric
   data transfers  are  not  supported.   DIL  (Data  Interchange  Library)
   routines,  or DIU (Data Interchange Utility) should be used to correctly
   exchange numeric data between TOPS-20 and VMS systems.
Fortran-20 Version 11                                          Page 26


   2.2.12.2.2.1  VMS Fortran Segmented Recordtype Files -

   VMS Fortran may write special  'segmented'  RMS  sequential  files  with
   embedded record control bytes as part of the data for each RMS record in
   the file (VMS Fortran RECORDTYPE='SEGMENTED').

   These files can be read correctly only from VMS  Fortran.   Attempts  to
   read  these  files  from a remote TOPS-20 system using Fortran-10/20 V11
   will return 2 bytes of control information as part of the data.



   2.2.13  RMS Error Reporting -

   I/O operations involving RMS  may  return  two  status  codes  when  RMS
   detects an error:

        STS     -       The main RMS error class for the error
        STV     -       A secondary status code which more specifically
                        defines or amplifies the reason for the error.


   Errors occuring during  remote  file  access  may  return  an  STV  code
   consisting  of a 2-part DAP MIC and MAC code which further describes the
   reasons for a network error  signal.   Refer  to  the  RMS  Programmer's
   Reference  Manual for an explanation of RMS error conditions and MIC/MAC
   codes.


   FOROTS treats RMS-returned errors as it would any other error condition.
   To assist in diagnosing and recovering from RMS errors, both the STS and
   STV codes are included in error messages resulting from  an  RMS  error.
   In  addition, the ERRSNS subroutine has been modified to accept a fourth
   argument, so that both STS and STV  codes  are  available  to  the  user
   program:

        CALL    ERRSNS (I,J,MSG,K)


   where I is returned with the first (FOROTS-class)  error  number,  J  is
   returned  with  the  STS code if the last error was an RMS error (or the
   FOROTS second error number if not), MSG is returned with the text of the
   message for the last error, and K is returned with the STV code (or zero
   if the last error was not an RMS error).  Note that all  four  arguments
   are required to return the STV.



   2.3  Single-character Object-Code Performance

   Previously,  the  code  generated  for  all  character  assignments  and
   relationals  is  a  call  to  a  library routine which uses the extended
   string instructions.  This version of Fortran  optimizes  this  code  by
   generating  inline  byte  instructions for single-character assignments,
   one of the more common kinds of character data  assignments.   Thus  the
Fortran-20 Version 11                                          Page 27


   assignment

                        A = B

   where A and B are both single-character, generates  the  following  code
   pattern:

                        LDB     R1,B
                        DPB     R1,A

   This code can be expected to increase runtime performance by a factor of
   3 or 4 over currently generated code performing the same assignment.

   Likewise for a relational such as (A.LT.B) where  A  and  B  are  single
   character, optimized code follows the pattern:

                        LDB     R1,A
                        LDB     R2,B
                        CAML    R1,R2




   2.4  Substring Support In FORDDT

   FORDDT previously lacked the ability to handle character  substrings  in
   ACCEPT,  TYPE  and  GROUP statements.  The version of FORDDT included on
   this tape supports the use of substring references  wherever  references
   to  character  data  are  allowed.   The syntax for specifying substring
   references in FORDDT is the same as for the compiler.



   3.0  RESTRICTIONS

   3.1  Utilities Which Do Not Support Long Symbols

   As noted in the section on Long Symbols, the overlay handler, GLOB,  and
   MAKLIB  do not support long-id .REL blocks generated by LINK.  There are
   no plans to modify these programs to provide such support.

   MACRO does not support long symbol names.  Therefore, the names of MACRO
   subroutines  called  from  a  Fortran  program cannot be longer than six
   characters.



   3.2  Numeric Data Exchange Between TOPS-20 And VMS Systems

   Unformatted numeric data I/O  between  TOPS-20  and  VMS  systems  using
   network  file access is not supported.  No error diagnostic is output at
   runtime, but the resulting conversion between 36 and  32  bits  produces
   indeterminate results.

   DIL (Data  Interchange  Library)  routines,  or  DIU  (Data  Interchange
Fortran-20 Version 11                                          Page 28


   Utility)  should  be  used  to  correctly  exchange numeric data between
   TOPS-20 and VMS systems.



   3.3  VMS Fortran Segmented Recordtype Files


   VMS Fortran may write special  'segmented'  RMS  sequential  files  with
   embedded record control bytes as part of the data for each RMS record in
   the file (VMS Fortran RECORDTYPE='SEGMENTED').

   These files can be read correctly only from VMS  Fortran.   Attempts  to
   read  these  files  from a remote TOPS-20 system using Fortran-10/20 V11
   will return 2 bytes of control information as part of the data.



   3.4  DBMS

   DBMS will not work in non-zero sections.  Since a section  zero  program
   which  invokes  RMS may cause sections 0 and 1 to be mapped together, no
   Fortran program which calls DBMS can also invoke RMS.



   4.0  KNOWN BUGS AND DEFICIENCIES

   None.



   5.0  COMPATIBILITY WITH PREVIOUS VERSIONS

   Fortran V11 will support programs that currently run under Fortran V10.



   6.0  INTERNAL CHANGES

   FOROTS, the compiler, and FORDDT have been modified to support  the  new
   features  that  are  in  this  release.  Complete revision histories are
   contained in REVHST.MAC (for the compiler), FORHST.MAC (for FOROTS), and
   FORDDT.MAC (for FORDDT).












                              APPENDIX A

                      RMS ARGUMENT BLOCK FIELDS



When RMS is invoked to access a file  on  a  particular  unit,  FOROTS
allocates  and  initializes the following RMS data structures for each
such unit:

      o  FAB - File Access Block

      o  RAB - Record Access Block

      o  XAB - Extended Attribute Block.  One or  more  are  allocated
         only if the file is indexed or remote.

In addition, a statically allocated NAM and TYP block are linked to  a
unit's FAB block during OPEN processing.

Values in these control structures are set or defaulted by Fortran  as
described below.  In addition, RMS may update these control structures
with information derived from the file after it is opened.

Unless an error intervenes, these data structures are not  deallocated
until  the  unit  is  closed.   User-written  subroutines and USEROPEN
functions may alter or examine field values in these  structures,  but
they  must  not  alter  their allocation.  Caution should be exercised
when changing fields that  have  been  set  as  a  result  of  Fortran
keywords  (e.g.   MRS  or FAC values), since unpredictable results may
occur during subsequent I/O.

The following RMS FAB, RAB and XAB fields are  either  initialized  by
Fortran  and/or examined upon return from an RMS service call.  Fields
not listed here take the RMS defaults, or are returned by RMS.
RMS ARGUMENT BLOCK FIELDS                                     Page A-2




                              FAB FIELDS:

---------------------------------------------------------------------------
Field   Name                    FORTRAN OPEN keyword/value
---------------------------------------------------------------------------
F$BSZ   Bytesize                n if BYTESIZE=n, else 7 for TOPS-20, 8 for
                                VMS files

F$CTX   Context                 Reserved for Digital

F$FAC   File access             Set at OPEN depending on STATUS, ACCESS
                                and READONLY or SHARED keywords.  Set to
                                FB$GET for read access files, else to
                                FB$GET+FB$PUT+FB$DEL+FB$UPD+FB$TRN

                                FB$BRO also for remote non-RMS files

F$FNA   File specification      FILE= filename + DEFAULTFILE= file name if
        string address          present, else FORnn.DAT if neither given

F$FOP   File-processing options

  FB$SUP Supersede              Set at OPEN depending on STATUS and
                                ACCESS keywords

  FB$DLT Delete on close        Set at CLOSE depending on DISPOSE keyword
                                in OPEN or CLOSE, or STATUS keyword in
                                CLOSE

  FB$SPL Spool to printer       Set at CLOSE depending on DISPOSE keyword
                                in OPEN or CLOSE, or STATUS keyword in
                                CLOSE

  FB$SCF Submit command         Set at CLOSE depending on DISPOSE keyword
                                in OPEN or CLOSE, or STATUS keyword in
                                CLOSE


F$MRS   Maximum record size     For RMS files, set to n if RECORDSIZE=n,
                                else to 0

F$MRN   Maximum record number   For RMS files, set to n if MAXREC=n, else
                                to 0

F$NAM   Name block address      Set to address of name block; both the
                                expanded and resultant string areas are
                                set up

F$TYP   Type block address      Set to address of type block for remote
                                non-RMS files. T$CLA is set to TY$IMA

F$ORG   File organization       FB$IDX if ORGANIZATION='INDEXED'
                                FB$REL if ORGANIZATION='RELATIVE'
RMS ARGUMENT BLOCK FIELDS                                     Page A-3


                                FB$SEQ if ORGANIZATION='SEQUENTIAL' or
                                omitted

F$RAT   Record attributes

  FB$BLK Do not cross page      1 if NOSPANBLOCKS
         boundaries

F$RFM   Record format           FB$FIX if RECORDTYPE='FIXED'
                                FB$VAR if RECORDTYPE='VARIABLE'
                                FB$STM if RECORDTYPE='STREAM'

                                FB$FIX if no RECORDTYPE and ORGANIZATION
                                is 'RELATIVE' or 'INDEXED'

F$SHR   File sharing

  FB$PUT Allow other PUTs       1 if SHARED
  FB$GET Allow other GETs       1 if SHARED
  FB$DEL Allow other DELETEs    1 if SHARED
  FB$UPD Allow other UPDATEs    1 if SHARED


F$XAB   Extended attribute      0 if the file is not indexed or is not
                                remote.  For all remote files, contains the
                                address of a Config XAB, whose X$NXT 
                                points to the beginning of the key XAB
                                chain, if any.  For local indexed files,
                                contains the address of the first key
                                XAB.



                              RAB FIELDS:

------------------------------------------------------------------------------
Field   Name                    FORTRAN OPEN keyword/value
------------------------------------------------------------------------------
R$BKT   Bucket code             Set to n during remote non-RMS processing

R$CTX   Context                 Reserved for Digital

R$FAB   FAB address             Set to address of file argument block

R$KBF   Key buffer address      Set to address of record number if
                                ACCESS='DIRECT' or address of key data
                                if ACCESS='KEYED'

R$KRF   Key of reference        Set to key of reference for indexed files

R$KSZ   Key size                Set to size of key for indexed files

R$MBF   Multibuffer count       n if BUFFERCOUNT=n, else 0

R$RAC   Record access mode      RB$KEY if ACCESS='DIRECT' or 'KEYED'
RMS ARGUMENT BLOCK FIELDS                                     Page A-4


                                RB$SEQ if ACCESS='SEQUENTIAL', 'APPEND'
                                or ACCESS is omitted
                
                                RB$BLK for remote non-RMS files

R$RBF   Record buffer address   Set during READ or WRITE

R$ROP   Record-processing options

  RB$EOF End-of-file            1 if ACCESS='APPEND'
  RB$KGE Key .GE.               1 if indexed READ
  RB$KGT Key .GT.               1 if indexed READ

R$RSZ   Record size             Set during READ and WRITE


R$UBF   User record area        Set during READ and WRITE
        address

R$USZ   User record area size   Set during READ and WRITE



The following KEY XAB fields are set by Fortran for indexed files:


                              XAB FIELDS:

------------------------------------------------------------------------------
Field   Name                    FORTRAN OPEN keyword/value
------------------------------------------------------------------------------
X$DTP   Key datatype            XB$STG if CHARACTER (default), else
                                XB$IN4 if INTEGER

X$FLG   Key options flags       XB$DUP!XB$CHG for each secondary index

X$REF   Key of reference        Set depending on OPEN KEY= position of
                                key specifier

X$POS   Key position            From OPEN KEY= specifier

X$SIZ   Key size                From OPEN KEY= specifier

X$NXT   Link address            Address of next XAB in chain, or 0


[End of FORTRA.DOC]
