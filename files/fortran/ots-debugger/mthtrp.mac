

	SEARCH	MTHPRM
	TV	MTHTRP	ARITHMETIC TRAP HANDLER,2(4017)
	SUBTTL	CHRIS SMITH/CKS/JLC/DAW		31-Jul-79

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1981, 1987
;ALL RIGHTS RESERVED.
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.

;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.

;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

COMMENT \

***** Begin Revision History *****

Modified from LIB40 TRAPS version 32A(444)

1100	CKS	10-Aug-79
	Rewrite for version 6
	Remove KA code and fixups for KA-format double precision instructions
	Add integer fixups (not enabled)
	Change UTRP instruction to JSR (can't use PUSHJ because DDT's stack
	 pointer is AC 1)
	Reorder stuff to optimize for SWTRP and UTRP
	Add fixups for G-format DP numbers

1217	JLC	09-Dec-80
	Fix integer divide check so it "patches" the answer

1464	DAW	12-May-81
	Error messages.

1466	CKS	18-May-81
	Use XSIR-format tables if the monitor supports them

1526	BL	9-Jul-81
	Make %PSIINI 'IF20'-conditional.

1531	JLC	10-Jul-81
	Typo in edit 1526.

1572	JLC	31-Jul-81	Q10-6348
	Setup F before calling trap error typeout.

1656	DAW	2-Sep-81
	Get rid of magic numbers.

1662	DAW	4-Sep-81
	New routine %CALU.

1700	BL	10-Sep-81
	Remove INTERN %CALU from 'IF20'.

1731	DAW	21-Sep-81
	Overflows not filling in the right stuff.

1753	DAW	29-Sep-81
	Don't call %TRACE on LERR's - PC is part of message now.

2033	DAW	19-Nov-81
	Don't do XSIR% unless FOROTS is running in a non-zero section;
	otherwise the Release 4 EXEC gets confused.

***** Begin Mathlib *****

3056	JLC	23-Mar-82
	Change the names of the error tables, add 1.

3122	JLC	29-Apr-82
	MATHLIB integration. Return to program if the instruction
	after the trapped one is JFCL with flag bits. If JFCL with
	no flag bits, do standard fixup and return to user program
	or address if address is specified. If other instruction,
	call error routine via $TCALL, which will print error
	message if not over message limit, and call a user trap
	routine (if specified) with the unfixed result and its type,
	allowing the user to supply a fixup.
	Removed the non-preferred trapping mechanisms for both
	TOPS-10 and TOPS-20, as the preferred methods (UTRP. on
	the -10 and SWTRP% on the -20) are both standard in the
	currently released monitors.

3203	JLC	27-May-82
	Fixed typo at NOCALU, TRNE was TRNN, so trap returned
	to AC0 instead of routine.

3204	JLC	2-Jun-82
	Removed ERR segment.

3205	JLC	3-Jun-82
	Moved the error character to the first argument in TERRs.

3211	JLC	26-Jun-82
	Fixed the documentation to reflect the separation of the
	data type and the "2nd error number" in the user subroutine
	call.

3213	JLC	20-Jul-82
	Save user's PDP in %ERPDP in trap processing, so that error
	processor can call GETPC to get module name.

3214	JLC	16-Aug-82
	Fix code at NOCLRF so it gets the original flags into PC
	for JRSTF. Turn off extraneous bits (namely, WRONGBIT) before
	using index into XLOAD and XSTORE.

3222	JLC	9-Nov-82
	Install patch to use APRENB instead of UTRP for the KS-10
	to avoid microcode/monitor bug which caused infinite loops
	in the overflow trap code.

3225	CKS	3-Jan-83
	Clear floating underflow PC flag when returning from underflow trap
	caught by JOV.  Otherwise, since the JOV only clears overflow, you
	get stray underflow flags left around.


***** Begin Version 1A *****

3243	BCM	29-Mar-83
	Get and clear PC flags with new GETFLG and RESFLG macros.  Fixes
	always clearing underflow in MTHTRP.  Only applies to JOV branches.

3252	MRB	27-Sep-83	10-34127
	Changed error message "integer overflow" to "Arithmetic
	integer overflow" to avoid confusion with "Input integer
	overflow".

***** End Revision History *****

***** Begin Version 2 *****

4006	JLC	27-Oct-83
	Removed edit 3252, as confusion is now removed by the
	word "Input" for the input overflows.

4013	JLC	12-Jun-84
	Added code to get XCT of a trapped instruction right most
	of the time.

4017	JLC	16-Jan-85
	Fix TOPS-10 extended addressing trap code.

\

	SEGMENT	CODE

	ENTRY	%TRPINI
	EXTERN	%TRFLG,%ERRPC,%UNFXD,%FIXED,%ERTYP,%ERPDP
	EXTERN	%ABORT

COMMENT	\

DESCRIPTION OF "TRAPS" PROGRAM FOR MATHLIB-

I. THE PURPOSE OF THE TRAPS PROGRAM IS DO ERROR DETECTION,
   CORRECTION, AND REPORTING WHEN ARITHMETIC FAULTS OCCUR
   DURING THE EXECUTION OF FORTRAN PROGRAMS.

II. THE TRAPS PROGRAM CONSISTS OF THREE DISTINCT PARTS:

	A. %TRPINI
		1. CALLING SEQUENCE- PUSHJ P,%TRPINI
		2. PROCESSOR AND MONITOR TRAPPING ON OVERFLOW (PC WORD
		      BIT 0) IS ENABLED

	B. ERRSET is a user-callable subroutine to set the conditions
	   for trap handling.

			CALL ERRSET (N)
		or	CALL ERRSET (N, I)
		or 	CALL ERRSET (N, I, SUBR)
	
		where	N = max number of error messages to type
	
			I = which error this call applies to.  One of:
			       -1 any of the following
				0 integer overflow
				1 integer divide check
				4 floating overflow
				5 floating divide check
				6 floating underflow

		 	if I is not specified, -1 is assumed
	
			SUBR = routine to call on the trap
	

	C. OVTRAP IS THE USER-MODE INTERRUPT ROUTINE WHICH IS STARTED
	   BY THE MONITOR WHEN AN ARITHMETIC FAULT OCCURS.
		1. The PC word (with the address+1 of the instruction
		      causing the trap) is stored in PC.
		2. FOR FLOATING POINT INSTRUCTIONS
			A. FOR OVERFLOWS AND DIVIDE CHECKS,
			   THE FAULTY ANSWER IS PATCHED
			   TO BE PLUS OR MINUS (THE SIGN WILL BE THAT
			   OF THE CORRECT ANSWER)THE LARGEST POSSIBLE
			   NUMBER.
			B. FOR UNDERFLOWS, THE FAULTY ANSWER IS NORMALLY
			   PATCHED TO BE 0. HOWEVER, IF THE INSTRUCTION
			   FOLLOWING THE TRAPPING INSTRUCTION IS A JFCL
			   WITH BIT 16 (XR2) SET, THE ANSWER WILL BE
			   UN-NORMALIZED ENOUGH TO BRING THE EXPONENT
			   BACK INTO RANGE.

		3. For integer instructions, no attempt is made to fix
		   up the faulty result. The problem is with the instructions
		   AOJX, AOSX, SOJX, and SOSX.  These can modify the PC
		   and overflow.  The new PC stored by the overflow trap
		   does not point to the instruction that overflowed, so
		   the recovery code will "fix" up a random instruction.  The
		   probability of this occurrence is small, but if it does
		   happen there is no way to limit the consequences.
		   The only available solution is to not touch any integer	
		   overflow.

		4. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS JFCL
		      A. DO NOT TYPE AN ERROR MESSAGE
		      B. DO NOT INCREMENT THE TRAP COUNTER ENTRY
		      C. IF ANY FLAG BITS ARE ON (9-12), IMMEDIATELY
			 RETURN TO THE PROGRAM WITHOUT CLEARING THE
			 FLAGS, AS IF THERE WERE NO TRAP HANDLER.
		      D. IF THE ADDRESS (BITS 18-35) OF THE JFCL
			 ARE NON-ZERO, THE INTERRUPTED PROGRAM WILL
			 BE RESTARTED AT THE ADDRESS OF THE JFCL
			 (THE @ AND INDEX FIELDS ARE IGNORED FOR
			 THE EFFECTIVE ADDRESS).
		      E. IF THE ADDRESS OF THE JFCL IS ZERO, THE
			 INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE JFCL

		5. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS NOT JFCL

		     A. INCREMENT THE TRAP COUNTER ENTRY
		     B. TYPE AN ERROR MESSAGE WITH THE FOLLOWING INFORMATION:
				FLOATING OR INTEGER FAULT
				OVERFLOW, UNDERFLOW, OR DIVIDE CHECK
				ADDRESS OF FAULTING INSTRUCTION
		     C. IF A USER SUBROUTINE SUBR IS SPECIFIED BY A PREVIOUS
			CALL TO ERRSET (SEE ABOVE), THE TRAP HANDLER
			SIMULATES A CALL TO THE SUBROUTINE:

			CALL SUBR (TRPNUM,PC,NUM2,VARTYP,UNFXD,FIXED)

			WHERE TRPNUM IS THE TRAP NUMBER, PC IS THE
			LOCATION OF THE TRAP RETURNED BY THE
			MONITOR (WHICH MAY BE THE ADDRESS OF AN
			XCT OR UUO WHICH THEN EXECUTED THE ACTUAL
			INSTRUCTION TRAPPED), NUM2 IS A 2ND ERROR NUMBER
			RESERVED FOR FUTURE USE, VARTYP IS THE TYPE CODE
			OF THE VARIABLE MODIFIED BY THE TRAPPED 
			INSTRUCTION, UNFXD IS THE UNFIXED VALUE
			OF THE VARIABLE, AND FIXED IS THE FORTRAN
			FIXED VALUE. FORTRP USES THE VALUE RETURNED
			IN FIXED, SO THAT THE USER MAY SUBSTITUTE
			FOR THE FORTRAN FIXUP. NOTE THAT WHILE INTEGER
			OVERFLOWS ARE TRAPPED, FIXUPS ARE NOT DONE.
			(SEE NOTE ABOVE REGARDING INTEGER INSTRUCTIONS.)

		     D. THE INTERRUPTED PROGRAM WILL BE RESTARTED AT
			THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION

		     E. THE PROCESSOR FLAGS (PC WORD FLAGS) ARE CLEARED
			EXCEPT FOR CRY0, CRY1, AND USER IOT.

		     F. THE INTERRUPTED PROGRAM IS RESTARTED
III. LIMITATIONS


	A.  Fixups are not made for KA-format double precision
		numbers.  The instructions FADL, FSBL, FMPL, FDVL,
		UFA, and DFN are not recognized as requiring fixups.

	B. THE MEMORY FIX UPS FOR THE FLOATING POINT INSTRUCTIONS
	   WILL NOT WORK PROPERLY IF THE ANSWER IS STORED INDEXED
	   BY 17 (THE PUSH DOWN POINTER). EXAMPLES:

			FADRM AC,(17)
			FMPRB AC,-2(17)
			FDVM  AC,+1(17)

	C. MOVNX and MOVMX are integer instructions and will have
	   get integer fixups if they cause overflow.  These
	   instructions can't overflow when dealing with normalized
	   floating point numbers.

	D. THE TRAPPING INSTRUCTION MUST NOT BE IN AC 0.

	F. THE SIGN OF F.P. DIVIDE CHECK FIX UPS WILL BE CORRECT
	    ONLY WHEN DIVIDING BY ZERO. (THIS IMPLIES THAT THE
	    ARGUMENTS FOR DIVIDE CHECKS SHOULD BE NORMALIZED.)

\

;PC FLAGS

;THESE FLAGS SHOULD BE DEFINED IN FORPRM INSTEAD
UBITS==PC%USR+PC%UIO		;FOR NOW, THE FLAGS WE WANT NOT
				;TO TURN OFF. WE REALLY
				;WANT TO JUST TURN OFF
				;THE FLAGS WE ARE INTERESTED IN


;ENTRY POINT TO INITALIZE TRAP HANDLER

%TRPINI:
	XMOVEI	T1,.		;Get section number
	HLLZM	T1,MSECT	;SAVE SECTION NUMBER OF TRAP HANDLER
	TLNN	T1,-1		; Are we running in section 0?
	 JRSTF	@[UBITS+SETRAP] ;YES. DO JRSTF TO CLEAR FLAGS
	XMOVEI	T1,SETRAP	;Place to go
	MOVEM	T1,TRPBLK+1	;Save in 2nd word
	MOVE	T1,[UBITS]	;Flags
	MOVEM	T1,TRPBLK	;Save in 1st word
	XJRSTF	TRPBLK		;** Clear arithmetic flags **

IF20,<
SETRAP:	XMOVEI	T1,OVTRP	;SET TRAP ADDRESS IN CONTROL BLOCK
	MOVEM	T1,NPC

	MOVEI	T1,.FHSLF	;THIS FORK
	MOVEI	T2,.SWART	;SET ARITHMETIC TRAP ADDRESS
	XMOVEI	T3,TRPBLK	;POINT TO CONTROL BLOCK
	SWTRP%			;TELL MONITOR
	POPJ	P,		;DONE

> ;END IF20

IF10,<

; This code is to alleviate a problem caused by a 
; microcode bug in the KS processor running under
; TOPS-10. It should be removed when the problem 
; has been corrected (don't hold your breath).
; The code will check to see
; if the processor type is a KS10, then use the
; APRENB trapping to avoid the problem with UTRP.

SETRAP:	MOVE	T1,[%CCTYP]	;get processor type from
	GETTAB	T1,		; the CPU data constants
	 JRST	NUTRP		;CAN'T FAIL
	MOVEI	T1,(T1)		;get just right half
	CAIN	T1,.CCKSX	;if the processor is a KS
	 JRST	NUTRP		;then use APRENB trapping.

	MOVE	T1,[JRST OVINT]	;SET UP JRST TO HIGH SEG
	MOVEM	T1,LTRAP+1	;STORE IN WRITABLE MEMORY FOR JSR

	MOVE	T1,[1,,[2	;SET TRAP,,BLOCK LENGTH
			.UTAOF	;TRAP ON ARITHMETIC OVERFLOW
			JSR LTRAP]] ;INSTRUCTION TO EXECUTE ON TRAP
	UTRP.	T1,		;SET INSTRUCTION TO EXECUTE
	 JRST	NUTRP		;TOO BAD, NO TRAPPING

	POPJ	P,		;DONE

;APRENB TRAPPING. USE ONLY IF WE'RE ON A KS OR UTRP DOESN'T WORK.
NUTRP:	MOVEI	T1,APRTRP	;GET TRAP ADDRESS
	HRRZM	T1,.JBAPR	;STORE IN JOBDAT
	MOVEI	T1,AP.REN+AP.AOV+AP.FOV	;TRAP ON OVERFLOW
	APRENB	T1,		;ENABLE TRAPS
	POPJ	P,		;DONE


;HERE FROM MONITOR ON APRENB TRAP
;MOVE PC TO WHERE UTRP WOULD HAVE PUT IT

APRTRP:	PORTAL	.+1		;OK TO ENTER HERE FROM PUBLIC PAGE
	DMOVEM	T0,ACS		;SAVE T0-T1
	MOVE	T0,.JBTPC	;GET TRAP PC
	MOVEM	T0,LTRAP	;STORE IT IN RIGHT PLACE
	JRST	OVZERO		;JOIN UTRP CODE

;HERE FROM JSR ON DIRECT OVERFLOW TRAP

;[4013] NEW CODE
OVINT:	PORTAL	.+1		;OK TO ENTER HERE FROM PUBLIC PAGE
	DMOVEM	T0,ACS		;SAVE T0-T1
	SKIPN	MSECT		;SHOULD WE BE IN A NON-ZERO SECTION?
	 JRST	OVZERO		;NO
	XMOVEI	T0,0		;ARE WE ALREADY THERE?
	JUMPN	T0,OVNONZ	;YES

	MOVE	T0,MSECT	;GET SECTION # OF TRAP HANDLER
	HRRI	T0,OVNONZ	;AND ADDRESS OF A PLACE TO GO
	XJRST	T0		;AND GO THERE

> ;END IF10

;THIS CODE ATTEMPTS TO GET ALL THE DATA THAT THE SWTRP JSYS GETS
;ON TOPS-20. THE COMPLICATED PART IS THE CALCULATION OF THE EFFECTIVE
;ADDRESS OF THE TRAPPED INSTRUCTION. THIS IS DONE BY GETTING THE LOCAL
;(18-BIT) ADDRESS FROM THE TRAPPED INSTRUCTION, THEN MOVING THE INDIRECT
;AND INDEX BITS TO THEIR PLACE IN EFIW FORMAT, AND USING AN INDIRECTED
;XMOVEI INSTRUCTION TO CALCULATE THE EFFECTIVE ADDRESS (THIS MUST BE
;DONE BECAUSE THE TRAPPED INSTRUCTION MAY, IN FACT, BE IN A DIFFERENT
;SECTION THAN THE TRAP HANDLER). NOTE THAT IF THE TRAPPED INSTRUCTION IS
;INDEXED, THE INDEX REGISTER MUST BE EXAMINED TO SEE IF IT CONTAINS A
;SECTION NUMBER. IF IT DOES, THE Y FIELD OF THE TRAPPED INSTRUCTION IS
;AN OFFSET, AND THUS DOES NOT GET A SECTION NUMBER ATTACHED TO IT IN
;THE EFFECTIVE ADDRESS CALCULATION.
OVNONZ:	SFM	FLGS		;SAVE FLAGS WHERE THEY BELONG
	MOVE	T0,LTRAP	;NON-ZERO SECTION. GET PC
	MOVEM	T0,PC		;SAVE IT
	SUBI	T0,1		;DECREMENT TO POINT AT TRAP INSTRUCTION
	MOVE	T0,@T0		;GET TRAP INSTRUCTION
XCTNZ:	HLRM	T0,INST		;[4017] STORE TRAP INSTRUCTION
	HRRZM	T0,INDADR	;SAVE LOCAL ADDRESS OF TRAPPED INST
	HLLZ	T0,T0		;TOSS THE LOCAL ADDRESS
	TLZ	T0,777740	;CLEAR THE INSTRUCTION AND AC FIELDS
	LSH	T0,^D12		;MOVE IND,IDX TO EFIW FIELDS
	MOVEM	T0,INDTMP	;[4017] SAVE IND, IDX FIELDS
	TLZ	T0,200000	;[4017] CLEAR IND FIELD
	JUMPN	T0,NZIDX	;IF INDEX, GO CHECK INDEX REGISTER
	HRRZ	T0,INDADR	;NO INDEXING. GET LOCAL ADDRESS AGAIN
	CAILE	T0,17		;IS IT AN AC?
	 JRST	NZGSN		;NO. USE PC-SECTION
	HRLI	T0,1		;YES. GET AC GLOBAL ADDRESS
	JRST	GETEA		;AND GO CALCULATE EFFECTIVE ADDRESS

NZIDX:	XMOVEI	T0,@T0		;[4017] GET INDEX REG
	TLZN	T0,-1		;[4017] IS IT EXTENDED REG?
NZGSN:	 IOR	T0,PC		;[4017] NO. GET SECTION NUMBER IN LEFT HALF
GETEA:	IOR	T0,INDTMP	;[4017] GET IND, IDX AGAIN
	HLLM	T0,INDADR	;SAVE EFIW IND, IDX, AND SECTION NUMBER
	MOVE	T0,ACS		;GET SAVED T0
	XMOVEI	T0,@INDADR	;DO EACALC
	MOVEM	T0,E		;SAVE EFFECTIVE ADDRESS OF TRAPPED INST
	JRST	OVTRAP		;JOIN COMMON CODE

OVZERO:	MOVE	T0,LTRAP	;GET TRAP PC AND FLAGS
	HLLZM	T0,FLGS		;SAVE FLAGS
	HRRZM	T0,PC		;AND PC
	SUBI	T0,1		;DECREMENT TO POINT AT TRAP INSTRUCTION
	MOVE	T0,@T0		;GET TRAP INSTRUCTION
	HLRM	T0,INST		;STORE TRAP INSTRUCTION
	MOVEI	T0,@T0		;GET EFFECTIVE ADDRESS
	MOVEM	T0,E		;SAVE IT
	JRST	OVTRAP		;JOIN COMMON CODE


;HERE ON OVERFLOW TRAP WITH TRPBLK FILLED IN

OVTRP:	DMOVEM	T0,ACS		;SAVE T0-T1

;CHECK HERE IF WE GOT A TRAP WITHIN A TRAP ROUTINE (FATAL).
OVTRAP:	MOVEM	P,%ERPDP	;SAVE CURRENT PDP FOR ERROR REPORTING
	MOVE	T0,PC		;GET PC OF TRAP + 1
	SUBI	T0,1		;GET PC OF TRAP
	MOVEM	T0,%ERRPC	;SAVE FOR ERROR REPORTING
	SKIPE	%TRFLG		;WERE WE IN A TRAP ALREADY?
	 $TCALL	TDT,%ABORT	;TRAP DURING TRAP PROCESSING

;[3122]CHECK THE INSTRUCTION AFTER THE TRAPPED ONE. IF IT IS
;JFCL WITH FLAGS, RETURN TO THE USER PROGRAM WITHOUT TURNING
;OFF THE FLAGS.
TRAPOK:	HLRZ	T0,@PC		;GET INSTRUCTION AFTER TRAP
	TRZ	T0,37		;SHUT OFF I AND X
	TRZN	T0,740		;ANY AC BITS?
	 JRST	NOTJF		;NO. CAN'T BE JFCL WITH FLAGS
	CAIE	T0,(JFCL)	;[3243] YES. IS IT A JFCL?
	 JRST	NOTJF		;[3243] NO, GO HANDLE THE TRAP
	DMOVE	T0,ACS		;[3243] YES, RESTORE ACS AND RETURN NOW
	JRST	@PC		;[3243] WITHOUT SETTING ANY FLAGS

NOTJF:	SETOM	%TRFLG		;SET FLAG FOR INSIDE TRAP ROUTINE
	DMOVEM	T2,ACS+T2	;SAVE T2-T3
	LDB	T1,[POINT 9,INST,26] ;GET OPCODE OF TRAP INSTRUCTION
	CAIL	T1,100		;OUTSIDE TABLE RANGE?
	CAILE	T1,377
	  MOVEI	T1,100		;YES, SET TO INNOCUOUS TABLE ENTRY
	IDIVI	T1,4		;4 BYTES PER WORD
	LDB	T1,BPTAB(T2)	;GET FLAG BITS FOR THIS INSTRUCTION
	JUMPE	T1,XRET		;INSTRUCTION CAN'T OVERFLOW, DON'T TRY FIXUPS

	LDB	T2,[POINT 4,INST,30] ;GET AC FIELD OF INSTRUCTION
	CAIG	T2,T3		;DOES INST USE ACS T0-T3?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE TO SAVED ACS
	MOVEM	T2,AC		;SAVE AC ADDRESS OF INSTRUCTION

	MOVE	T2,E		;GET EFFECTIVE ADDRESS
	CAIG	T2,T3		;IN SAVED ACS?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE
	MOVEM	T2,E

	CAIE	T1,SP		;SPECIAL INSTRUCTION?
	  JRST	SPCONT		;NO. NORMAL INST

;SPECIAL CASES (EXTEND INSTRUCTIONS, XCT)
;[3122] FOR FIX, FIXR, PUT THE UNFIXED RESULT (A REAL VALUE) IN THE AC

SPINST:	LDB	T1,[POINT 9,INST,26] ;GET OPCODE AGAIN
	CAIN	T1,(<XCT>B9)	;XCT INSTRUCTION?
	  JRST	SPXCT		;YES, GO HANDLE
	CAIN	T1,(<EXTEND>B9)	;EXTEND?
	 JRST	SPEXT		;YES

;MUST BE A FIX OR FIXR
SPFIX:	MOVE	T0,@E		;GET THE UNFIXED QUANTITY
	MOVEM	T0,@AC		;PRETEND THE AC GOT THE UNFIXED VALUE
	MOVEI	T1,SPRA		;TELL THE USER IT'S A REAL VALUE
	JRST	SPCONT		;AND CONTINUE

SPEXT:	MOVE	T1,ACS+T1	;RESTORE NONZERO ACS
	DMOVE	T2,ACS+T2
	MOVE	T0,@E		;GET EXTENDED INST
	XMOVEI	T1,@T0		;GET ITS EFFECTIVE ADDRESS
	CAIG	T1,T3		;IN SAVED ACS?
	 XMOVEI	T1,ACS(T1)	;YES, RELOCATE
	MOVEM	T1,E		;Store real E

	LDB	T1,[POINT 9,T0,8] ;GET EXTEND OPCODE
	CAIL	T1,020		;OUTSIDE TABLE RANGE?
	CAILE	T1,031
	  MOVEI	T1,020		;YES, SET TO INNOCUOUS TABLE ENTRY
	ADDI	T1,400-020	;OFFSET TO END OF MAIN TABLE
	IDIVI	T1,4		;9 BYTES PER WORD
	LDB	T1,BPTAB(T2)	;GET FLAG BITS FOR INSTRUCTION
	JUMPE	T1,XRET		;IF INST CAN'T OVERFLOW, DON'T TRY FIXUP

	TRZN	T1,WRONGBIT	;DOES INST LEAVE RESULT IN WRONG OPERAND?
	  JRST	SPCONT		;NO, FINE
	MOVE	T0,@E		;GET OPERAND
	MOVEM	T0,@AC		;STORE IN AC FOR SIGN FIXUP
	JRST	SPCONT		;GO CONTINUE AS IF NORMAL INST

SPXCT:	DMOVE	T0,ACS		;RESTORE ACS
	DMOVE	T2,ACS+T2
	MOVE	T0,@E		;GET XCTED INST
	SKIPE	MSECT		;[4013]NON-ZERO SECTION?
	 JRST	XCTNZ		;[4013]YES. MUST BE HANDLED MORE CAREFULLY
	XMOVEI	T1,@T0		;GET ITS EFFECTIVE ADDRESS
	CAIG	T2,T3		;IN SAVED ACS?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE
	HLRM	T0,INST		;STORE INST
	MOVEM	T1,E		;Store E
	JRST	OVTRAP		;START OVER


;[3122] SAVE THE UNFIXED RESULT IN %UNFXD
SPCONT:	MOVEI	T2,(T1)		;COPY FLAGS, ARG TYPE
	LSH	T2,-4		;GET JUST FLAGS
	ANDI	T2,7		;TURN OFF EXTRA BITS
	XCT	XLOAD(T2)	;GET UNFIXED RESULT
	DMOVEM	T2,%UNFXD	;SAVE FOR USER CALL
	HLLZ	T0,FLGS		;GET PC FLAGS
	TLNN	T0,(PC%FUF)	;FLOATING UNDERFLOW?
	  JRST	OV		;NO, GO HANDLE OVERFLOW

REPEAT 0,<
	MOVE	T2,@PC		;GET INSTRUCTION AFTER TRAP INST
	TLC	T2,(JFCL (2))	;IS IT A JFCL (2)?
	TLNN	T2,777002
	  JRST	UNNORM		;YES, GO UNNORMALIZE RESULT
> ;END REPEAT 0

	SETZB	T2,T3		;SET FIXED-UP VALUE TO 0
	JRST	STRET		;DONE

REPEAT 0,<

;THIS CODE HAS BEEN RECODED AND MOVED TO MODULE UNNORM IN MTHSNG, SINCE
;THE USER NOW HAS ACCESS TO THE UNFIXED AND FIXED-UP RESULTS
;VIA ERRSET.
UNNORM:	MOVEI	T2,(T1)		;COPY FLAGS AND TYPE CODE
	LSH	T2,-4		;GET JUST FLAGS
	ANDI	T2,7		;TURN OFF EXTRA BITS
	XCT	XLOAD(T2)	;GET RESULT STORED BY THE HARDWARE, HAS
				;CORRECT FRACTION AND EXPONENT TOO LARGE
				;BY 400
	PUSH	P,T1		;SAVE T1
	HLRE	T1,T2		;GET EXPONENT AND SIGN AND SOME FRACTION BITS
	ASH	T1,-9		;GET RID OF FRACTION BITS
	TSCE	T1,T1		;GET ABS(EXPONENT), SKIP IF POSITIVE FRACTION
	  TLOA	T2,777000	;NEGATIVE FRACTION, SET EXPONENT TO ALL ONES
	TLZ	T2,777000	;POSITIVE FRACTION, SET EXPONENT TO ALL ZEROS
	CAME	T1,[377,,377]	;SUPPRESS ZERO-BIT SHIFT (-0 IS -256)
	  ASHC	T2,400001(T1)	;UNNORMALIZE FRACTION, KEEP 1 BIT FOR ROUNDING
	POP	P,T1		;GET FLAG BITS BACK
	TRNE	T1,DPBIT	;WAS TRAP INSTRUCTION DOUBLE PRECISION?
	  JRST	DROUND		;YES, GO ROUND DP NUMBER
	ADDI	T2,1		;ROUND HIGH WORD OF FRACTION
	ASH	T2,-1		;DISCARD ROUNDING BIT
	JRST	STRET		;DONE

DROUND:	TLO	T3,(1B0)	;PREVENT INTEGER OVERFLOW WHEN WE ROUND
	ADDI	T3,1		;ROUND LOW WORD
	TLZN	T3,(1B0)	;DID FRACTION OVERFLOW INTO SIGN BIT?
	  ADDI	T2,1		;YES, PROPAGATE CARRY TO HIGH WORD
	ASHC	T2,-1		;DISCARD ROUNDING BIT
	JRST	STRET		;DONE

> ;END REPEAT 0


;HERE ON FLOATING & INTEGER OVERFLOW AND DIVIDE CHECK

OV:	TLNE	T0,(PC%NDV)	;NO DIVIDE?
	  JRST	DIVCHK		;YES. CHECK FOR 0/0
	TLNN	T0,(PC%FOV)	;NO. FLOATING OVERFLOW?
	  JRST	INTRET		;NO. INTEGER FIXUP IS DANGEROUS
	JRST	NDVCHK		;YES. GO ON WITH FIXUP

DIVCHK:	SKIPE	@AC		;DIVIDE BY ZERO. ZERO DIVIDEND?
	 JRST	NDVCHK		;NO.
	SETZB	T2,T3		;SET FIXED-UP VALUE TO 0
	JRST	STRET

NDVCHK:	TRNN	T1,ACBIT	;DID INST STORE ITS RESULT IN THE AC?
	TLNE	T0,(PC%NDV)	;YES, NO-DIVIDE, WHICH STORES NO RESULT?
	  SKIPA	T2,@AC		;NO, GET RESULT FROM AC
	MOVE	T2,@E		;ELSE GET RESULT FROM E

	TRZE	T1,WRONGBIT	;DID INST STORE WRONG SIGN?
	  TLC	T2,(1B0)	;YES, SET CORRECT SIGN

	JUMPL	T2,NEGOV	;IF CORRECT ANSWER NEGATIVE, GO SET -INF
	DMOVE	T2,[OCT 377777777777,377777777777] ;GET +INFINITY
	JRST	STRET

NEGOV:	TLNN	T0,(PC%FOV)	;FLOATING OVERFLOW?
	  JRST	INTOV		;NO, USE INTEGER -INFINITY

	MOVN	T2,[OCT 377777777777] ;FLOATING, GET FLOATING -INFINITY
	TRNE	T1,DPBIT	;WAS INSTRUCTION DOUBLE PRECISION?
	  DMOVN	T2,[OCT 377777777777,377777777777] ;YES, GET IT IN DP
	JRST	STRET		;GO STORE RESULT AND RETURN

INTOV:	DMOVE	T2,[OCT 400000000000,0] ;GET INTEGER -INFINITY

;[3122]CALL TCALU, WHICH IF THE INSTRUCTION FOLLOWING THE TRAPPED
;INSTRUCTION IS NOT A JFCL, ISSUES THE ERROR MESSAGE (IF NOT OVER THE
;MESSAGE LIMIT) AND CALLS THE USER-SPECIFIED TRAP SUBROUTINE (IF ANY);
;THEN USE THE RETURNED VALUE OF %FIXED (WHICH WILL BE UNTOUCHED IF
;THE USER DOESN'T DO ANYTHING TO IT).
STRET:	DMOVEM	T2,%FIXED	;STORE FIXED RESULT
	PUSHJ	P,TCALU		;CALL USER TRAP ROUTINE
	DMOVE	T2,%FIXED	;GET FIXED RESULT
	LSH	T1,-4		;TOSS DATA TYPE, JUST GET FLAGS
	ANDI	T1,7		;TURN OFF EXTRA BITS
	XCT	XSTORE(T1)	;STORE ANSWER

;RESTORE SOME ACS, CLEAR THE PC FLAGS
XRET:	DMOVE	T2,ACS+T2	;RESTORE T2-T3
	MOVSI	T1,(PC%OVF+PC%FOV+PC%FUF+PC%NDV) ;CLEAR OV, FOV, FUF, NDV
	ANDCAB	T1,FLGS
	SETZM	%TRFLG		;WE ARE NO LONGER IN A TRAP
	HLLZ	T0,PC		;GET LH OF PC+1 OF TRAPPED INST
	JUMPE	T0,XRET0	;NOT AN EXTENDED ADDRESSING TRAP
	DMOVE	T0,ACS		;RESTORE T0-T1
	XJRSTF	FLGS		;Return to user.

XRET0:	HLLM	T1,PC		;STORE FLAGS FOR JRSTF
	DMOVE	T0,ACS		;RESTORE T0-T1
	JRSTF	@PC

;INTEGER OVERFLOW RETURN - CALL TCALU TO ISSUE THE ERROR MSG AND
;CALL THE USER-SPECIFIED ROUTINE, BUT DO NOT USE THE FIXED-UP RESULT.
INTRET:	SETZM	%FIXED		;SET FIXED-UP VALUE TO 0
	SETZM	%FIXED+1
	PUSHJ	P,TCALU		;CALL USER ROUTINE
	JRST	XRET		;DON'T USE FIXED-UP VALUE

;[3122] IF THE INST AFTER THE TRAP IS A JFCL WITH NO FLAGS, PROCEED TO DO
;THE STANDARD FORTRAN FIXUP. OTHERWISE, PRINT A MESSAGE AND
;CALL A USER TRAP ROUTINE VIA $TCALL.
TCALU:	MOVE	T0,@PC		;GET INSTRUCTION AFTER TRAP
	TLC	T0,(JFCL)	;SEE IF IT'S JFCL
	TLNN	T0,777000	;IS IT?
	 JRST	NOCALU		;YES. DON'T PRINT MSG OR CALL USER
	MOVEI	T2,(T1)		;GET FLAGS AGAIN
	ANDI	T2,17		;GET VARIABLE TYPE
	MOVEM	T2,%ERTYP	;SAVE FOR USER CALL
	SETZ	T2,		;CREATE AN INDEX
	MOVE	T0,FLGS		;TESTING THE FLAGS
	TLNE	T0,(PC%NDV)	;NO-DIVIDE?
	 TRO	T2,1		;YES
	TLNE	T0,(PC%FUF)	;FLOATING UNDERFLOW?
	 TRO	T2,2		;YES
	TLNE	T0,(PC%FOV)	;FLOATING OVERFLOW?
	 TRO	T2,4		;YES
	XCT	TCALTB(T2)	;DO MESSAGE CALL
	POPJ	P,

NOCALU:	TRNE	T0,-1		;ADDR IN JCFL?
	 HRRM	T0,PC		;YES. RETURN TO THAT ADDR
	POPJ	P,


	SEGMENT	DATA

IF20,<
;SWTRP BLOCK, FILLED IN BY MONITOR OR MICROCODE ON OVERFLOW TRAP

LTRAP:				;NON-FUNCTIONAL. HERE FOR COMPATIBILITY

TRPBLK:
FLGS:				;LH = PC FLAGS
INST:	BLOCK	1		;RH = LH(TRAP INSTRUCTION)
PC:	BLOCK	1		;PC+1 OF TRAP INSTRUCTION
E:	BLOCK	1		;E OF TRAP INSTRUCTION
NPC:	BLOCK	1		;NEW PC TO USE AT TRAP

>;END IF20
IF10,<

TRPBLK:
LTRAP:	BLOCK	2		;JSR HERE ON OVERFLOW

FLGS:
INST:	BLOCK	1		;RH = LH(TRAP INSTRUCTION)
PC:	BLOCK	1		;PC+1 OF TRAP INSTRUCTION
E:	BLOCK	1		;ITS EFFECTIVE ADDRESS

>;END IF10


MSECT:	BLOCK	1		;SECTION NUMBER OF TRAP HANDLER
INDADR:	BLOCK	1		;TRAPPED INST IND,IDX,E IN EFIW FORMAT
INDTMP:	BLOCK	1		;TEMP INDIRECT AND INDEX OF TRAPPED INST
AC:	BLOCK	1		;AC FIELD OF TRAP INSTRUCTION
ACS:	BLOCK	4		;TEMP SPACE FOR T0-T3

	SEGMENT	CODE

;FLAG BITS FOR EVERY INSTRUCTION THAT CAN OVERFLOW
;[3122] EXPANDED THE FLAG BYTE FOR EACH INSTRUCTION TO 9 BITS,
;TO ALLOW FOR THE VARIABLE TYPE CODE AND FOR A NEW BIT, NOT YET
;IMPLEMENTED, FOR THE AOS/SOS-CLASS INSTRUCTIONS, WHICH LEAVE
;THE RESULT IN MEMORY AND AN AC IF A NON-ZERO AC IS SPECIFIED.
;THIS IS NOT A PROBLEM FOR THE CURRENT PROCESSORS, SINCE INTEGER
;FIXUPS CANNOT BE DONE RELIABLY (SEE NOTES AT BEGINNING OF MODULE).

	DPBIT==1*20		;1 IF INST STORES 2-WORD RESULT
	ACBIT==2*20		;1 IF INST STORES RESULT IN AC
	MEMBIT==4*20		;1 IF INST STORES RESULT IN MEMORY
	WRONGBIT==10*20		;1 IF INST STORES RESULT WITH WRONG SIGN,
				;  FOR EXTEND MEANS RESULT NOT STORED IN AC
	BOTHBT==ACBIT+MEMBIT	;RESULT STORED IN BOTH AC AND MEMORY
	NZACBT==4*20		;1 IF INST STORES RESULT IN BOTH IF AC NONZERO
				;NOT HANDLED, AS INTEGER OVERFLOWS AREN'T FIXED

	SPRA==TP%SPR+ACBIT	;SINGLE PRECISION REAL, RESULT IN AC
	SPRM==TP%SPR+MEMBIT	;SINGLE REAL, RESULT IN MEMORY
	SPRB==TP%SPR+BOTHBT	;SINGLE REAL, RESULT IN BOTH
	INTA==TP%INT+ACBIT	;INTEGER, RESULT IN AC
	INTM==TP%INT+MEMBIT	;INTEGER, RESULT IN MEMORY
	INTB==TP%INT+BOTHBT	;INTEGER, RESULT IN BOTH
	DPIA==TP%DPI+ACBIT+DPBIT  ;DOUBLE INTEGER, RESULT IN AC
	DPIM==TP%DPI+MEMBIT+DPBIT ;DOUBLE INTEGER, RESULT IN MEMORY
	DPIB==TP%DPI+BOTHBT+DPBIT ;DOUBLE INTEGER, RESULT IN BOTH
	DPRA==TP%DPR+ACBIT+DPBIT  ;DOUBLE REAL, RESULT IN AC
	DPRM==TP%DPR+MEMBIT+DPBIT ;DOUBLE REAL, RESULT IN MEMORY
	DPRB==TP%DPR+BOTHBT+DPBIT ;DOUBLE REAL, RESULT IN BOTH
	DPXA==TP%DPX+ACBIT+DPBIT  ;GDOUBLE REAL, RESULT IN AC
	DPXM==TP%DPX+MEMBIT+DPBIT ;GDOUBLE REAL, RESULT IN MEMORY
	DPXB==TP%DPX+BOTHBT+DPBIT ;GDOUBLE REAL, RESULT IN BOTH
	SPRAW==SPRA+WRONGBIT	;SPRA, RESULT HAS WRONG SIGN
	SPRMW==SPRM+WRONGBIT	;SPRM, RESULT HAS WRONG SIGN
	SPRBW==SPRB+WRONGBIT	;SPRB, RESULT HAS WRONG SIGN
	INTAW==INTA+WRONGBIT	;INTA, RESULT HAS WRONG SIGN
	INTMW==INTM+WRONGBIT	;INTM, RESULT HAS WRONG SIGN
	INTBW==INTB+WRONGBIT	;INTB, RESULT HAS WRONG SIGN
	INTNW==TP%INT+WRONGBIT+NZACBT	;INTEGER, WRONG SIGN, RESULT IN
					;BOTH IF NON-ZERO AC
	DPIAW==DPIA+WRONGBIT	;DPIA, RESULT HAS WRONG SIGN
	DPIMW==DPIM+WRONGBIT	;DPIM, RESULT HAS WRONG SIGN
	DPIBW==DPIB+WRONGBIT	;DPIB, RESULT HAS WRONG SIGN
	DPRAW==DPRA+WRONGBIT	;DPRA, RESULT HAS WRONG SIGN
	DPRMW==DPRM+WRONGBIT	;DPRM, RESULT HAS WRONG SIGN
	DPRBW==DPRB+WRONGBIT	;DPRB, RESULT HAS WRONG SIGN
	DPXAW==DPXA+WRONGBIT	;DPXA, RESULT HAS WRONG SIGN
	DPXMW==DPXM+WRONGBIT	;DPXM, RESULT HAS WRONG SIGN
	DPXBW==DPXB+WRONGBIT	;DPXB, RESULT HAS WRONG SIGN
	SP==1			;SPECIAL CASE, NOT COVERED ABOVE
	NOBIT==0		;NO BITS

BITS:	BYTE (9) NOBIT, NOBIT,  DPXA,  DPXA	;OPCODE	100 UJEN-GFSB
	BYTE (9) NOBIT, NOBIT,  DPXA,  DPXA	;	104 JSYS-GFDV
	BYTE (9)  DPRA,  DPRA,  DPRA,  DPRA	;	110 DFAD-DFDV
	BYTE (9) DPIAW, DPIAW, DPIAW,  DPIA	;	114 DADD-DDIV
	BYTE (9) NOBIT, DPIAW,    SP,    SP	;	120 DMOVE-EXTEND
	BYTE (9) NOBIT, DPIMW,    SP, NOBIT	;	124 DMOVEM-FLTR
	BYTE (9)  SPRA, NOBIT,  SPRA,  INTA	;	130 UFA-ADJBP
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	134 ILDB-DPB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	140 FAD-FADB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	144 FADR-FADRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	150 FSB-FSBB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	154 FSBR-FSBRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	160 FMP-FMPB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	164 FMPR-FMPRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	170 FDV-FDVB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	174 FDVR-FDVRB
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	200 MOVE-MOVES
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	204 MOVS-MOVSS
	BYTE (9) INTAW, NOBIT, INTMW, INTMW	;	210 MOVN-MOVNS
	BYTE (9) INTAW, NOBIT, INTMW, INTMW	;	214 MOVM-MOVMS
	BYTE (9)  INTA,  INTA,  INTM,  INTB	;	220 IMUL-IMULB
	BYTE (9)  DPIA,  DPIA,  DPIM,  DPIB	;	224 MUL-MULB
	BYTE (9)  INTA,  INTA,  INTM,  INTB	;	230 IDIV-IDIVB
	BYTE (9)  DPIA,  DPIA,  DPIM,  DPIB	;	234 DIV-DIVB
	BYTE (9)  INTA, NOBIT, NOBIT, NOBIT	;	240 ASH-JFFO
	BYTE (9)  INTA, NOBIT, NOBIT, NOBIT	;	244 ASHC-NONE
	BYTE (9) NOBIT, NOBIT,  INTA,  INTA	;	250 EXCH-AOBJN
	BYTE (9) NOBIT, NOBIT,    SP, NOBIT	;	254 JRST-MAP
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	260 PUSHJ-POPJ
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	264 JSR-JRA
	BYTE (9) INTAW, INTAW, INTMW, INTBW	;	270 ADD-ADDB
	BYTE (9) INTAW, INTAW, INTMW, INTBW	;	274 SUB-SUBB
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	300 CAI-CAILE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	304 CAIA-CAIG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	310 CAM-CAMG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	314 CAMA-CAMGE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	320 JUMP-JUMPLE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	324 JUMPA-JUMPG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	330 SKIP-SKIPLE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	334 SKIPA-SKIPG
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	340 AOJ-AOJLE
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	344 AOJA-AOJG
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	350 AOS-AOSLE
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	354 AOSA-AOSG
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	360 SOJ-SOJLE
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	364 SOJA-SOJG
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	370 SOS-SOSLE
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	374 SOSA-SOSG
	BYTE (9) NOBIT, SPRAW, NOBIT, DPIAW	;EXTEND	020 XBLT-DGFIX
	BYTE (9) INTAW, DPIAW, INTAW, NOBIT	;EXTEND	024 GFIX-DGFLTR
	BYTE (9) NOBIT,  DPXA, NOBIT, NOBIT	;EXTEND	030 GFLTR,GFSC

BPTAB:	POINT	9,BITS-20(T1),8		;BYTE POINTERS, OFFSET BY 100 OCTAL
	POINT	9,BITS-20(T1),17
	POINT	9,BITS-20(T1),26
	POINT	9,BITS-20(T1),35

;TABLES INDEXED BY T1 (WITH FLAG BITS IN IT) TO ACCESS INSTRUCTION OPERANDS

XLOAD=.-2
	MOVE	T2,@AC		;SA
	DMOVE	T2,@AC		;DA
	MOVE	T2,@E		;SM
	DMOVE	T2,@E		;DM
	MOVE	T2,@AC		;SB
	DMOVE	T2,@AC		;DB

XSTORE=.-2
	MOVEM	T2,@AC		;SA
	DMOVEM	T2,@AC		;DA
	MOVEM	T2,@E		;SM
	DMOVEM	T2,@E		;DM
	PUSHJ	P,[MOVEM T2,@AC	;SB
		   MOVEM T2,@E
		   POPJ P,]
	PUSHJ	P,[DMOVEM T2,@AC ;DB
		   DMOVEM T2,@E
		   POPJ P,]

;TRAP MESSAGE CALL EXECUTE TABLE
TCALTB:	$TCALL	IOV
	$TCALL	IDC
	NOP
	NOP
	$TCALL	FOV
	$TCALL	FDC
	$TCALL	FUN
	NOP

;TRAP ERROR MESSAGES 

	SEGMENT	CODE 

	$TERR (%,IOV,0,0,Integer overflow)	;000
	$TERR (%,IDC,1,0,Integer divide check)	;001  NDV
;	$TERR (%,XXX,2,0,Floating underflow)	;010  FXU 	(impossible)
;	$TERR (%,XXX,3,0,Floating divide check)	;011  FXU,NDV	(impossible)
	$TERR (%,FOV,4,0,Floating overflow)	;100  FXO
	$TERR (%,FDC,5,0,Floating divide check)	;101  FXO,NDV
	$TERR (%,FUN,6,0,Floating underflow)	;110  FXO,FXU
;	$TERR (%,XXX,7,0,Floating divide check)	;111  FXO,FXU,NDV (impossible)
	$TERR (?,TDT,-1,0,Trap occured during trap processing)

	END
 