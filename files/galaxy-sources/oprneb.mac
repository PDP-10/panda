	TITLE	OPRNEB	ORION MODULE FOR PROCESSING NEBULA MESSAGES
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

	SEARCH	GLXMAC,ORNMAC,QSRMAC,NEBMAC
	SEARCH	MACSYM			;[35]
	PROLOG(OPRNEB)
;**;[31]At PROLOG(OPRNEB)+1L add 1 line  JCR  2/22/90
	ERRSET				;[31]Initialize error tables
;Version numbers

	NEBMAN==:40			;Maintenance edit number
	NEBDEV==:20			;Development edit number
	VERSIN (NEB)			;Generate edit number

	Subttl	Table of Contents

;		     Table of Contents for OPRNEB
;
;				  Section		      Page
;
;
;    1. Revision history . . . . . . . . . . . . . . . . . . .   3
;    2. Global symbols . . . . . . . . . . . . . . . . . . . .   4
;    3. NEBMSG - NEBULA message dispatcher . . . . . . . . . .   5
;    4. N$RDSM - REMOTE DISMOUNT message . . . . . . . . . . .   6
;    5. N$FDSM - FROM NEBULA DISMOUNT message  . . . . . . . .   7
;    6. N$FDAK - FROM NEBULA DISMOUNT ACK message  . . . . . .   8
;    7. N$TDAK - TO NEBULA DISMOUNT ACK message  . . . . . . .   9
;    8. N$CDSM - NEBULA CANCEL DISMOUNT message  . . . . . . .  10
;    9. N$FMTS - FROM NEBULA MOUNT message . . . . . . . . . .  11
;   10. N$MESS - SHOW MESSAGES message . . . . . . . . . . . .  12
;   11. N$OPER - SHOW OPERATORS message  . . . . . . . . . . .  13
;   12. N$SHOW - REMOTE OPERATOR SHOW message  . . . . . . . .  14
;   13. N$MACS - REMOTE SHOW ACK message . . . . . . . . . . .  15
;   14. N$TEXT Process a TEXT message from a remote ORION  . .  16
;   15. N$FBLK - Find a specified message block  . . . . . . .  17
;   16. N$SQSR - Send messages to QUASAR, NEBULA and MOUNTR ro  18
;   17. BLDHDR - Build the GALAXY message header . . . . . . .  19
;   18. FINSHW - Send a SHOW MESSAGES or SHOW OPERATORS messag  20
;   19. CPYMSG - Copy an incoming message to an outgoing messa  21
;   20. GETMSG - PICK UP MESSAGE FOR SHOW MESSAGES COMMAND . .  22
;   21. N$BLDP - Build the remote .ORDSP block . . . . . . . .  23
;   22. CPYDSP - Copy the REMOTE DISPLAY block . . . . . . . .  24
;   23. NEBSTR - NEBULA message log file headers . . . . . . .  25
;   24. SHOW message code translation tables . . . . . . . . .  26
	SUBTTL	Revision history

COMMENT \

*****	Release 6.0 -- begin development edits	*****

1	6.1094		20-Nov-87
	Add OPRNEB as the ORION module that processes messages that
are processed on a remote node in the cluster and that have come from
a remote node in the cluster.

2	6.1098		22-Nov-87
	Add an entry for the OPR MOUNT STRUCTURE command to tables
NBTOQR and QRTONB.

3	6.1136		9-Dec-87
	Make routine N$FBLK global. Also, correct the way N$SQSR,
N$SMDA and N$SNEB pick up the system PID index for QUASAR, MOUNTR
and NEBULA.

4	6.1138		13-Dec-87
	Fix bugs found as a result of debugging NEBULA. Add routine N$TEXT
to process TEXT messages that originated from a remote ORION.

5	6.1142		17-Dec-87
	Add support for the SHOW STATUS TAPE/CLUSTER-NODE: and SHOW STATUS 
DISK/CLUSTER-NODE: commands.

6	6.1146		17-Dec-87
	Add support for the SHOW STATUS STRUCTURE/CLUSTER-NODE: command.

7	6.1157		4-Jan-88
	If an illegal NEBULA message type is detected or if the sender of
the NEBULA message is not privileged, then set flag word G$NERR so the remote
operator will be informed.

10	6.1158		5-Jan-88
	Change N$RDSM to send a FROM NEBULA DISMOUNT ACK (.NFDAK) instead of
a TO NEBULA DISMOUNT ACK (.NTDAK) to MOUNTR if NEBULA is not running.

11	6.1159		5-Jan-88
	Add entries for SHOW STATUS DISK, SHOW STATUS STRUCTURE and SHOW STATUS
TAPE to table NEBSTR.

12	6.1164		6-Jan-88
	Shorten the display lines in table NEBSTR.

13	6.1187		17-Feb-88
	If there are no messages for a node, change the error code from E$NNK
to E$NMN.

14	6.1197		27-Feb-88
	Don't log a FROM NEBULA DISMOUNT ACK message since the WTO message
is logged.

15	6.1205		1-Mar-88
	Change routines N$MACS and N$TEXT not to call routine SPGOUT so as to
prevent picking up a second IPCF page for the outgoing message.

16	6.1210		2-Mar-88
	Change the TO NEBULA DISMOUNT ACK message log file entry to indicate
that the message came from NEBULA instead of MOUNTR.

17	6.1225		8-Mar-88
	Update copyright notice.

20	6.1247		5-May-88
	Add support for the SHOW STATUS NETWORK-NODE and SHOW PARAMETERS
NETWORK-NODE commands.

21	6.1269		18-Oct-88
	Fix a bug in N$SHOW so that OPR>SHOW STATUS PRINTER LOCAL /CLUSTER
will work. If NEB%MS is lit for the cluster OPR action commands, turn it off,
update the node name in the object block and forward the message to QUASAR.

22	6.1284		4-Oct-89
	Replace "New message from NEBULA" in ORION's log file with the type
of message and what node the message originated from.

23	6.1289		29-Nov-89
	Add support for the RESPOND/CLUSTER-NODE command and remote MOUNTR
commands.

24	6.1294		23-Dec-89
	In routine N$SHOW turn off bit .RMLPT if set before sending the
message to QUASAR. Also, if the message contains an object block, place
the local node name in the object block only if a local printer or
non-printer object has been specified and the message is not for all
nodes (i.e., the node word does not contain a "-1").

25	6.1305		19-Jan-90
	Implement support for the ROUTE/CLUSTER-NODE command.

26	6.1307		1-Feb-90
	Implement support for the CLOSE LOG/CLUSTER-NODE command.

27	6.1311		14-Feb-90
	Implement support for the REPORT/CLUSTER-NODE command.

30	6.1313		20-Feb-90
	Implement support for DISMOUNT/CLUSTER-NODE command.  In routine N$FDSM
set bit MF.RDM if the remote dismount is a result of a SET EXCLUSIVE or
DISMOUNT REMOVAL command.

31	6.1312		22-Feb-90
	Implement support for the /CLUSTER-NODE: switch in the ENABLE/DISABLE
CLASS-SCHEDULER, FILE-RETRIEVAL-WAITS, LOGGING and SEMI-OPR commands.

32	6.1315		27-Apr-90
	Implement support for the /CLUSTER-NODE: swtich in the ENABLE/DISABLE
BROADCAST-MESSAGES, SHOW BROADCAST-MESSAGES and the SHOW OPERATOR/ALL commands.

33	6.1316		2-May-90
	Cause routine N$RSPD to always send a Null ACK to NEBULA.

34	6.1318		3-Jun-90
	Add support for alias printers

35	6.1317		7-June-90
	Add support for SET JOB /CLUSTER-NODE: command

36	6.1317		11-June-90
	Save the node name in case of error

37	6.1322		30-August-90
	Cause routine NBMSG to place the object block address in AC P1.

40	6.1323		12-Sept-90
	Add DISMOUNT STRUCTURE command to NEBSTR table
\   ;End of Revision History
	SUBTTL	Global symbols

	EXTERN	CHKWHL			;CHECK FOR PRIVILEGES
	EXTERN	TABSRC			;TABLE ENTRY LOOKUP ROUTINE
	EXTERN	G$NEBD			;NEBULA MSG PROCESSOR ROUTINE ADR
	EXTERN	G$NACK			;NEBULA ACK FLAG
	EXTERN	G$ARG1			;ARGUMENT HOLDER
	EXTERN	G$ARG2			;ARGUMENT HOLDER
	EXTERN	G$HOST			;LOCAL NODE NAME
	EXTERN	G$NODL			;NODE LIST POINTER
	EXTERN	G$NERR			;REMOTE (NEBULA) SHOW ACK COMMAND ERROR
	EXTERN	G$NSHW			;REMOTE SHOW MESSAGE
	EXTERN	GETPAG			;GET A MESSAGE PAGE
	EXTERN	RELPAG			;RELEASE A MESSAGE PAGE
	EXTERN	QSRNAM			;QUASAR'S NAME
	EXTERN	NEBNAM			;NEBULA'S NAME
	EXTERN	MDANAM			;MOUNTR'S NAME
	EXTERN	SNDCGP			;SEND MESSAGES TO CLUSTER GALAXY PROC
	EXTERN	SNDBLK			;SAB BLOCK ADDRESS
	EXTERN	L$NEB			;LOG A NEBULA MESSAGE
	EXTERN	FNDNOD			;FIND A NODE
	EXTERN	SHWMTX			;BUILD THE LOCAL DISPLAY BLOCK
	EXTERN	SHDPBK			;LOCAL DISPLAY BLOCK ADDRESS
	EXTERN	SHODBK			;SHOW OPERATORS HEADER
	EXTERN	FNDXCT			;COMPARE MESSAGE NUMBERS
	EXTERN	CHKMSG			;CHECK FOR A MESSAGE AT A NODE
	EXTERN	MSGNOD			;BUILD A DISPLAY BLOCK FOR A NODE
	EXTERN	OPRLST			;BUILD DISPLAY BLOCK FOR AN OPERATOR
	EXTERN	BLDDPY			;MOVE MSG FROM MSG LIST TO OUTPUT PAGE
	EXTERN	FNDMSG			;LOOK FOR A MESSAGE ON ALL NODES
	EXTERN	W$ASND			;[4]SEND MESSAGE TO AN OPERATOR
	EXTERN	G$NOW			;[4]TIME THE MESSAGE WAS RECEIVED
;**;[21]At EXTERN G$NOW add 1 line JYCW Oct-18-88
	EXTERN  MANTAB,COMMAN		;[21]COMMAND TABLE AND COMMAN ROUTINE
;**;[32]At EXTERN MANTAB add 1 line  JCR  4/27/90
	EXTERN	CLSTYP,DISARG,G$CLUN,MSGARG ;[32]Broadcast messages support
;**;[35]At EXTERN CLSTYP add 1 line  JYCW  6/8/90
	EXTERN	SETJ.S,SETJ.W		;[35]SET JOB 
	EXTERN	SNDAOP,SNDNAL,NOALTN	;[35]SEND OPERATOR
	INTERN	NEBMSG			;NEBULA MESSAGE DISPATCHER
	INTERN	NEBSTR			;NEBULA LOG FILE HEADERS
	INTERN	QRTONB			;QUASAR TO NEBULA SHOW MESSAGE CODE
	INTERN	N$BLDP			;REMOTE DISPLAY BLOCK BUILDER
	INTERN	BLDHDR			;BUILD A REMOTE SHOW ACK MESSAGE HEADER
	INTERN	N$SNEB			;SEND A MESSAGE TO NEBULA
	INTERN	N$FBLK			;[3]FIND AN ARGUMENT BLOCK
;**;[34]At EXTERN N$FBLK+1L: add 3 lines    PMM 6/3/90
	EXTERN	AKAOBJ			;[34]Alias printer object block
	EXTERN	SAKHDR			;[34]SHOW ALIAS remote message header
	EXTERN	LSTENT			;[34]SHOW ALIAS last printer type

MSGADR:	BLOCK	1			;MESSAGE PAGE RELEASED FLAG
DISBLK: BLOCK	15			;[4]REMOTE DISPLAY BLOCK
;**;[26]At DISBLK:+0L add 3 lines  JCR  2/1/90
G$NEBF::BLOCK	1			;[26]Remote origin flag
G$NULA::BLOCK	1			;[26]Null ACK needed flag
G$REMN::BLOCK	1			;[26]Remote node name

	SUBTTL	NEBMSG - NEBULA message dispatcher

;NEBMSG dispatches messages that NEBULA has involvement in.
;
;Call is:       S1/Message type
;		MI/IPCF message address
;
;Returns true:  The message was successfully processed
;Returns false: An error occurred processing the message

NEBMSG:	$CALL	CHKWHL			;CHECK THE CALLER'S PRIVILEGES
	JUMPF	[$CALL E$IPE##		  ;[7]INSUFFICIENT PRIVILEGES
		 SETOM G$NERR		  ;[7]ACK THE REMOTE REQUESTOR
		 $RET ]			  ;[7]RETURN TO THE CALLER
;**;[23]At NEBMSG:+4L replace 4 lines with 15 lines  JCR  11/29/89
	MOVEI	S2,N$TEXT		;[23]Assume a Text message
	CAIN	S1,MT.TXT		;[23]Is this a Text message?
	JRST	NEBM.2			;[23]Yes, go prepare to dispatch
	TXZ	S1,NEB%MS		;[23]No, turn off "CLUSTER-NODE" bit
	CAIGE	S1,.NBMSG		;[23]A NEBULA message?
	CAIGE	S1,.ODMES		;[23]No, a MOUNTR message?
	JRST	NEBM.1			;[23]No, search the table
	MOVEI	S2,NBMSG		;[23]Pick up the routine address
	JRST	NEBM.2			;[23]Go prepare to dispatch
NEBM.1:	MOVEI	S2,NEBTAB		;[23]Pick up message dispatch table
	$CALL	TABSRC			;[23]Pick up the processor routine adr
	JUMPF	[$CALL E$IMT##		  ;[23]Illegal message type
		 SETOM G$NERR		  ;[23]ACK the remote requestor
		 $RET ]			  ;[23]Return to the caller
NEBM.2:	DMOVEM	S1,G$NEBD		;[23]Save message type and routine adr
	$CALL	GETPAG			;PICK UP A PAGE FOR OUTGOING MESSAGE
	SETZM	MSGADR			;ASSUME MESSAGE NOT RELEASED ON AN ERROR
	DMOVE	S1,G$NEBD		;PICK UP MESSAGE TYPE AND ROUTINE ADR
	$CALL	0(S2)			;PROCESS THE MESSAGE
	SKIPF				;DID AN ERROR OCCUR?
	$RET				;NO, RETURN NOW
	CAME	MO,MSGADR		;MESSAGE PAGE ALREADY RELEASED?
	$CALL	RELPAG			;NO, RELEASE THE MESSAGE PAGE
	$RETF				;RETURN TO THE CALLER

NEBTAB:	$STAB				;NEBULA MESSAGE DISPATCH TABLE

	.NRDSM,,N$RDSM			;REMOTE DISMOUNT MESSAGE
	.NFDSM,,N$FDSM			;FROM NEBULA DISMOUNT MESSAGE
	.NFDAK,,N$FDAK			;FROM NEBULA DISMOUNT ACK MESSAGE
	.NTDAK,,N$TDAK			;TO NEBULA DISMOUNT ACK MESSAGE
	.NCDSM,,N$CDSM			;NEBULA CANCEL DISMOUNT MESSAGE
	.NFMTS,,N$FMTS			;FROM NEBULA MOUNT MESSAGE

	.NMESS,,N$MESS			;SHOW MESSAGES MESSAGE
	.NSHOP,,N$OPER			;SHOW OPERATORS MESSAGE
	.NMSHS,,N$SHOW			;SHOW STATUS MESSAGE
	.NDSHT,,N$SHOW			;[5]SHOW STATUS TAPE
	.NDSHD,,N$SHOW			;[5]SHOW STATUS DISK
	.NDSTR,,N$SHOW			;[6]SHOW STATUS STRUCTURE
	.NDSCD,,N$SHOW			;SHOW CONFIGURATION MESSAGE
	.NMSHQ,,N$SHOW			;SHOW QUEUES MESSAGE
	.NMSHP,,N$SHOW			;SHOW PARAMETERS MESSAGE
	.NMSHR,,N$SHOW			;SHOW ROUTE MESSAGE
	.NMSSN,,N$SHOW			;[5]SHOW STATUS NETWORK-NODES
	.NMSPN,,N$SHOW			;[5]SHOW PARAMTERS NETWORK-NODES
	.NMACS,,N$MACS			;REMOTE SHOW ACK MESSAGE
	MT.TXT,,N$TEXT			;[4]REMOTE ORION TEXT MESSAGE
;**;[23]At NEBTAB:+22L add 30 lines  JCR  11/29/89
	.OMSTA,,NBMSG			;[23]STARTUP message
	.OMSHT,,NBMSG		        ;[23]SHUTDOWN message
	.OMSET,,NBMSG			;[23]SET message
	.OMPAU,,NBMSG			;[23]STOP message
	.OMCON,,NBMSG			;[23]CONTINUE message
	.OMSHC,,NBMSG			;[23]SHOW COMMAND FILE 
	.OMREQ,,NBMSG			;[23]REQUEUE message
	.OMCAN,,NBMSG			;[23]ABORT message
	.OMFWS,,NBMSG			;[23]FORWARDSPACE message
	.OMALI,,NBMSG			;[23]ALIGN PRINTER message
	.OMSUP,,NBMSG			;[23]SUPPRESS PRINTER message
	.OMSND,,NBMSG			;[23]SEND message
	.OMBKS,,NBMSG			;[23]BACKSPACE message
	.OMHLD,,NBMSG			;[23]HOLD message
	.OMREL,,NBMSG			;[23]RELEASE message
;**;[25]At NEBTAB:+39L change 1 line  JCR  1/19/90
	.OMRTD,,RTMSG			;[25]ROUTE message
	.OMDEL,,NBMSG			;[23]CANCEL message
	.OMMOD,,NBMSG			;[23]MODIFY message
	.OMENA,,NBMSG			;[23]ENABLE message
	.OMDIS,,NBMSG			;[23]DISABLE message
	.OMDEF,,NBMSG			;[23]DEFINE message
	.OMDSP,,NBMSG			;[23]DN60 DISPLAY message
	.OMNXT,,NBMSG			;[23]NEXT message
	.OMELP,,NBMSG			;[23]ENA LOG/SPOOL LPT OBJECTS message
	.OMDLP,,NBMSG			;[23]DIS LOG/SPOOL LPT OBJECTS message
	.OMELT,,NBMSG			;[23]ENA SPECIFIC LPT LOG/SPOOL message
	.OMDLT,,NBMSG			;[23]DIS SPECIFIC LPT LOG/SPOOL message
	.OMEUP,,NBMSG			;[23]ENA UNPRIV USER REMOTE I/O message
	.OMDUP,,NBMSG			;[23]DIS UNPRIV USER REMOTE I/O
	.OMRSP,,N$RSPD			;[23]RESPOND message
;**;[26]At NEBTAB:+55L add 1 line  JCR  2/1/90
	.OMCLO,,N$LOG			;[26]CLOSE LOG message
;**;[27]At NEBTAB:+57L add 1 line  JCR  2/14/90
	.OMREP,,N$REP			;[27]REPORT message
;**;[31]At NEBTAB:+59L add 8 lines  JCR  2/22/90
	.OMECS,,N$CLAS			;[31]ENABLE CLASS-SCHEDULER
	.OMDCS,,N$CLAS			;[31]DISABLE CLASS-SCHEDULER
	.OMEFI,,N$FILE			;[31]ENABLE FILE-RETRIEVAL
	.OMDFI,,N$FILE			;[31]DISABLE FILE-RETRIEVAL
	.OMELG,,N$LGNG			;[31]ENABLE LOGGING
	.OMDLG,,N$LGNG			;[31]DISABLE LOGGING
	.OMESO,,N$SEMI			;[31]ENABLE SEMI-OPR
	.OMDSO,,N$SEMI			;[31]DISABLE SEMI-OPR
;**;[32]At NEBTAB:+68L add 3 lines  JCR  4/27/90
	.OMEBM,,N$BCW			;[32]ENABLE BROADCAST-MESSAGES
	.OMDBM,,N$BCW			;[32]DISABLE BROADCAST-MESSAGES
	.OMSBM,,N$SBC			;[32]SHOW BROADCAST-MESSAGES
;**;[34]At NEBTAB:+71L add 2 lines    PMM   6/3/90
	.OMAKA,,N$DAK			;[34]DEFINE ALIAS 
	.OMSAK,,N$SAK			;[34]SHOW ALIAS
;**;[35]At NEBTAB:+73L add 2 line  JYCW  6/8/90
	.OMSJB,,N$SETJ			;[35]REMOTE SET JOB
	.OMSOP,,N$SEDO			;[35]REMOTE SEND OPERATOR
	$ETAB				
;**;[25]At the end of NEBTAB: add routine RTMSG  JCR  1/19/90

	SUBTTL  RTMSG - ROUTE Message Preprocessor

;[25]Routine RTMSG is called to determine if the node names specified in
;[25]the source and/or destination object descriptions need to be
;[25]changed to the local node name. In processing the route command,
;[25]the ORION where the message originated will place its name into
;[25]the source or destination object descriptor if the operator did
;[25]not specify a node name. If this is the case, then the remote
;[25]ORION must change the node name to its own name.
;[25]
;[25]Call is:   MI/Route message address
;[25]		S1/Message type
;[25]Returns:	PJRST to NBMSG

RTMSG:	MOVE	S1,.OFLAG(MI)		;[25]Pick up the flag word
	MOVE	S2,G$HOST		;[25]Pick up local node name
	TXNE	S1,RT.SND		;[25]Default source node name?
	MOVEM	S2,SNDADR(MI)		;[25]Yes, update with local node name
	TXNE	S1,RT.DND		;[25]Default destination node name?
	MOVEM	S2,DNDADR(MI)		;[25]Yes, update with local node name
;**;[34]At RTMSG:+5L add 20 lines  PMM  6/3/90
	MOVEI	S2,.RTEFM		;[34]Get source object block type 
	MOVE	S1,MI			;[34]Get message address
	$CALL	N$FBLK			;[34]Get address of block type
	SETZM	ARG.DA+OBJ.AK(S1)	;[34]Clear alias name
	MOVE	P1,S1			;[34]Save address of block
	AOS	S1			;[34]Get address of block data
	$CALL	FINDPR##		;[34]Search for printer's alias name
	JUMPF	RTMS.1			;[34]No alias, check destination block
	MOVE	S1,OBJAKA(S2)		;[34]Get SIXBIT alias name
	MOVEM	S1,ARG.DA+OBJ.AK(P1)	;[34]Save in message
RTMS.1:	MOVEI	S2,.RTETO		;[34]Get destination object block type
	MOVE	S1,MI			;[34]Get message address
	$CALL	N$FBLK			;[34]Get address of block type
	SETZM	ARG.DA+OBJ.AK(S1)	;[34]Clear alias name
	MOVE	P1,S1			;[34]Save address of block
	AOS	S1			;[34]Get address of block data
	$CALL	FINDPR##		;[34]Search for printer's alias name
	JUMPF	RTMS.2			;[34]No alias, drop into common code
	MOVE	S1,OBJAKA(S2)		;[34]Get SIXBIT alias name
	MOVEM	S1,ARG.DA+OBJ.AK(P1)	;[34]Save in message
RTMS.2:	MOVEI	S1,.OMRTD		;[25]Expected by routine NBMSG
	PJRST	NBMSG			;[25]Drop into common code
	
	SUBTTL  NBMSG - Cluster OPR action routine handler.
;**;[23]At SUBTTL NBMSG:+1L replace 5 lines with 12 lines  JCR  11/29/89
;[23]Routine NBMSG processes OPR action messages that do not need to be 
;[23]converted. The message is already in the form of an ORION to QUASAR format.
;[23]If there is an object block in the message and it is not for a remote
;[23]printer (i.e., not for a cluster, DQS or LAT printer), then place the
;[23]local node name in the object block. The message is then forwarded to
;[23]QUASAR.
;
;[23]Call is:       S1/Message type with bit NEB%MS turned off
;[23]               MI/IPCF message address
;
;[23]Returns true:  The message was sucessfully sent to QUASAR
;[23]Returns false: The message was not sent to QUASAR

;**;[21]At NEBTAB:+21L add routine NBMSG:
;**;[23]At NBMSG:+0L replace 8 lines with 3 lines  JCR  11/29/89
NBMSG:	STORE	S1,.MSTYP(MI),MS.TYP	;[23]Turn off NEB%MS in incoming msg
	$CALL	L$NEB			;[23]Log the message
	$CALL	CPYMSG			;[23]Copy the message to outgoing page
	MOVE	S1,MO			;[21]PICK UP ADDRESS OF MESSAGE
	MOVEI	S2,.OROBJ		;[21]PICK UP BLOCK TYPE TO SEARCH FOR
	$CALL	N$FBLK			;[21]FIND THE OBJECT BLOCK
	JUMPF	NBMS.6			;[34]None
;**;[34]At NBMSG:+6L replace 1 line with 17 lines   PMM  6/3/90
	HRRZ	S2,ARG.DA+OBJ.TY(S1)	;[34]Pick up the object type
	CAIN	S2,.OTLPT		;[34]Is this a LPT?
	JRST	NBMS.2			;[34]Yes, treat differently
	MOVE	S2,ARG.DA+OBJ.TY(S1)	;[34]Pick up the full object type
	TXZE	S2,.RMLPT		;[34]Was /NODE specified originally?
	JRST	NBMS.1			;[34]Yes, so use its value
	MOVE	S2,G$HOST		;[34]Pick up the local node name
	MOVEM	S2,ARG.DA+OBJ.ND(S1)	;[34]Place it in the object block
	JRST	NBMS.6			;[34]Send to QUASAR
NBMS.1:	MOVEM	S2,ARG.DA+OBJ.TY(S1)	;[34]Save the updated object type
	JRST	NBMS.6			;[34]Send to QUASAR
	
;**;[37]At NBMS.2:+0L replace 1 line with 2 lines  JCR  8/30/90
NBMS.2:	MOVE	P1,S1			;[37]Save the object block address
	MOVE	S2,ARG.DA+OBJ.TY(S1)	;[37]Get object type
	TXNE	S2,.DQLPT!.LALPT	;[34]Is it LAT or DQS printer?
	JRST	NBMS.3			;[34]Yes, proceed as usual
	LOAD	S2,ARG.HD(S1),AR.LEN	;[34]Pick up object block length
	CAIN	S2,AKBSIZ		;[34]Does length indicate an alias?
	SETZM	OBJAKA(S1)		;[34]Yes, clear alias
	MOVE	P3,S1			;[34]Get address of object block
;**;[37]At NBMS.2:+8L remove 1 line  JCR  8/30/90
	LOAD	S1,ARG.DA+OBJ.UN(S1),OU.HRG ;[34]Get high range
	$CALL	RANGAB##		;[34]Search for alias names
	MOVE	S1,P1			;[34]Restore address of object block

NBMS.3:	MOVE	S2,ARG.DA+OBJ.TY(S1)	;[34]Get the object type
	TXNN	S2,.LALPT		;[34]Is it a LAT printer?
	TXNE	S2,.DQLPT		;[34]DQS printer?
	SETZM	ARG.DA+OBJ.AK(S1)	;[34]Yes, clear alias
	TXNN	S2,.DQLPT		;[21]DQS?
	TXNE	S2,.CLLPT		;[21]CLUSTER PRINTER?
	JRST	NBMS.5			;[34]YES
	TXNN	S2,.LALPT		;[21]IS IT A LAT?
	TXZE	S2,.RMLPT		;[21]IS IT A REMOTE PRINTER (/NODE:)
	JRST	NBMS.4			;[34]YES, NO NEED TO CHANGE NODE NAME
	MOVE	S2,G$HOST		;[21]GET LOCAL NODE NAME
	MOVEM	S2,ARG.DA+OBJ.ND(S1)	;[21]PUT IT IN OBJECT BLK
	SKIPA				;[21]NO NEED TO CHANGE THE OBJECT TYPE
NBMS.4:	MOVEM	S2,ARG.DA+OBJ.TY(S1)	;[34]SAVE THE OBJECT TYPE
NBMS.5:	AOS	S1			;[34]Point past object block header
	$CALL	FINDPR##		;[34]Is it in list?
	JUMPF	NBMS.6			;[34]No, send to QUASAR
	MOVE	T1,OBJAKA(S2)		;[34]Get SIXBIT alias name
	MOVEM	T1,ARG.DA+OBJ.AK(P1)	;[34]Save in object block
NBMS.6:	$CALL	N$SQSR			;[34]Send the message to QUASAR
;**;[23]At NBMSG1:+1L replace 5 lines with 1 line  JCR  11/29/89
	$RET				;[23]Preserve T/F for caller

	SUBTTL	N$RDSM - REMOTE DISMOUNT message 

N$RDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTPUT MESSAGE
	MOVEI	S1,.NTDSM		;PICK UP EXPECTED MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN OUTGOING MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS SEND

;AN ERROR HAS OCCURRED - SEND MOUNTR A "FROM NEBULA DISMOUNT ACK" MESSAGE

	MOVEI	S1,.NRDAK		;[10]PICK UP THE MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	SETZM	.MSFLG(MO)		;TURN OFF THE NEBULA BIT
	MOVX	S1,DS%FAI		;PICK UP ERROR INDICATOR
	MOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	S2,2			;PICK UP THE ARGUMENT BLOCK COUNT
	MOVEM	S2,.OARGC(MO)		;PLACE IN THE MESSAGE

	MOVEI	T1,.OHDRS(MO)		;[4]POINT TO THE ASCIZ STR NAME BLOCK
	MOVEI	S1,ARG.DA(T1)		;[4]POINT TO THE ASCIZ STRUCTURE NAME
	HRLI	S1,(POINT 7,)		;[4]MAKE INTO A POINTER
	$CALL	S%SIXB			;[4]PICK UP THE SIXBIT STRUCTURE NAME
	MOVEM	S2,ARG.DA(T1)		;[4]PLACE IN THE STRUCTURE BLOCK
	MOVE	S1,[.STRLN,,.STRNM]	;[4]PICK UP THE HEADER WORD
	MOVEM	S1,ARG.HD(T1)		;[4]PLACE IN THE STRUCTURE BLOCK
	ADDI	T1,.STRLN		;[4]POINT TO THE STATUS BLOCK

	LOAD	S1,.MSTYP(MO),MS.CNT	;PICK UP THE MESSAGE LENGTH
	SUBI	S1,<.OHDRS+.STRLN>	;DETERMINE NODE BLOCKS TOTAL LENGTH
	MOVE	S2,S1			;SAVE FOR LATER
	MOVSS	S1			;PLACE BLOCK LENGTH IN EXPECTED PLACE
	HRRI	S1,.STSBK		;PICK UP BLOCK TYPE
	MOVEM	S1,ARG.HD(T1)		;PLACE BLOCK HEADER WORD IN THE MESSAGE
	
	LSH	S2,-1			;DETERMINE THE NUMBER OF NODES
	AOS	T1			;POINT PASS THE HEADER WORD

N$RD.1:	MOVE	S1,ARG.DA(T1)		;[4]PICK UP THE NODE NAME
	MOVEM	S1,ARG.HD(T1)		;[4]PLACE WHERE MOUNTR EXPECTS IT
	MOVE	S1,[ST%OER+IPCFX4]	;[4]PICK UP ERROR CODE
	MOVEM	S1,ARG.DA(T1)		;[4]PLACE WHERE MOUNTR EXPECTS IT
	ADDI	T1,.NDENM		;POINT TO THE NEXT NODE BLOCK
	SOJG	S2,N$RD.1		;UPDATE THE NEXT NODE BLOCK

	$CALL	N$SMDA			;SEND THE MESSAGE TO MOUNTR
	SKIPF				;SKIP ON MESSAGE SEND FAILURE
	MOVEM	MO,MSGADR		;INDICATE MESSAGE PAGE RELEASED

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	SETOM	G$NACK			;DON'T SEND AN ACK TO NEBULA
	$RETF				;INDICATE AN ERROR HAS OCCURED

	SUBTTL	N$FDSM - FROM NEBULA DISMOUNT message

N$FDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE INTO OUTGOING PAGE
	MOVEI	S1,.ODDSM		;PICK UP MSG CODE THAT QUASAR EXPECTS
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
;**;[30]At N$FDSM+4L add 2 lines JYCW 2/20/90
	MOVX	S1,MF.RDM		;[30]Get indirect remote dismount
	IORM	S1,.MSFLG(MO)		;[30]Place in the outgoing message
	$CALL	N$SQSR			;SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

;AN ERROR OCCURRED. BUILD AND SEND THE FROM NEBULA DISMOUNT ACK MESSAGE

	MOVE	S1,[.OHDRS+.ERRSZ,,.NFDAK] ;PICK UP MESSAGE HEADER WORD
	MOVEM	S1,.MSTYP(MO)		;PLACE IN THE MESSAGE
	SETZM	.MSFLG(MO)		;ZERO OUT THE FLAG WORD
	MOVX	S1,FA%OER		;PICK UP ORION DETECTED THE ERROR
	MOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	S1,1			;PICK UP THE ARGUMENT COUNT
	MOVEM	S1,.OARGC(MO)		;PLACE IN THE MESSAGE

	MOVE	S1,[.ERRSZ,,.ERRBK]	;PICK UP ERROR BLOCK HEADER WORD
	MOVEM	S1,.OHDRS+ARG.HD(MO)	;PLACE IN THE MESSAGE
	MOVEI	S1,IPCFX4		;PICK UP THE MONITOR ERROR CODE
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;PLACE IN THE MESSAGE

	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	SKIPF				;IF FAILED, THEN STILL HAVE PAGE
	MOVEM	MO,MSGADR		;INDICATE MESSAGE PAGE RELEASED

	MOVEI	S1,QSRNAM		;PICK UP QUASAR'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	SETOM	G$NACK			;DON'T SEND THE SENDER AN ACK
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$FDAK - FROM NEBULA DISMOUNT ACK message

N$FDAK:	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	$CALL	N$SNEB			;SEND THE MESSAGE
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;NO, DON'T ACK MOUNTR
	$CALL	E$IAP##			;STORE ERROR CODE
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$TDAK - TO NEBULA DISMOUNT ACK message

N$TDAK:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	MOVEI	S1,.NRDAK		;PICK UP REMOTE DISMOUNT ACK MSG CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	$CALL	N$SMDA			;SEND THE MESSAGE TO MOUNTR
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;INDICATE DON'T ACK SENDER
	$CALL	E$IAP##			;STORE THE ERROR CODE IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$CDSM - NEBULA CANCEL DISMOUNT message

N$CDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	$CALL	N$SNEB			;SEND THE MESSAGE
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;NO, DON'T ACK MOUNTR
	$CALL	E$IAP##			;STORE THE ERROR CODE IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$FMTS - FROM NEBULA MOUNT message

N$FMTS:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	MOVEI	S1,.ODMTS		;PICK UP MSG CODE THAT QUASAR EXPECTS
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	$CALL	N$SQSR			;SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,QSRNAM		;PICK UP QUASAR'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;STORE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;SEND AND LOG THE ERROR 
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$MESS - SHOW MESSAGES message

N$MESS:	$SAVE	<P1>			;SAVE THIS AC
;**;[23]At N$MESS:+1L add 1 line  JCR  11/29/89
	$CALL	L$NEB			;[23]Log the message
	MOVEI	S1,.OMDSP		;[4]PICK UP THE MESSAGE TYPE
	$CALL	BLDHDR			;BUILD THE GALAXY MESSAGE HEADER
	MOVEI	S1,SHDPBK		;PICK UP DISPLAY HEADER ADDRESS
	$CALL	SHWMTX			;PLACE IN THE MESSAGE
	LOAD	S1,.OHDRS+ARG.HD(MI),AR.TYP ;PICK UP THE BLOCK TYPE
	CAIE	S1,.CMNOD		;IS THIS A NODE BLOCK?
	JRST	N$ME.1			;NO, CHECK FOR A NUMBER BLOCK
	MOVE	S1,.OHDRS+ARG.DA(MI)	;PICK UP THE NODE NAME
;**;[23]At N$MESS:+9L replace 4 lines with 2 lines  JCR  11/29/89
	$CALL	N$FNOD			;[23]Find the node list entry
	$RETIF				;[23]Return if node entry not found
	MOVE	S1,NOD.NM(S1)		;GET THE NODE NAME
	SETOM	G$NSHW			;INDICATE IT IS A REMOTE SHOW MESSAGE
	$CALL	MSGNOD			;OUTPUT THE MESSAGES
	JUMPF	N$ME.5			;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;HAVE SOME..SEND IT
	$RET				;RETURN TO THE CALLER

N$ME.1:	CAIE	S1,.CMNUM		;IS THIS A NUMBER BLOCK?
	JRST	N$ME.2			;NO, TREAT AS A <CR>
	MOVE	S1,G$HOST		;PICK UP THE LOCAL NODE NAME
;**;[23]At N$ME.1:+3L replace 4 lines with 2 lines  JCR  11/29/89
	$CALL	N$FNOD			;[23]Find the node list entry
	$RETIF				;[23]Return if node entry not found
	MOVE	S1,.OHDRS+ARG.DA(MI)	;PICK UP THE MESSAGE NUMBER
	MOVEM	S1,G$ARG2		;SAVE IN CASE OF AN ERROR
	$CALL	GETMSG			;PICK UP THE MESSAGE
;**;[23]At N$ME.1:+9L replace 2 lines with 1 line  JCR  11/29/89
	JUMPF	N$NSM			;[23]No such message
	$CALL	BLDDPY			;MOVE THE MESSAGE
	JUMPF	N$ME.5			;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;FINISH OFF THE MESSAGE
	$RET				;RETURN TO THE CALLER

;HERE IF JUST SHOW MESSAGES <CR>

N$ME.2:	MOVE	S1,G$HOST		;PICK UP THE LOCAL NODE NAME
;**;[23]At N$ME.2:+1L replace 4 lines with 2 lines  JCR  11/29/89
	$CALL	N$FNOD			;[23]Find the local node name entry
	$RETIF				;[23]The node is not known
	MOVE	S2,NOD.NM(S2)		;GET THE NAME
	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	[MOVEI	S1,E$NOM##	  ;NO OUTSTANDING MESSAGES
		 JRST	N$ME.5 ]	;GO SEND AN ACK MESSAGE
N$ME.3:	SETOM	G$NSHW			;INDICATE A REMOTE SHOW MESSAGE
	$CALL	MSGNOD			;GET MESSAGES FOR THIS NODE
	JUMPT	N$ME.4			;GO CHECK THE NEXT NODE
	CAIE	S1,E$NMN##		;[13]NO MESSAGES FOR THIS NODE?
	JRST	N$ME.5			;NO, INDICATE AN ERROR HAS OCCURRED
	SKIPA				;[4]YES, CHECK THE NEXT NODE

N$ME.4:	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	N$ME.3			;PROCESS MESSAGES
	JUMPE	P1,[MOVEI S1,E$NOM##	  ;PICK UP ERROR ROUTINE ADDRESS
		    JRST N$ME.5 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;SEND THE MESSAGE
	$RET				;RETURN TO THE CALLER

N$ME.5:	$CALL	0(S1)			;[4]PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;LOG AND SEND AN ERROR ACK
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$OPER - SHOW OPERATORS message

N$OPER:	$SAVE	<P1>			;SAVE THIS AC
;**;[23]At N$OPER:+1L add 1 line  JCR  11/29/89
	$CALL	L$NEB			;[23]Log the message	
	MOVEI	S1,.OMDSP		;[4]PICK UP THE MESSAGE TYPE
	$CALL	BLDHDR			;BUILD THE GALAXY MESSAGE HEADER
;**;[32]At N$OPER:+5L add 4 lines  JCR  4/27/90
	SETZM	G$ARG3##		;[32]Assume no /ALL switch
	MOVE	S1,.OFLAG(MI)		;[32]Pick up the flag word
	TXNE	S1,OP.ALL		;[32]/ALL switch specified?
	SETOM	G$ARG3##		;[32]Yes, indicate so
	MOVEI	S1,SHODBK		;SHOW OPERATOR TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT POINTER
	LOAD	S1,.OHDRS+ARG.HD(MI),AR.TYP ;PICK UP THE BLOCK TYPE
	CAIE	S1,.CMNOD		;IS THIS A NODE BLOCK?
	JRST	N$OP.1			;NO, SHOW ALL OPERATORS
	MOVE	S1,.OHDRS+ARG.DA(MI) ;PICK UP THE NODE NAME
;**;[23]At N$OPER:+9L replace 4 lines with 2 lines  JCR  11/29/89
	$CALL	N$FNOD			;[23]Find the local node name entry
	$RETIF				;[23]The node is not known
	$CALL	OPRLST			;OPERATORS AT NODE
	JUMPF	[MOVEI	S1,E$NON##	  ;NO MESSAGES FOR THE NODE
		 JRST   N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;HAVE SOME..SEND IT
	$RET				;RETURN TO THE CALLER

N$OP.1:	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	[MOVEI	S1,E$NOD##	  ;NO OPERATORS DEFINED
		 JRST	N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
N$OP.2:	$CALL	OPRLST			;OPERATORS AT NODE
	SKIPF				;NO MESSAGES SKIP FLAG SETTING
	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	N$OP.2			;PROCESS MESSAGES
	JUMPE	P1,[MOVEI S1,E$NOD##	  ;[4]NO OPERATORS DEFINED
		    JRST N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;YES..SEND MESSAGE
	$RET				;RETURN TO THE CALLER

N$OP.3:	$CALL	0(S1)			;PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;LOG AND SEND AN ERROR ACK
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$SHOW - REMOTE OPERATOR SHOW message

N$SHOW:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	LOAD	S1,.MSTYP(MO),MS.TYP	;PICK UP THE SHOW TYPE
	MOVEI	S2,NBTOQR		;PICK UP THEN CODE TRANSLATION TABLE
	$CALL	TABSRC			;PICK UP MESSAGE CODE QUASAR EXPECTS
	JUMPF	N$SH.1			;QUIT ON AN INVALID MESSAGE FORMAT
	STORE	S2,.MSTYP(MO),MS.TYP	;PLACE EXPECTED CODE IN THE MESSAGE
;**;[21]At N$SHOW:+6L add 12 lines JYCW Oct-18-88
	MOVE	S1,MO			;[21]PICK UP ADDRESS OF MESSAGE
	MOVEI	S2,.OROBJ		;[21]PICK UP BLOCK TYPE TO SEARCH FOR
	$CALL	N$FBLK			;[21]FIND THE OBJECT BLOCK
	JUMPF	N$SH.0			;[21]NO OBJECT BLOCK
;**;[34]At N$SHOW:+11L add 3 lines   PMM  6/3/90
	LOAD	S2,ARG.HD(S1),AR.LEN	;[34]Pick up object block length
	CAIN	S2,AKBSIZ		;[34]Does length indicate an alias?
	SETZM	OBJ.AK(S1)		;[34]Yes, clear alias

;**;[24]At N$SHOW:+12L replace 11 lines with 17 lines  JCR  12/23/89
N$SHW.0:MOVE	S2,ARG.DA+OBJ.ND(S1)	;[24]Pick up the node name
	CAMN	S2,[-1]			;[24]Is it for all nodes?
	JRST	N$SH.0			;[24]Yes, send the message to QUASAR
	MOVE	S2,ARG.DA+OBJ.TY(S1)	;[24]Get the object type
	CAMN	S2,[-1]			;[24]For all objects?
	JRST	N$SH.0			;[24]Yes, send the message to QUASAR
	TXNN	S2,.DQLPT		;[24]DQS?
	TXNE	S2,.CLLPT		;[24]Cluster printer?
	JRST	N$SH.0			;[24]Yes, send the message to QUASAR
	TXNE	S2,.LALPT		;[24]Is it a LAT?
	JRST	N$SH.0			;[24]Yes, send the message to QUASAR
	TXZE	S2,.RMLPT		;[24]Node Switch Present?
	JRST	N$SH0A			;[24]Yes, go turn off .RMLPT bit
	MOVE	S2,G$HOST		;[24]Get the local node name
	MOVEM	S2,ARG.DA+OBJ.ND(S1)	;[24]Put it in the  object block
	SKIPA				;[24]Don't update the object type
N$SH0A:	MOVEM	S2,ARG.DA+OBJ.TY(S1)	;[24]Update the object type
;**;[34]At N$SHOA:+1L add 2 lines  PMM  6/3/90
	SKIPA				;[34]Don't zero the alias name
N$SH.0:	SETZM	OBJ.AK(S1)		;[34]Clear alias for remote LPT only
	$CALL	N$SQSR			;[21]SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	$RETF				;INDICATE AN ERROR OCCURRED

N$SH.1:	$CALL	E$IFC##			;INDICATE ILLEGALLY FORMATTED MESSAGE
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$MACS - REMOTE SHOW ACK message

N$MACS:	HRLI	S1,(MI)			;[15]ADDRESS OF THE MESSAGE
	HRRI	S1,(MO)			;[15]ADDRESS OF THE OUTGOING MESSAGE
	BLT 	S1,PAGSIZ-1(MO)		;[15]MOVE THE MESSAGE
	MOVEI	S1,.OMACS		;PICK UP THE SHOW ACK MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE MESSAGE TYPE
	$CALL	L$NRSW##		;LOG THE MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;PLACE WHERE ERROR TEXT EXPECTS IT
	$CALL	E$IAP##			;PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NACK			;DON'T SEND AN ACK MESSAGE TO SENDER
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$TEXT  Process a TEXT message from a remote ORION

N$TEXT:	$CALL	CHKWHL			;[4]CHECK IF WHEEL
	JUMPF	E$ARP##			;[4]ERROR, RETURN
	HRLI	S1,(MI)			;[15]ADDRESS OF THE MESSAGE
	HRRI	S1,(MO)			;[15]ADDRESS OF THE OUTGOING MESSAGE
	BLT 	S1,PAGSIZ-1(MO)		;[15]MOVE THE MESSAGE
	MOVE	S1,G$NOW		;[4]PICK UP THE CURRENT TIME
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;[4]PLACE IN THE REMOTE DISPLAY BLOCK
	$CALL	L$RERR##		;[4]LOG THE REMOTE TEXT MESSAGE
	$CALL	W$ASND			;[4]SEND THE MESSAGE
	$RETT				;[4]RETURN
;**;[23]At N$TEXT:+9L add routines N$RSPD and N$FNOD JCR  11/29/89

	SUBTTL	N$RSPD - Process a RESPOND message from a remote ORION

;[23]Routine N$RSPD processes a RESPOND message from a remote ORION. 
;[23]
;[23]Call is:       MI/Address of the RESPOND message
;[23]
;[23]Returns true:  The outstanding WTOR was successfully responded to
;[23]Returns false: The outstanding WTOR no longer exists or was not
;[23]               responded to

N$RSPD:	$SAVE	<P1,P2,P3,P4>		;[23]Save some scratch ACs
	$CALL	L$NEB			;[23]Log the message
	MOVEI	S1,.OHDRS(MI)		;[23]Point to the first parser block
	$CALL	P$SETU##		;[23]Set up the parser
	$CALL	P$NUM##			;[23]Pick up the message number
	JUMPF	N$RS.1			;[23]Illegally formatted message
	MOVE	P1,S1			;[23]Save the message number
	MOVE	S1,G$HOST		;[23]Pick up the local node name
	$CALL	N$FNOD			;[23]Find the node entry address
;**;[33]At N$RSPD:+9L change 1 line  JCR  5/2/90
	JUMPF	N$RS.2			;[33]None, send a Null ACK
	MOVE	P2,S2			;[23]Save the node entry address	
	MOVEM	P1,G$ARG2		;[23]Save message number if an error
	MOVE	S1,P1			;[23]Place msg number in expected place
	$CALL	GETMSG			;[23]Check for message for this node
	JUMPF	N$NSM			;[23]Quit now if no such message
	MOVE	P2,S2			;[23]Save the message address
	MOVEI	S1,.OMRSP		;[23]Pick up RESPOND message type
	STORE	S1,.MSTYP(MO),MS.TYP	;[23]Place in the outgoing message
	MOVE	S1,MI			;[23]Pick up incoming message address
	MOVEI	S2,.NDENM		;[23]Pick up remote node block code
	$CALL	N$FBLK			;[23]Find it in the incoming message
	JUMPF	N$RS.1			;[23]Illegally formatted message
	LOAD	P4,ARG.DA(S1)		;[23]Save the requestor's node name
	MOVEI	P3,.OHDRS(MO)		;[23]Point to 1st block of outgoing msg
	MOVE	S1,.MSCOD(MI)		;[23]Pick up the PID
	MOVEM	S1,G$SND##		;[23]Overwrite NEBULA's PID
	MOVX	S1,MF.NEB		;[23]Pick up the remote origin bit
	IORM	S1,.MSFLG(MO)		;[23]Place in the outgoing message
	SETOM	G$NSHW			;[23]Indicate request came remotely
	$CALL	REMRSP##		;[23]Respond to the WTOR
	JUMPF	N$RS.1			;[23]Go indicate if an error occurred
	SKIPN	G$ERR##			;[23]Need to send a remote ACK?
;**;[33]At N$NSM:-3L change 1 line  JCR  5/2/90
	JRST	N$RS.2			;[33]No, send a Null ACK
	JRST	N$RS.1			;[23]Indicate an error has occurred
N$NSM:	MOVEI	S1,E$NSM##		;[23]No such message
	$CALL	0(S1)			;[23]Place error offset in G$ERR
N$RS.1:	SETOM	G$NERR			;[23]Indicate must build a remote ACK	
	$RETF				;[23]Indicate an error occurred
;**;[33]At N$RS.1:+2L add 14 lines  JCR  5/2/90
N$RS.2:	MOVE	P1,TF			;[33]Remember the T/F indicator
	$CALL	M%GPAG			;[33]Pick up a page
	MOVE	S2,[PAGSIZ,,.OMNAK]	;[33]Pick up message type
	MOVEM	S2,.MSTYP(S1)		;[33]Place in the message
	MOVE	S2,.MSCOD(MI)		;[33]Pick up the PID
	MOVEM	S2,.MSCOD(S1)		;[33]Place in the message
	MOVE	P2,MO			;[33]Remember first output page address
	MOVE	MO,S1			;[33]Place address where expected
	$CALL	N$SNEB			;[33]Send the message to NEBULA
	SKIPT				;[33]Don't release page on success
	$CALL	RELPAG			;[33]Release the page
	MOVE	MO,P2			;[33]Pick up first output page address
	MOVE	TF,P1			;[33]Pick up original T/F indicator
	$RET				;[33]Return to the caller

;**;[26]At N$RS.1:+1L add routine N$LOG  JCR  2/1/90

	SUBTTL	N$LOG - Close the Log File

;[26]N$LOG is called to close the OPR log file.
;[26]
;[26]Call is:       MI/Address of the CLOSE LOG message
;[26]		     MO/Address of outgoing IPCF message
;[26]		     S1/CLOSE LOG message code (.OMCLO)
;[26]Returns true:  The log file has been closed, renamed and a new log
;[26]		     file has been opened.
;[26]Returns false: Logging is not enabled or an error occurred in either
;[26]		     closing, renaming or opening the new log file.

N$LOG:	$CALL	L$NEB			;[26]Log the message
	$CALL	RELPAG			;[26]Release the outgoing page
	MOVE	S1,MI			;[26]Pick up the message address
	MOVEI	S2,.NDENM		;[26]Check for the node block
	$CALL	N$FBLK			;[26]Find the node argument block
	JUMPF	N$LO.1			;[26]If not found, pass back error
	MOVE	S1,ARG.DA(S1)		;[26]Pick up the node name
	MOVEM	S1,G$REMN		;[26]Save for any $QWTO
	MOVEM	S1,G$NEBF		;[26]Indicate remote for any $QWTO
	$CALL	L$CLOS##		;[26]Close the log file
	$RET				;[26]Preserve any error indicator

N$LO.1:	SETOM	G$NERR			;[26]Indicate must build a remote ACK	
	$CALL	E$IFC			;[26]Indicate illegally formatted msg

;**;[27]At N$LO.1:+2L add routine N$REP  JCR  2/14/90

	SUBTTL	N$REP - REPORT a Device Error

;[27]N$REP is called to place an entry in SYSERR
;[27]
;[27]Call is:        MI/Address of the REPORT message
;[27]		     MO/Address of outgoing IPCF message
;[27]		     S1/REPORT message code (.OMREP)
;[27]Returns false:  Always. This is because an MT.TXT message is
;[27]                always sent.

N$REP:	$CALL	L$NEB			;[27]Log the message
	$CALL	RELPAG			;[27]Not sending a message to QUASAR
	LOAD	S2,.OHDRS+ARG.HD(MI),AR.LEN ;[27]Pick up block length
	MOVEI	S1,.OHDRS+ARG.DA(MI)	;[27]Pick up block address
	SYERR%				;[27]Do the SYSERR update
	 ERJMP	N$RE.1			;[27]Go indicate the update failed
	$CALL	E$SEM##			;[27]Indicate SYSERR entry was made
	SKIPA				;[27]Set the MT.TXT message flag
N$RE.1:	$CALL	E$SUF##			;[27]SYSERR update failed
	SETOM	G$NERR			;[27]Indicate must build an MT.TXT msg
	$RET				;[27]Return to the caller
;**;[31]At N$RE.1:+3L add routines N$CLAS, N$FILE, N$LGNG and N$SEMI
;**;[31]  JCR  2/22/90

	SUBTTL	N$CLAS - Process an ENABLE/DISABLE CLASS-SCHEDULER Message

;[31]N$CLAS is called to Enable or Disable class scheduling
;[31]
;[31]Call is:        MI/Address of the CLASS-SCHEDULER message
;[31]		      MO/Address of outgoing IPCF message
;[31]		      S1/Message code (.OMECS or .OMDCS)
;[31]Returns false:  Always. This is because an MT.TXT message is
;[31]                always sent.

N$CLAS:	$SAVE	<P1,P2,P3>		;[31]Save these AC
	SETZ	P1,			;[31]Assume enable
	CAIE	S1,.OMECS		;[31]Enable request?
	SETO	P1,			;[31]No, indicate disable
	$CALL	L$NEB			;[31]Log the message
	$CALL	RELPAG			;[31]Not sending a message to QUASAR
	MOVE	S1,MI			;[31]Pick up the message address
	MOVEI	S2,.SCBLK		;[31]SKED% argument value block
	$CALL	N$FBLK			;[31]Pick up the block
	JUMPF	N$CL.2			;[31]Quit on an error
	MOVE	P3,ARG.DA(S1)		;[31]Pick up the SKED% data
	MOVEI	S1,.SKICS		;[31]Pick up the function
	MOVEI	S2,P2			;[31]Point to the SKED% argument block
	MOVEI	P2,.SACTL+1		;[31]Size of the block
	SKED%				;[31]Start or stop the scheduler
	ERJMP	N$CL.1			;[31]Trap the error
	MOVEI	S1,[ASCIZ/enabled/]	;[31]Assume enabling
	SKIPE	P1			;[31]Enabling?
	MOVEI	S1,[ASCIZ/disabled/]	;[31]No, disabling
	MOVEM	S1,G$ARG1		;[31]Save for routine E$CSE
	$CALL	E$CSE			;[31]Scheduler enabled/disabled
	JRST	N$CL.3			;[31]Go finish up

N$CL.1:	MOVE	S1,[EXP -2]		;[31]The last TOPS-20 error
	MOVEM	S1,G$ARG1		;[31]Save for routine E$CSF
	$CALL	E$CSF			;[31]Indicate class scheduler error
	SKIPA				;[31]Go finish up
N$CL.2:	$CALL	E$IFC			;[31]Indicate illegally formatted msg
N$CL.3:	SETOM	G$NERR			;[31]Indicate must build a remote ACK	
	$RET				;[31]Return to the caller

	SUBTTL	N$FILE - Process an ENABLE/DISABLE FILE-RETRIEVAL Message

;[31]N$FILE is called to enable or disable file retrievals
;[31]
;[31]Call is:        MI/Address of the File Retrieval message
;[31]		      MO/Address of outgoing IPCF message
;[31]		      S1/Message code (.OMEFI or .OMDFI)
;[31]Returns false:  Always. This is because an MT.TXT message is
;[31]                always sent.

N$FILE:	$SAVE	<P1>			;[31]Save this AC
	SETZ	P1,			;[31]Assume enable
	CAIE	S1,.OMEFI		;[31]Enable request?
	SETO	P1,			;[31]No, indicate disable
	$CALL	L$NEB			;[31]Log the message
	$CALL	RELPAG			;[31]Not sending a message to QUASAR
	MOVEI	S1,[ASCIZ/enable/]	;[31]Assume enable
	SKIPE	P1			;[31]Enabling?
	MOVEI	S1,[ASCIZ/disable/]	;[31]No, disabling
	MOVEM	S1,G$ARG1		;[31]Save for MT.TXT message
	MOVEI	S1,.SFRTW		;[31]Pick up the function code
	MOVE	S2,P1			;[31]Same as the ENABLE/DISABLE value
	SMON%				;[31]Set the value
	ERJMP	N$FI.1			;[31]Go indicate an error occurred
	$CALL	E$FRW			;[31]File retrieval waits modified
	SKIPA				;[31]Go finish up
N$FI.1:	$CALL	E$RWF			;[31]Indicate error
	SETOM	G$NERR			;[31]Indicate must build a remote ACK	
	$RET				;[31]Return to the caller

	SUBTTL	N$LGNG - Process an ENABLE/DISABLE LOGGING Message

;[31]N$LGNG is called to enable or disable logging
;[31]
;[31]Call is:        MI/Address of the Logging message
;[31]		      MO/Address of outgoing IPCF message
;[31]		      S1/Message code (.OMELG or .OMDLG)
;[31]Returns false:  Always. This is because an MT.TXT message is
;[31]                always sent.

N$LGNG:	$SAVE	<P1>			;[31]Save this AC
	SETZ	P1,			;[31]Assume enable
	CAIE	S1,.OMELG		;[31]Enable request?
	SETO	P1,			;[31]No, indicate disable
	$CALL	L$NEB			;[31]Log the message
	$CALL	RELPAG			;[31]Not sending a message to QUASAR
	SKIPN	P1			;[31]Disabling?
	JRST	N$LG.1			;[31]No, enabling
	$CALL	L$REL##			;[31]Release the log file
	JUMPF	N$LG.4			;[31]Indicate error to remote operator
	SETZM	LOGINT##		;[31]Logging disabled
	$CALL	E$LFC			;[31]Set log file closed
	MOVE	P1,G$ERR		;[31]Destroyed by N$SNDA
	JRST	N$LG.3			;[31]Indicate to the remote operator
N$LG.1:	SETOM	LOGINT##		;[31]Assume success
	$CALL	L$OPNL##		;[31]Open the log file
	JUMPT	N$LG.2			;[31]Go tell the operators
	SKIPN	LOGOPN##		;[31]Log file already open?
	SETZM	LOGINT##		;[31]No, so couldn't open it
	JRST	N$LG.4			;[31]Go indicate an error
	SETOM	LOGINT##		;[31]Mark logging enabled
N$LG.2:	$CALL	E$OLO			;[31]ORION log file open
	MOVE	P1,G$ERR		;[31]Destroyed by N$SNDA
N$LG.3:	$CALL	N$SNDA			;[31]Message to all operators
	MOVEM	P1,G$ERR		;[31]Save the error code
	SKIPA				;[31]Indicate error for NEBULA
N$LG.4:	$CALL	E$LFE			;[31]Indicate a log file error
	SETOM	G$NERR			;[31]Indicate must build a remote ACK	
	$RET				;[31]Return to the caller

	SUBTTL	N$SNDA - Send a Text Message to all the Operators

;[31]Routine N$SNDA sends a text (MT.TXT) message to all operators
;[31]that is the result of a remote operator request.
;[31]Call is: No arguments
;[31]Returns: The text message has been sent to all the local operators
;[31]Assumes: WDANHD contains the SIXBIT node name where the request
;[31]         originated.

N$SNDA: LOAD	S1,G$JOB##		;[31]Get the  job number
	$CALL	GETJOB##		;[31]Get the job information
	$CALL	BLDRAK##		;[31]Build the ACK
	SETOM	S1			;[31]Send to all
	SETZM	G$ERR			;[31]Clear the error word
	SETOM	G$ASND##		;[31]Force the message out
	$CALL	SNDAOP##		;[31]Send to all operators
	$RET				;[31]Return to the caller

	SUBTTL	N$SEMI - Process an ENABLE/DISABLE SEMI-OPR Message

;[31]N$SEMI is called to enable or disable SEMI-OPRs
;[31]
;[31]Call is:        MI/Address of the SEMI-OPR message
;[31]		      MO/Address of outgoing IPCF message
;[31]		      S1/Message code (.OMESO or .OMDSO)
;[31]Returns false:  Always. This is because an MT.TXT message is
;[31]                always sent.

N$SEMI:	$SAVE	<P1>			;[31]Save this AC
	SETZ	P1,			;[31]Assume enable
	CAIE	S1,.OMESO		;[31]Enable request?
	SETO	P1,			;[31]No, indicate disable
	$CALL	L$NEB			;[31]Log the message
	$CALL	RELPAG			;[31]Not sending a message to QUASAR
	JUMPN	P1,N$SE.1		;[31]Go disable SEMI-OPRs
	MOVEI	S1,[ASCIZ/enable/]	;[31]Get the enable text
	MOVEM	S1,G$ARG1		;[31]Save the value for the MT.TXT msg
	SETZM 	G$SEMF##		;[31]Indicate SEMI-OPR is enabled
	$CALL	E$SMO			;[31]Indicate result of the command
	JRST	N$SE.2			;[31]Indicate message for NEBULA

;[31]Do the DISABLE SEMI-OPR command

N$SE.1:	MOVEI	S1,[ASCIZ/disable/]	;[31]Get the disable text
	MOVEM	S1,G$ARG1		;[31]Save the value for the MT.TXT msg
	SETOM 	G$SEMF##		;[31]Indicate SEMI-OPR is disabled
	$CALL	E$SMO			;[31]Indicate result of the command
	$CALL	DELSOP##		;[31]Delete any SEMI-OPRs
N$SE.2:	SETOM	G$NERR			;[31]Indicate must build a remote ACK	
	$RET				;[31]Return to the caller

;**;[32]At N$SE.2:+2L add routines N$BCW and N$SBC JCR  4/27/90

	SUBTTL	N$BCW - Process an ENABLE/DISABLE BROADCAST-MESSAGES Message

;[32]N$BCW is called to enable or disable WTO broadcasting
;[32]
;[32]Call is:         MI/Address of the BROADCAST-MESSAGES message
;[32]		       MO/Address of outgoing IPCF message
;[32]		       S1/Message code (.OMEBM or .OMDBM)
;[32]Returns false:   Always. This is because an MT.TXT message is
;[32]                 always sent.

N$BCW:	$SAVE	<P1,P2>			;[32]Save some scratch ACs
	SETZ	P1,			;[32]Assume enable
	CAIE	S1,.OMEBM		;[32]Enable request?
	SETO	P1,			;[32]No, indicate disable
	$CALL	L$NEB			;[32]Log the message
	$CALL	RELPAG			;[32]Not sending a message to QUASAR

	MOVE	S1,MI			;[32]Pick up the message address
	MOVEI	S2,.BMPAR		;[32]Pick up the block type
	$CALL	N$FBLK			;[32]Find the block
	JUMPF	N$BC.1			;[32]Quit if no such block
	MOVE	S2,BMC.ND(S1)		;[32]Pick up the node name
	MOVEM	S2,G$ARG1		;[32]Save for later
	MOVEI	S2,.BMOTM		;[32]Assume msg associated w/ object
	MOVEI	P2,MSGARG		;[32]Assume msg associated w/ object
	CAME	S2,BMC.CL(S1)		;[32]Is it?
	MOVEI	P2,DISARG		;[32]No, so indicate so
	MOVEM	P2,CLSTYP		;[32]Save the message class type
	DMOVE	S1,BMC.A1(S1)		;[32]Pick up the data
	DMOVEM	S1,0(P2)		;[32]Save for later
	SETZM	G$CLUN			;[32]Indicate don't forward message
	$CALL	ENAB.1##		;[32]Update the message display queue
	SKIPA				;[32]Set remote ACK word

N$BC.1:	$CALL	E$IFC			;[32]Indicate illegally formatted msg
	SETOM	G$NERR			;[32]Indicate must build a remote ACK	
	$RET				;[32]Return to the caller

	SUBTTL	N$SBC - Process a SHOW BROADCAST-MESSAGES Message

;[32]N$SBC is called to process a remote SHOW BROADCAST-MESSAGS message.
;[32]
;[32]Call is:         MI/Address of the SHOW BROADCAST-MESSAGES message
;[32]		       MO/Address of outgoing IPCF message
;[32]		       S1/Message code (.OMSBM)
;[32]Returns true:    The SHOW BROADCAST-MESSAGES display has been built
;[32]Returns false:   The BROADCAST-MESSAGES queue is empty

N$SBC:	$SAVE	<P1,P2>			;[32]Save some scratch ACs
	$CALL	L$NEB			;[32]Log the message
	MOVEI	S1,.OMDSP		;[32]Pick up the message type
	$CALL	BLDHDR			;[32]Build the remote header
	MOVE	S1,MI			;[32]Pick up the message address
	MOVEI	S2,.ORNOD		;[32]Pick up the block type
	$CALL	N$FBLK			;[32]Find the block
	JUMPF	N$SB.1			;[32]Quit if no such block
	MOVE	S2,ARG.DA(S1)		;[32]Pick up the node name
	MOVEM	S2,G$ARG1		;[32]Save for later
	SETZM	G$CLUN			;[32]Indicate don't forward message
	$CALL	SHWB.2##		;[32]Update the message display queue
	JUMPF	N$SB.1			;[32]Indicate if an error occurred
	$CALL	FINSHW			;[32]Finish the message and send
	$RET				;[32]Return to the caller

N$SB.1:	SETOM	G$NERR			;[32]Indicate must build a remote ACK	
	$RET				;[32]Return to the caller

	SUBTTL	N$FNOD - Find a Node Entry

;[23]N$FNOD is called to find the node entry address of a node in the
;[23]node list.
;[23]
;[23]Call is:       S1/Sixbit node name whose entry is to be found
;[23]Returns true:  S2/Node entry address
;[23]Returns false: The node entry does not exist

N$FNOD:	MOVEM	S1,G$ARG1		;[23]Save in case of an error
	$CALL	FNDNOD			;[23]Validate the node
	$RETIT				;[23]Found the node entry
	MOVEI	S1,E$NNK##		;[23]Node not known
	$CALL	0(S1)			;[23]Place error offset in G$ERR
	SETOM	G$NERR			;[23]Log and send an error ACK
	$RET				;[23]Preserve the failure indicator

	SUBTTL	N$FBLK - Find a specified message block

;N$FBLK is called to find a specified message block in a message
;
;Call is:       S1/Message address
;               S2/Block type code
;
;Returns true:  S1/Block address
;Returns false: Requested block type not found in the message

N$FBLK:	$SAVE	<P1,P2>			;SAVE THESE AC
	MOVE	P1,.OARGC(S1)		;PICK UP THE NUMBER OF ARGUMENT BLOCKS
	MOVEI	S1,.OHDRS(S1)		;POINT TO THE FIRST BLOCK
	
N$FB.1:	LOAD	P2,ARG.HD(S1),AR.TYP	;PICK UP THE BLOCK'S TYPE
	CAMN	S2,P2			;IS THIS THE BLOCK BEING SEARCHED FOR?
	$RETT				;YES, RETURN NOW
	LOAD	P2,ARG.HD(S1),AR.LEN	;NO, PICK UP THIS BLOCK'S LENGTH
	ADD	S1,P2			;POINT TO THE NEXT BLOCK
	SOJG	P1,N$FB.1		;CHECK THE NEXT BLOCK IF THERE IS ONE
	
	$RETF				;INDICATE BLOCK NOT FOUND

	SUBTTL	N$SQSR - Send messages to QUASAR, NEBULA and MOUNTR routines

N$SQSR:	SKIPA	S1,[SP.QSR+SI.FLG]	;PICK UP QUASAR'S PID INDEX
N$SMDA:	MOVX	S1,SP.MDA+SI.FLG	;[3]PICK UP MOUNTR'S PID INDEX
	SKIPA				;SKIP OVER PICKING UP MOUNTR'S INDEX
N$SNEB:	MOVX	S1,SP.NEB+SI.FLG	;[3]PICK UP NEBULA'S PID INDEX

	STORE	S1,SNDBLK+SAB.SI	;PLACE PID INDEX INTO SAB
	SETZM	SNDBLK+SAB.PD		;ZERO OUT THE PID WORD
	MOVEI	S2,PAGSIZ		;INDICATE THERE IS A PAGE WITH THIS MSG
	$CALL	SNDCGP			;SEND THE MESSAGE
	$RET				;PRESERVE THE T/F INDICATOR

	SUBTTL	BLDHDR - Build the GALAXY message header

;Call is: S1/Message code

BLDHDR:	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE MESSAGE CODE VALUE IN MESSAGE
	DMOVE	S1,.MSFLG(MI)		;PICK UP THE FLAG AND ACK CODE WORDS
	DMOVEM	S1,.MSFLG(MO)		;PLACE IN THE MESSAGE
	MOVX	S1,WT.SJI!WT.NFO	;SUPPRESS JOB INFO + MSG FORMATTED 
	MOVEI	S2,1			;NUMBER OF ARGUMENT BLOCKS
	DMOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	P3,.OHDRS(MO)		;POINT TO FIRST ARGUMENT BLOCK
	$CALL	CPYDSP			;COPY OVER THE DISPLAY BLOCK
	MOVE	S1,MI			;PICK UP ADDRESS OF INCOMING MESSAGE
	MOVEI	S2,.NDENM		;PICK UP BLOCK TYPE TO SEARCH FOR
	$CALL	N$FBLK			;FIND THE NODE BLOCK
	MOVE	S1,ARG.DA(S1)		;PICK UP THE NODE NAME
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;SAVE FOR ACK AND ERROR DISPLAYS
	$RET				;RETURN TO THE CALL

	SUBTTL	FINSHW - Send a SHOW MESSAGES or SHOW OPERATORS message

FINSHW:	ANDI	P3,777			;ISOLATE THE MESSAGE LENGTH
	STORE	P3,.MSTYP(MO),MS.CNT	;PLACE IN MESSAGE
	$CALL	L$NRSW##		;LOG THE MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP ADDRESS OF NEBULA'S NAME
	MOVEM	S1,G$ARG1		;PLACE WHERE ERROR STRING EXPECTS IT
	SETOM	G$NACK			;DON'T ACK THE SENDER
	$CALL	E$IAP			;PLACE ERROR OFFSET IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	CPYMSG - Copy an incoming message to an outgoing message

CPYMSG:	LOAD	S2,.MSTYP(MI),MS.CNT	;PICK UP THE MESSAGE LENGTH
	ADD	S2,MO			;DESTINATION ADDRESS + 1
	MOVE	S1,MO			;DESTINATION
	HRL	S1,MI			;SOURCE,,DESTINATION
	BLT	S1,-1(S2)		;COPY THE MESSAGE
	$RET				;RETURN TO THE CALLER

	SUBTTL	GETMSG - PICK UP MESSAGE FOR SHOW MESSAGES COMMAND

;GETMSG is called to pick up the message address of the message specified
;in a SHOW MESSAGES command
;
;Call is:       S1/Message number
;               S2/Node list entry address
;
;**;[23]At GETMSG:-3L change 1 line
;[23]Returns true:  S2/Address of the message
;Returns false: The message was not found

GETMSG:	$SAVE	<P1,P2>			;SAVES THESE AC
	DMOVE	P1,S1			;SAVE MESSAGE NUMBER, NODE ENTRY ADR

	MOVEI	T1,MSL.ID		;PICK UP ID NUMBER OF MESSAGE
	HRRM	T1,FNDXCT		;SAVE FOR THE COMPARE
	$CALL	CHKMSG			;LOOK FOR THE MESSAGE ON LOCAL NODE
	$RETIT				;RETURN NOW IF MESSAGE WAS FOUND

	DMOVE	S1,P1			;PICK UP MSG NUMBER, NODE ENTRY ADDRESS
	MOVEI	T1,MSL.ID		;PICK UP ID NUMBER OF MESSAGE
;**;[23]At GETMSG:+9L add 1 line  JCR  11/29/89
	HRRM	T1,FNDXCT		;[23]SAVE FOR COMPARE
	$CALL	FNDMSG			;LOOK FOR MESSAGE ON ALL NODES
	$RET				;PRESERVE T/F INDICATOR

	SUBTTL	N$BLDP - Build the remote .ORDSP block

N$BLDP:	$SAVE	<P1>			;SAVE THIS AC

	MOVEI	P1,DISBLK		;PICK UP ADDRESS OF THE DISPLAY BLOCK
	$TEXT	(<-1,,ARG.DA+1(P1)>,< Received message from ^N/G$HOST/::^0>)
	MOVEI	S2,ARG.DA+1(P1)		;[4]PICK UP ADDRESS OF THE MESSAGE
	HRLI	S2,(POINT 7,)		;[4]MAKE INTO A POINTER
	SETZ	S1,			;NUMBER OF CHARACTERS IN MESSAGE

N$BL.1:	ILDB	P1,S2			;PICK UP THE NEXT BYTE
	AOS	S1			;INCREMENT THE NUMBER OF CHARACTERS
;**;[23]At N$BL.1:+2L replace 2 lines with 1 line  JCR  11/29/89
	JUMPN	P1,N$BL.1		;[23]Get the next character

	IDIVI	S1,5			;MESSAGE LENGTH IN WORDS
	SKIPE	S2			;ANY FRACTIONAL WORDS?
	AOS	S1			;YES, COUNT AS AN ENTIRE WORD
	ADDI	S1,2			;[4]INCLUDE HEADER AND UDT WORDS
	MOVSS	S1			;PLACE LENGTH IN EXPECTED PLACE
	HRRI	S1,.ORDSP		;PICK UP THE BLOCK TYPE
	MOVEM	S1,DISBLK		;PLACE IN THE MESSAGE
;**;[23]At N$BL.1:+12L add 3 lines  JCR  11/29/89

	MOVE	S1,[.NDESZ,,.NDENM]	;[23]Pick up cluster node header word
	MOVEM	S1,G$CBLK##		;[23]Save for /CLUSTER-NODE commands	
	$RET				;RETURN TO THE CALLER
;**;[34]After routine N$BLDP add routines N$DAK and N$SAK  PMM  6/3/90

	SUBTTL	N$DAK - Process the Remote DEFINE ALIAS Message

;[34]Routine N$DAK processes OPR DEFINE ALIAS messages.  It sets up the 
;[34]following data which are needed for DEFINE ALIAS processing:
;[34]the standard object block AKAOBJ, G$ARG2 and G$ARG3.
;[34]Call is:      MI/Address of the DEFINE ALIAS message
;[34]              MO/Address of outgoing IPCF message
;[34]Returns true: Always

N$DAK:	$SAVE	<P1,P2>			;[34]Save some ACs
	$CALL	L$NEB			;[34]Log the message
	MOVE	S1,MI			;[34]Get message address
	MOVEI	S2,.NDENM		;[34]Get block type
	$CALL	N$FBLK			;[34]Find block type in message
	JUMPF	N$DA.4			;[34]If none, indicate error
	MOVE	S1,ARG.DA(S1)		;[34]Get remote node name from message
	MOVEI	S2,G$CBLK##		;[34]Get address of global data block
	MOVEM	S1,ARG.DA(S2)		;[34]Save node name for later use
	SETZM	G$CLUN			;[34]Clear node(s) value
	SETZM	G$ARG2##		;[34]Clear alias to be deleted
	MOVEI	P1,.OHDRS(MI)		;[34]Point at first argument
	MOVE	S1,ARG.DA(P1)		;[34]Get 'new' alias name
	MOVEM	S1,G$ARG3##		;[34]Save for later
	ADDI	P1,.AKASZ		;[34]Point at next block
	HRRZ	S1,ARG.HD(P1)		;[34]Get block type
	CAIN	S1,.OROBJ		;[34]Is it an object block?
	JRST	N$DA.2			;[34]Yes process printer specification
;[34]It is an unDEFINE message
	$CALL	DEF.1B##		;[34]Process unDEFINE ALIAS message
	JUMPT	N$DA.6			;[34]Page has already been released
	$CALL	RELPAG			;[34]Release page if bad return
	JRST	N$DA.6			;[34]Indicate must send a remote ACK

N$DA.2:	HRLI	T1,(P1)			;[34]Get source address
	HRRI	T1,AKAOBJ		;[34]Get source,,destination address
	BLT	T1,AKAOBJ+OBJ.SQ	;[34]Move the entire object block
	MOVE	S1,AKAOBJ+ARG.DA+OBJ.TY	;[34]Pick up the printer type
	TXZE	S1,.RMLPT		;[34]Node switch specified?
	JRST	N$DA.3			;[34]Yes, so keep node name as is
	CAME	S1,[.OTLPT]		;[34]A local printer?
	JRST	N$DA.4			;[34]No, so doesn't apply
	MOVE	S1,G$HOST		;[34]Pick up the local node name
	MOVEM	S1,AKAOBJ+ARG.DA+OBJ.ND	;[34]Save in the object block
	SKIPA				;[34]Don't update the printer type
N$DA.3:	MOVEM	S1,AKAOBJ+ARG.DA+OBJ.TY	;[34]Save the updated printer type
N$DA.4:	MOVEI	S1,AKAOBJ+1		;[34]Pick up the object block address
	$CALL	FINDPR##		;[34]Is it in the linked list?
	JUMPF	N$DA.5			;[34]No, so don't indicate so
	MOVE	S1,OBJAKA(S2)		;[34]Get the old alias
	MOVEM	S1,AKAOBJ+OBJ.AK+1	;[34]Save it in the object block

N$DA.5: $CALL	DEF.6A##		;[34]Process the DEFINE ALIAS message
	SKIPT				;[34]Page has already been released
	$CALL	RELPAG			;[34]Release page if bad return
N$DA.6:	SETOM	G$NERR			;[34]Indicate must send a remote ACK
	$RET				;[34]Return to the caller

	SUBTTL	N$SAK - Process the Remote SHOW ALIAS Message

;[34]Routine N$SAK processes OPR SHOW ALIAS messages.  It sets up the 
;[34]the standard object block AKAOBJ which is needed for SHOW ALIAS 
;[34]processing.
;[34]Call is:       MI/Address of the DEFINE ALIAS message
;[34]               MO/Address of outgoing IPCF message
;[34]Returns true:  One or more aliases have been defined
;[34]Returns false: No aliases have been defined

N$SAK:: $SAVE	<P1,P2>			;[34]Save these ACs
	$CALL	L$NEB			;[34]Log message
	SETZM	G$CLUN			;[34]Clear node(s) value
	SETOM	G$NSHW			;[34]Indicate remote processing
	SETZM	AKAOUT##		;[34]Assume no eligible entries
	MOVEI	S1,.OMDSP		;[34]Pick up the message header
	$CALL	BLDHDR			;[34]Build the GALAXY message header
	MOVEI	P1,.OHDRS+ARG.DA(MI)	;[34]Point at object block
	MOVEI	P4,AKAOBJ		;[34]Get address of model object block

;[34]Initialize standard object block

	HRLI	T1,(P1)			;[34]Save source address
	HRRI	T1,AKAOBJ		;[34]Save source,,destination address
	BLT	T1,AKAOBJ+OBJ.SQ-1	;[34]Initialize entire object block
	SETZM	LSTENT			;[34]Initialize last entry type
	
	MOVEI	T1,AKAOBJ		;[34]Get destination address
	MOVE	P2,OBJ.AK(T1)		;[34]Get alias from object block
	CAME	P2,[-1]			;[34]Is there an alias?
	JRST	N$SA.2			;[34]Yes process for an alias name
	$CALL	SHWA.6##		;[34]Process for printer specification
	SKIPA				
N$SA.2:	$CALL	SHWA.3##		;[34]Yes process the show alias
	JUMPT	FINSHW			;[34]Finish and send to NEBULA
N$SA.3:	SETOM	G$NERR			;[34]Indicate an error occurred
	$RET				;[34]Return


	SUBTTL	CPYDSP - Copy the REMOTE DISPLAY block

;CPYDSP copies the built REMOTE DISPLAY block into the message being built
;
;Call is: P3/Address of the message's REMOTE DISPLAY block
;
;Returns: The REMOTE DISPLAY block has been copied into the message
;         P3/Address of the next block

CPYDSP:	MOVE	S1,P3			;PICK UP MESSAGE BLOCK ADDRESS
	HLRZ	S2,DISBLK		;PICK UP THE BLOCK LENGTH
	ADD	S2,S1			;END OF DESTINATION + 1
	HRLI	S1,DISBLK		;SOURCE,,DESTINATION
	BLT	S1,-1(S2)		;COPY THE BLOCK INTO THE MESSAGE
	MOVE	P3,S2			;[4]ADDRESS OF THE NEXT BLOCK
	$RET				;RETURN TO THE CALL

	SUBTTL N$SETJ - REMOTE SET JOB command
;**;[35]AtCPYDSP+6L add 31 lines JYCW  6/8/90
;Add routine N$SETJ to process a remote SET JOB command.

N$SETJ:	SETOM	G$NERR			;[35]Indicate this needs a remote ACK
	$CALL	L$NEB			;[35]Log the message
	$CALL	RELPAG			;[35]Release the outgoing page
	MOVE	S1,MI			;[35]Pick up the message address
	MOVEI	S2,.NDENM		;[35]Check for the node block
	$CALL	N$FBLK			;[35]Find the node argument block
	JUMPF	N$SET2			;[35]If not found, pass back error
	MOVE	S1,ARG.DA(S1)		;[35]Pick up the node name
	MOVEM	S1,G$REMN		;[35]Save for any $QWTO
	MOVEM	S1,G$NEBF		;[35]Indicate remote for any $QWTO
	MOVE	S1,MI			;[35]Pick up the message address
	MOVEI	S2,.STJOB		;[35]Set Job Block
	$CALL	N$FBLK			;[35]Find the block
	IFE. TF				;[35]No, how about .STSCH
	  MOVE	S1,MI			;[35]Pick up the message address
	  MOVEI	S2,.STSCH		;[35]Set Job Block
	  $CALL	N$FBLK			;[35]Find the block
	  JUMPF	N$SET2			;[35]No set job block!!
	  HRRZ	P1,ARG.DA(S1)		;[35]Job number
	  HLRZ	P2,ARG.DA(S1)		;[35]Data
	  MOVEM	P1,G$ARG1		;[35]SAVE THE JOB NUMBER
	  $CALL	SETJ.S			;[35]SET JOB SCH
	ELSE.				;[35]
	  HRRZ	P1,ARG.DA(S1)		;[35]Job number
	  HLRZ	P2,ARG.DA(S1)		;[35]Data
	  MOVEM	P1,G$ARG1		;[35]SAVE THE JOB NUMBER
	  $CALL	SETJ.W			;[35]SET JOB NOOPR/OP
	ENDIF.				;[35]
	$RET				;[35]
N$SET2:	$RETF				;[35]

	SUBTTL N$SEDO - REMOTE SEND OPERATOR command
;Add routine N$SEDO to process a remote SEND OPERATOR command.

N$SEDO:$CALL	L$NEB			;[35]Log the message
	$CALL	RELPAG			;[35]Release the outgoing page
	MOVE	S1,MI			;[35]Pick up the message address
	MOVEI	S2,.NDENM		;[35]Check for the node block
	$CALL	N$FBLK			;[35]Find the node argument block
	JUMPF	N$SET2			;[35]If not found, pass back error
	MOVE	S1,ARG.DA(S1)		;[35]Pick up the node name
	MOVEM	S1,G$REMN		;[35]Save for any $QWTO
	MOVEM	S1,G$NEBF		;[35]Indicate remote for any $QWTO
	$CALL	GETPAG			;[35]Get an output page
	MOVE	S1,MI			;[35]Pick up the message address
	MOVEI	S2,.CMTXT		;[35]Text block
	$CALL	N$FBLK			;[35]Find the block
	JUMPF	N$SED2			;[35]No message block
	MOVEI	P3,ARG.DA(S1)		;[35]Save the message address
	HRLI	S2,(S1)			;[35]Source
	HRRI	S2,.OHDRS(MO)		;[35]Out message
	LOAD	S1,ARG.HD(S1),AR.LEN	;[35] PICK UP THIS BLOCK'S LENGTH
	STORE	S1,.MSTYP(MO),MS.CNT	;[35]Store it in out message
	ADDI	S1,(S2)			;[35]
	BLT	S2,-1(S1)		;[35]Store the text message 
	AOS	.OARGC(MO)		;[35]BUMP THE ARGUMENT COUNT
	MOVX	S1,.OMDSP		;[35]Message type
	STORE	S1,.MSTYP(MO),MS.TYP	;[35]Store it in out message
	LOAD	S1,.MSTYP(MO),MS.CNT	;[35]Store it in out message		
	ADDI	S1,.OHDRS		;[35]Add in the galaxy header size
	STORE	S1,.MSTYP(MO),MS.CNT	;[35]Store it in out message
	MOVE	S1,MI			;[35]Pick up the message address
	MOVEI	S2,.ORNOD		;[35]/NODE block?
	$CALL	N$FBLK			;[35]Find the block
	IFN. TF				;[35]No,
	  MOVE	S1,ARG.DA(S1)		;[35]Data
;**;[36]At N$SEDO+32L add 1 line JYCW 6/11/90
	  MOVEM S1,G$ARG1		;[36]Save it for error
	  $CALL	FNDNOD			;[35]Find the node
	  JUMPF	E$NNK			;[35]The node is not known
	  MOVE	S1,S2			;[35]Get node entry address
	  SETOM	NOALTN			;[35]No alternate nodes
	  $CALL	SNDNAL			;[35]Send to all OPRs no alternates
	  JUMPF	E$NON			;[35]No OPRs at node and return
	ELSE.				;[35]
	  SETOM	S1			;[35]Send to all OPRS
	  $CALL	SNDAOP			;[35]Send to all
	ENDIF.				;[35]
	$RETT				;[35]
N$SED2:	$RETF				;[35]

	SUBTTL	NEBSTR - NEBULA message log file headers

NEBSTR:	$STAB

	.NRDSM,,[ITEXT(<REMOTE DISMOUNT message received from MOUNTR>)]
	.NFDSM,,[ITEXT(<FROM NEBULA DISMOUNT message received from node ^N/S1/>)]
	.NFDAK,,[ITEXT(<FROM NEBULA DISMOUNT ACK message received from MOUNTR>)]
	.NTDAK,,[ITEXT(<TO NEBULA DISMOUNT ACK message received from NEBULA>)] ;[16]
	.NCDSM,,[ITEXT(<NEBULA CANCEL DISMOUNT message received from MOUNTR>)]
	.NFMTS,,[ITEXT(<FROM NEBULA MOUNT message received from node ^N/S1/>)]

	.NSHOP,,[ITEXT(<SHOW OPERATORS message received from node ^N/S1/>)]
	.NMESS,,[ITEXT(<SHOW MESSAGES message received from node ^N/S1/>)]
	.NMSHS,,[ITEXT(<SHOW STATUS message received from node ^N/S1/>)]
	.NDSTR,,[ITEXT(<SHOW STATUS STRUCTURE message received from node ^N/S1/>)]
	.NDSHD,,[ITEXT(<SHOW STATUS DISK message received from node ^N/S1/>)]
	.NDSHT,,[ITEXT(<SHOW STATUS TAPE message received from node ^N/S1/>)]
	.NMSSN,,[ITEXT(<SHOW STATUS NETWORK message received from node ^N/S1/>)]
	.NMSPN,,[ITEXT(<SHOW PARAMETER NETWORK message received from node ^N/S1/>)]
	.NDSCD,,[ITEXT(<SHOW CONFIGURATION message received from node ^N/S1/>)]	
	.NMSHQ,,[ITEXT(<SHOW QUEUES message received from node ^N/S1/>)]
	.NMSHP,,[ITEXT(<SHOW PARAMETERS message received from node ^N/S1/>)]
	.NMSHR,,[ITEXT(<SHOW ROUTE-TABLE message received from node ^N/S1/>)]
;**;[22]At NEBSTR:+21L  add 29 lines  JCR 10/4/89
	.OMSTA,,[ITEXT(<START message received from node ^N/S1/>)]       ;[22]
	.OMSHT,,[ITEXT(<SHUT message received from node ^N/S1/>)]        ;[22]
	.OMSET,,[ITEXT(<SET message received from node ^N/S1/>)]         ;[22]
	.OMPAU,,[ITEXT(<STOP message received from node ^N/S1/>)]        ;[22]
	.OMCON,,[ITEXT(<CONTINUE message received from node ^N/S1/>)]    ;[22]
	.OMSHC,,[ITEXT(<SHOW CONTROL FILE message received from node ^N/S1/>)] ;[22]
	.OMREQ,,[ITEXT(<REQUEUE message received from node ^N/S1/>)]     ;[22]
	.OMCAN,,[ITEXT(<ABORT message received from node ^N/S1/>)]       ;[22]
	.OMFWS,,[ITEXT(<FORWARDSPACE message received from node ^N/S1/>)];[22]
	.OMALI,,[ITEXT(<ALIGN message received from node ^N/S1/>)]       ;[22]
	.OMSUP,,[ITEXT(<SUPPRESS message received from node ^N/S1/>)]    ;[22]
	.OMSND,,[ITEXT(<SEND message received from node ^N/S1/>)]        ;[22]
	.OMBKS,,[ITEXT(<BACKSPACE message received from node ^N/S1/>)]   ;[22]
	.OMHLD,,[ITEXT(<HOLD message received from node ^N/S1/>)]        ;[22]
	.OMREL,,[ITEXT(<RELEASE message received from node ^N/S1/>)]     ;[22]
	.OMRTD,,[ITEXT(<ROUTE message received from node ^N/S1/>)]       ;[22]
	.OMDEL,,[ITEXT(<CANCEL message received from node ^N/S1/>)]      ;[22]
	.OMMOD,,[ITEXT(<MODIFY message received from node ^N/S1/>)]      ;[22]
	.OMENA,,[ITEXT(<ENABLE message received from node ^N/S1/>)]      ;[22]
	.OMDIS,,[ITEXT(<DISABLE message received from node ^N/S1/>)]     ;[22]
	.OMDEF,,[ITEXT(<DEFINE message received from node ^N/S1/>)]      ;[22]
	.OMDSP,,[ITEXT(<DN60 DISPLAY message received from node ^N/S1/>)];[22]
	.OMNXT,,[ITEXT(<NEXT message received from node ^N/S1/>)]        ;[22]
	.OMELP,,[ITEXT(<ENABLE message received from node ^N/S1/>)]      ;[22]
	.OMDLP,,[ITEXT(<DISABLE message received from node ^N/S1/>)]     ;[22]
	.OMELT,,[ITEXT(<ENABLE message received from node ^N/S1/>)]      ;[22]
	.OMDLT,,[ITEXT(<DISABLE message received from node ^N/S1/>)]     ;[22]
	.OMEUP,,[ITEXT(<ENABLE message received from node ^N/S1/>)]      ;[22]
	.OMDUP,,[ITEXT(<DISABLE message received from node ^N/S1/>)]     ;[22]
;**;[23]At NEBSTR:+51L add 12 lines  JCR  11/29/89
	.OMRSP,,[ITEXT(<RESPOND message received from node ^N/S1/>)]	;[23]
	.ODENA,,[ITEXT(<ENABLE AVR message received from node ^N/S1/>)] ;[23]
	.ODDIS,,[ITEXT(<DISABLE AVR message received from node ^N/S1/>)] ;[23]
	.ODSDK,,[ITEXT(<SET DISK message received from node ^N/S1/>)] ;[23]
	.ODSTP,,[ITEXT(<SET TAPE message received from node ^N/S1/>)] ;[23]
	.ODSST,,[ITEXT(<SET STRUCTURE message received from node ^N/S1/>)];[23]
	.ODUNL,,[ITEXT(<DISMOUNT TAPE message received from node ^N/S1/>)];[23]
	.ODIDN,,[ITEXT(<IDENTIFY message received from node ^N/S1/>)];[23]
	.ODDMT,,[ITEXT(<CANCEL MOUNT message received from node ^N/S1/>)];[23]
	.ODSWI,,[ITEXT(<SWITCH message received from node ^N/S1/>)];[23]
	.ODSPO,,[ITEXT(<SET PORT message received from node ^N/S1/>)];[23]
	.ODUDS,,[ITEXT(<UNDEFINE message received from node ^N/S1/>)];[23]
;**;[26]At NEBSTR:+62L add 1 line  JCR  2/1/90
	.OMCLO,,[ITEXT(<CLOSE LOG message received from node ^N/S1/>)];[26]
;**;[27]At NEBSTR:+64L add 1 line  JCR  2/14/90
	.OMREP,,[ITEXT(<REPORT message received from node ^N/S1/>)];[27]
;**;[31]At NEBSTR:+66L add 8 lines  JCR  2/22/90
	.OMECS,,[ITEXT(<ENABLE message received from node ^N/S1/>)]  ;[31]
	.OMDCS,,[ITEXT(<DISABLE message received from node ^N/S1/>)] ;[31]
	.OMEFI,,[ITEXT(<ENABLE message received from node ^N/S1/>)]  ;[31]
	.OMDFI,,[ITEXT(<DISABLE message received from node ^N/S1/>)] ;[31]
	.OMELG,,[ITEXT(<ENABLE message received from node ^N/S1/>)]  ;[31]
	.OMDLG,,[ITEXT(<DISABLE message received from node ^N/S1/>)] ;[31]
	.OMESO,,[ITEXT(<ENABLE message received from node ^N/S1/>)]  ;[31]
	.OMDSO,,[ITEXT(<DISABLE message received from node ^N/S1/>)] ;[31]
;**;[32]At NEBSTR:+77L add 3 lines  JCR  4/27/90
	.OMEBM,,[ITEXT(<ENABLE message received from node ^N/S1/>)]  ;[32]
	.OMDBM,,[ITEXT(<DISABLE message received from node ^N/S1/>)] ;[32]	
	.OMSBM,,[ITEXT(<SHOW BROADCAST-MESSAGES message received from node ^N/S1/>)] ;[32]	
;**;[34]At NEBSTR:+81L add 2 lines   PMM  6/3/90
	.OMAKA,,[ITEXT(<DEFINE ALIAS message received from node ^N/S1/>)] ;[34]
	.OMSAK,,[ITEXT(<SHOW ALIAS message received from node ^N/S1/>)]  ;[34]
;**;[35]At NEBSTR+80L add 1 line  JYCW   6/8/90
	.OMSJB,,[ITEXT(<SET JOB message received from node ^N/S1/>)] ;[35]
	.OMSOP,,[ITEXT(<SEND OPERATOR message received from node ^N/S1/>)] ;[35]
;**;[40]At NEBSTR+82L add 1 line JYCW  9/12/90
	.ODDSM,,[ITEXT(<DISMOUNT STRUCTURE mmessage received from node ^N/S1/>)] ;[40]
	$ETAB

	SUBTTL	SHOW message code translation tables

;NEBULA SHOW TO QUASAR SHOW

NBTOQR:	$STAB				;[4] 

	.NMSHS,,.OMSHS			;SHOW STATUS
	.NDSHT,,.ODSHT			;[5]SHOW STATUS TAPE
	.NDSHD,,.ODSHD			;[5]SHOW STATUS DISK
	.NDSTR,,.ODSTR			;[6]SHOW STATUS STRUCTURE
	.NDSCD,,.ODSCD			;SHOW CONFIGURATION
	.NMSHQ,,.OMSHQ			;SHOW QUEUES
	.NMSHP,,.OMSHP			;SHOW PARAMETERS
	.NMSHR,,.OMSHR			;SHOW ROUTE
	.NFMTS,,.ODMTS			;[2]MOUNT STRUCTURE/CLUSTER-NODE
	.NMSSN,,.OMSSN			;[20]SHOW STATUS NETWORK-NODE
	.NMSPN,,.OMSPN			;[20]SHOW PARAMETERS NETWORK-NODE

	$ETAB

;QUASAR SHOW TO NEBULA SHOW

QRTONB:	$STAB

	.OMSHS,,.NMSHS			;SHOW STATUS
	.ODSHT,,.NDSHT			;[5]SHOW STATUS TAPE
	.ODSHD,,.NDSHD			;[5]SHOW STATUS DISK
	.ODSTR,,.NDSTR			;[6]SHOW STATUS STRUCTURE
	.ODSCD,,.NDSCD			;SHOW CONFIGURATION
	.OMSHQ,,.NMSHQ			;SHOW QUEUES
	.OMSHP,,.NMSHP			;SHOW PARAMETERS
	.OMSHR,,.NMSHR			;SHOW ROUTE
	.ODMTS,,.NTMTS			;[2]MOUNT STRUCTURE/CLUSTER-NODE
	.OMSSN,,.NMSSN			;[20]SHOW STATUS NETWORK-NODE
	.OMSPN,,.NMSPN			;[20]SHOW PARAMETERS NETWORK-NODE
	$ETAB

	END

