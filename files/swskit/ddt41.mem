DDT41 - DDT %41(260) Users Guide to New Features                Page 1



                       Copyright (C) 1978, 1979
    Digital Equipment Corporation, Maynard, Massachusetts, U.S.A.

This software is furnished under a license and may be used and  copyed
only in accordance with the terms of such license and with the  inclu-
sion of the above copyright notice. This software or any other  copies
thereof may not be provided or  otherwise made available to any  other
person. No title  to and ownership  of the software  is hereby  trans-
ferred.

The information in this software  is subject to change without  notice
and should not be construed as a commitment by Digital Equipment  Cor-
poration.

Digital assumes no responsibility  for the use  or reliability of  its
software on equipment which is not supplied by Digital.DDT41 - DDT %41(260) Users Guide to New Features                Page 2
Introduction and Overview


1.0 Introduction and Overview1.0 Introduction and Overview1.0 Introduction and Overview1.0 Introduction and Overview1.0 Introduction and Overview1.0 Introduction and Overview

This document is designed as a users guide to DDT version 41 in so far
as it has changed from previous versions of DDT. It is not a  complete
users guide to all the wonders  of DDT, just those new features  which
have recently  been implemented  (although directed  primarily at  new
features only in  DDT version  41, some documentation  is included  to
describe other aspects  of DDT  which have  been around  for a  longer
period  of  time,  but  were  never  fully  understood  or   otherwise
documented).

Throughout this  document it  is assumed  that the  reader is  already
familiar with DDT and the MACRO  assembly language in general as  well
as the appropriate operating system(s).

This is the first revision  of this document, incorporating the  addi-
tional changes to DDT version 41 as of edit 260.


2.0 Configurations2.0 Configurations2.0 Configurations2.0 Configurations2.0 Configurations2.0 Configurations

DDT version 41  will run  on KA-10's, KI-10's,  KL-10's, and  KS-10's,
using no paging,  KI-paging, or  KL-paging, with  or without  extended
addressing in user or executive mode (user and file DDT's run only  in
user mode) with  no special assembly  needed. DDT version  41 must  be
assembled to run  under either  the TOPS-10 or  the TOPS-20  operating
system.

It traditionally has been a goal to maintain one single set of  source
files from which  all flavors  of DDT are  built. This  goal has  been
maintained.
                            
                                 Note                                 Note                                 Note                                 Note                                 Note                                 Note

     TOPS-20 UDDT  (and SDDT)  now  use memory  locations  764000
     through 777777 (previously 770000  through 777777), but  the
     starting address for  DDT continues to  be location  770000.
     This requires version   4 of the PA1050 "compatibility pack-
     age".



3.0 Memory and Address Control3.0 Memory and Address Control3.0 Memory and Address Control3.0 Memory and Address Control3.0 Memory and Address Control3.0 Memory and Address Control

The single biggest change to DDT  version 41 from earlier versions  is
in the realm of memory control and how the user addresses memory loca-
tions.

3.1 Extended addressing

All flavors of DDT except FILDDT will run in any memory section.  Full
extended addressing is supported, as are "large" addresses - DDT  will
now accept a full 36-bit  expression as an address although  obviously
only FILDDT can actually handle an  address over 30-bits wide. In  all
cases the actual address must be positive (i.e., effectively a  35-bit
address).DDT41 - DDT %41(260) Users Guide to New Features                Page 3
Memory and Address Control


3.1.1 Symbol table restrictions
There are certain  restrictions however  which must be  adhered to  in
order for DDT to function correctly. The first restriction is that the
symbol table logic is essentially section-dependent, i.e., the  symbol
table and its pointers (.JBSYM=116 and .JBUSY=117, also .JBHSM=6 rela-
tive to the start of the "high segment") must reside (i.e., be mapped)
in the same section as that  in which DDT itself is running.  Further,
the symbol table can be no longer  than 128K words in length and  must
be RADIX-50 format.

Much thought is being  given towards the  implementation of a  totally
new symbol table scheme which would address all of these problems, the
single biggest one of which is simply how is extended addressing going
to be used - as a single fixed address space with one or more "global"
symbol tables  (like the  TOPS-20 monitor  currently works),  or as  a
collection of  independent sections  each of  which has  section-local
symbols/symbol tables (whatever that means), or what?

3.1.2 Breakpoint restrictions
The second  restriction  of which  the  user must  be  aware  concerns
breakpoints. Since  the hardware  has no  facility to  unconditionally
transfer control to DDT  using only 36-bits, DDT  must be mapped  into
each section (at the same  relative address obviously) which  contains
code into which the user wishes to place breakpoints.

3.1.3 Location examining restrictions
Even if running on an extended addressing machine if DDT is running in
section 0,  then  only locations  within  section 0  (addresses  0  to
777777) may be manipulated.  DDT will make no  effort to outsmart  the
combined efforts of the user and the operating system by sneaking into
a non-zero section even momentarily to do the memory reference.

3.2 Effective address calculation

DDT version 41 can calculate effective address references using either
"local" or IFIW (Instruction Format Indirect Word) or "global" or EFIW
(Extended Format Indirect Word) formats. In a normal DDT address-open-
ing command  ("/", "\",  <TAB>, etc.)  a single  <ESC> delimiting  the
address expression (e.g., "MOVE 3,@200(10)$/" or just "$[")  instructs
DDT to treat the expression as  an IFIW word and calculate the  effec-
tive address exactly  like the  hardware would, were  the hardware  to
execute that 36-bit word as an instruction at location "." (whether or
not location "." is currently open).

Two <ESC>'s delimiting the address  expression instructs DDT to  treat
the 36-bit  expression as  an EFIW  word and  calculate the  effective
address exactly as the hardware would, were the hardware to indirectly
address the 36-bit expression at location "." (whether or not location
"." is currently  open). A strange  case can come  up about which  the
user should be cautioned  - there is an  ambiguity as to where  (i.e.,
what "section") to  start the effective  address calculation. DDT  as-
sumes the left  half of  "." (i.e., the  last location  opened by  the
user). If for  example having opened  location 0,,1234 which  contains
7,,4321 the user issues the command  "$$[" then DDT will calulate  the
effective address  as  the contents  of  location 4321  in  section  0
indexed by the right half of register 7, and if bit 13 is on, treatingDDT41 - DDT %41(260) Users Guide to New Features                Page 4
Memory and Address Control


that word as  an IFIW  and continuing the  address calculation.  This,
although probably not what was expected,  is in fact exactly what  the
hardware would do since the indirect word came from section 0. Had the
user opened location 1,,1234 (containing 7,,4321) then DDT would  take
the contents of location 7004321 and continue from there.

If no <ESC>'s delimit the address expression, then DDT simply uses the
full 36-bit expression as the address (e.g., "30,,30/" says open loca-
tion 30000030 and "-1/" says open location 777777777777). Again,  only
FILDDT can actually  reference an  address greater  than 30-bits  wide
(not that anyone has that much  disk space, but the hardware will  not
permit an address space  over 30-bits wide), and  in any case the  ad-
dress must be a non-negative 36-bit integer.

There is a special  case in which  DDT does something  "kinky" - if  a
space was typed in entering the address expression, or if no  explicit
address was typed (i.e.,  the user is using  the "last word typed"  by
simply typing  only (for  example) <TAB>),  DDT will  form the  36-bit
actual address by  using only  the right  half of  the 36-bit  address
expression plus the left half of "." as the section number. This  not-
at-all-obvious behavior is so  that the user  can type in  expressions
such as "JRST PAT<TAB>" and  have DDT go to  location PAT in the  same
section as  the JRST  PAT  instruction rather  than going  to  address
254000000000+(PAT modulo 2**18).  Another common usage  of this  "fea-
ture" would be in chaining down linked lists where the link pointer is
an 18-bit section-local address in the left half of a word. To do this
the user may type  "sp$$Q/" (where "sp" means  space). This is one  of
those cases where usefullness outweighs cleanliness of  implementation
and documentation.

3.3 Modifying memory

Two new commands have been  added to facilitate DDT's manipulation  of
the user address space.

3.3.1 Automatic write-enable
The $W or $0W command instructs DDT to, if the user attempts to depos-
it into a  write-protected memory location,  automatically attempt  to
write-enable the memory location, do the memory deposit, then  finally
re-write-protect the memory location (default for TOPS-10); the $$W or
$$0W command instructs DDT to simply  give an error indication if  the
user attempts to change a write-protected memory location (default for
TOPS-20). For FILDDT the use of this command is restricted to non-file
usage such as "DDT'ing" the running monitor/memory space.

3.3.2 Automatic page-creation
The $1W command instructs DDT to automatically try to create the  page
the user is trying  to deposit into if  it doesn't already exist  (de-
fault for TOPS-20); the $$1W command  instructs DDT to simply give  an
error indication if  the user  attempts to write  into a  non-existant
page (default  for  TOPS-10).  EDDT  and FILDDT  doing  super  I/O  or
"DDT'ing" an .EXE  file will  NEVER attempt to  create a  non-existant
page. For  FILDDT the  user must  specify patching  the file  when  he
starts FILDDT in order  to be able to  create new pages (e.g.,  extend
the file or fill in a gap in the middle of the file (TOPS-20 only)).DDT41 - DDT %41(260) Users Guide to New Features                Page 5
Memory and Address Control


3.4 Page mapping and physical addressing

In DDT version 41 all flavors of DDT support page mapping and  address
relocation as well as register and physical address manipulation.  All
of these functions use  some variation of the  $U/$$U DDT command.  In
general these functions  may be  mixed together  (for example  address
relocation and page mapping).
                      
                           *** Warning ***                           *** Warning ***                           *** Warning ***                           *** Warning ***                           *** Warning ***                           *** Warning ***

     The $U command syntax in DDT is totally different (and main-
     ly incompatible) from previous versions of DDT! The user  is
     MOST strongly urged to carefully read this section on memory
     mapping and addressing!


3.4.1 Physical addressing
DDT now has the  concept of "physical" addressing  in addition to  its
normal "virtual" addressing. The $U command instructs DDT to use  nor-
mal virtual addressing (what it used to do); the $$U command instructs
DDT to manually track down the honest physical address rather than the
virtual address space in which DDT finds itself running. Physical  ad-
dressing is really  applicable only to  EDDT or to  FILDDT looking  at
running monitor/memory (TOPS-10 only).  User mode DDT (including  EDDT
running in user mode, MDDT  (TOPS-20 only), and VMDDT (TOPS-10  only))
and FILDDT looking  at a  disk all treat  $U and  $$U identically.  In
physical addressing location 0 is not register 0 (i.e., DDT's internal
copy of user register 0) but rather physical memory location 0 page  0
bank 0 box  0 (that memory  location on the  hardware memory bus  that
responds to all address bits = 0).

When the $$U DDT command is issued "physical" locations 0 to 17 become
"registers" 0 to 17. For  user mode DDT this  means locations 0 to  17
become DDT's registers rather than the user's registers (although  the
user's registers will  be properly  restored on  DDT-exit, $$U  merely
directs DDT not to  use the internal  "fake" (i.e., user)  registers).
For FILDDT  this means  file words  0 to  17 (as  mapped by  the  .EXE
directory if used) become locations 0 to 17 (normal for a data file).

Subsequent issuance of the $U DDT command will redirect locations 0 to
17 to being DDT's internal  "fake" registers again, except for  FILDDT
looking at an data file or doing super I/O to a disk.

Note that for executive mode  EDDT to utilize physical addressing  the
paging hardware must have  been enabled PRIOR  to DDT-entry. This  re-
quirement exists  because EDDT,  in order  to access  all of  physical
memory, needs to map the desired physical address into its own (execu-
tive) virtual address space,  which it does  by fondling the  already-
extant page maps. For EDDT  to provide physical addressing  capability
without this restriction would require 2 (3 if KL-paging) more  memory
pages be  dedicated to  EDDT for  building temporary  page maps,  plus
support code etc.

For FILDDT to examine/modify physical  memory a 7.00 or later  release
of the TOPS-10  monitor is  required; no release  of TOPS-20  supports
FILDDT'ing physical memory.DDT41 - DDT %41(260) Users Guide to New Features                Page 6
Memory and Address Control


3.4.2 Page mapping
All flavors of DDT now  support page mapping in  both the KI- and  the
KL-tradition. EDDT in executive mode will dynamically figure out which
style of paging is in effect  and operate accordingly. All other  fla-
vors of DDT (including EDDT running in user mode) will assume the mode
of paging used by the operating  system for which DDT was assembled  -
KI-paging for TOPS-10 and KL-paging  for TOPS-20. To select  KI-paging
emulation the flg$10U command is used; to select KL-paging the flg$11U
command is  issued; in  either case  if flg  is zero  then the  paging
emulation is disabled, if flg is non-zero then the appropriate  paging
emulation is enabled.

In executive mode  EDDT or  FILDDT looking  at running  monitor/memory
space DDT  will internally  utilize physical  addressing in  order  to
provide the user the true mapped virtual address space desired.

3.4.2.1 KI-paging - For KI-paging  (TOPS-10 default) the page  mapping
command for the executive  virtual addressing space is  [upt<]ept$[0]U
where upt is  the optional  physical memory  page number  of the  user
process table (for setting the  "per-process" addressing space -  exec
virtual addresses 340000 through 377777) and ept is the physical memo-
ry page number of  the executive process table.  The user virtual  ad-
dressing space is selected by the  upt$1U command. The command $U  re-
turns DDT to regular unmapped virtual addressing.

3.4.2.2 KL-paging - For KL-paging  (TOPS-20 default) the page  mapping
command for the executive virtual  addressing space is ept$[0]U  where
ept is the physical memory page number of the executive process table,
or epx$$[0]U where  epx is  the index into  the SPT  of the  executive
process table pointer. To select the user virtual addressing space the
command is upt$1U where upt is the physical memory page number of  the
user process table, or upx$$1U where upx is the index into the SPT  of
the user process table pointer. The command $U returns DDT to  regular
unmapped virtual addressing.

To map  a single  section  (256K address  space) under  KL-paging  the
command is either sec$2U where sec is the physical memory page  number
of a KL-paging section map, or sex$$2U where sex is the index into the
SPT of the section map.

Basically, under KL-paging, $0U selects the ept, $1U selects the  upt,
and $2U selects a  single section. A single  $ indicates the  physical
memory page number and two $'s indicate an SPT index.

3.4.3 Setting the SPT
FILDDT will automatically define the start of the SPT from a disk file
(assumed monitor dump)  from the  symbol "SPT" if  it exists  (TOPS-20
only). The command  spt$6U specifies  to DDT  that the  SPT starts  at
address spt.

3.4.4 Register addressing
The command acs$5U instructs DDT  to use the 20 consecutive  locations
starting at acs as  the registers (DDT maintains  an internal copy  of
the registers so changing "register"  3 will not affect (for  example)
acs+3). FILDDT, when reading an .EXE file, will automatically load its
internal "fake" registers as  though the user  had typed CRSHAC$5U  ifDDT41 - DDT %41(260) Users Guide to New Features                Page 7
Memory and Address Control


TOPS-10 or BUGACS$5U if TOPS-20. Note that if physical addressing mode
has been entered (the user has issued the $$U command) then the inter-
nal "fake" registers  are ignored; if  the user subsequently  reenters
virtual addressing (via some  form of the $U  command) then an  acs$5U
command may also have to be re-issued to get the registers back  (this
does not affect the saving and restoring of the hardware registers  in
user or executive DDT, only what DDT will use for typing out locations
0 to 17).

The command flg$3U  explicitly controls  the usage  of DDT's  internal
"fake" registers - if flg is  0 then the "fake" registers are  ignored
(i.e., 0 to 17 are taken  from the true current addressing space),  if
flg is non-zero then addresses 0  to 17 are taken from DDT's  internal
copies of the registers.

The $U command, except for FILDDT'ing  a data file or doing super  I/O
to a disk, will return DDT  to its internal "fake" registers. The  se-
lection of registers is completely independent of any page mapping  in
effect. Changing virtual  address spaces does  not change the  "regis-
ters".

In executive mode  DDT only the  command n$4U will  switch DDT to  use
(and thus display) hardware AC block n (available only for KL-10's and
KS-10's). The user is warned that 7$4U on a KL-10 will bring rapid and
rabid death (the  microcode uses  AC block 7).  On DDT  exit DDT  will
restore the ac block context to the state it was in at DDT entry.

3.4.5 Address relocation and protection
As an  aid  to looking  at  data  structures which  are  formed  using
pointers as offsets rather than  pointers as absolute values DDT  ver-
sion 41 will allow the user to  set both a base relocation address  to
be added to all  addresses used in location  examining commands and  a
protection address beyond which  the user "virtual"  (note the use  of
"virtual" here as meaning pre-relocated)  address is illegal. This  is
(coincidently) exactly analguous to the KA-10 hardware relocation  and
protection strategy, and in fact could be used as such to "mimic"  the
$U KI/KL/KS-10 functionality on a KA-10 in executive mode. The form of
this command is  bas$8U where  bas is  the base  virtual address,  and
prt$9U where prt is  the maximum address the  user will be allowed  to
type in. Note that page mapping and address relocation and  protection
are independent mechanisms, with address relocation and protection be-
ing performed before any mapping  is done. The protection address  has
no effect on  the final  "physical" address generated  by any  mapping
currently in effect.

3.4.6 $U command summary
All $U/$$U commands take the following form:

1.   $U             Unmapped virtual addressing
2.   $$U            Unmapped physical addressing
3.   ept$[$][0]U    Select executive virtual addressing
4.   upt$[$]1U      Select user virtual addressing
5.   sec$[$]2U      Select single section
6.   flg$3U         Select (deselect) internal fake registers
7.   acb$4U         Select hardware ac block
8.   acs$5U         Load internal fake registersDDT41 - DDT %41(260) Users Guide to New Features                Page 8
Memory and Address Control


9.   spt$6U         Select base of SPT
10.  bas$8U         Set base relocation address
11.  prt$9U         Set protection address
12.  flg$10U        Select (deselect) KI-paging
13.  flg$11U        Select (deselect) KL-paging

where:

1.   acb := integer ac block number
2.   acs := address of 20-word register block
3.   bas := base relocation address
4.   ept := executive process table page number
5.   flg := selection flag, zero to deselect, non-zero to select
6.   prt := protection (maximum allowable) address
7.   sec := section map page number
8.   spt := address of SPT
9.   upt := user process table page number


3.4.7 Address checking (Executive EDDT only)
EDDT version 41,  when running  in executive  mode, now  is much  more
extensive in validity-checking memory references. In particular,  EDDT
will not cause a NXM (page fault) trap to the resident operating  sys-
tem if  the  user  types  in an  illegal  (non-existent  or  unmapped)
address, but rather will simply type its ubiquitous ?<DINK><TAB> error
message.

3.4.8 Address breaking
DDT will no longer cause an  address break to occur when examining  or
depositing a location  at which  an address break  condition has  been
set. This applies  only to  "user" examines and  deposits, an  address
break set in DDT will still cause an address break to occur.


4.0 Specifying the Start Address4.0 Specifying the Start Address4.0 Specifying the Start Address4.0 Specifying the Start Address4.0 Specifying the Start Address4.0 Specifying the Start Address

The $G command now expects a 36-bit address (obviously with bits 0  to
5 off) at which to start the  user program. This means that the  users
of programs  such as  the TOPS-10  monitor which  define symbols  like
"DEBUG=:<JRST .>" can no  longer go either DEBUG$G  or DEBUG$X at  the
users whim  but must  decide on  one form  or the  other (the  default
obviously being to do nothing - i.e., to settle for the DEBUG$X form)


5.0 Symbolic expression typein and typeout5.0 Symbolic expression typein and typeout5.0 Symbolic expression typein and typeout5.0 Symbolic expression typein and typeout5.0 Symbolic expression typein and typeout5.0 Symbolic expression typein and typeout

DDT version 41  has expanded  the range  of both  symbolic typein  and
symbolic typeout.

5.1 Symbolic typein

The JSYS opcode (opcode  104) has been added  to TOPS-20 DDT, as  have
all the TOPS-10 UUO's  (but not the CALLI's  etc.) for debugging  pro-
grams which run under the compatibility package.DDT41 - DDT %41(260) Users Guide to New Features                Page 9
Symbolic expression typein and typeout


5.2 Multiply-defined symbol typein

If the user types  an ambiguous symbol (a  symbol defined two or  more
places outside of the current local  symbol table and not in the  cur-
rent local symbol table) DDT will issue an "M" error message.

5.3 Selecting no local symbol table

The $: command issued  without an explicit module  name to use as  the
local (or "opened") symbol table will deselect any local symbol table.
This is the initial state in which DDT starts.

5.4 Symbol cache

DDT now has  a symbol  "cache" of symbols  recently used  to type  out
values. This cache is  used primarily for  typeout; typein will  check
the symbol cache for  a matching symbol from  the currently opened  or
local symbol table, if no match is found the cache is ignored and  the
regular symbol table  is used. The  symbol cache is  "flushed" on  the
issuance of any $: command.

5.5 Symbolic typeout

DDT now goes to great pains  to find any possible user-defined  symbol
(such as an OPDEF) to match the expression DDT is trying to type  out.
The order in which DDT searches for a symbol match in symbolic typeout
mode for non-I/O instructions is:

1.   Full 36-bit match; OP, AC, I, X, and Y fields (e.g., the  TOPS-20
     monitor calls such as GTJFN)
2.   OP, I, X, and Y fields  (e.g., the TOPS-10 monitor calls such  as
     FILOP.)
3.   OP and AC fields (e.g., the TOPS-10 monitor calls such as  INCHWL
     or "instructions" such as HALT)
4.   OP field only (e.g., user UUO's or "OPDEF XMOVEI [SETMI]")
5.   DDT's internal hardware opcode table

The order in which DDT searches for a symbol match in symbolic typeout
mode for I/O instructions is:

1.   I/O OP and DEV fields (bits 0 to 12 - e.g., KL-10 APRID or  KS-10
     RDCSB)
2.   Regular (non-I/O) OP field (e.g., KS-10 UMOVE)



6.0 ASCII typeout6.0 ASCII typeout6.0 ASCII typeout6.0 ASCII typeout6.0 ASCII typeout6.0 ASCII typeout

DDT version 41 adds the typeout mode commands $8T and $9T to typeout 8
bit ASCII or 9 bit ASCII respectively (i.e., pick up 8 or 9 bit  bytes
and "type" them straight as is - which with current TOPS-10 and  TOPS-
20 operating systems means as 7-bit ASCII).DDT41 - DDT %41(260) Users Guide to New Features               Page 10
Command files


7.0 Command files7.0 Command files7.0 Command files7.0 Command files7.0 Command files7.0 Command files

The $Y command (TOPS-10 DDT only)  has been changed somewhat, both  in
input and output (logging) functions.

7.1 Command input

If the user does  not type a  36-bit expression to be  used as a  file
name (such as $""FILNAM"$Y) but just types $Y by itself then DDT  will
prompt with "File: ". After  the prompt the user  can enter a  TOPS-10
file specification in the form dev:name.type[directory]/switches where
[directory] can of course contain SFD's.

7.1.1 /A switch
The /A switch instructs DDT to abort the command file if a DDT-detect-
ed command error occurs (such as reference to an undefined symbol).

7.2 Command output (logging)

When reading a command file ($Y command) DDT will no longer "log"  all
output onto  device  LPT: but  rather  just  type out  onto  the  user
terminal.


8.0 Automatic patch insertion8.0 Automatic patch insertion8.0 Automatic patch insertion8.0 Automatic patch insertion8.0 Automatic patch insertion8.0 Automatic patch insertion

The automatic patch insertion facility ($< and $> commands) are  basi-
cally the same as in version 40 of DDT with only minor differences.

8.1 Patch opening

The user may specify patching either by sym$< where sym is the name of
a symbol (which will  be automatically updated  at the termination  of
the patch) or via exp$< where exp is any 36-bit expression  represent-
ing the address of the resultant patch. If the later form of the patch
command is used no symbol will be updated to the end of the patch.

8.2 Default patching symbol

The list and order of default patching symbols which DDT uses when the
user does not supply an explicit patching symbol is now:

1.   PAT (TOPS-10 EDDT only)
2.   FFF (TOPS-20 EDDT and MDDT only)
3.   PAT.. (all flavors)
4.   PATCH (all flavors)
5.   PAT (all flavors except TOPS-10 EDDT)


8.3 Default patching address

If the user  does not supply  an explicit patching  symbol and DDT  is
unable to find one  of the default patching  symbols then the  address
specified by the  right half of  location .JBFF (even  on TOPS-20)  is
used. On patch close ($> command) if the patching address was default-
ed to via .JBFF, then  both the right half  of location .JBFF and  theDDT41 - DDT %41(260) Users Guide to New Features               Page 11
Automatic patch insertion


left half of location .JBSA are updated.

8.4 Patch closing confusion and restriction

With DDT version 41 it no longer matters how (when) the user types the
$> command, either  immediately after  the final  word expression,  or
after a <CR> or <LF> to terminate the final word expression - DDT will
never generate a 0 word for free.

There is  a very  obscure restriction  however  on the  use of  the  #
command in conjunction with the $> command. If the user is referencing
an undefined symbol in the expression  for the last word of the  patch
then that expression must explicitly  be terminated in such a  fashion
as to close the  location before terminating  the patch. For  example,
"MOVE T1,BLETCH#$>" is  illegal but "MOVE  T1,BLETCH#cr$> (where  "cr"
indicates a carriage return) is ok.


9.0 Breakpoints9.0 Breakpoints9.0 Breakpoints9.0 Breakpoints9.0 Breakpoints9.0 Breakpoints

The breakpoint logic in DDT  version 41 has been extensively  revamped
in order to support extended addressing. The default number of  break-
points is now  12 (decimal); and  can be set  (by defining the  symbol
NBP=number of breakpoints) arbitrarily high (within memory space limi-
tations) rather than being limited to  9 or 36 (decimal) depending  on
which code restriction one choose to believe.

9.1 Setting breakpoints

DDT can now set a breakpoint in  code running in any section with  two
restrictions:

1.   If DDT is  currently running  in section 0  then breakpoints  can
     only be set in section 0 (see section 3.1.3 above).
2.   DDT must be mapped  in the section containing  the code in  which
     breakpoints are to  be placed (the  logic of this  is that  since
     there is no way for DDT  to cause unconditional transfer of  con-
     trol to DDT with only 36 bits some portion of the section address
     space must be devoted to DDT; therefore, given this  restriction,
     one might just as well  put all of DDT  in that section since  it
     makes for a cleaner and  simpler implementation). Note that  this
     does not mean  DDT must be  running in that  section, but  merely
     that DDT must be mapped in that section!

It does not matter into how  many different sections the same code  is
mapped as long as DDT  is mapped into the  same sections since DDT  is
"section-independent". For example (taking  the TOPS-20 monitor  which
maps section 0 and  section 1 identically) if  a breakpoint is set  at
address 1004567 (or 1,,4567) but the PC was 4567 (or 0,,4567, i.e., in
section 0 rather than section 1) when the breakpoint was executed  DDT
does not care (as long as DDT is mapped in that section, which in  the
example of the TOPS-20 monitor it is).

The syntax  for setting  a breakpoint  is now  opn<bpt$nB where  n  is
optional and, if specified, declares  the breakpoint number to be  as-
signed to that address; bpt is the 36-bit address at which to place  aDDT41 - DDT %41(260) Users Guide to New Features               Page 12
Breakpoints


breakpoint; and opn is an optional 36-bit address to open and  display
upon execution of the breakpoint.  The syntax was changed because  two
full 30-bit addresses could not be squeezed into two halfwords.

DDT will no longer  assign two different breakpoints  to the same  ad-
dress, either accidentally  or under user  control - if  the user  at-
tempts to  set a  breakpoint  at a  location  at which  a  (different)
breakpoint is already set, the old breakpoint is cleared first.

9.2 Breakpoint typeout

Upon execution of a  breakpoint DDT will now  always typeout the  user
instruction (in instruction format regardless of the permanent typeout
mode) at that breakpoint  and set "." to  the breakpoint address.  If,
further, opn was specified as in section 9.1 above, then DDT will also
display the contents of  location opn in  the permanently set  typeout
mode and "." will be updated  to opn (with the breakpoint address  it-
self becoming the previous PC sequence and so available via the  $<CR>
etc. commands).

9.3 Examining breakpoint locations

The $nB command continues to be the "address" of breakpoint n's  data-
base, but $nB is no longer  equal to $n-1B+3. The breakpoint  database
of interest to the user now has the following format:

1.   $nB+0/    If nonzero the address for breakpoint n
2.   $nB+1/    The conditional break instruction (break if skips)
3.   $nB+2/    The proceed count (break on transition to 0)
4.   $nB+3/    If greater than or equal to zero then the address to be
     displayed

The rest of the breakpoint data base should not be of use to the user.


9.4 Unsolicited breakpoints

DDT version 41 has a new  breakpoint facility - the ability to  handle
unsolicited breakpoints  (i.e., breakpoints  that DDT  did not  itself
set). If control  passes to location  $0BPT+1 ($0BPT is  a global  DDT
symbol) then DDT  will act  as if  a breakpoint  had been  set at  the
address-1 contained in location  $0BPT. The address  in $0BPT must  be
setup as if the cpu executed a JSR $0BPT instruction - if in section 0
then flags,,PC otherwise  just global  30-bit PC.  After "hitting"  an
unsolicited breakpoint  the user  can proceed  with program  execution
with the $P command (all arguments  to the $P command such as  proceed
count or auto-proceed ($$P) are ignored).

Although this facility gives programs the ability to cause breakpoints
at any time (thus  getting into DDT with  the program state  carefully
preserved) it is intended to be of most use in conjunction with an as-
yet-unimplemented monitor  command (such  as control-D)  to "force"  a
breakpoint on a program without  having to control-C/DDT the  program.
Then the user could simply continue with the program by typing $P.DDT41 - DDT %41(260) Users Guide to New Features               Page 13
Single-stepping the program


10.0 Single-stepping the program10.0 Single-stepping the program10.0 Single-stepping the program10.0 Single-stepping the program10.0 Single-stepping the program10.0 Single-stepping the program

The $X DDT command has been  significantly modernized (and sped up  in
general) with version 41 of DDT.

10.1 New opcodes

The ADJSP, DADD, DSUB, DMUL, and DDIV instructions have been added  to
DDT's $X table although double- and quad-word integers (for DADD etc.)
are still typed out as  two or four single  words rather than one  big
multiple precision integer.  All of the  extended JRST-class  instruc-
tions are correctly simulated/traced. A  user-UUO being executed in  a
non-zero section is simply XCT'ed and is not traced.

10.2 Byte-manipulation typeout

A rudimentary byte-manipulation-instruction typeout facility was added
(to DDT  version 40  actually) to  display the  byte pointer  and  the
contents of the  effective address  of the byte  pointer. The  EXTEND-
class instructions are not handled.

10.3 Effective address calculation

DDT now always  calculates the  effective address  of the  instruction
being $X'ed rather than just blindly "doing it" in order to both  pre-
vent DDT from getting an illegal  memory reference as well as to  make
DDT be independent of the section in which the user PC resides  (i.e.,
DDT does not  have to be  mapped into  the user PC  section to  handle
$X'es although if the user PC is  in a non-zero section then DDT  must
be in a non-zero section). Besides, it's usually faster too!

10.4 KS-10 I/O instruction trace

The KS-10 specific I/O instructions which reference the UNIBUS (execu-
tive mode only)  are not  traced, only  the contents  of the  register
specified in the AC field are displayed. Since the UNIBUS device  reg-
isters can  be reference-volatile  (i.e., merely  referencing one  can
cause it to change -  such as the DL-11  data registers) DDT does  not
typeout the contents of the referenced UNIBUS address. Further,  since
the effective  address  of the  instruction  is not  calculated  in  a
standard format (at least  as far as DDT  is concerned) the  effective
address itself is not even displayed.

10.5 PC skipping

If the user instruction  being $X'ed skips then  DDT will now  typeout
"<SKIP>" if the  PC skips by  one location,  or "<SKIP n>"  if the  PC
skips by n locations, where n is less than or equal to the DDT  assem-
bly parameter SKPMAX (by default 3). If the PC changes more drastical-
ly than that (e.g., goes to  a smaller address) DDT will type  "<JUMP>
instead.

10.6 ERCAL/ERJMP

DDT (TOPS-20 only) will now handle instructions followed by either  an
ERCAL or an ERJMP instruction (which is really just a 72-bit  instruc-DDT41 - DDT %41(260) Users Guide to New Features               Page 14
Single-stepping the program


tion with two effective addresses). If the instruction being  executed
does not take the error jump  then DDT will print "<ERSKP>" after  the
normal instruction trace  to indicate  to the  user that  an ERCAL  or
ERJMP was just skipped (i.e., the  PC incremented by 2 rather than  1)
and  will  not  display  the  ERCAL  or  ERJMP  instruction.  If   the
instruction does take the error jump then the ERCAL or ERJMP  instruc-
tion will be displayed, if an ERCAL instruction then register 17  will
also be displayed, and the PC will be changed to the error address.

DDT will print "<ERSKP>"  rather than showing the  ERCAL or ERJMP  in-
struction since DDT has no way of telling whether or not the  instruc-
tion itself caused the skip (as in a SKIPA) or if the PC merely  "fell
through" the ERCAL or ERJMP instruction (as in a successful MOVE).

Users of EDDT and  MDDT should be  cautioned about $Xing  instructions
followed by an ERCAL or ERJMP in non-zero sections - the monitor has a
tendency to transfer control to the error address in section 0,  which
will cause a BUGHLT because DDT (running in executive mode) does  non-
zero section things thinking it is still in a non-zero section.

10.7 $X'ing an INIT

DDT will now let the user $X an INIT (TOPS-10) monitor call. DDT  will
print out <SKIP 2> if the INIT fails or <SKIP 3> if the INIT succeeds.


10.8 $X speed up

By building into DDT a table of instructions which can cause the state
of the known world to change, and assuming the state of the world does
not change if the instruction being  $X'ed is not so marked, the  time
required to $X an instruction is cut  by roughly a factor of 10.  This
results in a dramatic performance increase especially for EDDT on  KL-
10's where  waiting  for  the  console front  end  to  switch  between
secondary and primary protocol is very time-consuming.

10.9 Repetitive $X'es

The $$X command now takes an optional address range. Normally $$X will
terminate when the  user PC  inclusively enters  the range  .+1 to  .+
SKPMAX  (default  value  of  SKPMAX  is  3).  The  user  may   specify
lwr<upr>$$X where lwr  is the lower  address boundary and  upr is  the
upper address boundary which, if  the user PC ever inclusively  enters
the range so specified, terminates the  $$X. If only lwr is  specified
then upr defaults to lwr+SKPMAX. This  command is very useful for  re-
covering from having  $X'ed a  (for example) PUSHJ  instead of  having
$$X'ed the (for example) PUSHJ.

10.10 $X'ing from instr$X

If the user  $X'es a  return from a  subroutine which  was entered  by
doing an instr$X  (for example  "PUSHJ P,SUBRTN$X where  SUBRTN has  a
breakpoint in it) then DDT simply "returns" from the original  instr$X
rather than proceding  to $X the  internals of DDT  itself. This is  a
very obscure condition so don't worry too much about it.DDT41 - DDT %41(260) Users Guide to New Features               Page 15
Single-stepping the program


10.11 $$X status

DDT will now respond to  a ? character being  typed during an $$X  se-
quence by typing "Executing: " followed  by the current user "pc"  and
instruction being executed. Typing any other character terminates  the
$$X immediately.

10.12 $X PC

The $. command now acts like the  . command only $. returns the  value
of the $X PC (i.e., the address of the next instruction to be  $X'ed).
The $$. command returns the previous  $. value (useful for $$.<$$X  as
in section 10.9 above).


11.0 Searches11.0 Searches11.0 Searches11.0 Searches11.0 Searches11.0 Searches

Most of the  differences in how  DDT version 41  handles searches  are
simply bug fixes, not major changes in the logic of searching.

11.1 Non-existant pages

DDT version 41 now  simply skips over pages  which don't exist in  the
address space being  searched, rather than  terminating the search  as
soon as a hole has been found.

11.2 Missed matches

The bug which caused TOPS-20 DDT  to miss many valid matches is  fixed
in DDT version 41.

11.3 Effective address searches

Since almost all address calculations  start with an IFIW basis  (with
the exceptions being such things as interrupt vectors and the like  on
KL-10's or KS-10's),  DDT version  41 will  assume that  each word  it
examines is an instruction and perform an IFIW effective address  cal-
culation. The  final  result  must  match in  all  30  bits  (actually
internally DDT will  do a  full 36-bit  compare so  the address  being
searched for had better not contain anything in bits 0 to 5).

11.4 Address limit defaults

With the advent  of extended  addressing and  physical addressing  the
address limits are defaulted  somewhat differently than from  previous
versions of DDT:

1.   EDDT, MDDT (TOPS-20 only), UDDT, and VMDDT

     1.   Lower Limit: <current section>,,0
     2.   Upper Limit: <current section>,,777777

2.   FILDDT looking at an .EXE file

     1.   Lower Limit: 0
     2.   Upper Limit: highest virtual address mappedDDT41 - DDT %41(260) Users Guide to New Features               Page 16
Searches


3.   FILDDT looking at a data file

     1.   Lower Limit: 0
     2.   Upper Limit: highest word written in file

4.   FILDDT looking at disk structure/unit

     1.   Lower Limit: 0
     2.   Upper Limit: highest word in disk structure/unit

5.   FILDDT looking at runing monitor

     1.   Lower limit: 0
     2.   Upper limit: 777777

6.   FILDDT looking at physical memory (TOPS-10 only)

     1.   Lower Limit: 0
     2.   Upper Limit: Highest extant memory address

As with any defaults not all cases will be properly "guessed" by  DDT.
In particular if the user has mapping or address relocation in  effect
the virtual address range so  produced may have nothing whatsoever  in
common with the address limit defaults chosen by DDT.

11.5 Search matches

DDT will leave each  address matched by its  search on the "pc  stack"
available to $<CR> etc.  commands. When the  search is terminated  DDT
will set "." to the last address searched.

11.6 Searching status

DDT will now respond to a ?  character being typed during a search  by
typing "Searching: " followed by the current location and value  being
searched. Typing any other character terminates the search  immediate-
ly.


12.0 Watching12.0 Watching12.0 Watching12.0 Watching12.0 Watching12.0 Watching

DDT version 41 allows the user  to "watch" a location, waiting for  it
to change. Although primarily useful for FILDDT'ing the running  moni-
tor, it is present in all flavors fo DDT for completeness. The  syntax
of the  watching command  is exp$V,  where exp  is the  address to  be
watched. If no explicit address is specified the last location  opened
by the user will be used.

Upon initial issuance  of the  $V command the  location is  displayed.
Thereafter the location  is continuously monitored,  and will be  dis-
played every time  its contents change.  In user mode  DDTs (and  this
includes TOPS-20 MDDT as  well) the location is  checked once a  clock
tick (approximately 50 to  60 times a second),  in exec mode EDDT  the
location is continuously being monitored - no "pause" is attempted.

DDT will respond to a ? character being typed during an $V sequence byDDT41 - DDT %41(260) Users Guide to New Features               Page 17
Watching


typing "Watching:  " followed  by the  current location  and  contents
being watched. Typing any other character terminates the $V immediate-
ly.


13.0 Zeroing memory13.0 Zeroing memory13.0 Zeroing memory13.0 Zeroing memory13.0 Zeroing memory13.0 Zeroing memory

The algorithm used  by DDT  previous to  version 41  has only  limited
usefulness in today's  modern virtual world  (especially on  TOPS-20).
However, to avoid "breaking" already extant control or MIC files which
may use the $$Z command it  remains unchanged. A new command has  been
implemented - lwr<upr>exp$z  where lwr  is the  lowest (starting)  ad-
dress, upr is  the highest  (ending) address,  and exp  is the  36-bit
quantity to deposit in each word  inclusively bounded by lwr and  upr.
Both lwr and upr must be specified. If exp is not specified then 0  is
used as the default.

A special note: The creation of zeroed pages (which formerly were non-
existent) by  the $Z  and $$Z  commands is  under the  control of  the
automatic page create flag (i.e, the $1W and $$1W commands - see  sec-
tion 3.3.2).

DDT will  now  respond to  a  ? character  being  typed during  an  $Z
sequence by typing "Zeroing:  " followed by  the current location  and
value being "zeroed".  Typing any  other character  terminates the  $Z
immediately.


14.0 Special masks14.0 Special masks14.0 Special masks14.0 Special masks14.0 Special masks14.0 Special masks

DDT version 41 (it actually started  with DDT version 40) has  several
new "masks" (for lack of a better name and/or command) of interest  to
the user. None of these masks are currently displayable (e.g., "$3M/")
in FILDDT although they may be set normally.

14.1 $0M - Search mask

The operation of the search mask continues unchanged. The search  mask
may now be referenced  by either the  $M (old style)  or the $0M  com-
mands. The default value remains 777777777777.

14.2 $1M - TTY control mask

This mask controls  special TTY behavior  (primarily TOPS-10 and  exec
mode EDDT).

14.2.1 Tab separator display
Bit 17 controls whether DDT will print its usual <TAB> or three spaces
for the <TAB> separator. A 0  (the default) selects three spaces, a  1
selects a <TAB>.

14.2.2 Tab simulation
Bit 34 controls tab simulation.  A 0 selects literal <TAB>  characters
(i.e., the terminal handles <TAB>'s  directly, a 1 selects  space-fill
instead. This condition is automatically  set for user mode DDT's  (in
user mode <TAB>s are always output  literally) - it is only useful  toDDT41 - DDT %41(260) Users Guide to New Features               Page 18
Special masks


manually set tab simulation in exec mode EDDT.

14.2.3 Rubout control
Bit 35  controls rubout  (and ^W)  operation. A  0 selects  "hardcopy"
operation (DDT  will echo  a  "\" character  and the  character  being
deleted), a 1 will cause rubouts to echo as a backspace, space,  back-
space sequence.  This condition  is automatically  set for  user  mode
DDT's (if TTY DISPLAY is set  then rubouts echo as <BS><SP><BS>) -  it
is only useful to manually set fancy rubouts in exec mode EDDT.

14.3 $2M - Offset range

The 36-bit "mask" in this case is really a value, used as the  maximum
offset allowable for typing addresses  in the form symbol+offset.  The
default offset is 1000 (octal).

14.4 $3M - Byte mask

This mask is used in conjunction with the $O command for typing  bytes
in a word that are not necessarily evenly spaced. Whenever an $O  com-
mand is issued without an explicit  byte size the byte boundaries  are
determined by one-bits in  the byte mask  - each one  bit in the  byte
mask marks the low order  bit of a byte.  Bit 35 is always  considered
on. The default value  is 0 (i.e., one  36-bit byte). For example  the
DDT command 040100200401$3M sets the byte mask for typing right-justi-
fied 8-bit bytes (preceded by the leading 4-bit byte).


15.0 RADIX-50 symbol typein15.0 RADIX-50 symbol typein15.0 RADIX-50 symbol typein15.0 RADIX-50 symbol typein15.0 RADIX-50 symbol typein15.0 RADIX-50 symbol typein

Since prehistoric times DDT has supported RADIX-50 symbol typein,  but
that fact was never documented. The syntax for using a RADIX-50 symbol
as an 36-bit item in an expression is sym$5" where sym is the  desired
RADIX-50 symbol.  For example,  to search  for all  occurences of  the
symbol PAT.. the DDT commands  37777,,-1$M (only look at low-order  32
bits) and PAT..$5"$W suffice.


16.0 New DDT runtime information16.0 New DDT runtime information16.0 New DDT runtime information16.0 New DDT runtime information16.0 New DDT runtime information16.0 New DDT runtime information

Several new words have  been added to  DDT's runtime table  describing
the state of the machine  upon (executive mode only) DDT-entry.  These
words are all accessible via the DDT command $I+offset (not  available
in FILDDT):

1.   $I-01/    APR CONI word
2.   $I+00/    PI CONI word
3.   $I+01/    Mask of PI channels turned off by EDDT
4.   $I+02/    Executive virtual address of EPT
5.   $I+03/    Executive virtual address of UPT
6.   $I+04/    Executive virtual address of CST
7.   $I+05/    Executive virtual address of SPT
8.   $I+06/    Original AC-block word (DATAI PAG) if acb$4UDDT41 - DDT %41(260) Users Guide to New Features               Page 19
Obsolete commands


17.0 Obsolete commands17.0 Obsolete commands17.0 Obsolete commands17.0 Obsolete commands17.0 Obsolete commands17.0 Obsolete commands

The executive mode paper tape facilities (^R, $J, and $L DDT commands)
are no  longer supported.  The code  is left  in the  source file  for
reference purposes but will soon be removed.


18.0 FILDDT startup and commands18.0 FILDDT startup and commands18.0 FILDDT startup and commands18.0 FILDDT startup and commands18.0 FILDDT startup and commands18.0 FILDDT startup and commands

FILDDT is a special version of  DDT with the facilities for  "DDT'ing"
address spaces other than its own, such as disk files and in  particu-
lar .EXE files. FILDDT has existed  for years but has always been  off
in the background  as a specialized  "tool" for the  exclusive use  of
monitor programmers looking at crash dumps. With DDT version 41 FILDDT
is now a  general purpose  utility for  use by  the "general  public",
particularly people who  have databases resident  in disk files  (.REL
files for example).

18.1 Symbols

Out of efficiency considerations FILDDT builds the symbol table(s)  it
will actually use at runtime in  its own address space. Virgin  FILDDT
has no symbols (the symbol table (if any) for FILDDT in FILDDT.EXE  is
completely independent of the address  space being FILDDT'ed and  does
not count). There are special  commands to instruct FILDDT to  extract
(and build internal-to-FILDDT copies of) symbol tables from .EXE files
(see below). Once FILDDT  has setup its  internal symbol table(s),  it
may then be SAVEd with the  internal symbol table(s) for later use  by
exiting to monitor level (with the  ^Z FILDDT command) and typing  the
"SAVE" command.

18.2 TOPS-10

When FILDDT is started it will  prompt "File: ". The user may at  this
time optionally enter  a standard  TOPS-10 file  specification in  the
form dev:name.type[directory]/switch. At least one function switch  is
mandatory. SFD's are of course legal in the directory specification.

18.2.1 /D command
The /D  command or  function  switch instructs  FILDDT that  the  file
specified is a data file - i.e., do  not map the file as an .EXE  file
and use real file words 0 to 17 for locations 0 to 17.

18.2.2 /F command
The /F command or function switch  instructs FILDDT to "DDT this  file
anyway". It is useful only in conjunction with the /S command or func-
tion switch which normally re-prompts for another file  specification.
Used in conjunction with /S (which  implies an .EXE file) FILDDT  will
use the  file from  which symbols  were extracted  as the  file to  be
"DDT'ed".

18.2.3 /H command
The /H command or function switch instructs FILDDT to type out a brief
help text, abort the current command, and prompt the user for  another
command.DDT41 - DDT %41(260) Users Guide to New Features               Page 20
FILDDT startup and commands


18.2.4 /J command
The /J command or  function switch is applied  to a job number  rather
than a file specification  and instructs FILDDT  to "DDT" the  address
space of the job specified. Since FILDDT uses JOBPEK monitor calls  to
access the specified job's address space the success or failure of any
given memory reference is dependent on the job being resident in  main
memory - if the job is swapped out or if the memory reference is to  a
page which is  paged out  the memory reference  will fail.  This is  a
privileged command.

18.2.5 /M command
The /M command or function switch  instructs FILDDT to "DDT" the  cur-
rently running monitor and  physical memory address space  (controlled
by use of the $U and $$U commands). This is a privileged command.

18.2.6 /P command
The /P command or function switch instructs FILDDT to enable for writ-
ing as well as  reading the specified address  space. Note that  DDT's
internal fake registers are always writable.

18.2.7 /S command
The /S command or function switch instructs FILDDT to only extract the
symbol table  from  the file  specified,  replacing any  symbol  table
FILDDT may already have.  Unless overridden by the  inclusion of a  /F
command FILDDT will, after having read the symbol table, again  prompt
the user for the next FILDDT command.

18.2.8 /U command
The /U command or  function switch is applied  to a file structure  or
disk unit only rather than a complete file specification and indicates
to FILDDT that the user wants the entire physical address space repre-
sented by that  file structure or  disk unit name  independent of  any
"file structure mapping" normally  imposed by the  monitor. This is  a
privileged command.

18.3 TOPS-20

With DDT version  41, FILDDT on  TOPS-20 runs in  native mode, and  in
particular, uses the PMAP  monitor call for  all regular file  access.
FILDDT will also type  a brief message telling  what address space  is
about to be "DDT'ed" before going into DDT mode.

18.3.1 DRIVE command
The format of the DRIVE command is:

     DRIVE (FOR PHYSICAL I/O IS ON CHANNEL) c (UNIT) u

The DRIVE command  allows examination  of the  disk unit  u on  system
channel c without regard for whether it  is mounted as part of a  file
structure, or indeed whether it even has the necessary information  so
that it could be so  mounted (as if the  HOME blocks were wiped  out).
If, however, the  drive is part  of a mounted  file structure,  FILDDT
will type a message indicating the structure to which it belongs. This
is a privileged command.DDT41 - DDT %41(260) Users Guide to New Features               Page 21
FILDDT startup and commands


18.3.2 ENABLE DATA-FILE command
The ENABLE DATA-FORMAT command instructs  FILDDT to treat the file  as
pure data, even if a valid .EXE directory is detected, and in particu-
lar to use real file words 0 to 17 as locations 0 to 17.

18.3.3 ENABLE PATCHING command
The ENABLE PATCHING command instructs FILDDT to enable any subsequent-
ly specified address  space for  patching (writing).  This command  is
ignored when looking at the running monitor since there is no  monitor
call to "poke" the running monitor.

18.3.4 EXIT command
The EXIT  command instructs  FILDDT  to return  to command  level.  If
FILDDT has an  internal symbol table  (due to a  previous LOAD or  GET
FILDDT command) then a SAVE command will save FILDDT with the  symbols
pre-loaded.

18.3.5 GET command
The format of the GET command is:

     GET (FILE) filespec (optional switches)

The GET command instructs FILDDT to  set up the disk file filespec  as
the address space to be "DDT'ed", as modified by the optional switches
or previous ENABLE commands. The available switches are:

18.3.5.1 /DATA - The /DATA switch  is equivilent to a previous  ENABLE
DATA-FILE command.

18.3.5.2 /PATCH - The /PATCH switch is equivilent to a previous ENABLE
PATCHING command.

18.3.5.3 /SYMBOL - The /SYMBOL switch instructs FILDDT to extract sym-
bols from the specified .EXE file before "DDT'ing" the file,  discard-
ing any symbols  that FILDDT may  already have. This  switch is  legal
only with .EXE files.

18.3.6 HELP command
The HELP command instructs FILDDT to  type out a short summary of  the
available FILDDT commands.

18.3.7 LOAD command
The format of the LOAD command is:

     LOAD (SYMBOLS FROM) filespec

The LOAD command  instructs FILDDT  to extract symbols  from the  disk
file filespec, which must  be an .EXE file,  then to return to  FILDDT
command level. This command is legal only for .EXE files.

18.3.8 PEEK command
The PEEK command instructs FILDDT to use the currently running monitor
as the address space to be "DDT'ed". The address space so available is
currently limited to monitor executive virtual addresses 0 to  777777,
since the PEEK monitor call will only accept 18-bit address  arguments
for executive  virtual addresses.  Physical memory  addressing is  notDDT41 - DDT %41(260) Users Guide to New Features               Page 22
FILDDT startup and commands


available. This is a privileged command.

18.3.9 STRUCTURE command
The format of the STRUCTURE command is:

     STRUCTURE (FOR PHYSICAL I/O IS) str:

The STRUCTURE command instructs FILDDT to use as the address space  to
be "DDT'ed"  the entire  disk file  structure str  independent of  any
"file structure mapping" normally  imposed by the  monitor. This is  a
privileged command.

18.4 Defaults

Following is a list of the various defaults supplied by FILDDT:

1.   DSK: is the  default file  device unless super  I/O is  specified
     (which requires an explicit file structure or disk unit name).
2.   .EXE is the default file type  or extension unless either a  data
     file or super I/O is specified, in which case there is no default
     file type or extension.
3.   The default directory is the user's default directory.
4.   The specified address space is read-only.
5.   If "DDT'ing" an  .EXE file  and FILDDT  does not  already have  a
     symbol table, extract  the symbol  table (if any)  from the  .EXE
     file first.
6.   If "DDT'ing" an .EXE file and  the symbol CRSHAC (if TOPS-10)  or
     BUGACS (if TOPS-20) exists, give a "free" CRSHAC$5U or  BUGACS$5U
     command. If the CRSHAC/BUGACS symbol does not exist then use file
     words 0 to 17 (if any) as mapped by the .EXE directory for  loca-
     tions 0 to 17.  For TOPS-20 only, if  the symbol SPT exists  then
     also give a free SPT$6U command as well.


18.5 Other FILDDT-specific commands

Following are the commands which are unique (or different) to FILDDT.

18.5.1 ^E command
The ^E command instructs FILDDT to exit the current address space  and
prompt the user for a new address space. The ^E command is  equivilent
to a ^Z, START command sequence.

18.5.2 ^Z command
The ^Z command instructs FILDDT to exit to monitor level after  having
written out  any changes  to the  current file  (if any).  It is  most
important that the user exit only via ^Z (or ^E which does an implicit
^Z) in order to guarantee the integrity of the file data (if any) -  a
^C can leave a  file in an indeterminate  state (some changes  written
out to the disk and some not).

18.5.3 I/O errors
Should FILDDT incur  an I/O error  reading or writing  a disk file,  a
warning message will be  issued but FILDDT  will otherwise ignore  the
error. This is to allow  the user the ability  to manually fix a  file
with bad data by  rewriting the data  correctly (hoping the  rewritingDDT41 - DDT %41(260) Users Guide to New Features               Page 23
FILDDT startup and commands


operation clears the error  condition - if  the physical disk  surface
itself is at fault, then it is probably hopeless).


                      [End of DDT41 Users Guide]  