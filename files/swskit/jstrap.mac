	TITLE	JSTRAP	PROGRAM TO WATCH JSYSES OF AN INFERIOR FORK


;NOTE:  THIS PROGRAM CAN ONLY RUN UNDER RELEASE 3 OR LATER.
;WRITTEN BY DAVID I. BELL, AT DIGITAL IN MARLBORO.
;THIS PROGRAM WILL WATCH THE JSYSES WHICH SOME INFERIOR FORK
;DOES, AND LOG THEM TO A LOG FILE.  THE LOG FILE CAN CONTAIN THE
;JSYS, THE PC IT WAS EXECUTED AT, AND THE ARGUMENTS TO THE JSYS.


	SEARCH	MACSYM,MONSYM	;GET SYMBOLS
	SALL			;NICE LOOKING MACROS


;VERSION INFORMATION:


	VMAJOR==1		;MAJOR VERSION
	VMINOR==0		;MINOR VERSION
	VEDIT==104		;EDIT NUMBER
	VWHO==1			;WHO LAST EDITED



;ACCUMULATORS:


	F=0			;FLAGS
	T1=1			;TEMPORARY AC'S
	T2=2
	T3=3
	T4=4
	T5=5
	C=6			;CHARACTER HOLDING
	P=17			;STACK



;FLAGS


	FR.INT==1		;USER HAS INTERRUPTED US
	FR.HDR==2		;HEADER LINE HAS BEEN TYPED
	FR.SAM==4		;ALL FORKS HAVE THE SAME ADDRESS SPACE

;JSYS CATAGORIES:


	JS.PRI==1		;JSYSES DOING PRIMARY I/O
	JS.FRK==2		;JSYSES HANDLING FORKS
	JS.FIL==4		;JSYSES HANDLING ANY FILE
	JS.INP==10		;JSYSES HANDLING INPUT
	JS.OUT==20		;JSYSES HANDLING OUTPUT
	JS.INT==40		;JSYSES HANDLING INTERRUPTS
	JS.SET==100		;JSYSES WHICH SET SOMETHING
	JS.STS==200		;JSYSES WHICH GET INFO
	JS.IPC==400		;JSYSES WHICH DO IPCF FUNCTIONS
	JS.ALL==1000		;ANY JSYS


;DEFAULT PARAMETERS:


	TXTLEN==^D100		;SIZE OF COMMAND BUFFERS
	PDLSIZ==40		;SIZE OF PUSHDOWN STACK
	SYMLEN==10000		;MAXIMUM NUMBER OF WORDS FOR SYMBOLS
	TTCHN==0		;CHANNEL FOR TTY INTERRUPTS
	JSCHN==1		;CHANNEL FOR JS TRAPPING INTERRUPTS
	BITSIZ==<1000+^D35>/^D36	;WORDS NEEDED FOR 1000 BITS




;MACROS AND OPDEFS:


	OPDEF	PJRST	[JRST]			;PUSHJ/POPJ
	OPDEF	PUTCHR	[PUSHJ	P,CHROUT]	;STORE A CHARACTER



	DEFINE	AA(NAME,DATA,FLAGS),<		;;MACRO FOR COMMAND TABLES
	XWD	[IFNB <FLAGS>,<EXP CM%FW!<FLAGS>>
		 ASCIZ/NAME/],DATA
>



	DEFINE	TEXT(STRING),<		;;MACRO FOR ASCIZ TEXT
	XLIST
	ASCIZ	@STRING@
	LIST
>

	SUBTTL	COMMAND SCANNER AND INITIALIZATION




ENTRY:	JRST	START		;NORMAL ENTRY
	JRST	START		;REENTER
	BYTE 	(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT


START:	RESET			;CLEAR EVERYTHING
	MOVE	P,[IOWD PDLSIZ,PDL]	;SET UP A STACK
	SETZB	F,JFN		;CLEAR FLAGS AND INPUT JFN
	SETZM	JFNOUT		;AND OUTPUT JFN
	SETZM	HANDLE		;AND HANDLE OF INFERIOR
	SETZM	MAPCNT		;CLEAR NUMBER OF MAPPED PAGES
	MOVEI	T1,.JBSYM##	;GET NORMAL ADDRESS OF SYMBOLS
	MOVEM	T1,SYMADR	;AND SAVE IT
	MOVEI	T1,CORE		;GET ADDRESS OF PMAP BLOCK
	ADDI	T1,777		;ROUND UP TO NEXT PAGE
	ANDCMI	T1,777		;AND PUT ON EXACT BOUNDARY
	MOVEM	T1,PAGADR	;THEN SAVE POINTER
	MOVEI	T1,^D1000	;GET DEFAULT REPETITION COUNT
	MOVEM	T1,REPMAX	;AND INITIALIZE IT
	SETOM	BITS		;SET ALL THE BITS ON
	MOVE	T1,[BITS,,BITS+1]	;FOR DEFAULT CASE
	BLT	T1,BITS+BITSIZ-1	;WHICH IS TRAPPING OF ALL JSYSES
	MOVEI	T1,.TICCP	;GET DEFAULT TRAPPING CODE
	MOVEM	T1,INTCHR	;AND INITIALIZE IT
	MOVEI	T1,.FHSLF	;GET READY
	MOVE	T2,[LEVTAB,,CHNTAB]	;TO SET INTERRUPTS
	SIR			;TELL MONITOR WHERE THEY ARE
	MOVX	T2,1B<TTCHN>	;GET CHANNEL FOR TTY INTERRUPT
	AIC			;TURN IT ON
	MOVX	T2,1B<JSCHN>	;GET CHANNEL FOR JSYS TRAPPING
	AIC			;TURN IT ON
	EIR			;ENABLE THE INTERRUPTS

;HERE TO PROCESS A NEW COMMAND.  THIS IS ALSO THE PLACE THAT CONTROL
;IS PASSED WHEN WE ARE RUNNING AN INFERIOR FORK, AND A TERMINAL
;INTERRUPT OCCURRS.



NEWCMD:	MOVEI	T1,CMDBLK	;POINT TO COMMAND BLOCK
	MOVEI	T2,[FLDDB. (.CMINI)]	;INITIALIZATION FUNCTION
	PUSHJ	P,COMMND	;GO DO IT
	MOVEM	P,SAVEP		;SAVE STACK FOR REPARSING


NEWPAR:	MOVE	P,SAVEP		;RESTORE THE STACK
	MOVEI	T1,CMDBLK	;POINT TO THE COMMAND BLOCK
	MOVEI	T2,[FLDDB. (.CMKEY,,CMDTAB)]	;POINT TO COMMAND TABLE
	PUSHJ	P,COMMND	;READ THE COMMAND
	MOVE	T2,(T2)		;GET ADDRESS OF ROUTINE
	PUSHJ	P,(T2)		;CALL IT
	JRST	NEWCMD		;AND GET A NEW COMMAND




;TABLE OF COMMANDS:


CMDTAB:	CMDLEN,,CMDLEN			;HEADER
	AA	ALLOW,CMDALW		;ALLOW TRAPPING FOR JSYSES
	AA	CLOSE,CMDCLS		;CLOSE LOG FILE
	AA	DISALLOW,CMDDIS		;DISALLOW TRAPPING
	AA	EXIT,CMDXIT		;LEAVE PROGRAM
	AA	FORKS,CMDFRK		;FORKS HAVE SAME ADDRESS SPACE
	AA	GET,CMDGET		;READ IN THE PROGRAM TO WATCH
	AA	HELP,CMDHLP		;TYPE HELP MESSAGE
	AA	INTERRUPT,CMDINT	;SET INTERRUPT CHARACTER
	AA	LOG,CMDLOG		;BEGIN LOGGING JSYSES
	AA	MAXIMUM,CMDMAX		;SET MAXIMUM REPETITIONS
	AA	PROCEED,CMDPRO		;CONTINUE FROM INTERRUPT
	AA	RESET,CMDRES		;RESET EVERYTHING
	AA	S,STABBR,CM%ABR+CM%INV	;ABBREVIATION OF START
STABBR:	AA	START,CMDST		;START THE PROGRAM
	AA	SYMBOLS,CMDSYM		;GET SYMBOLS
	AA	TELL,CMDTEL		;TELL STATUS OF A JSYS

	CMDLEN==.-CMDTAB-1		;NUMBER OF COMMANDS

	SUBTTL	COMMAND TO SET WHAT ADDRESS TO GET SYMBOL TABLE FROM




;HERE TO READ IN THE ADDRESS OF THE SYMBOL POINTER TO USE IN
;READING IN THE SYMBOLS.  THE SYMBOLS ARE ALSO READ IN IF THE
;PROGRAM IS CURRENTLY IN CORE.




CMDSYM:	MOVEI	T2,[ASCIZ/READ USING POINTER AT LOCATION/]
	PUSHJ	P,NOISE		;PARSE NOISE
	MOVEI	T2,[FLDDB. (.CMNUM,,^D8,,<116>)]	;GET FUNCTION
	PUSHJ	P,COMMND	;READ NUMBER
	MOVE	T4,T2		;SAVE IT
	PUSHJ	P,CONFRM	;AND CONFIRM THE LINE
	CAIL	T4,20		;MAKE SURE NOT IN THE AC'S
	CAILE	T4,777777	;AND MAKE SURE NOT TOO LARGE
	  JRST	BADSYA		;BAD ADDRESS
	MOVEM	T4,SYMADR	;OK, SAVE THE ADDRESS
	SKIPN	HANDLE		;DO WE HAVE A FORK THERE?
	  POPJ	P,		;NO, THEN RETURN
	PJRST	GETSYM		;YES, THEN GET THE SYMBOLS



BADSYA:	HRROI	T1,[ASCIZ/
? Illegal address specified/]	;GET ERROR TEXT
	PSOUT			;OUTPUT IT
	JRST	LOSFIN		;AND FINISH UP

	SUBTTL	ROUTINE TO BEGIN LOGGING OF JSYSES




;HERE IS THE COMMAND WHICH DETERMINES THE OUTPUT SPEC FOR THE LOGGING,
;AND SETS UP THE TRAPPING FOR JSYSES.  USUALLY THE PROGRAM TO BE
;TRAPPING HASN'T STARTED YET, BUT IT COULD BE IF IT WAS INTERRUPTED.




CMDLOG:	MOVEI	T2,[ASCIZ/JSYSES TO FILE/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE NOISE TEXT
	HRROI	T2,[ASCIZ/JSTRAP/]	;GET DEFAULT FILE
	MOVEM	T2,JFNBLK+.GJNAM	;SAVE IT
	HRROI	T2,[ASCIZ/LOG/]		;GET DEFAULT EXTENSION
	MOVEM	T2,JFNBLK+.GJEXT	;SAVE IT TOO
	MOVX	T2,GJ%FOU+GJ%MSG	;GET FLAGS
	MOVEM	T2,JFNBLK	;AND SET THEM
	MOVEI	T2,[FLDDB. (.CMFIL)]	;GET READY
	PUSHJ	P,COMMND	;READ OUTPUT SPEC
	MOVE	T4,T2		;SAVE THIS JFN
	PUSHJ	P,CONFRM	;CONFIRM THE LINE
	PUSHJ	P,CLSLOG	;CLOSE ANY OLD LOG FILE
	HRRZM	T4,JFNOUT	;THEN SAVE AWAY THIS NEW ONE
	MOVE	T1,JFNOUT	;GET READY TO OPEN THE FILE
	MOVX	T2,7B5+OF%APP	;WANT TO APPEND TO THE FILE
	OPENF			;OPEN IT UP
	  ERJMP	LOSE		;CAN'T
	SETZM	REPCNT		;CLEAR THE REPEAT COUNT
	SETZM	JSJSYS		;AND PREVIOUS JSYS
	ANDCMI	F,FR.HDR	;REMEMBER WE NEED A NEW HEADER LINE
	POPJ	P,		;AND RETURN

	SUBTTL	SIMPLE COMMANDS



;HERE TO DO A RESET.  THIS IS ESSENTIALLY JUST THE SAME THING
;AS RESTARTING THE PROGRAM.



CMDRES:	PUSHJ	P,CONFRM	;CONFIRM THE COMMAND FIRST
	PUSHJ	P,CLRADR	;UNDO ANY MAPPINGS
	PUSHJ	P,CLSLOG	;CLOSE THE LOG FILE
	JRST	START		;THEN START THE PROGRAM OVER





;HERE TO EXIT FROM PROGRAM.  THE OUTPUT FILE IS CLOSED IF NECESSARY.


CMDXIT:	MOVEI	T2,[ASCIZ/FROM PROGRAM/]	;GET NOISE
	PUSHJ	P,NOISE		;EAT NOISE WORDS
	PUSHJ	P,CONFRM	;THEN CONFIRM THE COMMAND
	PUSHJ	P,CLRADR	;UNDO ANY MAPPING
	PUSHJ	P,CLSLOG	;CLOSE UP THE LOG FILE
	RESET			;RESET EVERYTHING
	HALTF			;QUIT FOR NOW
	JRST	START		;AND RESTART IF CONTINUED




;HERE TO GET THE NUMBER OF DUPLICATIONS OF A JSYS WHICH OCCUR
;IN A ROW.  LISTING OF THE JSYS AFTER THIS MANY TIMES IN A ROW
;WILL BE SUPPRESSED (SUCH AS BOUTS, PBOUTS, ETC.).




CMDMAX:	MOVEI	T2,[ASCIZ/NUMBER OF REPETITIONS IS/]
	PUSHJ	P,NOISE		;PARSE THE NOISE
	MOVEI	T2,[FLDDB. (.CMNUM,,^D10,,<1000>)]
	PUSHJ	P,COMMND	;READ THE NUMBER
	MOVE	T4,T2		;SAVE IT
	PUSHJ	P,CONFRM	;CONFIRM THE LINE
	SKIPG	T4		;IS THE RESULT NEGATIVE?
	HRLOI	T4,377777	;YES, MAKE IT LARGE AND POSITIVE
	MOVEM	T4,REPMAX	;SAVE THE VALUE
	POPJ	P,		;AND RETURN

;HERE TO STOP LOGGING OF JSYSES.  AS LONG AS WE DO NOT LOG THE
;JSYSES, NO JSYS TRAPPING CAN OCCUR, SINCE THAT IS USELESS.
;THE "CLOSE" COMMAND.




CMDCLS:	MOVEI	T2,[ASCIZ/LOG FILE AND STOP TRAPPING JSYSES/]
	PUSHJ	P,NOISE		;PARSE NOISE
	PUSHJ	P,CONFRM	;CONFIRM THE COMMAND

CLSLOG:	SKIPE	T1,JFNOUT	;GET OUTPUT JFN
	CLOSF			;CLOSE THE FILE IF IT WAS OPEN
	  ERJMP	.+1		;SHOULDN'T FAIL
	SETZM	JFNOUT		;CLEAR OUTPUT JFN
	POPJ	P,		;AND RETURN




;HERE TO SET WHETHER OR NOT ALL FORKS WILL HAVE THE SAME ADDRESSING
;SPACE OR NOT.  NEEDED FOR US TO KNOW WHETHER OR NOT TO GIVE SYMBOLS
;FOR LOWER FORKS.



CMDFRK:	MOVEI	T2,[ASCIZ/HAVE/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE IT
	MOVEI	T2,[FLDDB. (.CMKEY,,FRKTAB,,<DIFFERENT>)]
	PUSHJ	P,COMMND	;READ THE KEYWORD
	MOVE	T4,(T2)		;GET THE OFFSET
	MOVEI	T2,[ASCIZ/CORE IMAGES/]	;GET MORE NOISE
	PUSHJ	P,NOISE		;PARSE IT
	PUSHJ	P,CONFRM	;THEN CONFIRM IT
	XCT	[IORI	F,FR.SAM	;DO PROPER THING
		 ANDCMI	F,FR.SAM](T4)	;DEPENDING ON KEYWORD
	POPJ	P,		;THEN RETURN


FRKTAB:	FRKLEN,,FRKLEN		;NUMBER OF KEYWORDS
	AA	DIFFERENT,1	;DIFFERENT CORE IMAGES
	AA	IDENTICAL,0	;SAME CORE IMAGES

	FRKLEN==.-FRKTAB-1	;NUMBER OF KEYWORDS

	SUBTTL	THE HELP COMMAND


CMDHLP:	PUSHJ	P,CONFRM	;CONFIRM THE LINE
	HRROI	T1,HLPTXT	;POINT TO HELP MESSAGE
	PSOUT			;TYPE IT
	POPJ	P,		;AND RETURN


HLPTXT:	TEXT	<
Commands are the following:

  ALLOW arg		Add the set of JSYSes specified to the set
			which is being trapped and logged.

  DISALLOW arg		Remove the set of JSYSes specified from the
			set which is being trapped and logged.

  CLOSE			Close the log file and stop trapping of JSYSes.

  EXIT			Close log file and exit from program.

  FORKS arg		Tell whether or not you expect the core image
			of all forks to be the same.  This command only
			affects the symbolic listing in the log file.

  GET program		Read the specified program into an inferior fork.
			The program is not started.

  INTERRUPT char	Set which control character to use to interrupt
			the program being run.  The default is ^P.

  LOG spec		Begin logging of the JSYSes to the specified
			file.  The default file is JSTRAP.LOG.

  MAXIMUM number	Set how many identical JSYSes in a row can be
			logged.  Any further identical JSYSes are
			ignored.  Default value is 1000.

  PROCEED		Return from a terminal interrupt.

  RESET			Close the log file and restart the program.

  START			Begin execution of the program being watched.

  SYMBOLS addr		Set what address to use for reading in symbols.
			The default address is .JBSYM (116).

  TELL jsys		Tell whether or not a particular JSYS is being
			trapped.  The argument ALL will list all JSYSes
			which are being trapped.

>				;HELP MESSAGE

	SUBTTL	COMMAND TO TELL ABOUT WHICH JSYSES WE ARE TRAPPING



;THIS IS THE "TELL" COMMAND, WHICH WILL TELL THE STATUS OF A JSYS.
;IF THE ARGUMENT IS "*", WE TELL ABOUT ALL JSYSES.



CMDTEL:	MOVEI	T2,[ASCIZ/ABOUT JSYS/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE IT
	PUSHJ	P,READJS	;INPUT JSYS NAME AND VALUE
	JUMPL	T1,TELWLD	;TELL ABOUT THEM ALL IF WILDCARD
	MOVE	T5,JSTAB(T1)	;GET POINTER TO JSYS NAME
	IDIVI	T1,^D36		;SPLIT UP
	MOVNI	T2,(T2)		;GET READY
	MOVSI	T3,400000	;GET A BIT READY
	LSH	T3,(T2)		;SHIFT IT
	AND	T3,BITS(T1)	;SEE IF THIS JSYS IS BEING TRAPPED
	HRROI	T1,[ASCIZ/
/]				;GET A CRLF
	PSOUT			;PRINT IT
	HRROI	T1,(T5)		;POINT TO JSYS NAME
	PSOUT			;OUTPUT IT
	HRROI	T1,[ASCIZ/ is /]	;MORE
	PSOUT			;PRINT IT
	HRROI	T1,[ASCIZ/not /]	;GET TEXT
	SKIPN	T3		;ARE WE TRAPPING THIS JSYS?
	PSOUT			;NO, SAY SO
	HRROI	T1,[ASCIZ/being trapped

/]				;GET FINAL STUFF
	PSOUT			;TYPE IT
	POPJ	P,		;AND RETURN

;HERE WHEN HE WANTS TO HAVE A LIST OF ALL THE JSYSES WE ARE
;TRAPPING FOR.



TELWLD:	MOVE	T4,[POINT 1,BITS]	;GET A BYTE POINTER
	MOVSI	T5,-1000	;AND AN AOBJN POINTER
	SETZ	C,		;AND A COUNTER

TELLOP:	ILDB	T1,T4		;GET NEXT BIT
	JUMPN	T1,TELNXT	;JUMP IF ARE TRAPPING IT
	HRROI	T1,[ASCIZ/
The following JSYSes are not being trapped:
/]				;GET TEXT READY
	SKIPN	C		;FIRST TIME?
	PSOUT			;YES, PRINT THE HEADER
	HRROI	T1,[ASCIZ/
/]				;GET A CRLF READY
	TRNN	C,7		;TIME FOR A NEW LINE?
	PSOUT			;YES, DO A CRLF FIRST
	MOVEI	T1,"	"	;GET A TAB
	TRNE	C,7		;AT FRONT OF A LINE?
	PBOUT			;NO, THEN TYPE THE TAB
	MOVE	T3,JSTAB(T5)	;GET POINTER TO NAME
	MOVE	T2,(T3)		;GET NAME
	CAMN	T2,[ASCII/JSYS /]	;IS THIS JSYS UNNAMED?
	MOVE	T2,1(T3)	;YES, GET SECOND PART OF NAME
	SETZ	T3,		;MAKE IT ASCIZ
	HRROI	T1,T2		;POINT TO IT
	PSOUT			;TYPE IT
	ADDI	C,1		;ADD TO COUNT OF JSYSES
TELNXT:	AOBJN	T5,TELLOP	;LOOP OVER ALL BITS
	HRROI	T1,[ASCIZ/
All JSYSes are being trapped/]	;GET TEXT READY
	SKIPN	C		;NO JSYSES AT ALL?
	PSOUT			;RIGHT, TELL SO
	HRROI	T1,[ASCIZ/

/]				;GET A FINAL CRLF
	PSOUT			;OUTPUT IT
	POPJ	P,		;AND RETURN

	SUBTTL	COMMANDS TO SET WHAT CLASS OF JSYSES TO TRAP



;HERE ARE THE "ALLOW" AND "DISALLOW" COMMANDS, TO SET OR CLEAR TRAPS
;FOR PARTICULAR CLASSES OF JSYSES.  THIS ACTION IS JUST DIDDLING
;THE BIT TABLE OF JSYSES.



CMDDIS:	TDZA	T4,T4		;SET AC ZERO AS A FLAG
CMDALW:	MOVSI	T4,-1		;SET AC NEGATIVE AS A FLAG
	MOVEI	T2,[ASCIZ/TRAPS FOR/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE IT
	MOVEI	T2,[FLDDB. (.CMKEY,,CLSTAB,,<ALL>)]	;GET SET
	PUSHJ	P,COMMND	;LOOK FOR KEYWORD
	CAIN	T2,SPCLCL	;IS IT THE SPECIAL KEYWORD?
	JRST	SETSPL		;YES, HANDLE SPECIALLY
	HRR	T4,(T2)		;NO, NORMAL CASE, SAVE TABLE ADDRESS
	MOVEI	T2,[ASCIZ/CLASS OF JSYSES/]	;MORE NOISE
	PUSHJ	P,NOISE		;PARSE IT
	PUSHJ	P,CONFRM	;COMFIRM THE COMMAND
CLSAOB:	MOVSI	T1,-BITSIZ	;GET AN AOBJN POINTER

CLSLOP:	MOVE	T2,(T4)		;GET WORD OF BITS
	SKIPL	T4		;CLEARING BITS?
	ANDCAM	T2,BITS(T1)	;YES, DO SO
	SKIPGE	T4		;SETTING BITS?
	IORM	T2,BITS(T1)	;YES, DO SO
	ADDI	T4,1		;MOVE TO NEXT WORD
	AOBJN	T1,CLSLOP	;LOOP OVER ALL WORDS
	POPJ	P,		;DONE, RETURN


;HERE WHEN THE KEYWORD WAS "JSYS".  WE LOOK FOR A PARTICULAR NAME,
;OR A PARTICULAR NUMBER.


SETSPL:	PUSHJ	P,READJS	;READ THE JSYS NAME
	JUMPL	T1,[	HRRI	T4,BT.ALL	;IF WILDCARD, GET TABLE
			JRST	CLSAOB	]	;AND SET THEM BITS
	IDIVI	T1,^D36		;DIVIDE BY BITS TO A WORD
	MOVNI	T2,(T2)		;GET SHIFT VALUE READY
	MOVSI	T3,400000	;AND BIT
	LSH	T3,(T2)		;POSITION IT
	SKIPL	T4		;CLEARING THE BIT?
	ANDCAM	T3,BITS(T1)	;YES, DO IT
	SKIPGE	T4		;SETTING THE BIT?
	IORM	T3,BITS(T1)	;YES, DO IT
	POPJ	P,		;THEN RETURN

;SUBROUTINE TO READ IN A JSYS NAME, OR THE OCTAL VALUE OF A JSYS.
;LEFT HALF OF AC T4 IS PRESERVED, THE NAME OF THE JSYS IS IN AC T5,
;AND THE VALUE OF THE JSYS IS IN AC T1.  IF "ALL" WAS TYPED, T1 IS NEGATIVE.




READJS:	MOVEI	T2,[FLDDB. (.CMNUM,,^D8,,<ALL>,<[FLDDB. (.CMFLD,,,<JSYS name>)]>)]
	SETZM	ATMBUF		;CLEAR THE ATOM BUFFER
	PUSHJ	P,COMMND	;PARSE A NUMBER OR A NAME
	TSC	T3,T3		;SEE WHICH ONE IT WAS
	HRRI	T4,(T3)		;AND SAVE IT
	SKIPN	T3		;WAS THIS A NUMBER?
	SKIPA	T5,T2		;YES, SAVE NUMBER
	MOVE	T5,ATMBUF	;NO, SAVE TEXT
	PUSHJ	P,CONFRM	;THEN CONFIRM THE COMMAND
	MOVE	T1,T5		;RESTORE ARGUMENT
	TRNN	T4,-1		;WAS THIS THE NUMBER?
	JRST	READJN		;YES, JUST GO CHECK THE RANGE
	MOVSI	T1,-1000	;GET READY FOR A SEARCH
	CAMN	T5,[ASCIZ/ALL/]	;IS THIS THE SPECIAL WORD?
	POPJ	P,		;YES, RETURN WITH T1 NEGATIVE

JSYSRC:	MOVE	T2,JSTAB(T1)	;GET POINTER TO JSYS NAME
	CAME	T5,(T2)		;MATCH?
	AOBJN	T1,JSYSRC	;NO, KEEP LOOKING
	JUMPGE	T1,BADJSY	;JUMP IF NOT FOUND
	MOVEI	T1,(T1)		;THROW AWAY LEFT HALF

READJN:	JUMPL	T1,BADJSY	;ERROR IF NEGATIVE
	CAIGE	T1,1000		;IS THE VALUE ILLEGAL?
	POPJ	P,		;YES, RETURN




BADJSY:	HRROI	T1,[ASCIZ/
? Illegal JSYS specified/]	;GET TEXT
	PSOUT			;OUTPUT IT
	JRST	LOSFIN		;AND FINISH

;THE TABLE OF CLASSES THAT CAN BE SET OR CLEARED.



CLSTAB:	CLSLEN,,CLSLEN			;NUMBER OF ENTRIES
	AA	ALL,BT.ALL		;ALL JSYSES
	AA	FILE,BT.FIL		;FILE ORIENTED JSYSES
	AA	FORK,BT.FRK		;FORK RELATED JSYSES
	AA	INFORMATION,BT.STS	;INFORMATION JSYSES
	AA	INPUT,BT.INP		;INPUT RELATED JSYSES
	AA	INTERRUPT,BT.INT	;INTERRUPT RELATED JSYSES
	AA	IPCF,BT.IPC		;IPCF JSYSES
SPCLCL:	AA	JSYS,0			;PARTICULAR JSYS
	AA	OUTPUT,BT.OUT		;OUTPUT RELATED JSYSES
	AA	SETTING,BT.SET		;JSYSES WHICH SET THINGS
	AA	TERMINAL,BT.PRI		;TERMINAL RELATED JSYSES

	CLSLEN==.-CLSTAB-1		;NUMBER OF KEYWORDS

	SUBTTL	COMMAND TO SET WHAT CHARACTER TO INTERRUPT ON




;HERE TO SET WHAT CHARACTER WILL BE USED TO INTERRUPT THE PROGRAM
;WHEN WE ARE RUNNING IT.



CMDINT:	HRROI	T2,[ASCIZ/CHARACTER IS CONTROL/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE IT
	MOVEI	T2,[FLDDB. (.CMFLD,,,<LETTER, A - Z>,<P>)]	;GET READY
	PUSHJ	P,COMMND	;READ IT
	MOVE	T4,ATMBUF	;SAVE FIRST WORD OF ATOM BUFFER
	PUSHJ	P,CONFRM	;CONFIRM THE COMMAND
	MOVE	T1,[POINT 7,T4]	;GET A BYTE POINTER READY
	ILDB	T2,T1		;GET THE CHARACTER
	CAIL	T2,"A"		;IS IT LEGAL ALPHABETIC CHAR?
	CAILE	T2,"Z"		;WELL?
	  JRST	BADCHR		;NO, COMPLAIN
	ILDB	T3,T1		;GET NEXT CHAR TOO
	JUMPN	T3,BADCHR	;IT MUST BE NULL
	MOVEI	T2,.TICCA-"A"(T2)	;CONVERT TO INTERRUPT CODE
	MOVEM	T2,INTCHR	;AND SAVE IT
	POPJ	P,		;THEN RETURN


BADCHR:	HRROI	T1,[ASCIZ/
? Character must be from A - Z/]	;GET TEXT
	PSOUT			;TYPE IT
	JRST	LOSFIN		;AND FINISH THE ERROR

	SUBTTL	COMMAND TO LOAD IN A PROGRAM TO BE WATCHED


;THE "GET" COMMAND.  CREATES AN INFERIOR FORK AND READS IN THE GIVEN
;PROGRAM INTO IT.  THE PROGRAM IS NOT YET STARTED.  IF THERE ARE ANY
;SYMBOLS, THEY ARE EXTRACTED INTO OUR OWN CORE SO THAT WE CAN EASILY
;USE THEM.




CMDGET:	MOVEI	T2,[ASCIZ/PROGRAM/]	;GET NOISE
	PUSHJ	P,NOISE		;PARSE IT
	SETZM	JFNBLK+.GJNAM	;CLEAR ANY DEFAULT FILE NAME
	HRROI	T2,[ASCIZ/EXE/]	;GET DEFAULT EXTENSION
	MOVEM	T2,JFNBLK+.GJEXT	;AND SAVE IT
	MOVX	T2,GJ%OLD	;GET FLAGS
	MOVEM	T2,JFNBLK	;SET THEM FOR GTJFN
	MOVEI	T2,[FLDDB. (.CMFIL)]	;GET READY
	PUSHJ	P,COMMND	;READ THE SPEC
	HRRZ	T4,T2		;SAVE IT
	PUSHJ	P,CONFRM	;CONFIRM THE COMMAND
	TRNE	F,FR.INT	;DURING AN INTERRUPT?
	  JRST	NOGET		;YES, LOSE
	PUSHJ	P,CLRADR	;REMOVE ANY MAPPING FROM BEFORE
	SKIPE	T1,HANDLE	;GET FORK HANDLE IF HAVE ONE
	KFORK			;RELEASE IT, AND CLOSE JFN
	  ERJMP	.+1		;CAN'T, IGNORE
	SETZM	HANDLE		;CLEAR HANDLE
	MOVEM	T4,JFN		;SAVE THE NEW JFN
	MOVX	T1,CR%CAP	;GET READY
	CFORK			;CREATE AN INFERIOR FORK
	  ERJMP	LOSE		;FAILED
	MOVEM	T1,HANDLE	;OK, SAVE HANDLE AWAY
	MOVSI	T1,(T1)		;PUT JFN IN RIGHT PLACE
	IOR	T1,JFN		;AND ADD IN JFN
	GET			;READ IN THE PROGRAM
	  ERJMP	LOSE		;FAILED
	SETZM	JSJSYS		;CLEAR OLD JSYS
	SETZM	REPCNT		;AND THE COUNTER
	PJRST	GETSYM		;READ IN SYMBOL TABLE



NOGET:	MOVE	T1,T4		;GET JFN
	RLJFN			;RELEASE IT
	  ERJMP	.+1		;FORGET IT
	JRST	INTST		;AND COMPLAIN

	SUBTTL	ROUTINE TO CONTINUE FROM INTERRUPTIONS




;HERE ON THE "PROCEED" COMMAND.  THIS CODE SHOULD ONLY BE REACHED
;WHEN A TERMINAL INTERRUPT IS IN PROGRESS.  WE RESTORE EVERYTHING AND
;RETURN TO WHERE WE WERE INTERRUPTED FROM SUCH A LONG TIME AGO.




CMDPRO:	MOVEI	T2,[ASCIZ/FROM INTERRUPTION/]	;GET TEXT
	PUSHJ	P,NOISE		;PARSE NOISE
	PUSHJ	P,CONFRM	;THEN END OF LINE
	TRNN	F,FR.INT	;INTERRUPTED FROM RUNNING THE PROG?
	  JRST	NOPRO		;NO, CAN'T DO THIS THEN
	HRROI	T1,[ASCIZ/
/]				;GET A CRLF
	PSOUT			;TYPE IT TO LOOK NICE
	MOVEI	T1,TTCHN	;GET CHANNEL FOR TERMINAL
	HRL	T1,INTCHR	;AND CODE FOR INTERRUPT
	ATI			;SET INTERRUPT CHARACTER
	SKIPE	JFNOUT		;DON'T TURN ON TRAPPING IF NOT LOGGING
	PUSHJ	P,TRAPON	;ALLOW TRAPPING AGAIN
	MOVE	T1,HANDLE	;GET PROCESS HANDLE
	RFORK			;RESUME THE INFERIORS
	MOVEI	T1,.FHSLF	;GET READY
	EIR			;ENABLE THE INTERRUPTS AGAIN
	MOVE	P,[SAVET1,,T1]	;GET READY
	BLT	P,P		;RESTORE AC'S, INCLUDING STACK
	ANDCMI	F,FR.INT	;CLEAR INTERRUPT FLAG
	DEBRK			;RETURN FROM INTERRUPT




NOPRO:	HRROI	T1,[ASCIZ/
? No interrupt was in progress/]	;GET TEXT
	PSOUT			;TYPE IT
	JRST	LOSFIN		;AND LOSE

	SUBTTL	ROUTINE TO START INFERIOR


;HERE TO START THE PROGRAM RUNNING THAT WAS READ INTO AN
;INFERIOR FORK.  WE MAY OR MAY NOT BE LOGGING THE JSYSES AT THIS
;POINT.  TERMINAL INTERRUPTS ARE ALWAYS ENABLED, SO THAT WE CAN
;HANDLE A COMMAND WHEN THE USER WANTS TO.



CMDST:	MOVEI	T2,[ASCIZ/PROGRAM/]	;NOISE
	PUSHJ	P,NOISE		;PARSE IT
	PUSHJ	P,CONFRM	;THEN CONFIRM IT
	SKIPN	HANDLE		;SEE IF HAVE A PROGRAM READ IN
	  JRST	NOST		;IF NONE, CAN'T DO THIS
	TRNE	F,FR.INT	;GET HERE DURING AN INTERRUPT?
	  JRST	INTST		;YES, LOSE
	HRROI	T1,[ASCIZ/
% Log file is not opened, thus no JSYS trapping will occur

/]				;GET TEXT
	SKIPN	JFNOUT		;HAVE OUTPUT FILE OPEN?
	PSOUT			;NO, WARN HIM
	MOVEI	T1,TTCHN	;GET CHANNEL FOR TERMINAL INTERRUPT
	HRL	T1,INTCHR	;AND GET INTERRUPT CODE
	ATI			;ALLOW INTERRUPTS
	MOVEI	T1,.FHSLF	;GET SET
	EIR			;ENABLE INTERRUPTS IN CASE WERE INTERRUPTED
	SKIPE	JFNOUT		;DON'T TURN ON TRAPPING UNLESS LOGGING
	PUSHJ	P,TRAPON	;TURN ON JSYS TRAPPING
	MOVE	T1,HANDLE	;GET FORK TO START
	SETZ	T2,		;START AT NORMAL ADDRESS
	SFRKV			;START THE PROGRAM
	  ERJMP	LOSE		;FAILED
	RFORK			;START FORK RUNNING
	WFORK			;NOW WAIT FOR IT TO TERMINATE
	MOVE	T1,INTCHR	;GET INTERRUPT CODE
	DTI			;REMOVE THE INTERRUPT
	PJRST	CLSLOG		;AND CLOSE THE LOG FILE



INTST:	HRROI	T1,[ASCIZ/
? Program currently interrupted.  Type "RESET" first/]
	SKIPA
NOST:	HRROI	T1,[ASCIZ/
? No program has been read in/]	;GET TEXT
	PSOUT			;TYPE IT
	JRST	LOSFIN		;AND FINISH UP

	SUBTTL	ROUTINE TO HANDLE INTERRUPT FROM A JSYS


;HERE ON AN INTERRUPT DUE TO A JSYS AN INFERIOR FORK HAS DONE.  WE
;MUST LOG IT IN THE LOG FILE AND THEN PROCEED.


JSYINT:	MOVEM	T1,SAV2T1	;SAVE AN AC
	MOVE	T1,[T2,,SAV2T1+1]	;GET READY
	BLT	T1,SAV2T1-T1+P	;SAVE THE REST
	RTFRK			;READ WHICH FORK TRAPPED
	MOVEM	T1,JSFORK	;REMEMBER WHICH FORK DID THE JSYS
	CAMN	T2,JSJSYS	;IS THIS JSYS THE SAME AS LAST ONE?
	AOSA	T3,REPCNT	;YES, ADD TO COUNTER
	SETZB	T3,REPCNT	;NO, CLEAR COUNTER
	MOVEM	T2,JSJSYS	;SAVE THIS JSYS NOW
	CAMGE	T3,REPMAX	;EXCEEDED OUR MAXIMUM?
	SKIPN	JFNOUT		;OR IS THERE NO OUTPUT JFN?
	  JRST	JSYDON		;YES, FORGET THIS THEN
	RFSTS			;READ THE FORK STATUS
	MOVEM	T2,JSPC		;SAVE THE PC
	MOVE	T1,JSFORK	;GET FORK AGAIN
	MOVEI	T2,ACS		;POINT TO STORAGE AREA
	RFACS			;READ THE FORK'S AC'S TOO
	MOVE	T1,[POINT 7,OUTBUF]	;GET A BYTE POINTER
	MOVEM	T1,OUTPTR	;INITIALIZE OUTPUT POINTER
	HRROI	T1,[ASCIZ/
FORK   PC     LABEL      JSYS         AC 1            AC 2            AC 3            AC 4

/]				;GET TEXT READY
	TRON	F,FR.HDR	;FIRST TIME THROUGH?
	PUSHJ	P,STROUT	;YES, TYPE HEADER LINE
	SETZM	OUTCNT		;NOW START COUNTER AT FRONT OF A LINE
	MOVE	T1,JSFORK	;GET FORK WHICH DID JSYS
	MOVEI	T1,-.FHSLF(T1)	;KEEP ONLY SMALL NUMBER
	MOVEI	C," "		;GET A SPACE
	CAIG	T1,7		;IS FORK NUMBER ONLY ONE DIGIT?
	PUTCHR			;YES, TYPE A SPACE
	PUSHJ	P,OCTOUT	;OUTPUT NUMBER
	MOVEI	T1,5		;GET COLUMN TO JUSTIFY TO
	PUSHJ	P,JUSTFY	;SPACE OVER TO IT
	MOVE	T1,JSPC		;GET THE PC OF THE FORK
	MOVEI	T1,-1(T1)	;BACK UP TO THE REAL PC
	PUSHJ	P,ADRTYP	;OUTPUT OCTAL AND SYMBOLIC ADDRESS
	MOVEI	T1,^D25		;GET COLUMN TO GO GO
	PUSHJ	P,JUSTFY	;MOVE TO IT
	MOVE	T1,JSJSYS	;GET THE JSYS THAT WAS DONE
	MOVE	T1,JSTAB(T1)	;POINT TO THE ASCIZ STRING
	PUSHJ	P,STROUT	;OUTPUT THE JSYS NAME
	MOVE	T5,JSJSYS	;GET JSYS AGAIN
	HLLZ	T5,JSTAB(T5)	;GET NEGATIVE NUMBER OF AC'S TO PRINT
	JUMPE	T5,ACDON	;SKIP ON IF NO AC'S GET PRINTED
	IORI	T5,T1		;AND FIRST AC TO PRINT

;HERE TO LOOP TYPING AS MANY AC'S AS IS NECESSARY FOR THIS JSYS.




ACTYP:	MOVEI	T1,-1(T5)	;GET WHICH AC WE ARE PRINTING
	IMULI	T1,^D16		;MULTIPLY BY WIDTH OF A COLUMN
	ADDI	T1,^D33		;ADD IN WIDTH USED BEFORE THE AC'S
	PUSHJ	P,JUSTFY	;MOVE TO THAT PLACE
	HLRZ	T1,ACS(T5)	;GET LEFT HALF OF AN AC
	PUSHJ	P,OCTSP6	;RIGHT JUSTIFY IN A FIELD OF 6
	PUSHJ	P,OCTOUT	;THEN OUTPUT IT
	MOVEI	T1,[ASCIZ/,,/]	;GET SOME COMMAS
	PUSHJ	P,STROUT	;OUTPUT THEM
	HRRZ	T1,ACS(T5)	;GET RIGHT HALF OF THE AC
	PUSHJ	P,OCTOUT	;OUTPUT IT
	AOBJN	T5,ACTYP	;LOOP OVER ALL THE AC'S WE TYPE


ACDON:	MOVEI	T1,[ASCIZ/
/]				;GET A CRLF
	PUSHJ	P,STROUT	;OUTPUT IT
	SETZB	C,T3		;GET A NULL CHARACTER
	PUTCHR			;STORE IT
	MOVE	T1,JFNOUT	;GET OUTPUT JFN
	HRROI	T2,OUTBUF	;POINT TO THE BUFFER
	SOUT			;THEN OUTPUT THE WHOLE LINE

JSYDON:	MOVE	T1,JSFORK	;GET FORK WHICH WAS STOPPED
	UTFRK			;RESTART IT
	MOVE	P,[SAV2T1,,T1]	;GET READY
	BLT	P,P		;RESTORE ALL AC'S
	DEBRK			;AND RETURN

	SUBTTL	INTERRUPT ROUTINE FOR THE TERMINAL




;HERE ON A TERMINAL INTERRUPT.  WE REMEMBER THE STATUS OF WHAT WE ARE
;DOING, SAVE THE AC'S AND STACK, FREEZE THE FORKS, AND TURN OFF THE
;TERMINAL INTERRUPTS.  THEN WE GO BACK TO THE COMMAND SCANNER FOR
;MORE COMMANDS.  ON A "PROCEED" COMMAND, WE WILL RETURN WHERE WE
;LEFT OFF.




TTYINT:	IORI	F,FR.INT	;REMEMBER WE ARE INTERRUPTED
	MOVEM	T1,SAVET1	;SAVE AN AC
	MOVE	T1,[T2,,SAVET1+1]	;GET READY
	BLT	T1,SAVET1-T1+P	;SAVE REST OF THEM TOO
	MOVEI	T1,.FHSLF	;GET SET
	DIR			;DISABLE ANY FURTHER INTERRUPTS
	PUSHJ	P,TRAPOF	;TURN OFF TRAPPING
	MOVE	T1,INTCHR	;GET THE INTERRUPT CODE
	DTI			;CLEAR IT
	HRROI	T1,[ASCIZ/
% Interrupting

/]				;GET TEXT
	PSOUT			;PRINT IT
	JRST	NEWCMD		;THEN JUMP BACK TO COMMAND SCANNER

	SUBTTL	ROUTINES TO TURN ON AND OFF JSYS TRAPPING



;HERE ARE THE ACTUAL ROUTINES TO INSERT OR REMOVE JSYS TRAPS.
;THE FORKS ARE FROZEN WHEN WE RETURN, SINCE THAT IS A NECESSARY
;REQUIREMENT FOR THE TFORK JSYS.  IF NO FORK EXISTS, WE JUST RETURN.




TRAPON:	SKIPN	T1,HANDLE	;GET HANDLE FOR INFERIORS
	  POPJ	P,		;NONE, THEN RETURN
	FFORK			;FREEZE THEM ALL
	MOVX	T1,<.TFSET,,.FHINF>	;GET CODE FOR SETTING TRAPS
	MOVX	T2,<JSCHN,,1000>	;AND CHANNEL AND NUMBER OF BITS
	MOVEI	T3,BITS		;GET ADDRESS OF THE BITS
	TFORK			;SAY WHICH JSYSES TO TRAP
	HRLI	T1,.TFSPS	;GET CODE TO SET CHANNEL
	TFORK			;SET WHICH CHANNEL TO INTERRUPT
	POPJ	P,		;THEN RETURN




TRAPOF:	SKIPN	T1,HANDLE	;GET HANDLE
	  POPJ	P,		;IF NONE, RETURN
	FFORK			;FREEZE THE FORKS
	MOVX	T1,<.TFRES,,.FHINF>	;GET CODE TO UNDO ALL TRAPPING
	TFORK			;DO IT
	POPJ	P,		;ALL DONE

	SUBTTL	SUBROUTINE TO READ IN SYMBOL TABLE



;THIS ROUTINE IS CALLED TO PMAP THE PAGES OF THE INFERIOR FORK
;WHERE THE SYMBOL POINTER RESIDES, SO THAT WE CAN LOOK AT IT.
;ON A RETURN, SYMPTR IS EITHER ZERO, OR IS A SYMBOL POINTER.



GETSYM:	PUSHJ	P,CLRADR	;FIRST REMOVE PREVIOUS MAPPING
	HRRO	T1,SYMADR	;GET ADDRESS OF SYMBOL POINTER
	PUSHJ	P,MAPADR	;MAP THE PAGE WHERE IT IS
	  JRST	NOSYM		;CAN'T GET IT, NO SYMBOLS
	SKIPL	T1,(T1)		;GET THE SYMBOL POINTER
	  JRST	NOSYM		;IF NONNEGATIVE DON'T HAVE ONE
	HLRZ	T2,T1		;GET COUNT OF SYMBOLS
	CAIGE	T2,-SYMLEN	;TOO MANY FOR US?
	HRLI	T2,-SYMLEN	;YES, REDUCE COUNT TO MAXIMUM
	PUSHJ	P,MAPADR	;MAP THE ADDRESSES OF THE SYMBOLS
	  JRST	NOSYM		;CAN'T, FLICK IT
	MOVEM	T1,SYMPTR	;THEN SAVE THE POINTER FOR USE
	SETOM	LASADR		;CLEAR THE SAVED ADDRESS
	POPJ	P,		;AND RETURN


NOSYM:	SETZM	SYMPTR		;CLEAR THE SYMBOL POINTER
	HRROI	T1,[ASCIZ/
% No symbols available

/]				;GET TEXT
	PSOUT			;OUTPUT IT
	POPJ	P,		;AND RETURN

	SUBTTL	ROUTINE TO MAP IN PAGES OF INFERIOR FORK



;THIS ROUTINE IS CALLED WITH AN IOWD WHICH POINTS TO A LOCATION
;IN THE INFERIOR FORK.  WE MAP THE REQUIRED PAGES INTO OUR OWN
;CORE, AND DIDDLE THE IOWD SO THAT IT POINTS TO OUR OWN CORE.
;WE ALSO CHECK FOR THE GOODNESS OF THE PAGES WHICH WE HAVE MAPPED.
;SKIP RETURN IF SUCCESSFUL.



MAPADR:	MOVEM	T1,IWDSAV	;SAVE THE IOWD
	HLRE	T3,T1		;GET THE COUNT WHICH IS NEGATIVE
	MOVM	T3,T3		;MAKE POSITIVE
	HRRZS	T2,T1		;GET ADDRESS TO START FROM
	ADDI	T2,-1(T3)	;COMPUTE LAST ADDRESS
	LSH	T1,-^D9		;CONVERT FIRST ADDR TO PAGE
	LSH	T2,-^D9		;AND LAST ADDRESS TOO
	SUBI	T2,(T1)		;COMPUTE DIFFERENCE
	ADDI	T2,1		;ADD 1 TO GET NUMBER OF PAGES
	MOVEM	T2,MAPCNT	;SAVE NUMBER OF PAGES TO MAP
	HRL	T1,HANDLE	;SET UP HANDLE OF INFERIOR
	MOVE	T2,PAGADR	;GET ADDRESS OF OUR PAGES
	LSH	T2,-^D9		;CONVERT TO PAGE NUMBER
	HRLI	T2,.FHSLF	;PUT IN OUR OWN HANDLE
	HRRZ	T3,MAPCNT	;GET THE COUNT OF PAGES
	TXO	T3,PM%CNT+PM%RD	;SET FOR READ ACCESS ONLY
	PMAP			;MAP THE PAGES NECESSARY
	  ERJMP	CPOPJ		;RETURN IF ERROR
	MOVE	T1,@PAGADR	;TOUCH FIRST PAGE TO SEE IF OK
	  ERJMP	CPOPJ		;FAILURE
	MOVE	T1,IWDSAV	;RESTORE THE IOWD
	ANDCMI	T1,777000	;CLEAR PAGE NUMBER
	IOR	T1,PAGADR	;AND INSERT OUR OWN
	AOS	(P)		;SET FOR SKIP
	POPJ	P,		;RETURN

	SUBTTL	ROUTINE TO REMOVE MAPPING OF PAGES




;HERE TO UNMAP ANY PAGES WHICH WE HAD EARLIER MAPPED.



CLRADR:	SKIPN	T3,MAPCNT	;ANY PAGES THERE?
	  POPJ	P,		;NO, THEN RETURN
	SETO	T1,		;SET AC TO -1
	MOVE	T2,PAGADR	;GET ADDRESS OF PAGES
	LSH	T2,-^D9		;MAKE PAGE NUMBER
	HRLI	T2,.FHSLF	;PUT OUR HANDLE IN
	TXO	T3,PM%CNT	;ADD THE REPEAT BIT
	PMAP			;REMOVE THE PAGES
	  ERJMP	LOSE		;SHOULDN'T FAIL
	SETZM	MAPCNT		;CLEAR COUNT NOW
	POPJ	P,		;RETURN

	SUBTTL	SUBROUTINE TO LOOK FOR A SYMBOL




;THIS ROUTINE WILL SEARCH THE SYMBOL TABLE FOR THE SYMBOL NEAREST
;THE GIVEN VALUE WHICH IS SUPPLIED IN AC T1.  NON-SKIP RETURN IF
;NO SYMBOL WAS GOOD ENOUGH TO USE.  SKIP RETURN IF A SYMBOL WAS
;FOUND, WITH THE RADIX-50 IN AC T1 AND THE OFFSET FROM THAT SYMBOL
;IN AC T2.  USES AC'S T1-T4.



SYMLOK:	SKIPLE	T1		;SEE IF VALUE IS NONPOSITIVE
	SKIPL	T2,SYMPTR	;OR SEE IF HAVE NO SYMBOLS
	  POPJ	P,		;YES, JUST RETURN
	CAMN	T1,LASADR	;LOOKED FOR THIS ADDRESS LAST TIME?
	  JRST	SYMKNW		;YES, GO BE FAST
	MOVEM	T1,LASADR	;NO, SAVE NEW ADDRESS
	SETZM	LASSYM		;AND CLEAR IT'S SYMBOL
	MOVEI	T3,[-1]-1	;POINT TO A FAKE SMALL SYMBOL

SYMLLP:	SKIPLE	0(T2)		;SEE IF SYMBOL IS SUPPRESSED
	SKIPG	T4,1(T2)	;OR IF VALUE IS NON-POSITIVE
	  JRST	SYMLNX		;YES, SKIP THIS ONE
	CAMLE	T4,1(T3)	;VALUE SMALLER THAN PREVIOUS BEST ONE?
	CAMLE	T4,T1		;OR LARGER THAN OUR TARGET?
	  JRST	SYMLNX		;YES, DON'T USE IT
	HRROI	T3,(T2)		;A BETTER SYMBOL, REMEMBER IT
	CAMN	T4,T1		;HAVE AN EXACT MATCH?
	  JRST	SYMXCT		;YES, SKIP OUT OF LOOP NOW

SYMLNX:	AOBJN	T2,.+1		;BUMP POINTER PAST TWO WORDS
	AOBJN	T2,SYMLLP	;AND KEEP LOOKING
	JUMPGE	T3,CPOPJ	;RETURN IF NO SYMBOL FOUND

SYMXCT:	MOVE	T2,T1		;COPY VALUE LOOKING FOR
	SUB	T2,1(T3)	;THEN GENERATE OFFSET FROM FOUND SYMBOL
	CAIL	T2,1000		;IS OFFSET SMALL ENOUGH TO USE?
	  POPJ	P,		;NO, RETURN
	MOVEM	T2,LASOFF	;YES, SAVE IT
	MOVE	T1,0(T3)	;GET THE SYMBOL WHICH WE FOUND
	MOVEM	T1,LASSYM	;SAVE IT TOO
	AOS	(P)		;THEN SKIP
	POPJ	P,		;RETURN

SYMKNW:	SKIPE	T1,LASSYM	;GET LAST SYMBOL IF HAD ONE
	AOS	(P)		;WE DID, THEN SET FOR SUCCESS
	MOVE	T2,LASOFF	;GET OFFSET USED ALSO
	POPJ	P,		;THEN RETURN

	SUBTTL	ROUTINE TO PRINT OUT SYMBOL VALUE




;THIS ROUTINE IS CALLED TO PRINT OUT THE VALUE OF A SYMBOL BOTH IN
;OCTAL AND IN SYMBOLIC.  AC T1 CONTAINS THE ADDRESS TO BE PRINTED.
;SYMBOLS ARE USUALLY ONLY TYPED FOR THE IMMEDIATE INFERIOR, SINCE
;IN GENERAL WE HAVE NO IDEA WHAT THE OTHER FORK'S CORE IMAGES ARE LIKE.



ADRTYP:	MOVE	T4,T1		;SAVE VALUE FOR LATER
	PUSHJ	P,OCTSIX	;OUTPUT THE ADDRESS
	MOVE	T1,JSFORK	;GET FORK WE TRAPPED FOR
	TRNN	F,FR.SAM	;IF ALL FORKS ARE SAME, SKIP CHECK
	CAMN	T1,HANDLE	;NOT OUR IMMEDIATE INFERIOR?
	SKIPG	T1,T4		;OR THE VALUE IS NONNEGATIVE?
	  POPJ	P,		;YES, CAN'T TYPE ANY SYMBOL THEN
	PUSHJ	P,SYMLOK	;LOOK FOR THE SYMBOL
	  POPJ	P,		;NOT FOUND, RETURN
	MOVEI	C," "		;GET A SPACE
	PUTCHR			;OUTPUT IT
	PUTCHR			;TWICE
	MOVE	T4,T2		;SAVE THE OFFSET
	PUSHJ	P,R50OUT	;PRINT THE RADIX-50 VALUE
	JUMPE	T4,CPOPJ	;FINISH UP IF SYMBOL WAS EXACT
	MOVEI	C,"+"		;GET A PLUS SIGN
	PUTCHR			;OUTPUT IT
	MOVE	T1,T4		;GET OFFSET READY TO PRINT
	PJRST	OCTOUT		;THEN GO PRINT IT

	SUBTTL	OUTPUT ROUTINES WHICH STORE RESULTS IN CORE



;THE FOLLOWING ROUTINES ARE CALLED WITH ARGUMENTS IN AC T1, TO
;TYPE THE VALUE IN VARIOUS FORMATS.  THE OUTPUT IS DONE WITHOUT
;JSYSES IN ORDER TO SPEED UP THE JSYS TRAPPING SUBROUTINE.  THE
;FEWER JSYSES THAT ROUTINE DOES, THE BETTER.





R50OUT:	TLZ	T1,740000	;CLEAR JUNK PART
R50OUL:	IDIVI	T1,50		;GET A DIGIT SPLIT OFF
	JUMPE	T1,R50FIN	;DONE IF HAVE A ZERO
	HRLM	T2,(P)		;NO, SAVE THIS DIGIT
	PUSHJ	P,R50OUL	;AND LOOP
	HLRZ	T2,(P)		;GET BACK SAVED DIGIT
R50FIN:	MOVEI	C," "		;IF NOTHING ELSE SET FOR SPACE
	CAIN	T2,47		;CODE FOR PERCENT SIGN?
	MOVEI	C,"%"		;YES, GET IT
	CAIN	T2,46		;CODE FOR A DOLLAR SIGN?
	MOVEI	C,"$"		;YES, GET IT
	CAIN	T2,45		;CODE FOR A PERIOD?
	MOVEI	C,"."		;YES, GET IT
	CAIL	T2,13		;IN RANGE OF A LETTER?
	CAILE	T2,44		;WELL?
	SKIPA			;NO
	MOVEI	C,"A"-13(T2)	;YES, GET IT
	CAIGE	T2,13		;FINALLY, IN RANGE OF A NUMBER?
	MOVEI	C,"0"-1(T2)	;YES, GET IT
	PUTCHR			;OUTPUT THE CHAR
	POPJ	P,		;AND RETURN




STROUT:	HRLI	T1,(POINT 7,)	;MAKE A BYTE POINTER
STROUL:	ILDB	C,T1		;GET NEXT CHARACTER
	JUMPE	C,CPOPJ		;NO MORE, RETURN
	PUTCHR			;STORE THIS ONE
	JRST	STROUL		;AND LOOP OVER WHOLE STRING

OCTOUT:	SKIPA	T3,[^D8]	;SET FOR OCTAL OUTPUT
DECOUT:	MOVEI	T3,^D10		;SET FOR DECIMAL OUTPUT
NUMOUT:	IDIVI	T1,(T3)		;GET A DIGIT
	JUMPE	T1,NUMFIN	;JUMP IF GOT LAST ONE
	HRLM	T2,(P)		;MORE, SAVE THIS ONE
	PUSHJ	P,NUMOUT	;AND FIND NEXT ONE
	HLRZ	T2,(P)		;OK, GET BACK A DIGIT
NUMFIN:	MOVEI	C,"0"(T2)	;CONVERT IT TO ASCII
	PUTCHR			;OUTPUT THE CHARACTER
	POPJ	P,		;THEN RETURN



OCTSIX:	HRLOI	T2,(T1)		;MOVE TO NICE AC
OCTSIL:	SETZ	T1,		;CLEAR AC
	LSHC	T1,3		;SHIFT IN NEXT DIGIT
	MOVEI	C,"0"(T1)	;CONVERT IT TO ASCII
	PUTCHR			;OUTPUT THE CHAR
	TRNE	T2,-1		;ALL DONE?
	JRST	OCTSIL		;NO, KEEP GOING
	POPJ	P,		;YES, RETURN



OCTSP6:	MOVEI	C," "		;GET A SPACE
	CAIG	T1,77777	;LESS THAN SIX DIGITS?
	PUTCHR			;YES, OUTPUT A SPACE
	CAIG	T1,7777		;LESS THAN 5 DIGITS?
	PUTCHR			;YES, ANOTHER SPACE
	CAIG	T1,777		;LESS THAN 4 DIGITS?
	PUTCHR			;YES, ANOTHER SPACE
	CAIG	T1,77		;LESS THAN 3 DIGITS?
	PUTCHR			;YES, ANOTHER SPACE
	CAIG	T1,7		;ONLY ONE DIGIT?
	PUTCHR			;YES, A FINAL SPACE
	POPJ	P,		;RETURN

;ROUTINE TO JUSTIFY OUTPUT.  CALLED WITH DESIRED POSITION ON A LINE
;IN AC T1.  WILL SPACE OVER TO THAT COLUMN WITH SPACES.



JUSTFY:	MOVEI	C," "		;GET A SPACE
JUSTFL:	PUTCHR			;OUTPUT A SPACE
	CAMLE	T1,OUTCNT	;MOVED TO RIGHT COLUMN YET?
	JRST	JUSTFL		;NO, KEEP LOOPING
	POPJ	P,		;YES, ALL DONE



;THE OUTPUT ROUTINE.  NO CHECKING FOR OVERFLOWS OF THE OUTPUT BUFFER
;IS DONE, THE CALLER MUST KNOW THAT THE BUFFER IS TO BE OUTPUT AFTER
;EVERY LINE OF TEXT.



CHROUT:	IDPB	C,OUTPTR	;STORE THIS CHARACTER
	AOS	OUTCNT		;AND INCREMENT THE COUNTER
CPOPJ:	POPJ	P,		;RETURN

	SUBTTL	ERROR HANDLING ROUTINE



;HERE ON ANY ERROR AT ALL.  WE CLOSE UP THE FILES IF THEY WERE
;OPEN, AND RESTART THE PROGRAM.



LOSE:	HRROI	T1,[ASCIZ/
? /]				;GET PRELIMINARY TEXT
	PSOUT			;TYPE IT
	MOVEI	T1,.PRIOU	;OUTPUT TO TERMINAL
	HRLOI	T2,.FHSLF	;LAST ERROR IN THIS FORK
	SETZ	T3,		;ALL OF THE TEXT
	ERSTR			;PRINT THE ERROR
	JFCL			;FAILED
	JFCL			;FAILED


LOSFIN:	HRROI	T1,[ASCIZ/

/]				;GET FINAL STRING
	PSOUT			;TYPE IT TOO
	MOVEI	T1,.PRIIN	;GET READY
	CFIBF			;CLEAR INPUT BUFFER
	MOVE	P,[IOWD PDLSIZ,PDL]	;RESET STACK
	JRST	NEWCMD		;AND GET ANOTHER COMMAND

	SUBTTL	COMMAND JSYS SUBROUTINES



;ANY ERROR IN THESE ROUTINES RESTARTS THE PROGRAM.
;POINTER TO THE COMMAND BLOCK IS IN AC T1.



NOISE:	HRROM	T2,NOIBLK+.CMDAT	;SAVE AS DATA
	MOVEI	T2,NOIBLK	;POINT TO BLOCK
	JRST	COMMND		;AND GO DO COMND JSYS



CONFRM:	MOVEI	T2,[FLDDB. (.CMCFM)]	;GET CONFIRM FUNCTION
COMMND:	COMND			;PARSE THE FUNCTION
	  ERJMP	LOSE		;ERROR, GO COMPLAIN
	TXNE	T1,CM%NOP	;DID IT PARSE?
	  JRST	LOSE		;NO, COMPLAIN
	POPJ	P,		;YES, RETURN SUCCESSFULLY




NOIBLK:	FLDDB.	(.CMNOI)	;BLOCK FOR NOISE FUNCTION

	SUBTTL	THE TABLES FOR THE JSYSES




;THE FOLLOWING MACRO AND CONTAINS THE IMBEDDED JS MACRO, WHICH
;HAS THE FOLLOWING ARGUMENTS:
;
;	JS	NAME, NUMBER OF AC'S, CLASSES
;
;WHERE NAME IS THE MNEMONIC FOR THE JSYS, THE NUMBER OF AC'S IS
;THE NUMBER OF AC'S TO BE TYPED IN THE LOG FILE, AND CLASSES
;IS A LIST OF THOSE CLASSES TO WHICH THIS JSYS BELONGS.


	DEFINE	JSYSES,<

	JS	JSYS 0,4,<ALL>
	JS	LOGIN,3,<ALL>
	JS	CRJOB,4,<ALL>
	JS	LGOUT,1,<ALL>
	JS	CACCT,1,<ALL,SET>
	JS	EFACT,1,<ALL,FIL,SET>
	JS	SMON,2,<ALL,SET>
	JS	TMON,1,<ALL,STS>
	JS	GETAB,1,<ALL,STS>
	JS	ERSTR,3,<ALL,FIL,OUT,STS,PRI>
	JS	GETER,1,<ALL,FRK,STS>
	JS	GJINF,4,<ALL,STS>
	JS	TIME,1,<ALL,STS>
	JS	RUNTM,1,<ALL,STS>
	JS	SYSGT,2,<ALL,STS>
	JS	GNJFN,1,<ALL,FIL>
	JS	GTJFN,2,<ALL,FIL>
	JS	OPENF,2,<ALL,FIL>
	JS	CLOSF,1,<ALL,FIL>
	JS	RLJFN,1,<ALL,FIL>
	JS	GTSTS,2,<ALL,FIL,STS>
	JS	STSTS,2,<ALL,FIL,SET>
	JS	DELF,1,<ALL,FIL>
	JS	SFPTR,2,<ALL,FIL,SET>
	JS	JFNS,3,<ALL,FIL,OUT,STS>
	JS	FFFFP,1,<ALL,FIL,STS>
	JS	RDDIR,4,<ALL>
	JS	CPRTF,4,<ALL>
	JS	CLZFF,1,<ALL,FIL>
	JS	RNAMF,2,<ALL,FIL,SET>
	JS	SIZEF,3,<ALL,FIL,STS>
	JS	GACTF,2,<ALL,FIL,STS>
	JS	STDIR,4,<ALL>
	JS	DIRST,2,<ALL,FIL,OUT,STS>
	JS	BKJFN,1,<ALL,FIL,SET>
	JS	RFPTR,2,<ALL,FIL,STS>
	JS	CNDIR,4,<ALL>
	JS	RFBSZ,2,<ALL,FIL,STS>
	JS	SFBSZ,2,<ALL,FIL,SET>
	JS	SWJFN,2,<ALL,FIL,SET>
	JS	BIN,2,<ALL,FIL,INP>
	JS	BOUT,2,<ALL,FIL,OUT>
	JS	SIN,4,<ALL,FIL,INP>
	JS	SOUT,4,<ALL,FIL,OUT>
	JS	RIN,3,<ALL,FIL,INP>
	JS	ROUT,3,<ALL,FIL,OUT>
	JS	PMAP,3,<ALL,FIL,FRK,INP,OUT>
	JS	RPACS,2,<ALL,FIL,FRK,STS>
	JS	SPACS,2,<ALL,FIL,FRK,SET>
	JS	RMAP,2,<ALL,FRK,STS>
	JS	SACTF,2,<ALL,FIL,SET>
	JS	GTFDB,3,<ALL,FIL,STS>
	JS	CHFDB,3,<ALL,FIL,SET>
	JS	DUMPI,2,<ALL,FIL,INP>
	JS	DUMPO,2,<ALL,FIL,OUT>
	JS	DELDF,2,<ALL,FIL>
	JS	ASND,1,<ALL,FIL,SET>
	JS	RELD,1,<ALL,FIL,SET>
	JS	CSYNO,4,<ALL>
	JS	PBIN,1,<ALL,FIL,PRI,INP>
	JS	PBOUT,1,<ALL,FIL,PRI,OUT>
	JS	PSIN,4,<ALL>
	JS	PSOUT,1,<ALL,FIL,PRI,OUT>
	JS	MTOPR,3,<ALL,FIL,SET,STS>
	JS	CFIBF,1,<ALL,FIL,INP>
	JS	CFOBF,1,<ALL,FIL,OUT>
	JS	SIBE,2,<ALL,FIL,PRI,INP>
	JS	SOBE,2,<ALL,FIL,PRI,OUT>
	JS	DOBE,1,<ALL,FIL,OUT>
	JS	GTABS,4,<ALL>
	JS	STABS,4,<ALL>
	JS	RFMOD,2,<ALL,FIL,PRI,STS>
	JS	SFMOD,2,<ALL,FIL,PRI,SET>
	JS	RFPOS,2,<ALL,FIL,PRI,STS>
	JS	RFCOC,3,<ALL,FIL,PRI,STS>
	JS	SFCOC,3,<ALL,FIL,PRI,SET>
	JS	STI,2,<ALL,FIL,PRI,INP>
	JS	DTACH,0,<ALL,PRI,SET>
	JS	ATACH,3,<ALL,PRI,SET>
	JS	DVCHR,3,<ALL,FIL,STS>
	JS	STDEV,2,<ALL,FIL,STS>
	JS	DEVST,2,<ALL,FIL,STS>
	JS	MOUNT,4,<ALL>
	JS	DSMNT,4,<ALL>
	JS	INIDR,4,<ALL>
	JS	SIR,2,<ALL,FRK,INT,SET>
	JS	EIR,1,<ALL,FRK,INT>
	JS	SKPIR,1,<ALL,FRK,INT>
	JS	DIR,1,<ALL,FRK,INT>
	JS	AIC,2,<ALL,FRK,INT>
	JS	IIC,2,<ALL,FRK,INT>
	JS	DIC,1,<ALL,FRK,INT>
	JS	RCM,1,<ALL,FRK,INT,STS>
	JS	RWM,2,<ALL,FRK,INT,STS>
	JS	DEBRK,0,<ALL,INT>
	JS	ATI,1,<ALL,INT>
	JS	DTI,1,<ALL,INT>
	JS	CIS,0,<ALL,INT>
	JS	SIRCM,3,<ALL,FRK,INT,SET>
	JS	RIRCM,2,<ALL,FRK,INT,STS>
	JS	RIR,2,<ALL,FRK,INT,STS>
	JS	GDSTS,3,<ALL,FIL,STS>
	JS	SDSTS,2,<ALL,SET>
	JS	RESET,0,<ALL,FRK,INT,SET>
	JS	RPCAP,3,<ALL,FRK,STS>
	JS	EPCAP,3,<ALL,FRK,SET>
	JS	CFORK,2,<ALL,FRK>
	JS	KFORK,1,<ALL,FRK>
	JS	FFORK,1,<ALL,FRK,SET>
	JS	RFORK,1,<ALL,FRK,SET>
	JS	RFSTS,2,<ALL,FRK,STS>
	JS	SFORK,2,<ALL,FRK,SET>
	JS	SFACS,2,<ALL,FRK,SET>
	JS	RFACS,2,<ALL,FRK,STS>
	JS	HFORK,1,<ALL,FRK,SET>
	JS	WFORK,1,<ALL,FRK>
	JS	GFRKH,3,<ALL,FRK>
	JS	RFRKH,1,<ALL,FRK,SET>
	JS	GFRKS,3,<ALL,FRK,STS>
	JS	DISMS,1,<ALL>
	JS	HALTF,0,<ALL>
	JS	GTRPW,2,<ALL,FRK,STS>
	JS	GTRPI,3,<ALL,FRK,STS>
	JS	RTIW,3,<ALL,INT,PRI,STS>
	JS	STIW,3,<ALL,PRI,INT,SET>
	JS	SOBF,2,<ALL,FIL,PRI,OUT>
	JS	RWSET,0,<ALL,SET>
	JS	GETNM,1,<ALL,STS>
	JS	GET,2,<ALL,FIL,FRK,INP>
	JS	SFRKV,2,<ALL,FRK,SET>
	JS	SAVE,2,<ALL,FRK,FIL,OUT>
	JS	SSAVE,3,<ALL,FRK,FIL,OUT>
	JS	SEVEC,2,<ALL,FRK,SET>
	JS	GEVEC,2,<ALL,FRK,STS>
	JS	GPJFN,2,<ALL,FRK,PRI,STS>
	JS	SPJFN,2,<ALL,FRK,PRI,SET>
	JS	SETNM,1,<ALL,SET>
	JS	FFUFP,1,<ALL,FIL,STS>
	JS	DIBE,1,<ALL,FIL,INP>
	JS	FDFRE,4,<ALL>
	JS	GDSKC,2,<ALL,FIL,STS>
	JS	LITES,4,<ALL>
	JS	TLINK,2,<ALL,SET,STS,PRI,FIL>
	JS	STPAR,2,<ALL,FIL,PRI,SET>
	JS	ODTIM,3,<ALL,FIL,OUT>
	JS	IDTIM,2,<ALL,FIL,INP>
	JS	ODCNV,4,<ALL,STS>
	JS	IDCNV,4,<ALL,STS>
	JS	NOUT,3,<ALL,FIL,OUT>
	JS	NIN,3,<ALL,FIL,INP>
	JS	STAD,1,<ALL,SET>
	JS	GTAD,1,<ALL,STS>
	JS	ODTNC,5,<ALL,FIL,OUT>
	JS	IDTNC,4,<ALL,FIL,INP>
	JS	FLIN,3,<ALL,FIL,INP>
	JS	FLOUT,3,<ALL,FIL,OUT>
	JS	DFIN,4,<ALL,FIL,INP>
	JS	DFOUT,4,<ALL,FIL,OUT>
	JS	JSYS 236,4,<ALL>
	JS	JSYS 237,4,<ALL>
	JS	CRDIR,3,<ALL,FIL,SET>
	JS	GTDIR,3,<ALL,FIL,STS>
	JS	DSKOP,4,<ALL,FIL,INP,OUT>
	JS	SPRIW,2,<ALL,FRK,SET>
	JS	DSKAS,2,<ALL,FIL,SET>
	JS	SJPRI,2,<ALL,SET>
	JS	STO,2,<ALL,FIL,PRI,OUT>
	JS	JSYS 247,4,<ALL>
	JS	JSYS 250,4,<ALL>
	JS	JSYS 251,4,<ALL>
	JS	JSYS 252,4,<ALL>
	JS	JSYS 253,4,<ALL>
	JS	JSYS 254,4,<ALL>
	JS	JSYS 255,4,<ALL>
	JS	JSYS 256,4,<ALL>
	JS	JSYS 257,4,<ALL>
	JS	ASNDP,4,<ALL>
	JS	RELDP,4,<ALL>
	JS	ASNDC,4,<ALL>
	JS	RELDC,4,<ALL>
	JS	STRDP,4,<ALL>
	JS	STPDP,4,<ALL>
	JS	STSDP,4,<ALL>
	JS	RDSDP,4,<ALL>
	JS	WATDP,4,<ALL>
	JS	JSYS 271,4,<ALL>
	JS	GTNCP%,4,<ALL,STS>
	JS	GTHST%,4,<ALL,STS>
	JS	ATPTY,4,<ALL>
	JS	CVSKT,4,<ALL>
	JS	CVHST,4,<ALL>
	JS	FLHST,4,<ALL>
	JS	GCVEC,3,<ALL,FRK,STS>
	JS	SCVEC,3,<ALL,FRK,SET>
	JS	STTYP,2,<ALL,PRI,STS>
	JS	GTTYP,3,<ALL,PRI,STS>
	JS	BPT,4,<ALL>
	JS	GTDAL,3,<ALL,FIL,STS>
	JS	WAIT,0,<ALL>
	JS	HSYS,2,<ALL,SET>
	JS	USRIO,0,<ALL,SET>
	JS	PEEK,2,<ALL,STS>
	JS	MSFRK,2,<ALL,FRK,SET>
	JS	ESOUT,1,<ALL,FIL,OUT,PRI>
	JS	SPLFK,2,<ALL,FRK,SET>
	JS	ADVIS,4,<ALL>
	JS	JOBTM,4,<ALL>
	JS	DELNF,2,<ALL,FIL>
	JS	SWTCH,4,<ALL>
	JS	TFORK,3,<ALL,FRK,INT,SET,STS>
	JS	RTFRK,2,<ALL,FRK,STS>
	JS	UTFRK,1,<ALL,FRK,SET>
	JS	SCTTY,2,<ALL,PRI,SET>
	JS	JSYS 325,4,<ALL>
	JS	JSYS 326,4,<ALL>
	JS	JSYS 327,4,<ALL>
	JS	JSYS 330,4,<ALL>
	JS	JSYS 331,4,<ALL>
	JS	JSYS 332,4,<ALL>
	JS	JSYS 333,4,<ALL>
	JS	JSYS 334,4,<ALL>
	JS	JSYS 335,4,<ALL>
	JS	SETER,2,<ALL,SET,FRK>
	JS	JSYS 337,4,<ALL>
	JS	JSYS 340,4,<ALL>
	JS	JSYS 341,4,<ALL>
	JS	JSYS 342,4,<ALL>
	JS	JSYS 343,4,<ALL>
	JS	JSYS 344,4,<ALL>
	JS	JSYS 345,4,<ALL>
	JS	JSYS 346,4,<ALL>
	JS	JSYS 347,4,<ALL>
	JS	JSYS 350,4,<ALL>
	JS	JSYS 351,4,<ALL>
	JS	JSYS 352,4,<ALL>
	JS	JSYS 353,4,<ALL>
	JS	JSYS 354,4,<ALL>
	JS	JSYS 355,4,<ALL>
	JS	JSYS 356,4,<ALL>
	JS	JSYS 357,4,<ALL>
	JS	JSYS 360,4,<ALL>
	JS	JSYS 361,4,<ALL>
	JS	JSYS 362,4,<ALL>
	JS	JSYS 363,4,<ALL>
	JS	JSYS 364,4,<ALL>
	JS	JSYS 365,4,<ALL>
	JS	JSYS 366,4,<ALL>
	JS	JSYS 367,4,<ALL>
	JS	JSYS 370,4,<ALL>
	JS	JSYS 371,4,<ALL>
	JS	JSYS 372,4,<ALL>
	JS	JSYS 373,4,<ALL>
	JS	JSYS 374,4,<ALL>
	JS	JSYS 375,4,<ALL>
	JS	JSYS 376,4,<ALL>
	JS	JSYS 377,4,<ALL>
	JS	JSYS 400,4,<ALL>
	JS	JSYS 401,4,<ALL>
	JS	JSYS 402,4,<ALL>
	JS	JSYS 403,4,<ALL>
	JS	JSYS 404,4,<ALL>
	JS	JSYS 405,4,<ALL>
	JS	JSYS 406,4,<ALL>
	JS	JSYS 407,4,<ALL>
	JS	JSYS 410,4,<ALL>
	JS	JSYS 411,4,<ALL>
	JS	JSYS 412,4,<ALL>
	JS	JSYS 413,4,<ALL>
	JS	JSYS 414,4,<ALL>
	JS	JSYS 415,4,<ALL>
	JS	JSYS 416,4,<ALL>
	JS	JSYS 417,4,<ALL>
	JS	JSYS 420,4,<ALL>
	JS	JSYS 421,4,<ALL>
	JS	JSYS 422,4,<ALL>
	JS	JSYS 423,4,<ALL>
	JS	JSYS 424,4,<ALL>
	JS	JSYS 425,4,<ALL>
	JS	JSYS 426,4,<ALL>
	JS	JSYS 427,4,<ALL>
	JS	JSYS 430,4,<ALL>
	JS	JSYS 431,4,<ALL>
	JS	JSYS 432,4,<ALL>
	JS	JSYS 433,4,<ALL>
	JS	JSYS 434,4,<ALL>
	JS	JSYS 435,4,<ALL>
	JS	JSYS 436,4,<ALL>
	JS	JSYS 437,4,<ALL>
	JS	JSYS 440,4,<ALL>
	JS	JSYS 441,4,<ALL>
	JS	JSYS 442,4,<ALL>
	JS	JSYS 443,4,<ALL>
	JS	JSYS 444,4,<ALL>
	JS	JSYS 445,4,<ALL>
	JS	JSYS 446,4,<ALL>
	JS	JSYS 447,4,<ALL>
	JS	JSYS 450,4,<ALL>
	JS	JSYS 451,4,<ALL>
	JS	JSYS 452,4,<ALL>
	JS	JSYS 453,4,<ALL>
	JS	JSYS 454,4,<ALL>
	JS	JSYS 455,4,<ALL>
	JS	JSYS 456,4,<ALL>
	JS	JSYS 457,4,<ALL>
	JS	JSYS 460,4,<ALL>
	JS	JSYS 461,4,<ALL>
	JS	JSYS 462,4,<ALL>
	JS	JSYS 463,4,<ALL>
	JS	JSYS 464,4,<ALL>
	JS	JSYS 465,4,<ALL>
	JS	JSYS 466,4,<ALL>
	JS	JSYS 467,4,<ALL>
	JS	JSYS 470,4,<ALL>
	JS	JSYS 471,4,<ALL>
	JS	JSYS 472,4,<ALL>
	JS	JSYS 473,4,<ALL>
	JS	JSYS 474,4,<ALL>
	JS	JSYS 475,4,<ALL>
	JS	JSYS 476,4,<ALL>
	JS	JSYS 477,4,<ALL>
	JS	RSCAN,1,<ALL,FIL,PRI,INP,STS>
	JS	HPTIM,1,<ALL,STS>
	JS	CRLNM,3,<ALL,FIL,SET>
	JS	INLNM,2,<ALL,FIL,STS>
	JS	LNMST,3,<ALL,FIL,STS>
	JS	RDTXT,4,<ALL,FIL,PRI,INP>
	JS	SETSN,2,<ALL,SET>
	JS	GETJI,3,<ALL,STS>
	JS	MSEND,2,<ALL,IPC,OUT>
	JS	MRECV,2,<ALL,IPC,INP>
	JS	MUTIL,2,<ALL,IPC,SET,STS>
	JS	ENQ,2,<ALL,FIL>
	JS	DEQ,2,<ALL,FIL>
	JS	ENQC,3,<ALL,FIL,SET,STS>
	JS	SNOOP,4,<ALL,SET,STS>
	JS	SPOOL,2,<ALL,FIL,SET>
	JS	ALLOC,3,<ALL,FIL,SET>
	JS	CHKAC,2,<ALL,FIL,STS>
	JS	TIMER,3,<ALL,SET,FRK>
	JS	RDTTY,3,<ALL,FIL,PRI,INP>
	JS	TEXTI,1,<ALL,FIL,PRI,INP>
	JS	UFPGS,2,<ALL,FIL,SET,OUT>
	JS	SFPOS,2,<ALL,FIL,PRI,SET>
	JS	SYERR,2,<ALL,FIL,SET>
	JS	DIAG,1,<ALL,FIL,SET>
	JS	SINR,4,<ALL,FIL,INP>
	JS	SOUTR,4,<ALL,FIL,OUT>
	JS	RFTAD,3,<ALL,FIL,STS>
	JS	SFTAD,3,<ALL,FIL,SET>
	JS	TBDEL,2,<ALL>
	JS	TBADD,2,<ALL>
	JS	TBLUK,3,<ALL>
	JS	STCMP,2,<ALL,STS>
	JS	SETJB,3,<ALL,SET>
	JS	GDVEC,2,<ALL,FRK,STS>
	JS	SDVEC,2,<ALL,FRK,SET>
	JS	COMND,3,<ALL,FIL,PRI,INP>
	JS	PRARG,3,<ALL,FRK,SET,STS>
	JS	GACCT,2,<ALL,STS>
	JS	LPINI,3,<ALL,FIL,SET>
	JS	GFUST,2,<ALL,FIL,STS>
	JS	SFUST,2,<ALL,FIL,SET>
	JS	ACCES,2,<ALL,SET>
	JS	RCDIR,3,<ALL,FIL,STS>
	JS	RCUSR,3,<ALL,FIL,STS>
	JS	MSTR,2,<ALL,FIL,SET,STS>
	JS	STPPN,2,<ALL,FIL,STS>
	JS	PPNST,3,<ALL,FIL,OUT,STS>
	JS	PMCTL,3,<ALL,SET,STS>
	JS	LOCK,4,<ALL>
	JS	BOOT,2,<ALL,SET,INP,OUT>
	JS	UTEST,2,<ALL,STS>
	JS	USAGE,2,<ALL,OUT>
	JS	WILD%,3,<ALL,FIL>
	JS	VACCT,2,<ALL,STS>
	JS	NODE,2,<ALL,SET,STS>
	JS	ADBRK,3,<ALL,SET,STS,FRK>
	JS	JSYS 571,4,<ALL>
	JS	JSYS 572,4,<ALL>
	JS	SWTRP%,3,<ALL,SET,STS>
	JS	GETOK,4,<ALL,SET,STS>
	JS	RCVOK%,2,<ALL,SET>
	JS	GIVOK%,3,<ALL,SET>
	JS	SKED%,4,<ALL,SET,STS>
	JS	MTU%,3,<ALL,SET,STS,FIL>
	JS	XRIR%,2,<ALL,FRK,STS,INT>
	JS	XSIR%,3,<ALL,SET,FRK,INT>
	JS	PDVOP%,3,<ALL,FRK,SET,STS>
	JS	NTMAN%,1,<ALL,SET,STS>
	JS	XSFRK%,3,<ALL,FRK>
	JS	JSYS 606,4,<ALL>
	JS	XSVEC%,3,<ALL,SET,FRK>
	JS	RSMAP%,2,<ALL,STS,FRK,FIL>
	JS	XRMAP%,1,<ALL,FRK,SET,STS>
	JS	JSYS 612,4,<ALL>
	JS	JSYS 613,4,<ALL>
	JS	JSYS 614,4,<ALL>
	JS	JSYS 615,4,<ALL>
	JS	JSYS 616,4,<ALL>
	JS	JSYS 617,4,<ALL>
	JS	JSYS 620,4,<ALL>
	JS	JSYS 621,4,<ALL>
	JS	JSYS 622,4,<ALL>
	JS	JSYS 623,4,<ALL>
	JS	JSYS 624,4,<ALL>
	JS	JSYS 625,4,<ALL>
	JS	JSYS 626,4,<ALL>
	JS	JSYS 627,4,<ALL>
	JS	JSYS 630,4,<ALL>
	JS	JSYS 631,4,<ALL>
	JS	JSYS 632,4,<ALL>
	JS	JSYS 633,4,<ALL>
	JS	JSYS 634,4,<ALL>
	JS	JSYS 635,4,<ALL>
	JS	JSYS 636,4,<ALL>
	JS	JSYS 637,4,<ALL>
	JS	JSYS 640,4,<ALL>
	JS	JSYS 641,4,<ALL>
	JS	JSYS 642,4,<ALL>
	JS	JSYS 643,4,<ALL>
	JS	JSYS 644,4,<ALL>
	JS	JSYS 645,4,<ALL>
	JS	JSYS 646,4,<ALL>
	JS	JSYS 647,4,<ALL>
	JS	JSYS 650,4,<ALL>
	JS	JSYS 651,4,<ALL>
	JS	JSYS 652,4,<ALL>
	JS	JSYS 653,4,<ALL>
	JS	JSYS 654,4,<ALL>
	JS	JSYS 655,4,<ALL>
	JS	JSYS 656,4,<ALL>
	JS	JSYS 657,4,<ALL>
	JS	JSYS 660,4,<ALL>
	JS	JSYS 661,4,<ALL>
	JS	JSYS 662,4,<ALL>
	JS	JSYS 663,4,<ALL>
	JS	JSYS 664,4,<ALL>
	JS	JSYS 665,4,<ALL>
	JS	JSYS 666,4,<ALL>
	JS	JSYS 667,4,<ALL>
	JS	JSYS 670,4,<ALL>
	JS	JSYS 671,4,<ALL>
	JS	JSYS 672,4,<ALL>
	JS	JSYS 673,4,<ALL>
	JS	JSYS 674,4,<ALL>
	JS	JSYS 675,4,<ALL>
	JS	JSYS 676,4,<ALL>
	JS	JSYS 677,4,<ALL>
	JS	JSYS 700,4,<ALL>
	JS	JSYS 701,4,<ALL>
	JS	JSYS 702,4,<ALL>
	JS	JSYS 703,4,<ALL>
	JS	JSYS 704,4,<ALL>
	JS	JSYS 705,4,<ALL>
	JS	JSYS 706,4,<ALL>
	JS	JSYS 707,4,<ALL>
	JS	JSYS 710,4,<ALL>
	JS	JSYS 711,4,<ALL>
	JS	JSYS 712,4,<ALL>
	JS	JSYS 713,4,<ALL>
	JS	JSYS 714,4,<ALL>
	JS	JSYS 715,4,<ALL>
	JS	JSYS 716,4,<ALL>
	JS	JSYS 717,4,<ALL>
	JS	JSYS 720,4,<ALL>
	JS	JSYS 721,4,<ALL>
	JS	JSYS 722,4,<ALL>
	JS	JSYS 723,4,<ALL>
	JS	JSYS 724,4,<ALL>
	JS	JSYS 725,4,<ALL>
	JS	JSYS 726,4,<ALL>
	JS	JSYS 727,4,<ALL>
	JS	JSYS 730,4,<ALL>
	JS	JSYS 731,4,<ALL>
	JS	JSYS 732,4,<ALL>
	JS	JSYS 733,4,<ALL>
	JS	JSYS 734,4,<ALL>
	JS	JSYS 735,4,<ALL>
	JS	JSYS 736,4,<ALL>
	JS	JSYS 737,4,<ALL>
	JS	JSYS 740,4,<ALL>
	JS	JSYS 741,4,<ALL>
	JS	JSYS 742,4,<ALL>
	JS	JSYS 743,4,<ALL>
	JS	JSYS 744,4,<ALL>
	JS	JSYS 745,4,<ALL>
	JS	JSYS 746,4,<ALL>
	JS	JSYS 747,4,<ALL>
	JS	SNDIM,2,<ALL,SET>
	JS	RCVIM,2,<ALL,STS>
	JS	ASNSQ,2,<ALL,SET>
	JS	RELSQ,1,<ALL,SET>
	JS	JSYS 754,4,<ALL>
	JS	JSYS 755,4,<ALL>
	JS	JSYS 756,4,<ALL>
	JS	JSYS 757,4,<ALL>
	JS	JSYS 760,4,<ALL>
	JS	JSYS 761,4,<ALL>
	JS	JSYS 762,4,<ALL>
	JS	JSYS 763,4,<ALL>
	JS	JSYS 764,4,<ALL>
	JS	JSYS 765,4,<ALL>
	JS	METER%,3,<ALL,STS>
	JS	SMAP%,3,<ALL,SET>
	JS	THIBR,1,<ALL>
	JS	TWAKE,1,<ALL,SET>
	JS	MRPAC,4,<ALL>
	JS	SETPV,4,<ALL>
	JS	MTALN,2,<ALL,FIL,SET>
	JS	TTMSG,2,<ALL,PRI,FIL>
	JS	JSYS 776,4,<ALL>
	JS	MDDT%,0,<ALL>
>

;NOW GENERATE THE BIT TABLES FOR EACH TYPE OF JSYS.  THESE MASKS
;ARE USED FOR THE SETTING OF WHICH JSYSES TO TRAP FOR.


	DEFINE	BITGEN(TYP),<	;;MACRO TO MAKE BIT TABLE
IRP TYP,<
	..WRD==0		;;START WORD AT ZERO
	..BIT==1B0		;;AND START BIT AT SIGN BIT
	..VAL==JS.'TYP		;;DEFINE VALUE OF BIT
BT.'TYP:	JSYSES		;;GENERATE THE TABLE
	IFG ..BIT,<
	EXP	..WRD		;LAST BITS FOR TABLE BT.'TYP
>				;;DUMP OUT LAST WORD IF NECESSARY
>
>


	DEFINE	JS(NAME,ACS,CODE,ROUTINE),<
IRP CODE,<
	IFN <..VAL&JS.'CODE>,<..WRD==..WRD!..BIT>	;;ADD BIT IF NEEDED
>
	..BIT==..BIT_-1		;;SHIFT OVER TO NEW BIT
IFE ..BIT,<
	EXP	..WRD		;BITS UP TO "NAME"
	..WRD==0		;;RESET WORD TO ZERO
	..BIT==1B0		;;AND RESET BIT TO FRONT OF WORD
>
>


	XALL			;LET THE DATA SHOW



BITGEN	<PRI,FRK,FIL,INT,SET,STS,IPC,INP,OUT,ALL>	;PRODUCE THE TABLES

;NOW TO EXPAND THE JSYS TABLE.




	DEFINE	JS(NAME,NUMBER<4>,CLASS<>,ROUTINE<>),<
	XWD	-NUMBER,[ASCIZ/NAME/]
>


JSTAB:	JSYSES			;DUMP THE JSYS NAMES

	SUBTTL	THE DATA AREA



CMDBLK:	CM%RAI+NEWPAR		;ADDRESS OF REPARSE ROUTINE
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	-1,,[ASCIZ/JSTRAP>/]	;CONTROL-R POINTER
	-1,,TXTBUF		;POINTER TO TEXT BUFFER
	-1,,TXTBUF		;POINTER TO CURRENT POSITION
	TXTLEN			;NUMBER OF CHARS IN BUFFER
	0			;NUMBER OF UNPARSED CHARACTERS
	-1,,ATMBUF		;POINTER TO ATOM BUFFER
	TXTLEN			;NUMBER OF CHARACTERS IN BUFFER
	EXP	JFNBLK		;POINTER TO GTJFN BLOCK

JFNBLK:	GJ%OLD			;FLAGS,,GENERATION NUMBER
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT JFNS
	BLOCK	20		;NO DEFAULTS




LEVTAB:	EXP	CHN1PC		;LOCATION TO STORE PC
	EXP	CHN2PC		;SAME FOR LEVEL 2
	BLOCK	1		;LEVEL 3 IS UNUSED

CHNTAB:	XWD	2,TTYINT	;LEVEL 2, INTERRUPT ROUTINE
	XWD	1,JSYINT	;LEVEL 1, INTERRUPT ROUTINE
	BLOCK	^D34		;OTHER CHANNELS UNUSED

	XLIST			;DUMP THE LITERALS
	LIT
	LIST



CHN1PC:	BLOCK	1		;PC FOR INTERRUPT ON LEVEL 1
CHN2PC:	BLOCK	1		;PC FOR INTERRUPT ON LEVEL 2
BITS:	BLOCK	BITSIZ		;BIT STORAGE FOR WHICH JSYSES TO TRAP
PDL:	BLOCK	PDLSIZ		;STACK ROOM
ACS:	BLOCK	^D16		;THE INFERIOR FORK'S AC'S
HANDLE:	BLOCK	1		;THE HANDLE OF THE INFERIOR
INTCHR:	BLOCK	1		;THE CHARACTER CODE WE ARE TRAPPING FOR
JSPC:	BLOCK	1		;THE PC OF A STOPPED FORK
JSJSYS:	BLOCK	1		;THE JSYS A FORK EXECUTED
JSFORK:	BLOCK	1		;THEN FORK NUMBER WHICH DID A JSYS
SAVET1:	BLOCK	^D16		;STORAGE FOR AC'S IN AN INTERRUPT
SAV2T1:	BLOCK	^D16		;ANOTHER SET OF AC'S FOR OTHER INTERRUPT
REPMAX:	BLOCK	1		;MAXIMUM NUMBER JSYS REPETITIONS
REPCNT:	BLOCK	1		;NUMBER OF REPETITIONS SO FAR
JFN:	BLOCK	1		;JFN OF FILE WE ARE READING
JFNOUT:	BLOCK	1		;OUTPUT JFN
OUTPTR:	BLOCK	1		;BYTE POINTER INTO OUTPUT BUFFER
OUTCNT:	BLOCK	1		;COUNTER OF POSITION ON A LINE
OUTBUF:	BLOCK	^D50		;BUFFER FOR OUTPUT
IWDSAV:	BLOCK	1		;TEMPORARY LOCATION
SAVEP:	BLOCK	1		;STOREAGE OF STACK
TXTBUF:	BLOCK	TXTLEN/5+1	;BUFFER FOR COMMAND JSYS
ATMBUF:	BLOCK	TXTLEN/5+1	;BUFFER FOR ATOM BUFFER
SYMPTR:	BLOCK	1		;SYMBOL POINTER
LASADR:	BLOCK	1		;THE LAST ADDRESS WE SEARCHED FOR
LASSYM:	BLOCK	1		;THE SYMBOL FOR THE LAST ADDRESS
LASOFF:	BLOCK	1		;THE OFFSET FROM THE SYMBOL
SYMADR:	BLOCK	1		;ADDRESS OF SYMBOL TABLE POINTER
PAGADR:	BLOCK	1		;ADDRESS OF PMAP AREA
MAPCNT:	BLOCK	1		;NUMBER OF PAGES WE HAVE MAPPED
CORE:	BLOCK	SYMLEN+777	;RESERVE LOTS OF ROOM



	END	3,,START
