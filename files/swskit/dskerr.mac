	TITLE	DSKERR	PRODUCE COMPACT LISTING OF DISK ERRORS
	SUBTTL	J. G. ZIMA/JGZ JANUARY 1979

	SEARCH	MACSYM,MONSYM	;GET SYMBOLS
	SEARCH	SERCOD		;GET SYSERR SYMBOLS
	SEARCH	ZSUBS		;GET SUBROUTINE PACKAGE STUFF
	SALL			;NICE LOOKING MACROS
	.DIRECT	FLBLST		;AND NICE LISTING


;VERSION INFORMATION:


	VMAJOR==1		;MAJOR VERSION LEVEL
	VMINOR==0		;MINOR VERSION LEVEL
	VEDIT==43		;EDIT LEVEL
	VWHO==0			;WHO LAST EDITED


;DSKERR IS A PRODUCT OF THE MONITOR SUPPORT GROUP OF SOFTWARE SERVICES,
;PRIMARILY FOR INCLUSION ON THE TOPS-20 MONITOR SWSKIT.  THE PURPOSE
;OF THE PROGRAM IS TO PROVIDE A "CONCISE" LISTING OF SYSTEM DISK ERRORS,
;IN LIEU OF SYSERR.
;
;RELATED FILES:
;	DSKERR.MAC	THIS FILE
;	ZSUBS.UNV	COMND/LUUO PACKAGE UNIVERSAL
;	ZSUBS.REL	COMND/LUUO PACKAGE CODE
;	SERCOD.UNV	SYSERR SYMBOLS UNIVERSAL



;	TABLE OF CONTENTS FOR DSKERR				  PAGE
;	----------------------------				  ----
;
;  1. J. G. ZIMA/JGZ JANUARY 1979. . . . . . . . . . . . . . . . .   1
;  2. COMMAND SCANNER AND INITIALIZATION . . . . . . . . . . . . .   6
;  3. THE SIMPLE COMMANDS. . . . . . . . . . . . . . . . . . . . .   8
;  4. PARAMETER SETTING AND SHOWING COMMANDS . . . . . . . . . . .   9
;  5. THE MAIN PROCESSING LOOP . . . . . . . . . . . . . . . . . .  16
;  6. ENTRY INPUT AND VALIDATION ROUTINES. . . . . . . . . . . . .  18
;  7. OUTPUT CONVERSION ROUTINES . . . . . . . . . . . . . . . . .  22
;  8. PAGE HEADER PRINTING ROUTINE . . . . . . . . . . . . . . . .  26
;  9. SUMMARY PRINTING ROUTINE . . . . . . . . . . . . . . . . . .  27
; 10. THE DATA AREA. . . . . . . . . . . . . . . . . . . . . . . .  28



;REVISION HISTORY:
;
;   21	JGZ	8-FEB-79
;		BETTER FILE HANDLING ON EOF OR ERROR MARKER ENTRIES.
;
;   22	JGZ	9-FEB-79
;		ADD DRIVE COMMAND TO SELECT ENTRIES FROM A CERTAIN
;		DRIVE SERIAL NUMBER.
;
;   23	JGZ	15-FEB-79
;		CHANGE FLAG NAMING CONVENTION.
;
;   24	JGZ	20-FEB-79
;		ADD QUOTED STRING FUNCTION TO VOLUME COMMAND TO ALLOW
;		THINGS LIKE SPECIFYING BLANK VOLUME ID.
;
;   25	JGZ	22-FEB-79
;		ADD CONTROL-E INTERRUPT FEATURE TO ALLOW ABORTING THE
;		LIST COMMAND IN THE MIDDLE AND GET BACK TO COMMAND LEVEL.
;
;   26	JGZ	22-FEB-79
;		MAKE ALL SETTINGS BUT INPUT FILE SPECIFIED PRESERVED
;		ACROSS ERRORS.  FORMERLY, ALL FLAGS CLEARED.
;
;   27	JGZ	24-FEB-79
;		MAKE INPUT FILE SPECIFIED PRESERVED ALSO.
;
;   30	JGZ	9-MAR-79
;		ADD PUSH COMMAND.
;
;   31	JGZ	10-MAR-79
;		ADD TAKE COMMAND.
;
;   32	JGZ	29-JUN-79
;		WARN, RESYNCH, AND CONTINUE ON LOSS OF SYNCHRONIZATION.
;
;   33	JGZ	27-JAN-80
;		ADD RP20 TO TABLES, RANGE CHECK DEVICE TYPE.
;
;   34	JGZ	8-MAY-80
;		ADD A SINGLE LEVEL "JFN STACK" TO KEEP UNUSED JFNS
;		FROM PILING UP ON REPARSES.
;
;   35	JGZ	26-FEB-80
;		CORRECT RP07 VALUES FOR NEW RP07.
;
;   36	JGZ	23-JUN-81
;		ERROR.SYS MOVES TO <SYSTEM-ERROR> FOR RELEASE 5.
;

;   37	JGZ	26-JUL-81
;		CHANGE HDRVER DEFSTR.  RELEASE 5 REDEFINES IT.
;
;   40	JGZ	28-JUL-81
;		BEGIN CONVERSION TO USE THE ZSUBS PACKAGE.
;
;   41	JGZ	25-NOV-81
;		LBN TYPEOUT SHOULD BE OCTAL.  MAKE IT SO.
;
;   42	JGZ	25-NOV-81
;		USE WARN AND ERROR UUOS WHERE APPROPRIATE.
;
;  43	JGZ	28-JAN-82
;		USE NEW ZSUBS MACRO TYPJFN TO OUTPUT FILESPECS.
;



;DEFAULT PARAMETERS:


	TXTLEN==^D100		;SIZE OF COMMAND BUFFERS
	PDLSIZ==30		;SIZE OF PUSHDOWN STACK
	PAGSIZ==^D55		;NUMBER OF LINES/PAGE
	VTBSIZ==20		;NUMBER OF VOLUMES IN SUMMARY MAX



;CONSTANTS:


	IS.ERR==1B2		;BIT IN IORB INDICATING HARD ERROR

	HF.ERR==377		;ENTRY TYPE INDICATING ERROR IN FILE
	HF.EOF==777		;ENTRY TYPE INDICATING END-OF-FILE
	HF.T20==1B17		;ENTRY HEADER BIT FOR TOPS-20
	HF.VER==1		;SYSERR VERSION WE KNOW ABOUT
	HDRDAT==1		;OFFSET TO DATE-TIME WORD
	SEROFF==MB%REG+10	;OFFSET TO SERIAL #

	SIZSUM==4		;SIZE OF A SUMTAB ENTRY
		VSUM==0			;OFFSET OF VOLUME ID IN SUMTAB ENTRY
		HSUM==1			;OFFSET OF HARD ERRORS IN SUMTAB ENTRY
		SSUM==2			;OFFSET OF SOFT ERRORS IN SUMTAB ENTRY
		USUM==3			;OFFSET OF UNIT TYPE IN SUMTAB ENTRY

	INTCHN==0		;CHANNEL FOR ^E INTERRUPT


;FLAGS:


	FL%TIM==1B0		;CHECK ENTRIES FOR TIME RANGE
	FL%VOL==1B1		;CHECK ENTRIES TO MATCH VOLUME ID
	FL%SSE==1B2		;SUPPRESS SOFT ERRORS
	FL%SHE==1B3		;SUPPRESS HARD ERRORS
	FL%IFS==1B4		;INPUT FILE SPECIFIED
	FL%SUM==1B5		;SUMMARY OUTPUT ONLY
	FL%TMV==1B6		;TOO MANY VOLUMES FOR SUMTAB
	FL%FDO==1B7		;FORCE DATE OUTPUT AT START OF PAGE
	FL%OFO==1B8		;OUTPUT FILE IS OPEN
	FL%SER==1B9		;CHECK ENTRIES TO MATCH DRIVE SERIAL NUMBER


;MACROS, OPDEFS, AND DEFSTRS:



	DEFSTR	F%SER,T2,35,16		;SERIAL NUMBER
	DEFSTR	F%TYP,T2,35,5		;UNIT TYPE
	DEFSTR	HDRLEN,HDRWRD,26,3	;HEADER LENGTH FIELD
	DEFSTR	ENTLEN,HDRWRD,35,9	;ENTRY LENGTH FIELD
	DEFSTR	HDRCOD,HDRWRD,8,9	;ENTRY TYPE CODE
	DEFSTR	HDRVER,HDRWRD,23,3	;VERSION LEVEL

	SUBTTL	COMMAND SCANNER AND INITIALIZATION




EVEC:	JRST	DSKERR		;START
	JRST	REEN		;REENTER
	BYTE	(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT	;VERSION




DSKERR:	RESET			;CLEAR EVERYTHING
	$INIT			;INITIALIZE ZSUBS THINGS
	TYPE	<DSKERR Disk Error Lister %>
	VERSIO	EVEC+2		;OUTPUT THE VERSION NUMBER
	TYPE	<

>				;AND SPACE DOWN
REEN:	TXZ	F,FL%TMV!FL%FDO!FL%OFO	;INITIALIZE FLAGS
	MOVE	P,[IOWD	PDLSIZ,PDL] ;RESET STACK


NEWCMD:	HRROI	T1,[ASCIZ/DSKERR>/] ;PROMPT
	MOVEM	T1,CMDBLK+.CMRTY ;SET IT UP
	MOVEI	T1,NEWPAR	;SETUP REPARSE ADDRESS
	HRRM	T1,CMDBLK+.CMFLG ;IN THE COMND BLOCK
	PARSE	[FLDDB. .CMINI]	;INITIALIZATION FUNCTION
	MOVEM	P,SAVEP		;SAVE STACK FOR REPARSING
	JRST	NEWPAR		;AND PARSE A NEW COMMAND

PARERR:	JRST	REEN		;REENTER ON LOSE-TYPE ERROR
NEWPAR:	MOVE	P,SAVEP		;RESTORE THE STACK
	SKIPE	T1,JFNTMP	;GET RID OF ANY ACCUMULATED
	RLJFN			; JFNS FROM REPARSE,...
	 ERJMP	.+1
	SETZM	JFNTMP		;MARK NOT IN USE
	PARSE	[FLDDB. (.CMKEY,,CMDTAB)] ;PARSE A KEYWORD
	MOVE	T2,(T2)		;GET ADDRESS OF ROUTINE
	CALL	(T2)		;CALL IT
	JRST	NEWCMD		;AND GET A NEW COMMAND




;TABLE OF COMMANDS:


CMDTAB:	CMDLEN,,CMDLEN			;HEADER
	AA	DRIVE,.DRIVE		;SET DRIVE ID TO MATCH
	AA	EXIT,.EXIT		;EXIT COMMAND
	AA	HELP,.HELP		;TYPE HELP MESSAGE
	AA	LIST,.LIST		;SET UP OUTPUT SPEC
	AA	PUSH,.PUSH		;PUSH TO A NEW EXEC
	AA	READ,.READ		;SET UP INPUT SPEC
	AA	SUPPRESS,.SUPPRESS	;SET SUPRESS FLAGS
	AA	TAKE,.TAKE		;TAKE COMMANDS FROM FILE
	AA	TIME,.TIME		;SET BEGIN AND END TIMES
	AA	VOLUME,.VOLUME		;SET VOLUME ID TO MATCH
	AA	WHAT,.WHAT		;TELL SETTINGS

	CMDLEN==.-CMDTAB-1		;NUMBER OF COMMANDS
	SUBTTL	THE SIMPLE COMMANDS



;THE "HELP" COMMAND.


.HELP:	CONFRM			;CONFIRM THE LINE
	TYPE.	HLPTXT		;TYPE IT
	RET			;AND DONE

HLPTXT:	ASCIZ\


     DSKERR is a program designed to produce a compact listing of  the
hard  and soft disk errors recorded for the system in the SYSERR file.
The listing contains the time an error occurred, the structure it  was
on, the serial number of the drive in use, the logical block number of
the error on the unit, the cylinder, surface and sector of the  error,
the  number  of  retries,  and  whether  it was a hard (unrecoverable)
error.  A by-volume summary gives the structure name, unit  type,  and
accumulated hard and soft error totals.

     The commands are:

	DRIVE		Specify specific drive serial number to list
				or ALL for all drives
        EXIT            Exit from the program
        HELP            Type this text
        LIST            Specify output file and begin processing
				May be aborted with Control-E
	PUSH		Push command level to a new EXEC
        READ            Specify alternate input ERROR.SYS format file
        SUPPRESS        Suppress listing of hard errors, or soft
                                errors, or detailed by error listing
                                section, or nothing
	TAKE		Take commands from specified file
        TIME            Set begin and end times for searching input
        VOLUME          Specify specific single structure to list or
                                * to do all structures
        WHAT            Tell current parameter settings
\

	SUBTTL	PARAMETER SETTING AND SHOWING COMMANDS

;VOLUME COMMAND TO SET VOLUME ID TO MATCH


.VOLUM:	NOISE	(ID TO LIST ERRORS FOR)
	PARSE	[FLDDB. (.CMQST,CM%SDH,,<Optionally quoted Volume ID or * for all>,<*>,[
		FLDDB. (.CMTXT,CM%SDH)])] ;READ IT
	MOVE	T1,[POINT 6,T4]	;POINTER TO OUTPUT
	MOVE	T2,[POINT 7,ATMBUF]	;POINTER TO INPUT
	MOVEI	P1,6		;COUNTER
	SETZ	T4,		;START CLEAR
SIXL:	ILDB	T3,T2		;GET NEXT BYTE
	CAIL	T3,"A"+40	;ASSURE CASE CONVERSION
	CAILE	T3,"Z"+40	;FIRST
	SKIPA
	SUBI	T3,40		;TO UPPER CASE
	CAIL	T3," "		;CHECK SIXBIT RANGE
	CAILE	T3," "+100	;ALL ALLOWED
	JRST	SIXFIN		;NO GOOD--MUST BE DONE
	SUBI	T3," "		;MAKE SIXBIT
	IDPB	T3,T1		;STORE
	SOJG	P1,SIXL		;ONLY TAKE SIX
SIXFIN:	TXO	F,FL%VOL	;REMEMBER
	MOVEM	T4,VOLIDM	;STORE NAME
	CAMN	T4,[SIXBIT/*/]	;CLEARING?
	TXZ	F,FL%VOL	;YES
	CONFRM			;CONFIRM THE LINE
	RET			;AND RETURN


;SUPPRESS COMMAND TO SET ERROR TYPE TO SUPPRESS


.SUPPR:	PARSE	[FLDDB. (.CMKEY,,HRDTAB,,<NOTHING>)] ;KEYWORD INPUT
	HRRZ	T4,(T2)		;VALUE
	CONFRM			;CONFIRM THE LINE
	XCT [	TXZ	F,FL%SSE+FL%SHE+FL%SUM ;SUPPRESS NOTHING
		TXO	F,FL%SHE	;HARD
		TXO	F,FL%SSE	;SOFT
		TXO	F,FL%SUM](T4)	;MAIN LISTING
	RET		;AND RETURN


HRDTAB:	HRDLEN,,HRDLEN		;ERROR SUPPRESSION TABLE
	AA	DETAIL-LISTING,3;DETAILED LISTING SECTION
	AA	HARD-ERRORS,1	;HARD ERRORS
	AA	NOTHING,0	;NO ERRORS (DEFAULT)
	AA	SOFT-ERRORS,2	;SOFT ERRORS

	HRDLEN==.-HRDTAB-1


;WHAT COMMAND TO TELL SWITCH SETTINGS


.WHAT:	NOISE	(ARE PARAMETER SETTINGS) ;GUIDEWORDS
	CONFRM			;CONFIRM IT
	TYPE	<
Suppress >			;ERROR SUPRESSION
	HRROI	T1,[ASCIZ/No/]	;DEFAULT
	TXNE	F,FL%SSE	;SOFT?
	HRROI	T1,[ASCIZ/Soft/];YES
	TXNE	F,FL%SHE	;HARD?
	HRROI	T1,[ASCIZ/Hard/];YES
	TXC	F,FL%SHE+FL%SSE	;CHECK
	TXCE	F,FL%SHE+FL%SSE	; FOR BOTH ON
	SKIPA
	HRROI	T1,[ASCIZ/All/]	;BOTH
	TYPE.	0(T1)		;OUTPUT
	TYPE	< Errors>	;END LINE
	TYPE	<
Drive Serial Number to Report: >
	TXNE	F,FL%SER	;ALL?
	JRST	CMDWH0		;NO
	TYPE	<All drives>	;YES--SAY SO
	JRST	CMDWH1		;AND CONTINUE
CMDWH0:	MOVE	P1,SERNOM	;FETCH THE SERIAL NUMBER
	MOVEI	T1,.PRIOU	; AND GET THE JFN
	CALL	SEROUX		; TO TYPE IT
CMDWH1:	TYPE	<
Volume ID to Report: >		;VOLUMES
	TXNE	F,FL%VOL	;ALL?
	JRST	CMDWH2		;NO
	TYPE	<All Volumes>	;YES
	JRST	CMDWH3		;AND CONTINUE
CMDWH2:	MOVE	P1,VOLIDM	;GET VOLUME NAME
	MOVEI	T1,.PRIOU	; AND THE JFN
	CALL	VOLOUX		; TO TYPE IT
CMDWH3:	TXNN	F,FL%TIM	;RANGES OF TIME?
	JRST	CMDWH4		;NOT SET
	TYPE	<
Time Settings:	Begin: >	;SET--TYPE THEM
	MOVEI	T1,.PRIOU
	MOVE	T2,BGNTIM
	SETZ	T3,
	ODTIM
	 ERJMP	LOSE
	TYPE	<
		End:   >	;AND END VALUE
	MOVEI	T1,.PRIOU
	MOVE	T2,ENDTIM
	SETZ	T3,
	ODTIM
	 ERJMP	LOSE
	JRST	CMDWH5		;AND CONTINUE
CMDWH4:	TYPE	<
No Time Range Set>		;SAY NONE SET
CMDWH5:	TXNE	F,FL%IFS	;CHECK INPUT FILE SETUP
	JRST	CMDWH6		;ONE SPECIFIED
	TYPE	<
Default Input Error File>	;NOT SET UP
	JRST	CMDWH7		;AND CONTINUE
CMDWH6:	TYPE	<
Input Error File Specified: >	;PREFIX
	HRROI	T1,JFNSTR	;POINT TO FILENAME STRING
	TYPE.	0(T1)		;TYPE IT
CMDWH7:	HRROI	T1,[ASCIZ/
Complete Output Listing/]	;ASSUME COMPLETE OUTPUT
	TXNE	F,FL%SUM	;JUST THE SUMMARY?
	HRROI	T1,[ASCIZ/
Summary Output Listing Only/]	;YUP
	TYPE.	0(T1)		;SAY SO
	TYPE	<

>				;AND A CRLF
	RET			;AND RETURN


;DRIVE COMMAND TO SET DRIVE SERIAL NUMBER TO MATCH


.DRIVE:	NOISE	(SERIAL NUMBER TO LIST ERRORS FOR) ;GUIDEWORDS
	PARSE	[FLDDB. (.CMNUM,,^D10,,<ALL>,[FLDDB. (.CMKEY,,DRITAB)])] ;PARSE NUMBER
	TSC	T3,T3		;CHECK WHICH BLOCK WORKED
	JUMPN	T3,[	TXZ	F,FL%SER	;"ALL" SPECIFIED
			CONFRM			;CONFIRM IT
			RET]			;CLEAR FLAG AND RETURN
	TXO	F,FL%SER	;MARK TO CHECK
	MOVEI	P1,4		;CONVERT TO FOUR DIGIT BCD
	SETZM	T4		;START CLEAR
CMDDR0:	IDIVI	T2,^D10		;REMOVE DIGIT
	LSHC	T3,-4		;SHIFT DOWN
	SOJG	P1,CMDDR0	;LOOP FOR FOUR
	ROT	T4,^D16		;RIGHT JUSTIFIY
	MOVEM	T4,SERNOM	; AND SAVE FOR MATCHING
	CONFRM			;CONFIRM THE LINE
	RET			;AND RETURN


DRITAB:	DRILEN,,DRILEN		;HEADER
	AA	ALL,0		;ONLY ENTRY

	DRILEN==.-DRITAB-1	;NUMBER

;TIME COMMAND TO SET BEGIN AND END THRESHOLDS


.TIME:	NOISE	(TO START LISTING ENTRIES) ;GUIDEWORDS
	PARSE	[FLDDB.(.CMCFM,,,,,[FLDDB.(.CMTAD,,CM%IDA+CM%ITM,,,[
		FLDDB.(.CMTAD,,CM%IDA,,,[FLDDB.(.CMTAD,,CM%ITM)])])])] ;GET BEGIN
	TSC	T3,T3		;CHECK FOR JUST A CRLF
	JUMPE	T3,[	TXZ	F,FL%TIM	;YES--CLEAR TIME CHECKING
			RET]			; AND DONE HERE
	MOVEM	T2,BGNTIM	;SAVE IT
	NOISE	(AND END AT)	;MORE NOISE
	PARSE	[FLDDB.(.CMCFM,,,,,[FLDDB.(.CMTAD,,CM%IDA+CM%ITM,,,[
		FLDDB.(.CMTAD,,CM%IDA,,,[FLDDB.(.CMTAD,,CM%ITM)])])])] ;END
	TXO	F,FL%TIM	;REMEMBER
	MOVEM	T2,ENDTIM	;SAVE AWAY
	TSC	T3,T3		;CHECK FOR JUST CRLF (FIRST FLDDB.)
	JUMPE	T3,[GTAD	; IF SO, USE NOW
		    MOVEM T1,ENDTIM	; AS ENDING TIME
		    RET]		;AND DONE
	CONFRM			;OTHERWISE CONFIRM THE LINE
	RET			;AND RETURN



;READ COMMAND TO SET ALTERNATE INPUT FILE


.READ:	NOISE	(ERROR DATA FROM) ;GUIDEWORDS
	MOVX	T2,GJ%OLD	;FILE MUST EXIST
	MOVEM	T2,JFNBLK	;SET FLAGS
	PARSE	[FLDDB. (.CMIFI,,,,<PS:<SYSTEM-ERROR>ERROR.SYS>)] ;PARSE INPUT FILENAME
	MOVEM	T2,JFNTMP	;SAVE THE INPUT JFN FOR LATER
	CONFRM			;CONFIRM THE LINE
	TXO	F,FL%IFS	;FILE SPECIFIED
	HRROI	T1,JFNSTR	;WHERE TO PUT THE STRING
	MOVE	T2,JFNTMP	;GET JFN BACK
	MOVEM	T2,IJFN		;PUT IN IJFN
	SETZB	T3,T4		;DEFAULT STRING
	JFNS			;PUT IT IN STRING BLOCK
	 ERJMP	LOSE		;FAILED
	MOVE	T1,IJFN		;AND PROCEED TO
	RLJFN			; UNLOAD JFN, SAVING STRING
	 ERJMP	LOSE		;FAILED
	RET			;AND RETURN



;LIST COMMAND TO SET OUTPUT FILE AND BEGIN


.LIST:	NOISE	(OUTPUT ON FILE) ;GUIDEWORDS
	PARSE	[FLDDB. (.CMOFI,,,,<TTY:>)] ;READ OUTPUT SPEC
	MOVEM	T2,JFNTMP	;STORE JFN FOR OUTPUT
	NOISE	(AND BEGIN PROCESSING) ;FINAL GUIDEWORDS
	CONFRM			;CONFIRM THE LINE
	MOVE	T1,JFNTMP	;GET BACK OUTPUT JFN
	MOVEM	T1,OJFN		; AND ESTABLISH IT
	SETABT	LSTABT		;ACTIVATE CONTROL-E ABORT
	CALL	PROCES		;DO THE JOB
LSTDON:	CLRABT			;CLEAR PSI STUFF
	RET			;AND RETURN FOR ANOTHER COMMAND



;DEBRK TRANSFERS CONTROL TO HERE TO ABORT THE LIST COMMAND

LSTABT:	MOVEI	T1,.PRIOU	;PRESUME TO CLEAR
	CFOBF			; THE OUTPUT IN CASE GOING TO TTY
	 ERJMP	LOSE
	WARN	Listing Aborted
	TXZ	F,FL%IFS+FL%OFO	;ABORT CLOSE THE FILES
	MOVX	T1,CZ%ABT+.FHSLF; FOR THE  JOB
	CLZFF
	 ERJMP	LOSE
	MOVE	P,SAVPSI	;ADJUST STACK BACK FOR ABORT
	JRST	LSTDON		; AND FINISH UP THE COMMAND

	SUBTTL	THE MAIN PROCESSING LOOP


PROCES:	MOVX	T1,GJ%OLD+GJ%SHT	;GETJFN BITS
	HRROI	T2,[ASCIZ/PS:<SYSTEM-ERROR>ERROR.SYS/]	;ASSUME DEFAULT
	TXNE	F,FL%IFS	;SPECIAL FILE SPECIFIED?
	HRROI	T2,JFNSTR	;YES--POINT TO IT
	GTJFN			;TRY TO GET IT
	 ERJMP	LOSE		;FAILED
	MOVEM	T1,IJFN		;SAVE JFN

PROC1:	MOVE	T1,IJFN		;GET INPUT JFN
	MOVX	T2,^D36B5+OF%RD	;TO READ
	OPENF			;OPEN IT
	 ERJMP	LOSE		;FAILED

	MOVE	T1,OJFN		;NOW TRY OUTPUT JFN
	MOVX	T2,^D7B5+OF%WR	;TO WRITE IN ASCII
	OPENF			;OPEN IT
	 ERJMP LOSE		;FAILED
	TXO	F,FL%OFO	;MARK AS OPEN

	TYPE	<
[ PROCESSING >			;SAY WHO
	TYPJFN	IJFN		;OUTPUT THE FILESPEC TO THE USER
	TYPE	< ]

>				;AND A CRLF
	SETOM	LINENO		;INIT LINE COUNTER
	SETZM	PAGENO		;INIT PAGE NUMBER
	TXO	F,FL%FDO	;FORCE DATE OUTPUT
	SETZM	SUMCNT		;INIT SUMMARY TABLE
	SETZB	T1,T2		;ZERO SOME STUFF
	SETZ	T3,		;TO INDICATE MIDNIGHT
	IDCNV			;GET LOCAL MIDNITE
	 ERJMP	LOSE		;FAILED
	HRROM	T2,LSTDAT	;SET DATE PRINTING THRESHOLD

	CALL	FILINI		;INIT INPUT FILE POINTERS

PROCLP:	CALL	NXTENT		;GET NEXT ENTRY TO BUFFER
	JRST	PROCFN		;END OF FILE OR OTHER TERMINATION
	MOVE	P1,HDRTIM	;MAKE
	CALL	TIMCHK		; CHECK OF TIME
	JRST	PROCSM		;UNWANTED--BUT SUMMARIZE
	MOVE	P1,VOLID	;MAKE
	CALL	VOLCHK		; CHECK OF VOLUME
	JRST	PROCSM		;UNWANTED--BUT SUMMARIZE
	MOVE	P1,SERNO	;MAKE
	CALL	SERCHK		; CHECK OF DRIVE SERIAL NUMBER
	JRST	PROCSM		;UNWANTED--BUT SUMMARIZE
	MOVE	P1,IRBSTS	;MAKE
	CALL	HRDCHK		; CHECK OF ERROR TYPE
	JRST	PROCSM		;UNWANTED--BUT SUMMARIZE
	TXNE	F,FL%SUM	;SUMMARY ONLY?
	JRST	PROCSM		;YES

	CALL	TSTPAG		;WANT THIS ONE--
	MOVE	P1,HDRTIM	;OUTPUT TIME
	CALL	DATOUT
	PSPACE	1
	MOVE	P1,VOLID	;OUTPUT VOLUME ID
	CALL	VOLOUT
	PSPACE	2
	MOVE	P1,SERNO	;OUTPUT SERIAL NUMBER
	CALL	SEROUT
	PSPACE	1
	OCTOUT	LBN,^D10	;LOGICAL BLOCK NUMBER, 10 RJ OCTAL DIGITS
	PSPACE	1
	MOVE	P1,LBN		;OUTPUT CYL/SURF/SEC
	CALL	CYLOUT
	PSPACE	2
	DECOUT	RETRY,3		;RETRY COUNT, 3 RJ DECIMAL DIGITS
	PSPACE	1
	MOVE	P1,IRBSTS	;OUTPUT HARD/SOFT
	CALL	HRDOUT
	PRINT	<
>				;AND A CRLF
PROCSM:	MOVE	P1,VOLID	;VOLUME AND
	MOVE	P2,IRBSTS	; ERROR TYPE
	MOVE	P3,DEVTYP	; AND INTERNAL UNIT TYPE
	CALL	SUMVOL		;FOR SUMMARY BY VOLUME
	JRST	PROCLP		;AND LOOP


PROCFN:	CALL	SUMOUT		;PRINT THE SUMMARY
	MOVE	T1,IJFN		;INPUT JFN
	CLOSF			;CLOSE
	 ERJMP	LOSE
	MOVE	T1,OJFN		;OUTPUT JFN
	CLOSF			;SAME
	 ERJMP	LOSE
	TXZ	F,FL%IFS+FL%OFO	;MARK AS NOT OPEN
	RET			;AND DONE



;SUMVOL	DO THE SUMMARY OF HARD/SOFT ERRORS BY VOLUME


SUMVOL:	SKIPN	T2,SUMCNT	;ANYONE THERE?
	JRST	SUMADV		; NOT YET
	SETZ	T1,		;START AT THE BEGINNING
SUMSLP:	CAMN	P1,SUMTAB+VSUM(T1)	;VOLUMES MATCH?
	CAME	P3,SUMTAB+USUM(T1)	; AND UNIT TYPE TOO?
	SKIPA			;NO
	JRST	SUMINC		;YES--MAKE THE COUNTS
	ADDI	T1,SIZSUM	;LENGTH OF AN ENTRY
	SOJG	T2,SUMSLP	;NO FOUND YET--KEEP LOOKING

	MOVEI	T1,VTBSIZ	;NOT FOUND--CHECK FOR ROOM
	SUB	T1,SUMCNT	; TO ADD TO TABLE
	JUMPG	T1,SUMADV	;THERE IS ROOM
	TXO	F,FL%TMV	;NO ROOM--MARK
	RET			; AND FORGET FOR NOW

SUMADV:	MOVE	T1,SUMCNT	;GET COUNT OF ENTRIES
	IMULI	T1,SIZSUM	;SIZE OF AN ENTRY
	MOVEM	P1,SUMTAB+VSUM(T1)	;STORE VOLUME
	MOVEM	P3,SUMTAB+USUM(T1)	;SET UNIT TYPE
	SETZB	T2,T3			;INITIALIZE
	DMOVEM	T2,SUMTAB+VSUM+1(T1)	; HARD AND SOFT COUNTS
	AOSE	SUMCNT		;COUNT THE ENTRY
SUMINC:	TXNE	P2,IS.ERR	;HARD OR SOFT?
	AOSA	SUMTAB+HSUM(T1)	;HARD
	AOS	SUMTAB+SSUM(T1)	;SOFT
	RET			;AND RETURN


	SUBTTL	ENTRY INPUT AND VALIDATION ROUTINES


;ALL ROUTINES HERE RETSKP IF VALID AND RET IF ENTRY IS UNWANTED


;TIMCHK	VERIFY ENTRY TIME IN P1 IN RANGE

TIMCHK:	TXNN	F,FL%TIM	;DO WE CARE?
	RETSKP			;NO
	CAML	P1,BGNTIM	;TOO EARLY
	CAMLE	P1,ENDTIM	; OR TOO LATE?
	RET			;YUP
	RETSKP			;IN RANGE


;VOLCHK	VERIFY VOLUME ID IN P1

VOLCHK:	TXNE	F,FL%VOL	;DO WE CARE?
	CAMN	P1,VOLIDM	; OR DOES IT MATCH?
	RETSKP			;YES
	RET			;NO


;SERCHK	VERIFY DRIVE SERIAL NUMBER IN P1

SERCHK:	TXNE	F,FL%SER	;DO WE CARE?
	CAMN	P1,SERNOM	; OR DOES IT MATCH?
	RETSKP			;YES
	RET			;NO


;HRDCHK	VERIFY IF SUPPRESSING HARD OR SOFT ERRORS FROM IS.ERR IN P1

HRDCHK:	TXNN	P1,IS.ERR	;HARD OR SOFT?
	JRST	SOFCHK		;SOFT
	TXNN	F,FL%SHE	;SUPPRESS?
	RETSKP			;NO
	RET			;YES

SOFCHK:	TXNN	F,FL%SSE	;SUPPRESS?
	RETSKP			;NO
	RET			;YES



;FILINI	INITIALIZE INPUT FILE...


FILINI:	MOVEI	T1,1		;ADDRESS OF FIRST HEADER WORD
	MOVEM	T1,HDRADR	;INIT HDRADR
	SETZM	HDRWRD		;AND FAKE HDRWRD SO WILL BEGIN AT START
	RET			;AND RETURN



;NXTENT	READ IN THE NEXT MASSBUS ENTRY.  RETSKP OK, RET ON EOF.


NXTENT:	LOAD	T2,HDRLEN	;HEADER LENGTH
	LOAD	T1,ENTLEN	;ENTRY LENGTH
	ADD	T2,T1		;COMBINE
	CALL	GETWRD		;READ NEXT HEADER
	RET			;EOF???
	LOAD	T1,HDRCOD	;GET TYPE CODE
	CAIE	T1,HF.ERR	;IS IT AN ERROR MARKER
	CAIN	T1,HF.EOF	; OR THE NORMAL EOF MARKER?
	RET			;YES
	MOVEM	T3,HDRADR	;SET NEW HEADER ADDRESS
	MOVEM	T2,HDRWRD	;SET NEW HEADER WORD
	LOAD	T1,HDRVER	;GET VERSION
	CAIE	T1,HF.VER	;ONE WE KNOW?
	JRST	LOST		;NO--SANITY CHECK LOSES
	MOVE	T1,HDRWRD	;WORD
	TXNN	T1,HF.T20	;TOPS-20 ENTRY?
	JRST	LOST		;NO--SANITY CHECK LOSES
	LOAD	T1,HDRCOD	;GET TYPE CODE
	CAIE	T1,SEC%MB	;MASSBUS ERROR?
	JRST	NXTENT		;NO--LOOP
	CALL	RDENT		;OK, SO READ VALUES
	SKIPGE	DEVTYP		;DISK DEVICE?
	JRST	NXTENT		;NO--LOOP
	RETSKP			;AND RETURN SKIP

LOST:	TYPE	<
% LOST SYNCHRONIZATION--ATTEMPTING TO CONTINUE

>				;SAY OOPS
	MOVE	T1,HDRADR	;GET CURRENT ADDRESS
	ADDI	T1,^D128	;MOVE TO NEXT BLOCK
	TRZ	T1,177		;AND ROUND BACK TO BEGINNING
	MOVEM	T1,HDRADR	;THEN STORE BACK
	MOVEI	T2,0		;ZERO OFFSET
	CALL	GETWRD		;READ THE POINTER WORD AT START OF BLOCK
	 RET			;APPARENTLY END OF FILE...
	HRRZS	T2		;OFFSET IS IN THE RIGHT HALF
	ADDM	T2,HDRADR	;POINT TO START OF NEXT ENTRY
	SETZM	HDRWRD		;NO FURTHER OFFSETS
	JRST	NXTENT		; AND TRY THE NEXT ENTRY

;RDENT	READ IN THE DATA FOR THE CURRENT ENTRY


RDENT:	MOVEI	T2,HDRDAT	;GET DATE-TIME
	CALL	GETWRD
	 JRST	OOPS
	MOVEM	T2,HDRTIM

	LOAD	T2,HDRLEN	;GET VOLUME ID
	ADDI	T2,MB%VID
	CALL	GETWRD
	 JRST	OOPS
	MOVEM	T2,VOLID

	LOAD	T2,HDRLEN	;GET LBN - ACTUALLY LINEAR UNIT ADR
	ADDI	T2,MB%LOC
	CALL	GETWRD
	 JRST	OOPS
	MOVEM	T2,LBN

	LOAD	T2,HDRLEN	;GET SERIAL #
	ADDI	T2,SEROFF
	CALL	GETWRD
	 JRST	OOPS
	LOAD	T2,F%SER
	MOVEM	T2,SERNO

	LOAD	T2,HDRLEN	;GET IORB STATUS
	ADDI	T2,MB%IRS
	CALL	GETWRD
	 JRST	OOPS
	MOVEM	T2,IRBSTS

	LOAD	T2,HDRLEN	;GET RETRY COUNT
	ADDI	T2,MB%FEC
	CALL	GETWRD
	 JRST	OOPS
	MOVEM	T2,RETRY

	LOAD	T2,HDRLEN	;GET UNIT TYPE
	ADDI	T2,MB%TYP
	CALL	GETWRD
	 JRST	OOPS
	LOAD	T2,F%TYP
	CAILE	T2,MXUTYP	;REASONABLE?
	SKIPA	T2,[-1]		; NO, FAKE AS UNKNOWN
	MOVE	T2,CVTTAB(T2)	;CONVERT TO INTERNAL FORM UNIT
	MOVEM	T2,DEVTYP
	RET			;AND RETURN

OOPS:	ERROR	UNEXPECTED END-OF-FILE ON INPUT



;GETWRD	ROUTINE TO RETURN DESIRED WORD FROM INPUT FILE
;CALLED WITH OFFSET FROM THE BEGINNING OF THE HEADER IN T2.
;RETURNS THE DESIRED WORD IN T2 RETSKP.  NONSKIP FOR END-OF-FILE.
;RETURNS WORD ADDRESS IN T3.
;COMPUTES THE ADJUSTMENTS NEEDED TO ACCOMODATE THE SYNCH WORD AT
;THE START OF EVERY 128-WORD BLOCK.


GETWRD:	MOVE	T1,HDRADR	;HEADER ADDRESS
	ADD	T2,T1		;PLUS OFFSET
	LSH	T1,-7		;DIVIDE BY BLOCKSIZE
	MOVE	T3,T2		;COPY FOR ADJUST
	LSH	T3,-7		;DIVIDE BY BLOCKSIZE
	SUB	T3,T1		;COUNT BLOCK CROSSINGS
	ADD	T3,T2		;UPDATE ADDRESS FOR PROPER ADJUSTMENT
	XOR	T2,T3		;AND CHECK TO SEE IF THE ADJUSTMENT
	TRNE	T2,200		; PUSHED US ACROSS ANOTHER BOUNDARY
	AOS	T3		;IT DID, ADD THE (FINAL!) ADJUSTMENT.
	MOVE	T1,IJFN		;INPUT JFN
	RIN			;READ THE WORD
	 ERJMP	CHKEOF		;WATCH FOR EOF
	RETSKP			;RETURN

CHKEOF:	GTSTS			;GET STATUS BITS
	TXNN	T2,GS%EOF	;END OF FILE?
	JRST	LOSE		;NO--SOME ERROR
	RET			;YES--NONSKIP


	SUBTTL	OUTPUT CONVERSION ROUTINES


;DATOUT	OUTPUT THE DATE-TIME PASSED IN P1.


DATOUT:	MOVE	T1,OJFN		;JFN
	MOVE	T2,P1		;THE DATE-TIME
	SETZ	T3,		;DEFAULT FORMAT
	TXNE	F,FL%FDO	;FORCED?
	JRST	DATOU1		;YES--MAKE SURE THRESHOLD OK
	CAMGE	T2,LSTDAT	;PAST THRESHOLD?
	JRST [	PUSH	P,T2	;SAVE ACROSS CALL
		PSPACE	12	; DO SPACING
		POP	P,T2	;RESTORE
		JRST	DATOU2]	;AND CONTINUE
	TXO	F,FL%FDO	;YES, FORCE DATE OUT
DATOU1:	HLLM	T2,LSTDAT	;UPDATE THE THRESHOLD
	MOVSI	T4,1		; AND ADJUST IT
	CAML	T2,LSTDAT	; TO BE CORRECT
	ADDM	T4,LSTDAT	; FOR NEXT DAY
DATOU2:	TXZN	F,FL%FDO	;FORCING?
	TXO	T3,OT%NDA	;NO--SUPPRESSING
	ODTIM			;DO IT
	 ERJMP	LOSE		;FAILED
	RET			;DONE



;VOLOUT	OUTPUT THE VOLUME ID FROM P1 (SIXBIT)
;ENTRY POINT VOLOUX FOR JFN ALREADY SETUP IN T1


VOLOUT:	MOVE	T1,OJFN		;JFN FOR OUTPUT
VOLOUX:	MOVE	T3,[POINT 6,P1]	;POINTER
	MOVEI	T4,6		;COUNTER
VOLOUL:	ILDB	T2,T3		;FETCH BYTE
	ADDI	T2," "		;MAKE ASCII
	BOUT			;OUTPUT
	 ERJMP	LOSE		;FAILED
	SOJG	T4,VOLOUL	;LOOP
	RET			;DONE




;SEROUT	OUTPUT THE SERIAL NUMBER FROM P1 (BCD)
;ENTRY POINT SEROUX FOR JFN ALREADY SETUP IN T1


SEROUT:	MOVE	T1,OJFN		;JFN FOR OUTPUT
SEROUX:	MOVE	T2,P1		;VALUE
	MOVE	T3,[NO%MAG+NO%LFL+NO%ZRO+4B17+^D16] ;FOUR BCD DIGITS
	NOUT			; WITH ZERO FILL
	 ERJMP	LOSE		;FAILED
	MOVEI	T2,"."		;"DECIMAL"
	BOUT			; POINT
	 ERJMP	LOSE		;FAILED
	RET			;DONE




;HRDOUT	OUTPUT IF HARD OR SOFT ERROR BASED ON IS.ERR IN P1


HRDOUT:	TXNE	P1,IS.ERR	;HARD OR SOFT?
	 JRST [	PRINT	<HARD>	;HARD
		RET]		;DONE
	PSPACE	4		;SOFT - SPACE INSTEAD
	RET




;CYLOUT	OUTPUT CYLINDER/SURFACE/SECTOR FROM LBN IN P1


CYLOUT:	MOVE	T4,DEVTYP	;GET TYPE OF UNIT FOR INDEX
	CAMGE	P1,.MXBLK(T4)	;MORE THAN ONE UNIT FULL?
	JRST	CYLOU1		;NO
	SUB	P1,.MXBLK(T4)	;REDUCE BY SECTORS/UNIT
	JRST	.-3		;AND LOOP
CYLOU1:	IDIV	P1,.TRBLK(T4)	;DIVIDE BY SECTORS/CYLINDER
	DECOUT	P1,4		;4 DIGIT DECIMAL CYLINDER
	PSPACE	2		;AND SPACING

	MOVE	P1,P2		;MOVE
	IDIV	P1,.SUBLK(T4)	;DIVIDE BY SECTORS/SUFRACE
	DECOUT	P1,2		;TWO DIGIT DECIMAL SURFACE
	PSPACE	2		;AND SPACING

	MOVE	P1,P2		;MOVE
	IMUL	P1,.SECBK(T4)	;MULTIPLY BY SECTORS/BLOCK
	DECOUT	P1,3		;THREE DIGIT DECIMAL SECTOR

	RET			;AND RETURN

;CONVERSION FROM UNIT TO INTERNAL DISK UNIT, -1 FOR NON-DISK OR UNKNOWN

CVTTAB:	EXP	-1		;0 - UNKNOWN TYPE
	EXP	1		;1 - RP04
	EXP	0		;2 - RS04
	EXP	-1		;3 - TU45
	EXP	-1		;4 - TM02
	EXP	2		;5 - RP05
	EXP	3		;6 - RP06
	EXP	5		;7 - RP07
	EXP	-1		;10 - RP08--NOT YET HANDLING
	EXP	4		;11 - RM03
	EXP	-1		;12 - TM03
	EXP	-1		;13 - TU77
	EXP	-1		;14 - TM78
	EXP	-1		;15 - TU78
	EXP	-1		;16 - DX20-A (FOR TAPES)
	EXP	-1		;17 - TU70
	EXP	-1		;20 - TU71
	EXP	-1		;21 - TU72
	EXP	-1		;22 - TU7x
	EXP	-1		;23 - DX20-B (FOR DISKS)
	EXP	6		;24 - RP20

	MXUTYP==.-CVTTAB-1

;TABLES INDEXED BY INTERNAL UNIT TYPE

.DVTAB:	ASCIZ/RS04/
	ASCIZ/RP04/
	ASCIZ/RP05/
	ASCIZ/RP06/
	ASCIZ/RM03/
	ASCIZ/RP07/
	ASCIZ/RP20/

.MXBLK:	^D2048			;2048 BLOCKS PER RS04
	^D152000		;152000 BLOCKS PER RP04
	^D152000		;152000 BLOCKS PER RP05
	^D304000		;304000 FOR AN RP06
	^D121360		;121360 BLOCKS/PACK RM03
	^D865504		;865504 BLOCKS PER RP07
	^D201420		;201420 BLOCKS PER RP20

.TRBLK:	^D32			;32 BLOCKS/TRACK ON RS04
	^D380			;380 BLOCKS/CYL RP04
	^D380			;380 BLOCKS/CYL RP05
	^D380			;380 BLOCKS/CYL RP06
	^D148			;BLOCKS/CYL RM03  (LAST 2 SECTORS LOST)
	^D1376			;1376 BLOCKS/CYL RP07
	^D180			;180 SECTORS/CYL ON RP20

.SUBLK:	^D0			;RS04 BLOCKS/SURFACE
	^D20			;RP04 BLOCKS/SURFACE
	^D20			;RP05 BLOCKS/SURFACE
	^D20			;RP06 BLOCKS/SURFACE
	^D30			;BLOCKS / SURFACE FOR RM03
	^D43			;RP07 BLOCKS/SURFACE
	^D6			;RP20 SECTORS/SURFACE

.SECBK:	2			;2/BLOCK FOR RS04
	1			;1 PER FOR RP04
	1			;1 PER FOR RP05
	1			;1 PER FOR RP06
	1			;1 SECTOR / BLOCK FOR RM03
	1			;1 PER FOR RP07
	1			;1 SECTOR/BLOCK FOR RP20

	SUBTTL	PAGE HEADER PRINTING ROUTINE


;TSTPAG	ROUTINE CALLED PRIOR TO OUTPUTTING A LINE.  TESTS LINENO AND
;	PUTS OUT A NEW PAGE HEADER WHEN THE COUNTER EXPIRES.


TSTPAG:	AOSE	LINENO		;HEADER TIME
	 RET			;NOT YET
	AOS	PAGENO		;NEW PAGE
	PRINT.	[BYTE(7).CHFFD,0,0,0,0] ;OUTPUT FORM FEED
	PRINT	<
DSKERR %>			;OUT NAME
	VERSIO	EVEC+2	;OUTPUT OUR VERSION NUMBER
	PRINT	<	>	;AND A TAB
	MOVE	T1,OJFN		;OUTPUT JFN
	SETO	T2,		;NOW
	ODTIM			;DATE AND TIME
	 ERJMP	LOSE
	PRINT	<				PAGE  >
	DECOUT	PAGENO,3	;AND FINALLY THE PAGE NUMBER
	PRINT	<

   DATE     TIME   VOLUME SERIAL #    LBN    CYL  SURF  SEC  RETRY TYPE

>				;COLUMN HEADER

	MOVNI	T1,PAGSIZ	;RESET COUNTER
	MOVEM	T1,LINENO	; FOR NEXT TIME
	TXO	F,FL%FDO	;FORCE THE DATE ON FIRST LINE
	RET			;AND RETURN


	SUBTTL	SUMMARY PRINTING ROUTINE

;SUMOUT	OUTPUT THE BY VOLUME SUMMARY ON A NEW PAGE


SUMOUT:	SKIPN	P2,SUMCNT	;ANYTHING TO DO
	 JRST	[TYPE	<No errors summarized>	;NOTHING ACCUMULATED
		 RET]		;SO DONE

	PRINT.	[BYTE(7).CHFFD,0,0,0,0] ;FORM FEED FOR NEW PAGE
	PRINT	<

ERROR SUMMARY BY VOLUME

VOLUME ID   UNIT TYPE    HARD ERRORS    SOFT ERRORS

>				;THE HEADER LINE
	SETZ	P3,		;START OF TABLE
SUMOLP:	MOVE	P1,SUMTAB+VSUM(P3) ;VOLUME ID
	CALL	VOLOUT		;OUTPUT IT
	PSPACE	10		;SPACING
	MOVE	T2,SUMTAB+USUM(P3)	;UNIT TYPE
	PRINT.	.DVTAB(T2)	;PRINT NAME
	PSPACE	10		;SPACING
	DECOUT	SUMTAB+HSUM(P3),6 ;DO HARD ERROR COUNT
	PSPACE	10		;SPACING
	DECOUT	SUMTAB+SSUM(P3),6 ;DO SOFT ERROR COUNT
	PRINT	<
>				;AND END LINE
	ADDI	P3,SIZSUM	;SIZE OF AN ENTRY
	SOJG	P2,SUMOLP	;LOOP THRU TABLE
	TXNN	F,FL%TMV	;SOME NOT LISTED?
	 RET			;NO, DONE.
	PRINT	<
*** Further volumes not listed because of insufficient room in table ***
>				;PROVIDE A CLUE
	RET			;AND DONE

	SUBTTL	THE DATA AREA

	XLIST			;DUMP THE LITERALS
	LIT
	LIST


SAVEP:	BLOCK	1		;STORAGE OF STACK FOR COMND PARSING
JFNSTR:	BLOCK	100		;STORAGE FOR INPUT FILENAME
IJFN:	BLOCK	1		;INPUT FILE JFN
PAGENO:	BLOCK	1		;PAGE NUMBER
LINENO:	BLOCK	1		;LINE NUMBER
BGNTIM:	BLOCK	1		;BEGIN TIME
ENDTIM:	BLOCK	1		;END TIME
VOLIDM:	BLOCK	1		;SIXBIT VOLUME ID TO MATCH
SERNOM:	BLOCK	1		;DRIVE SERIAL NUMBER TO MATCH
LSTDAT:	BLOCK	1		;LAST DATE OUTPUT WORD

;ENTRY DATA

HDRADR:	BLOCK	1		;ADDRESS OF CURRENT HEADER WORD

HDRWRD:	BLOCK	1		;CURRENT HEADER WORD
HDRTIM:	BLOCK	1		;DATE-TIME
DEVTYP:	BLOCK	1		;DEVICE TYPE WORD
VOLID:	BLOCK	1		;VOLUME ID
LBN:	BLOCK	1		;LOGICAL BLOCK NUMBER
RETRY:	BLOCK	1		;RETRY COUNT
IRBSTS:	BLOCK	1		;IORB STATUS WORD
SERNO:	BLOCK	1		;SERIAL NUMBER

SUMCNT:	BLOCK	1		;COUNT OF ENTRIES IN SUMTAB
SUMTAB:	BLOCK	SIZSUM*VTBSIZ	;SUMMARY TABLE--VOLID,HARD,SOFT


	END	<3,,EVEC>
