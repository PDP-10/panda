This is Info file ../info/emacs, produced by Makeinfo-1.43 from the
input file emacs.tex.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: emacs,  Node: Commands,  Next: Entering Emacs,  Prev: Keys,  Up: Top

Keys and Commands
=================

   This manual is full of passages that tell you what particular keys
do.  But Emacs does not assign meanings to keys directly.  Instead,
Emacs assigns meanings to "functions", and then gives keys their
meanings by "binding" them to functions.

   A function is a Lisp object that can be executed as a program. 
Usually it is a Lisp symbol which has been given a function
definition; every symbol has a name, usually made of a few English
words separated by dashes, such as `next-line' or `forward-word'.  It
also has a "definition" which is a Lisp program; this is what makes
the function do what it does.  Only some functions can be the bindings
of keys; these are functions whose definitions use `interactive' to
specify how to call them interactively.  Such functions are called
"commands", and their names are "command names".  More information on
this subject will appear in the GNU Emacs Lisp Manual (which is not
yet written).

   The bindings between keys and functions are recorded in various
tables called "keymaps".  *Note Keymaps::.

   When we say that "`C-n' moves down vertically one line" we are
glossing over a distinction that is irrelevant in ordinary use but is
vital in understanding how to customize Emacs.  It is the function
`next-line' that is programmed to move down vertically.  `C-n' has
this effect because it is bound to that function.  If you rebind `C-n'
to the function `forward-word' then `C-n' will move forward by words
instead.  Rebinding keys is a common method of customization.

   In the rest of this manual, we usually ignore this subtlety to keep
things simple.  To give the customizer the information he needs, we
state the name of the command which really does the work in parentheses
after mentioning the key that runs it.  For example, we will say that
"The command `C-n' (`next-line') moves point vertically down," meaning
that `next-line' is a command that moves vertically down and `C-n' is
a key that is standardly bound to it.

   While we are on the subject of information for customization only,
it's a good time to tell you about "variables".  Often the description
of a command will say, "To change this, set the variable `mumble-foo'."
A variable is a name used to remember a value.  Most of the variables
documented in this manual exist just to facilitate customization: some
command or other part of Emacs examines the variable and behaves
differently accordingly.  Until you are interested in customizing, you
can ignore the information about variables.  When you are ready to be
interested, read the basic information on variables, and then the
information on individual variables will make sense.  *Note
Variables::.


File: emacs,  Node: Entering Emacs,  Next: Exiting,  Prev: Commands,  Up: Top

Entering and Exiting Emacs
**************************

   The usual way to invoke Emacs is just to type `emacs RET' at the
shell.  Emacs clears the screen and then displays an initial advisor
message and copyright notice.  You can begin typing Emacs commands
immediately afterward.

   Some operating systems insist on discarding all type-ahead when
Emacs starts up; they give Emacs no way to prevent this.  Therefore,
it is wise to wait until Emacs clears the screen before typing your
first editing command.

   Before Emacs reads the first command, you have not had a chance to
give a command to specify a file to edit.  But Emacs must always have
a current buffer for editing.  In an attempt to do something useful,
Emacs presents a buffer named `*scratch*' which is in Lisp Interaction
mode; you can use it to type Lisp expressions and evaluate them, or
you can ignore that capability and simply doodle.  (You can specify a
different major mode for this buffer by setting the variable
`initial-major-mode' in your init file.  *Note Init File::.)

   It is also possible to specify files to be visited, Lisp files to be
loaded, and functions to be called, by giving Emacs arguments in the
shell command line.  *Note Command Switches::.


File: emacs,  Node: Exiting,  Next: Command Switches,  Prev: Entering Emacs,  Up: Top

Exiting Emacs
=============

   There are two commands for exiting Emacs because there are two
kinds of exiting: "suspending" Emacs and "killing" Emacs. 
"Suspending" means stopping Emacs temporarily and returning control to
its superior (usually the shell), allowing you to resume editing later
in the same Emacs job, with the same files, same kill ring, same undo
history, and so on.  This is the usual way to exit.  "Killing" Emacs
means destroying the Emacs job.  You can run Emacs again later, but
you will get a fresh Emacs; there is no way to resume the same editing
session after it has been killed.

`C-z'
     Suspend Emacs (`suspend-emacs').

`C-x C-c'
     Kill Emacs (`save-buffers-kill-emacs').

   To suspend Emacs, type `C-z' (`suspend-emacs').  This takes you
back to the shell from which you invoked Emacs.  You can resume Emacs
with the command `%emacs' if you are using the C shell.

   On systems that do not permit programs to be suspended, `C-z' runs
an inferior shell that communicates directly with the terminal, and
Emacs waits until you exit the subshell.  The only way on these
systems to get back to the shell from which Emacs was run (to log out,
for example) is to kill Emacs.  `C-d' or `exit' are typical commands
to exit a subshell.

   To kill Emacs, type `C-x C-c' (`save-buffers-kill-emacs').  A
two-character key is used for this to make it harder to type.  Unless a
numeric argument is used, this command first offers to save any
modified buffers.  If you do not save them all, it asks for
reconfirmation with `yes' before killing Emacs, since any changes not
saved before that will be lost forever.  Also, if any subprocesses are
still running, `C-x C-c' asks for confirmation about them, since
killing Emacs will kill the subprocesses immediately.

   In most programs running on Unix, certain characters may instantly
suspend or kill the program.  (In Berkeley Unix these characters are
normally `C-z' and `C-c'.)  This Unix feature is turned off while you
are in Emacs.  The meanings of `C-z' and `C-x C-c' as keys in Emacs
were inspired by the standard Berkeley Unix meanings of `C-z' and
`C-c', but that is their only relationship with Unix.  You could
customize these keys to do anything (*note Keymaps::.).


File: emacs,  Node: Command Switches,  Next: Basic,  Prev: Exiting,  Up: Top

Command Line Switches and Arguments
===================================

   GNU Emacs supports command line arguments to request various actions
when invoking Emacs.  These are for compatibility with other editors
and for sophisticated activities.  They are not needed for ordinary
editing with Emacs, so new users can skip this section.

   You may be used to using command line arguments with other editors
to specify which file to edit.  That's because many other editors are
designed to be started afresh each time you want to edit.  You edit
one file and then exit the editor.  The next time you want to edit
either another file or the same one, you must run the editor again. 
With these editors, it makes sense to use a command line argument to
say which file to edit.

   The recommended way to use GNU Emacs is to start it only once, just
after you log in, and do all your editing in the same Emacs process. 
Each time you want to edit a different file, you visit it with the
existing Emacs, which eventually comes to have many files in it ready
for editing.  Usually you do not kill the Emacs until you are about to
log out.

   When files are nearly always read by typing commands to an editor
that is already running, command line arguments for specifying a file
when the editor is started are seldom needed.

   Emacs accepts command-line arguments that specify files to visit,
functions to call, and other activities and operating modes.

   The command arguments are processed in the order they appear in the
command argument list; however, certain arguments (the ones in the
second table) must be at the front of the list if they are used.

   Here are the arguments allowed:

`FILE'
     Visit FILE using `find-file'.  *Note Visiting::.

`+LINENUM FILE'
     Visit FILE using `find-file', then go to line number LINENUM in
     it.

`-l FILE'
`-load FILE'
     Load a file FILE of Lisp code with the function `load'.  *Note
     Lisp Libraries::.

`-f FUNCTION'
`-funcall FUNCTION'
     Call Lisp function FUNCTION with no arguments.

`-i FILE'
`-insert FILE'
     Insert the contents of FILE into the current buffer.  This is
     like what `M-x insert-buffer' does; *Note Misc File Ops::.

`-kill'
     Exit from Emacs without asking for confirmation.

   The remaining switches are recognized only at the beginning of the
command line.  If more than one of them appears, they must appear in
the order that they appear in this table.

`-t DEVICE'
     Use DEVICE as the device for terminal input and output.

`-d DISPLAY'
     When running with the X window system, use the display named
     DISPLAY to make the window that serves as Emacs's terminal.

`-batch'
     Run Emacs in "batch mode", which means that the text being edited
     is not displayed and the standard Unix interrupt characters such
     as `C-z' and `C-c' continue to have their normal effect.  Emacs
     in batch mode outputs to `stdout' only what would normally be
     printed in the echo area under program control.

     Batch mode is used for running programs written in Emacs Lisp from
     shell scripts, makefiles, and so on.  Normally the `-l' switch or
     `-f' switch will be used as well, to invoke a Lisp program to do
     the batch processing.

     `-batch' implies `-q' (do not load an init file).  It also causes
     Emacs to kill itself after all command switches have been
     processed.  In addition, auto-saving is not done except in
     buffers for which it has been explicitly requested.

`-q'
`-no-init-file'
     Do not load your Emacs init file `~/.emacs'.

`-u USER'
`-user USER'
     Load USER's Emacs init file `~USER/.emacs' instead of your own.

   Note that the init file can get access to the command line argument
values as the elements of a list in the variable `command-line-args'. 
(The arguments in the second table above will already have been
processed and will not be in the list.)  The init file can override
the normal processing of the other arguments by setting this variable.

   One way to use command switches is to visit many files
automatically:

     emacs *.c

passes each `.c' file as a separate argument to Emacs, so that Emacs
visits each file (*note Visiting::.).

   Here is an advanced example that assumes you have a Lisp program
file called `hack-c-program.el' which, when loaded, performs some
useful operation on current buffer, expected to be a C program.

     emacs -batch foo.c -l hack-c-program -f save-buffer -kill > log

Here Emacs is told to visit `foo.c', load `hack-c-program.el' (which
makes changes in the visited file), save `foo.c' (note that
`save-buffer' is the function that `C-x C-s' is bound to), and then
exit to the shell that this command was done with.  `-batch'
guarantees there will be no problem redirecting output to `log',
because Emacs will not assume that it has a display terminal to work
with.


File: emacs,  Node: Basic,  Next: Undo,  Prev: Command Switches,  Up: Top

Basic Editing Commands
**********************

   We now give the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, you might
learn it more easily by running the Emacs learn-by-doing tutorial.  To
do this, type `Control-h t' (`help-with-tutorial').

Inserting Text
==============

   To insert printing characters into the text you are editing, just
type them.  This inserts the character into the buffer at the cursor
(that is, at "point"; *note Point::.).  The cursor moves forward.  Any
characters after the cursor move forward too.  If the text in the
buffer is `FOOBAR', with the cursor before the `B', then if you type
`XX', you get `FOOXXBAR', with the cursor still before the `B'.

   To "delete" text you have just inserted, use DEL.  DEL deletes the
character BEFORE the cursor (not the one that the cursor is on top of
or under; that is the character AFTER the cursor).  The cursor and all
characters after it move backwards.  Therefore, if you type a printing
character and then type DEL, they cancel out.

   To end a line and start typing a new one, type RET.  This inserts a
newline character in the buffer.  If point is in the middle of a line,
RET splits the line.  Typing DEL when the cursor is at the beginning
of a line rubs out the newline before the line, thus joining the line
with the preceding line.

   Emacs will split lines automatically when they become too long, if
you turn on a special mode called "Auto Fill" mode.  *Note Filling::,
for how to use Auto Fill mode.

   Customization information: DEL in most modes runs the command named
`delete-backward-char'; RET runs the command `newline', and
self-inserting printing characters run the command `self-insert',
which inserts whatever character was typed to invoke it.  Some major
modes rebind DEL to other commands.

   Direct insertion works for printing characters and SPC, but other
characters act as editing commands and do not insert themselves.  If
you need to insert a control character or a character whose code is
above 200 octal, you must "quote" it by typing the character
`control-q' (`quoted-insert') first.  There are two ways to use `C-q':

   * `Control-q' followed by any non-graphic character (even `C-g')
     inserts that character.

   * `Control-q' followed by three octal digits inserts the character
     with the specified character code.

A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::.).

   If you prefer to have text characters replace (overwrite) existing
text rather than shove it to the right, you can enable Overwrite mode,
a minor mode.  *Note Minor Modes::.

Changing the Location of Point
==============================

   To do more than insert characters, you have to know how to move
point (*note Point::.).  Here are a few of the commands for doing that.

`C-a'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
     Move to the end of the line (`end-of-line').

`C-f'
     Move forward one character (`forward-char').

`C-b'
     Move backward one character (`backward-char').

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`C-n'
     Move down one line, vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you end in the middle of the
     next.  When on the last line of text, `C-n' creates a new line
     and moves onto it.

`C-p'
     Move up one line, vertically (`previous-line').

`C-l'
     Clear the screen and reprint everything (`recenter').  Text moves
     on the screen to bring point to the center of the window.

`M-r'
     Move point to left margin on the line halfway down the screen or
     window (`move-to-window-line').  Text does not move on the
     screen.  A numeric argument says how many screen lines down from
     the top of the window (zero for the top).  A negative argument
     counts from the bottom (-1 for the bottom).

`C-t'
     Transpose two characters, the ones before and after the cursor
     (`transpose-chars').

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`M-x goto-char'
     Read a number N and move cursor to character number N.  Position
     1 is the beginning of the buffer.

`M-x goto-line'
     Read a number N and move cursor to line number N.  Line 1 is the
     beginning of the buffer.

`C-x C-n'
     Use the current column of point as the "semipermanent goal
     column" for `C-n' and `C-p' (`set-goal-column').  Henceforth,
     those commands always move to this column in each line moved
     into, or as close as possible given the contents of the line. 
     This goal column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' once again
     try to avoid changing the horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then
`C-n' and `C-p' when at the end of the starting line move to the end
of the line.  Normally, `track-eol' is `nil'.

Erasing Text
============

`DEL'
     Delete the character before the cursor (`delete-backward-char').

`C-d'
     Delete the character after the cursor (`delete-char').

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-DEL'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the DEL key which deletes the character
before the cursor.  Another key, `Control-d', deletes the character
after the cursor, causing the rest of the text on the line to shift
left.  If `Control-d' is typed at the end of a line, that line and the
next line are joined together.

   To erase a larger amount of text, use the `Control-k' key, which
kills a line at a time.  If `C-k' is done at the beginning or middle of
a line, it kills all the text up to the end of the line.  If `C-k' is
done at the end of a line, it joins that line and the next line.

   *Note Killing::, for more flexible ways of killing text.

Files
=====

   The commands above are sufficient for creating and altering text in
an Emacs buffer; the more advanced Emacs commands just make things
easier.  But to keep any text permanently you must put it in a "file".
 Files are named units of text which are stored by the operating
system for you to retrieve later by name.  To look at or use the
contents of a file in any way, including editing the file with Emacs,
you must specify the file name.

   Consider a file named `/usr/rms/foo.c'.  In Emacs, to begin editing
this file, type

     C-x C-f /usr/rms/foo.c RET

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type RET to terminate the argument (*note
Minibuffer::.).

   Emacs obeys the command by "visiting" the file: creating a buffer,
copying the contents of the file into the buffer, and then displaying
the buffer for you to edit.  You can make changes in it, and then
"save" the file by typing `C-x C-s' (`save-buffer').  This makes the
changes permanent by copying the altered contents of the buffer back
into the file `/usr/rms/foo.c'.  Until then, the changes are only
inside your Emacs, and the file `foo.c' is not changed.

   To create a file, just visit the file with `C-x C-f' as if it
already existed.  Emacs will make an empty buffer in which you can
insert the text you want to put in the file.  When you save your text
with `C-x C-s', the file will be created.

   Of course, there is a lot more to learn about using files.  *Note
Files::.

Help
====

   If you forget what a key does, you can find out with the Help
character, which is `C-h'.  Type `C-h k' followed by the key you want
to know about; for example, `C-h k C-n' tells you all about what `C-n'
does.  `C-h' is a prefix key; `C-h k' is just one of its subcommands
(the command `describe-key').  The other subcommands of `C-h' provide
different kinds of help.  Type `C-h' three times to get a description
of all the help facilities.  *Note Help::.

* Menu:

* Blank Lines::        Commands to make or delete blank lines.
* Continuation Lines:: Lines too wide for the screen.
* Position Info::      What page, line, row, or column is point on?
* Arguments::	       Numeric arguments for repeating a command.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic,  Up: Basic

Blank Lines
===========

   Here are special commands and techniques for putting in and taking
out blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   When you want to insert a new line of text before an existing line,
you can do it by typing the new line of text, followed by RET. 
However, it may be easier to see what you are doing if you first make
a blank line and then insert the desired text into it.  This is easy
to do using the key `C-o' (`open-line'), which inserts a newline after
point but leaves point in front of the newline.  After `C-o', type the
text for the new line.  `C-o F O O' has the same effect as `F O O
RET', except for the final location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it an argument to tell it how many blank lines to make. 
*Note Arguments::, for how.

   If you have many blank lines in a row and want to get rid of them,
use `C-x C-o' (`delete-blank-lines').  When point is on a blank line
which is adjacent to at least one other blank line, `C-x C-o' deletes
all but one of the consecutive blank lines, leaving exactly one.  With
point on a blank line with no other blank line adjacent to it, the
sole blank line is deleted, leaving none.  When point is on a nonblank
line, `C-x C-o' deletes any blank lines following that nonblank line.


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

Continuation Lines
==================

   If you add too many characters to one line, without breaking it
with a RET, the line will grow to occupy two (or more) lines on the
screen, with a `\' at the extreme right margin of all but the last of
them.  The `\' says that the following screen line is not really a
distinct line in the text, but just the "continuation" of a line too
long to fit the screen.  Sometimes it is nice to have Emacs insert
newlines automatically when a line gets too long; for this, use Auto
Fill mode (*note Filling::.).

   Instead of continuation, long lines can be displayed by
"truncation".  This means that all the characters that do not fit in
the width of the screen or window do not appear at all.  They remain
in the buffer, temporarily invisible.  `$' is used in the last column
instead of `\' to inform you that truncation is in effect.

   Continuation can be turned off for a particular buffer by setting
the variable `truncate-lines' to non-`nil' in that buffer.  Truncation
instead of continuation also happens whenever horizontal scrolling is
in use, and optionally whenever side-by-side windows are in use (*note
Windows::.).  Altering the value of `truncate-lines' makes it local to
the current buffer; until that time, the default value is in effect. 
The default is initially `nil'.  *Note Locals::.


File: emacs,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

Cursor Position Information
===========================

   If you are accustomed to other display editors, you may be
surprised that Emacs does not always display the page number or line
number of point in the mode line.  This is because the text is stored
in a way that makes it difficult to compute this information. 
Displaying them all the time would be intolerably slow.  They are not
needed very often in Emacs anyway, but there are commands to compute
them and print them.

`M-x what-page'
     Print page number of point, and line number within page.

`M-x what-line'
     Print line number of point in the buffer.

`M-='
     Print number of lines in the current region
     (`count-lines-region').

`C-x ='
     Print character code of character after point, character position
     of point, and column of point (`what-cursor-position').

   There are two commands for printing line numbers.  `M-x what-line'
counts lines from the beginning of the file and prints the line number
point is on.  The first line of the file is line number 1.  These
numbers can be used as arguments to `M-x goto-line'.  By contrast, `M-x
what-page' counts pages from the beginning of the file, and counts
lines within the page, printing both of them.  *Note Pages::.

   While on this subject, we might as well mention `M-='
(`count-lines-region'), which prints the number of lines in the region
(*note Mark::.).  *Note Pages::, for the command `C-x l' which counts
the lines in the current page.

   The command `C-x =' (`what-cursor-position') can be used to find out
the column that the cursor is in, and other miscellaneous information
about point.  It prints a line in the echo area that looks like this:

     Char: x (0170)  point=65986 of 563027(12%)  x=44

(In fact, this is the output produced when point is before the `x=44'
in the example.)

   The two values after `Char:' describe the character following point,
first by showing it and second by giving its octal character code.

   `point=' is followed by the position of point expressed as a
character count.  The front of the buffer counts as position 1, one
character later as 2, and so on.  The next, larger number is the total
number of characters in the buffer.  Afterward in parentheses comes
the position expressed as a percentage of the total size.

   `x=' is followed by the horizontal position of point, in columns
from the left edge of the window.

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily invisible, `C-x =' prints additional
text describing the current visible range.  For example, it might say

     Char: x (0170)  point=65986 of 563025(12%) <65102 - 68533>  x=44

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between
those two positions are the visible ones.  *Note Narrowing::.

   If point is at the end of the buffer (or the end of the visible
part), `C-x =' omits any description of the character after point. 
The output looks like

     point=563026 of 563025(100%)  x=0


File: emacs,  Node: Arguments,  Prev: Position Info,  Up: Basic

Numeric Arguments
=================

   Any Emacs command can be given a "numeric argument".  Some commands
interpret the argument as a repetition count.  For example, giving an
argument of ten to the key `C-f' (the command `forward-char', move
forward one character) moves forward ten characters.  With these
commands, no argument is equivalent to an argument of one.  Negative
arguments are allowed.  Often they tell a command to move or act
backwards.

   If your terminal keyboard has a META key, the easiest way to
specify a numeric argument is to type digits and/or a minus sign while
holding down the the META key.  For example,
     M-5 C-n

would move down five lines.  The characters `Meta-1', `Meta-2', and so
on, as well as `Meta--', do this because they are keys bound to
commands (`digit-argument' and `negative-argument') that are defined
to contribute to an argument for the next command.

   Another way of specifying an argument is to use the `C-u'
(`universal-argument') command followed by the digits of the argument. 
With `C-u', you can type the argument digits without holding down
shift keys.  To type a negative argument, start with a minus sign. 
Just a minus sign normally means -1.  `C-u' works on all terminals.

   `C-u' followed by a character which is neither a digit nor a minus
sign has the special meaning of "multiply by four".  It multiplies the
argument for the next command by four.  `C-u' twice multiplies it by
sixteen.  Thus, `C-u C-u C-f' moves forward sixteen characters.  This
is a good way to move forward "fast", since it moves about 1/5 of a
line in the usual size screen.  Other useful combinations are `C-u
C-n', `C-u C-u C-n' (move down a good fraction of a screen), `C-u C-u
C-o' (make "a lot" of blank lines), and `C-u C-k' (kill four lines).

   Some commands care only about whether there is an argument, and not
about its value.  For example, the command `M-q' (`fill-paragraph')
with no argument fills text; with an argument, it justifies the text
as well.  (*Note Filling::, for more information on `M-q'.)  Just
`C-u' is a handy way of providing an argument for such commands.

   Some commands use the value of the argument as a repeat count, but
do something peculiar when there is no argument.  For example, the
command `C-k' (`kill-line') with argument N kills N lines, including
their terminating newlines.  But `C-k' with no argument is special: it
kills the text up to the next newline, or, if point is right at the
end of the line, it kills the newline itself.  Thus, two `C-k'
commands with no arguments can kill a nonblank line, just like `C-k'
with an argument of one.  (*Note Killing::, for more information on
`C-k'.)

   A few commands treat a plain `C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases will be
described when they come up; they are always for reasons of
convenience of use of the individual command.


File: emacs,  Node: Undo,  Next: Minibuffer,  Prev: Basic,  Up: Top

Undoing Changes
***************

   Emacs allows all changes made in the text of a buffer to be undone,
up to a certain amount of change (8000 characters).  Each buffer
records changes individually, and the undo command always applies to
the current buffer.  Usually each editing command makes a separate
entry in the undo records, but some commands such as `query-replace'
make many entries, and very simple commands such as self-inserting
characters are often grouped to make undoing less tedious.

`C-x u'
     Undo one batch of changes (usually, one command worth) (`undo').

`C-_'
     The same.

   The command `C-x u' or `C-_' is how you undo.  The first time you
give this command, it undoes the last change.  Point moves to the text
affected by the undo, so you can see what was undone.

   Consecutive repetitions of the `C-_' or `C-x u' commands undo
earlier and earlier changes, back to the limit of what has been
recorded.  If all recorded changes have already been undone, the undo
command prints an error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting at this moment, the previous undo commands are
considered ordinary changes that can themselves be undone.  Thus, you
can redo changes you have undone by typing `C-f' or any other command
that will have no important effect, and then using more undo commands.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  At this time, all the
modifications you made have been cancelled.  If you do not remember
whether you changed the buffer deliberately, type `C-_' once, and when
you see the last change you made undone, you will remember why you
made it.  If it was an accident, leave it undone.  If it was
deliberate, redo the change as described in the preceding paragraph.

   Whenever an undo command makes the stars disappear from the mode
line, it means that the buffer contents are the same as they were when
the file was last read in or saved.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit. 
Also, minibuffers, help buffers and documentation buffers don't record
undo information.

   At most 8000 or so characters of deleted or modified text can be
remembered in any one buffer for reinsertion by the undo command. 
Also, there is a limit on the number of individual insert, delete or
change actions that can be remembered.

   The reason the `undo' command has two keys, `C-x u' and `C-_', set
up to run it is that it is worthy of a single-character key, but the
way to type `C-_' on some keyboards is not obvious.  `C-x u' is an
alternative you can type in the same fashion on any terminal.


File: emacs,  Node: Minibuffer,  Next: M-x,  Prev: Undo,  Up: Top

The Minibuffer
**************

   The "minibuffer" is the facility used by Emacs commands to read
arguments more complicated than a single number.  Minibuffer arguments
can be file names, buffer names, Lisp function names, Emacs command
names, Lisp expressions, and many other things, depending on the
command reading the argument.  The usual Emacs editing commands can be
used in the minibuffer to edit the argument.

   When the minibuffer is in use, it appears in the echo area, and the
terminal's cursor moves there.  The beginning of the minibuffer line
displays a "prompt" which says what kind of input you should supply and
how it will be used.  Often this prompt is derived from the name of the
command that the argument is for.  The prompt normally ends with a
colon.

   Sometimes a "default argument" appears in parentheses after the
colon; it too is part of the prompt.  The default will be used as the
argument value if you enter an empty argument (e.g., just type RET). 
For example, commands that read buffer names always show a default,
which is the name of the buffer that will be used if you type just RET.

   The simplest way to give a minibuffer argument is to type the text
you want, terminated by RET which exits the minibuffer.  You can get
out of the minibuffer, canceling the command that it was for, by typing
`C-g'.

   Since the minibuffer uses the screen space of the echo area, it can
conflict with other ways Emacs customarily uses the echo area.  Here
is how Emacs handles such conflicts:

   * If a command gets an error while you are in the minibuffer, this
     does not cancel the minibuffer.  However, the echo area is needed
     for the error message and therefore the minibuffer itself is
     hidden for a while.  It comes back after a few seconds, or as
     soon as you type anything.

   * If in the minibuffer you use a command whose purpose is to print a
     message in the echo area, such as `C-x =', the message is printed
     normally, and the minibuffer is hidden for a while.  It comes back
     after a few seconds, or as soon as you type anything.

   * Echoing of keystrokes does not take place while the minibuffer is
     in use.

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Repetition::		  Re-executing commands that used the minibuffer.


File: emacs,  Node: Minibuffer File,  Next: Minibuffer Edit,  Prev: Minibuffer,  Up: Minibuffer

Minibuffers for File Names
==========================

   Sometimes the minibuffer starts out with text in it.  For example,
when you are supposed to give a file name, the minibuffer starts out
containing the "default directory", which ends with a slash.  This is
to inform you which directory the file will be found in if you do not
specify a directory.  For example, the minibuffer might start out with

     Find File: /u2/emacs/src/

where `Find File: ' is the prompt.  Typing `buffer.c' specifies the
file `/u2/emacs/src/buffer.c'.  To find files in nearby directories,
use `..'; thus, if you type `../lisp/simple.el', the file that you
visit will be the one named `/u2/emacs/lisp/simple.el'. 
Alternatively, you can kill with `M-DEL' the directory names you don't
want (*note Words::.).

   You can also type an absolute file name, one starting with a slash
or a tilde, ignoring the default directory.  For example, to find the
file `/etc/termcap', just type the name, giving

     Find File: /u2/emacs/src//etc/termcap

Two slashes in a row are not normally meaningful in Unix file names,
but they are allowed in GNU Emacs.  They mean, "ignore everything
before the second slash in the pair."  Thus, `/u2/emacs/src/' is
ignored, and you get the file `/etc/termcap'.

   If you set `insert-default-directory' to `nil', the default
directory is not inserted in the minibuffer.  This way, the minibuffer
starts out empty.  But the name you type, if relative, is still
interpreted with respect to the same default directory.


File: emacs,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

Editing in the Minibuffer
=========================

   The minibuffer is an Emacs buffer (albeit a peculiar one), and the
usual Emacs commands are available for editing the text of an argument
you are entering.

   Since RET in the minibuffer is defined to exit the minibuffer,
inserting a newline into the minibuffer must be done with `C-o' or with
`C-q LFD'.  (Recall that a newline is really the LFD character.)

   The minibuffer has its own window which always has space on the
screen but acts as if it were not there when the minibuffer is not in
use.  When the minibuffer is in use, its window is just like the
others; you can switch to another window with `C-x o', edit text in
other windows and perhaps even visit more files, before returning to
the minibuffer to submit the argument.  You can kill text in another
window, return to the minibuffer window, and then yank the text to use
it in the argument.  *Note Windows::.

   There are some restrictions on the use of the minibuffer window,
however.  You cannot switch buffers in it--the minibuffer and its
window are permanently attached.  Also, you cannot split or kill the
minibuffer window.  But you can make it taller in the normal fashion
with `C-x ^'.

   If while in the minibuffer you issue a command that displays help
text of any sort in another window, then that window is identified as
the one to scroll if you type `C-M-v' while in the minibuffer.  This
lasts until you exit the minibuffer.  This feature comes into play if
a completing minibuffer gives you a list of possible completions.

   Recursive use of the minibuffer is supported by Emacs.  However, it
is easy to do this by accident (because of autorepeating keyboards, for
example) and get confused.  Therefore, most Emacs commands that use the
minibuffer refuse to operate if the minibuffer window is selected.  If
the minibuffer is active but you have switched to a different window,
recursive use of the minibuffer is allowed--if you know enough to try
to do this, you probably will not get confused.

   If you set the variable `enable-recursive-minibuffers' to be
non-`nil', recursive use of the minibuffer is always allowed.


File: emacs,  Node: Completion,  Next: Repetition,  Prev: Minibuffer Edit,  Up: Minibuffer

Completion
==========

   When appropriate, the minibuffer provides a "completion" facility. 
This means that you type enough of the argument to determine the rest,
based on Emacs's knowledge of which arguments make sense, and Emacs
visibly fills in the rest, or as much as can be determined from the
part you have typed.

   When completion is available, certain keys--TAB, RET, and SPC--are
redefined to complete an abbreviation present in the minibuffer into a
longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the argument. 
`?' is defined to display a list of possible completions of what you
have inserted.

   For example, when the minibuffer is being used by `Meta-x' to read
the name of a command, it is given a list of all available Emacs
command names to complete against.  The completion keys match the text
in the minibuffer against all the command names, find any additional
characters of the name that are implied by the ones already present in
the minibuffer, and add those characters to the ones you have given.

   Case is normally significant in completion, because it is
significant in most of the names that you can complete (buffer names,
file names and command names).  Thus, `fo' will not complete to `Foo'.
 When you are completing a name in which case does not matter, case
may be ignored for completion's sake if the program said to do so.

Completion Example
------------------

   A concrete example may help here.  If you type `Meta-x au TAB', the
TAB looks for alternatives (in this case, command names) that start
with `au'.  There are only two: `auto-fill-mode' and `auto-save-mode'.
 These are the same as far as `auto-', so the `au' in the minibuffer
changes to `auto-'.

   If you type TAB again immediately, there are multiple possibilities
for the very next character--it could be `s' or `f'--so no more
characters are added; but a list of all possible completions is
displayed in another window.

   If you go on to type `f TAB', this TAB sees `auto-f'.  The only
command name starting this way is `auto-fill-mode', so completion
inserts the rest of that.  You now have `auto-fill-mode' in the
minibuffer after typing just `au TAB f TAB'.  Note that TAB has this
effect because in the minibuffer it is bound to the function
`minibuffer-complete' when completion is supposed to be done.

Completion Commands
-------------------

   Here is a list of all the completion commands, defined in the
minibuffer when completion is available.

`TAB'
     Complete the text in the minibuffer as much as possible 
      (`minibuffer-complete').

`SPC'
     Complete the text in the minibuffer but don't add or fill out more
     than one word (`minibuffer-complete-word').

`RET'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

   SPC completes much like TAB, but never goes beyond the next hyphen
or space.  If you have `auto-f' in the minibuffer and type SPC, it
finds that the completion is `auto-fill-mode', but it stops completing
after `fill-'.  This gives `auto-fill-'.  Another SPC at this point
completes all the way to `auto-fill-mode'.  SPC in the minibuffer runs
the function `minibuffer-complete-word' when completion is available.

   There are three different ways that RET can work in completing
minibuffers, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `C-x k' reads the name of a buffer to kill, it is meaningless to
     give anything but the name of an existing buffer.  In strict
     completion, RET refuses to exit if the text in the minibuffer
     does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     RET exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, RET does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second RET will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string whatever is
     meaningful, and the list of completion alternatives is just a
     guide.  For example, when `C-x C-f' reads the name of a file to
     visit, any file name is allowed, in case you want to create a
     file.  In permissive completion, RET takes the text in the
     minibuffer exactly as given, without completing it.

   The completion commands display a list of all possible completions
in a window whenever there is more than one possibility for the very
next character.  Also, typing `?' explicitly requests such a list.  The
list of completions counts as help text, so `C-M-v' typed in the
minibuffer scrolls the list.

   When completion is done on file names, certain file names are
usually ignored.  The variable `completion-ignored-extensions'
contains a list of strings; a file whose name ends in any of those
strings is ignored as a possible completion.  The standard value of
this variable has several elements including `".o"', `".elc"',
`".dvi"' and `"~"'.  The effect is that, for example, `foo' can
complete to `foo.c' even though `foo.o' exists as well.  If the only
possible completions are files that end in "ignored" strings, then
they are not ignored.

   Normally, a completion command that finds the next character is
undetermined automatically displays a list of all possible
completions.  If the variable `completion-auto-help' is set to `nil',
this does not happen, and you must type `?' to display the possible
completions.


File: emacs,  Node: Repetition,  Prev: Completion,  Up: Minibuffer

Repeating Minibuffer Commands
=============================

   Every command that uses the minibuffer at least once is recorded on
a special history list, together with the values of the minibuffer
arguments, so that you can repeat the command easily.  In particular,
every use of `Meta-x' is recorded, since `M-x' uses the minibuffer to
read the command name.

`C-x ESC'
     Re-execute a recent minibuffer command 
     (`repeat-complex-command').

`M-p'
     Within `C-x ESC', move to previous recorded command
     (`previous-complex-command').

`M-n'
     Within `C-x ESC', move to the next (more recent) recorded command
     (`next-complex-command').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     ESC' can repeat, most recent first.

   `C-x ESC' is used to re-execute a recent minibuffer-using command. 
With no argument, it repeats the last such command.  A numeric
argument specifies which command to repeat; one means the last one, and
larger numbers specify earlier ones.

   `C-x ESC' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  If you type just RET, the command is repeated as
before.  You can also change the command by editing the Lisp
expression.  Whatever expression you finally submit is what will be
executed.  The repeated command is added to the front of the command
history unless it is identical to the most recently executed command
already there.

   Even if you don't understand Lisp syntax, it will probably be
obvious which command is displayed for repetition.  If you do not
change the text, you can be sure it will repeat exactly as before.

   Once inside the minibuffer for `C-x ESC', if the command shown to
you is not the one you want to repeat, you can move around the list of
previous commands using `M-n' and `M-p'.  `M-p' replaces the contents
of the minibuffer with the next earlier recorded command, and `M-n'
replaces them with the next later command.  After finding the desired
previous command, you can edit its expression as usual and then
resubmit it by typing RET as usual.  Any editing you have done on the
command to be repeated is lost if you use `M-n' or `M-p'.

   `M-p' is more useful than `M-n', since more often you will
initially request to repeat the most recent command and then decide to
repeat an older one instead.  These keys are specially defined within
`C-x ESC' to run the commands `previous-complex-command' and
`next-complex-command'.

   The list of previous minibuffer-using commands is stored as a Lisp
list in the variable `command-history'.  Each element is a Lisp
expression which describes one command and its arguments.  Lisp
programs can reexecute a command by feeding the corresponding
`command-history' element to `eval'.

