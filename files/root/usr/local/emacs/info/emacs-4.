This is Info file ../info/emacs, produced by Makeinfo-1.43 from the
input file emacs.tex.

   This file documents the GNU Emacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: emacs,  Node: Display Vars,  Prev: Selective Display,  Up: Display

Variables Controlling Display
=============================

   This section contains information for customization only.  Beginning
users should skip it.

   The variable `mode-line-inverse-video' controls whether the mode
line is displayed in inverse video (assuming the terminal supports it);
`nil' means don't do so.  *Note Mode Line::.

   If the variable `inverse-video' is non-`nil', Emacs attempts to
invert all the lines of the display from what they normally are.

   If the variable `visible-bell' is non-`nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a
way to make the screen blink.

   When you reenter Emacs after suspending, Emacs normally clears the
screen and redraws the entire display.  On some terminals with more
than one page of memory, it is possible to arrange the termcap entry
so that the `ti' and `te' strings (output to the terminal when Emacs is
entered and exited, respectively) switch between pages of memory so as
to use one page for Emacs and another page for other output.  Then you
might want to set the variable `no-redraw-on-reenter' non-`nil' so that
Emacs will assume, when resumed, that the screen page it is using still
contains what Emacs last wrote there.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero meaning don't echo at all.
 *Note Echo Area::.

   If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, all except newline
and tab.  Altering the value of `ctl-arrow' makes it local to the
current buffer; until that time, the default value is in effect.  The
default is initially `t'.  *Note Locals::.

   Normally, a tab character in the buffer is displayed as whitespace
which extends to the next display tab stop position, and display tab
stops come at intervals equal to eight spaces.  The number of spaces
per tab is controlled by the variable `tab-width', which is made local
by changing it, just like `ctl-arrow'.  Note that how the tab character
in the buffer is displayed has nothing to do with the definition of
TAB as a command.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots do not appear at the end of a line that precedes invisible
lines.  Then there is no visible indication of the invisible lines. 
This variable too becomes local automatically when set.


File: emacs,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

Searching and Replacement
*************************

   Like other editors, Emacs has commands for searching for
occurrences of a string.  The principal search command is unusual in
that it is "incremental"; it begins to search before you have finished
typing the search string.  There are also nonincremental search
commands more like those of other editors.

   Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a
fancy replacement command called `query-replace' which asks
interactively which occurrences to replace.

* Menu:

* Incremental Search::     Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::            Search for sequence of words.
* Regexp Search::          Search for match for a regexp.
* Regexps::                Syntax of regular expressions.
* Search Case::            To ignore case while searching, or not.
* Replace::                Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.


File: emacs,  Node: Incremental Search,  Next: Nonincremental Search,  Prev: Search,  Up: Search

Incremental Search
==================

   An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string,
Emacs shows you where the string (as you have typed it so far) would
be found.  When you have typed enough characters to identify the place
you want, you can stop.  Depending on what you will do next, you may
or may not need to terminate the search explicitly with an ESC first.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

   `C-s' starts an incremental search.  `C-s' reads characters from
the keyboard and positions the cursor at the first occurrence of the
characters that you have typed.  If you type `C-s' and then `F', the
cursor moves right after the first `F'.  Type an `O', and see the
cursor move to after the first `FO'.  After another `O', the cursor is
after the first `FOO' after the place where you started the search. 
Meanwhile, the search string `FOO' has been echoed in the echo area.

   The echo area display ends with three dots when actual searching is
going on.  When search is waiting for more input, the three dots are
removed.  (On slow terminals, the three dots are not displayed.)

   If you make a mistake in typing the search string, you can erase
characters with DEL.  Each DEL cancels the last character of search
string.  This does not happen until Emacs is ready to read another
input character; first it must either find, or fail to find, the
character you want to erase.  If you do not want to wait for this to
happen, use `C-g' as described below.

   When you are satisfied with the place you have reached, you can type
ESC, which stops searching, leaving the cursor where the search
brought it.  Also, any command not specially meaningful in searches
stops the searching and is then executed.  Thus, typing `C-a' would
exit the search and then move to the beginning of the line.  ESC is
necessary only if the next command you want to type is a printing
character, DEL, ESC, or another control character that is special
within searches (`C-q', `C-w', `C-r', `C-s' or `C-y').

   Sometimes you search for `FOO' and find it, but not the one you
expected to find.  There was a second `FOO' that you forgot about,
before the one you were looking for.  In this event, type another `C-s'
to move to the next occurrence of the search string.  This can be done
any number of times.  If you overshoot, you can cancel some `C-s'
characters with DEL.

   After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again".

   If your string is not found at all, the echo area says `Failing
I-Search'.  The cursor is after the place where Emacs found as much of
your string as it could.  Thus, if you search for `FOOT', and there is
no `FOOT', you might see the cursor after the `FOO' in `FOOL'.  At
this point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the
place you have found, you can type ESC or some other Emacs command to
"accept what the search offered".  Or you can type `C-g', which
removes from the search string the characters that could not be found
(the `T' in `FOOT'), leaving those that were found (the `FOO' in
`FOOT').  A second `C-g' at that point cancels the search entirely,
returning point to where it was when the search started.

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with `C-r' starts again from the end.  This is
called "wrapping around".  `Wrapped' appears in the search prompt once
this has happened.

   The `C-g' "quit" character does special things during searches;
just what it does depends on the status of the search.  If the search
has found what you specified and is waiting for input, `C-g' cancels
the entire search.  The cursor moves back to where you started the
search.  If `C-g' is typed when there are characters in the search
string that have not been found--because Emacs is still searching for
them, or because it has failed to find them--then the search string
characters which have not been found are discarded from the search
string.  With them gone, the search is now successful and waiting for
more input, so a second `C-g' will cancel the entire search.

   To search for a control character such as `C-s' or DEL or ESC, you
must quote it by typing `C-q' first.  This function of `C-q' is
analogous to its meaning as an Emacs command: it causes the following
character to be treated the way a graphic character would normally be
treated in the same context.

   You can change to searching backwards with `C-r'.  If a search fails
because the place you started was too late in the file, you should do
this.  Repeated `C-r' keeps looking for more occurrences backwards.  A
`C-s' starts going forwards again.  `C-r' in a search can be cancelled
with DEL.

   If you know initially that you want to search backwards, you can
use `C-r' instead of `C-s' to start the search, because `C-r' is also
a key running a command (`isearch-backward') to search backward.

   The characters `C-y' and `C-w' can be used in incremental search to
grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the word after point as part of the search string, advancing
point over that word.  Another `C-s' to repeat the search will then
search for a string including that word.  `C-y' is similar to `C-w'
but copies all the rest of the current line into the search string.

   All the characters special in incremental search can be changed by
setting the following variables:

`search-delete-char'
     Character to delete from incremental search string (normally DEL).

`search-exit-char'
     Character to exit incremental search (normally ESC).

`search-quote-char'
     Character to quote special characters for incremental search
     (normally `C-q').

`search-repeat-char'
     Character to repeat incremental search forwards (normally `C-s').

`search-reverse-char'
     Character to repeat incremental search backwards (normally `C-r').

`search-yank-line-char'
     Character to pull rest of line from buffer into search string
     (normally `C-y').

`search-yank-word-char'
     Character to pull next word from buffer into search string
     (normally `C-w').

Slow Terminal Incremental Search
--------------------------------

   Incremental search on a slow terminal uses a modified style of
display that is designed to take less time.  Instead of redisplaying
the buffer at each place the search gets to, it creates a new
single-line window and uses that to display the line that the search
has found.  The single-line window comes into play as soon as point
gets outside of the text that is already on the screen.

   When the search is terminated, the single-line window is removed. 
Only at this time is the window in which the search was done
redisplayed to show its new value of point.

   The three dots at the end of the search string, normally used to
indicate that searching is going on, are not displayed in slow style
display.

   The slow terminal style of display is used when the terminal baud
rate is less than or equal to the value of the variable
`search-slow-speed', initially 1200.

   The number of lines to use in slow terminal search display is
controlled by the variable `search-slow-window-lines'.  1 is its
normal value.


File: emacs,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

Nonincremental Search
=====================

   Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

`C-s ESC STRING RET'
     Search for STRING.

`C-r ESC STRING RET'
     Search backward for STRING.

   To do a nonincremental search, first type `C-s ESC'.  This enters
the minibuffer to read the search string; terminate the string with
RET, and then the search is done.  If the string is not found the
search command gets an error.

   The way `C-s ESC' works is that the `C-s' invokes incremental
search, which is specially programmed to invoke nonincremental search
if the argument you give it is empty.  (Such an empty argument would
otherwise be useless.)  `C-r ESC' also works this way.

   Forward and backward nonincremental searches are implemented by the
commands `search-forward' and `search-backward'.  These commands may
be bound to keys in the usual manner.  The reason that incremental
search is programmed to invoke them as well is that `C-s ESC' is the
traditional sequence of characters used in Emacs to invoke
nonincremental search.

   However, nonincremental searches performed using `C-s ESC' do not
call `search-forward' right away.  The first thing done is to see if
the next character is `C-w', which requests a word search.  *Note Word
Search::.


File: emacs,  Node: Word Search,  Next: Regexp Search,  Prev: Nonincremental Search,  Up: Search

Word Search
===========

   Word search searches for a sequence of words without regard to how
the words are separated.  More precisely, you type a string of many
words, using single spaces to separate them, and the string can be
found even if there are multiple spaces, newlines or other punctuation
between the words.

   Word search is useful in editing documents formatted by text
formatters.  If you edit while looking at the printed, formatted
version, you can't tell where the line breaks are in the source file. 
With word search, you can search without having to know them.

`C-s ESC C-w WORDS RET'
     Search for WORDS, ignoring differences in punctuation.

`C-r ESC C-w WORDS RET'
     Search backward for WORDS, ignoring differences in punctuation.

   Word search is a special case of nonincremental search and is
invoked with `C-s ESC C-w'.  This is followed by the search string,
which must always be terminated with RET.  Being nonincremental, this
search does not start until the argument is terminated.  It works by
constructing a regular expression and searching for that.  *Note
Regexp Search::.

   A backward word search can be done by `C-r ESC C-w'.

   Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  These commands may
be bound to keys in the usual manner.  The reason that incremental
search is programmed to invoke them as well is that `C-s ESC C-w' is
the traditional Emacs sequence of keys for word search.


File: emacs,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

Regular Expression Search
=========================

   A "regular expression" ("regexp", for short) is a pattern that
denotes a set of strings, possibly an infinite set.  Searching for
matches for a regexp is a very powerful operation that editors on Unix
systems have traditionally offered.  In GNU Emacs, you can search for
the next match for a regexp either incrementally or not.

   Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp').  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the
regexp longer, and the new regexp is searched for.  A reverse regexp
search command `isearch-backward-regexp' also exists but no key runs
it.

   All of the control characters that do special things within an
ordinary incremental search have the same function in incremental
regexp search.  Typing `C-s' or `C-r' immediately after starting the
search retrieves the last incremental search regexp used; that is to
say, incremental regexp and non-regexp searches have independent
defaults.

   Note that adding characters to the regexp in an incremental regexp
search does not make the cursor move back and start again.  Perhaps it
ought to; I am not sure.  As it stands, if you have searched for `foo'
and you add `\|bar', the search will not check for a `bar' in the
buffer before the `foo'.

   Nonincremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke these
with `M-x', or bind them to keys.  Also, you can call
`re-search-forward' by way of incremental regexp search with `C-M-s
ESC'.


File: emacs,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that character and
nothing else.  The special characters are `$', `^', `.', `*', `+',
`?', `[', `]' and `\'; no new special characters will be defined.  Any
other character appearing in a regular expression is ordinary, unless
a `\' precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does not match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.

   Any two regular expressions A and B can be concatenated.  The
result is a regular expression which matches a string if A matches
some amount of the beginning of that string and B matches the rest of
the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b' which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a suffix, which means the
     preceding regular expression is to be repeated as many times as
     possible.  In `fo*', the `*' applies to the `o', so `fo*' matches
     one `f' followed by any number of `o's.  The case of zero `o's is
     allowed: `fo*' does match `f'.

     `*' always applies to the smallest possible preceding expression.
      Thus, `fo*' has a repeating `o', not a repeating `fo'.

     The matcher processes a `*' construct by matching, immediately,
     as many repetitions as can be found.  Then it continues with the
     rest of the pattern.  If that fails, backtracking occurs,
     discarding some of the matches of the `*'-modified construct in
     case that makes it possible to match the rest of the pattern. 
     For example, matching `ca*ar' against the string `caaar', the
     `a*' first tries to match all three `a's; but the rest of the
     pattern is `ar' and there is only `r' left to match, so this try
     fails.  The next alternative is for `a*' to match only two `a's. 
     With this choice, the rest of the regexp matches successfully.

`+'
     Is a suffix character similar to `*' except that it requires that
     the preceding expression be matched at least once.  So, for
     example, `ca+r' will match the strings `car' and `caaaar' but not
     the string `cr', whereas `ca*r' would match all three strings.

`?'
     Is a suffix character similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' will match `car' or `cr'; nothing else.

`[ ... ]'
     `[' begins a "character set", which is terminated by a `]'.  In
     the simplest case, the characters between the two form the set. 
     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     Character ranges can also be included in a character set, by
     writing two characters with a `-' between them.  Thus, `[a-z]'
     matches any lower-case letter.  Ranges may be intermixed freely
     with individual characters, as in `[a-z$%.]', which matches any
     lower case letter or `$', `%' or period.

     Note that the usual special characters are not special any more
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `---', which is a range containing only `-'.  To
     include `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complement character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]'
     matches all characters except letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (`-' and `]' are not special there).

     Note that a complement character set can match a newline, unless
     newline is mentioned as one of the characters not to match.

`^'
     is a special character that matches the empty string, but only if
     at the beginning of a line in the text being matched.  Otherwise
     it fails to match anything.  Thus, `^foo' matches a `foo' which
     occurs at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `xx*$' matches a string of one `x' or more at the end of a line.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression which matches only `$', and `\[' is a regular
     expression which matches only `[', and so on.

   Note: for historical compatibility, special characters are treated
as ordinary ones if they are in contexts where their special meanings
make no sense.  For example, `*foo' treats `*' as ordinary since there
is no preceding expression on which the `*' can act.  It is poor
practice to depend on this behavior; better to quote the special
character anyway, regardless of where is appears.

   For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: characters which,
when preceded by `\', are special constructs.  Such characters are
always ordinary when encountered on their own.  Here is a table of `\'
constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything that
     either A or B will match.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other
     string.

     `\|' applies to the largest possible surrounding expressions. 
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations. 
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix `*' to
          operate on.  Thus, `ba\(na\)*' matches `bananana', etc.,
          with any (zero or more) number of `na' strings.

       3. To mark a matched substring for future reference.


     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature which happens to
     be assigned as a second meaning to the same `\( ... \)' construct
     because there is no conflict in practice between the two meanings. 
     Here is an explanation of this feature:

`\DIGIT'
     after the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct. 
     Then, later on in the regular expression, you can use `\'
     followed by DIGIT to mean "match the same text matched the
     DIGIT'th time by the `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through
     9 in order that the open-parentheses appear in the regular
     expression.  `\1' through `\9' may be used to refer to the text
     matched by the corresponding `\( ... \)' construct.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

`\`'
     matches the empty string, provided it is at the beginning of the
     buffer.

`\''
     matches the empty string, provided it is at the end of the buffer.

`\b'
     matches the empty string, provided it is at the beginning or end
     of a word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

`\B'
     matches the empty string, provided it is not at the beginning or
     end of a word.

`\<'
     matches the empty string, provided it is at the beginning of a
     word.

`\>'
     matches the empty string, provided it is at the end of a word.

`\w'
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.

`\W'
     matches any character that is not a word-constituent.

`\sCODE'
     matches any character whose syntax is CODE.  CODE is a character
     which represents a syntax code: thus, `w' for word constituent,
     `-' for whitespace, `(' for open-parenthesis, etc.  *Note
     Syntax::.

`\SCODE'
     matches any character whose syntax is not CODE.

   Here is a complicated regexp, used by Emacs to recognize the end of
a sentence together with any whitespace that follows.  It is given in
Lisp syntax to enable you to distinguish the spaces from the tab
characters.  In Lisp syntax, the string constant begins and ends with
a double-quote.  `\"' stands for a double-quote as part of the regexp,
`\\' for a backslash as part of the regexp, `\t' for a tab and `\n'
for a newline.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This contains four parts in succession: a character set matching
period, `?' or `!'; a character set matching close-brackets, quotes or
parentheses, repeated any number of times; an alternative in
backslash-parentheses that matches end-of-line, a tab or two spaces;
and a character set matching whitespace characters, repeated any
number of times.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

   All sorts of searches in Emacs normally ignore the case of the text
they are searching through; if you specify searching for `FOO', then
`Foo' and `foo' are also considered a match.  Regexps, and in
particular character sets, are included: `[aB]' would match `a' or `A'
or `b' or `B'.

   If you do not want this feature, set the variable `case-fold-search'
to `nil'.  Then all letters must match exactly, including case.  This
is a per-buffer variable; altering the variable affects only the
current buffer, but there is a default value which you can change as
well.  *Note Locals::.


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

   Global search-and-replace operations are not needed as often in
Emacs as they are in other editors, but they are available.  In
addition to the simple `replace-string' command which is like that
found in most editors, there is a `query-replace' command which asks
you, for each occurrence of the pattern, whether to replace it.

   The replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs'.  *Note Expanding
Abbrevs::.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string RET STRING RET NEWSTRING RET'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'. 
Replacement occurs only after point, so if you want to cover the whole
buffer you must go to the beginning first.  All occurrences up to the
end of the buffer are replaced; to limit replacement to part of the
buffer, narrow to that part of the buffer before doing the replacement
(*note Narrowing::.).

   When `replace-string' exits, point is left at the last occurrence
replaced.  The value of point when the `replace-string' command was
issued is remembered on the mark ring; `C-u C-SPC' moves back there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

   `replace-string' replaces exact matches for a single string.  The
similar command `replace-regexp' replaces any match for a specified
pattern.

   In `replace-regexp', the NEWSTRING need not be constant.  It can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire text being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the D'th
parenthesized grouping in REGEXP.  For example,

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

would replace (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

would perform exactly the opposite replacements.  To include a `\' in
the text to replace with, you must give `\\'.


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

Replace Commands and Case
-------------------------

   If the arguments to a replace command are in lower case, it
preserves case when it makes a replacement.  Thus, the command

     M-x replace-string RET foo RET bar RET

replaces a lower case `foo' with a lower case `bar', `FOO' with `BAR',
and `Foo' with `Bar'.  If upper case letters are used in the second
argument, they remain upper case every time that argument is inserted.
 If upper case letters are used in the first argument, the second
argument is always substituted exactly as given, with no case
conversion.  Likewise, if the variable `case-replace' is set to `nil',
replacement is done without case conversion.  If `case-fold-search' is
set to `nil', case is significant in matching occurrences of `foo' to
replace; also, case conversion of the replacement string is not done.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

Query Replace
-------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     Replace some occurrences of STRING with NEWSTRING.

`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, then you cannot use an ordinary
`replace-string'.  Instead, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  A numeric argument to `query-replace'
tells it to consider only occurrences that are bounded by
word-delimiter characters.

   Aside from querying, `query-replace' works just like
`replace-string', and `query-replace-regexp' works just like
`replace-regexp'.

   The things you can type when you are shown an occurrence of STRING
or a match for REGEXP are:

`SPC'
     to replace the occurrence with NEWSTRING.  This preserves case,
     just like `replace-string', provided `case-replace' is non-`nil',
     as it normally is.

`DEL'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character, except that since the
     replacement has already been made, DEL and SPC are equivalent. 
     You could type `C-r' at this point (see below) to alter the
     replaced text.  You could also type `C-x u' to undo the
     replacement; this exits the `query-replace', so if you want to do
     further replacement you must use `C-x ESC' to restart (*note
     Repetition::.).

`ESC'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the location of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake. 
     This works by popping the mark ring.  Only one `^' in a row is
     allowed, because only one previous replacement location is kept
     during `query-replace'.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' and the
     next occurrence will be displayed.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing
     level as in `C-r'.  Use the recursive edit to insert text to
     replace the deleted occurrence of STRING.  When done, exit the
     recursive editing level with `C-M-c' and the next occurrence will
     be displayed.

`C-l'
     to redisplay the screen and then give another answer.

`C-h'
     to display a message summarizing these options, then give another
     answer.

   If you type any other character, the `query-replace' is exited, and
the character executed as a command.  To restart the `query-replace',
use `C-x ESC', which repeats the `query-replace' because it used the
minibuffer to read its arguments.  *Note C-x ESC: Repetition.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

Other Search-and-Loop Commands
==============================

   Here are some other commands that find matches for a regular
expression.  They all operate from point to the end of the buffer.

`M-x occur'
     Print each line that follows point and contains a match for the
     specified regexp.  A numeric argument specifies the number of
     context lines to print before and after each matching line; the
     default is none.

     The buffer `*Occur*' containing the output serves as a menu for
     finding the occurrences in their original context.  Find an
     occurrence as listed in `*Occur*', position point there and type
     `C-c C-c'; this switches to the buffer that was searched and
     moves point to the original of the same occurrence.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x count-matches'
     Print the number of matches following point for the specified
     regexp.

`M-x delete-non-matching-lines'
     Delete each line that follows point and does not contain a match
     for the specified regexp.

`M-x delete-matching-lines'
     Delete each line that follows point and contains a match for the
     specified regexp.


File: emacs,  Node: Fixit,  Next: Files,  Prev: Search,  Up: Top

Commands for Fixing Typos
*************************

   In this chapter we describe the commands that are especially useful
for the times when you catch a mistake in your text just after you
have made it, or change your mind while composing text on line.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Kill Errors,  Next: Transpose,  Prev: Fixit,  Up: Fixit

Killing Your Mistakes
=====================

`DEL'
     Delete last character (`delete-backward-char').

`M-DEL'
     Kill last word (`backward-kill-word').

`C-x DEL'
     Kill to beginning of sentence (`backward-kill-sentence').

   The DEL character (`delete-backward-char') is the most important
correction command.  When used among graphic (self-inserting)
characters, it can be thought of as canceling the last character typed.

   When your mistake is longer than a couple of characters, it might
be more convenient to use `M-DEL' or `C-x DEL'.  `M-DEL' kills back to
the start of the last word, and `C-x DEL' kills back to the start of
the last sentence.  `C-x DEL' is particularly useful when you are
thinking of what to write as you type it, in case you change your mind
about phrasing.  `M-DEL' and `C-x DEL' save the killed text for `C-y'
and `M-y' to retrieve.  *Note Yanking::.

   `M-DEL' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and
aren't sure exactly what you typed.  At such a time, you cannot
correct with DEL except by looking at the screen to see what you did. 
It requires less thought to kill the whole word and start over again.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

Transposing Text
================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars'). 
Normally, `C-t' transposes the two characters on either side of point.
 When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back to between
the two transposed characters.  If you transposed a space with the
last character of the word before it, the word motion commands are a
good way of getting there.  Otherwise, a reverse search (`C-r') is
often the best way.  *Note Search::.

   `Meta-t' (`transpose-words') transposes the word before point with
the word after point.  It moves point forward over a word, dragging
the word preceding or containing point forward as well.  The
punctuation characters between the words do not move.  For example,
`FOO, BAR' transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing
two expressions (*note Lists::.), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except in determining the
division of the text into syntactic units.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, sexp,
line) before or containing point across several other characters
(words, sexps, lines).  For example, `C-u 3 C-t' moves the character
before point forward across three other characters.  This is
equivalent to repeating `C-t' three times.  `C-u - 4 M-t' moves the
word before point backward across four words.  `C-u - C-M-t' would
cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, sexp, line) ending after point with the
one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

Case Conversion
===============

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move
the cursor.  As soon as you see you have mistyped the last word, you
can simply case-convert it and go on typing.  *Note Case::.


File: emacs,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

Checking and Correcting Spelling
================================

`M-$'
     Check and correct spelling of word (`spell-word').

`M-x spell-buffer'
     Check and correct spelling of each word in the buffer.

`M-x spell-region'
     Check and correct spelling of each word in the region.

`M-x spell-string'
     Check spelling of specified word.

   To check the spelling of the word before point, and optionally
correct it as well, use the command `M-$' (`spell-word').  This
command runs an inferior process containing the `spell' program to see
whether the word is correct English.  If it is not, it asks you to
edit the word (in the minibuffer) into a corrected spelling, and then
does a `query-replace' to substitute the corrected spelling for the
old one throughout the buffer.

   If you exit the minibuffer without altering the original spelling,
it means you do not want to do anything to that word.  Then the
`query-replace' is not done.

   `M-x spell-buffer' checks each word in the buffer the same way that
`spell-word' does, doing a `query-replace' if appropriate for every
incorrect word.

   `M-x spell-region' is similar but operates only on the region, not
the entire buffer.

   `M-x spell-string' reads a string as an argument and checks whether
that is a correctly spelled English word.  It prints in the echo area a
message giving the answer.


File: emacs,  Node: Files,  Next: Buffers,  Prev: Fixit,  Up: Top

File Handling
*************

   The basic unit of stored data in Unix is the "file".  To edit a
file, you must tell Emacs to examine the file and prepare a buffer
containing a copy of the file's text.  This is called "visiting" the
file.  Editing commands apply directly to text in the buffer; that is,
to the copy inside Emacs.  Your changes appear in the file itself only
when you "save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, and operate on file directories.

* Menu:

* File Names::   How to type and edit file name arguments.
* Visiting::     Visiting a file prepares Emacs to edit the file.
* Saving::       Saving makes your changes permanent.
* Reverting::    Reverting cancels all the changes not saved.
* Auto Save::    Auto Save periodically protects against loss of data.
* ListDir::      Listing the contents of a file directory.
* Dired::        "Editing" a directory to delete, rename, etc.
                  the files in it.
* Misc File Ops:: Other things you can do on files.


File: emacs,  Node: File Names,  Next: Visiting,  Prev: Files,  Up: Files

File Names
==========

   Most Emacs commands that operate on a file require you to specify
the file name.  (Saving and reverting are exceptions; the buffer knows
which file name to use for them.)  File names are specified using the
minibuffer (*note Minibuffer::.).  "Completion" is available, to make
it easier to specify long file names.  *Note Completion::.

   There is always a "default file name" which will be used if you type
just RET, entering an empty argument.  Normally the default file name
is the name of the file visited in the current buffer; this makes it
easy to operate on that file with any of the Emacs file commands.

   Each buffer has a default directory, normally the same as the
directory of the file visited in that buffer.  When Emacs reads a file
name, if you do not specify a directory, the default directory is
used.  If you specify a directory in a relative fashion, with a name
that does not start with a slash, it is interpreted with respect to
the default directory.  The default directory is kept in the variable
`default-directory', which has a separate value in every buffer.

   For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is `/u/rms/gnu/'.  If you type just `foo', which
does not specify a directory, it is short for `/u/rms/gnu/foo'. 
`../.login' would stand for `/u/rms/.login'.  `new/foo' would stand
for the filename `/u/rms/gnu/new/foo'.

   The command `M-x pwd' prints the current buffer's default directory,
and the command `M-x cd' sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the `cd'
command is used.  A file-visiting buffer's default directory is
initialized to the directory of the file that is visited there.  If a
buffer is made randomly with `C-x b', its default directory is copied
from that of the buffer that was current at the time.

   The default directory actually appears in the minibuffer when the
minibuffer becomes active to read a file name.  This serves two
purposes: it shows you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to edit the default to specify a different directory.  This
insertion of the default directory is inhibited if the variable
`insert-default-directory' is set to `nil'.

   Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name as part of the text.  The final minibuffer contents may look
invalid, but that is not so.  *Note Minibuffer File::.

   `$' in a file name is used to substitute environment variables.  For
example, if you have used the shell command `setenv FOO rms/hacks' to
set up an environment variable named `FOO', then you can use
`/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  The environment variable name consists of all
the alphanumeric characters after the `$'; alternatively, it may be
enclosed in braces after the `$'.  Note that the `setenv' command
affects Emacs only if done before Emacs is started.

   To access a file with `$' in its name, type `$$'.  This pair is
converted to a single `$' at the same time as variable substitution is
performed for single `$'.  The Lisp function that performs the
substitution is called `substitute-in-file-name'.  The substitution is
performed only on filenames read as such using the minibuffer.

