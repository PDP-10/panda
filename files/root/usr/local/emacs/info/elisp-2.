Info file elisp, produced by Makeinfo, -*- Text -*- from input file
elisp.texi.

   This file documents GNU Emacs Lisp.

   This is edition 1.03 of the GNU Emacs Lisp Reference Manual,   for
Emacs Version 18.

   Published by the Free Software Foundation, 675 Massachusetts
Avenue,  Cambridge, MA 02139 USA

   Copyright (C) 1990 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.



File: elisp,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

Evaluation Notation
-------------------

   When you evaluate a piece of Lisp code, it produces a result.  In
the examples in this manual, this is indicated with `=>':

     (car '(1 2))
          => 1

You can read this as "`(car '(1 2))' evaluates to 1".

   When a form is a macro call, it expands into a new form for Lisp
to evaluate.  We show the result of the expansion with `==>'.  We may
or may not show the actual result of the evaluation of the expanded
form.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

   Sometimes to help describe one form we show another form which
produces identical results.  The exact equivalence of two forms is
indicated with `=='.

     (make-sparse-keymap) == (list 'keymap)



File: elisp,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

Printing Notation
-----------------

   Many of the examples in this manual print text when they are
evaluated.  If you execute the code from an example in a Lisp
Interaction buffer (such as the buffer `*scratch*'), the printed text
is inserted into the buffer.  If the example is executed by other
means (such as by evaluating the function `eval-region'), the text
printed is usually displayed in the echo area.  You should be aware
that text displayed in the echo area is truncated to a single line.

   In examples that print text, the printed text is indicated with
`-|', irrespective of how the form is executed.  The value returned
by evaluating the form (here `bar') follows on a separate line.

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar



File: elisp,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

Error Messages
--------------

   Some examples cause errors to be signaled.  In them, the error
message (which always appears in the echo area) is shown on a line
starting with `error-->'.  Note that `error-->' itself does not
appear in the echo area.

     (+ 23 'x)
     error--> Wrong type argument: integer-or-marker-p, x



File: elisp,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

Buffer Text Notation
--------------------

   Some examples show modifications to text in a buffer, with
"before" and "after" versions of the text.  In such cases, the entire
contents of the buffer in question are included between two lines of
dashes containing the buffer name.  In addition, the location of
point is shown as `-!-'.  (The symbol for point, of course, is not
part of the text in the buffer; it indicates the place *between* two
characters where point is located.)

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------
     
     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------



File: elisp,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

Format of Descriptions
----------------------

   Functions, variables, macros, commands, user options, and special
forms are described in this manual in a uniform format.  The first
line of a description contains the name of the item followed by its
arguments, if any.

   The category--function, variable, or whatever--appears at the
beginning of the line.

   The description follows on succeeding lines, sometimes with
examples.

* Menu:

* A Sample Function Description::       
* A Sample Variable Description::



File: elisp,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Prev: Format of Descriptions,  Up: Format of Descriptions

A Sample Function Description
.............................

    In a function description, the name of the function being
described appears first.  It is followed on the same line by a list
of parameters.  The names used for the parameters are also used in
the body of the description.

   The appearance of the keyword `&optional' in the parameter list
indicates that the arguments for subsequent parameters may be omitted
(omitted parameters default to `nil').  Do not write `&optional' when
you call the function.

   The keyword `&rest' (which will always be followed by a single
parameter) indicates that any number of arguments can follow.  The
value of the single following parameter will be a list of all these
arguments.  Do not write `&rest' when you call the function.

   Here is a description of an imaginary function `foo':

 * Function: foo INTEGER1 &optional INTEGER2 &rest INTEGERS
     The function `foo' subtracts INTEGER1 from INTEGER2, then adds
     all the rest of the arguments to the result.  If INTEGER2 is not
     supplied, then the number 19 is used by default.

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     More generally,

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

   Any parameter whose name contains the name of a type (e.g.,
INTEGER, INTEGER1 or BUFFER) is expected to be of that type.  A
plural of a type (such as BUFFERS) often means a list of objects of
that type.  Parameters named OBJECT may be of any type.  (*Note Types
of Lisp Object::, for a list of Emacs object types.) Parameters with
other sorts of names (e.g., NEW-FILE) are discussed specifically in
the description of the function.  In some sections, features common
to parameters of several functions are described at the beginning.

   *Note Lambda Expressions::, for a more complete description of
optional and rest arguments.

   Command, macro, and special form descriptions have the same
format, but the word `Function' is replaced by `Command', `Macro', or
`Special Form', respectively.  Commands are simply functions that may
be called interactively; macros process their arguments differently
from functions (the arguments are not evaluated), but are presented
the same way.

   Special form descriptions use a more complex notation to specify
optional and repeated parameters because they can break the argument
list down into separate arguments in more complicated ways. 
``[OPTIONAL-ARG]'' means that OPTIONAL-ARG is optional and
`REPEATED-ARGS...' stands for zero or more arguments.  Parentheses
are used when several arguments are grouped into additional levels of
list structure.  Here is an example:

 * Special Form: count-loop (VAR [FROM TO [INC]]) BODY...
     This imaginary special form implements a loop that executes the
     BODY forms and then increments the variable VAR on each
     iteration.  On the first iteration, the variable has the value
     FROM; on subsequent iterations, it is incremented by 1 (or by
     INC if that is given).  The loop exits before executing BODY if
     VAR equals TO.  Here is an example:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i)) (terpri))

     If FROM and TO are omitted, then VAR is bound to `nil' before
     the loop begins, and the loop exits if VAR is non-`nil' at the
     beginning of an iteration.  Here is an example:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     In this special form, the arguments FROM and TO are optional,
     but must both be present or both absent.  If they are present,
     INC may optionally be specified as well.  These arguments are
     grouped with the argument VAR into a list, to distinguish them
     from BODY, which includes all remaining elements of the form.



File: elisp,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

A Sample Variable Description
.............................

    A "variable" is a name that can hold a value.  Although any
variable can be set by the user, certain variables that exist
specifically so that users can change them are called "user options".
Ordinary variables and user options are described using a format like
that for functions except that there are no arguments.

   Here is a description of the imaginary `electric-future-map'
variable.

 * Variable: electric-future-map
     The value of this variable is a full keymap used by electric
     command future mode.  The functions in this map will allow you
     to edit commands you have not yet thought about executing.

   User option descriptions have the same format, but `Variable' is
replaced by `User Option'.



File: elisp,  Node: Acknowledgements,  Prev: Conventions,  Up: Introduction

Acknowledgements
================

   This manual was written by Robert Krawitz, Bil Lewis, Dan
LaLiberte, Richard M. Stallman and Chris Welty, the volunteers of the
GNU manual group, in an effort extending over several years.  Robert
J. Chassell helped to review and edit the manual, with the support of
the Defense Advanced Research Projects Agency, ARPA Order 6082,
arranged by Warren A. Hunt, Jr. of Computational Logic, Inc.

   Corrections were supplied by Karl Berry, Bard Bloom, David Boyes,
Alan Carroll, David A. Duff, Beverly Erlebacher, David Eckelkamp,
Eirik Fuller, Eric Hanchrow, George Hartzell, Nathan Hess, Dan
Jacobson, Jak Kirman, Bob Knighten, Frederick M. Korz, Joe Lammens,
K. Richard Magill, Brian Marick, Roland McGrath, Skip Montanaro, John
Gardiner Myers, Arnold D. Robbins, Raul Rockwell, Shinichirou Sugou,
Kimmo Suominen, Edward Tharp, Bill Trost, Jean White, Matthew
Wilding, Carl Witty, Dale Worley, Rusty Wright, and David D. Zuhn.



File: elisp,  Node: Types of Lisp Object,  Next: Numbers,  Prev: Introduction,  Up: Top

Lisp Data Types
***************

   A Lisp "object" is a piece of data used and manipulated by Lisp
programs.  For our purposes, a "type" or "data type" is a set of
possible objects.

   Every object belongs to at least one type.  Objects of the same
type have similar structures and may usually be used in the same
contexts.  Types can overlap, and objects can belong to two or more
types.  Consequently, we can ask whether an object belongs to a
particular type, but not for "the" type of an object.

   A few fundamental object types are built into Emacs.  These, from
which all other types are constructed, are called "primitive types". 
They include "integer", "cons", "symbol", "string", "vector", "subr"
and several special types, such as "buffer", that are related to
editing.  (*Note Editing Types::.)

   While an object may be a member of more than one type, every
object is a member of exactly one primitive type.  The primitive type
of an object is stored with the object's data.  A Lisp function is
provided for each primitive type to check whether an object is a
member of that type.

   Note that Lisp is unlike many other languages in that Lisp objects
are "self-typing": the primitive type of the object is implicit in
the object itself.  For example, if an object is a vector, it cannot
be treated as a number because Lisp knows it is a vector, not a
number.  In most languages, the programmer must declare the data type
of each variable, and the type is known by the compiler but not
represented in the data.  Such type declarations do not exist in
Emacs Lisp.

   This chapter describes the purpose, printed representation, and
read syntax of each of the standard types in GNU Emacs Lisp.  Details
on how to use these types can be found in later chapters.

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.

 

File: elisp,  Node: Printed Representation,  Next: Comments,  Prev: Types of Lisp Object,  Up: Types of Lisp Object

Printed Representation and Read Syntax
======================================

   The "printed representation" of an object is the format of the
output generated by the Lisp printer (the function `print') for that
object.  The "read syntax" of an object is the format of the input
accepted by the Lisp reader (the function `read') for that object. 
Most objects have more than one possible read syntax.  Some types of
object have no read syntax; except in these cases, the printed
representation of an object is also a read syntax for it.

   In other languages, an expression is text; it has no other form. 
In Lisp, an expression is primarily a Lisp object and only
secondarily the text that is the object's read syntax.  Often there
is no need to emphasize this distinction, but you must keep it in the
back of your mind, or you will occasionally be very confused.

   Every type has a printed representation.  Some types have no read
syntax, since it may not make sense to enter objects of these types
directly in a Lisp program.  For example, the buffer type does not
have a read syntax.  Objects of these types are printed in "hash
notation": the characters `#<' followed by a descriptive string
(typically the type name followed by the name of the object), and
closed with a matching `>'.  Hash notation cannot be read at all, so
the Lisp reader signals the error `invalid-read-syntax' whenever a
`#' is encountered.

     (current-buffer)
          => #<buffer objects.texi>

   When you evaluate an expression interactively, the Lisp
interpreter first reads the textual representation of it, producing a
Lisp object, and then evaluates that object (*note Evaluation::.). 
However, evaluation and reading are separate activities.  Reading
returns the Lisp object represented by the text that is read; the
object may or may not be evaluated later.  *Note Input Functions::,
for a description of `read', the basic function for reading objects.



File: elisp,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Types of Lisp Object

Comments
========

   A "comment" is text that is written in a program only for the sake
of humans that read the program, and that has no effect on the
meaning of the program.  In Lisp, a comment starts with a semicolon
(`;') and continues to the end of line.  Comments are discarded by
the Lisp reader, and do not become part of the Lisp objects which
represent the program within the Lisp system.

   We recommend these conventions for where to put comments and how
to indent them:

`;'
     Comments that start with a single semicolon, `;', should all be
     aligned to the same column on the right of the source code. 
     Such comments usually explain how the code on the same line does
     its job.  In Lisp mode and related modes, the `M-;'
     (`indent-for-comment') command automatically inserts such a `;'
     in the right place, or aligns such a comment if it is already
     inserted.

     (The following examples are taken from the Emacs sources.)

          (setq base-version-list                 ; there was a base
                (assoc (substring fn 0 start-vn)  ; version to which
                       file-version-assoc-list))  ; this looks like
                                                  ; a subversion

`;;'
     Comments that start with two semicolons, `;;', should be aligned
     to the same level of indentation as the code.  Such comments are
     used to describe the purpose of the following lines or the state
     of the program at that point.  For example:

            (prog1 (setq auto-fill-hook
                         ...
                         ...
              ;; update mode-line
              (set-buffer-modified-p (buffer-modified-p))))

     These comments are also written before a function definition to
     explain what the function does and how to call it properly.

`;;;'
     Comments that start with three semicolons, `;;;', should start
     at the left margin.  Such comments are not used within function
     definitions, but are used to make more general comments.  For
     example:

          ;;; This Lisp code is run in Emacs when it is to operate as
          ;;; a server for other processes.

`;;;;'
     Comments that start with four semicolons, `;;;;', should be
     aligned to the left margin and are used for headings of major
     sections of a program.  For example:

          ;;;; The kill ring

The indentation commands of the Lisp modes in Emacs, such as `M-;'
(`indent-for-comment') and TAB (`lisp-indent-line') automatically
indent comments according to these conventions, depending on the the
number of semicolons.  *Note : (emacs)Comments.

   Any character may be included in a comment, but it is advisable to
precede a character with syntactic significance in Lisp (such as `\'
or unpaired `(' or `)') with a `\', to prevent it from confusing the
Emacs commands for editing Lisp.



File: elisp,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Types of Lisp Object

Programming Types
=================

   There are two general categories of types in Emacs Lisp: those
having to do with Lisp programming, and those having to do with
editing.  The former are provided in many Lisp implementations, in
one form or another.  The latter are unique to Emacs Lisp.

* Menu:

* Number Type::         Primarily integers.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Sequence Type::       Both lists and arrays are classified as sequences.
* List Type::           Lists gave Lisp its name (not to mention reputation).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, property list, or itself.
* Lisp Function Type::  A piece of executable code you can call from elsewhere.
* Lisp Macro Type::     A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.

 

File: elisp,  Node: Number Type,  Next: Character Type,  Prev: Programming Types,  Up: Programming Types

Number Type
-----------

   Integers are the only kind of number in GNU Emacs Lisp, version 18.
The range of values for integers is -8388608 to 8388607 (24 bits; i.e.,

   -2**23

   to

   2**23 - 1)

   on most machines, but is 25 or 26 bits on some systems.  It is
important to note that the Emacs Lisp arithmetic functions do not
check for overflow.  Thus `(1+ 8388607)' is -8388608 on 24-bit
implementations.

   Version 19 supports floating point numbers.

   The read syntax for numbers is a sequence of (base ten) digits
with an optional sign.  The printed representation produced by the
Lisp interpreter never has a leading `+'.

     -1               ; The integer -1.
     1                ; The integer 1.
     +1               ; Also the integer 1.
     16777217         ; Also the integer 1! (on a 24-bit or 25-bit implementation)

   *Note Numbers::, for more information.



File: elisp,  Node: Character Type,  Next: Sequence Type,  Prev: Number Type,  Up: Programming Types

Character Type
--------------

   A "character" in Emacs Lisp is nothing more than an integer.  In
other words, characters are represented by their eight-bit ASCII
values.  For example, the character `A' is represented as the
integer 65.  If an arbitrary integer is used as a character, only
the lower eight bits are significant.

   Individual characters are not often used in programs.  It is far
more common to work with *strings*, which are sequences composed of
characters.  *Note String Type::.

   Since characters are really integers, the printed representation
of a character is a decimal number.  This is also a possible read
syntax for a character, but it is not convenient for that purpose. 
Therefore, Emacs Lisp provides a variety of read syntax formats, such
as `?A' and `?\101', for entering characters.  They all start with a
question mark.

   The usual read syntax for alphanumeric characters is a question
mark followed by the character; thus, `?A' for the character `A',
`?B' for the character `B', and `?a' for the character `a'.  For
example:

     ?Q => 81
     
     ?q => 113

   The characters backspace, tab, newline, vertical tab, formfeed,
return, and escape may be represented as `?\b', `?\t', `?\n', `?\v',
`?\f', `?\r', `?\e', respectively.  Those values are 8, 9, 10, 11,
12, 13, and 27 in decimal.  Thus,

     ?\b => 8                 ; backspace, BS, `C-h'
     ?\t => 9                 ; tab, TAB, `C-i'
     ?\n => 10                ; newline, LFD, `C-j'
     ?\v => 11                ; vertical tab, `C-k'
     ?\f => 12                ; formfeed character, `C-l'
     ?\r => 13                ; carriage return, RET, `C-m'
     ?\e => 27                ; escape character, ESC, `C-['
     ?\\ => 92                ; backslash character, `\'

   Control characters may be represented using yet another read syntax.
This consists of a question mark followed by a backslash, caret, and
the corresponding non-control character, in either upper or lower
case.  For example, either `?\^I' or `?\^i' may be used as the read
syntax for the character `C-i', the character whose value is 9.

   Instead of the `^', you can use `C-'; thus, `?\C-i' is equivalent
to `?\^I', and `?\C-i' is equivalent to `?\^i'.  For example:

     ?\^I => 9
     
     ?\C-I => 9

   The DEL key can be considered and written as `Control-?':

     ?\^? => 127
     
     ?\C-? => 127

   When you represent control characters to be found in files or
strings, we recommend the `^' syntax; but when you refer to keyboard
input, we prefer the `C-' syntax.  This does not affect the meaning
of the program, but may guide the understanding of people who read it.

   A "meta character" is a character that has its eighth bit set. 
The read syntax for these characters is question mark, backslash,
`M-', and the corresponding seven-bit character.  For example,
`?\M-A' stands for `M-A', the character with code 193 (301 octal). 
The seven-bit character can be written directly or specified by any
of the `\' escapes described above or below.  Thus, `M-A' can be
written as `?\M-A', or as `?\M-\101', or as `?\301'.  Likewise, the
character whose decimal printed representation is 130 (202 octal) can
use any one of the following for its read syntax: `?\202',
`?\M-\C-b', `?\C-\M-b', or `?\M-\002'.  For example:

     ?\C-\M-b => 130          ?\M-\C-b => 130
     
     ?\^\M-b => 130           ?\M-\002 => 130

   Finally, the most general read syntax consists of a question mark
followed by a backslash and the ASCII code for the character in octal
(up to three octal digits); thus, `?\101' for the character `A',
`?\001' for the character `C-a', and `?\002' for the character `C-b'.
Although this syntax can represent any character, it is preferred
only when the precise octal value is more important than the ASCII
representation.  (These sequences which start with backslash are also
known as "escape sequences", because backslash plays the role of an
escape character, but they have nothing to do with the character ESC.)

     ?\012 => 10        ?\n => 10         ?\C-j => 10
     
     ?\101 => 65        ?A => 65           
     
     ?\301 => 193       ?\M-A => 193      ?\M-\101 => 193

   A backslash is allowed, and harmless, preceding any character
without a special escape meaning; thus, `?\A' is equivalent to `?A'. 
There is no reason to use a backslash before most such characters. 
However, any of the characters `()\|;'`"#.,' should be preceded by a
backslash to avoid confusing the Emacs commands for editing Lisp code.
Whitespace characters such as space, tab, newline and formfeed should
also be preceded by a backslash.  However, it is cleaner to use one
of the easily readable escape sequences, such as `\t', instead of an
actual control character such as a tab.



File: elisp,  Node: Sequence Type,  Next: List Type,  Prev: Character Type,  Up: Programming Types

Sequence Types
--------------

   A "sequence" is a Lisp object that represents an ordered set of
elements.  There are two kinds of sequence in Emacs Lisp, lists and
arrays.  Thus, an object of type list or of type array is also
considered a sequence.

   Arrays are further subdivided into strings and vectors.  Vectors
can hold elements of any type, but string elements must be
characters--integers from 0 to 255.

   Lists, strings and vectors are different, but they have important
similarities.  For example, all have a length L, and all have
elements which can be indexed from zero to L minus one.  Also,
several functions, called sequence functions, accept any kind of
sequence.  For example, the function `elt' can be used to extract an
element of a sequence, given its index.  *Note Sequences Arrays
Vectors::.

   It is impossible to read the same sequence twice, in the sense of
`eq' (*note Equality Predicates::.), since sequences are always
created anew upon reading.  There is one exception: the empty list
`()' is always read as the same object, `nil'.



File: elisp,  Node: List Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

List Type
---------

   A "list" is a series of cons cells, linked together.  A "cons
cell" is an object comprising two pointers named the CAR and the CDR.
Each of them can point to any Lisp object, but when the cons cell is
part of a list, the CDR points either to another cons cell or to the
empty list.  *Note Lists::, for functions that work on lists.

   The names CAR and CDR have only historical meaning now.  The
original Lisp implementation ran on an IBM 704 computer which divided
words into two parts, called the "address" part and the "decrement";
CAR was an instruction to extract the contents of the address part of
a register, and CDR an instruction to extract the contents of the
decrement.  By contrast, "cons cells" are named for the function
`cons' that creates them, which in turn is named for its purpose, the
construction of cells.

   Because cons cells are so central to Lisp, we also have a word for
"an object which is not a cons cell".  These objects are called
"atoms".

   The read syntax and printed representation for lists are
identical, and consist of a left parenthesis, an arbitrary number of
elements, and a right parenthesis.

   Upon reading, any object inside the parentheses is made into an
element of the list.  That is, a cons cell is made for each element. 
The CAR of the cons cell points to the element, and its CDR points to
the next cons cell which holds the next element in the list.  The CDR
of the last cons cell is set to point to `nil'.

   A list can be illustrated by a diagram in which the cons cells are
shown as pairs of boxes.  (The Lisp reader cannot read such an
illustration; unlike the textual notation, which can be understood
both humans and computers, the box illustrations can only be
understood by humans.)  The following represents the three-element
list `(rose violet buttercup)':

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   In the diagram, each box represents a slot that can refer to any
Lisp object.  Each pair of boxes represents a cons cell.  Each arrow
is a reference to a Lisp object, either an atom or another cons cell.

   In this example, the first box, the CAR of the first cons cell,
refers to or "contains" `rose' (a symbol).  The second box, the CDR
of the first cons cell, refers to the next pair of boxes, the second
cons cell.  The CAR of the second cons cell refers to `violet' and
the CDR refers to the third cons cell.  The CDR of the third (and
last) cons cell refers to `nil'.

   Here is another diagram of the same list, `(rose violet
buttercup)', sketched in a different manner:

      ---------------         ----------------         -------------------
     |car    |cdr    |       |car     |cdr    |       |car        |cdr    |
     | rose  |   o---------->| violet |   o---------->| buttercup |  nil  |
     |       |       |       |        |       |       |           |       |
      ---------------         ----------------         -------------------

   A list with no elements in it is the "empty list"; it is identical
to the symbol `nil'.  In other words, `nil' is both a symbol and a
list.

   Here are examples of lists written in Lisp syntax:

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string `"A ()"'.
     (A ())               ; A list of two elements: `A' and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ; (which is a list of three elements).

    Here is the list `(A ())', or equivalently `(A nil)', depicted
with boxes and arrows:

         ___ ___      ___ ___
        |___|___|--> |___|___|--> nil
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.

 

File: elisp,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: List Type,  Up: List Type

Dotted Pair Notation
....................

    "Dotted pair notation" is an alternative syntax for cons cells
that represents the CAR and CDR explicitly.  In this syntax, `(A .
B)' stands for a cons cell whose CAR is the object A, and whose CDR
is the object B.  Dotted pair notation is therefore more general than
list syntax.  In the dotted pair notation, the list `(1 2 3)' is
written as `(1 .  (2 . (3 . nil)))'.  For `nil'-terminated lists, the
two notations produce the same result, but list notation is usually
clearer and more convenient when it is applicable.  When printing a
list, the dotted pair notation is only used if the CDR of a cell is
not a list.

   Box notation can also be used to illustrate what dotted pairs look
like.  For example, `(rose . violet)' is diagrammed as follows:

         ___ ___
        |___|___|--> violet
          |
          |
           --> rose

   Dotted pair notation can be combined with list notation to
represent a chain of cons cells with a non-`nil' final CDR.  For
example, `(rose violet . buttercup)' is equivalent to `(rose .
(violet . buttercup))'.  The object looks like this:

         ___ ___      ___ ___
        |___|___|--> |___|___|--> buttercup
          |            |
          |            |
           --> rose     --> violet

   These diagrams make it evident that `(rose . violet . buttercup)'
must have an invalid syntax since it would require that a cons cell
have three parts rather than two.

   The list `(rose violet)' is equivalent to `(rose . (violet))' and
looks like this:

         ___ ___      ___ ___
        |___|___|--> |___|___|--> nil
          |            |
          |            |
           --> rose     --> violet

   Similarly, the three-element list `(rose violet buttercup)' is
equivalent to `(rose . (violet . (buttercup)))'.

   It looks like this:

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



File: elisp,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: List Type

Association List Type
.....................

    An "association list" or "alist" is a specially-constructed list
whose elements are cons cells.  In each element, the CAR is
considered a "key", and the CDR is considered an "associated value". 
(In some cases, the associated value is stored in the CAR of the
CDR.)  Association lists are often used to implement stacks, since
new associations may easily be added to or removed from the front of
the list.

   For example,

     (setq alist-of-colors '((rose . red) (lily . white)  (buttercup . yellow)))

sets the variable `alist-of-colors' to an alist of three elements. 
In the first element, `rose' is the key and `red' is the value.

   *Note Association Lists::, for a further explanation of alists and
for functions that work on alists.



File: elisp,  Node: Array Type,  Next: String Type,  Prev: List Type,  Up: Programming Types

Array Type
----------

   An "array" is composed of an arbitrary number of other Lisp
objects, arranged in a contiguous block of memory.  Any element of an
array may be accessed in constant time.  In contrast, accessing an
element of a list requires time proportional to the position of the
element in the list.  (Elements at the end of a list take longer to
access than elements at the beginning of a list.)

   Emacs defines two types of array, strings and vectors.  A string
is an array of characters and a vector is an array of arbitrary
objects.  Both are one-dimensional.  (Most other programming
languages support multidimensional arrays, but we don't think they
are essential in Emacs Lisp.)  Each type of array has its own read
syntax; see *Note String Type::, and *Note Vector Type::.

   An array may have any length up to the largest integer; but once
created, it has a fixed size.  The first element of an array has
index zero, the second element has index 1, and so on.  This is
called "zero-origin" indexing.  For example, an array of four
elements has indices 0, 1, 2, and 3.

   The array type is contained in the sequence type and contains both
strings and vectors.



File: elisp,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

String Type
-----------

   A "string" is an array of characters.  Strings are used for many
purposes in Emacs, as can be expected in a text editor; for example,
as the names of Lisp symbols, as messages for the user, and to
represent text extracted from buffers.  Strings in Lisp are
constants; evaluation of a string returns the same string.

   The read syntax for strings is a double-quote, an arbitrary number
of characters, and another double-quote, `"like this"'.  The Lisp
reader accepts the same formats for reading the characters of a
string as it does for reading single characters (without the question
mark that begins a character literal).  You can enter a nonprinting
character such as tab, `C-a' or `M-C-A' using the convenient escape
sequences, like this: `"\t, \C-a, \M-\C-a"'.  You can include a
double-quote in a string by preceding it with a backslash; thus,
`"\""' is a string containing just a single double-quote character. 
(*Note Character Type::, for a description of the read syntax for
characters.)

   In contrast with the C programming language, newlines are allowed
in Emacs Lisp string literals.  But an escaped newline--one that is
preceded by `\'--does not become part of the string; i.e., the Lisp
reader ignores an escaped newline in a string literal.

     "It is useful to include newlines in
     documentation strings, but the newline is \
     ignored if escaped."
          => "It is useful to include newlines in
     documentation strings, but the newline is ignored if escaped."

   The printed representation of a string consists of a double-quote,
the characters it contains, and another double-quote.  However, any
backslash or double-quote characters in the string are preceded with
a backslash like this: `"this \" is an embedded quote"'.

   *Note Strings and Characters::, for functions that work on strings.



File: elisp,  Node: Vector Type,  Next: Symbol Type,  Prev: String Type,  Up: Programming Types

Vector Type
-----------

   A "vector" is a one-dimensional array of elements of any type.  It
takes a constant amount of time to access any element of a vector. 
(In a list, the access time of an element is proportional to the
distance of the element from the beginning of the list.)

   The printed representation of a vector consists of a left square
bracket, the elements, and a right square bracket.  This is also the
read syntax.  Like numbers and strings, vectors are considered
constants for evaluation.

     [1 "two" (three)]      ; A vector of three elements.
          => [1 "two" (three)]

   *Note Vectors::, for functions that work with vectors.



File: elisp,  Node: Symbol Type,  Next: Lisp Function Type,  Prev: Vector Type,  Up: Programming Types

Symbol Type
-----------

   A "symbol" in GNU Emacs Lisp is an object with a name.  The symbol
name is the printed representation of the symbol.  In ordinary use,
the name is unique--no two symbols have the same name.

   A symbol may be used in programs as a variable, as a function
name, or to hold a list of properties.  Or it may serve only to be
distinct from all other Lisp objects, so that its presence in a data
structure may be recognized reliably.  In a given context, usually
only one of these uses is intended.

   A symbol name can contain any characters whatever.  Most symbol
names are written with letters, digits, and the punctuation
characters `-+=*/'.  Such names require no special punctuation; the
characters of the name suffice as long as the name does not look like
a number.  (If it does, write a `\' at the beginning of the name to
force interpretation as a symbol.)  The characters `_~!@$%^&:<>{}'
are less often used but also require no special punctuation.  Any
other characters may be included in a symbol's name by escaping them
with a backslash.  In contrast to its use in strings, however, a
backslash in the name of a symbol quotes the single character that
follows the backslash, without conversion.  For example, in a string,
`\t' represents a tab character; in the name of a symbol, however,
`\t' merely quotes the letter `t'.  To have a symbol with a tab
character in its name, you must actually type an tab (preceded with a
backslash).  But you would hardly ever do such a thing.

     Common Lisp note: in Common Lisp, lower case letters are always
     "folded" to upper case, unless they are explicitly escaped. 
     This is in contrast to Emacs Lisp, in which upper case and lower
     case letters are distinct.

   Here are several examples of symbol names.  Note that the `+' in
the fifth example is escaped to prevent it from being read as a number.
This is not necessary in the last example because the rest of the
name makes it invalid as a number.

     foo                 ; A symbol named `foo'.
     FOO                 ; A symbol named `FOO', different from `foo'.
     char-to-string      ; A symbol named `char-to-string'.
     1+                  ; A symbol named `1+'
                         ;     (not `+1', which is an integer).
     \+1                 ; A symbol named `+1' (not a very readable name).
     \(*\ 1\ 2\)         ; A symbol named `(* 1 2)' (a worse name).
     +-*/_~!@$%^&=:<>{}  ; A symbol named `+-*/_~!@$%^&=:<>{}'.
                         ;     These characters need not be escaped.

 

File: elisp,  Node: Lisp Function Type,  Next: Lisp Macro Type,  Prev: Symbol Type,  Up: Programming Types

Lisp Function Type
------------------

   Just as functions in other programming languages are executable, a
"Lisp function" object is a piece of executable code.  However, Lisp
functions are primarily Lisp objects, and only secondarily the text
which represents them.  These Lisp objects are lambda expressions:
lists whose first element is the symbol `lambda' (*note Lambda
Expressions::.).

   In most programming languages, it is impossible to have a function
without a name.  In Lisp, a function has no intrinsic name.  A lambda
expression is also called an "anonymous function" (*note Anonymous
Functions::.).  A named function in Lisp is actually a symbol with a
valid function in its function cell (*note Defining Functions::.).

   Most of the time, functions are called when their names are
written in Lisp expressions in Lisp programs.  However, a function
object found or constructed at run time can be called and passed
arguments with the primitive functions `funcall' and `apply'.  *Note
Calling Functions::.



File: elisp,  Node: Lisp Macro Type,  Next: Primitive Function Type,  Prev: Lisp Function Type,  Up: Programming Types

Lisp Macro Type
---------------

   A "Lisp macro" is a user-defined construct that extends the Lisp
language.  It is represented as an object much like a function, but
with different parameter-passing semantics.  A Lisp macro has the
form of a list whose first element is the symbol `macro' and whose
CDR is a Lisp function object, including the `lambda' symbol.

   Lisp macro objects are usually defined with the built-in function
`defmacro', but any list that begins with `macro' is a macro as far
as Emacs is concerned.  *Note Macros::, for an explanation of how to
write a macro.



File: elisp,  Node: Primitive Function Type,  Next: Autoload Type,  Prev: Lisp Macro Type,  Up: Programming Types

Primitive Function Type
-----------------------

   A "primitive function" is a function callable from Lisp but
written in the C programming language.  Primitive functions are also
called "subrs" or "built-in functions".  (The word "subr" is derived
from "subroutine".)  Most primitive functions evaluate all their
arguments when they are called.  A primitive function that does not
evaluate all its arguments is called a "special form" (*note Special
Forms::.).

   It does not matter to the caller of a function whether the
function is primitive.  However, this does matter if you are trying
to substitute a function written in Lisp for a primitive of the same
name.  The reason is that the primitive function may be called
directly from C code.  When the redefined function is called from
Lisp, the new definition will be used; but calls from C code may
still use the old definition.

   The term "function" is used to refer to all Emacs functions,
whether written in Lisp or C.  *Note Lisp Function Type::, for
information about the functions written in Lisp.

   Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

     (symbol-function 'car)          ; Access the function cell of the symbol.
          => #<subr car>
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          => t                       ; Yes.

 

File: elisp,  Node: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

Autoload Type
-------------

   An "autoload object" is a list whose first element is the symbol
`autoload'.  It is stored as the function definition of a symbol to
say that a file of Lisp code should be loaded when necessary to find
the true definition of that symbol.  The autoload object contains the
name of the file, plus some other information about the real
definition.

   After the file has been loaded, the symbol should have a new
function definition that is not an autoload object.  The new
definition is then called as if it had been there to begin with. 
From the user's point of view, the function call works as expected,
using the function definition in the loaded file.

   An autoload object is usually created with the function
`autoload', which stores the object in the function cell of a symbol.
*Note Autoload::, for more details.



File: elisp,  Node: Editing Types,  Next: Type Predicates,  Prev: Programming Types,  Up: Types of Lisp Object

Editing Types
=============

   The types in the previous section are common to many Lisp-like
languages.  But Emacs Lisp provides several additional data types for
purposes connected with editing.

* Menu:

* Buffer Type::         The basic object of editing.
* Window Type::         What makes buffers visible.
* Window Configuration Type::   Save what the screen looks like.
* Marker Type::         A position in a buffer.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Syntax Table Type::   What a character means.

 

File: elisp,  Node: Buffer Type,  Next: Window Type,  Prev: Editing Types,  Up: Editing Types

Buffer Type
-----------

   A "buffer" is an object that holds text that can be edited (*note
Buffers::.).  Most buffers hold the contents of a disk file (*note
Files::.) so they can be edited, but some are used for other
purposes.  Most buffers are also meant to be seen by the user, and
therefore displayed, at some time, in a window (*note Windows::.). 
But a buffer need not be displayed in a window.

   The contents of a buffer are much like a string, but buffers are
not used like strings in Emacs Lisp, and the available operations are
different.  For example, text can be inserted into a buffer very
quickly, while "inserting" text into a string is accomplished by
concatenation and the result is an entirely new string object.

   Each buffer has a designated position called "point" (*note
Positions::.).  And one buffer is the "current buffer".  Most editing
commands act on the contents of the current buffer in the
neighborhood of point.  Many other functions manipulate or test the
characters in the current buffer and much of this manual is devoted
to describing these functions (*note Text::.).

   Several other data structures are associated with each buffer:

   * a local syntax table (*note Syntax Tables::.);

   * a local keymap (*note Keymaps::.); and,

   * a local variable binding list (*note Variables::.).

The local keymap and variable list contain entries which individually
override global bindings or values.  These are used to customize the
behavior of programs in different buffers, without actually changing
the programs.

   Buffers have no read syntax.  They print in hash notation with the
buffer name.

     (current-buffer)
          => #<buffer objects.texi>



File: elisp,  Node: Window Type,  Next: Window Configuration Type,  Prev: Buffer Type,  Up: Editing Types

Window Type
-----------

   A "window" describes the portion of the terminal screen that Emacs
uses to display a buffer.  Every window has one associated buffer,
whose contents appear in the window.  By contrast, a given buffer may
appear in one window, no window, or several windows.

   Though many windows may exist simultaneously, one window is
designated the "selected window".  This is the window where the
cursor is (usually) displayed when Emacs is ready for a command.  The
selected window usually displays the current buffer, but this is not
necessarily the case.

   Windows have no read syntax.  They print in hash notation, giving
the window number and the name of the buffer being displayed.  The
window numbers exist to identify windows uniquely, since the buffer
displayed in any given window can change frequently.

     (selected-window)
          => #<window 1 on objects.texi>

   *Note Windows::, for a description of the functions that work on
windows.



File: elisp,  Node: Window Configuration Type,  Next: Marker Type,  Prev: Window Type,  Up: Editing Types

Window Configuration Type
-------------------------

   A "window configuration" stores information about the positions
and sizes of windows at the time the window configuration is created,
so that the screen layout may be recreated later.

   Window configurations have no read syntax.  They print as
`#<window-configuration>'.  *Note Window Configurations::, for a
description of several functions related to window configurations.



File: elisp,  Node: Marker Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

Marker Type
-----------

   A "marker" denotes a position in a specific buffer.  Markers
therefore have two components: one for the buffer, and one for the
position.  The position value is changed automatically as necessary
as text is inserted into or deleted from the buffer.  This is to
ensure that the marker always points between the same two characters
in the buffer.

   Markers have no read syntax.  They print in hash notation, giving
the current character position and the name of the buffer.

     (point-marker)
          => #<marker at 10779 in objects.texi>

   *Note Markers::, for information on how to test, create, copy, and
move markers.



File: elisp,  Node: Process Type,  Next: Stream Type,  Prev: Marker Type,  Up: Editing Types

Process Type
------------

   The word "process" means a running program.  Emacs itself runs in
a process of this sort.  However, in Emacs Lisp, a process is a Lisp
object that designates a subprocess created by Emacs process. 
External subprocesses, such as shells, GDB, ftp, and compilers, may
be used to extend the processing capability of Emacs.

   A process takes input from Emacs and returns output to Emacs for
further manipulation.  Both text and signals can be communicated
between Emacs and a subprocess.

   Processes have no read syntax.  They print in hash notation,
giving the name of the process:

     (process-list)
          => (#<process shell>)

   *Note Processes::, for information about functions that create,
delete, return information about, send input or signals to, and
receive output from processes.


