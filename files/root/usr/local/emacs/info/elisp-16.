Info file elisp, produced by Makeinfo, -*- Text -*- from input file
elisp.texi.

   This file documents GNU Emacs Lisp.

   This is edition 1.03 of the GNU Emacs Lisp Reference Manual,   for
Emacs Version 18.

   Published by the Free Software Foundation, 675 Massachusetts
Avenue,  Cambridge, MA 02139 USA

   Copyright (C) 1990 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.



File: elisp,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Basic Windows,  Up: Windows

Splitting Windows
=================

   The functions described here are the primitives used to split a
window into two windows.  Two higher level functions sometimes split
a window, but not always: `pop-to-buffer' and `display-buffer' (*note
Displaying Buffers::.).

   The functions described here do not accept a buffer as an argument.
They let the two "halves" of the split window display the same buffer
previously visible in the window that was split.

 * Function: one-window-p &optional NO-MINI
     This function returns non-`nil' if there is only one window. 
     The argument NO-MINI, if non-`nil', means don't count the
     minibuffer even if it is active; otherwise, the minibuffer
     window is included, if active, in the total number of windows
     which is compared against one.

 * Command: split-window &optional WINDOW SIZE HORIZONTAL
     This function splits WINDOW into two windows.  The original
     window WINDOW remains the selected window, but occupies only
     part of its former screen area.  The rest is occupied by a newly
     created window which is returned as the value of this function.

     If HORIZONTAL is non-`nil', then WINDOW splits side by side,
     keeping the leftmost SIZE columns and giving the rest of the
     columns to the new window.  Otherwise, it splits into halves one
     above the other, keeping the upper SIZE lines and giving the
     rest of the lines to the new window.  The original window is
     therefore the right-hand or upper of the two, and the new window
     is the left-hand or lower.

     If WINDOW is omitted or `nil', then the selected window is
     split.  If SIZE is omitted or `nil', then WINDOW is divided
     evenly into two parts.  (If there is an odd line, it is
     allocated to the new window.)  When `split-window' is called
     interactively, all its arguments are `nil'.

     The following example starts with one window on a screen that is
     50 lines high by 80 columns wide; then the window is split.

          (setq w (selected-window))
               => #<window 8 on windows.texi>
          (window-edges)                  ; Edges in order: left--top--right--bottom
               => (0 0 80 50)
          
          (setq w2 (split-window w 15))   ; Returns window created
               => #<window 28 on windows.texi>
          (window-edges w2)
               => (0 15 80 50)            ; Bottom window; top is line 15
          (window-edges w)
               => (0 0 80 15)             ; Top window

     The screen looks like this:

                   __________ 
                  |          |  line 0  
                  |    w     |
                  |__________|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

     Next, the top window is split horizontally:

          (setq w3 (split-window w 35 t))
               => #<window 32 on windows.texi>
          (window-edges w3)
               => (35 0 80 15)  ; Left edge at column 35
          (window-edges w)
               => (0 0 35 15)   ; Right edge at column 35
          (window-edges w2)
               => (0 15 80 50)  ; Bottom window unchanged

     Now, the screen looks like this:

               column 35
                   __________ 
                  |   |      |  line 0  
                  | w |  w3  |
                  |___|______|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

 * Command: split-window-vertically SIZE
     This function splits the selected window into two windows, one
     above the other, leaving the selected window with SIZE lines.

     This function is simply an interface to `split-windows'.  Here
     is the complete function definition for it:

          (defun split-window-vertically (&optional arg)
            "Split selected window into two windows, one above the other..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg))))

 * Command: split-window-horizontally SIZE
     This function splits the selected window into two windows
     side-by-side, leaving the selected window with SIZE columns.

     This function is simply an interface to `split-windows'.  Here
     is the complete definition for `split-window-horizontally'
     (except for part of the documentation string):

          (defun split-window-horizontally (&optional arg)
            "Split selected window into two windows side by side..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg)) t))



File: elisp,  Node: Deleting Windows,  Next: Selecting Windows,  Prev: Splitting Windows,  Up: Windows

Deleting Windows
================

   A "deleted window" no longer appears on the screen.  In Emacs
version 18, the space it took up on the screen is divided
proportionally among all siblings; in version 19, the space is given
to one adjacent sibling.

 * Command: delete-window &optional WINDOW
     This function removes WINDOW from the display.  If WINDOW is
     omitted, then the selected window is deleted.  An error is
     signaled if there is only one window when `delete-window' is
     called.

          *Warning:* erroneous information or fatal errors may result
          from using a deleted window.  Use `(window-point WINDOW)'
          to test whether a window has been deleted; it yields `nil'
          for a deleted window.

     This function returns `nil'.

     When `delete-window' is called interactively, WINDOW defaults to
     the selected window.

 * Command: delete-other-windows &optional WINDOW
     This function makes WINDOW the only window on the screen by
     deleting all the other windows.  If WINDOW is omitted or `nil',
     then the selected window is used by default.

     The result is `nil'.

 * Command: delete-windows-on BUFFER
     This function deletes all windows showing BUFFER.  If there are
     no windows showing BUFFER, then this function does nothing.  If
     all windows are showing BUFFER (including the case where there
     is only one window), then the screen reverts to having a single
     window showing the buffer chosen by `other-buffer'.  *Note The
     Buffer List::.

     If there are several windows showing different buffers, then
     those showing BUFFER are removed, and the others are expanded to
     fill the void.

     The result is `nil'.



File: elisp,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

Selecting Windows
=================

   When a window is selected, the buffer in the window becomes the
current buffer, and the cursor will appear in it.

 * Function: selected-window
     This function returns the selected window.  This is the window
     in which the cursor appears and to which many commands apply.

 * Function: select-window WINDOW
     This function makes WINDOW the selected window.  The cursor then
     appears in WINDOW (on redisplay).  The buffer being displayed in
     WINDOW is immediately designated the current buffer.

     The return value is WINDOW.

          (setq w (next-window))
          (select-window w)
               => #<window 65 on windows.texi>

   The following functions choose one of the windows on the screen,
offering various criteria for the choice.

 * Function: get-lru-window
     This function returns the window least recently "used" (that is,
     selected).  The selected window is always the most recently used
     window.

     The selected window can be the least recently used window if it
     is the only window.  A newly created window becomes the least
     recently used window until it is selected.  The minibuffer
     window is not considered a candidate.

 * Function: get-largest-window
     This function returns the window with the largest area (height
     times width).  If there are no side-by-side windows, then this
     is the window with the most lines.  The minibuffer window is not
     considered a candidate.

     If there are two windows of the same size, then the function
     returns the window which is first in the cyclic ordering of
     windows (see following section), starting from the selected
     window.



File: elisp,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

Cycling Ordering of Windows
===========================

   When you use the command `C-x o' (`other-window') to select the
next window, it moves through all the windows on the screen in a
specific cyclic order.  For any given configuration of windows, this
order never varies.  It is called the "cyclic ordering of windows".

   This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the screen, or the windows within the screen, were
split.

   If the screen was first split vertically (into windows one above
each other), and then the subwindows were split horizontally, then
the ordering is left to right in the top, and then left to right in
the next lower part of the screen, and so on.  If the screen was
first split horizontally, the ordering is top to bottom in the left
part, and so on.  In general, within each set of siblings at any
level in the window tree, the order is left to right, or top to bottom.

 * Function: next-window WINDOW &optional MINIBUF
     This function returns the window following WINDOW in the cyclic
     ordering of windows.  This is the window which `C-x o' would
     select if done when WINDOW is selected.  If WINDOW is the only
     window visible, then this function returns WINDOW.

     The value of the argument MINIBUF determines whether the
     minibuffer is included in the window order.  Normally, when
     MINIBUF is `nil', the minibuffer is included if it is currently
     active; this is the behavior of `C-x o'.

     If MINIBUF is `t', then the cyclic ordering includes the
     minibuffer window even if it is not active.  If MINIBUF is
     neither `t' nor `nil', then the minibuffer window is not
     included even if it is active.  (The minibuffer window is active
     while the minibuffer is in use.  *Note Minibuffers::.)

     This example shows two windows, which both happen to be
     displaying the same buffer:

          (selected-window)
               => #<window 56 on windows.texi>
          (next-window (selected-window))
               => #<window 52 on windows.texi>
          (next-window (next-window (selected-window)))
               => #<window 56 on windows.texi>

 * Function: previous-window WINDOW
     This function returns the window preceding WINDOW in the cyclic
     ordering of windows.

 * Command: other-window COUNT
     This function selects the COUNTth next window in the cyclic
     order.  If count is negative, then it selects the -COUNTth
     preceding window.  It returns `nil'.

     In an interactive call, COUNT is the numeric prefix argument.



File: elisp,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

   This section describes low-level functions to examine windows or
to show buffers in windows in a precisely controlled fashion.

   *Note Displaying Buffers::, for

   related functions that find a window to use and specify a buffer
for it.  The functions described there are easier to use than these,
but they employ heuristics in choosing or creating a window; use
these functions when you need complete control.

 * Function: set-window-buffer WINDOW BUFFER-OR-NAME
     This function makes WINDOW display BUFFER-OR-NAME as its
     contents.  It returns `nil'.

          (set-window-buffer (selected-window) "foo")
               => nil

 * Function: window-buffer &optional WINDOW
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, then this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texi>

 * Function: get-buffer-window BUFFER-OR-NAME
     This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the first one in the
     cyclic ordering of windows, starting from the selected window. 
     *Note Cyclic Window Ordering::.

 * Command: replace-buffer-in-windows BUFFER
     This function replaces BUFFER with some other buffer in all
     windows displaying it.  The other buffer used is chosen with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make
     sure that BUFFER is off the screen.

     This function returns `nil'.



File: elisp,  Node: Displaying Buffers,  Next: Window Point,  Prev: Buffers and Windows,  Up: Windows

Displaying Buffers in Windows
=============================

   In this section we describe convenient functions that choose a
window automatically and use it to display a specified buffer.  These
functions can also split an existing window in certain circumstances.
We also describe variables that parameterize the heuristics used for
choosing a window.

   *Note Buffers and Windows::, for

   low-level functions that give you more precise control.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers on
the screen, which is gratuitous and will surprise the user.  Instead,
use `set-buffer' (*note Current Buffer::.) and `save-excursion'
(*note Excursions::.), which designate buffers as current for
programmed access without affecting the display of buffers in windows.

 * Command: switch-to-buffer BUFFER-OR-NAME &optional NORECORD
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a
     new buffer by that name is created.

     Normally the specified buffer is put at the front of the buffer
     list.  This affects the operation of `other-buffer'.  However,
     if NORECORD is non-`nil', this is not done.  *Note The Buffer
     List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It always returns `nil'.

 * Command: switch-to-buffer-other-window BUFFER-OR-NAME
     This function makes BUFFER-OR-NAME the current buffer and
     displays it in a window not currently selected.  It then selects
     that window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The previously selected window is absolutely never used to
     display the buffer.  If it is the only window, then it is split
     to make a distinct window for this purpose.  If the selected
     window is already displaying the buffer, then it continues to do
     so, but another window is nonetheless found to display it in as
     well.

 * Function: pop-to-buffer BUFFER-OR-NAME &optional OTHER-WINDOW
     This function makes BUFFER-OR-NAME the current buffer and
     switches to it in some window, preferably not the window
     previously selected.  The "popped-to" window becomes the
     selected window.

     If the variable `pop-up-windows' is non-`nil', windows may be
     split to create a new window that is different from the original
     window.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.

     An example use of this function is found at the end of *Note
     Filter Functions::.

 * Function: display-buffer BUFFER-OR-NAME &optional NOT-THIS-WINDOW
     This function makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.

     If NOT-THIS-WINDOW is non-`nil', it means that the specified
     buffer should be displayed in a window other than the selected
     one, even if it is already on display in the selected window. 
     This can cause the buffer to appear in two windows at once. 
     Otherwise, if BUFFER-OR-NAME is already being displayed in any
     window, that is good enough, so this function does nothing.

     If the variable `pop-up-windows' is non-`nil', windows can be
     split to display the buffer.  If there are multiple windows,
     `display-buffer' will split the largest window if it has more
     than the number of lines specified by the variable
     `split-height-threshold'.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

 * User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new
     windows.  If it is non-`nil' and there is only one window on the
     screen, then that window is split.  If it is `nil', then
     `display-buffer' does not split the single window, but rather
     replaces its buffer.

     This variable also affects `pop-to-buffer', which uses
     `display-buffer' as a subroutine.

 * User Option: split-height-threshold
     This variable determines when `display-buffer' may split a
     window, if there are multiple windows.  `display-buffer' splits
     the largest window if it has at least this many lines.

     If there is only one window, it is split regardless of this
     value, provided `pop-up-windows' is non-`nil'.



File: elisp,  Node: Window Point,  Next: Window Start,  Prev: Displaying Buffers,  Up: Windows

Window Point
============

   Each window has its own value of point, independent of the value
of point in other windows displaying the same buffer.  This makes it
useful to have multiple windows showing one buffer.

   * The window point is established when a window is first created;
     it is initialized from the buffer's point, or from the window
     point of another window opened on the buffer if such a window
     exists.

   * Selecting a window sets the value of point in its buffer to the
     window's value of point.  Conversely, deselecting a window
     copies the buffer's value of point into the window.  Thus, when
     you switch between windows that display a given buffer, the
     point value for the selected window is in effect in the buffer,
     while the point values for the other windows are stored in those
     windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   * *Note Positions::, for more details on positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 * Function: window-point WINDOW
     This function returns the current position of point in WINDOW. 
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion'
     forms.  But that value is hard to find.

 * Function: set-window-point WINDOW POSITION
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.



File: elisp,  Node: Window Start,  Next: Vertical Scrolling,  Prev: Window Point,  Up: Windows

The Display-Start Position
==========================

   Each window contains a marker used to keep track of a buffer
position which specifies where in the buffer display should start. 
This position is called the "display-start" position of the window. 
The character after this position is the one that appears at the
upper left corner of the window.  It is usually, but not inevitably,
at the beginning of a text line.

 * Function: window-start &optional WINDOW
     This function returns the display-start position of window
     WINDOW.  If WINDOW is `nil', the selected window is used.

          (window-start)
               => 7058

     For a more complicated example of use, see the description of
     `count-lines' in *Note Text Lines::.

 * Function: set-window-start WINDOW POSITION &optional NOFORCE
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.

     The display routines insist that the position of point be
     visible when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function with `nil' for NOFORCE, it
     means you want display to start at POSITION even if that would
     put the location of point off the screen.  What the display
     routines do in this case is move point instead, to the left
     margin on the middle line in the window.

     For example, if point is 1 and you attempt to set the start of
     the window to 2, then the position of point would be "above" the
     top of the window.  The display routines would automatically
     move point if it is still 1 when redisplay occurs.  Here is an
     example:

          ;; Here is what `foo' looks like before executing
          ;; the `set-window-start' expression.

             ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------


                    (set-window-start (selected-window) (1+ (window-start)))
          
          ;; Here is what `foo' looks like after executing
          ;; the `set-window-start' expression.

             ---------- Buffer: foo ----------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------
          
               => 2

     However, when NOFORCE is non-`nil', `set-window-start' does
     nothing if the specified start position would make point
     invisible.

     This function returns POSITION, regardless of whether the
     NOFORCE option caused that position to be overruled.

 * Function: pos-visible-in-window-p &optional POSITION WINDOW
     This function returns `t' if POSITION is within the range of
     text currently visible on the screen in WINDOW.  It returns
     `nil' if POSITION is scrolled vertically out of view.  The
     argument POSITION defaults to the current position of point;
     WINDOW, to the selected window.  Here is an example:

          (or (pos-visible-in-window-p (point) (selected-window))
              (recenter 0))

     The `pos-visible-in-window-p' function considers only vertical
     scrolling.  It returns `t' if POSITION is out of view only
     because WINDOW has been scrolled horizontally.  *Note Horizontal
     Scrolling::.



File: elisp,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Window Start,  Up: Windows

Vertical Scrolling
==================

   Vertical scrolling means moving the text up or down in a window. 
It works by changing the value of the window's display-start
location.  It may also change the value of `window-point' to keep it
on the screen.

   In the commands `scroll-up' and `scroll-down', the directions "up"
and "down" refer to the motion of the text in the buffer at which you
are looking through the window.  Imagine that the text is written on
a long roll of paper and that the scrolling commands move the paper
up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call `scroll-down', you will eventually see the
beginning of the buffer.

   Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
"down" commands would take you to the end of the buffer.  This view
is more consistent with the actual relationship between windows and
the text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short
scrolling commands clearly move the text up or down on the screen. 
We have chosen names that fit the user's point of view.

   The scrolling functions (aside from `scroll-other-window') will
have unpredictable results if the current buffer is different from
the buffer that is displayed in the selected window.  *Note Current
Buffer::.

 * Command: scroll-up &optional COUNT
     This function scrolls the text in the selected window upward
     COUNT lines.  If COUNT is negative, scrolling is actually
     downward.

     If COUNT is `nil' (or omitted), then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-up' returns `nil'.

 * Command: scroll-down &optional COUNT
     This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

     If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window.

     `scroll-down' returns `nil'.

 * Command: scroll-other-window &optional COUNT
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

     The window that is scrolled is normally the one following the
     selected window in the cyclic ordering of windows--the window
     that `next-window' would return.  *Note Cyclic Window Ordering::.

     If the selected window is the minibuffer, the next window is
     normally the one at the top left corner.  However, you can
     specify the window to scroll by binding the variable
     `minibuffer-scroll-window'.  This variable has no effect when
     any other window is selected.  *Note Minibuffer Misc::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' will attempt to scroll the
     minibuffer.  If the minibuffer contains just one line, that line
     will be redisplayed after the echo area momentarily displays the
     message "Beginning of buffer".

 * User Option: scroll-step
     This variable controls how scrolling is done automatically when
     point moves off the screen.  If the value is zero, then the text
     is scrolled so that point is centered vertically in the window. 
     If the value is a positive integer N, then if it is possible to
     bring point back on screen by scrolling N lines in either
     direction, that is done; otherwise, point is centered vertically
     as usual.  The default value is zero.

 * User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity
     to retain when scrolling by full screens.  For example, when
     `scroll-up' executes, this many lines that were visible at the
     bottom of the window move to the top of the window.  The default
     value is `2'.

 * Command: recenter &optional COUNT
     This function scrolls the selected window to put the text where
     point is located at a specified screen position.

     If COUNT is a nonnegative number, it puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is
     a negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.
     If COUNT is a non-`nil' list, then it stands for the line in the
     middle of the window.

     If COUNT is `nil', then it puts the line containing point in the
     middle of the window, then clears and redisplays the entire
     screen.

     When `recenter' is called interactively, Emacs sets COUNT to the
     raw prefix argument.  Thus, typing `C-u' as the prefix sets the
     COUNT to a non-`nil' list, while typing `C-u 4' sets COUNT to 4,
     which positions the current line four lines from the top.

     Typing `C-u 0 C-l' positions the current line at the top of the
     window.  This action is so handy that some people bind the
     command to a function key.  For example,

          (defun line-to-top-of-window ()
            "Scroll the selected window up so current line moves to the top.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive) 
            (recenter 0))
          
          (global-set-key "\C-cl" 'line-to-top-of-window)



File: elisp,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

Horizontal Scrolling
====================

   Because we read English first from top to bottom and second from
left to right, horizontal scrolling is not like vertical scrolling. 
Vertical scrolling involves selection of a contiguous portion of text
to display.  Horizontal scrolling causes part of each line to go off
screen.  The amount of horizontal scrolling is therefore specified as
a number of columns rather than as a position in the buffer.  It has
nothing to do with the display-start position returned by
`window-start'.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling
to the right is meaningless, since there is no data to the left of
the screen to be revealed by it, so it is not allowed.  Scrolling to
the left is allowed; it causes the first columns of text to go off
the edge of the window and can reveal additional columns on the right
that were truncated before.  Once a window has a nonzero amount of
leftward horizontal scrolling, you can scroll it back to the right,
but only so far as to reduce the net horizontal scroll to zero. 
There is no limit to how far left you can scroll, but eventually all
the text will disappear off the left edge.

 * Command: scroll-left COUNT
     This function scrolls the selected window COUNT columns to the
     left (or to the right if COUNT is negative).  The return value
     is the total amount of leftward horizontal scrolling in effect
     after the change--just like the value returned by
     `window-hscroll'.

 * Command: scroll-right COUNT
     This function scrolls the selected window COUNT columns to the
     right  (or to the left if COUNT is negative).  The return value
     is the total amount of leftward horizontal scrolling in effect
     after the change--just like the value returned by
     `window-hscroll'.

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther have no effect.

 * Function: window-hscroll &optional WINDOW
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.

     The value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

     If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 * Function: set-window-hscroll WINDOW COLUMNS
     This function sets the number of columns from the left margin
     that WINDOW is scrolled to the value of COLUMNS.  The argument
     COLUMNS should be zero or positive; if not, it is taken as zero.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (save-excursion 
       (goto-char POSITION)
       (and 
        (>= (- (current-column) (window-hscroll WINDOW)) 0)
        (< (- (current-column) (window-hscroll WINDOW))
           (window-width WINDOW))))



File: elisp,  Node: Size of Window,  Next: Resizing Windows,  Prev: Horizontal Scrolling,  Up: Windows

The Size of a Window
====================

   An Emacs window is rectangular, and its size information consists
of the height (the number of lines) and the width (the number of
character positions in each line).  The mode line is included in the
height.  For a window that does not abut the right hand edge of the
screen, the column of `|' characters that separates it from the
window on the right is included in the width.

   The following three functions return size information about a
window:

 * Function: window-height &optional WINDOW
     This function returns the number of lines in WINDOW, including
     its mode line.  If WINDOW fills the entire screen, this is one
     less than the value of `(screen-height)' (since the last line is
     always reserved for the minibuffer).

     If WINDOW is `nil', the function uses the selected window.

          (window-height)
               => 23
          (split-window-vertically)
               => #<window 4 on windows.texi>
          (window-height)
               => 11

 * Function: window-width &optional WINDOW
     This function returns the number of columns in WINDOW.  If
     WINDOW fills the entire screen, this is the same as the value of
     `(screen-width)'.

     If WINDOW is `nil', the function uses the selected window.

          (window-width)
               => 80

 * Function: window-edges &optional WINDOW
     This function returns a list of the edge coordinates of WINDOW. 
     If WINDOW is `nil', the selected window is used.

     The order of the list is `(LEFT TOP RIGHT BOTTOM)', all elements
     relative to 0, 0 at the top left corner of the screen.  The
     element RIGHT of the value is one more than the rightmost column
     used by WINDOW, and BOTTOM is one more than the bottommost row
     used by WINDOW and its mode-line.

     Here is the result obtained on a typical 24-line terminal with
     just one window:

          (window-edges (selected-window))
               => (0 0 80 23)

     If WINDOW is at the upper left corner of the screen, RIGHT and
     BOTTOM are the same as the values returned by `(window-width)'
     and `(window-height)' respectively, and TOP and BOTTOM are zero.
     For example, the edges of the following window are `0 0 5 8'. 
     Assuming that the screen has more than 8 columns, the last
     column of the window (column 7) holds a border rather than text.
     The last row (row 4) holds the mode line, shown here with
     `xxxxxxxxx'.

                     0    
                     _______
                  0 |       | 
                    |       |   
                    |       | 
                    |       | 
                    xxxxxxxxx  4
          
                            7

     When there are side-by-side windows, any window not at the right
     edge of the screen has a border in its last column.  This border
     counts as one column in the width of the window.  A window never
     includes a border on its left, since the border there belongs to
     the window to the left.

     In the following example, let's imagine that the screen is 7
     columns wide.  Then the edges of the left window are `0 0 4 3'
     and the edges of the right window are `4 0 7 3'.

                     ___ ___
                    |   |   |    
                    |   |   |    
                    xxxxxxxxx 
          
                     0  34  7



File: elisp,  Node: Resizing Windows,  Next: Window Configurations,  Prev: Size of Window,  Up: Windows

Changing the Size of a Window
=============================

   The window size functions fall into two classes: high-level
commands that change the size of windows and low-level functions that
access window size.  Emacs does not permit overlapping windows or
gaps between windows, so resizing one window affects other windows.

 * Command: enlarge-window SIZE &optional HORIZONTAL
     This function makes the selected window SIZE lines bigger,
     stealing lines from neighboring windows.  It generally tries to
     steal equal numbers of lines from the other windows.  If a
     window from which lines are stolen shrinks below
     `window-min-height', then that window disappears.

     If HORIZONTAL is non-`nil', then this function makes WINDOW
     wider by SIZE columns, stealing columns as it does lines.  If a
     window from which lines are stolen shrinks below
     `window-min-width', then that window disappears.

     If the screen is smaller than SIZE lines (or columns), then the
     function makes the window occupy the entire height (or width) of
     the screen.

     If SIZE is negative, this function shrinks the window by -SIZE
     lines.  If it becomes shorter than `window-min-height', it
     disappears.

     `enlarge-window' returns `nil'.

 * Command: enlarge-window-horizontally COLUMNS
     This function makes the selected window COLUMNS wider.  It could
     be defined as follows:

          (defun enlarge-window-horizontally (columns)
            (enlarge-window columns t))

 * Command: shrink-window SIZE &optional HORIZONTAL
     This function is like `enlarge-window' but negates the argument
     SIZE, making the selected window smaller by giving lines (or
     columns) to the other windows.  If the window shrinks below
     `window-min-height' or `window-min-width', then it disappears.

     If SIZE is negative, the window is enlarged by -SIZE lines.

 * Command: shrink-window-horizontally COLUMNS
     This function makes the selected window COLUMNS narrower.  It
     could be defined as follows:

          (defun shrink-window-horizontally (columns)
            (shrink-window columns t))

   The following two variables constrain the window size changing
functions to a minimum height and width.

 * User Option: window-min-height
     The value of this variable determines how short a window may
     become before it disappears.  A window disappears when it
     becomes smaller than `window-min-height', and no window may be
     created that is smaller.  The absolute minimum height is two
     (allowing one line for the mode line, and one line for the
     buffer display).  Actions which change window sizes reset this
     variable to two if it is less than two.  The default value is 4.

 * User Option: window-min-width
     The value of this variable determines how narrow a window may
     become before it disappears.  A window disappears when it
     becomes narrower than `window-min-width', and no window may be
     created that is narrower.  The absolute minimum width is one;
     any value below that is ignored.  The default value is 10.



File: elisp,  Node: Window Configurations,  Prev: Resizing Windows,  Up: Windows

Window Configurations
=====================

   "Window configurations" record entire screen layouts--all windows,
their sizes, which buffers they contain, what part of each buffer is
displayed, and the values of point and the mark.  You can bring back
an entire previous screen layout by restoring a window configuration
that you had previously saved.

 * Function: current-window-configuration
     This function returns a new object representing Emacs's current
     window configuration, namely the number of windows, their sizes
     and current buffers, which window is the selected window, and
     for each window the displayed buffer, the display-start
     position, and the positions of point and the mark.  An exception
     is made for point in the current buffer, whose value is not saved.

 * Function: set-window-configuration CONFIGURATION
     This function restores the configuration of Emacs's windows and
     buffers to the state specified by CONFIGURATION.  The argument
     CONFIGURATION must be a value that was previously returned by
     `current-window-configuration'.

     Here is a way of using this function to get the same effect as
     `save-window-excursion':

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-vertically nil)
                       ...)
              (set-window-configuration config)))

 * Special Form: save-window-excursion FORMS...
     This special form executes FORMS in sequence, preserving window
     sizes and contents, including the value of point and the portion
     of the buffer which is visible.  However, it does not restore
     the value of point in the current buffer; use `save-excursion'
     for that.

     The return value is the value of the final form in FORMS.  For
     example:

          (split-window)
               => #<window 25 on control.texi>
          (setq w (selected-window))
               => #<window 19 on control.texi>
          (save-window-excursion
            (delete-other-windows w)
            (switch-to-buffer "foo")
            'do-something)
               => do-something
            ;; The screen is now split again.

    Primitives to look inside of window configurations would make
sense, but none are implemented.  It is not clear they are useful
enough to be worth implementing.



File: elisp,  Node: Positions,  Next: Markers,  Prev: Windows,  Up: Top

Positions
*********

   A "position" is the index of a character in the text of buffer. 
More precisely, a position identifies the place between two
characters (or before the first character, or after the last
character), so we can speak of the character before or after a given
position.  However, the character after a position is often said to
be "at" that position.

   Positions are usually represented as integers starting from 1, but
can also be represented as "markers"--special objects which relocate
automatically when text is inserted or deleted so they stay with the
surrounding characters.  *Note Markers::.

* Menu:

* Point::         The special position where editing takes place.
* Motion::        Changing point.
* Excursions::    Temporary motion and buffer changes.
* Narrowing::     Restricting editing to a portion of the buffer.

 

File: elisp,  Node: Point,  Next: Motion,  Prev: Positions,  Up: Positions

Point
=====

   "Point" is a special buffer position used by many editing
commands, including the self-inserting typed characters and text
insertion functions.  Other commands move point through the text to
allow editing and insertion at different places.

   Like other positions, point designates a place between two
characters (or before the first character, or after the last
character), rather than a particular character.  Many terminals
display the cursor over the character that immediately follows point;
on such terminals, point is actually before the character on which
the cursor sits.

   The value of point is a number between 1 and the buffer size plus 1.
If narrowing is in effect (*note Narrowing::.), then point is
constrained to fall within the accessible portion of the buffer
(possibly at one end of it).

   Each buffer has its own value of point, which is independent of
the value of point in other buffers.  Each window also has a value of
point, which is independent of the value of point in other windows on
the same buffer.  This is why point can have different values in
various windows that display the same buffer.  When a buffer appears
in only one window, the buffer's point and the window's point
normally have the same value, so the distinction is rarely important.
*Note Window Point::, for more details.

 * Function: point
     This function returns the position of point in the current
     buffer, as an integer.

          (point)
               => 175

 * Function: point-min
     This function returns the minimum accessible value of point in
     the current buffer.  This is 1, unless narrowing is in effect,
     in which case it is the position of the start of the region that
     you narrowed to.  (*Note Narrowing::.)

 * Function: point-max
     This function returns the maximum accessible value of point in
     the current buffer.  This is `(1+ (buffer-size))', unless
     narrowing is in effect, in which case it is the position of the
     end of the region that you narrowed to.  (*Note Narrowing::).

 * Function: buffer-end FLAG
     This function returns `(point-min)' if FLAG is less than 1,
     `(point-max)' otherwise.  The argument FLAG must be a number.

 * Function: buffer-size
     This function returns the total number of characters in the
     current buffer.  In the absence of any narrowing (*note
     Narrowing::.), `point-max' returns a value one larger than this.

          (buffer-size)
               => 35
          (point-max)
               => 36

 * Variable: buffer-saved-size
     The value of this buffer-local variable is the former length of
     the current buffer, as of the last time it was read in, saved or
     auto-saved.



File: elisp,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

Motion
======

   Motion functions change the value of point, either relative to the
current value of point, relative to the beginning or end of the
buffer, or relative to the edges of the selected window.

* Menu:

* Character Motion::       Moving in terms of characters.
* Word Motion::            Moving in terms of words.
* Buffer End Motion::      Moving to the beginning or end of the buffer.
* Text Lines::             Moving in terms of lines of text.
* Screen Lines::           Moving in terms of lines as displayed.
* Vertical Motion::        Implementation of `next-line' and 
                             `previous-line'.
* List Motion::            Moving by parsing lists and sexps.
* Skipping Characters::    Skipping characters belonging to a certain set.

 

File: elisp,  Node: Character Motion,  Next: Word Motion,  Prev: Motion,  Up: Motion

Motion by Characters
--------------------

   These functions move point based on a count of characters. 
`goto-char' is a fundamental primitive because it is the way to move
point to a specified position.

 * Command: goto-char POSITION
     This function sets point in the current buffer to the value
     POSITION.  If POSITION is less than 1, then point is set to the
     beginning of the buffer.  If it is greater than the length of
     the buffer, then point is set to the end of the buffer.

     If narrowing is in effect, then the position is still measured
     from the beginning of the buffer, but point cannot be moved
     outside of the accessible portion.  Therefore, if POSITION is
     too small, point is set to the beginning of the accessible
     portion of the text; if POSITION is too large, point is set to
     the end.

     When this function is called interactively, POSITION is the
     numeric prefix argument, if provided; otherwise it is read from
     the minibuffer.

     `goto-char' returns POSITION.

 * Command: forward-char &optional COUNT
     This function moves point forward, towards the end of the
     buffer, COUNT characters (or backward, towards the beginning of
     the buffer, if COUNT is negative).  If the function attempts to
     move point past the beginning or end of the buffer (or the
     limits of the accessible portion, when narrowing is in effect),
     an error is signaled with error code `beginning-of-buffer' or
     `end-of-buffer'.

     In an interactive call, COUNT is the numeric prefix argument.

 * Command: backward-char &optional COUNT
     This function moves point backward, towards the beginning of the
     buffer, COUNT characters (or forward, towards the end of the
     buffer, if COUNT is negative).  If the function attempts to move
     point past the beginning or end of the buffer (or the limits of
     the accessible portion, when narrowing is in effect), an error
     is signaled with error code `beginning-of-buffer' or
     `end-of-buffer'.

     In an interactive call, COUNT is the numeric prefix argument.


