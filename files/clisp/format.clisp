;;; -*-Lisp-*-
;;;
;;; **********************************************************************
;;; This code was written as part of the Spice Lisp project at
;;; Carnegie-Mellon University, and has been placed in the public domain.
;;; If you want to use this code or any part of Spice Lisp, please contact
;;; Scott Fahlman (FAHLMAN@CMUC). 
;;; **********************************************************************
;;;
;;; Functions to implement FORMAT for Spice Lisp.
;;;
;;; Original by David Adam.
;;; Re-write by Bill Maddox.
;;; Currently maintained by Bill Maddox.
;;;
;;; FORMAT is part of the standard Spice Lisp environment.
;;;
;;; **********************************************************************

(in-package 'lisp)

(export '(format))

;;; Special variables local to FORMAT

(defvar *format-control-string* ""
  "The current FORMAT control string")

(defvar *format-index* 0
  "The current index into *format-control-string*")

(defvar *format-length* 0
  "The length of the current FORMAT control string")

(defvar *format-arguments* ()
  "Arguments to the current call of FORMAT")

(defvar *format-original-arguments* ()
 "Saved arglist from top-level FORMAT call for ~* and ~@*")

(defvar *format-stream-stack* ()
  "A stack of string streams for collecting FORMAT output")

;;; This is bound in FORMAT-INIT.

(defvar *format-dispatch-table* ()
  "Dispatch table for FORMAT commands")


;;; Specials imported from PRINT and STREAM

(proclaim '(special *print-base* *standard-output* *terminal-io*))

;;; Specials imported from ERRORFUNS

(proclaim '(special *error-output*))



;;; ERRORS

;;; Since errors may occur while an indirect control string is being
;;; processed, i.e. by ~? or ~{~:}, some sort of backtrace is necessary
;;; in order to indicate the location in the control string where the
;;; error was detected.  To this end, errors detected by format are
;;; signalled by throwing a list of the form ((control-string args))
;;; to the tag FORMAT-ERROR.  This throw will be caught at each level
;;; of indirection, and the list of error messages re-thrown with an
;;; additional message indicating that indirection was present CONSed
;;; onto it.  Ultimately, the last throw will be caught by the top level
;;; FORMAT function, which will then signal an error to the Slisp error
;;; system in such a way that all the errror messages will be displayed
;;; in reverse order.

(defun format-error (complaint &rest args)
  (throw 'format-error
	 (list (list "~1{~:}~%~S~%~V@T^" complaint args
		     *format-control-string* (1+ *format-index*)))))



;;; MACROS

;;; This macro establishes the correct environment for processing
;;; an indirect control string.  CONTROL-STRING is the string to
;;; process, and FORMS are the forms to do the processing.  They 
;;; invariably will involve a call to SUB-FORMAT.  CONTROL-STRING
;;; is guaranteed to be evaluated exactly once.

(defmacro format-with-control-string (control-string &body forms)
  `(let ((string (if (simple-string-p ,control-string)
		     ,control-string
		     (coerce ,control-string 'simple-string))))
     (declare (simple-string string))
     (let ((error (catch 'format-error
			 (let ((*format-control-string* string)
			       (*format-length* (length string))
			       (*format-index* 0))
			   ,@forms
			   nil))))
       (when error
	 (throw 'format-error
	   (cons (list "While processing indirect control string~%~S~%~V@T^"
		       *format-control-string*
		       (1+ *format-index*))
	       error))))))


;;; This macro rebinds collects output to the standard output stream
;;; in a string.  For efficiency, we avoid consing a new stream on
;;; every call.  A stack of string streams is maintained in order to
;;; guarantee re-entrancy.

(defmacro format-stringify-output (&body forms)
  `(let ((*standard-output*
	  (if *format-stream-stack*
	      (pop *format-stream-stack*)
	      (make-string-output-stream))))
     (unwind-protect
      (progn ,@forms
	     (prog1
	      (get-output-stream-string *standard-output*)
	      (push *standard-output* *format-stream-stack*)))
      (get-output-stream-string *standard-output*))))



;;; Pops an argument from the current argument list.  This is either the
;;; list of arguments given to the top-level call to FORMAT, or the argument
;;; list for the current iteration in a ~{~} construct.  An error is signalled
;;; if the argument list is empty.

(defmacro pop-format-arg ()
  '(if *format-arguments*
       (pop *format-arguments*)
       (format-error "Missing argument")))


;;; This macro decomposes the argument list returned by PARSE-FORMAT-OPERATION.
;;; PARMVAR is the list of parameters.  PARMDEFS is a list of lists of the form
;;; (<var> <default>).  The FORMS are evaluated in an environment where each 
;;; <var> is bound to either the value of the parameter supplied in the 
;;; parameter list, or to its <default> value if the parameter was omitted or
;;; explicitly defaulted.

(defmacro with-format-parameters (parmvar parmdefs &body forms)
  (do ((parmdefs parmdefs (cdr parmdefs))
       (bindings () (cons `(,(caar parmdefs) (or (if ,parmvar (pop ,parmvar))
						 ,(cadar parmdefs)))
			 bindings)))
      ((null parmdefs)
       `(let ,(nreverse bindings)
	  (when ,parmvar
	    (format-error "Too many parameters"))
	  ,@forms))))



;;; CONTROL STRING PARSING 

;;; The current control string is kept in *format-control-string*. 
;;; The variable *format-index* is the position of the last character
;;; processed, indexing from zero.  The variable *format-length* is the
;;; length of the control string, which is one greater than the maximum
;;; value of *format-index*.  


;;; Gets the next character from the current control string.  It is an
;;; error if there is none.  Leave *format-index* pointing to the
;;; character returned.

(defmacro nextchar ()
  '(if (< (incf *format-index*) *format-length*)
       (schar *format-control-string* *format-index*)
       (format-error "Syntax error")))


;;; Returns the current character, i.e. the one pointed to by *format-index*.

(defmacro format-peek ()
  '(schar *format-control-string* *format-index*))


;;; Returns the index of the first occurrence of the specified character
;;; between indices START (inclusive) and END (exclusive) in the control
;;; string.


(defmacro format-find-char (char start end)
  `(position ,char (the simple-string *format-control-string*)
	     :start ,start :end ,end :test #'char=))


;;; Attempts to parse a parameter, starting at the current index.
;;; Returns the value of the parameter, or NIL if none is found. 
;;; On exit, *format-index* points to the first character which is
;;; not a part of the recognized parameter.

(defun format-get-parameter ()
  (case (format-peek)
    (#\# (nextchar) (length *format-arguments*))
    ((#\V #\v)
     (prog1 (pop-format-arg) (nextchar)))
    (#\' (prog1 (nextchar) (nextchar)))
    ((#\0 #\1 #\2 #\3 #\4
      #\5 #\6 #\7 #\8 #\9)
     (do* ((number (digit-char-p (format-peek))
		   (+ (* 10 number) (digit-char-p (format-peek)))))
	  ((not (digit-char-p (nextchar))) number)))
    (#\-
     (nextchar)
     (case (format-peek)
       ((#\0 #\1 #\2 #\3 #\4
	 #\5 #\6 #\7 #\8 #\9)
	(do* ((number (digit-char-p (format-peek))
		      (+ (* 10 number) (digit-char-p (format-peek)))))
	     ((not (digit-char-p (nextchar))) (- number))))
       (t (decf *format-index*)		; put back to out of place "-"
	  nil)))
    (#\+
     (nextchar)
     (case (format-peek)
       ((#\0 #\1 #\2 #\3 #\4
	 #\5 #\6 #\7 #\8 #\9)
	(do* ((number (digit-char-p (format-peek))
		      (+ (* 10 number) (digit-char-p (format-peek)))))
	     ((not (digit-char-p (nextchar))) number)))
       (t (decf *format-index*)		; put back to out of place "+"
	  nil)))
    (t nil)))


;;; Parses a format directive, including flags and parameters.  On entry,
;;; *format-index* should point to the "~" preceding the command.  On
;;; exit, *format-index* points to the command character itself.
;;; Returns the list of parameters, the ":" flag, the "@" flag, and the
;;; command character as multiple values.  Explicitly defaulted parameters
;;; appear in the list of parameters as NIL.  Omitted parameters are simply 
;;; not included in the list at all.

(defun parse-format-operation ()
  (let ((ch (nextchar)))
    (values (if (or (digit-char-p ch)
		    (member ch '(#\, #\# #\V #\v #\' #\+ #\-) :test #'char=))
		(do ((parms (list (format-get-parameter))
			    (cons (format-get-parameter) parms)))
		    ((char/= (format-peek) #\,) (nreverse parms))
		  (nextchar))
		'())
	    (if (char= (format-peek) #\:) (nextchar) nil)
	    (if (char= (format-peek) #\@) (nextchar) nil)
	    (format-peek))))



;;; Starting at the current value of *format-index*, finds the first
;;; occurrence of one of the specified directives. Embedded constructs,
;;; i.e. those inside ~(~), ~[~], ~{~}, or ~<~>, are ignored.  And error is
;;; signalled if no satisfactory command is found.  Otherwise, the
;;; following are returned as multiple values:
;;;
;;;     The value of *format-index* at the start of the search
;;;     The index of the "~" character preceding the command
;;;     The parameter list of the command
;;;     The ":" flag
;;;     The "@" flag
;;;     The command character
;;;
;;; Implementation note:  The present implementation is not particulary
;;; careful with storage allocation.  It would be a good idea to have
;;; a separate function for skipping embedded constructs which did not
;;; bother to cons parameter lists and then throw them away.
;;;
;;; We go to some trouble here to use POSITION for most of the searching.

(defun format-find-command (command-list)
  (let ((start *format-index*))
    (do ((place start *format-index*)
	 (tilde (format-find-char #\~ start *format-length*)
		(format-find-char #\~ place *format-length*)))
	((not tilde)
	 (format-error "Expecting one of ~S" command-list))
      (setq *format-index* tilde)
      (multiple-value-bind
       (parms colon atsign command)
       (parse-format-operation)
       (when (member command command-list :test #'char=)
	 (return (values start tilde parms colon atsign command)))
       (case command
	 (#\{ (nextchar)(format-find-command '(#\})))
	 (#\< (nextchar)(format-find-command '(#\>)))
	 (#\( (nextchar)(format-find-command '(#\))))
	 (#\[ (nextchar)(format-find-command '(#\])))
	 ((#\} #\> #\) #\])
	  (format-error "No matching bracket")))))))

 

;;; This is the FORMAT top-level function.

(defun format (destination control-string &rest format-arguments)
  "Provides various facilities for formatting output.
  CONTROL-STRING contains a string to be output, possibly with embedded
  directives, which are flagged with the escape character \"~\".  Directives
  generally expand into additional text to be output, usually consuming one
  or more of the FORMAT-ARGUMENTS in the process.  A few useful directives
  are:
        ~A or ~nA     Prints one argument as if by PRINC
        ~S or ~nS     Prints one argument as if by PRIN1
        ~D or ~nD     Prints one argument as a decimal integer
        ~%            Does a TERPRI
        ~&            Does a FRESH-LINE

         where n is the width of the field in which the object is printed.
  
  DESTINATION controls where the result will go.  If DESTINATION is T, then
  the output is sent to the standard output stream.  If it is NIL, then the
  output is returned in a string as the value of the call.  Otherwise,
  DESTINATION must be a stream to which the output will be sent.

  Example:   (FORMAT NIL \"The answer is ~D.\" 10) => \"The answer is 10.\"

  FORMAT has many additional capabilities not described here.  Consult the
  manual for details."

  (let ((*format-original-arguments* format-arguments)	;for abs. and rel. goto
	(*format-arguments* format-arguments)
	(*format-control-string*
	 (if (simple-string-p control-string)
	     control-string
	     (coerce control-string 'simple-string))))
    (cond
     ((not destination)
      (format-stringify-output
       (let ((errorp (catch 'format-error
		       (catch 'format-escape
			 (catch 'format-colon-escape
			   (sub-format 0 (length control-string))))
		       nil)))
	 (when errorp
	   (error "~%~:{~@?~%~}" (nreverse errorp))))))
     ((and (stringp destination) (array-has-fill-pointer-p destination))
      (with-output-to-string (*standard-output* destination)
	(let ((errorp (catch 'format-error
			(catch 'format-escape
			  (catch 'format-colon-escape
			    (sub-format 0 (length control-string))))
			nil)))
	  (when errorp
	    (error "~%~:{~?~%~}" (reverse errorp)))
	  nil)))
     (t
      (let ((*standard-output*
	     (if (eq destination 't) *standard-output* destination)))
	(let ((errorp (catch 'format-error
			(catch 'format-escape
			  (catch 'format-colon-escape
			    (sub-format 0 (length control-string))))
			nil)))
	  (when errorp
	    (error "~%~:{~@?~%~}" (nreverse errorp))))
	nil)))))



;;; This function does the real work of format.  The segment of the control
;;; string between indiced START (inclusive) and END (exclusive) is processed
;;; as follows: Text not part of a directive is output without further
;;; processing.  Directives are parsed along with their parameters and flags,
;;; and the appropriate handlers invoked with the arguments COLON, ATSIGN, and
;;; PARMS. 
;;;
;;; Implementation Note: FORMAT-FIND-CHAR uses the POSITION stream operation
;;; for speed.  This is potentially faster than character-at-a-time searching.

(defun sub-format (start end)
  (let ((*format-index* start)
	(*format-length* end))
    (do* ((place start *format-index*)
	  (tilde (format-find-char #\~ start end)
		 (format-find-char #\~ place end)))
	 ((not tilde)
	  (%sp-write-string *format-control-string*
			    *standard-output* place end))
      (when (> tilde place)
	(%sp-write-string *format-control-string*  *standard-output*
			  place tilde))
      (setq *format-index* tilde)
      (multiple-value-bind
       (parms colon atsign command)
       (parse-format-operation)
       (let ((cmdfun (svref *format-dispatch-table* (char-code command))))
	 (if cmdfun
	     (funcall cmdfun colon atsign parms)
	     (format-error "Illegal FORMAT command ~~~S" command))))
      (unless (< (incf *format-index*) end) (return)))))



;;; Conditional case conversion  ~( ... ~)

(defun format-capitalization (colon atsign parms)
  (when parms
    (format-error "No parameters allowed to ~~\("))
  (nextchar)
  (multiple-value-bind
   (prev tilde end-parms end-colon end-atsign)
   (format-find-command '(#\)))
   (when (or end-parms end-colon end-atsign)
     (format-error "Flags or parameters not allowed"))
   (let ((string (format-stringify-output (sub-format prev tilde))))
     (write-string
      (cond ((and atsign colon) (nstring-upcase string))
	    (colon (nstring-capitalize string))
	    ;; Capitalize the first word only
	    (atsign (nstring-downcase string)
		    (dotimes (i (length string) string)
		      (when (alpha-char-p (char string i))
			    (setf (char string i)
				  (char-upcase (char string i)))
			    (return string))))
	    (t (nstring-downcase string)))))))



;;; Up and Out (Escape)  ~^

(defun format-escape (colon atsign parms)
  (when atsign
    (format-error "FORMAT command ~~~:[~;:~]@^ is undefined" colon))
  (when (if (first parms)
	    (if (second parms)
		(if (third parms)
		    (typecase (second parms)
		      (integer
		       (<= (first parms) (second parms) (third parms)))
		      (character
		       (char< (first parms) (second parms) (third parms)))
		      (t nil))
		    (equal (first parms) (second parms)))
		(zerop (first parms)))
	    (not *format-arguments*))
    (throw (if colon 'format-colon-escape 'format-escape) nil)))


;;; Conditional expression  ~[ ... ]


;;; ~[ 

(defun format-untagged-condition ()
  (let ((test (pop-format-arg)))
    (unless (integerp test)
      (format-error "Argument to ~~[ must be integer - ~S" test))
    (do ((count 0 (1+ count)))
	((= count test)
	 (multiple-value-bind
	  (prev tilde parms colon atsign cmd)
	  (format-find-command '(#\; #\]))
	  (declare (ignore colon))
	  (when atsign
	    (format-error "Atsign flag not allowed"))
	  (when parms
	    (format-error "No parameters allowed"))
	  (sub-format prev tilde)
	  (unless (char= cmd #\])
	    (format-find-command '(#\])))))
      (multiple-value-bind
       (prev tilde parms colon atsign cmd)
       (format-find-command '(#\; #\]))
       (declare (ignore prev tilde))
       (when atsign
	 (format-error "Atsign flag not allowed"))
       (when parms
	 (format-error "Parameters not allowed"))
       (when (char= cmd #\]) (return))
       (when colon
	 (nextchar)
	 (multiple-value-bind (prev tilde parms colon atsign cmd)
			      (format-find-command '(#\; #\]))
	   (declare (ignore parms colon atsign))
	   (sub-format prev tilde)
	   (unless (char= cmd #\])
	     (format-find-command '(#\]))))
	 (return))
       (nextchar)))))


;;; ~@[

(defun format-funny-condition ()
  (multiple-value-bind
   (prev tilde parms colon atsign)
   (format-find-command '(#\]))
   (when (or colon atsign parms)
     (format-error "Flags or arguments not allowed"))
   (if *format-arguments*
       (if (car *format-arguments*)
	   (sub-format prev tilde)
	   (pop *format-arguments*))
       (format-error "Missing argument"))))


;;; ~:[ 

(defun format-boolean-condition ()
  (multiple-value-bind
   (prev tilde parms colon atsign)
   (format-find-command '(#\;))
   (when (or parms colon atsign)
     (format-error "Flags or parameters not allowed"))
   (nextchar)			  
   (if (pop-format-arg)
       (multiple-value-bind
	(prev tilde parms colon atsign)
	(format-find-command '(#\]))
	(when (or colon atsign parms)
	  (format-error "Flags or parameters not allowed"))
	(sub-format prev tilde))
       (progn
	(sub-format prev tilde)
	(format-find-command '(#\]))))))


(defun format-condition (colon atsign parms)
  (when parms
    (push (pop parms) *format-arguments*)
    (unless (null parms)
      (format-error "Too many parameters to ~[")))
  (nextchar)
  (cond (colon
	 (when atsign
	   (format-error  "~~:@[ undefined"))
	 (format-boolean-condition))
	(atsign
	 (format-funny-condition))
	(t (format-untagged-condition))))


;;; Iteration  ~{ ... ~}

(defun format-iteration (colon atsign parms)
  (with-format-parameters parms ((max-iter -1))
    (nextchar)
    (multiple-value-bind
     (prev tilde end-parms end-colon end-atsign)
     (format-find-command '(#\}))
     (when (or end-atsign end-parms)
       (format-error "Illegal terminator for ~~{"))
     (if (= prev tilde)
	 ;; Use an argument as the control string if ~{~} is empty
	 (let ((string (pop-format-arg)))
	   (unless (stringp string)
	     (format-error "Control string is not a string"))
	   (format-with-control-string string
	     (format-do-iteration 0 *format-length*
				  max-iter colon atsign end-colon)))
	 (format-do-iteration prev tilde max-iter colon atsign end-colon)))))


;;; The two catch tags FORMAT-ESCAPE and FORMAT-COLON-ESCAPE are needed here
;;; to correctly implement ~^ and ~:^.  The former aborts only the current
;;; iteration, but the latter aborts the entire iteration process.

(defun format-do-iteration (start end max-iter colon atsign at-least-once-p)
  (catch 'format-colon-escape
    (catch 'format-escape
      (if atsign
	  (do* ((count 0 (1+ count)))
	       ((or (= count max-iter)
		    (and (null *format-arguments*)
			 (if (= count 0) (not at-least-once-p) t))))
	    (catch (if colon 'format-escape nil)
	      (if colon
		  (let* ((*original-arguments* (pop-format-arg))
			 (*format-arguments* *original-arguments*))
		    (unless (listp *format-arguments*)
		      (format-error "Argument must be a list"))
		    (sub-format start end))
		  (sub-format start end))))
	  (let* ((*original-arguments* (pop-format-arg))
		 (*format-arguments* *original-arguments*))
	    (unless (listp *format-arguments*)
	      (format-error "Argument must be a list"))
	    (do* ((count 0 (1+ count)))
		 ((or (= count max-iter)
		      (and (null *format-arguments*)
			   (if (= count 0) (not at-least-once-p) t))))
	      (catch (if colon 'format-escape nil)
		(if colon
		    (let* ((*original-arguments* (pop-format-arg))
			   (*format-arguments* *original-arguments*))
		      (unless (listp *format-arguments*)
			(format-error "Argument must be a list of lists"))
		      (sub-format start end))
		    (sub-format start end)))))))))
  


;;; Justification  ~< ... ~>

;;; Parses a list of clauses delimited by ~; and terminated by ~>.
;;; Recursively invoke SUB-FORMAT to process them, and return a list
;;; of the results, the length of this list, and the total number of
;;; characters in the strings composing the list.

(defun format-get-trailing-segments ()
  (nextchar)
  (multiple-value-bind
   (prev tilde colon atsign parms cmd)
   (format-find-command '(#\; #\>))
   (when colon
     (format-error "~~:; allowed only after first segment in ~~<"))
   (when (or atsign parms)
     (format-error "Flags and parameters not allowed"))
   (let ((str (catch 'format-escape
		(format-stringify-output (sub-format prev tilde)))))
     (if str
	 (if (char= cmd #\;)
	     (multiple-value-bind
	      (segments numsegs numchars)
	      (format-get-trailing-segments)
	      (values (cons str segments)
		      (1+ numsegs) (+ numchars (length str))))
	     (values (list str) 1 (length str)))
	 (values () 0 0)))))


;;; Gets the first segment, which is treated specially.  Call 
;;; FORMAT-GET-TRAILING-SEGMENTS to get the rest.

(defun format-get-segments ()
  (multiple-value-bind
   (prev tilde parms colon atsign cmd)
   (format-find-command '(#\; #\>))
   (when atsign
     (format-error "Atsign flag not allowed"))
   (let ((first-seg (format-stringify-output (sub-format prev tilde))))
     (if (char= cmd #\;)
	 (multiple-value-bind
	  (segments numsegs numchars)
	  (format-get-trailing-segments)
	  (if colon
	      (values first-seg parms segments numsegs numchars)
	      (values nil nil (cons first-seg segments) (1+ numsegs)
		      (+ (length first-seg) numchars))))
	 (values nil nil (list first-seg) 1 (length first-seg))))))


   

;;; Given the total number of SPACES needed for padding, and the number
;;; of padding segments needed (PADDINGS), returns a list of such segments.
;;; We try to allocate the spaces equally to each segment.  When this is
;;; not possible, we allocate the left-over spaces randomly, to improve the
;;; appearance of many successive lines of justified text.
;;; 
;;; Query:  Is this right?  Perhaps consistency might be better for the kind
;;; of applications ~<~> is used for.

(defun make-pad-segs (spaces paddings)
  (do* ((extra-space () (and (plusp extra-spaces)
			     (< (random (float 1)) (/ segs extra-spaces))))
	(result () (cons (if extra-space (1+ min-space) min-space) result))
	(min-space (truncate spaces paddings))
	(extra-spaces (- spaces (* paddings min-space))
		      (if extra-space (1- extra-spaces) extra-spaces))
	(segs paddings (1- segs)))
       ((zerop segs) result)))
  

;;; Determine the actual width to be used for a field requiring WIDTH
;;; characters according to the following rule:  If WIDTH is less than or
;;; equal to MINCOL, use WIDTH as the actual width.  Otherwise, round up 
;;; to MINCOL + k * COLINC for the smallest possible positive integer k.

(defun format-round-columns (width mincol colinc)
  (if (> width mincol)
      (multiple-value-bind
       (quotient remainder)
       (floor (- width mincol) colinc)
       (+ mincol (* quotient colinc) (if (zerop remainder) 0 colinc)))
      mincol))



(defun format-justification (colon atsign parms)
  (with-format-parameters parms
    ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
    (unless (and (integerp mincol) (not (minusp mincol)))
      (format-error "Mincol must be a non-negative integer - ~S" mincol))
    (unless (and (integerp colinc) (plusp colinc))
      (format-error "Colinc must be a positive integer - ~S" colinc))
    (unless (and (integerp minpad) (not (minusp minpad)))
      (format-error "Minpad must be a non-negative integer - ~S" minpad))
    (unless (characterp padchar)
      (format-error "Padchar must be a character - ~S" padchar))
    (nextchar)
    (multiple-value-bind
     (special-arg special-parms segments numsegs numchars)
     (format-get-segments)
     (let* ((padsegs (+ (if (or colon (and (not atsign) (= numsegs 1))) 1 0)
			(1- numsegs)
			(if atsign 1 0)))
	    (width (format-round-columns (+ numchars (* minpad padsegs))
					 mincol colinc))
	    (spaces (append (if (or colon (and (not atsign) (= numsegs 1)))
				() '(0))
			    (make-pad-segs (- width numchars) padsegs)
			    (if atsign () '(0)))))
       (when special-arg
	 (with-format-parameters special-parms ((spare 0)
						(linel (or (line-length) 72)))
	   (let ((pos (or (charpos *standard-output*) 0)))
	     (when (> (+ pos width spare) linel)
	       (write-string special-arg)))))
       (do ((segs segments (cdr segs))
	    (spcs spaces (cdr spcs)))
	   ((null segs) (dotimes (i (car spcs)) (write-char padchar)))
	 (dotimes (i (car spcs)) (write-char padchar))
	 (write-string (car segs)))))))

  

;;; Newline  ~&

(defun format-terpri (colon atsign parms)
  (when (or colon atsign)
    (format-error "Flags not allowed"))
  (with-format-parameters parms ((repeat-count 1))
    (dotimes (i repeat-count) (terpri))))


;;; Fresh-line  ~%

(defun format-freshline (colon atsign parms)
  (when (or colon atsign)
    (format-error "Flags not allowed"))
  (with-format-parameters parms ((repeat-count 1))
    (fresh-line)
    (dotimes (i (1- repeat-count)) (terpri))))


;;; Page  ~|

(defun format-page (colon atsign parms)
  (when (or colon atsign)
    (format-error "Flags not allowed"))
  (with-format-parameters parms ((repeat-count 1))
    (dotimes (i repeat-count) (write-char #\form))))


;;; Print a tilde  ~~

(defun format-tilde (colon atsign parms)
  (when (or colon atsign)
    (format-error "Flags not allowed"))
  (with-format-parameters parms ((repeat-count 1))
    (dotimes (i repeat-count) (write-char #\~))))


;;; Continue control string on next line  ~<newline>

(defun format-eat-whitespace ()
  (nextchar)
  (setq *format-index*
	(1- (position-if-not #'(lambda (ch) (or (whitespace-char-p ch)
						(char= ch #\linefeed)))
			     *format-control-string*
			     :start *format-index*))))


;;; Whitespace-Char-P returns T if the argument is considered whitespace;
;;; NIL otherwise.
;;; Written by Dave Steiner@Rutgers.  20 August 84. 
;;; Changed to conform to slisp version DKS  6 March 85.

(defun whitespace-char-p (char)
  "Determines whether or not a character is considered whitespace."
  (or (char= char #\space)
      (char= char #\tab)
      (char= char #\page)
      (char= char #\newline)
      (char= char #\return)
      (char= char #\linefeed)))

(defun format-newline (colon atsign parms)
  (when parms
    (format-error "Parameters not allowed"))
  (cond (colon
	 (when atsign (format-error "~:@<newline> is undefined")))
	(atsign (terpri)(format-eat-whitespace))
	(t (format-eat-whitespace))))


;;; Pluralize word  ~P

(defun format-plural (colon atsign parms)
  (when parms
    (format-error "Parameters not allowed"))
  (when colon
    ;; Back up one argument first
    (let ((cdrs (- (length *format-original-arguments*)
		   (length *format-arguments*)
		   1)))
      (if (minusp cdrs)
	  (format-error  "No previous argument")
	  (setq *format-arguments*
		(nthcdr cdrs *format-original-arguments*)))))
  (if (eql (pop-format-arg) 1)
      (write-string (if atsign "y" ""))
      (write-string (if atsign "ies" "s"))))



;;; Skip arguments  (relative goto)  ~*

(defun format-skip-arguments (colon atsign parms)
  (with-format-parameters parms ((count 1))
    (cond (atsign
	   (when (or (minusp count)
		     (> count (length *format-original-arguments*)))
	     (format-error "Illegal to go to non-existant argument"))
	   (setq *format-arguments*
		 (nthcdr count *format-original-arguments*)))
	  (colon
	   (let ((cdrs (- (length *format-original-arguments*)
			  (length *format-arguments*)
			  count)))
	     (if (minusp cdrs)
		 (format-error  "Skip to nonexistant argument")
		 (setq *format-arguments*
		       (nthcdr cdrs *format-original-arguments*)))))
	  (t
	   (if (> count (length *format-arguments*))
	       (format-error "Skip to nonexistant argument")
	       (setq *format-arguments* (nthcdr count *format-arguments*)))))))

  

;;; Indirection  ~?.  With atsign, indirects only the control string.

(defun format-indirection (colon atsign parms)
  (when (or colon parms)
    (format-error "Flags or parameters not allowed"))
  (if atsign
    (let ((string (pop-format-arg)))
      (unless (stringp string)
        (format-error "Indirected control string is not a string"))
      (format-with-control-string string
        (sub-format 0 *format-length*)))
    (let ((string (pop-format-arg))
  	  (*format-arguments* (pop-format-arg)))
       (unless (stringp string)
        (format-error "Indirected control string is not a string"))
      (format-with-control-string string
        (sub-format 0 *format-length*)))))

;;; Tabulation  ~T

(defun format-tab (colon atsign parms)
  (with-format-parameters parms ((colnum 1) (colinc 1))
    (when colon
      (format-error "Tab-to in pixel units not supported"))
    (%sp-write-string "                                                                                "
		  *standard-output*
		  0
		  (let ((position (charpos *standard-output*)))
		    (cond (position
			   (let ((tabcol (if atsign
					     (+ position colnum)
					     colnum)))
			     (min
			      (if (> position tabcol)
				  (- colinc (rem (- position tabcol) colinc))
				  (- tabcol position))
			      80)))
			  (atsign colnum)
			  (t 2))))))

;;; Ascii  ~A

(defun format-princ (colon atsign parms)
  (let ((arg (pop-format-arg)))
    (if (null parms)
	(if arg (princ arg) (write-string (if colon "()" "NIL")))
	(with-format-parameters parms
	   ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
	   (format-write-field (if arg
				   (princ-to-string arg)
				   (if colon "()" "NIL"))
			       mincol colinc minpad padchar atsign)))))



;;; S-expression  ~S
	    
(defun format-prin1 (colon atsign parms)
  (let ((arg (pop-format-arg)))
    (if (null parms)
	(if arg (prin1 arg) (write-string (if colon "()" "NIL")))
	(with-format-parameters parms
	   ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
	   (format-write-field (if arg
				   (prin1-to-string arg)
				   (if colon "()" "NIL"))
			       mincol colinc minpad padchar atsign)))))



;;; Character  ~C

(defun format-print-character (colon atsign parms)
  (with-format-parameters parms ()
    (let ((char (pop-format-arg)))
      (unless (characterp char)
	(format-error "Argument must be a character"))
      (cond ((and atsign (not colon)) (prin1 char))
	    (t (format-print-named-character char colon))))))


(defun format-print-named-character (char longp)
  (write-string
   (cond ((char-bit char :control)
	  (if longp "Control-" "C-"))
	 ((char-bit char :meta)
	  (if longp "Meta-" "M-"))
	 ((char-bit char :super)
	  (if longp "Super-" "S-"))
	 ((char-bit char :hyper)
	  (if longp "Hyper-" "H-"))
	 (t "")))
  (let* ((ch (code-char (char-code char)))	;strip funny bits
	 (name (char-name ch)))
    (cond (name (write-string (string-capitalize name)))
	  ;; Print control characters as "^"<char>
	  ((<= 0 (char-code char) 31)
	   (write-char #\^)
	   (write-char (code-char (+ 64 (char-code char)))))
	  (t (write-char ch)))))
	  



;;; NUMERIC PRINTING


;;; Insert commas after every third digit, scanning from right to left.

(defun format-add-commas (string commachar)
  (do* ((length (length (the string string)))
	(new-length (+ length (floor (1- length) 3))) 
	(new-string (make-string new-length :initial-element commachar) 
		    (replace (the string new-string)
			     (the string string)
			     :start1 (max 0 (- new-pos 3))
			     :end1 new-pos
			     :start2 (max 0 (- pos 3))
			     :end2 pos))
	(pos length  (- pos 3))
	(new-pos new-length (- new-pos 4)))
       ((not (plusp pos)) new-string)))


;;; Output a string in a field at MINCOL wide, padding with PADCHAR.
;;; Pads on the left if PADLEFT is true, else on the right.  If the
;;; length of the string plus the minimum permissible padding, MINPAD,
;;; is greater than MINCOL, the actual field size is rounded up to
;;; MINCOL + k * COLINC for the smallest possible positive integer k.

(defun format-write-field (string mincol colinc minpad padchar padleft)
  (unless (and (integerp mincol) (not (minusp mincol)))
    (format-error "Mincol must be a non-negative integer - ~S" mincol))
  (unless (and (integerp colinc) (plusp colinc))
    (format-error "Colinc must be a positive integer - ~S" colinc))
  (unless (and (integerp minpad) (not (minusp minpad)))
    (format-error "Minpad must be a non-negative integer - ~S" minpad))
  (unless (characterp padchar)
    (format-error "Padchar must be a character - ~S" padchar))
  (let* ((strlen (length (the string string)))
	 (width (format-round-columns (+ strlen minpad) mincol colinc)))
    (cond (padleft
	   (dotimes (i (- width strlen)) (write-char padchar))
	   (write-string string))
	  (t
	   (write-string string)
	   (dotimes (i (- width strlen)) (write-char padchar))))))


;;; This functions does most of the work for the numeric printing
;;; directives.  The parameters are interpreted as defined for ~D.

(defun format-print-number (number radix print-commas-p print-sign-p parms)
  (with-format-parameters parms
    ((mincol 0) (padchar #\space) (commachar #\,))
    (let* ((*print-base* radix)
	   (text (princ-to-string number)))
      (if (integerp number)
	  (format-write-field
	   (if (and (plusp number) print-sign-p)
	       (if print-commas-p
		   (concatenate 'string "+" (format-add-commas text commachar))
		   (concatenate 'string "+" text))
	       (if print-commas-p
		   (format-add-commas text commachar)
		   text))
	   mincol 1 0 padchar t)	;colinc = 1, minpad = 0, padleft = t
	  (write-string text)))))


;;; Print a cardinal number in English

(defvar cardinal-ones 
  '#(nil "one" "two" "three" "four" "five" "six" "seven" "eight" "nine")
  "Table of cardinal ones-place digits in English")

(defvar cardinal-tens
  '#(nil nil "twenty" "thirty" "forty" "fifty" "sixty" "seventy"
	 "eighty" "ninety")
  "Table of cardinal tens-place digits in English")

(defvar cardinal-teens
  '#("ten" "eleven" "twelve" "thirteen" "fourteen"
	   "fifteen" "sixteen" "seventeen" "eighteen" "nineteen")
  "Table of cardinal 'teens' digits in English")


(defun format-print-small-cardinal (n)
  (multiple-value-bind 
   (hundreds rem) (truncate n 100)
    (when (plusp hundreds)
      (write-string (svref cardinal-ones hundreds))
      (write-string " hundred")
      (when (plusp rem) (write-char #\space)))
    (when (plusp rem)
      (multiple-value-bind 
       (tens ones) (truncate rem 10)
       (cond ((< 1 tens)
	      (write-string (svref cardinal-tens tens))
	      (when (plusp ones)
		(write-char #\-)
		(write-string (svref cardinal-ones ones))))
	     ((= tens 1)
	      (write-string (svref cardinal-teens ones)))
	     ((plusp ones)
	      (write-string (svref cardinal-ones ones))))))))

(defconstant cardinal-periods
  '#("" " thousand" " million" " billion" " trillion" " quadrillion"
	" quintillion" " sextillion" " septillion" " octillion" " nonillion"
	" decillion" " undecillion" " duodecillion" " tredecillion"
        " quattuordecillion" " quindecillion" " sexdecillion"
	" septendecillion" " octodecillion" " novemdecillion"
	" vigintillion")
  "Table of cardinal 'illions' in English")

(defun format-print-cardinal (n)
  (cond ((minusp n)
	 (write-string "negative ")
	 (format-print-cardinal-aux (- n) 0 n))
	((zerop n)
	 (write-string "zero"))
	(t (format-print-cardinal-aux n 0 n))))

(defun format-print-cardinal-aux (n period err)
  (multiple-value-bind (beyond here) (truncate n 1000)
    (unless (<= period 21)
      (format-error "Number too large to print in English: ~:D" err))
    (unless (zerop beyond)
      (format-print-cardinal-aux beyond (1+ period) err))
    (unless (zerop here)
      (unless (zerop beyond) (write-char #\space))
      (format-print-small-cardinal here)
      (write-string (svref cardinal-periods period)))))


;;; Print an ordinal number in English


(defvar ordinal-ones
  '#(nil "first" "second" "third" "fourth" "fifth" "sixth"
	 "seventh" "eighth" "ninth")
  "Table of ordinal ones-place digits in English")

(defvar ordinal-tens
  '#(nil "tenth" "twentieth" "thirtieth" "fortieth"
	 "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth")
  "Table of ordinal tens-place digits in English")


(defun format-print-ordinal (n)
  (when (minusp n)
    (write-string "negative "))
  (let ((number (abs n)))
    (multiple-value-bind
     (top bot) (truncate number 100)
     (unless (zerop top) (format-print-cardinal (* 100 top)))
     (when (and (plusp top) (plusp bot)) (write-char #\space))
     (multiple-value-bind
      (tens ones) (truncate bot 10)
      (cond ((= bot 12) (write-string "twelfth"))
	    ((= tens 1)
	     (write-string (svref cardinal-teens ones))
	     (write-string "th"))
	    ((and (zerop tens) (plusp ones))
	     (write-string (svref ordinal-ones ones)))
	    ((and (zerop ones)(plusp tens))
	     (write-string (svref ordinal-tens tens)))
	    ((plusp bot)
	     (write-string (svref cardinal-tens tens))
	     (write-char #\-)
	     (write-string (svref ordinal-ones ones)))
	    ((plusp number) (write-string "th"))
	    (t (write-string "zeroeth")))))))


;;; Print Roman numerals

(defun format-print-old-roman (n)
  (unless (< 0 n 5000)
    (format-error "Number too large to print in old Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (start n (do ((i start (progn (write-char cur-char) (- i cur-val))))
		    ((< i cur-val) i))))
      ((zerop start))))


(defun format-print-roman (n)
  (unless (< 0 n 4000)
    (format-error "Number too large to print in Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (sub-chars '(#\C #\X #\X #\I #\I) (cdr sub-chars))
       (sub-val '(100 10 10 1 1 0) (cdr sub-val))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (cur-sub-char #\C (car sub-chars))
       (cur-sub-val 100 (car sub-val))
       (start n (do ((i start (progn (write-char cur-char) (- i cur-val))))
		    ((< i cur-val)
		     (cond ((<= (- cur-val cur-sub-val) i)
			    (write-char cur-sub-char)
			    (write-char cur-char)
			    (- i (- cur-val cur-sub-val)))
			   (t i))))))
	  ((zerop start))))



;;; Decimal  ~D

(defun format-print-decimal (colon atsign parms)
  (format-print-number (pop-format-arg) 10 colon atsign parms))


;;; Binary  ~B

(defun format-print-binary (colon atsign parms)
  (format-print-number (pop-format-arg) 2 colon atsign parms))


;;; Octal  ~O

(defun format-print-octal (colon atsign parms)
  (format-print-number (pop-format-arg) 8 colon atsign parms))


;;; Hexadecimal  ~X

(defun format-print-hexadecimal (colon atsign parms)
  (format-print-number (pop-format-arg) 16 colon atsign parms))


;;; Radix  ~R

(defun format-print-radix (colon atsign parms)
  (let ((number (pop-format-arg)))
    (if parms
	(format-print-number number (pop parms) colon atsign parms)
	(if atsign
	    (if colon
		(format-print-old-roman number)
		(format-print-roman number))
	    (if colon
		(format-print-ordinal number)
		(format-print-cardinal number))))))


;;; FLOATING-POINT NUMBERS


;;; Fixed-format floating point  ~F

(defun format-fixed (colon atsign parms)
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms
    ((w nil) (d nil) (k nil) (ovf nil) (pad #\space))
    ;;Note that the scale factor k defaults to nil.  This is interpreted as
    ;;zero by flonum-to-string, but more efficiently.
    (let ((number (pop-format-arg)))
      (if (floatp number)
	  (format-fixed-aux number w d k ovf pad atsign)
	  (if (rationalp number)
	      (format-fixed-aux
	       (coerce number 'short-float) w d k ovf pad atsign)
	      (let ((*print-base* 10))
		(format-write-field
		 (princ-to-string number) w 1 0 #\space t)))))))


(defun format-fixed-aux (number w d k ovf pad atsign)
  (if (not (or w d))
      (prin1 number)
      (let ((spaceleft w))
	(when (and w (or atsign (minusp number))) (decf spaceleft))
	(multiple-value-bind 
          (str len lpoint tpoint)
	  (flonum-to-string (abs number) spaceleft d k)
	  ;;if caller specifically requested no fraction digits, suppress the
	  ;;optional trailing zero
	  (when (and d (zerop d)) (setq tpoint nil))
	  (when w 
	    (decf spaceleft len)
	    ;;optional leading zero
	    (when lpoint
	      (if (or (> spaceleft 0) tpoint) ;force at least one digit
		  (decf spaceleft)
		  (setq lpoint nil)))
	    ;;optional trailing zero
	    (when tpoint
	      (if (> spaceleft 0)
		  (decf spaceleft)
		  (setq tpoint nil))))
	  (cond ((and w (< spaceleft 0) ovf)
		 ;;field width overflow
		 (dotimes (i w) (write-char ovf)))
		(t (when w (dotimes (i spaceleft) (write-char pad)))
		   (if (minusp number)
		       (write-char #\-)
		       (if atsign (write-char #\+)))
		   (when lpoint (write-char #\0))
		   (write-string str)
		   (when tpoint (write-char #\0))))))))


;;; Exponential-format floating point  ~E


(defun format-exponential (colon atsign parms)
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms
    ((w nil) (d nil) (e nil) (k 1) (ovf nil) (pad #\space) (marker nil))
    (let ((number (pop-format-arg)))
      (if (floatp number)
	  (format-exp-aux number w d e k ovf pad marker atsign)
	  (if (rationalp number)
	      (format-exp-aux
	       (coerce number 'short-float) w d e k ovf pad marker atsign)
	      (let ((*print-base* 10))
		(format-write-field
		 (princ-to-string number) w 1 0 #\space t)))))))


(defun format-exponent-marker (number)
  (if (typep number *read-default-float-format*)
      #\E
      (typecase number
	(short-float #\S)
	(single-float #\F)
	(double-float #\D)
	(long-float #\L))))


;;;Here we prevent the scale factor from shifting all significance out of
;;;a number to the right.  We allow insignificant zeroes to be shifted in
;;;to the left right, athough it is an error to specify k and d such that this
;;;occurs.  Perhaps we should detect both these condtions and flag them as
;;;errors.  As for now, we let the user get away with it, and merely guarantee
;;;that at least one significant digit will appear.

(defun format-exp-aux (number w d e k ovf pad marker atsign)
  (if (not (or w d))
      (prin1 number)
      (multiple-value-bind (num expt)
			   (scale-exponent (abs number))
	(let* ((expt (- expt k))
	       (estr (princ-to-string (abs expt)))
	       (elen (if e (max (length estr) e) (length estr)))
	       (fdig (if d (if (plusp k) (1+ (- d k)) d) nil))
	       (fmin (if (minusp k) (- 1 k) nil))
	       (spaceleft (if w (- w 2 elen) nil)))
	  (when (or atsign (minusp number)) (decf spaceleft))
	  (if (and w e ovf (> elen e))
	      ;;exponent overflow
	      (dotimes (i w) (write-char ovf))
	      (multiple-value-bind
                (fstr flen lpoint tpoint)
		(flonum-to-string num spaceleft fdig k fmin)
		(declare (ignore tpoint))
		(when w 
		  (decf spaceleft flen)
		  (when lpoint
		    (if (> spaceleft 0)
			(decf spaceleft)
			(setq lpoint nil))))
		(cond ((and w (< spaceleft 0) ovf)
		       ;;significand overflow
		       (dotimes (i w) (write-char ovf)))
		      (t (when w
			   (dotimes (i spaceleft) (write-char pad)))
			 (if (minusp number)
			     (write-char #\-)
			     (if atsign (write-char #\+)))
			 (when lpoint (write-char #\0))
			 (write-string fstr)
			 (write-char (if marker
					 marker
					 (format-exponent-marker number)))
			 (write-char (if (minusp expt) #\- #\+))
			 (when e 
			   ;;zero-fill before exponent if necessary
			   (dotimes (i (- e (length estr))) (write-char #\0)))
			 (write-string estr)))))))))



;;; General Floating Point -  ~G

(defun format-general-float (colon atsign parms)
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms
    ((w nil) (d nil) (e nil) (k nil) (ovf #\*) (pad #\space) (marker nil))
    (let ((number (pop-format-arg)))
      ;;The Excelsior edition does not say what to do if
      ;;the argument is not a float.  Here, we adopt the
      ;;conventions used by ~F and ~E.
      (if (floatp number)
	  (format-general-aux number w d e k ovf pad marker atsign)
	  (if (rationalp number)
	      (format-general-aux
	       (coerce number 'short-float) w d e k ovf pad marker atsign)
	      (let ((*print-base* 10))
		(format-write-field
		 (princ-to-string number) w 1 0 #\space t)))))))


(defun format-general-aux (number w d e k ovf pad marker atsign)
  (multiple-value-bind (ignore n) 
		       (scale-exponent (abs number))
    (declare (ignore ignore))
    ;;Default d if omitted.  The procedure is taken directly
    ;;from the definition given in the manual, and is not
    ;;very efficient, since we generate the digits twice.
    ;;Future maintainers are encouraged to improve on this.
    (unless d
      (multiple-value-bind (str len) 
			   (flonum-to-string (abs number))
	(declare (ignore str))
	(let ((q (if (= len 1) 1 (1- len))))
	  (setq d (max q (min n 7))))))
    (let* ((ee (if e (+ e 2) 4))
	   (ww (if w (- w ee) nil))
	   (dd (- d n)))
      (cond ((<= 0 dd d)
	     (format-fixed-aux number ww dd nil ovf pad atsign)
	     (dotimes (i ee) (write-char #\space)))
	    (t (format-exp-aux 
		 number w d e (or k 1) ovf pad marker atsign))))))


;;; Dollars floating-point format  ~$

(defun format-dollars (colon atsign parms)
  (with-format-parameters parms ((d 2) (n 1) (w 0) (pad #\space))
    (let ((number (pop-format-arg)))
      (if (rationalp number)
	  (setq number (coerce number 'short-float)))
      (if (floatp number)
	  (let* ((signstr (if (minusp number) "-" (if atsign "+" "")))
		 (signlen (length signstr)))
	    (multiple-value-bind (str strlen ig2 ig3 pointplace)
				 (flonum-to-string number nil d nil)
	      (declare (ignore ig2 ig3))
	      (when colon (write-string signstr))
	      (dotimes (i (- w signlen (- n pointplace) strlen))
		(write-char pad))
	      (unless colon (write-string signstr))
	      (dotimes (i (- n pointplace)) (write-char #\0))
	      (write-string str)))
	  (let ((*print-base* 10))
	    (format-write-field (princ-to-string number) w 1 0 #\space t))))))



;;; INITIALIZATION


;;; Hairy dispatch-table initialization macro.  Takes a list of two-element
;;; lists (<character> <function-object>) and returns a vector char-code-limit
;;; elements in length, where the Ith element is the function associated with
;;; the character with char-code I.  If the character is case-convertible, it
;;; must be given in only one case; however, an entry in the vector will be
;;; made for both.


(defmacro make-dispatch-vector (&body entries)
  (let ((entries (mapcan #'(lambda (x)
			     (let ((lower (char-downcase (car x)))
				   (upper (char-upcase (car x))))
			       (if (char= lower upper)
				   (list x)
				   (list (cons upper (cdr x))
					 (cons lower (cdr x))))))
			 entries)))
    (do ((entries (sort entries #'(lambda (x y) (char< (car x) (car y)))))
	 (charidx 0 (1+ charidx))
	 (comtab () (cons (if entries
			      (if (= (char-code (caar entries)) charidx)
				  (cadr (pop entries))
				  nil)
			      nil)
			  comtab)))
	((= charidx char-code-limit)
	 (if entries
	     (error "Garbage in dispatch vector - ~S" entries))
	 `(vector ,@(nreverse comtab))))))


(defun format-init ()
  (setq *format-dispatch-table*
	(make-dispatch-vector
	 (#\B #'format-print-binary)
	 (#\O #'format-print-octal)
	 (#\D #'format-print-decimal)
	 (#\X #'format-print-hexadecimal)
	 (#\R #'format-print-radix)
	 (#\F #'format-fixed)
	 (#\E #'format-exponential)
         (#\G #'format-general-float)
	 (#\A #'format-princ)
	 (#\C #'format-print-character)
	 (#\P #'format-plural)
	 (#\S #'format-prin1)
	 (#\T #'format-tab)
	 (#\% #'format-terpri)
	 (#\& #'format-freshline)
	 (#\* #'format-skip-arguments)
	 (#\| #'format-page)
	 (#\~ #'format-tilde)
	 (#\$ #'format-dollars)
	 (#\? #'format-indirection)
	 (#\^ #'format-escape)
	 (#\[ #'format-condition)
	 (#\{ #'format-iteration)
	 (#\< #'format-justification)
	 (#\( #'format-capitalization)
	 (#\newline #'format-newline))))
